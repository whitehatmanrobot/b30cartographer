 IDS_PROBLEM_FINDING_SERVER_TITLE, 
                            IDS_PROBLEM_FINDING_SERVER_CONFIRM_TEXT, 
                            MB_YESNO|MB_ICONWARNING );
    hr = (retVal == IDYES)?S_OK:E_ADS_BAD_PARAMETER;


    HRETURN(hr);
}


HRESULT
THISCLASS::_OnSearch(
    HWND hDlg )
{
    TraceClsFunc( "_OnSearch( )\n" );

    HRESULT hr = E_FAIL;
    DSQUERYINITPARAMS dqip;
    OPENQUERYWINDOW   oqw;
    LPDSOBJECTNAMES   pDsObjects;
    VARIANT var;
    ICommonQuery * pCommonQuery = NULL;
    IDataObject *pdo;

    VariantInit( &var );

    hr = THR( CoCreateInstance( CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_ICommonQuery, (PVOID *)&pCommonQuery) );
    if (hr)
        goto Error;

    ZeroMemory( &dqip, sizeof(dqip) );
    dqip.cbStruct = sizeof(dqip);
    dqip.dwFlags  = DSQPF_NOSAVE | DSQPF_SHOWHIDDENOBJECTS | DSQPF_ENABLEADMINFEATURES;
    dqip.dwFlags  |= DSQPF_ENABLEADVANCEDFEATURES;

    ZeroMemory( &oqw, sizeof(oqw) );
    oqw.cbStruct           = sizeof(oqw);
    oqw.dwFlags            = OQWF_SHOWOPTIONAL | OQWF_ISSUEONOPEN
                           | OQWF_REMOVESCOPES | OQWF_REMOVEFORMS
                           | OQWF_DEFAULTFORM | OQWF_OKCANCEL | OQWF_SINGLESELECT;
    oqw.clsidHandler       = CLSID_DsQuery;
    oqw.pHandlerParameters = &dqip;
    oqw.clsidDefaultForm   = CLSID_RISrvQueryForm;
    
    hr = pCommonQuery->OpenQueryWindow( hDlg, &oqw, &pdo);

    if ( SUCCEEDED(hr) && pdo) {
        FORMATETC fmte = {
                      (CLIPFORMAT)g_cfDsObjectNames,
                      NULL,
                      DVASPECT_CONTENT, 
                      -1, 
                      TYMED_HGLOBAL};
        STGMEDIUM medium = { TYMED_HGLOBAL, NULL, NULL };
 
        //
        // Retrieve the result from the IDataObject, 
        // in this case CF_DSOBJECTNAMES (dsclient.h) 
        // is needed because it describes 
        // the objects which were selected by the user.
        //
        hr = pdo->GetData(&fmte, &medium);
        if ( SUCCEEDED(hr) ) {
            DSOBJECTNAMES *pdon = (DSOBJECTNAMES*)GlobalLock(medium.hGlobal);
            PWSTR p,FQDN;

            //
            // we want the name of the computer object that was selected.
            // crack the DSOBJECTNAMES structure to get this data, 
            // convert it into a version that the user can view, and set the
            // dialog text to this data.
            //
            if ( pdon ) {
                Assert( pdon->cItems == 1);
                p = (PWSTR)((ULONG_PTR)pdon + (ULONG_PTR)pdon->aObjects[0].offsetName);
                if (p && (p = wcsstr(p, L"LDAP://"))) {
                    p += 6;
                    if ((p = wcsstr(p, L"/CN="))) {
                        p += 1;
                        hr = DNtoFQDN( p, &FQDN);

                        if (SUCCEEDED(hr)) {
                            SetDlgItemText( hDlg, IDC_E_SERVER, FQDN );
                            TraceFree( FQDN );
                        }
                    }
                }
                GlobalUnlock(medium.hGlobal);
            }
        }

        ReleaseStgMedium(&medium);
        pdo->Release();
    }

Error:
    
    if ( pCommonQuery )
        pCommonQuery->Release();

    if (FAILED(hr)) {
        MessageBoxFromStrings( 
                        hDlg, 
                        IDS_PROBLEM_SEARCHING_TITLE, 
                        IDS_PROBLEM_SEARCHING_TEXT, 
                        MB_ICONEXCLAMATION );
    }

    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\imos.h ===
//
// Copyright 1997 - Microsoft

//
// CLIENT.H - Handles the "IntelliMirror" IDD_PROP_INTELLIMIRROR_CLIENT tab
//


#ifndef _IMOS_H_
#define _IMOS_H_

// Definitions
LPVOID
CIntelliMirrorOSTab_CreateInstance( void );

class CComputer;
typedef CComputer* LPCComputer;

// CIntelliMirrorOSTab
class
CIntelliMirrorOSTab:
    public ITab
{
private:
    HWND  _hDlg;
    LPUNKNOWN _punkService;     // Pointer back to owner object

    BOOL    _fAdmin;
    LPWSTR  _pszDefault;        // default OS
    LPWSTR  _pszTimeout;        // timeout string

    // "Add Wizard" flags
    BOOL    _fAddSif:1;
    BOOL    _fNewImage:1;
    BOOL    _fRiPrep:1;

    HWND    _hNotify;           // DSA's notify object

private: // Methods
    CIntelliMirrorOSTab();
    ~CIntelliMirrorOSTab();
    STDMETHOD(Init)();

    // Property Sheet Functions
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    BOOL    _InitDialog( HWND hDlg, LPARAM lParam );
    BOOL    _OnCommand( WPARAM wParam, LPARAM lParam );
    INT     _OnNotify( WPARAM wParam, LPARAM lParam );
    HRESULT _OnSelectionChanged( );

public: // Methods
    friend LPVOID CIntelliMirrorOSTab_CreateInstance( void );

    // ITab
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                            LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(QueryInformation)( LPWSTR pszAttribute, LPWSTR * pszResult );
    STDMETHOD(AllowActivation)( BOOL * pfAllow );
};

typedef CIntelliMirrorOSTab* LPCIntelliMirrorOSTab;

#endif // _IMOS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\makefile.inc ===
$(O)\newclnts.obj: $(PROJECT_INC_PATH)\riname.h $(PROJECT_INC_PATH)\riname.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\itab.h ===
//
// Copyright 1997 - Microsoft

//
// ITAB.H - Generic property tab abstract class
//


#ifndef _ITAB_H_
#define _ITAB_H_

// ITab
class 
ITab
{
public: // Methods
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk ) PURE;
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
                            LPARAM lParam, LPUNKNOWN punk ) PURE;
    STDMETHOD(QueryInformation)( LPWSTR pszAttribute, LPWSTR * pszResult ) PURE;
    STDMETHOD(AllowActivation)( BOOL * pfAllow ) PURE;
};

typedef ITab* LPTAB;

#endif // _ITAB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\mangdlg.h ===
//
// Copyright 1997 - Microsoft

//
// MangDlg.H - Handles the IDD_MANAGED_WIZARD_PAGE
//


#ifndef _MANGDLG_H_
#define _MANGDLG_H_

class CNewComputerExtensions; // fwd decl

// Definitions
LPVOID
CManagedPage_CreateInstance( void );

// CManagedPage
class
CManagedPage:
    public ITab
{
private: // Members
    HWND  _hDlg;
    CNewComputerExtensions* _pNewComputerExtension;
    LPWSTR       _pszGuid;
    BOOL *       _pfActivate;

private: // Methods
    CManagedPage();
    ~CManagedPage();
    STDMETHOD(Init)();

    // Property Sheet Functions
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    static INT_PTR CALLBACK
        DupGuidDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    HRESULT _InitDialog( HWND hDlg, LPARAM lParam );
    INT     _OnCommand( WPARAM wParam, LPARAM lParam );
    INT     _OnNotify( WPARAM wParam, LPARAM lParam );
    HRESULT _OnPSPCB_Create( );
    HRESULT _UpdateWizardButtons( );
    HRESULT _OnKillActive( );
    HRESULT _OnQuery( HWND hDlg );

public: // Methods
    friend LPVOID CManagedPage_CreateInstance( void );

    // ITab
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                     LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(QueryInformation)( LPWSTR pszAttribute, LPWSTR * pszResult );
    STDMETHOD(AllowActivation)( BOOL * pfAllow );

    friend CNewComputerExtensions;
};

typedef CManagedPage* LPCManagedPage;

#endif // _MANGDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\imos.cpp ===
//
// Copyright 1997 - Microsoft

//
// IMOS.CPP - Handles the "IntelliMirror OS" IDD_PROP_INTELLIMIRROR_OS tab
//


#include "pch.h"

#include "utils.h"
#include "cservice.h"
#include "cenumsif.h"
#include "imos.h"
#include "ccomputr.h"
#include "addwiz.h"
#include "sifprop.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CIntelliMirrorOSTab")
#define THISCLASS CIntelliMirrorOSTab
#define LPTHISCLASS LPCIntelliMirrorOSTab

#define NUM_COLUMNS				    4

DWORD aImosHelpMap[] = {
    IDC_L_OS, HIDC_L_OS,
    IDC_B_ADD, HIDC_B_ADD,
    IDC_B_REMOVE, HIDC_B_REMOVE,
    IDC_B_PROPERTIES, HIDC_B_PROPERTIES,
    IDC_B_REFRESH, HIDC_B_REFRESH,
    NULL, NULL
};

//
// CreateInstance()
//
LPVOID
CIntelliMirrorOSTab_CreateInstance( void )
{
	TraceFunc( "CIntelliMirrorOSTab_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CIntelliMirrorOSTab()\n" );

	InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CIntelliMirrorOSTab()\n" );

    if ( _punkService )
        _punkService->Release( );

    // tell ADS to destroy the notify object
    // NOTE: Another property page may do this before us. Ignore errors.
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_EXIT, 0, 0 );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// *************************************************************************
//
// ITab
//
// *************************************************************************

STDMETHODIMP
THISCLASS::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam,
    LPUNKNOWN punk )
{
    TraceClsFunc( "AddPages( )\n" );

    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
    psp.hInstance   = (HINSTANCE) g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP_INTELLIMIRROR_OS);
    psp.pcRefParent = (UINT *) &g_cObjects;
    psp.pfnCallback = (LPFNPSPCALLBACK) PropSheetPageProc;
    psp.pfnDlgProc  = PropSheetDlgProc;
    psp.lParam      = (LPARAM) this;

    hpage = CreatePropertySheetPage( &psp );
    if ( hpage )
    {
        if ( !lpfnAddPage( hpage, lParam ) )
        {
            DestroyPropertySheetPage( hpage );
            hr = THR(E_FAIL);
            goto Error;
        }
    }

    punk->AddRef( );   // matching Release in the destructor
    _punkService = punk;

Error:
    HRETURN(hr);
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam,
    LPUNKNOWN punk )
{

    TraceClsFunc( "ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    HRETURN(E_NOTIMPL);
}

//
// QueryInformation( )
//
STDMETHODIMP
THISCLASS::QueryInformation(
    LPWSTR pszAttribute,
    LPWSTR * pszResult )
{
    TraceClsFunc( "QueryInformation( )\n" );

    HRETURN(E_NOTIMPL);
}

//
// AllowActivation( )
//
STDMETHODIMP
THISCLASS::AllowActivation(
    BOOL * pfAllow )
{
    TraceClsFunc( "AllowActivation( )\n" );

    HRETURN(E_NOTIMPL);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************


//
// _InitDialog( )
//
BOOL
THISCLASS::_InitDialog(
    HWND hDlg,
    LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    CWaitCursor Wait;
    
    HRESULT hr = S_OK;
    HWND hwndList = GetDlgItem( hDlg, IDC_L_OS );

    LPUNKNOWN punk = NULL;
    IIntelliMirrorSAP * pimsap = NULL;
    IEnumIMSIFs * penum = NULL;
    LV_COLUMN lvC;
    INT iCount;
    WCHAR szText[ 64 ];
    UINT uColumnWidths[NUM_COLUMNS] = { 225, 75, 75, 75 };

    if ( hDlg )
    {
        _hDlg = hDlg;
    }

    Assert( _punkService );
    hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
    if (hr) {
        Assert( _fAdmin == FALSE );
        goto Error;
    }

    hr = THR( pimsap->GetNotifyWindow( &_hNotify ) );
    if (FAILED( hr ))
        goto Error;
    
    ADsPropSetHwnd( _hNotify, _hDlg );

    hr = THR( pimsap->EnumIntelliMirrorOSes( ENUM_READ, &punk ) );
    if (hr)
    {
        Assert( _fAdmin == FALSE );
        goto Error;
    }

    hr = THR( punk->QueryInterface( IID_IEnumIMSIFs, (void**)&penum ) );
    if (hr)
    {
        Assert( _fAdmin == FALSE );
        goto Error;
    }

    punk->Release( );
    punk = NULL;

    ListView_DeleteAllItems( hwndList );

    // Create the columns
    lvC.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt     = LVCFMT_LEFT;
    lvC.pszText = szText;

    // Add the columns.
    for ( iCount = 0; iCount < NUM_COLUMNS; iCount++ )
    {
        INT i;

        lvC.iSubItem = iCount;
        lvC.cx       = uColumnWidths[iCount];

        i = LoadString( g_hInstance, IDS_OS_COLUMN1 + iCount, szText, ARRAYSIZE (szText) );
        Assert( i );

        i = ListView_InsertColumn ( hwndList, iCount, &lvC );
        Assert( i != -1 );
    }

    hr = PopulateListView( hwndList, penum );
    if(FAILED(hr))
    {
        MessageBoxFromStrings( _hDlg,
                               IDS_COULDNOTCONTACTSERVER_CAPTION,
                               IDS_COULDNOTCONTACTSERVER_TEXT,
                               MB_OK | MB_ICONERROR );
    }

    hr = THR( pimsap->IsAdmin( &_fAdmin ) );
    if (hr) {
        Assert( _fAdmin == FALSE );
    }

Cleanup:
    if ( penum )
        penum->Release( );
    if ( pimsap )
        pimsap->Release( );
    if ( punk )
        punk->Release( );

    EnableWindow( hwndList, _fAdmin );

    HRETURN(hr);

Error:
    switch (hr) {
    case S_OK:
        break;
    default:
        MessageBoxFromHResult( NULL, IDS_ERROR_OPENNINGGROUPOBJECT, hr );
        break;
    }
    goto Cleanup;
}

//
// _OnSelectionChanged( )
//
HRESULT
THISCLASS::_OnSelectionChanged( )
{
    TraceClsFunc( "_OnSelectionChanged( )\n" );

    HRESULT hr = S_OK;
    UINT iItems = ListView_GetSelectedCount( GetDlgItem( _hDlg, IDC_L_OS ) );
    EnableWindow( GetDlgItem( _hDlg, IDC_B_REMOVE ), !!iItems );
    EnableWindow( GetDlgItem( _hDlg, IDC_B_PROPERTIES ), !!iItems );
    //EnableWindow( GetDlgItem( _hDlg, IDC_B_ADD ), !!iItems  );

    HRETURN( hr );
}

//
// _OnCommand( )
//
BOOL
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    HRESULT hr = S_FALSE;
    HWND hwndCtl = (HWND) lParam;

    switch( LOWORD(wParam) )
    {
    case IDC_B_PROPERTIES:
        if ( HIWORD( wParam ) == BN_CLICKED ) {
            LVITEM lvi;
            HWND hwndList = GetDlgItem( _hDlg, IDC_L_OS );
            lvi.iItem = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );

            if ( lvi.iItem != -1 )
            {
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( hwndList, &lvi );

                Assert(lvi.lParam);
                hr = CSifProperties_CreateInstance( _hDlg, MAKEINTRESOURCE(IDD_SIF_PROP_IMAGES), (LPSIFINFO) lvi.lParam );
            }
        }
        break;

    case IDC_B_REFRESH:
        hr = S_OK;
        break;

    case IDC_B_REMOVE:
        if ( HIWORD( wParam ) == BN_CLICKED ) {
            LVITEM lvi;
            UINT iResult;
            HWND hwndList = GetDlgItem( _hDlg, IDC_L_OS );
            lvi.iItem = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );

            iResult = MessageBoxFromStrings( _hDlg, IDS_AREYOUSURE_CAPTION, IDS_DELETESIF_TEXT, MB_YESNO );
            if ( iResult == IDYES )
            {
                if ( lvi.iItem != -1 )
                {
                    HRESULT hr;
                    LPSIFINFO psif;

                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem( hwndList, &lvi );

                    psif = (LPSIFINFO)lvi.lParam;

                    if ( !DeleteFile( psif->pszFilePath ) )
                    {
                        ::MessageBoxFromError( _hDlg, 0, GetLastError() );
                        hr = E_FAIL;
                    } else {
                        ListView_DeleteItem( hwndList, lvi.iItem );
                        hr = S_FALSE;
                    }
                }
            }
        }
        break;

    case IDC_B_ADD:
        if ( HIWORD( wParam ) == BN_CLICKED ) {
            hr = CAddWiz_CreateInstance( _hDlg, _punkService );
        }
        break;
    }

    if ( hr == S_OK )
    {
        HWND hwndList = GetDlgItem(_hDlg, IDC_L_OS);
        IIntelliMirrorSAP * pimsap = NULL;
        hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
        if (hr == S_OK)
        {
            IEnumIMSIFs * penum = NULL;
            hr = THR( pimsap->EnumIntelliMirrorOSes( ENUM_READ, (LPUNKNOWN*)&penum ) );
            if ( hr == S_OK )
            {
                hr = PopulateListView( hwndList, penum);
                penum->Release();
            }
            pimsap->Release();
        }

        // See if we still have a selection
        _OnSelectionChanged( );
    }

    HRETURN(hr);
}

//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;

    switch( lpnmhdr->code )
    {
    case PSN_APPLY:
        TraceMsg( TF_WM, TEXT("WM_NOTIFY: PSN_APPLY\n"));
        // Tell DSA that someone hit Apply
        SendMessage( _hNotify, WM_ADSPROP_NOTIFY_APPLY, 0, 0 );
        SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
        RETURN(TRUE);

    case LVN_ITEMCHANGED:
        {
            _OnSelectionChanged( );
        }
        break;

    case LVN_DELETEALLITEMS:
        DebugMsg( "LVN_DELETEALLITEMS - Deleting all items.\n" );
        RETURN(FALSE);

    case LVN_DELETEITEM:
        {
            LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;
            LPSIFINFO psif = (LPSIFINFO) pnmv->lParam;
            Assert( psif );

            if ( psif )
            {
                TraceFree( psif->pszArchitecture );
                TraceFree( psif->pszDescription );
                TraceFree( psif->pszDirectory );
                TraceFree( psif->pszFilePath );
                TraceFree( psif->pszHelpText );
                TraceFree( psif->pszImageType );
                TraceFree( psif->pszLanguage );
                TraceFree( psif->pszVersion );
                TraceFree( psif->pszImageFile );
                TraceFree( psif );
            }
        }
        break;

    default:
        break;
    }

    RETURN(FALSE);
}

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, psp->lParam );
        pcc = (LPTHISCLASS) psp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc)
    {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg )
        {
        case WM_NOTIFY:
            return pcc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, "WM_COMMAND\n" );
            return pcc->_OnCommand( wParam, lParam );
            break;

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aImosHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aImosHelpMap );
            break;

        case WM_ADSPROP_PAGE_GET_NOTIFY:
            {
                HWND *phwnd = (HWND *) wParam;
                *phwnd = pcc->_hNotify;
            }
            return TRUE;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
UINT CALLBACK
THISCLASS::PropSheetPageProc(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp )
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("hwnd = 0x%08x, uMsg = 0x%08x, ppsp= 0x%08x )\n"),
        hwnd, uMsg, ppsp );

    switch ( uMsg )
    {
    case PSPCB_CREATE:
        RETURN(TRUE);   // create it
        break;

    case PSPCB_RELEASE:
        LPTHISCLASS pcc = (LPTHISCLASS) ppsp->lParam;
        delete pcc;
        break;
    }

    RETURN(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\mangdlg.cpp ===
//
// Copyright 1997 - Microsoft

//
// MangDlg.CPP - Handles the IDD_MANAGED_WIZARD_PAGE
//

#include "pch.h"
#include "mangdlg.h"
#include "utils.h"
#include "newcmptr.h"
#include "dpguidqy.h"
#include "querypb.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CManagedPage")
#define THISCLASS CManagedPage
#define LPTHISCLASS LPCManagedPage

DWORD aManagedHelpMap[] = {
    IDC_E_GUID, HIDC_E_GUID,
    IDC_C_MANAGED_PC, HIDC_C_MANAGED_PC,
    NULL, NULL
};

//
// CreateInstance()
//
LPVOID
CManagedPage_CreateInstance( void )
{
	TraceFunc( "CManagedPage_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CManagedPage()\n" );

	InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    Assert( !_pNewComputerExtension );
    Assert( !_pszGuid );
    Assert( !_pfActivate );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CManagedPage()\n" );

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// *************************************************************************
//
// ITab
//
// *************************************************************************

STDMETHODIMP
THISCLASS::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam,
    LPUNKNOWN punk )
{
    TraceClsFunc( "AddPages( )\n" );

    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    Assert( lpfnAddPage );
    if ( !lpfnAddPage )
        HRETURN(E_INVALIDARG);

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT | PSP_USECALLBACK;
    psp.hInstance   = (HINSTANCE) g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_MANAGED_WIZARD_PAGE);
    psp.pcRefParent = (UINT *) &g_cObjects;
    psp.pfnCallback = (LPFNPSPCALLBACK) PropSheetPageProc;
    psp.pfnDlgProc  = PropSheetDlgProc;
    psp.lParam      = (LPARAM) this;

    hpage = CreatePropertySheetPage( &psp );
    if ( hpage )
    {
        if ( !lpfnAddPage( hpage, lParam ) )
        {
            DestroyPropertySheetPage( hpage );
            hr = THR(E_FAIL);
            goto Error;
        }
    }

Error:
    HRETURN(hr);
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam,
    LPUNKNOWN punk )
{

    TraceClsFunc( "ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    RETURN(E_NOTIMPL);
}

//
// QueryInformation( )
//
STDMETHODIMP
THISCLASS::QueryInformation(
    LPWSTR pszAttribute,
    LPWSTR * pszResult )
{
    TraceClsFunc( "QueryInformation( )\n" );

    if ( !pszResult )
        HRETURN(E_POINTER);

    if ( !pszAttribute )
        HRETURN(E_INVALIDARG);

    HRESULT hr = E_INVALIDARG;
    LRESULT lResult;

    *pszResult = NULL;

    lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_C_MANAGED_PC ) );
    if ( lResult )
    {
        if ( StrCmpI( pszAttribute, NETBOOTGUID ) == 0 )
        {
            HWND  hwndGuid = GetDlgItem( _hDlg, IDC_E_GUID );
            DWORD dw = Edit_GetTextLength( hwndGuid ) + 1;

            *pszResult = (LPWSTR) TraceAllocString( LMEM_FIXED, dw );
            if ( !*pszResult )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            Edit_GetText( hwndGuid, *pszResult, dw );

            hr = S_OK;
        }

        if ( StrCmpI( pszAttribute, L"Guid" ) == 0 )
        {
            HWND  hwndGuid = GetDlgItem( _hDlg, IDC_E_GUID );
            DWORD dw = Edit_GetTextLength( hwndGuid ) + 1;
            BYTE uGuid[16];
            LPWSTR pszTemp;

            pszTemp = (LPWSTR) TraceAllocString( LMEM_FIXED, dw );
            if ( !pszTemp )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            Edit_GetText( hwndGuid, pszTemp, dw );

            hr = ValidateGuid( pszTemp, uGuid, NULL );
            Assert( hr == S_OK );

            TraceFree( pszTemp );

            LPWSTR pszPrettyString = PrettyPrintGuid( uGuid );
            if ( !pszPrettyString )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            *pszResult = pszPrettyString;
            hr = S_OK;
        }
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    HRETURN(hr);
}

//
// AllowActivation( )
//
STDMETHODIMP
THISCLASS::AllowActivation(
    BOOL * pfAllow )
{
    TraceClsFunc( "AllowActivation( )\n" );

    _pfActivate = pfAllow;

    HRETURN(S_OK);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, psp->lParam );
        pcc = (LPTHISCLASS) psp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc)
    {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg )
        {
        case WM_NOTIFY:
            TraceMsg( TF_WM, TEXT("WM_NOTIFY\n") );
            return pcc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
            return pcc->_OnCommand( wParam, lParam );

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aManagedHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aManagedHelpMap );
            break;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
UINT CALLBACK
THISCLASS::PropSheetPageProc(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp )
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("hwnd = 0x%08x, uMsg = 0x%08x, ppsp= 0x%08x )\n"),
        hwnd, uMsg, ppsp );

    Assert( ppsp );
    LPTHISCLASS pcc = (LPTHISCLASS) ppsp->lParam;

    switch ( uMsg )
    {
    case PSPCB_CREATE:
        TraceMsg( TF_WM, "PSPCB_CREATE\n" );
        if ( S_OK == pcc->_OnPSPCB_Create( ) )
        {
            RETURN(TRUE);   // create it
        }
        break;

    case PSPCB_RELEASE:
        TraceMsg( TF_WM, "PSPCB_RELEASE\n" );
        delete pcc;
        break;
    }

    RETURN(FALSE);
}

//
// _OnPSPCB_Create( )
//
HRESULT
THISCLASS::_OnPSPCB_Create( )
{
    TraceClsFunc( "_OnPSPCB_Create( )\n" );

    return S_OK;

}

//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
    HWND hDlg,
    LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    _hDlg = hDlg;

    Assert( _pNewComputerExtension );
    SetWindowText( GetParent( _hDlg ), _pNewComputerExtension->_pszWizTitle );
    SetDlgItemText( _hDlg, IDC_S_CREATEIN, _pNewComputerExtension->_pszContDisplayName );
    SendMessage( GetDlgItem( _hDlg, IDC_S_ICON ), STM_SETICON, (WPARAM) _pNewComputerExtension->_hIcon, 0 );
    
    Edit_LimitText( GetDlgItem( _hDlg, IDC_E_GUID), MAX_INPUT_GUID_STRING - 1 );

    HRETURN(S_OK);
}


//
// _OnCommand( )
//
INT
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    switch ( LOWORD(wParam) )
    {
    case IDC_C_MANAGED_PC:
        if ( HIWORD(wParam) == BN_CLICKED )
        {
            LRESULT lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_C_MANAGED_PC ) );
            EnableWindow( GetDlgItem( _hDlg, IDC_E_GUID), (BOOL)lResult );
            _UpdateWizardButtons( );
        }
        break;

    case IDC_E_GUID:
        if ( HIWORD(wParam) == EN_CHANGE )
        {
            _UpdateWizardButtons( );
        }
        break;
    }

    RETURN(FALSE);
}

//
// _UpdateWizardButtons( )
//
HRESULT
THISCLASS::_UpdateWizardButtons( )
{
    TraceClsFunc( "_UpdateWizardButtons( )\n" );

    HRESULT hr = S_OK;

    LRESULT lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_C_MANAGED_PC ) );
    if ( lResult == BST_CHECKED )
    {
        WCHAR szGuid[ MAX_INPUT_GUID_STRING ];
        Edit_GetText( GetDlgItem( _hDlg, IDC_E_GUID ), szGuid, ARRAYSIZE(szGuid) );
        hr = ValidateGuid( szGuid, NULL, NULL );
        if ( hr != S_OK )
        {
            PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_BACK );
        }
        else
        {
            PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
        }
    }
    else
    {
        PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
    }

    HRETURN(hr);
}


//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;
    TraceMsg( TF_WM, "NMHDR:  HWND = 0x%08x, idFrom = 0x%08x, code = 0x%08x\n",
        lpnmhdr->hwndFrom, lpnmhdr->idFrom, lpnmhdr->code );

    switch( lpnmhdr->code )
    {
    case PSN_SETACTIVE:
        TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
        Assert( _pfActivate );
        *_pfActivate = FALSE;
        _UpdateWizardButtons( );
        break;

    case PSN_WIZNEXT:
        TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
        {
            HRESULT hr = _OnKillActive( );
            if (FAILED(hr))
            {
                SetFocus( GetDlgItem( _hDlg, IDC_E_GUID ) );
                SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, -1 ); // don't continue
                RETURN(TRUE);
            }
        }
        break;

    default:
        break;
    }

    RETURN(FALSE);
}

//
// _OnKillActive( )
//
HRESULT
THISCLASS::_OnKillActive( )
{
    TraceClsFunc( "_OnKillActive( )\n" );

    HRESULT hr;
    LRESULT lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_C_MANAGED_PC ) );

    Assert( _pfActivate );
    *_pfActivate = ( lResult == BST_CHECKED );

    if ( *_pfActivate )
    {
        HWND  hwndGuid = GetDlgItem( _hDlg, IDC_E_GUID );
        DWORD dw = Edit_GetTextLength( hwndGuid ) + 1;
        BYTE uGuid[16];

        Assert( !_pszGuid );
        _pszGuid = (LPWSTR) TraceAllocString( LMEM_FIXED, dw );
        if ( !_pszGuid )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        Edit_GetText( hwndGuid, _pszGuid, dw );

        hr = ValidateGuid( _pszGuid, uGuid, NULL );
        Assert( hr == S_OK );

        hr = CheckForDuplicateGuid( uGuid );
        if ( hr == S_FALSE )
        {
            INT i = (INT)DialogBoxParam( g_hInstance, MAKEINTRESOURCE(IDD_DUPLICATE_GUID), _hDlg, DupGuidDlgProc, (LPARAM) this );
            switch ( i )
            {
            case IDOK:
                hr = S_OK;      // ignore problem and continue
                break;

            case IDCANCEL:
                hr = E_FAIL;    // go back and change the GUID
                break;
#ifdef DEBUG
            default:
                AssertMsg( 0, "Invalid return value from DialogBox( )\n" );
                break;
#endif // debug
            }
        }
        else if ( FAILED( hr ) ) 
        {
            MessageBoxFromHResult( _hDlg, NULL, hr );
        }
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    if ( _pszGuid )
    {
        TraceFree( _pszGuid );
        _pszGuid = NULL;
    }

    HRETURN(hr);
}

HRESULT
THISCLASS::_OnQuery(
    HWND hDlg )
{
    TraceClsFunc( "_OnQuery( )\n" );

    HRESULT hr;
    DSQUERYINITPARAMS dqip;
    OPENQUERYWINDOW   oqw;
    LPDSOBJECTNAMES   pDsObjects;
    VARIANT var;
    IPropertyBag * ppb = NULL;
    ICommonQuery * pCommonQuery = NULL;

    VariantInit( &var );

    hr = THR( CoCreateInstance( CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_ICommonQuery, (PVOID *)&pCommonQuery) );
    if (hr)
        goto Error;

    ZeroMemory( &dqip, sizeof(dqip) );
    dqip.cbStruct = sizeof(dqip);
    dqip.dwFlags  = DSQPF_NOSAVE | DSQPF_SHOWHIDDENOBJECTS | DSQPF_ENABLEADMINFEATURES;
    dqip.dwFlags  |= DSQPF_ENABLEADVANCEDFEATURES;

    ppb = (IPropertyBag *) QueryPropertyBag_CreateInstance( );
    if ( !ppb )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    V_VT( &var ) = VT_BSTR;
    V_BSTR( &var ) = SysAllocString( _pszGuid );
    hr = ppb->Write( L"ClientGuid", &var );
    if (hr)
        goto Error;
    
    ZeroMemory( &oqw, sizeof(oqw) );
    oqw.cbStruct           = sizeof(oqw);
    oqw.dwFlags            = OQWF_SHOWOPTIONAL | OQWF_ISSUEONOPEN
                           | OQWF_REMOVESCOPES | OQWF_REMOVEFORMS
                           | OQWF_DEFAULTFORM;
    oqw.clsidHandler       = CLSID_DsQuery;
    oqw.pHandlerParameters = &dqip;
    oqw.clsidDefaultForm   = CLSID_RIQueryForm;
    oqw.pFormParameters    = ppb;

    hr = pCommonQuery->OpenQueryWindow( hDlg, &oqw, NULL /* don't need results */);

Error:
    VariantClear( &var );

    if ( ppb )
        ppb->Release( );

    if ( pCommonQuery )
        pCommonQuery->Release();

    HRETURN(hr);
}

//
// DupGuidDlgProc()
//
INT_PTR CALLBACK
THISCLASS::DupGuidDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("DupGuidDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));
        SetWindowLongPtr( hDlg, GWLP_USERDATA, (LPARAM) lParam );
    }

    switch ( uMsg )
    {
    case WM_COMMAND:
        TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
        switch( LOWORD(wParam) )
        {
        case IDOK:
        case IDCANCEL:
            EndDialog( hDlg, LOWORD(wParam) );
            break;

        case IDC_B_QUERY:
            if ( HIWORD(wParam) == BN_CLICKED )
            {
                if (pcc)
                {
                    pcc->_OnQuery( NULL );
                }
            }
            break;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\pch.h ===
//
// Copyright 1997 - Microsoft
//

//
// PCH.H - Precompiled header
//

#define UNICODE

#if DBG==1
#define DEBUG
#endif // DBG==1

#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG

#ifdef DEBUG
// Turn these on for Interface Tracking
#define NO_TRACE_INTERFACES
// #define NOISY_QI
#endif

//
// Global includes
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <windowsx.h>
#include <activeds.h>
#include <dsclient.h>
#include <prsht.h>
#include <mmc.h>
#include <ntdsapi.h>
#include <remboot.h>
#include <dsquery.h>
#include <cmnquery.h>
#include <dns.h>
#include <dspropp.h>

#include <dsadmin.h>

#include "dll.h"
#include "guids.h"
#include "resource.h"
#include "resource.hm"
#include "cfactory.h"
#include "itab.h"
#include "utils.h"

//
// Global Defines
//
#define OSCHOOSER_SIF_SECTION           L"OSChooser"
#define OSCHOOSER_DESCRIPTION_ENTRY     L"Description"
#define OSCHOOSER_HELPTEXT_ENTRY        L"Help"
#define OSCHOOSER_VERSION_ENTRY         L"Version"
#define OSCHOOSER_IMAGETYPE_ENTRY       L"ImageType"
#define OSCHOOSER_IMAGETYPE_FLAT        L"Flat"
#define OSCHOOSER_LAUNCHFILE_ENTRY      L"LaunchFile"

// object attributes
#define NETBOOTALLOWNEWCLIENTS          L"netbootAllowNewClients"
#define NETBOOTLIMITCLIENTS             L"netbootLimitClients"
#define NETBOOTMAXCLIENTS               L"netbootMaxClients"
#define NETBOOTCURRENTCLIENTCOUNT       L"netbootCurrentClientCount"
#define NETBOOTANSWERREQUESTS           L"netbootAnswerRequests"
#define NETBOOTANSWERONLYVALIDCLIENTS   L"netbootAnswerOnlyValidClients"
#define NETBOOTNEWMACHINENAMINGPOLICY   L"netbootNewMachineNamingPolicy"
#define NETBOOTNEWMACHINEOU             L"netbootNewMachineOU"
#define NETBOOTINTELLIMIRROROSES        L"netbootIntelliMirrorOSes"
#define NETBOOTTOOLS                    L"netbootTools"
#define NETBOOTLOCALINSTALLOSES         L"netbootLocalInstallOSes"
#define NETBOOTGUID                     L"netbootGUID"
#define NETBOOTMACHINEFILEPATH          L"netbootMachineFilepath"
#define NETBOOTINITIALIZATION           L"netbootInitialization"
#define NETBOOTSAP                      L"netbootSCPBL"
#define NETBOOTSERVER                   L"netbootServer"
#define SAMNAME                         L"sAMAccountName"
#define DISTINGUISHEDNAME               L"distinguishedName"
#define DS_CN                           L"cn"

// DS class names
#define DSCOMPUTERCLASSNAME             L"computer"
#define DSGROUPCLASSNAME                L"intelliMirrorGroup"
#define DSIMSAPCLASSNAME                L"intellimirrorSCP"

// path strings
#define SLASH_TEMPLATES                 L"\\" REMOTE_INSTALL_TEMPLATES_DIR_W
#define SLASH_SETUP                     L"\\" REMOTE_INSTALL_SETUP_DIR_W
#define SLASH_IMAGES                    L"\\" REMOTE_INSTALL_IMAGE_DIR_W
#define REMINST_SHARE                   REMOTE_INSTALL_SHARE_NAME_W

// misc
#define STRING_ADMIN                    L"admin"
#define BINL_SERVER_NAME                L"BINLSVC"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\newclnts.h ===
//
// Copyright 1997 - Microsoft

//
// CLIENT.H - Handles the "IntelliMirror" IDD_PROP_INTELLIMIRROR_CLIENT tab
//


#ifndef _NEWCLNTS_H_
#define _NEWCLNTS_H_

// Definitions
LPVOID
CNewClientsTab_CreateInstance( void );
#define SAMPLES_LIST_SIZE 512

INT_PTR CALLBACK
AdvancedDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


class CComputer;
typedef CComputer* LPCComputer;

// CNewClientsTab
class
CNewClientsTab:
    public ITab
{
private:
    HWND  _hDlg;
    LPUNKNOWN _punkService;     // Pointer back to service object

    BOOL   _fAdmin;             // admin mode == TRUE;
    BOOL   _fChanged:1;         // Are we dirty?
    INT    _iCustomId;          // custom ID in the ComboBox

    LPWSTR _pszCustomNamingPolicy; // last customized string
    LPWSTR _pszNewMachineOU;    // netbootNewMachineOU (DN)
    LPWSTR _pszServerDN;        // netbootServer (DN)

    WCHAR  _szSampleName[DNS_MAX_LABEL_BUFFER_LENGTH];   // generated sample machine name

    HWND   _hNotify;            // DSA notify obj

private: // Methods
    CNewClientsTab();
    ~CNewClientsTab();
    STDMETHOD(Init)();

    // Property Sheet Functions
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    HRESULT _ApplyChanges( );
    HRESULT _UpdateSheet( LPWSTR pszNamingPolicy );
    HRESULT _InitDialog( HWND hDlg, LPARAM lParam );
    HRESULT _OnCommand( WPARAM wParam, LPARAM lParam );
    INT     _OnNotify( WPARAM wParam, LPARAM lParam );
    HRESULT _GetCurrentNamingPolicy( LPWSTR * ppszNamingPolicy );
    HRESULT _MakeOUPretty( DS_NAME_FORMAT inFlag, DS_NAME_FORMAT outFlag, LPWSTR *ppszOU );

public: // Methods
    friend LPVOID CNewClientsTab_CreateInstance( void );
    friend INT_PTR CALLBACK
        AdvancedDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

    // ITab
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                            LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(QueryInformation)( LPWSTR pszAttribute, LPWSTR * pszResult );
    STDMETHOD(AllowActivation)( BOOL * pfAllow );
};

typedef CNewClientsTab* LPCNewClientsTab;

#endif // _NEWCLNTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\propext.h ===
// file deleted
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\propext.cpp ===
// file deleted
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\proputil.cpp ===
// file deleted
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\newcmptr.h ===
//
// Copyright 1997 - Microsoft

//
// NEWCMPTR.H - The "New Computer" wizard extensions for Remote Installation Services
//


#ifndef _NEWCMPTR_H_
#define _NEWCMPTR_H_

#include "mangdlg.h"
#include "hostdlg.h"

// QITable
BEGIN_QITABLE( CNewComputerExtensions )
DEFINE_QI( IID_IDsAdminNewObjExt, IDsAdminNewObjExt, 6 )
END_QITABLE

// Definitions
LPVOID
CNewComputerExtensions_CreateInstance( void );

// CNewComputerExtensions
class CNewComputerExtensions
    : public IDsAdminNewObjExt
{
private:
    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( CNewComputerExtensions );

    IADsContainer*      _padsContainerObj;
    LPCManagedPage      _pManagedDialog;
    LPCHostServerPage   _pHostServerDialog;
    IADs *              _pads;
    BOOL                _fActivatePages;

    // display info for pages
    LPWSTR       _pszWizTitle;
    LPWSTR       _pszContDisplayName;
    HICON        _hIcon;

private: // methods
    CNewComputerExtensions( );
    ~CNewComputerExtensions( );
    HRESULT
        Init( void );

public: // methods
    friend LPVOID
        CNewComputerExtensions_CreateInstance( void );

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IDsAdminNewObjExt methods
    STDMETHOD(Initialize)( IADsContainer* pADsContainerObj, 
                           IADs* pADsCopySource,
                           LPCWSTR lpszClassName,
                           IDsAdminNewObj* pDsAdminNewObj,
                           LPDSA_NEWOBJ_DISPINFO pDispInfo);
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, 
                         LPARAM lParam);
    STDMETHOD(SetObject)( IADs* pADsObj);
    STDMETHOD(WriteData)( HWND hWnd, 
                          ULONG uContext);
    STDMETHOD(OnError)( HWND hWnd,
                        HRESULT hr,
                        ULONG uContext);
    STDMETHOD(GetSummaryInfo)( BSTR* pBstrText);

    friend class CManagedPage;
    friend class CHostServerPage;

};

typedef CNewComputerExtensions * LPCNewComputerExtensions;


#endif // _NEWCMPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\proputil.h ===
// file deleted
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\newcmptr.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// NEWCMPTR.CPP - The "New Client" dialog box
//

#include "pch.h"

#include "newcmptr.h"
#include "mangdlg.h"
#include "ccomputr.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CNewComputerExtensions")
#define THISCLASS CNewComputerExtensions
#define LPTHISCLASS LPCNewComputerExtensions

//
// CNewComputerExtensions_CreateInstance( )
//
LPVOID
CNewComputerExtensions_CreateInstance( void )
{
    TraceFunc( "CNewComputerExtensions_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    if ( !lpcc ) {
        RETURN(lpcc);
    }

    HRESULT hr = THR( lpcc->Init( ) );
    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN(lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CNewComputerExtensions( )\n" );

    InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init( )
//
HRESULT
THISCLASS::Init( )
{
    TraceClsFunc( "Init( )\n" );

    HRESULT hr;

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CNewComputerExtensions, IDsAdminNewObjExt );
    QITABLE_IMP( IDsAdminNewObjExt );
    END_QITABLE_IMP( CNewComputerExtensions );
    Assert( _cRef == 0);
    AddRef( );

    hr = CheckClipboardFormats( );

    Assert( !_padsContainerObj );
    Assert( !_pManagedDialog );
    Assert( !_pHostServerDialog );

    Assert( !_pszWizTitle );
    Assert( !_pszContDisplayName );
    Assert( !_hIcon );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CNewComputerExtensions( )\n" );

    if ( _padsContainerObj )
        _padsContainerObj->Release( );

    if ( _pszWizTitle )
        TraceFree( _pszWizTitle );

    if ( _pszContDisplayName )
        TraceFree( _pszContDisplayName );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
}

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface( 
    REFIID riid, 
    LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );
    
    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}

// ************************************************************************
//
// IDsAdminNewObjExt
//
// ************************************************************************

//
// Initialize( )
//
STDMETHODIMP
THISCLASS::Initialize(IADsContainer* pADsContainerObj, 
                           IADs* pADsCopySource,
                           LPCWSTR lpszClassName,
                           IDsAdminNewObj* pDsAdminNewObj,
                           LPDSA_NEWOBJ_DISPINFO pDispInfo)
{
    TraceClsFunc( "[IDsAdminNewObjExt] Initialize(" );
    TraceMsg( TF_FUNC, " pADsContainerObj = 0x%08x, lpszClassName = '%s', pDispInfo = 0x%08x )\n",
        pADsContainerObj, lpszClassName, pDispInfo );

    if ( !pADsContainerObj )
        HRETURN(E_POINTER);

    if ( !pDispInfo )
        HRETURN(E_POINTER);

    if ( pDispInfo->dwSize != sizeof(*pDispInfo) )
    {
        HRETURN(E_INVALIDARG);
    }


    if ( StrCmpI( lpszClassName, COMPUTER_CLASS_NAME ) !=0 )
        HRETURN(E_INVALIDARG);

    HRESULT hr = S_OK;

    _padsContainerObj = pADsContainerObj;
    _padsContainerObj->AddRef( );

    // deep copy DSA_NEWOBJ_DISPINFO
    _pszWizTitle = (LPWSTR) TraceStrDup( pDispInfo->lpszWizTitle );
    _pszContDisplayName = (LPWSTR) TraceStrDup( pDispInfo->lpszContDisplayName );
    _hIcon = pDispInfo->hObjClassIcon;

    HRETURN(hr);
}

//
// AddPages( )
//
STDMETHODIMP
THISCLASS::AddPages( 
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam)
{
    TraceClsFunc( "[IDsAdminNewObjExt] AddPages(" );
    TraceMsg( TF_FUNC, " lpfnAddPage = 0x%08x, lParam = 0x%08x )\n", lpfnAddPage, lParam );

    HRESULT hr;

    hr = THR( ::AddPagesEx( (ITab**)&_pManagedDialog, 
                            CManagedPage_CreateInstance, 
                            lpfnAddPage, 
                            lParam,
                            (LPUNKNOWN) NULL ) );
    if (FAILED( hr ))
        goto Error;

    _pManagedDialog->_pNewComputerExtension = this;
    _pManagedDialog->AllowActivation( &_fActivatePages );

    hr = THR( ::AddPagesEx( (ITab**)&_pHostServerDialog, 
                            CHostServerPage_CreateInstance, 
                            lpfnAddPage, 
                            lParam,
                            (LPUNKNOWN) NULL ) );
    if (FAILED( hr ))
        goto Error;

    _pHostServerDialog->_pNewComputerExtension = this;
    _pHostServerDialog->AllowActivation( &_fActivatePages );


Error:
    HRETURN(hr);
}

//
// SetObject( )
//
STDMETHODIMP
THISCLASS::SetObject( 
    IADs* pADsObj)
{
    TraceClsFunc( "[IDsAdminNewObjExt] SetObject(" );
    TraceMsg( TF_FUNC, " pADsObj = 0x%08x )\n", pADsObj );

    if ( !pADsObj )
        HRETURN(E_POINTER);

    HRESULT hr = S_OK;

    _pads = pADsObj;
    _pads->AddRef( );

    HRETURN(hr);
}


//
// WriteData( )
//
STDMETHODIMP
THISCLASS::WriteData(
    HWND hWnd,
    ULONG uContext)
{
    TraceClsFunc( "[IDsAdminNewObjExt] WriteData(" );
    TraceMsg( TF_FUNC, " hWnd = 0x%08x, uContext = %d )\n", hWnd, uContext );

    HRESULT hr = S_OK;
    LPWSTR  pszGuid = NULL;
    LPWSTR  pszServer = NULL;
    LPCOMPUTER lpc = NULL;

    //
    // we should set our data during PRECOMMIT, so that the data
    // get's set during the initial SetCommit().  This way we never have
    // to actually commit the data ourselves.
    //
    if ( uContext != DSA_NEWOBJ_CTX_PRECOMMIT )
        goto Cleanup;

    lpc = (LPCOMPUTER) CreateIntelliMirrorClientComputer( _pads );
    if ( !lpc )
        goto Error;

    hr = THR( _pManagedDialog->QueryInformation( NETBOOTGUID, &pszGuid ) );
    if (FAILED( hr ))
        goto Error;

    if ( pszGuid && pszGuid[0] )
    {
        hr = THR( lpc->SetGUID( pszGuid ) );
        if (FAILED( hr ))
            goto Error;
    }

    hr = THR( _pHostServerDialog->QueryInformation( NETBOOTSERVER, &pszServer ) );
    if (FAILED( hr ))
        goto Error;

    if ( pszServer && pszServer[0] )
    {
        hr = THR( lpc->SetServerName( pszServer ) );
        if (FAILED( hr ))
            goto Error;
    }

    Assert( hr == S_OK );

Cleanup:
    if ( pszGuid )
        TraceFree( pszGuid );
    if ( pszServer )
        TraceFree( pszServer );
    if ( lpc )
        lpc->Release( );
    HRETURN(hr);
Error:
    MessageBoxFromHResult( NULL, IDS_ERROR_WRITINGTOCOMPUTERACCOUNT, hr );
    goto Cleanup;

}

//
// OnError( )
//
STDMETHODIMP
THISCLASS::OnError( 
    HWND hWnd, 
    HRESULT hr,
    ULONG uContext)
{
    TraceClsFunc( "[IDsAdminNewObjExt] OnError(" );
    TraceMsg( TF_FUNC, " hWnd = 0x%08x, uContext = %d )\n", hWnd, uContext );

    HRESULT hrRet = E_NOTIMPL;

    HRETURN(hrRet);
}

//
// GetSummaryInfo( )
//
STDMETHODIMP
THISCLASS::GetSummaryInfo(
    BSTR* pBstrText)
{
    TraceClsFunc( "[IDsAdminNewObjExt] GetSummaryInfo( ... )\n" );

    if ( !pBstrText )
        HRETURN(E_POINTER);

    HRESULT hr;
    DWORD   dw;
    WCHAR   szManagedPC[ 256 ];
    LPWSTR  pszGuid = NULL;
    LPWSTR  pszServer = NULL;
    LPWSTR  pszOut = NULL;

    *pBstrText = NULL;

    hr = _pManagedDialog->QueryInformation( L"Guid", &pszGuid );
#ifdef DEBUG
    if ( hr != S_FALSE && hr != E_FAIL )
    {
        THR( hr );
    }
#endif // DEBUG
    if (pszGuid == NULL)
        goto Cleanup;

    dw = LoadString( g_hInstance, IDS_MANAGED_PC, szManagedPC, ARRAYSIZE(szManagedPC) );
    Assert( dw );

    hr = THR( _pHostServerDialog->QueryInformation( L"Server", &pszServer ) );
#ifdef DEBUG
    if ( FAILED(hr) )
    {
        Assert( pszServer == NULL );
    }
#endif // DEBUG

    // Make a buffer
    dw += wcslen( pszGuid ) + 1;
    if ( pszServer )
    {
        dw += wcslen( pszServer ) + 1;
    }

    pszOut = (LPWSTR) TraceAllocString( LMEM_FIXED, dw );
    if ( !pszOut )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    wsprintf( pszOut, szManagedPC, pszGuid, pszServer );

    *pBstrText = SysAllocString( pszOut );
    if( !*pBstrText )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    if ( pszOut )
        TraceFree( pszOut );

    if ( pszServer )
        TraceFree( pszServer );

    if ( pszGuid )
        TraceFree( pszGuid );

    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\newclnts.cpp ===
//
// Copyright 1997 - Microsoft

//
// NEWCLNT.CPP - Handle the "New Clients" IDD_PROP_NEW_CLIENTS property page
//


#include "pch.h"
#include <dnsapi.h>
#include <ntdsapi.h>
#include <dsgetdc.h>
#include <lm.h>
#include <wininet.h>
#include "newclnts.h"
#include "cservice.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CNewClientsTab")
#define THISCLASS CNewClientsTab
#define LPTHISCLASS LPCNewClientsTab

#define UNKNOWN_INVALID_TEMPLATE L"??"

#include <riname.h>
#include <riname.c>

DWORD aNewClientsHelpMap[] = {
    IDC_B_BROWSE, HIDC_B_BROWSE,
    IDC_E_NEWMACHINEOU, HIDC_E_NEWMACHINEOU,
    IDC_R_SPECIFICLOCATION, HIDC_R_SPECIFICLOCATION,
    IDC_R_SAMEASUSER, HIDC_R_SAMEASUSER,
    IDC_R_DOMAINDEFAULT, HIDC_R_DOMAINDEFAULT,
    IDC_G_CLIENTACCOUNTLOCATION, HIDC_G_CLIENTACCOUNTLOCATION,
    IDC_E_SAMPLE, HIDC_E_SAMPLE,
    IDC_CB_NAMINGPOLICY, HIDC_CB_NAMINGPOLICY,
    IDC_B_ADVANCED, HIDC_B_ADVANCED,
    IDC_G_NAMINGFORMAT, HIDC_G_NAMINGFORMAT,
    NULL, NULL
};

DWORD aAdvancedHelpMap[] = {
    IDC_E_FORMAT, HIDC_E_FORMAT,
    IDC_E_SAMPLE, HIDC_E_SAMPLE,
    NULL, NULL
};

//
// CreateInstance()
//
LPVOID
CNewClientsTab_CreateInstance( void )
{
        TraceFunc( "CNewClientsTab_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    if ( !lpcc ) {
        RETURN(lpcc);
    }

    HRESULT hr = THR( lpcc->Init( ) );
    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN(lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CNewClientsTab()\n" );

        InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
HRESULT __stdcall
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    Assert( !_pszNewMachineOU );
    Assert( !_pszServerDN );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CNewClientsTab()\n" );

    if ( _punkService )
        _punkService->Release( );

    if ( _pszServerDN )
        TraceFree( _pszServerDN );

    if ( _pszCustomNamingPolicy )
        TraceFree( _pszCustomNamingPolicy );

    // tell ADS to destroy the notify object
    // NOTE: Another property page may do this before us. Ignore errors.
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_EXIT, 0, 0 );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// *************************************************************************
//
// ITab
//
// *************************************************************************

STDMETHODIMP
THISCLASS::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam,
    LPUNKNOWN punk )
{
    TraceClsFunc( "AddPages( )\n" );

    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
    psp.hInstance   = (HINSTANCE) g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP_NEW_CLIENTS);
    psp.pcRefParent = (UINT *) &g_cObjects;
    psp.pfnCallback = (LPFNPSPCALLBACK) PropSheetPageProc;
    psp.pfnDlgProc  = PropSheetDlgProc;
    psp.lParam      = (LPARAM) this;

    hpage = CreatePropertySheetPage( &psp );
    if ( hpage )
    {
        if ( !lpfnAddPage( hpage, lParam ) )
        {
            DestroyPropertySheetPage( hpage );
            hr = E_FAIL;
            goto Error;
        }
    }

    punk->AddRef( );   // matching Release in the destructor
    _punkService = punk;

Error:
    HRETURN(hr);
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam,
    LPUNKNOWN punk )
{

    TraceClsFunc( "ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    RETURN(E_NOTIMPL);
}

//
// QueryInformation( )
//
STDMETHODIMP
THISCLASS::QueryInformation(
    LPWSTR pszAttribute,
    LPWSTR * pszResult )
{
    TraceClsFunc( "QueryInformation( )\n" );

    HRETURN(E_NOTIMPL);
}


//
// AllowActivation( )
//
STDMETHODIMP
THISCLASS::AllowActivation(
    BOOL * pfAllow )
{
    TraceClsFunc( "AllowActivation( )\n" );

    HRETURN(E_NOTIMPL);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************

//
// GenerateSample( )
//

DWORD
GenerateSample(
    LPWSTR pszPolicy,
    LPWSTR pszSampleOut,
    LPDWORD maxLength )
{
    DWORD error;
    GENNAME_VARIABLES variables;

    TraceClsFunc( "GenerateSample( )\n" );

    if ( !pszPolicy )
        HRETURN(E_POINTER);

    variables.UserName = L"JOHNSMI";
    variables.FirstName = L"John";
    variables.LastName = L"Smith";
    variables.MacAddress = L"123456789012";
    variables.Counter = 123456789;
    variables.AllowCounterTruncation = TRUE;

    error = GenerateNameFromTemplate(
                pszPolicy,
                &variables,
                pszSampleOut,
                DNS_MAX_LABEL_BUFFER_LENGTH,
                NULL,
                NULL,
                maxLength
                );

    if ( error == GENNAME_TEMPLATE_INVALID ) {
        wcscpy( pszSampleOut, UNKNOWN_INVALID_TEMPLATE );
    }

    RETURN(error);
}

//
// _UpdateSheet()
//
HRESULT
THISCLASS::_UpdateSheet( LPWSTR pszNamingPolicy )
{
    TraceClsFunc( "_UpdateSheet( )\n" );

    HRESULT hr = S_FALSE;
    LPWSTR  pszNext;
    DWORD   dw;
    WCHAR   szSamples[ 256 ];
    HWND    hwndCB = GetDlgItem( _hDlg, IDC_CB_NAMINGPOLICY );

    if (hwndCB == NULL) {
        RRETURN(GetLastError());
    }

    if ( pszNamingPolicy )
    {
        BOOL   fMatched = FALSE;
        INT    iCount;
        INT    iOldCount = ComboBox_GetCurSel( hwndCB );

        // Retrieve the combobox strings
        dw = LoadString( g_hInstance, IDS_SAMPLENAMINGPOLICY, szSamples, ARRAYSIZE( szSamples ) );
        Assert( dw );

        iCount = 0;
        pszNext = szSamples;
        while ( *pszNext )
        {
            LPWSTR pszFriendlyName = pszNext;

            // skip the friendly name
            pszNext =StrChr( pszNext, L';' );
            if ( !pszNext )
                break;
            *pszNext = L'\0'; // terminate
            pszNext++;

            LPWSTR pszCodedString = pszNext;

            pszNext = StrChr( pszNext, L';' );
            if ( !pszNext )
                break;

            *pszNext = L'\0'; // teminate

            if ( pszNamingPolicy && StrCmpI( pszNamingPolicy, pszCodedString ) == 0 )
            {
                break;
            }

            iCount++;
            pszNext++;
        }

        if ( iOldCount != iCount )
        {
            ComboBox_SetCurSel( hwndCB, iCount );
            hr = S_OK;
        }
    }
    else
    {
        INT    iCount = ComboBox_GetCurSel( hwndCB );

        // Retrieve the combobox strings
        dw = LoadString( g_hInstance, IDS_SAMPLENAMINGPOLICY, szSamples, ARRAYSIZE( szSamples ) );
        Assert( dw );

        pszNext = szSamples;
        while ( *pszNext && iCount >= 0 )
        {
            LPWSTR pszFriendlyName = pszNext;

            // skip the friendly name
            pszNext =StrChr( pszNext, L';' );
            if ( !pszNext )
                break;
            *pszNext = L'\0'; // terminate
            pszNext++;

            pszNamingPolicy = pszNext;

            pszNext = StrChr( pszNext, L';' );
            if ( !pszNext )
                break;

            *pszNext = L'\0'; // teminate

            iCount--;
            pszNext++;
        }
    }

    GenerateSample( pszNamingPolicy, _szSampleName, &dw );

    SetDlgItemText( _hDlg, IDC_E_SAMPLE, _szSampleName );

    RETURN(hr);
}


//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
    HWND hDlg,
    LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    HRESULT hr;
    HRESULT hResult = S_OK;
    DWORD   dw;
    LPWSTR  pszNext;
    HWND    hwnd;
    WCHAR   szSamples[ SAMPLES_LIST_SIZE ];
    LPWSTR  pszNewMachineOU = NULL;

    IIntelliMirrorSAP * pimsap = NULL;

    _hDlg = hDlg;

    dw = LoadString( g_hInstance, IDS_SAMPLENAMINGPOLICY, szSamples, ARRAYSIZE( szSamples ) );
    Assert( dw );

    Assert( _punkService );
    hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
    if (FAILED( hr ))
        goto Error;

    hr = THR( pimsap->GetNotifyWindow( &_hNotify ) );
    if (FAILED( hr ))
        goto Error;
    
    ADsPropSetHwnd( _hNotify, _hDlg );

    //
    // Populate Naming Policy ComboBox
    //
    hwnd = GetDlgItem( _hDlg, IDC_CB_NAMINGPOLICY );
    ComboBox_ResetContent( hwnd );

    _iCustomId = 0;
    pszNext = szSamples;
    while ( *pszNext )
    {
        // add the friendly name to the combobox
        LPWSTR pszFriendlyName = pszNext;

        pszNext = StrChr( pszNext, L';' );
        if ( !pszNext )
            break;

        *pszNext = L'\0'; // terminate
        ComboBox_AddString( hwnd, pszFriendlyName );
        *pszNext = L';';  // restore

        // skip the formatted string
        pszNext++;
        pszNext = StrChr( pszNext, L';' );
        if ( !pszNext )
            break;

        pszNext++;
        _iCustomId++;
    }

    hr = THR( pimsap->IsAdmin( &_fAdmin ) );
    Assert( SUCCEEDED(hr) || _fAdmin == FALSE );

    EnableWindow( GetDlgItem( _hDlg, IDC_CB_NAMINGPOLICY ),    _fAdmin );
    EnableWindow( GetDlgItem( _hDlg, IDC_B_ADVANCED ),         _fAdmin );
    EnableWindow( GetDlgItem( _hDlg, IDC_R_SAMEASUSER ),       _fAdmin );
    EnableWindow( GetDlgItem( _hDlg, IDC_R_DOMAINDEFAULT ),    _fAdmin );
    EnableWindow( GetDlgItem( _hDlg, IDD_PROP_NEW_CLIENTS ),   _fAdmin );
    EnableWindow( GetDlgItem( _hDlg, IDC_R_SPECIFICLOCATION ), _fAdmin );

    hr = THR( pimsap->GetNewMachineNamingPolicy( &_pszCustomNamingPolicy ) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND && hResult == S_OK )
    {
        hResult = hr;
    }
    Assert( SUCCEEDED(hr) || !_pszCustomNamingPolicy );
    _UpdateSheet( _pszCustomNamingPolicy );

    hr = pimsap->GetNewMachineOU( &pszNewMachineOU );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND && hResult == S_OK )
    {
        hResult = hr;
    }
    Assert( SUCCEEDED(hr) || !pszNewMachineOU );
    
    hr = THR( pimsap->GetServerDN( &_pszServerDN ) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND && hResult == S_OK )
    {
        hResult = hr;
    }
    Assert( SUCCEEDED(hr) || !_pszServerDN );

    if ( pszNewMachineOU )
    {
        if( StrCmp( pszNewMachineOU, _pszServerDN ) !=0 )
        {
            hr = _MakeOUPretty( DS_FQDN_1779_NAME, DS_CANONICAL_NAME, &pszNewMachineOU );
            BOOLEAN temp = _fChanged;
            _fChanged =TRUE;// Prevent early turning on of the Apply button.
            SetDlgItemText( _hDlg, IDC_E_NEWMACHINEOU, pszNewMachineOU );
            _fChanged = temp;

            EnableWindow( GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU ), _fAdmin );
            EnableWindow( GetDlgItem( _hDlg, IDC_B_BROWSE ), _fAdmin );

            Button_SetCheck( GetDlgItem( _hDlg, IDC_R_SPECIFICLOCATION ),  BST_CHECKED );
            Button_SetCheck( GetDlgItem( _hDlg, IDC_R_DOMAINDEFAULT ),     BST_UNCHECKED );
            Button_SetCheck( GetDlgItem( _hDlg, IDC_R_SAMEASUSER ),        BST_UNCHECKED );
        }
        else
        {
            EnableWindow( GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU ), FALSE );
            EnableWindow( GetDlgItem( _hDlg, IDC_B_BROWSE ), FALSE );

            Button_SetCheck( GetDlgItem( _hDlg, IDC_R_SPECIFICLOCATION ), BST_UNCHECKED );
            Button_SetCheck( GetDlgItem( _hDlg, IDC_R_DOMAINDEFAULT ),    BST_CHECKED );
            Button_SetCheck( GetDlgItem( _hDlg, IDC_R_SAMEASUSER ),       BST_UNCHECKED );
        }
    }
    else
    {
        EnableWindow( GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU ), FALSE );
        EnableWindow( GetDlgItem( _hDlg, IDC_B_BROWSE ), FALSE );

        Button_SetCheck( GetDlgItem( _hDlg, IDC_R_SPECIFICLOCATION ), BST_UNCHECKED );
        Button_SetCheck( GetDlgItem( _hDlg, IDC_R_DOMAINDEFAULT ),    BST_UNCHECKED );
        Button_SetCheck( GetDlgItem( _hDlg, IDC_R_SAMEASUSER ),       BST_CHECKED );
    }

    if ( hResult )
    {
        MessageBoxFromHResult( _hDlg, IDS_ERROR_READINGCOMPUTERACCOUNT, hResult );
    }

Cleanup:
    if ( pszNewMachineOU )
        TraceFree( pszNewMachineOU );
    if ( pimsap )
        pimsap->Release( );
    HRETURN(hr);

Error:
    MessageBoxFromHResult( _hDlg, IDS_ERROR_READINGCOMPUTERACCOUNT, hr );
    goto Cleanup;
}

PCWSTR
GetLdapNameOfObjectOu(
    PCWSTR InputPath
    )
{
    PWSTR p,pOut;
    DWORD dwLen;
    
    p = StrStrI( InputPath, L"dc=" );

    if (!p) {
        return(NULL);
    }

    dwLen = (wcslen(p) + 1)*sizeof(WCHAR) + sizeof(L"LDAP://");
    
    pOut = (PWSTR)TraceAlloc(LMEM_FIXED, dwLen );
    if (!pOut) {
        return(NULL);
    }

    wcscpy(pOut, L"LDAP://");
    wcscat(pOut, p );

    return(pOut);

}

//
// _OnCommand( )
//
HRESULT
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    BOOL fReturn = FALSE;
    BOOL fChanged = FALSE;
    HWND    hwndCtl = (HWND) lParam;

    switch( LOWORD(wParam) )
    {
    case IDC_B_ADVANCED:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            LPWSTR  pszNamingPolicy = _pszCustomNamingPolicy;
            HRESULT hr = _GetCurrentNamingPolicy( &_pszCustomNamingPolicy );
            if ( hr != S_FALSE )
            {
                TraceFree( pszNamingPolicy );
            }
            UINT i = (UINT) DialogBoxParam( g_hInstance, 
                                            MAKEINTRESOURCE( IDD_ADVANCEDNAMIMG), 
                                            _hDlg, 
                                            AdvancedDlgProc,
                                            (LPARAM) this );
            hr = _UpdateSheet( _pszCustomNamingPolicy );
            if ( i == IDOK )
            {
                fChanged = TRUE;
            }
        }
        break;

    case IDC_CB_NAMINGPOLICY:
        if ( HIWORD( wParam ) == CBN_SELCHANGE )
        {
            INT i = ComboBox_GetCurSel( hwndCtl );
            if ( i == _iCustomId )
            {
                UINT i = (UINT) DialogBoxParam( g_hInstance, 
                                                MAKEINTRESOURCE( IDD_ADVANCEDNAMIMG), 
                                                _hDlg, 
                                                AdvancedDlgProc,
                                                (LPARAM) this );
                HRESULT hr = _UpdateSheet( _pszCustomNamingPolicy );
                if ( i == IDOK )
                {
                    fChanged = TRUE;
                }
            }
            else
            {
                _UpdateSheet( NULL );
                fChanged = TRUE;
            }
        }
        break;

    case IDC_R_SPECIFICLOCATION:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            HWND hwnd = GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU );
            EnableWindow( hwnd, _fAdmin );
            EnableWindow( GetDlgItem( _hDlg, IDC_B_BROWSE ), _fAdmin );

            if ( GetWindowTextLength( hwnd ) != 0 )
            {
                fChanged = TRUE;
            }
        }
        break;

    case IDC_E_NEWMACHINEOU:
        if ( HIWORD( wParam ) == EN_CHANGE )
        {
            HWND hwnd = GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU );
            if ( GetWindowTextLength( hwnd ) != 0 )
            {
                fChanged = TRUE;
            }
        }
        break;

    case IDC_R_SAMEASUSER:
    case IDC_R_DOMAINDEFAULT:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            EnableWindow( GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU ), FALSE );
            EnableWindow( GetDlgItem( _hDlg, IDC_B_BROWSE ), FALSE );
            fChanged = TRUE;
        }
        break;

    case IDC_B_BROWSE:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            DSBROWSEINFO info;
            WCHAR szCaption[ 64 ];
            WCHAR szTitle[ 64 ];
            WCHAR szPath[ INTERNET_MAX_URL_LENGTH ];
            DWORD dw;

            dw = LoadString( g_hInstance, IDS_BROWSEFOROU_CAPTION, szCaption, ARRAYSIZE( szCaption ) );
            Assert( dw );

            dw = LoadString( g_hInstance, IDS_BROWSEFOROU_TITLE, szTitle, ARRAYSIZE( szTitle ) );
            Assert( dw );

            ZeroMemory( &info, sizeof(info) );
            info.cbStruct   = sizeof(info);
            info.hwndOwner  = _hDlg;
            info.pszRoot    = GetLdapNameOfObjectOu(_pszServerDN);
            info.pszCaption = szCaption;
            info.pszTitle   = szTitle;
            info.pszPath    = szPath;
            info.cchPath    = ARRAYSIZE(szPath);
            info.dwFlags    = DSBI_ENTIREDIRECTORY;

            if ( IDOK == DsBrowseForContainer( &info ) )
            {
                // Skip the "LDAP://" part
                HRESULT hr = E_FAIL;
                LPWSTR pszOU = TraceStrDup( &szPath[7] );
                if ( pszOU )
                {
                    hr = _MakeOUPretty( DS_FQDN_1779_NAME, DS_CANONICAL_NAME, &pszOU );
                    if (SUCCEEDED( hr ))
                    {
                        SetWindowText( GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU ), pszOU );
                        fChanged = TRUE;
                    }
                    TraceFree( pszOU );
                }

                if (FAILED( hr ))
                {
                    SetWindowText( GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU ), &szPath[7] );
                    fChanged = TRUE;
                }
            }

            if (info.pszRoot) {
                TraceFree( (HGLOBAL)info.pszRoot );
            }
        }
        break;
    }

    if ( fChanged )
    {
        if ( !_fChanged )
        {
            _fChanged = TRUE;
            SendMessage( GetParent( _hDlg ), PSM_CHANGED, 0, 0 );
        }
    }

    RRETURN(fReturn);
}


//
// _ApplyChanges( )
//
HRESULT
THISCLASS::_ApplyChanges( )
{
    TraceClsFunc( "_ApplyChanges( )\n" );

    if ( !_fChanged )
        HRETURN(S_OK); // nop

    HRESULT hr;
    HRESULT hResult = S_OK;
    LPWSTR  pszNamingPolicy = NULL;
    UINT    iItem;
    IIntelliMirrorSAP * pimsap = NULL;

    hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
    if (FAILED( hr ))
        goto Error;

    if ( Button_GetCheck( GetDlgItem( _hDlg, IDC_R_SPECIFICLOCATION ) ) == BST_CHECKED )
    {
        HWND   hwnd = GetDlgItem( _hDlg, IDC_E_NEWMACHINEOU );
        ULONG  uLen = GetWindowTextLength( hwnd ) + 1;
        LPWSTR pszNewMachineOU = TraceAllocString( LMEM_FIXED, uLen );
        if ( pszNewMachineOU )
        {
            GetWindowText( hwnd, pszNewMachineOU, uLen );

            hr = _MakeOUPretty( DS_CANONICAL_NAME, DS_FQDN_1779_NAME, &pszNewMachineOU );
            if (SUCCEEDED( hr ))
            {            
                hr = THR( pimsap->SetNewMachineOU( pszNewMachineOU ) );
            }

            TraceFree( pszNewMachineOU );

            if (FAILED(hr) && hResult == S_OK )
            {
                hResult = hr;
                SetFocus( hwnd );
            }
        }
    }
    else if ( Button_GetCheck( GetDlgItem( _hDlg, IDC_R_DOMAINDEFAULT ) ) == BST_CHECKED )
    {
        hr = THR( pimsap->SetNewMachineOU( _pszServerDN ) );
        if (FAILED(hr) && hResult == S_OK )
        {
            hResult = hr;
            SetFocus( GetDlgItem( _hDlg, IDC_R_DOMAINDEFAULT ) );
        }
    }
    else
    {
        hr = THR( pimsap->SetNewMachineOU( NULL ) );
        if (FAILED(hr) && hResult == S_OK )
        {
            hResult = hr;
            SetFocus( GetDlgItem( _hDlg, IDC_R_SAMEASUSER ) );
        }
    }

    hr = _GetCurrentNamingPolicy( &pszNamingPolicy );
    if (FAILED( hr ) && hResult == S_OK )
    {
        hResult = hr;
    }

    hr = THR( pimsap->SetNewMachineNamingPolicy( pszNamingPolicy ) );
    if (FAILED( hr ) && hResult == S_OK )
    {
        SetFocus( GetDlgItem( _hDlg, IDC_CB_NAMINGPOLICY ) );
        hResult = hr;
    }

    hr = THR( pimsap->CommitChanges( ) );
    if (FAILED( hr ))
        goto Error;

    if ( hResult )
    {
        MessageBoxFromHResult( _hDlg, IDS_ERROR_WRITINGTOCOMPUTERACCOUNT, hResult );
        hr = hResult;
    }
    else
    {
        _fChanged = FALSE;
    }

Cleanup:
    if ( pimsap )
        pimsap->Release( );
    if ( pszNamingPolicy )
        TraceFree( pszNamingPolicy );

    // Tell DSA that someone hit Apply
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_APPLY, !!SUCCEEDED( hr ), 0 );

    HRETURN(hr);
Error:
    MessageBoxFromHResult( _hDlg, IDS_ERROR_WRITINGTOCOMPUTERACCOUNT, hr );
    goto Cleanup;
}

//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;

    switch( lpnmhdr->code )
    {
    case PSN_APPLY:
        {
            HRESULT hr;
            TraceMsg( TF_WM, TEXT("WM_NOTIFY: PSN_APPLY\n"));
            hr = _ApplyChanges( );
            SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, ( SUCCEEDED(hr) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE ));
            RETURN(TRUE);
        }
        break;

    default:
        break;
    }

    RETURN(FALSE);
}

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, psp->lParam );
        pcc = (LPTHISCLASS) psp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc)
    {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg )
        {
        case WM_NOTIFY:
            return pcc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
            pcc->_OnCommand( wParam, lParam );
            break;

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aNewClientsHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aNewClientsHelpMap );
            break;

        case WM_ADSPROP_PAGE_GET_NOTIFY:
            {
                HWND *phwnd = (HWND *) wParam;
                *phwnd = pcc->_hNotify;
            }
            return TRUE;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
UINT CALLBACK
THISCLASS::PropSheetPageProc(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp )
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("hwnd = 0x%08x, uMsg = 0x%08x, ppsp= 0x%08x )\n"),
        hwnd, uMsg, ppsp );

    switch ( uMsg )
    {
    case PSPCB_CREATE:
        RETURN(TRUE);   // create it
        break;

    case PSPCB_RELEASE:
        LPTHISCLASS pcc = (LPTHISCLASS) ppsp->lParam;
        delete pcc;
        break;
    }

    RETURN(FALSE);
}

// ************************************************************************
//
// Advanced Namimg Dialog Proc
//
// ************************************************************************


//
// Advanced_OnCommand( )
//
UINT CALLBACK
Advanced_OnCommand(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam,
    LPTHISCLASS pcc )
{
    TraceFunc( "Advanced_OnCommand( " );
    TraceMsg( TF_FUNC, "hDlg, wParam, lParam, pcc )\n" );


    RETURN(TRUE);
}

INT_PTR CALLBACK
AdvancedDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("AdvancedDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );
    WCHAR szFormat[ DNS_MAX_LABEL_BUFFER_LENGTH ];

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        pcc = (LPTHISCLASS) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, (LPARAM) pcc );

        Assert( pcc != NULL );

        HWND hwnd = GetDlgItem( hDlg, IDC_E_FORMAT );
        Edit_LimitText( hwnd, ARRAYSIZE(szFormat) - 1 );

        LPWSTR pszNamingPolicy = NULL;
        HRESULT hr = pcc->_GetCurrentNamingPolicy( &pszNamingPolicy );
        if (SUCCEEDED( hr )  && (hr != S_FALSE))
        {
            SetWindowText( hwnd, pszNamingPolicy );
            TraceFree( pszNamingPolicy );
        }
    }

    if (pcc)
    {
        switch ( uMsg )
        {
        case WM_COMMAND:
            {
                switch( LOWORD( wParam ) )
                {
                case IDCANCEL:
                    if ( HIWORD( wParam ) == BN_CLICKED )
                    {
                        EndDialog( hDlg, LOWORD( wParam ) );
                        return TRUE;
                    }
                    break;

                case IDOK:
                    if ( HIWORD( wParam ) == BN_CLICKED )
                    {
                        WCHAR szSample[ DNS_MAX_LABEL_BUFFER_LENGTH ];
                        DWORD maxLength;
                        DWORD nameError;

                        GetDlgItemText( hDlg, IDC_E_FORMAT, szFormat, ARRAYSIZE(szFormat) );

                        nameError = GenerateSample( szFormat, szSample, &maxLength );

                        Assert( (nameError == GENNAME_NO_ERROR) ||
                                (nameError == GENNAME_TEMPLATE_INVALID) ||
                                (nameError == GENNAME_NAME_TOO_LONG) );

                        if ( nameError == GENNAME_TEMPLATE_INVALID )
                        {
                            MessageBoxFromStrings( hDlg,
                                                   IDS_ADVANCED_NAMING_RESTRICTIONS_TITLE,
                                                   IDS_ADVANCED_NAMING_RESTRICTIONS_TEXT,
                                                   MB_OK );
                            break;
                        }
                        else if ( nameError == GENNAME_NAME_TOO_LONG )
                        {
                            LRESULT lResult = MessageBoxFromStrings( hDlg,
                                                                     IDS_DNS_NAME_LENGTH_WARNING_TITLE,
                                                                     IDS_DNS_NAME_LENGTH_WARNING_TEXT,
                                                                     MB_YESNO );
                            if ( lResult == IDNO )
                                break;
                        }

                        pcc->_pszCustomNamingPolicy = (LPWSTR) TraceStrDup( szFormat );

                        EndDialog( hDlg, LOWORD( wParam ) );

                        return TRUE;
                    }
                    break;

                case IDC_E_FORMAT:
                    if ( HIWORD( wParam ) == EN_CHANGE )
                    {
                        WCHAR szSample[ DNS_MAX_LABEL_BUFFER_LENGTH ] = { L"" };
                        DWORD maxLength;
                        DWORD nameError;

                        if ( !GetDlgItemText( hDlg, IDC_E_FORMAT, szFormat, ARRAYSIZE(szFormat) ) )
                        {
                            nameError = GENNAME_TEMPLATE_INVALID;
                        }
                        else
                        {
                            nameError = GenerateSample( szFormat, szSample, &maxLength );

                            Assert( (nameError == GENNAME_NO_ERROR) ||
                                    (nameError == GENNAME_TEMPLATE_INVALID) ||
                                    (nameError == GENNAME_NAME_TOO_LONG) );

                        }

                        if ( DnsValidateDnsName_W( szSample ) != NO_ERROR ) {
                            nameError = GENNAME_TEMPLATE_INVALID;
                            wcscpy( szSample, UNKNOWN_INVALID_TEMPLATE );
                        }

                        SetDlgItemText( hDlg, IDC_E_SAMPLE, szSample );
                        EnableWindow( GetDlgItem( hDlg, IDOK ),
                                      (BOOL)(nameError != GENNAME_TEMPLATE_INVALID) );
                    }
                    break;
                }
            }
            break; // WM_COMMAND

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aAdvancedHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aAdvancedHelpMap );
            break;
        }
    }

    return FALSE;
}

HRESULT
THISCLASS::_GetCurrentNamingPolicy( LPWSTR * ppszNamingPolicy )
{
    TraceClsFunc( "_GetCurrentNamingPolicy( )\n" );

    if ( !ppszNamingPolicy )
        HRETURN(E_POINTER);

    HRESULT hr = S_OK;
    INT iItem = ComboBox_GetCurSel( GetDlgItem( _hDlg, IDC_CB_NAMINGPOLICY ) );

    if ( iItem == - 1 )
    {
        *ppszNamingPolicy = NULL;
        HRETURN(S_FALSE);
    }
    else if ( iItem == _iCustomId && _pszCustomNamingPolicy )
    {
        if ( *ppszNamingPolicy == _pszCustomNamingPolicy )
            HRETURN(S_FALSE);

        *ppszNamingPolicy = TraceStrDup( _pszCustomNamingPolicy );
    }
    else if ( iItem != _iCustomId )
    {
        WCHAR   szSamples[ SAMPLES_LIST_SIZE ];
        LPWSTR  pszFormat = NULL;
        LPWSTR  pszNext = szSamples;
        DWORD   dw;

        dw = LoadString( g_hInstance, IDS_SAMPLENAMINGPOLICY, szSamples, ARRAYSIZE( szSamples ) );
        Assert( dw );

        for( ; *pszNext && iItem >= 0; iItem-- )
        {
            // find the end of the friendly name which is terminated by a ';'
            pszNext = StrChr( pszNext, L';' );
            if ( !pszNext )
            {
                pszFormat = NULL;
                break;
            }

            pszNext++;

            pszFormat = pszNext;

            // skip the internal string
            pszNext = StrChr( pszNext, L';' );
            if ( !pszNext )
            {
                pszFormat = NULL;
                break;
            }

            // next string please...
            pszNext++;
        }
        Assert( pszFormat );

        pszNext = StrChr( pszFormat, L';' );
        Assert( pszNext );
        *pszNext = L'\0';

        *ppszNamingPolicy = TraceStrDup( pszFormat );
    }

    if ( !*ppszNamingPolicy )
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN(hr);
}

typedef enum {
    MOUP_SYNTACTICAL,
    MOUP_LOCAL_DC,
    MOUP_OTHER_DC,
    MOUP_GC
} CRACK_TYPE;

HRESULT
THISCLASS::_MakeOUPretty( DS_NAME_FORMAT inFlag, DS_NAME_FORMAT outFlag, LPWSTR *ppszOU )
{
    TraceClsFunc("_MakeOUPretty()\n");
    Assert( ppszOU );
    if ( !*ppszOU ) {
        HRETURN(S_FALSE); // nothing in... nothing out
    }

    HRESULT hr;
    PDS_NAME_RESULT pResults;
    DWORD dw;
    HANDLE hDS;
    CRACK_TYPE crackType;

    //
    // We might need to call DsCrackNames up to four times. The logic goes like this:
    //
    //  Call DsCrackNames to attempt a local-only syntactical mapping.
    //  If that fails with DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING,
    //      Try the local DC.
    //      If can't find the local DC,
    //          Try the GC.
    //      Else if local DC failed with DS_NAME_ERROR_DOMAIN_ONLY,
    //          Try the DC pointed to by the local DC.
    //          If can't find the other DC,
    //              Try the GC.
    //

    crackType = MOUP_SYNTACTICAL;
    hDS = NULL;
    pResults = NULL;

    while ( TRUE ) {

        //
        // If we have a bind handle left over from the previous pass, unbind it now.
        //

        if ( hDS != NULL ) {
            DsUnBind( &hDS );
            hDS = NULL;
        }

        //
        // Bind to the DC or GC.
        //

        if ( crackType == MOUP_SYNTACTICAL ) {

            hDS = NULL;

        } else if ( crackType == MOUP_LOCAL_DC ) {

            //
            // Find a local DC.
            //

            PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;

            dw = DsGetDcName(
                    NULL,
                    NULL,
                    NULL,
                    NULL, 
                    DS_DIRECTORY_SERVICE_REQUIRED | DS_IP_REQUIRED,
                    &pDCInfo
                    );

            if ( dw != NO_ERROR ) {

                //
                // Couldn't find a DC. Try the GC.
                //

                crackType = MOUP_GC;
                continue;
            }

            Assert( pDCInfo != NULL );

            dw = DsBind( pDCInfo->DomainControllerName, NULL, &hDS );

            NetApiBufferFree( pDCInfo );

            if ( dw != NO_ERROR ) {

                //
                // Couldn't bind to the DC. Try the GC.
                //

                crackType = MOUP_GC;
                continue;
            }

        } else if ( crackType == MOUP_OTHER_DC ) {

            //
            // We need to talk to the DC that the local DC referred us to.
            //

            dw = DsBind( NULL, pResults->rItems[0].pDomain, &hDS );

            if ( dw != NO_ERROR ) {

                //
                // Couldn't bind to the DC. Try the GC.
                //

                crackType = MOUP_GC;
                continue;
            }

        } else {

            //
            // Bind to the GC.
            //

            dw = DsBind( NULL, NULL, &hDS );

            if ( dw != NO_ERROR ) {

                //
                // Couldn't bind to the GC. Give up.
                //

                hr = HRESULT_FROM_WIN32( dw );
                break;
            }
        }

        //
        // If we have pResults left over from a previous call, free it now.
        //

        if ( pResults != NULL ) {
            DsFreeNameResult( pResults );
            pResults = NULL;
        }

        //
        // Try to crack the name.
        //

        dw = DsCrackNames( hDS,
                           (crackType == MOUP_SYNTACTICAL) ?
                                DS_NAME_FLAG_SYNTACTICAL_ONLY : DS_NAME_NO_FLAGS,
                           inFlag,
                           outFlag,
                           1,
                           ppszOU,
                           &pResults );
    
        if ( dw != NO_ERROR ) {

            if ( crackType == MOUP_SYNTACTICAL ) {
            
                //
                // We were doing a syntactical check. We don't expect this to fail.
                //

                hr = HRESULT_FROM_WIN32( dw );
                break;

            } else if ( crackType == MOUP_LOCAL_DC ) {

                //
                // We had trouble getting to the local DC. Try the GC.
                //

                crackType = MOUP_GC;
                continue;


            } else if ( crackType == MOUP_OTHER_DC ) {

                //
                // We had trouble getting to the other DC. Try the GC.
                //

                crackType = MOUP_GC;
                continue;


            } else {

                //
                // We had trouble getting to the GC. Give up.
                //

                hr = HRESULT_FROM_WIN32( dw );
                break;
            }

        } else {
        
            Assert( pResults != NULL );
            Assert( pResults->cItems == 1 );

            if ( pResults->rItems[0].status == DS_NAME_NO_ERROR ) {

                //
                // We've got what we wanted.
                //

                hr = S_OK;
                break;
            }

            if ( crackType == MOUP_SYNTACTICAL ) {
            
                if ( pResults->rItems[0].status != DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING ) {

                    //
                    // Unexpected error. Give up.
                    //

                    hr = HRESULT_FROM_WIN32( ERROR_DS_GENERIC_ERROR );
                    break;
                }

                //
                // Try the local DC next.
                //

                crackType = MOUP_LOCAL_DC;
                continue;

            } else if ( crackType == MOUP_LOCAL_DC ) {

                if ( pResults->rItems[0].status != DS_NAME_ERROR_DOMAIN_ONLY ) {

                    //
                    // Unexpected error. Give up.
                    //

                    hr = HRESULT_FROM_WIN32( ERROR_DS_GENERIC_ERROR );
                    break;
                }

                //
                // Try the other DC next.
                //

                crackType = MOUP_OTHER_DC;
                continue;

            } else if ( crackType == MOUP_OTHER_DC ) {

                //
                // Unexpected error. Give up.
                //

                hr = HRESULT_FROM_WIN32( ERROR_DS_GENERIC_ERROR );
                break;

            } else {

                //
                // Couldn't get what we need from the GC. Give up.
                //

                hr = HRESULT_FROM_WIN32( ERROR_DS_GENERIC_ERROR );
                break;
            }
        }
    }

    if ( hr == S_OK ) {

        Assert( pResults != NULL );
        Assert( pResults->cItems == 1 );
        Assert( pResults->rItems[0].status == DS_NAME_NO_ERROR );
        Assert( pResults->rItems[0].pName );

        LPWSTR psz = TraceStrDup( pResults->rItems[0].pName );
        if ( psz != NULL ) {
            TraceFree( *ppszOU );
            *ppszOU = psz;
        } else {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    if ( hDS != NULL ) {
        DsUnBind( &hDS );
    }
    if ( pResults != NULL ) {
        DsFreeNameResult( pResults );
    }

    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\register.h ===
//
// Copyright 1997 - Microsoft
//

//
// REGISTER.H - Registery functions
//

#ifndef _REGISTER_H_
#define _REGISTER_H_

LONG
RegisterDll( BOOL fCreate );

#endif // _REGISTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by adminui.rc
//
#define IDS_BIGFONTSIZE                 2
#define IDS_SAMPLENAMINGPOLICY          3
#define IDS_WORD_CUSTOM                 4
#define IDS_COLUMN1                     5
#define IDS_COLUMN2                     6
#define IDS_COLUMN3                     7
#define IDS_COLUMN4                     8
#define IDS_BROWSEFOROU_CAPTION         9
#define IDS_BROWSEFOROU_TITLE           10
#define IDS_NOT_AVAILABLE               11
#define IDS_CLIENTS_COLUMN1             12
#define IDS_CLIENTS_COLUMN2             13
#define IDC_CLIENTS_COLUMN3             14
#define IDS_OS_COLUMN1                  15
#define IDS_OS_COLUMN2                  16
#define IDS_OS_COLUMN3                  17
#define IDS_OS_COLUMN4                  18
#define IDS_OS_COLUMN5                  19
#define IDS_ERROR_ACCOUNTEXISTS         22
#define IDC_ERROR_CREATINGACCOUNT_TITLE 23
#define IDS_ERROR                       24
#define IDS_ERROR_WRITINGTOCOMPUTERACCOUNT 25
#define IDS_ERROR_READINGCOMPUTERACCOUNT 26
#define IDS_ERROR_OPENNINGGROUPOBJECT   27
#define IDS_ERROR_DELETINGCOMPUTERDIRECTORY 28
#define IDS_ERROR_REMOVINGCOMPUTERACCOUNT 29
#define IDS_COULDNOTCONTACTSERVER_CAPTION 30
#define IDS_COULDNOTCONTACTSERVER_TEXT  31
#define IDS_AREYOUSURE_CAPTION          33
#define IDS_DELETESIF_TEXT              34
#define IDS_ADVANCED_NAMING_RESTRICTIONS_TITLE 35
#define IDS_ADVANCED_NAMING_RESTRICTIONS_TEXT 36
#define IDS_DNS_NAME_LENGTH_WARNING_TITLE 37
#define IDS_DNS_NAME_LENGTH_WARNING_TEXT 38
#define IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE 39
#define IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT 40
#define IDS_UNABLETODETERMINESERVERNAME_TITLE 41
#define IDS_UNABLETODETERMINESERVERNAME_TEXT 42
#define IDS_MANAGED_PC                  43
#define IDS_ANY_SERVER                  44
#define IDS_REMOTE_INSTALL_CLIENTS      45
#define IDS_GUID                        46
#define IDS_HOST_SERVER                 47
#define IDS_NAME                        48
#define IDS_INVALID_GUID_CAPTION        49
#define IDS_INVALID_GUID_TEXT           50
#define IDS_ADD_DOT_DOT_DOT             51
#define IDS_PAGE1_TITLE                 52
#define IDS_PAGE1_SUBTITLE              53
#define IDS_PAGE2_TITLE                 54
#define IDS_PAGE2_SUBTITLE              55
#define IDS_PAGE3_TITLE                 56
#define IDS_PAGE3_SUBTITLE              57
#define IDS_PAGE4_TITLE                 58
#define IDS_PAGE4_SUBTITLE              59
#define IDS_PAGE5_TITLE                 60
#define IDS_PAGE5_SUBTITLE              61
#define IDS_PAGE6_TITLE                 62
#define IDS_PAGE6_SUBTITLE              63
#define IDS_PAGE7_TITLE                 64
#define IDS_PAGE7_SUBTITLE              65
#define IDS_PAGE8_TITLE                 66
#define IDS_PAGE8_SUBTITLE              67
#define IDS_CANCELCAPTION               68
#define IDS_CANCELTEXT                  69
#define IDS_NA                          70
#define IDS_NOTARISERVER_CAPTION        71
#define IDS_NOTARISERVER_TEXT           72
#define IDS_ERROR_COPYING_FILE          73
#define IDS_PAGE9_TITLE                 74
#define IDS_PAGE9_SUBTITLE              75
#define IDS_PAGE10_TITLE                76
#define IDS_PAGE10_SUBTITLE             77
#define IDS_RISETUP_FAILED_TO_START     78
#define IDS_MUST_BE_FLAT_CAPTION        79
#define IDS_MUST_BE_FLAT_TEXT           80
#define IDC_NOT_A_BINL_SERVER           81
#define IDS_USER_LOCATION               82
#define IDS_BROWSE_FOR_BINL_SERVER_TITLE 83
#define IDS_INVALID_PARTIAL_GUID_TEXT   84
#define IDS_OFN_SIF_FILTER              85
#define IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TITLE 86
#define IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TEXT 87
#define IDS_OVERWRITE_CAPTION           88
#define IDS_OVERWRITE_TEXT              89
#define IDC_IMPROPER_EXTENSION_CAPTION  90
#define IDC_IMPROPER_EXTENSION_TEXT     91
#define IDS_CUSTOM_NAMING_DESCRIPTION   92
#define IDS_PROBLEM_FINDING_SERVER_TITLE 93
#define IDS_PROBLEM_FINDING_SERVER_TEXT 94
#define IDS_REMOVING_GUID_TITLE         95
#define IDS_REMOVING_GUID_TEXT          96
#define IDS_PROBLEM_FINDING_SERVER_CONFIRM_TEXT 97
#define IDI_RBSICON                     101
#define IDD_ADVANCEDNAMIMG              104
#define IDD_PROP_INTELLIMIRROR_OS       107
#define IDD_SIF_PROP_IMAGES             108
#define IDD_PROP_INTELLIMIRROR_SERVER   111
#define IDD_PROP_TOOLS                  112
#define IDD_ADD_PAGE4                   113
#define IDD_PROP_INTELLIMIRROR_CLIENT   115
#define IDD_PROP_NEW_CLIENTS            116
#define IDD_ADD_PAGE2                   117
#define IDD_MANAGED_WIZARD_PAGE         120
#define IDD_HOST_SERVER_PAGE            121
#define IDD_GUID_QUERY_FORM             122
#define IDD_DUPLICATE_GUID              123
#define IDD_ADD_PAGE1                   124
#define IDD_ADD_PAGE3                   125
#define IDB_HEADER                      126
#define IDD_ADD_PAGE5                   126
#define IDD_ADD_PAGE6                   127
#define IDD_ADD_PAGE7                   128
#define IDD_ADD_PAGE8                   129
#define IDD_ADD_PAGE9                   130
#define IDD_ADD_PAGE10                  131
#define IDD_SIF_PROP_TOOLS              132
#define IDD_SERVER_QUERY_FORM           133
#define IDS_REMOTE_INSTALL_SERVERS      134
#define IDS_PROBLEM_SEARCHING_TEXT      135
#define IDS_PROBLEM_SEARCHING_TITLE     136
#define IDC_L_TOOLS                     1000
#define IDC_B_REFRESH                   1011
#define IDC_E_HELP                      1013
#define IDC_E_SERVER                    1013
#define IDC_C_RESPOND                   1015
#define IDC_C_KNOWNCLIENTS              1016
#define IDC_B_CLIENTS                   1020
#define IDC_B_SERVICE                   1021
#define IDC_L_OS                        1024
#define IDC_E_SERVERNAME                1027
#define IDC_E_GUID                      1028
#define IDC_B_SERVER                    1030
#define IDC_CB_NAMINGPOLICY             1032
#define IDC_B_ADVANCED                  1033
#define IDC_E_NEWMACHINEOU              1034
#define IDC_B_BROWSE                    1035
#define IDC_R_SAMEASUSER                1036
#define IDC_R_DOMAINDEFAULT             1037
#define IDC_R_SPECIFICLOCATION          1038
#define IDC_B_ADD                       1040
#define IDC_B_REMOVE                    1041
#define IDC_B_PROPERTIES                1042
#define IDC_E_FORMAT                    1048
#define IDC_E_DESCRIPTION               1056
#define IDC_B_ANYSERVER                 1062
#define IDC_B_SPECIFICSERVER            1064
#define IDC_S_VERSION                   1070
#define IDC_S_LANGUAGE                  1071
#define IDC_S_LASTMODIFIED              1072
#define IDC_S_IMAGETYPE                 1073
#define IDC_S_DIRECTORY                 1075
#define IDC_B_CHECKSERVER               1078
#define IDC_C_MANAGED_PC                1079
#define IDC_B_QUERY                     1081
#define IDC_B_ADDSIF                    1083
#define IDC_B_NEWIMAGE                  1084
#define IDC_B_FROMSAMPLES               1086
#define IDC_B_LOCATION                  1088
#define IDC_E_FILEPATH                  1091
#define IDC_L_OSES                      1092
#define IDC_E_SOURCE                    1093
#define IDC_E_DESTINATION               1094
#define IDC_L_SIFS                      1096
#define IDC_E_FILENAME                  1097
#define IDC_E_HELPTEXT                  1099
#define IDC_S_SOURCEIMAGE               1100
#define IDC_S_DESTIMAGE                 1101
#define IDC_E_SAMPLE                    1103
#define IDC_S_CREATEIN                  1105
#define IDC_S_ICON                      1106
#define IDC_G_CHECKSERVER               1109
#define IDC_G_CLIENTSERVICING           1110
#define IDC_G_CLIENTACCOUNTLOCATION     1111
#define IDC_G_NAMINGFORMAT              1112
#define IDC_G_IMAGEDETAILS              1113
#define IDC_BUTTON1                     1114
#define IDC_B_SEARCH                    IDC_B_BROWSE
#define IDI_COMPUTER                    4097

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1115
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\qi.h ===
//
// Copyright 1997 - Microsoft
//

//
// QI.H - Handles the query interface functions
//

#ifndef _QI_H_
#define _QI_H_

///////////////////////////////////////
//  
// QueryInterface Definitions
//
typedef struct {
    LPUNKNOWN          pvtbl;   // "punk" - pointer to a specific interface
    const struct _GUID *riid;   // GUID of interfaace

#ifdef DEBUG
    LPCTSTR pszName;    // Text name of interface - used to make sure tables are consistant
    DWORD   cFunctions; // Number of function entries in this interface's vtbl.
#endif // DEBUG

} QITABLE, *LPQITABLE, QIENTRY, *LPQIENTRY;

///////////////////////////////////////
//
// Quick-Lookup table declaration macro
//
#define DECLARE_QITABLE( _Class) QITABLE _QITable[ARRAYSIZE(QIT_##_Class)];

///////////////////////////////////////
//
// Quick-Lookup table construction macros
//
#ifdef DEBUG
#define DEFINE_QI( _iface, _name, _nFunctions ) \
    { NULL, &_iface, TEXT(#_name), _nFunctions },
#else // RETAIL
#define DEFINE_QI( _iface, _name, _nFunctions ) \
    { NULL, &_iface },
#endif // DEBUG

#define BEGIN_QITABLE( _Class ) \
    static const QITABLE QIT_##_Class[] = { DEFINE_QI( IID_IUnknown, IUnknown, 0 )

#define END_QITABLE  { NULL, NULL } };

///////////////////////////////////////
//
// Common Quick-Lookup QueryInterface( )
//
extern HRESULT
QueryInterface( 
    LPVOID    that,
    LPQITABLE pQI,
    REFIID    riid, 
    LPVOID   *ppv );

#ifdef DEBUG
///////////////////////////////////////
//
// BEGIN DEBUG 
//

#ifndef NO_TRACE_INTERFACES
///////////////////////////////////////
//
// BEGIN DEBUG INTERFACE TRACKING
//
#pragma message("BUILD: Interface tracking enabled")

///////////////////////////////////////
//
// Debug Quick-Lookup QI Interface Macros
//

// Begins construction of the runtime Quick-Lookup table.
// Adds IUnknown by default.
#define BEGIN_QITABLE_IMP( _Class, _IUnknownPrimaryInterface ) \
    int _i = 0; \
    CopyMemory( _QITable, &QIT_##_Class, sizeof( QIT_##_Class ) ); \
	_QITable[_i].pvtbl = (_IUnknownPrimaryInterface *) this;

// Checks that the QIENTRY matches the current QITABLE_IMP.
#define QITABLE_IMP( _Interface ) \
    _i++; \
    _QITable[_i].pvtbl = (_Interface *) this; \
{   int ___i = lstrcmp( TEXT(#_Interface), _QITable[_i].pszName ); \
    AssertMsg( ___i == 0, \
        "DEFINE_QIs and QITABLE_IMPs don't match. Incorrect order.\n" ); }

// Verifies that the number of entries in the QITABLE match
// the number of QITABLE_IMP in the runtime section
#define END_QITABLE_IMP( _Class ) \
    AssertMsg( _i == ( ARRAYSIZE( QIT_##_Class ) - 2 ), \
        "The number of DEFINE_QIs and QITABLE_IMPs don't match.\n" ); \
    LPVOID pCITracker; \
    TraceMsgDo( pCITracker = CITracker_CreateInstance( _QITable ), "0x%08x" );

///////////////////////////////////////
//
// CITracker Structures
//
typedef HRESULT (CALLBACK *LPFNQUERYINTERFACE)(
    LPUNKNOWN punk, 
    REFIID    riid, 
    LPVOID*   ppv );

typedef ULONG (CALLBACK *LPFNADDREF)(
    LPUNKNOWN punk );

typedef ULONG (CALLBACK *LPFNRELEASE)( 
    LPUNKNOWN punk );

typedef struct __vtbl {
    LPFNQUERYINTERFACE lpfnQueryInterface;
    LPFNADDREF         lpfnAddRef;
    LPFNRELEASE        lpfnRelease;
} VTBL, *LPVTBL;

typedef struct __vtbl2 {
    LPCTSTR            pszInterface;
    UINT               cRef;
    LPUNKNOWN          punk;
    LPVTBL             pOrginalVtbl;
    LPUNKNOWN          pITracker;
    // These must be last and in this order QI, AddRef, Release.
    LPFNQUERYINTERFACE lpfnQueryInterface;
    LPFNADDREF         lpfnAddRef;
    LPFNRELEASE        lpfnRelease;
} VTBL2, *LPVTBL2;

#define VTBL2OFFSET ( sizeof( VTBL2 ) - ( 3 * sizeof(LPVOID) ) )

///////////////////////////////////////
//
// CITracker Functions
//
LPVOID
CITracker_CreateInstance( 
    LPQITABLE pQITable );   // QI Table of the object
    
///////////////////////////////////////
//
// CCITracker Class
//
//
class
CITracker:
    public IUnknown
{
private: // Members
    VTBL2 _vtbl;

private: // Methods
    CITracker( );
    ~CITracker( );
    STDMETHOD(Init)( LPQITABLE pQITable );

public: // Methods
    friend LPVOID CITracker_CreateInstance( LPQITABLE pQITable );

    // IUnknown (Translates to IUnknown2)
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IUnknown2 (Real Implementation)
    STDMETHOD(_QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, _AddRef)(void);
    STDMETHOD_(ULONG, _Release)(void);
};

typedef CITracker* LPITRACKER;

//
// END DEBUG INTERFACE TRACKING
//
///////////////////////////////////////
#else // !NO_TRACE_INTERFACES
///////////////////////////////////////
//
// BEGIN DEBUG WITHOUT INTERFACE TRACKING
//

// Begins construction of the runtime Quick-Lookup table.
// Adds IUnknown by default.
#define BEGIN_QITABLE_IMP( _Class, _IUnknownPrimaryInterface ) \
    int _i = 0; \
    LPVOID pCITracker; \
    CopyMemory( _QITable, &QIT_##_Class, sizeof( QIT_##_Class ) ); \
	_QITable[_i].pvtbl = (_IUnknownPrimaryInterface *) this;

// Adds a CITracker to interface and checks that the QIENRTY
// matches the current QITABLE_IMP.
#define QITABLE_IMP( _Interface ) \
    _i++; \
    _QITable[_i].pvtbl = (_Interface *) this; \
{   int ___i = lstrcmp( TEXT(#_Interface), _QITable[_i].pszName ); \
    AssertMsg( ___i == 0, \
        "DEFINE_QIs and QITABLE_IMPs don't match. Incorrect order.\n" ); }

// Verifies that the number of entries in the QITABLE match
// the number of QITABLE_IMP in the runtime section
#define END_QITABLE_IMP( _Class )\
    AssertMsg( _i == ( ARRAYSIZE( QIT_##_Class ) - 2 ), \
        "The number of DEFINE_QIs and QITABLE_IMPs don't match.\n" );

//
// END DEBUG INTERFACE TRACKING
//
///////////////////////////////////////
#endif // NO_TRACE_INTERFACES

#else
///////////////////////////////////////
//
// BEGIN RETAIL
//

//
// Debug Macros -> Retail Code
//
#define BEGIN_QITABLE_IMP( _Class, _IUnknownPrimaryInterface ) \
    int _i = 0; \
    CopyMemory( _QITable, &QIT_##_Class, sizeof( QIT_##_Class ) ); \
	_QITable[_i++].pvtbl = (_IUnknownPrimaryInterface *) this;

#define QITABLE_IMP( _Interface ) \
    _QITable[_i++].pvtbl = (_Interface *) this;

#define END_QITABLE_IMP( _Class )


//
// END RETAIL
//
///////////////////////////////////////
#endif // DEBUG

#endif _QI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\querypb.h ===
//
// Copyright 1997-199 - Microsoft Corporation
//

//
// QUERYPB.H - Property Bag for sending arguments to the DSFind Query Form
//

// QITable
BEGIN_QITABLE( QueryPropertyBag )
DEFINE_QI( IID_IPropertyBag, IPropertyBag, 3 )
END_QITABLE

// Definitions
LPVOID
QueryPropertyBag_CreateInstance( void );

class QueryPropertyBag : public IPropertyBag
{
    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( QueryPropertyBag );

    LPWSTR      _pszServerName;
    LPWSTR      _pszClientGuid;

    QueryPropertyBag( );
    ~QueryPropertyBag( );
    HRESULT Init( );

public:
    friend LPVOID QueryPropertyBag_CreateInstance( void );

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IPropertyBag methods
    STDMETHOD(Read)( LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog );
    STDMETHOD(Write)( LPCOLESTR pszPropName, VARIANT *pVar );
};


typedef class QueryPropertyBag *LPQUERYPROPERTYBAG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\register.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// REGISTER.CPP - Registery functions
//

#include "pch.h"
#include "register.h"
#include <advpub.h>
#include <dsquery.h>

DEFINE_MODULE("IMADMUI")

//
// RegisterQueryForm( )
//
HRESULT
RegisterQueryForm( 
    BOOL fCreate,
    const GUID *pclsid )
{
    TraceFunc( "RegisterQueryForm(" );
    TraceMsg( TF_FUNC, " %s )\n", BOOLTOSTRING( fCreate ) );

    HRESULT hr = E_FAIL;
    int     i = 0;
    HKEY    hkclsid;

    HKEY     hkey;
    HKEY     hkeyForms;
    DWORD    cbSize;
    DWORD    dwDisposition;
    DWORD    dwFlags = 0x2;
    LPOLESTR pszCLSID;
    LPTSTR   psz;

    //
    // Open the "CLSID" under HKCR
    //
    if ( ERROR_SUCCESS !=
         RegOpenKey( HKEY_CLASSES_ROOT, TEXT("CLSID"), &hkclsid ) )
    {
        hr = E_FAIL;
        goto Error;
    }

    //
    // Convert the CLSID to a string
    //
    hr = THR( StringFromCLSID( CLSID_DsQuery, &pszCLSID ) );
    if (hr)
        goto Error;

#ifdef UNICODE
    psz = pszCLSID;
#else // ASCII
    CHAR szCLSID[ 40 ];

    wcstombs( szCLSID, pszCLSID, lstrlenW( pszCLSID ) + 1 );
    psz = szCLSID;
#endif // UNICODE

    //
    // Create the "CLSID" key
    //
    if ( ERROR_SUCCESS != RegOpenKey( hkclsid, psz, &hkey ))
    {
        hr = E_FAIL;
        goto Error;
    }
    CoTaskMemFree( pszCLSID );

    //
    // Create "Forms"
    //
    if ( ERROR_SUCCESS !=
        RegCreateKeyEx( hkey, 
                        TEXT("Forms"), 
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_CREATE_SUB_KEY | KEY_WRITE, 
                        NULL,
                        &hkeyForms,
                        &dwDisposition ) )
    {
        hr = E_FAIL;
        goto Error;
    }

    //
    // Convert the CLSID to a string
    //
    hr = THR( StringFromCLSID( (IID &)*pclsid, &pszCLSID ) );
    if (hr)
        goto Error;

#ifdef UNICODE
    psz = pszCLSID;
#else // ASCII
    CHAR szCLSID[ 40 ];

    wcstombs( szCLSID, pszCLSID, lstrlenW( pszCLSID ) + 1 );
    psz = szCLSID;
#endif // UNICODE

    //
    // Create the "CLSID" key under the forms key
    //
    if ( ERROR_SUCCESS != 
        RegCreateKeyEx( hkeyForms, 
                        psz, 
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_CREATE_SUB_KEY | KEY_WRITE, 
                        NULL,
                        &hkey,
                        &dwDisposition ) )
    {
        hr = E_FAIL;
        goto Error;
    }

    //
    // Set "CLSID" to the "CLSID" key
    //
    cbSize = ( lstrlen( psz ) + 1 ) * sizeof(TCHAR);
    RegSetValueEx( hkey, L"CLSID", 0, REG_SZ, (LPBYTE) psz, cbSize );

    //
    // Set "FLAGS" to 0x2
    //
    cbSize = sizeof(dwFlags);
    RegSetValueEx( hkey, L"Flags", 0, REG_DWORD, (LPBYTE) &dwFlags, cbSize );

    //
    // Cleanup
    //
    RegCloseKey( hkeyForms );
    RegCloseKey( hkey );
    RegCloseKey( hkclsid );
    CoTaskMemFree( pszCLSID );

Error:
    HRETURN(hr);
}

//
// RegisterDll()
//
LONG
RegisterDll( BOOL fCreate )
{
    TraceFunc( "RegisterDll(" );
    TraceMsg( TF_FUNC, " %s )\n", BOOLTOSTRING( fCreate ) );

    HRESULT hr = E_FAIL;
    int     i = 0;
    HKEY    hkclsid;

    static const TCHAR szApartment[] = TEXT("Apartment");
    static const TCHAR szInProcServer32[] = TEXT("InProcServer32");
    static const TCHAR szThreadingModel[] = TEXT("ThreadingModel");

    //
    // Open the "CLSID" under HKCR
    //
    if ( ERROR_SUCCESS !=
         RegOpenKey( HKEY_CLASSES_ROOT, TEXT("CLSID"), &hkclsid ) )
    {
        hr = E_FAIL;
        goto Error;
    }

    //
    // Loop until we have created all the keys for our classes.
    //
    while ( g_DllClasses[ i ].rclsid != NULL )
    {
        HKEY     hkey;
        HKEY     hkeyInProc;
        DWORD    cbSize;
        DWORD    dwDisposition;
        LPOLESTR pszCLSID;
        LPTSTR   psz;

        TraceMsg( TF_ALWAYS, "Registering %s = ", g_DllClasses[i].pszName );
        TraceMsgGUID( TF_ALWAYS, (*g_DllClasses[ i ].rclsid) );
        TraceMsg( TF_ALWAYS, "\n" );

        //
        // Convert the CLSID to a string
        //
        hr = THR( StringFromCLSID( *g_DllClasses[ i ].rclsid, &pszCLSID ) );
        if (hr)
            goto Error;

#ifdef UNICODE
        psz = pszCLSID;
#else // ASCII
        CHAR szCLSID[ 40 ];

        wcstombs( szCLSID, pszCLSID, lstrlenW( pszCLSID ) + 1 );
        psz = szCLSID;
#endif // UNICODE

        //
        // Create the "CLSID" key
        //
        if ( ERROR_SUCCESS != 
            RegCreateKeyEx( hkclsid, 
                            psz, 
                            0, 
                            NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_CREATE_SUB_KEY | KEY_WRITE, 
                            NULL,
                            &hkey,
                            &dwDisposition ) )
        {
            hr = E_FAIL;
            goto Error;
        }

        //
        // Set "Default" for the CLSID
        //
        cbSize = ( lstrlen( g_DllClasses[i].pszName ) + 1 ) * sizeof(TCHAR);
        RegSetValueEx( hkey, NULL, 0, REG_SZ, (LPBYTE) g_DllClasses[i].pszName, cbSize );

        //
        // Create "InProcServer32"
        //
        if ( ERROR_SUCCESS !=
            RegCreateKeyEx( hkey, 
                            szInProcServer32, 
                            0, 
                            NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_CREATE_SUB_KEY | KEY_WRITE, 
                            NULL,
                            &hkeyInProc,
                            &dwDisposition ) )
        {
            hr = E_FAIL;
            goto Error;
        }

        //
        // Set "Default" in the InProcServer32
        //
        cbSize = ( lstrlen( g_szDllFilename ) + 1 ) * sizeof(TCHAR);
        RegSetValueEx( hkeyInProc, NULL, 0, REG_SZ, (LPBYTE) g_szDllFilename, cbSize );

        //
        // Set "ThreadModel" to "Apartment"
        //
        cbSize = sizeof( szApartment );
        RegSetValueEx( hkeyInProc, szThreadingModel, 0, REG_SZ, (LPBYTE) szApartment, cbSize );          

        //
        // Cleanup
        //
        RegCloseKey( hkeyInProc );
        RegCloseKey( hkey );
        CoTaskMemFree( pszCLSID );

        //
        // Next!
        //
        i++;
    }

    RegCloseKey( hkclsid );

    //
    // Ignore failure from RegisterQueryForm. It fails during Setup because
    // some shell stuff isn't registered yet.
    //

    RegisterQueryForm( fCreate, &CLSID_RIQueryForm );
    RegisterQueryForm( fCreate, &CLSID_RISrvQueryForm );
    
    hr = NOERROR;

Error:
    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\querypb.cpp ===
//
// Copyright 1997-199 - Microsoft Corporation
//

//
// QUERYPB.CPP - Property Bag for sending arguments to the DSFind Query Form
//

#include "pch.h"

#include "querypb.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("QueryPropertyBag")
#define THISCLASS QueryPropertyBag
#define LPTHISCLASS LPQUERYPROPERTYBAG

//
// QueryPropertyBag_CreateInstance( )
//
LPVOID
QueryPropertyBag_CreateInstance( void )
{
    TraceFunc( "QueryPropertyBag_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    if ( !lpcc ) {
        RETURN(lpcc);
    }

    HRESULT hr = THR( lpcc->Init( ) );
    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN(lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "QueryPropertyBag( )\n" );

    InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init( )
//
HRESULT
THISCLASS::Init( )
{
    TraceClsFunc( "Init( )\n" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    BEGIN_QITABLE_IMP( QueryPropertyBag, IPropertyBag );
    QITABLE_IMP( IPropertyBag );
    END_QITABLE_IMP( QueryPropertyBag );
    Assert( _cRef == 0);
    AddRef( );

    Assert( !_pszServerName );
    Assert( !_pszClientGuid );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~QueryPropertyBag( )\n" );

    if ( _pszServerName )
        TraceFree( _pszServerName );

    if ( _pszClientGuid )
        TraceFree( _pszClientGuid );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
}

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface(
    REFIID riid,
    LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}

// ************************************************************************
//
// IQueryForm
//
// ************************************************************************

STDMETHODIMP
THISCLASS::Read(
    LPCOLESTR pszPropName,
    VARIANT *pVar,
    IErrorLog *pErrorLog )
{
    TraceClsFunc("Read( )\n" );

    HRESULT hr;

    if ( !pszPropName || !pVar )
        HRETURN(E_POINTER);

    if ( V_VT( pVar ) != VT_EMPTY )
        HRETURN(OLE_E_CANTCONVERT);

    if ( StrCmpI( pszPropName, L"ServerName" ) == 0 )
    {
        if ( !_pszServerName )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
        }
        else
        {
            V_VT( pVar ) = VT_BSTR;
            V_BSTR( pVar ) = SysAllocString( _pszServerName );
            hr = S_OK;
        }
    }
    else if ( StrCmpI( pszPropName, L"ClientGuid" ) == 0 )
    {
        if ( !_pszClientGuid )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
        }
        else
        {
            V_VT( pVar ) = VT_BSTR;
            V_BSTR( pVar ) = SysAllocString( _pszClientGuid );
            hr = S_OK;
        }
    }
    else
    {   // something unexpected came in
        hr = THR(E_INVALIDARG);
    }

    HRETURN(hr);
}

STDMETHODIMP
THISCLASS::Write(
    LPCOLESTR pszPropName,
    VARIANT *pVar )
{
    TraceClsFunc("Write( )\n" );

    HRESULT hr;

    if ( !pszPropName || !pVar )
        HRETURN(E_POINTER);

    if ( V_VT( pVar ) != VT_BSTR )
        HRETURN(OLE_E_CANTCONVERT);

    if ( StrCmpI( pszPropName, L"ServerName" ) == 0 )
    {
        if ( _pszServerName )
        {
            TraceFree( _pszServerName );
        }

        _pszServerName = TraceStrDup( V_BSTR( pVar ) );
        if ( _pszServerName )
        {
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if ( StrCmpI( pszPropName, L"ClientGuid" ) == 0 )
    {
        if ( _pszClientGuid )
        {
            TraceFree( _pszClientGuid );
        }

        _pszClientGuid = TraceStrDup( V_BSTR( pVar) );
        if ( _pszClientGuid )
        {
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {   // something unexpected came in
        hr = THR(E_INVALIDARG);
    }

    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\qi.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// QI.CPP - Handles the QueryInterface
//

#include "pch.h"

//
// Begin Class Definitions
//
DEFINE_MODULE("IMADMUI")

//
// QueryInterface()
//
extern HRESULT
QueryInterface( 
    LPVOID    that,
    LPQITABLE pQI,
    REFIID    riid, 
    LPVOID*   ppv )
{
    TraceMsg( TF_FUNC, "[IUnknown] QueryInterface( riid=" );
    HRESULT hr = E_NOINTERFACE;

    Assert( ppv != NULL );
    *ppv = NULL;

    for( int i = 0; pQI[ i ].pvtbl; i++ )
    {
        if ( riid == *pQI[ i ].riid )
        {
#ifdef DEBUG
            TraceMsg( TF_FUNC, "%s, ppv=0x%08x )\n", pQI[i].pszName, ppv );
#endif // DEBUG
            *ppv = pQI[ i ].pvtbl;
            hr = S_OK;
            break;
        }
    }

    if ( hr == E_NOINTERFACE )
    {
        TraceMsgGUID( TF_FUNC, riid );
        TraceMsg( TF_FUNC, ", ppv=0x%08x )\n", ppv );
    }

    if ( SUCCEEDED( hr ) )
    {
        ( (IUnknown *) *ppv )->AddRef();
    }

    return hr;
}

///////////////////////////////////////
//
// NOISY_QI
//
#ifndef NOISY_QI

#undef TraceMsg
#define TraceMsg        1 ? (void)0 : (void) 
#undef TraceFunc     
#define TraceFunc       1 ? (void)0 : (void) 
#undef TraceClsFunc     
#define TraceClsFunc    1 ? (void)0 : (void) 
#undef TraceFuncExit
#define TraceFuncExit()
#undef HRETURN
#define HRETURN(_hr)    return(_hr)
#undef RETURN
#define RETURN(_fn)     return(_fn)  
#undef ErrorMsg
#define ErrorMsg        1 ? (void)0 : (void) 

#endif // NOISY_QI
//
// END NOISY_QI
//
///////////////////////////////////////

#ifndef NO_TRACE_INTERFACES
#ifdef DEBUG
///////////////////////////////////////
//
// BEGIN DEBUG
//

///////////////////////////////////////
//
// CITracker
//
//

DEFINE_THISCLASS("CITracker");
#define THISCLASS CITracker
#define LPTHISCLASS LPITRACKER

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//
// Special new( ) for CITracker
//
#undef new
void* __cdecl operator new( unsigned int nSize, LPCTSTR pszFile, const int iLine, LPCTSTR pszModule, UINT nExtra )
{
    return DebugAlloc( pszFile, iLine, pszModule, GPTR, nSize + nExtra, __THISCLASS__ );
}
#define new new( TEXT(__FILE__), __LINE__, __MODULE__, nExtra )

//
// CreateInstance()
//
LPVOID
CITracker_CreateInstance(
    LPQITABLE pQITable )
{
	TraceFunc( "CITracker_CreateInstance( " );
    TraceMsg( TF_FUNC, "pQITable = 0x%08x )\n", pQITable );

    if ( !pQITable )
    {
        THR( E_POINTER );
        RETURN(NULL);
    }

    HRESULT hr;

    // 
    // Add up the space needed for all the vtbls
    //
    for( int i = 1; pQITable[i].riid; i++ )
    {
        UINT nExtra = VTBL2OFFSET + (( 3 + pQITable[i].cFunctions ) * sizeof(LPVOID));

        // The "new" below is a macro that needs "nExtra" defined. (see above)
        LPTHISCLASS lpc = new THISCLASS( ); 
        if ( !lpc )
        {
            hr = THR(E_OUTOFMEMORY);
            goto Error;
        }

        hr = THR( lpc->Init( &pQITable[i] ) );
        if ( hr )
        {
            delete lpc;
            lpc = NULL;
            goto Error;
        }

        // DebugMemoryDelete( lpc );
    }

Error:
    RETURN(NULL);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "" );
    TraceMsg( TF_FUNC, "%s()\n", __THISCLASS__ );

	InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

STDMETHODIMP
THISCLASS::Init(    
    LPQITABLE  pQITable )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init( " );
    TraceMsg( TF_FUNC, "pQITable = 0x%08x )\n", pQITable );

    //
    // Generate new Vtbls for each interface
    //
    LPVOID *pthisVtbl = (LPVOID*) (IUnknown*) this;
    LPVOID *ppthatVtbl = (LPVOID*) pQITable->pvtbl;
    DWORD dwSize = ( 3 + pQITable->cFunctions ) * sizeof(LPVOID);

    // Interface tracking information initialization
    Assert( _vtbl.cRef == 0 );
    _vtbl.pszInterface = pQITable->pszName;

    // This is so we can get to our object's "this" pointer
    // after someone jumped to our IUnknown.
    _vtbl.pITracker = (LPUNKNOWN) this;

    // Copy the orginal vtbl.
    CopyMemory( &_vtbl.lpfnQueryInterface, *ppthatVtbl, dwSize );

    // Copy our IUnknown vtbl to the beginning 3 entries.
    CopyMemory( &_vtbl.lpfnQueryInterface, *pthisVtbl, 3 * sizeof(LPVOID) );

    // Remember the old vtbl so we can jump to the orginal objects
    // IUnknown functions.
    _vtbl.pOrginalVtbl = (LPVTBL) *ppthatVtbl;

    // Remember the "punk" pointer so we can pass it back in when
    // we jump to the orginal objects IUnknown functions.
    _vtbl.punk = (LPUNKNOWN) pQITable->pvtbl;

    // And finally, point the objects vtbl for this interface to
    // our newly created vtbl.
    *ppthatVtbl = &_vtbl.lpfnQueryInterface;

    TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, TF_FUNC, 
                  L"Tracking %s Interface...\n", _vtbl.pszInterface );

    HRETURN(hr);
}



//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "" );
    TraceMsg( TF_FUNC, "~%s()\n", __THISCLASS__ );

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface( 
    REFIID riid, 
    LPVOID *ppv )
{
    // TraceClsFunc( "[IUnknown] QueryInterface( )\n" );

    //
    // Translate call to get our this pointer
    //
    LPVOID*     punk  = (LPVOID*) (LPUNKNOWN) this;
    LPVTBL2     pvtbl = (LPVTBL2) ((LPBYTE)*punk - VTBL2OFFSET);
    LPTHISCLASS that  = (LPTHISCLASS) pvtbl->pITracker;

    //
    // Jump to our real implementation
    //
    HRESULT hr = that->_QueryInterface( riid, ppv );

    // HRETURN(hr);
    return hr;
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    // TraceClsFunc( "[IUnknown] AddRef( )\n" );
    //
    // Translate call to get our this pointer
    //
    LPVOID*     punk  = (LPVOID*) (LPUNKNOWN) this;
    LPVTBL2     pvtbl = (LPVTBL2) ((LPBYTE)*punk - VTBL2OFFSET);
    LPTHISCLASS that  = (LPTHISCLASS) pvtbl->pITracker;

    //
    // Jump to our real implementation
    //
    ULONG ul = that->_AddRef( );

    // RETURN(ul);
    return ul;
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    // TraceClsFunc( "[IUnknown] Release( )\n" );
    //
    // Translate call to get our this pointer
    //
    LPVOID*     punk  = (LPVOID*) (LPUNKNOWN) this;
    LPVTBL2     pvtbl = (LPVTBL2) ((LPBYTE)*punk - VTBL2OFFSET);
    LPTHISCLASS that  = (LPTHISCLASS) pvtbl->pITracker;

    //
    // Jump to our real implementation
    //
    ULONG ul = that->_Release( );

    // RETURN(ul);
    return ul;
}

// ************************************************************************
//
// IUnknown2
//
// ************************************************************************

//
// _QueryInterface()
//
STDMETHODIMP
THISCLASS::_QueryInterface( 
    REFIID riid, 
    LPVOID *ppv )
{
#ifdef NOISY_QI
    TraceClsFunc( "");
    TraceMsg( TF_FUNC, "{%s} QueryInterface( ... )\n", _vtbl.pszInterface );
#else
    InterlockIncrement(g_dwCounter)
    TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, TF_FUNC, L"{%s} QueryInterface( ... )\n", 
        _vtbl.pszInterface );
#endif

    HRESULT hr = _vtbl.pOrginalVtbl->lpfnQueryInterface( _vtbl.punk, riid, ppv );

#ifdef NOISY_QI
    HRETURN(hr);
#else
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V\n") );
    InterlockDecrement(g_dwCounter);
    return(hr);
#endif
}

//
// _AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::_AddRef( void )
{
#ifdef NOISY_QI
    TraceClsFunc( "");
    TraceMsg( TF_FUNC, "{%s} AddRef( )\n", _vtbl.pszInterface );
#else
    InterlockIncrement(g_dwCounter)
    TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, TF_FUNC, L"{%s} AddRef()\n", 
        _vtbl.pszInterface );
#endif

    ULONG ul = _vtbl.pOrginalVtbl->lpfnAddRef( _vtbl.punk );

    InterlockIncrement( _vtbl.cRef );

#ifdef NOISY_QI
    RETURN(ul);
#else
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V I=%u, O=%u\n"),
        _vtbl.cRef, ul );
    InterlockDecrement(g_dwCounter);
    return ul;
#endif
}

//
// _Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::_Release( void )
{
#ifdef NOISY_QI
    TraceClsFunc( "");
    TraceMsg( TF_FUNC, "{%s} Release( )\n", _vtbl.pszInterface );
#else
    InterlockIncrement(g_dwCounter)
    TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, TF_FUNC, L"{%s} Release()\n", 
        _vtbl.pszInterface );
#endif

    ULONG ul = _vtbl.pOrginalVtbl->lpfnRelease( _vtbl.punk );

    InterlockDecrement( _vtbl.cRef );

    if ( ul ) 
    {
#ifdef NOISY_QI
    RETURN(ul);
#else
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V I=%u, O=%u\n"),
        _vtbl.cRef, ul );
    InterlockDecrement(g_dwCounter);
    return ul;
#endif
    }

    //
    // TODO: Figure out how to destroy the tracking objects.
    //

#ifdef NOISY_QI
    RETURN(ul);
#else
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V I=%u, O=%u\n"),
        _vtbl.cRef, ul );
    InterlockDecrement(g_dwCounter);
    return ul;
#endif
}

//
// END DEBUG
//
///////////////////////////////////////
#endif // DEBUG
#endif // NO_TRACE_INTERFACES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\server.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// SERVER.CPP - Handles the "IntelliMirror" IDD_PROP_INTELLIMIRROR_SERVER tab
//

#include "pch.h"
#include <dns.h>
#include "utils.h"
#include "cservice.h"
#include "cenumsif.h"
#include "ccomputr.h"
#include "server.h"
#include "dpguidqy.h"
#include "querypb.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CServerTab")
#define THISCLASS CServerTab
#define LPTHISCLASS LPSERVERTAB


DWORD aServerHelpMap[] = {
    IDC_C_RESPOND, HIDC_C_RESPOND,
    IDC_C_KNOWNCLIENTS, HIDC_C_KNOWNCLIENTS,
    IDC_B_CHECKSERVER, HIDC_B_CHECKSERVER,
    IDC_B_CLIENTS, HIDC_B_CLIENTS,
    IDC_B_SERVICE, HIDC_B_SERVICE,
    IDC_G_CHECKSERVER, HIDC_G_CHECKSERVER,
    IDC_G_CLIENTSERVICING, HIDC_G_CLIENTSERVICING,
    NULL, NULL
};

//
// CreateInstance()
//
LPVOID
CServerTab_CreateInstance( void )
{
	TraceFunc( "CServerTab_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CServerTab()\n" );

	InterlockIncrement( g_cObjects );

    Assert( !_punkService );
    Assert( !_pido );
    Assert( !_pszGroupDN );
    Assert( !_pszSCPDN );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    _uMode = MODE_SHELL; // default

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CServerTab()\n" );

    if ( _pido )
        _pido->Release( );

    if ( _punkService )
        _punkService->Release( );

    if ( _punkComputer )
        _punkComputer->Release( );

    if ( _pszSCPDN )
        TraceFree( _pszSCPDN );

    if ( _pszGroupDN )
        TraceFree( _pszGroupDN );

    // tell ADS to destroy the notify object
    // NOTE: Another property page may do this before us. Ignore errors.
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_EXIT, 0, 0 );

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// *************************************************************************
//
// ITab
//
// *************************************************************************

STDMETHODIMP
THISCLASS::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam,
    LPUNKNOWN punk )
{
    TraceClsFunc( "AddPages( )\n" );

    if ( !punk )
        RRETURN(E_POINTER);

    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
    psp.hInstance   = (HINSTANCE) g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP_INTELLIMIRROR_SERVER);
    psp.pcRefParent = (UINT *) &g_cObjects;
    psp.pfnCallback = (LPFNPSPCALLBACK) PropSheetPageProc;
    psp.pfnDlgProc  = PropSheetDlgProc;
    psp.lParam      = (LPARAM) this;

    LPSHELLEXTINIT pShellExtInit = NULL;
    IMAO * pmao = NULL;

    _punkComputer = punk;
    _punkComputer->AddRef( );

    hr = THR( _punkComputer->QueryInterface( IID_IMAO, (void**) &pmao ) );
    if (FAILED( hr ))
        goto Error;

    hr = THR( pmao->GetDataObject( &_pido ) );
    if (FAILED( hr ))
        goto Error;

    _punkService = (LPUNKNOWN) CService_CreateInstance( );
    if ( !_punkService )
        goto OutOfMemory;

    hr = THR( _punkService->QueryInterface( IID_IShellExtInit, (void **) &pShellExtInit ) );
    if (FAILED( hr ))
        goto Error;

    hr = THR( pShellExtInit->Initialize( NULL, _pido, NULL ) );
    if (FAILED( hr ))
        goto Error;

    hpage = CreatePropertySheetPage( &psp );
    if ( hpage )
    {
        if ( !lpfnAddPage( hpage, lParam ) )
        {
            DestroyPropertySheetPage( hpage );
            hr = THR(E_FAIL);
        }
    }

Cleanup:
    if ( pShellExtInit )
        pShellExtInit->Release( );

    if ( pmao )
        pmao->Release( );

    HRETURN(hr);

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
Error:
    MessageBoxFromHResult( NULL, NULL, hr );
    goto Cleanup;
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam,
    LPUNKNOWN punk )
{

    TraceClsFunc( "ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    HRETURN(E_NOTIMPL);
}

//
// QueryInformation( )
//
STDMETHODIMP
THISCLASS::QueryInformation(
    LPWSTR pszAttribute,
    LPWSTR * pszResult )
{
    TraceClsFunc( "QueryInformation( )\n" );

    HRETURN(E_NOTIMPL);
}

//
// AllowActivation( )
//
STDMETHODIMP
THISCLASS::AllowActivation(
    BOOL * pfAllow )
{
    TraceClsFunc( "AllowActivation( )\n" );

    HRETURN(E_NOTIMPL);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************



//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, psp->lParam );
        pcc = (LPTHISCLASS) psp->lParam;
        return pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc)
    {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg )
        {
        case WM_NOTIFY:
            return pcc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
            return pcc->_OnCommand( wParam, lParam );
            break;

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aServerHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aServerHelpMap );
            break;

        case WM_ADSPROP_PAGE_GET_NOTIFY:
            {
                HWND *phwnd = (HWND *) wParam;
                *phwnd = pcc->_hNotify;
            }
            return TRUE;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
UINT CALLBACK
THISCLASS::PropSheetPageProc(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp )
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("hwnd = 0x%08x, uMsg = 0x%08x, ppsp= 0x%08x )\n"),
        hwnd, uMsg, ppsp );

    switch ( uMsg )
    {
    case PSPCB_CREATE:
        RETURN(TRUE);   // create it
        break;

    case PSPCB_RELEASE:
        LPTHISCLASS pcc = (LPTHISCLASS) ppsp->lParam;
        delete pcc;
        break;
    }

    RETURN(FALSE);
}

//
// _InitDialog( )
//
BOOL
THISCLASS::_InitDialog(
    HWND hDlg,
    LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    CWaitCursor Wait;

    BOOL fAdmin           = FALSE;

    LPINTELLIMIRRORSAP pimsap     = NULL;

    HRESULT hr;
    HRESULT hResult = S_OK;
    WCHAR   szRISETUPPath[ MAX_PATH ];
    HANDLE  hFind;
    BOOL    fOnOff;

    IMAO *  pmao = NULL;

#if 0
    ULONG uCount;
#endif

    WIN32_FIND_DATA fda;

    _hDlg = hDlg;

    hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
    if (FAILED( hr )) 
        goto Error;

    hr = THR( _punkComputer->QueryInterface( IID_IMAO, (void**) &pmao ) );
    if (FAILED( hr ))
        goto Error;

    hr = THR( pmao->GetNotifyWindow( &_hNotify ) );
    if (FAILED( hr ))
        goto Error;

    ADsPropSetHwnd( _hNotify, _hDlg );

    hr = THR( pimsap->IsAdmin( &fAdmin ) );
    Assert( SUCCEEDED(hr) || fAdmin == FALSE );

#if 0
    hr = THR( pimsap->GetAllowNewClients( &fOnOff) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND && hResult == S_OK )
    {
        hResult = hr;
    }
    Assert( SUCCEEDED(hr) || fOnOff == FALSE );
    Button_SetCheck( GetDlgItem( _hDlg, IDC_C_ALLOWNEWCLIENT ), ( fOnOff ? BST_CHECKED : BST_UNCHECKED ) );
    EnableWindow( GetDlgItem( _hDlg, IDC_C_LIMITCLIENT ), fOnOff );

    hr = THR( pimsap->GetLimitClients( &fOnOff ) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND && hResult == S_OK )
    {
        hResult = hr;
    }
    Assert( SUCCEEDED(hr) || fOnOff == FALSE );
    Button_SetCheck( GetDlgItem( _hDlg, IDC_C_ALLOWNEWCLIENT ), ( fOnOff ? BST_CHECKED : BST_UNCHECKED ) );

    hr = THR( pimsap->GetMaxClients( &uCount ) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND && hResult == S_OK )
    {
        hResult = hr;
    }
    Assert( SUCCEEDED(hr) || uCount == 0 );
    {
        WCHAR szText[ 13 ];
        wsprintf( szText, "%u", uCount );
        SetDlgItemText( _hDlg, IDC_E_LIMIT, szText );
    }

    hr = THR( pimsap->GetCurrentClientCount( &uCount ) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND && hResult == S_OK )
    {
        hResult = hr;
    }
    Assert( SUCCEEDED(hr) || uCount == 0 );
    {
        WCHAR szText[ 13 ];
        wsprintf( szText, "%u", uCount );
        SetDlgItemText( _hDlg, IDC_S_CURRENTCOUNT, szText );
    }
#endif
   
    hr = THR( pimsap->GetAnswerRequests( &fOnOff) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND && hResult == S_OK )
    {
        hResult = hr;
    }
    Assert( SUCCEEDED(hr) || fOnOff == FALSE );
    Button_SetCheck( GetDlgItem( _hDlg, IDC_C_RESPOND ), ( fOnOff ? BST_CHECKED : BST_UNCHECKED ) );
    EnableWindow( GetDlgItem( _hDlg, IDC_C_KNOWNCLIENTS ), fOnOff );

    hr = THR( pimsap->GetAnswerOnlyValidClients( &fOnOff) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND && hResult == S_OK )
    {
        hResult = hr;
    }
    Assert( SUCCEEDED(hr) || fOnOff == FALSE );
    Button_SetCheck( GetDlgItem( _hDlg, IDC_C_KNOWNCLIENTS ), ( fOnOff ? BST_CHECKED : BST_UNCHECKED ) );

#if 0
    // Change the text on the button if it already is in a group.
    Assert( !_pszGroupDN );
    hr = THR( pimsap->GetGroupDN( &_pszGroupDN ) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND ) 
        goto Error;

    if ( _pszGroupDN ) {
        DWORD dw;
        WCHAR szManageGroup[ 64 ];
        dw = LoadString( g_hInstance, IDS_MANAGE_GROUP, szManageGroup, ARRAYSIZE(szManageGroup) );
        Assert( dw );

        // SetWindowText( GetDlgItem( _hDlg, IDC_B_GROUP ), szManageGroup );
    }
#endif

    // See if we can enable the "Check Server" button.
    GetWindowsDirectory( szRISETUPPath, ARRAYSIZE(szRISETUPPath) );
    wcscat( szRISETUPPath, L"\\system32\\risetup.exe" );

    hFind = FindFirstFile( szRISETUPPath, &fda );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        FindClose( hFind );

        LPWSTR pszServerName;
        WCHAR szFQDNS[ DNS_MAX_NAME_BUFFER_LENGTH ];
        DWORD cbSize = ARRAYSIZE( szFQDNS );

        hr = THR( pimsap->GetServerName( &pszServerName ) );
        if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
            goto Error;
        if (SUCCEEDED( hr ))
        {
            GetComputerNameEx( ComputerNameNetBIOS, szFQDNS, &cbSize );
            if ( StrCmpI( szFQDNS, pszServerName ) == 0)
            {
                EnableWindow( GetDlgItem( _hDlg, IDC_B_CHECKSERVER ), TRUE );
            }

            TraceFree( pszServerName );
        }
    }

    Assert( !_pszSCPDN );
    hr = THR( pimsap->GetSCPDN( &_pszSCPDN ) );
    if (FAILED( hr ))
        goto Error;
    EnableWindow( GetDlgItem( _hDlg, IDC_B_SERVICE ), !!_pszSCPDN );

    if (FAILED( hResult ))
    {
        MessageBoxFromHResult( _hDlg, IDS_ERROR_READINGCOMPUTERACCOUNT, hResult );
    }

Cleanup:
    if ( pmao )
        pmao->Release( );
    if ( pimsap )
        pimsap->Release( );
    RETURN(FALSE);
Error:
    MessageBoxFromHResult( _hDlg, IDS_ERROR_READINGCOMPUTERACCOUNT, hr );
    goto Cleanup;
}

//
// _DisplayClientsQueryForm( )
//
HRESULT
THISCLASS::_DisplayClientsQueryForm( )
{
    TraceClsFunc( "_DisplayClientsQueryForm( )\n" );

    HRESULT hr;
    DSQUERYINITPARAMS dqip;
    OPENQUERYWINDOW   oqw;
    LPDSOBJECTNAMES   pDsObjects;
    ICommonQuery *    pCommonQuery = NULL;
    IPropertyBag *    ppb = NULL;
    VARIANT           var;

    LPINTELLIMIRRORSAP pimsap = NULL;
    LPWSTR pszServerName = NULL;
    WCHAR  szServerQuery[ DNS_MAX_NAME_BUFFER_LENGTH + 1 ];

    VariantInit( &var );

    hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
    if (FAILED( hr )) 
        goto Clients_Error;

    hr = THR( pimsap->GetServerName( &pszServerName ) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Clients_Error;

    hr = THR( CoCreateInstance( CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_ICommonQuery, (PVOID *)&pCommonQuery) );
    if (FAILED( hr ))
        goto Clients_Error;

    wcscpy( szServerQuery, pszServerName );
    wcscat( szServerQuery, L"*" );
    V_VT( &var ) = VT_BSTR;
    V_BSTR( &var ) = SysAllocString( szServerQuery );

    ZeroMemory( &dqip, sizeof(dqip) );
    dqip.cbStruct      = sizeof(dqip);
    dqip.dwFlags       = DSQPF_NOSAVE | DSQPF_SHOWHIDDENOBJECTS | DSQPF_ENABLEADMINFEATURES;
    dqip.dwFlags       |= DSQPF_ENABLEADVANCEDFEATURES;

    ppb = (IPropertyBag *) QueryPropertyBag_CreateInstance( );
    if ( !ppb )
    {
        hr = E_OUTOFMEMORY;
        goto Clients_Error;
    }

    hr = THR( ppb->Write( L"ServerName", &var ) );
    if (hr)
        goto Clients_Error;
    
    ZeroMemory( &oqw, sizeof(oqw) );
    oqw.cbStruct           = sizeof(oqw);
    oqw.dwFlags            = OQWF_SHOWOPTIONAL | OQWF_ISSUEONOPEN | OQWF_DEFAULTFORM;
    oqw.clsidHandler       = CLSID_DsQuery;
    oqw.pHandlerParameters = &dqip;
    oqw.clsidDefaultForm   = CLSID_RIQueryForm;
    oqw.pFormParameters    = ppb;

    hr = pCommonQuery->OpenQueryWindow( _hDlg, &oqw, NULL /* don't need results */);

Clients_Error:
    VariantClear( &var );

    if ( ppb )
        ppb->Release( );

    if ( pCommonQuery )
        pCommonQuery->Release( );

    if ( pszServerName )
        TraceFree( pszServerName );

    if ( pimsap )
        pimsap->Release( );

    HRETURN(hr);
}

//
// _OnCommand( )
//
BOOL
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    BOOL fChanged = FALSE;
    BOOL fReturn = FALSE;
    HWND hwndCtl = (HWND) lParam;

    switch( LOWORD(wParam) )
    {
    case IDC_C_RESPOND:
        if ( HIWORD(wParam) == BN_CLICKED )
        {
            EnableWindow( GetDlgItem( _hDlg, IDC_C_KNOWNCLIENTS ), Button_GetCheck( hwndCtl ) == BST_CHECKED );
            fChanged = TRUE;
        }
        break;

    case IDC_C_KNOWNCLIENTS:
        if ( HIWORD(wParam) == BN_CLICKED )
        {
            fChanged = TRUE;
        }
        break;


    case IDC_B_CLIENTS:
        if ( HIWORD(wParam) == BN_CLICKED )
        {
            _DisplayClientsQueryForm( );
        }
        break;

    case IDC_B_CHECKSERVER:
        {
            WCHAR szCommand[ MAX_PATH ] = { L"RISETUP.EXE -check" };
            STARTUPINFO startupInfo;
            PROCESS_INFORMATION pi;
            BOOL b;

            ZeroMemory( &startupInfo, sizeof( startupInfo) );
            startupInfo.cb = sizeof( startupInfo );

            b = CreateProcess( NULL,
                               szCommand,
                               NULL,
                               NULL,
                               TRUE,
                               NORMAL_PRIORITY_CLASS,
                               NULL,
                               NULL,
                               &startupInfo,
                               &pi );
            if ( b )
            {
                CloseHandle( pi.hProcess );
                CloseHandle( pi.hThread );
            }
            else
            {
                DWORD dwErr = GetLastError( );
                MessageBoxFromError( _hDlg, IDS_RISETUP_FAILED_TO_START, dwErr );
            }
        }
        break;

    case IDC_B_SERVICE:
        if ( HIWORD(wParam) == BN_CLICKED )
        {
            Assert( _pszSCPDN );
            THR( PostADsPropSheet( _pszSCPDN, _pido, _hDlg, FALSE) );
        }
        break;
    }

    if ( fChanged )
    {
        if ( !_fChanged )
        {
            _fChanged = TRUE;
            SendMessage( GetParent( _hDlg ), PSM_CHANGED, 0, 0 );
        }
    }

    RETURN(fReturn);
}

//
// _ApplyChanges( )
//
HRESULT
THISCLASS::_ApplyChanges( )
{
    TraceClsFunc( "_ApplyChanges( )\n" );

    if ( !_fChanged )
        HRETURN(S_FALSE); // nop

    HRESULT hr;
    HRESULT hResult = S_OK;
    BOOL    fOnOff;
    HWND    hwnd;
    LPINTELLIMIRRORSAP pimsap;
    WCHAR   szBuffer[ 10 ];

    hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
    if (FAILED( hr )) 
        goto Error;

#if 0
    hwnd = GetDlgItem( _hDlg, IDC_C_ALLOWNEWCLIENT );
    fOnOff = Button_GetCheck( hwnd ) == BST_CHECKED;
    hr = THR( pimsap->SetAllowNewClients( fOnOff ) );
    if(FAILED( hr ) && hResult == S_OK )
    {
        hResult = hr;
        SetFocus( hwnd );
    }

    hwnd = GetDlgItem( _hDlg, IDC_C_LIMITCLIENT );
    fOnOff = Button_GetCheck( hwnd ) == BST_CHECKED;
    hr = THR( pimsap->SetLimitClients( fOnOff ) );
    if(FAILED( hr ) && hResult == S_OK )
    {
        hResult = hr;
        SetFocus( hwnd );
    }

    hwnd = GetDlgItem( _hDlg, IDC_E_LIMIT );
    GetWindowText( hwnd , szBuffer, ARRAYSIZE(szBuffer) );
    uValue = wcstol( szBuffer, NULL, 10 );
    hr = THR( pimsap->SetMaxClients( uValue ) );
    if(FAILED( hr ) && hResult == S_OK )
    {
        hResult = hr;
        SetFocus( hwnd );
    }
#endif

    hwnd = GetDlgItem( _hDlg, IDC_C_RESPOND );
    fOnOff = Button_GetCheck( hwnd ) == BST_CHECKED;
    hr = THR( pimsap->SetAnswerRequests( fOnOff ) );
    if(FAILED( hr ) && hResult == S_OK )
    {
        hResult = hr;
        SetFocus( hwnd );
    }

    hwnd = GetDlgItem( _hDlg, IDC_C_KNOWNCLIENTS );
    fOnOff = Button_GetCheck( hwnd ) == BST_CHECKED;
    hr = THR( pimsap->SetAnswerOnlyValidClients( fOnOff ) );
    if(FAILED( hr ) && hResult == S_OK )
    {
        hResult = hr;
        SetFocus( hwnd );
    }

    hr = THR( pimsap->CommitChanges() );
    if(FAILED( hr ))
        goto Error;

    if (FAILED( hResult ))
    {
        MessageBoxFromHResult( NULL, NULL, hResult );
        hr = hResult;
    }

Cleanup:
    if ( pimsap )
        pimsap->Release( );

    // Tell DSA that someone hit Apply
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_APPLY, !!SUCCEEDED( hr ), 0 );

    HRETURN(hr);
Error:
    MessageBoxFromHResult( NULL, NULL, hr );
    goto Cleanup;
}

//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LV_DISPINFO * plvdi = (LV_DISPINFO *) lParam;

    switch( plvdi->hdr.code )
    {
    case PSN_APPLY:
        {
            HRESULT hr;
            TraceMsg( TF_WM, TEXT("WM_NOTIFY: PSN_APPLY\n"));
            hr = _ApplyChanges( );
            _fChanged = FALSE;
            SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, ( SUCCEEDED(hr) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE ));
            RETURN(TRUE);
        }
        break;

#if 0
    case LVN_DELETEALLITEMS:
        fReturn = TRUE;
        break;

    case LVN_DELETEITEM:
        {
            LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;
            LPSIFTABLE psif = (LPSIFTABLE) pnmv->lParam;
            Assert( psif );

            if ( psif )
            {
                TraceFree( psif->pszName );
                TraceFree( psif->pszLanguage );
                TraceFree( psif->pszSIF );
                TraceFree( psif );
            }
        }
        break;
#endif

    default:
        break;
    }

    RETURN(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\serverqy.h ===
//
// Copyright 1997 - Microsoft

//
// DPGUIDQY.H - The duplicate GUID query form
//


#ifndef _SERVERQY_H_
#define _SERVERQY_H_

// QITable
BEGIN_QITABLE( CRISrvQueryForm )
DEFINE_QI( IID_IQueryForm, IQueryForm, 3 )
END_QITABLE

// Definitions
LPVOID
CRISrvQueryForm_CreateInstance( void );

// CRISrvQueryForm
class CRISrvQueryForm
    : public IQueryForm
{
private:
    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( CRISrvQueryForm );

    HWND        _hDlg;

private: // methods
    CRISrvQueryForm( );
    ~CRISrvQueryForm( );
    HRESULT
        Init( void );

    // Property Sheet Functions
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static HRESULT CALLBACK
        PropSheetPageProc( LPCQPAGE pQueryPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    HRESULT _InitDialog( HWND hDlg, LPARAM lParam );
    INT     _OnCommand( WPARAM wParam, LPARAM lParam );
    INT     _OnNotify( WPARAM wParam, LPARAM lParam );
    HRESULT _OnPSPCB_Create( );
    HRESULT _GetQueryParams( HWND hwnd, LPDSQUERYPARAMS* ppdsqp );

public: // methods
    friend LPVOID CRISrvQueryForm_CreateInstance( void );

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IQueryForm methods
    STDMETHOD(Initialize)(HKEY hkForm);
    STDMETHOD(AddForms)(LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam);
    STDMETHOD(AddPages)(LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam);
};

typedef CRISrvQueryForm * LPCRISrvQueryForm;


#endif // _DPGUIDQY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\sifprop.h ===
//
// Copyright 1997 - Microsoft
//

//
// SIFPROP.H - Handles the "SIF Properties" IDC_SIF_PROP_IMAGES
//             and IDD_SIF_PROP_TOOLS dialogs
//


#ifndef _SIFPROP_H_
#define _SIFPROP_H_

// Definitions
HRESULT
CSifProperties_CreateInstance(
    HWND hParent,
    LPCTSTR lpszTemplate,
    LPSIFINFO pSIF );

// CSifProperties
class
CSifProperties
{
private:
    HWND  _hDlg;
    LPSIFINFO _pSIF;

private: // Methods
    CSifProperties();
    ~CSifProperties();
    STDMETHOD(Init)( HWND hParent, LPCTSTR lpszTemplate, LPSIFINFO pSIF );

    // Property Sheet Functions
    HRESULT _InitDialog( HWND hDlg );
    INT     _OnCommand( WPARAM wParam, LPARAM lParam );
    INT     _OnNotify( WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

public: // Methods
    friend HRESULT CSifProperties_CreateInstance( HWND hParent, LPCTSTR lpszTemplate, LPSIFINFO pSIF );
};

typedef CSifProperties* LPCSIFPROPERTIES;

#endif // _SIFPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\sifprop.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// SIFPROP.CPP - Handles the "SIF Properties" IDC_SIF_PROP_IMAGES
//               and IDD_SIF_PROP_TOOLS dialogs
//


#include "pch.h"
#include "sifprop.h"
#include "utils.h"
#include "shellapi.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CSifProperties")
#define THISCLASS CSifProperties
#define LPTHISCLASS CSifProperties*

#define NUM_COLUMNS				    3

DWORD aSifHelpMap[] = {
    IDC_E_DESCRIPTION, HIDC_E_DESCRIPTION,
    IDC_E_HELP, HIDC_E_HELP,
    IDC_S_VERSION, HIDC_S_VERSION,
    IDC_S_LANGUAGE, HIDC_S_LANGUAGE,
    IDC_S_LASTMODIFIED, HIDC_S_LASTMODIFIED,
    IDC_S_IMAGETYPE, HIDC_S_IMAGETYPE,
    IDC_S_DIRECTORY, HIDC_S_DIRECTORY,
    IDC_G_IMAGEDETAILS, HIDC_G_IMAGEDETAILS,
    NULL, NULL
};

//
// CreateInstance()
//
HRESULT
CSifProperties_CreateInstance(
    HWND hParent,
    LPCTSTR lpszTemplate,
    LPSIFINFO pSIF )
{
	TraceFunc( "CSifProperties_CreateInstance( )\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = lpcc->Init( hParent, lpszTemplate, pSIF );

    delete lpcc;

    HRETURN(hr);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CSifProperties()\n" );

	InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init(
    HWND hParent,
    LPCTSTR lpszTemplate,
    LPSIFINFO pSIF )
{
    HRESULT hr;

    TraceClsFunc( "Init( ... )\n" );

    Assert( pSIF );
    _pSIF = pSIF;

    INT i = (INT)DialogBoxParam( g_hInstance, lpszTemplate, hParent, PropSheetDlgProc, (LPARAM) this );

    switch( i )
    {
    case IDOK:
        hr = S_OK;
        break;

    case IDCANCEL:
        hr = S_FALSE;
        break;

#ifdef DEBUG
    default:
        hr = THR(E_FAIL);
        break;
#endif // DEBUG
    }

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CSifProperties()\n" );

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************

//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
    HWND hDlg )
{
    TraceClsFunc( "_InitDialog( )\n" );

    HRESULT hr = S_OK;
    TCHAR   szTempBuffer[ 256 ];
    TCHAR   szTmp[ 128 ];
    TCHAR   szTmp2[ 128 ];
    FILETIME   ftLocal;
    SYSTEMTIME stSystem;

    _hDlg = hDlg;

    Assert( _pSIF );
    SetDlgItemText( hDlg, IDC_E_DESCRIPTION, _pSIF->pszDescription);
    SetDlgItemText( hDlg, IDC_E_HELP,        _pSIF->pszHelpText);
    SetDlgItemText( hDlg, IDC_S_IMAGETYPE,   _pSIF->pszImageType);
    SetDlgItemText( hDlg, IDC_S_LANGUAGE,    _pSIF->pszLanguage);
    SetDlgItemText( hDlg, IDC_S_VERSION,     _pSIF->pszVersion);
    SetDlgItemText( hDlg, IDC_S_DIRECTORY,   _pSIF->pszDirectory );

    FileTimeToLocalFileTime( &_pSIF->ftLastWrite, &ftLocal);
    FileTimeToSystemTime( &ftLocal, &stSystem);
    GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE, &stSystem, NULL, szTmp, ARRAYSIZE(szTmp));
    GetTimeFormat(LOCALE_USER_DEFAULT, 0, &stSystem, NULL, szTmp2, ARRAYSIZE(szTmp2));
    wsprintf(szTempBuffer, L"%s, %s", szTmp, szTmp2);
    SetDlgItemText( hDlg, IDC_S_LASTMODIFIED, szTempBuffer );

    Edit_LimitText( GetDlgItem( hDlg, IDC_E_DESCRIPTION), REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT - 1 );
    Edit_LimitText( GetDlgItem( hDlg, IDC_E_HELP),        REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT - 1 );

    HRETURN(hr);
}


//
// _OnCommand( )
//
INT
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    HRESULT hr = S_FALSE;
    HWND hwndCtl = (HWND) lParam;

    switch( LOWORD(wParam) )
    {
    case IDOK:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            Assert( _pSIF );
            TCHAR szTempBuffer[  REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT + 2 ]; // +2 = the "Quotes"

            Assert( REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT <=  REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT ); // paranoid

            szTempBuffer[0] = L'\"';
            GetDlgItemText( _hDlg, IDC_E_DESCRIPTION, &szTempBuffer[1], REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT );
            wcscat( szTempBuffer, L"\"" );

            if ( VerifySIFText( szTempBuffer ) )
            {
                if (!WritePrivateProfileString( OSCHOOSER_SIF_SECTION,
                                           OSCHOOSER_DESCRIPTION_ENTRY,
                                           szTempBuffer,
                                           _pSIF->pszFilePath)) {
                    MessageBoxFromError( _hDlg, NULL, GetLastError());
                    break;
                }
            }
            else
            {
                MessageBoxFromStrings( _hDlg, IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE, IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT, MB_OK );
                SetFocus( GetDlgItem( _hDlg, IDC_E_DESCRIPTION ) );
                break;
            }

            szTempBuffer[0] = L'\"';
            GetDlgItemText( _hDlg, IDC_E_HELP, &szTempBuffer[1],  REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT );
            wcscat( szTempBuffer, L"\"" );

            if ( VerifySIFText( szTempBuffer ) )
            {
                if (!WritePrivateProfileString( OSCHOOSER_SIF_SECTION,
                                           OSCHOOSER_HELPTEXT_ENTRY,
                                           szTempBuffer,
                                           _pSIF->pszFilePath)) {
                    MessageBoxFromError( _hDlg, NULL, GetLastError());
                }
            }
            else
            {
                MessageBoxFromStrings( _hDlg, IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE, IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT, MB_OK );
                SetFocus( GetDlgItem( _hDlg, IDC_E_HELP ) );
                break;
            }

            EndDialog( _hDlg, LOWORD( wParam ) );
        }
        break;

    case IDCANCEL:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            EndDialog( _hDlg, LOWORD( wParam ) );
        }
        break;

    case IDC_E_DESCRIPTION:
    case IDC_E_HELP:
        if ( HIWORD( wParam ) == EN_CHANGE ) {
            DWORD dwLen1 = Edit_GetTextLength( GetDlgItem( _hDlg, IDC_E_DESCRIPTION) );
            DWORD dwLen2 = Edit_GetTextLength( GetDlgItem( _hDlg, IDC_E_HELP) );
            EnableWindow( GetDlgItem( _hDlg, IDOK ), !( dwLen1==0 || dwLen2==0) );
        }
        break;

    case IDC_BUTTON1:
        if ( HIWORD(wParam) == BN_CLICKED )
        {
            SHELLEXECUTEINFO shexinfo = { 0 };
            Assert( _pSIF );
            shexinfo.cbSize = sizeof(shexinfo);
            shexinfo.fMask = SEE_MASK_INVOKEIDLIST;
            shexinfo.hwnd = hwndCtl;
            shexinfo.nShow = SW_SHOWNORMAL;
            shexinfo.lpFile = _pSIF->pszFilePath;
            shexinfo.lpVerb = TEXT("properties");
            ShellExecuteEx(&shexinfo);
        }
        break;

    }

    RETURN((SUCCEEDED(hr) ? TRUE : FALSE));
}

//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;

#if 0
    switch( lpnmhdr->code )
    {
    }
#endif

    RETURN(FALSE);
}

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    // TraceFunc( "PropSheetDlgProc()\n" );
    // TraceMsg( TF_WM, "hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x\n",
       // hDlg, uMsg, wParam, lParam );

    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        Assert( lParam );
        SetWindowLongPtr( hDlg, GWLP_USERDATA, lParam );
        lpc = (LPTHISCLASS) lParam;
        lpc->_InitDialog( hDlg );
        return TRUE;
    }

    if ( lpc )
    {
        switch( uMsg )
        {
        case WM_NOTIFY:
            TraceMsg( TF_WM, "WM_NOTIFY\n" );
            return lpc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, "WM_COMMAND\n" );
            return lpc->_OnCommand( wParam, lParam );

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aSifHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aSifHelpMap );
            break;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\server.h ===
//
// Copyright 1997 - Microsoft

//
// SERVER.H - Handles the "IntelliMirror" IDD_PROP_INTELLIMIRROR_CLIENT tab
//


#ifndef _SERVER_H_
#define _SERVER_H_

// Definitions
LPVOID
CServerTab_CreateInstance( void );

// CServerTab
class
CServerTab:
    public ITab
{
private:
    // Enums
    enum {
        MODE_SHELL = 0,
        MODE_ADMIN
    };

    HWND            _hDlg;
    BOOL            _fChanged:1;    // Are we dirty?
    UINT            _uMode;         // Admin or Shell mode
    LPUNKNOWN       _punkService;   // Pointer to service object
    IDataObject *   _pido;          // IDataObject to be pass to "Clients" dialog and PostADsPropSheet
    LPWSTR          _pszSCPDN;      // SCP's DN
    LPWSTR          _pszGroupDN;    // The group's DN. If NULL, not in a group.
    LPUNKNOWN       _punkComputer;  // Pointer to computer object
    HWND            _hNotify;       // ADS notify window handle

private: // Methods
    CServerTab();
    ~CServerTab();
    STDMETHOD(Init)();

    // Property Sheet Functions
    BOOL    _InitDialog( HWND hDlg, LPARAM lParam );
    BOOL    _OnCommand( WPARAM wParam, LPARAM lParam );
    HRESULT _ApplyChanges( );
    INT _OnNotify( WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    HRESULT _DisplayClientsQueryForm( );

public: // Methods
    friend LPVOID CServerTab_CreateInstance( void );

    // ITab
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                            LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(QueryInformation)( LPWSTR pszAttribute, LPWSTR * pszResult );
    STDMETHOD(AllowActivation)( BOOL * pfAllow );
};

typedef CServerTab* LPSERVERTAB;

#endif // _SERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\serverqy.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// SERVERQY.CPP - The RIS server query form
//

#include "pch.h"

#include "serverqy.h"
#include "mangdlg.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CRISrvQueryForm")
#define THISCLASS CRISrvQueryForm
#define LPTHISCLASS LPCRISrvQueryForm

#define FILTER_QUERY_SERVER    L"(&(objectClass=computer)(netbootSCPBL=*)(CN=%s))"

#define StringByteCopy(pDest, iOffset, sz)          \
        { memcpy(&(((LPBYTE)pDest)[iOffset]), sz, StringByteSize(sz)); }

#define StringByteSize(sz)                          \
        ((lstrlen(sz)+1)*sizeof(TCHAR))


DWORD aSrvQueryHelpMap[] = {
    IDC_E_SERVER, HIDC_E_SERVER,
    NULL, NULL
};

//
// CRISrvQueryForm_CreateInstance( )
//
LPVOID
CRISrvQueryForm_CreateInstance( void )
{
    TraceFunc( "CRISrvQueryForm_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    if ( !lpcc ) {
        RETURN(lpcc);
    }

    HRESULT hr = THR( lpcc->Init( ) );
    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN(lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CRISrvQueryForm( )\n" );

    InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init( )
//
HRESULT
THISCLASS::Init( )
{
    TraceClsFunc( "Init( )\n" );

    HRESULT hr;

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CRISrvQueryForm, IQueryForm );
    QITABLE_IMP( IQueryForm );
    END_QITABLE_IMP( CRISrvQueryForm );
    Assert( _cRef == 0);
    AddRef( );

    hr = CheckClipboardFormats( );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CRISrvQueryForm( )\n" );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
}

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface(
    REFIID riid,
    LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}

// ************************************************************************
//
// IQueryForm
//
// ************************************************************************

//
// Initialize( )
//
STDMETHODIMP
THISCLASS::Initialize(
    HKEY hkForm)
{
    TraceClsFunc( "[IQueryForm] Initialize( )\n" );

    HRETURN(S_OK);
}

//
// SetObject( )
//
STDMETHODIMP
THISCLASS::AddForms(
    LPCQADDFORMSPROC pAddFormsProc,
    LPARAM lParam )
{
    TraceClsFunc( "[IQueryForm] AddForms(" );
    TraceMsg( TF_FUNC, " pAddFormsProc = 0x%p, lParam = 0x%p )\n", pAddFormsProc, lParam );

    if ( !pAddFormsProc )
        HRETURN(E_INVALIDARG);

    HRESULT hr = S_OK;
    CQFORM cqf;
    WCHAR szTitle[ 255 ];
    DWORD dw;

    dw = LoadString( g_hInstance, IDS_REMOTE_INSTALL_SERVERS, szTitle, ARRAYSIZE(szTitle) );
    Assert(dw);

    ZeroMemory( &cqf, sizeof(cqf) );
    cqf.cbStruct = sizeof(cqf);
    cqf.dwFlags = CQFF_ISOPTIONAL;
    cqf.clsid = CLSID_RISrvQueryForm;
    cqf.pszTitle = szTitle;

    hr = THR( pAddFormsProc(lParam, &cqf) );

    HRETURN(hr);
}


//
// AddPages( )
//
STDMETHODIMP
THISCLASS::AddPages(
    LPCQADDPAGESPROC pAddPagesProc,
    LPARAM lParam)
{
    TraceClsFunc( "[IQueryForm] AddPages(" );
    TraceMsg( TF_FUNC, " pAddPagesProc = 0x%p, lParam = 0x%p )\n", pAddPagesProc, lParam );

    if ( !pAddPagesProc )
        HRETURN(E_INVALIDARG);

    HRESULT hr = S_OK;
    CQPAGE cqp;

    cqp.cbStruct = sizeof(cqp);
    cqp.dwFlags = 0x0;
    cqp.pPageProc = (LPCQPAGEPROC) PropSheetPageProc;
    cqp.hInstance = g_hInstance;
    cqp.idPageName = IDS_REMOTE_INSTALL_SERVERS;
    cqp.idPageTemplate = IDD_SERVER_QUERY_FORM;
    cqp.pDlgProc = PropSheetDlgProc;
    cqp.lParam = (LPARAM)this;

    hr = THR( pAddPagesProc(lParam, CLSID_RISrvQueryForm, &cqp) );

    HRETURN(hr);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%p, uMsg = 0x%p, wParam = 0x%p, lParam = 0x%p )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        CQPAGE * pcqp = (CQPAGE *) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, pcqp->lParam );
        pcc = (LPTHISCLASS) pcqp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc)
    {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg )
        {
        case WM_NOTIFY:
            TraceMsg( TF_WM, TEXT("WM_NOTIFY\n") );
            return pcc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
            return pcc->_OnCommand( wParam, lParam );

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aSrvQueryHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aSrvQueryHelpMap );
            break;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
HRESULT CALLBACK
THISCLASS::PropSheetPageProc(
    LPCQPAGE pQueryPage,
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("pQueryPage = 0x%p, hwnd = 0x%p, uMsg = 0x%p, wParam= 0x%p, lParam = 0x%p )\n"),
        pQueryPage, hwnd, uMsg, wParam, lParam );

    HRESULT hr = E_NOTIMPL;
    Assert( pQueryPage );
    LPTHISCLASS pQueryForm = (LPTHISCLASS )pQueryPage->lParam;
    Assert( pQueryForm );

    switch ( uMsg )
    {
    // Initialize so AddRef the object we are associated with so that
    // we don't get unloaded.

    case CQPM_INITIALIZE:
        TraceMsg( TF_WM, "CQPM_INITIALIZE\n" );
        pQueryForm->AddRef();
        hr = S_OK;
        break;

    // Release, therefore Release the object we are associated with to
    // ensure correct destruction etc.

    case CQPM_RELEASE:
        TraceMsg( TF_WM, "CQPM_RELEASE\n" );
        SetWindowLongPtr( pQueryForm->_hDlg, GWLP_USERDATA, NULL );
        pQueryForm->Release();
        hr = S_OK;
        break;

    // Enable so fix the state of our two controls within the window.

    case CQPM_ENABLE:
        TraceMsg( TF_WM, "CQPM_ENABLE\n" );
        EnableWindow( GetDlgItem( hwnd, IDC_E_SERVER ), (BOOL)wParam );
        hr = S_OK;
        break;

    // Fill out the parameter structure to return to the caller, this is
    // handler specific.  In our case we constructure a query of the CN
    // and objectClass properties, and we show a columns displaying both
    // of these.  For further information about the DSQUERYPARAMs structure
    // see dsquery.h

    case CQPM_GETPARAMETERS:
        TraceMsg( TF_WM, "CQPM_GETPARAMETERS\n" );
        hr = pQueryForm->_GetQueryParams( hwnd, (LPDSQUERYPARAMS*)lParam );
        break;

    // Clear form, therefore set the window text for these two controls
    // to zero.

    case CQPM_CLEARFORM:
        TraceMsg( TF_WM, "CQPM_CLEARFORM\n" );
        SetDlgItemText( hwnd, IDC_E_SERVER, L"" );
        hr = S_OK;
        break;

    case CQPM_SETDEFAULTPARAMETERS:
        TraceMsg( TF_WM, "CQPM_SETDEFAULTPARAMETERS: wParam = %s  lParam = 0x%p\n", BOOLTOSTRING(wParam), lParam );
        SetDlgItemText( hwnd, IDC_E_SERVER, L"*" );
        hr = S_OK;
        break;

    default:
        TraceMsg( TF_WM, "CQPM_message 0x%08x *** NOT IMPL ***\n", uMsg );
        hr = E_NOTIMPL;
        break;
    }

    RETURN(hr);
}

//
// _OnPSPCB_Create( )
//
HRESULT
THISCLASS::_OnPSPCB_Create( )
{
    TraceClsFunc( "_OnPSPCB_Create( )\n" );

    HRETURN(S_OK);
}
//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
    HWND hDlg,
    LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    _hDlg = hDlg;
    Edit_LimitText( GetDlgItem( _hDlg, IDC_E_SERVER), DNS_MAX_NAME_LENGTH );

    HRETURN(S_OK);
}


//
// _OnCommand( )
//
INT
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%p, lParam = 0x%p )\n", wParam, lParam );

#if 0
    switch ( LOWORD(wParam) )
    {
    }
#endif

    RETURN(FALSE);
}

//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%p, lParam = 0x%p )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;
    TraceMsg( TF_WM, "NMHDR:  HWND = 0x%p, idFrom = 0x%08x, code = 0x%08x\n",
        lpnmhdr->hwndFrom, lpnmhdr->idFrom, lpnmhdr->code );

#if 0
    switch( lpnmhdr->code )
    {
    }
#endif

    RETURN(FALSE);
}

struct
{
    INT fmt;
    INT cx;
    INT uID;
    LPCTSTR pDisplayProperty;
}
srvcolumns[] =
{
    0, 20, IDS_NAME, TEXT("cn"),    
};

//
// _GetQueryParams( )
//
HRESULT
THISCLASS::_GetQueryParams(
    HWND hWnd,
    LPDSQUERYPARAMS* ppdsqp )
{
    TraceClsFunc( "_GetQueryParams( )\n" );

    if ( !ppdsqp )
        HRETURN(E_POINTER);

    HRESULT hr = S_OK;
    INT     i;
    WCHAR   szServer[DNS_MAX_NAME_BUFFER_LENGTH];
    WCHAR   szFilter[ARRAYSIZE(FILTER_QUERY_SERVER)+ARRAYSIZE(szServer)];
    ULONG   offset;
    
    ULONG   cbStruct = 0;
    LPDSQUERYPARAMS pDsQueryParams = NULL;

#if 0
    if ( *ppdsqp )
    {
        // This page doesn't support appending its query data to an
        // existing DSQUERYPARAMS strucuture, only creating a new block,
        // therefore bail if we see the pointer is not NULL.
        hr = THR(E_INVALIDARG);
        goto Error;
    }
#endif

    if (!GetDlgItemText( hWnd, IDC_E_SERVER, szServer, ARRAYSIZE(szServer))) {
        wcscpy( szServer, L"*");
    }

    wsprintf( szFilter, FILTER_QUERY_SERVER, szServer );
    
    DebugMsg( "RI Filter: %s\n", szFilter );

    // compute the size of the new query block
    if ( !*ppdsqp )
    {
        offset = cbStruct = sizeof(DSQUERYPARAMS) + ((ARRAYSIZE(srvcolumns)-1)*sizeof(DSCOLUMN));
        cbStruct += StringByteSize(szFilter);
        for ( i = 0; i < ARRAYSIZE(srvcolumns); i++ )
        {
            cbStruct += StringByteSize(srvcolumns[i].pDisplayProperty);
        }
    }
    else
    {
        LPWSTR pszQuery;
        pszQuery = (LPWSTR) ((LPBYTE)(*ppdsqp) + (*ppdsqp)->offsetQuery);
        offset = (*ppdsqp)->cbStruct;
        cbStruct = (*ppdsqp)->cbStruct + StringByteSize( pszQuery ) + StringByteSize( szFilter );
    }

    // Allocate it and populate it with the data, the header is fixed
    // but the strings are referenced by offset.
    pDsQueryParams = (LPDSQUERYPARAMS)CoTaskMemAlloc(cbStruct);
    if ( !pDsQueryParams )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    // Did they hand in a query that we need to modify?
    if ( !*ppdsqp)
    {   // no... create our own query
        pDsQueryParams->cbStruct = cbStruct;
        pDsQueryParams->dwFlags = 0;
        pDsQueryParams->hInstance = g_hInstance;
        pDsQueryParams->offsetQuery = offset;
        pDsQueryParams->iColumns = ARRAYSIZE(srvcolumns);

        // Copy the filter string and bump the offset
        StringByteCopy(pDsQueryParams, offset, szFilter);
        offset += StringByteSize(szFilter);

        // Fill in the array of columns to dispaly, the cx is a percentage of the
        // current view, the propertie names to display are UNICODE strings and
        // are referenced by offset, therefore we bump the offset as we copy
        // each one.

        for ( i = 0 ; i < ARRAYSIZE(srvcolumns); i++ )
        {
            pDsQueryParams->aColumns[i].fmt = srvcolumns[i].fmt;
            pDsQueryParams->aColumns[i].cx = srvcolumns[i].cx;
            pDsQueryParams->aColumns[i].idsName = srvcolumns[i].uID;
            pDsQueryParams->aColumns[i].offsetProperty = offset;

            StringByteCopy(pDsQueryParams, offset, srvcolumns[i].pDisplayProperty);
            offset += StringByteSize(srvcolumns[i].pDisplayProperty);
        }
    }
    else
    {   // yes... add our parameters to the query
        LPWSTR pszQuery;
        LPWSTR pszNewQuery;
        INT    n;

        // duplicate the existing query
        Assert( offset == (*ppdsqp)->cbStruct );
        CopyMemory( pDsQueryParams, *ppdsqp, offset );
        pDsQueryParams->cbStruct = cbStruct;

#if 0
        // add our columns
        for ( i = 0 ; i < ARRAYSIZE(srvcolumns); i++ )
        {
            pDsQueryParams->aColumns[n+i].fmt = srvcolumns[i].fmt;
            pDsQueryParams->aColumns[n+i].cx = srvcolumns[i].cx;
            pDsQueryParams->aColumns[n+i].idsName = srvcolumns[i].uID;
            pDsQueryParams->aColumns[n+i].offsetProperty = offset;

            StringByteCopy(pDsQueryParams, offset, srvcolumns[i].pDisplayProperty);
            offset += StringByteSize(srvcolumns[i].pDisplayProperty);
        }
#endif
        // new query location
        pDsQueryParams->offsetQuery = offset;
        pszQuery = (LPWSTR) ((LPBYTE)(*ppdsqp) + (*ppdsqp)->offsetQuery);
        pszNewQuery = (LPWSTR) ((LPBYTE)pDsQueryParams + offset);
        Assert( pszQuery );

        // append to their query
        if ( StrCmpN( pszQuery, L"(&", 2 ) == 0 )
        {
            pszQuery[ wcslen( pszQuery ) - 1 ] = L'\0'; // remove ")"
        }
        else
        {
            wcscpy( pszNewQuery, L"(&" );               // add "(&" to begining of query
        }
        wcscat( pszNewQuery, pszQuery );                // add their query
        wcscat( pszNewQuery, &szFilter[2] );            // add our query starting after the "(&"
        offset += StringByteSize( pszNewQuery );        // compute new offset
        DebugMsg( "New Query String: %s\n", pszNewQuery );

        // Cleanup
        CoTaskMemFree( *ppdsqp );
    }

    // Success
    *ppdsqp = pDsQueryParams;
    Assert( hr == S_OK );

Cleanup:
    HRETURN(hr);
Error:
    if ( pDsQueryParams )
        CoTaskMemFree( pDsQueryParams );

    // If we aren't modifying the query and there wasn't
    // a query handed into us, indicate failure instead.
    if ( hr == S_FALSE && !*ppdsqp )
    {
        hr = E_FAIL;
    }
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\tools.h ===
//
// Copyright 1997 - Microsoft

//
// CLIENT.H - Handles the "IntelliMirror" IDD_PROP_INTELLIMIRROR_CLIENT tab
//


#ifndef _TOOLS_H_
#define _TOOLS_H_

// Definitions
LPVOID
CToolsTab_CreateInstance( void );

class CComputer;
typedef CComputer* LPCComputer;

// CToolsTab
class
CToolsTab:
    public ITab
{
private:
    HWND  _hDlg;
    LPUNKNOWN _punkService;     // Pointer back to owner object

    BOOL    _fAdmin;

    HWND    _hNotify;           // DSA's notify object

private: // Methods
    CToolsTab();
    ~CToolsTab();
    STDMETHOD(Init)();

    // Property Sheet Functions
    HRESULT _InitDialog( HWND hDlg, LPARAM lParam );
    HRESULT _OnCommand( WPARAM wParam, LPARAM lParam );
    INT     _OnNotify( WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    HRESULT _OnSelectionChanged( );

public: // Methods
    friend LPVOID CToolsTab_CreateInstance( void );

    // ITab
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                            LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(QueryInformation)( LPWSTR pszAttribute, LPWSTR * pszResult );
    STDMETHOD(AllowActivation)( BOOL * pfAllow );
};

typedef CToolsTab* LPCToolsTab;

#endif // _TOOLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\tools.cpp ===
//
// Copyright 1997 - Microsoft

//
// TOOLS.CPP - Handles the "Tools" IDD_PROP_TOOLS tab
//


#include "pch.h"

#include "utils.h"
#include "cservice.h"
#include "cenumsif.h"
#include "tools.h"
#include "ccomputr.h"
#include "sifprop.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CToolsTab")
#define THISCLASS CToolsTab
#define LPTHISCLASS CToolsTab*

#define NUM_COLUMNS				    3

DWORD aToolsHelpMap[] = {
    IDC_L_TOOLS, HIDC_L_TOOLS,
    IDC_B_REMOVE, HIDC_B_REMOVE,
    IDC_B_PROPERTIES, HIDC_B_PROPERTIES,
    IDC_B_REFRESH, HIDC_B_REFRESH,
    NULL, NULL
};

//
// CreateInstance()
//
LPVOID
CToolsTab_CreateInstance( void )
{
	TraceFunc( "CToolsTab_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CToolsTab()\n" );

	InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CToolsTab()\n" );

    if ( _punkService )
        _punkService->Release( );

    // tell ADS to destroy the notify object
    // NOTE: Another property page may do this before us. Ignore errors.
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_EXIT, 0, 0 );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// *************************************************************************
//
// ITab
//
// *************************************************************************

STDMETHODIMP
THISCLASS::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam,
    LPUNKNOWN punk )
{
    TraceClsFunc( "AddPages( )\n" );

    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
    psp.hInstance   = (HINSTANCE) g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP_TOOLS);
    psp.pcRefParent = (UINT *) &g_cObjects;
    psp.pfnCallback = (LPFNPSPCALLBACK) PropSheetPageProc;
    psp.pfnDlgProc  = PropSheetDlgProc;
    psp.lParam      = (LPARAM) this;

    hpage = CreatePropertySheetPage( &psp );
    if ( hpage )
    {
        if ( !lpfnAddPage( hpage, lParam ) )
        {
            DestroyPropertySheetPage( hpage );
            hr = E_FAIL;
            goto Error;
        }
    }

    punk->AddRef( );   // matching Release in the destructor
    _punkService = punk;

Error:
    HRETURN(hr);
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam,
    LPUNKNOWN punk )
{

    TraceClsFunc( "ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    RETURN(E_NOTIMPL);
}

//
// QueryInformation( )
//
STDMETHODIMP
THISCLASS::QueryInformation(
    LPWSTR pszAttribute,
    LPWSTR * pszResult )
{
    TraceClsFunc( "QueryInformation( )\n" );

    HRETURN(E_NOTIMPL);
}

//
// AllowActivation( )
//
STDMETHODIMP
THISCLASS::AllowActivation(
    BOOL * pfAllow )
{
    TraceClsFunc( "AllowActivation( )\n" );

    HRETURN(E_NOTIMPL);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************


//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
    HWND hDlg,
    LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    CWaitCursor Wait;

    HRESULT hr = S_OK;
    HWND hwndList;

    IIntelliMirrorSAP * pimsap = NULL;
    IEnumIMSIFs * penum = NULL;
    LV_COLUMN lvC;
    INT iCount;
    WCHAR szText[ 64 ];
    UINT uColumnWidths[NUM_COLUMNS] = { 225, 75, 75 };

    if ( hDlg )
    {
        _hDlg = hDlg;
    }

    hwndList = GetDlgItem( _hDlg, IDC_L_TOOLS );

    Assert( _punkService );
    hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
    if (hr) {
        Assert( _fAdmin == FALSE );
        goto Error;
    }

    hr = THR( pimsap->GetNotifyWindow( &_hNotify ) );
    if (FAILED( hr ))
        goto Error;

    ADsPropSetHwnd( _hNotify, _hDlg );

    hr = THR( pimsap->IsAdmin( &_fAdmin ) );
    if (hr) {
        Assert( _fAdmin == FALSE );
    }

    hr = THR( pimsap->EnumTools( ENUM_READ, (LPUNKNOWN*)&penum ) );
    if (hr)
    {
        Assert( _fAdmin == FALSE );
        goto Error;
    }

    ListView_DeleteAllItems( hwndList );

    // Create the columns
    lvC.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt     = LVCFMT_LEFT;
    lvC.pszText = szText;

    // Add the columns.
    for ( iCount = 0; iCount < NUM_COLUMNS; iCount++ )
    {
        INT i;

        lvC.iSubItem = iCount;
        lvC.cx       = uColumnWidths[iCount];

        i = LoadString( g_hInstance, IDS_OS_COLUMN1 + iCount, szText, ARRAYSIZE (szText) );
        Assert( i );

        i = ListView_InsertColumn ( hwndList, iCount, &lvC );
        Assert( i != -1 );
    }

    hr = PopulateListView( hwndList, penum );
    if(FAILED(hr))
    {
        MessageBoxFromStrings( _hDlg,
                               IDS_COULDNOTCONTACTSERVER_CAPTION,
                               IDS_COULDNOTCONTACTSERVER_TEXT,
                               MB_OK | MB_ICONERROR );
    }

Cleanup:
    if ( penum )
        penum->Release( );
    if ( pimsap )
        pimsap->Release( );

    EnableWindow( hwndList, _fAdmin );

    HRETURN(hr);

Error:
    switch (hr) {
    case S_OK:
        break;
    default:
        MessageBoxFromHResult( _hDlg, IDS_ERROR_OPENNINGGROUPOBJECT, hr );
        break;
    }
    goto Cleanup;
}

//
// _OnSelectionChanged( )
//
HRESULT
THISCLASS::_OnSelectionChanged( )
{
    TraceClsFunc( "_OnSelectionChanged( )\n" );

    HRESULT hr = S_OK;
    UINT iItems = ListView_GetSelectedCount( GetDlgItem( _hDlg, IDC_L_TOOLS ) );
    EnableWindow( GetDlgItem( _hDlg, IDC_B_REMOVE ), !!iItems );
    EnableWindow( GetDlgItem( _hDlg, IDC_B_PROPERTIES ), !!iItems );

    HRETURN( hr );
}

//
// _OnCommand( )
//
HRESULT
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    HRESULT hr = S_FALSE;
    HWND hwndCtl = (HWND) lParam;

    switch( LOWORD(wParam) )
    {
    case IDC_B_PROPERTIES:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            LVITEM lvi;
            HWND hwndList = GetDlgItem( _hDlg, IDC_L_TOOLS );
            lvi.iItem = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );

            if ( lvi.iItem != -1 )
            {
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( hwndList, &lvi );

                Assert(lvi.lParam);
                hr = CSifProperties_CreateInstance( _hDlg, MAKEINTRESOURCE(IDD_SIF_PROP_TOOLS), (LPSIFINFO) lvi.lParam );
            }
        }
        break;

    case IDC_B_REFRESH:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            hr = S_OK;
        }
        break;

    case IDC_B_REMOVE:
        if ( HIWORD( wParam ) == BN_CLICKED ) {
            LVITEM lvi;
            UINT iResult;
            HWND hwndList = GetDlgItem( _hDlg, IDC_L_TOOLS );
            lvi.iItem = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );

            iResult = MessageBoxFromStrings( _hDlg, IDS_AREYOUSURE_CAPTION, IDS_DELETESIF_TEXT, MB_YESNO );
            if ( iResult == IDYES )
            {
                if ( lvi.iItem != -1 )
                {
                    HRESULT hr;
                    LPSIFINFO psif;

                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem( hwndList, &lvi );

                    psif = (LPSIFINFO)lvi.lParam;

                    if ( !DeleteFile( psif->pszFilePath ) )
                    {
                        ::MessageBoxFromError( _hDlg, 0, GetLastError() );
                    } else {
                        ListView_DeleteItem( hwndList, lvi.iItem );
                        hr = S_OK;
                    }
                }
            }
        }
        break;
    }

    if ( hr == S_OK )
    {
        HWND hwndList = GetDlgItem(_hDlg, IDC_L_TOOLS);
        IIntelliMirrorSAP * pimsap = NULL;
        hr = THR( _punkService->QueryInterface( IID_IIntelliMirrorSAP, (void**) &pimsap ) );
        if (hr == S_OK)
        {
            LPENUMSIFS penum = NULL;
            hr = THR( pimsap->EnumTools( ENUM_READ, (LPUNKNOWN*)&penum ) );
            if ( hr == S_OK )
            {
                hr = PopulateListView( hwndList, penum);
                penum->Release();
            }
            pimsap->Release();
        }

        // See if we still have a selection
        _OnSelectionChanged( );
    }

    HRETURN(hr);
}

//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;

    switch( lpnmhdr->code )
    {
    case PSN_APPLY:
        TraceMsg( TF_WM, TEXT("WM_NOTIFY: PSN_APPLY\n"));
        // Tell DSA that someone hit Apply
        SendMessage( _hNotify, WM_ADSPROP_NOTIFY_APPLY, 0, 0 );
        SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, PSNRET_NOERROR );
        RETURN(TRUE);

    case LVN_ITEMCHANGED:
        {
            _OnSelectionChanged( );
        }
        break;

    case LVN_DELETEALLITEMS:
        DebugMsg( "LVN_DELETEALLITEMS - Deleting all items.\n" );
        RETURN(FALSE);

    case LVN_DELETEITEM:
        {
            LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;
            LPSIFINFO psif = (LPSIFINFO) pnmv->lParam;
            Assert( psif );

            if ( psif )
            {
                TraceFree( psif->pszArchitecture );
                TraceFree( psif->pszDescription );
                TraceFree( psif->pszDirectory );
                TraceFree( psif->pszFilePath );
                TraceFree( psif->pszHelpText );
                TraceFree( psif->pszImageType );
                TraceFree( psif->pszLanguage );
                TraceFree( psif->pszVersion );
                TraceFree( psif->pszImageFile );
                TraceFree( psif );
            }
        }
        break;
    }

    RETURN(FALSE);
}

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, psp->lParam );
        pcc = (LPTHISCLASS) psp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc)
    {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg )
        {
        case WM_NOTIFY:
            pcc->_OnNotify( wParam, lParam );
            break;

        case WM_COMMAND:
            TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
            pcc->_OnCommand( wParam, lParam );
            break;

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aToolsHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aToolsHelpMap );
            break;

        case WM_ADSPROP_PAGE_GET_NOTIFY:
            {
                HWND *phwnd = (HWND *) wParam;
                *phwnd = pcc->_hNotify;
            }
            return TRUE;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
UINT CALLBACK
THISCLASS::PropSheetPageProc(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp )
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("hwnd = 0x%08x, uMsg = 0x%08x, ppsp= 0x%08x )\n"),
        hwnd, uMsg, ppsp );

    switch ( uMsg )
    {
    case PSPCB_CREATE:
        RETURN(TRUE);   // create it
        break;

    case PSPCB_RELEASE:
        LPTHISCLASS pcc = (LPTHISCLASS) ppsp->lParam;
        delete pcc;
        break;
    }

    RETURN(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\utils.cpp ===
/************************************************************************

   Copyright (c) Microsoft Corporation 1997-1999
   All rights reserved

 ***************************************************************************/

//
// UTILS.CPP - Common non-class specific utility calls.
//


#include "pch.h"

#include <dsgetdc.h>
#include <lm.h>
#include "cenumsif.h"
#include "utils.h"

#include <dsadmin.h>

DEFINE_MODULE("IMADMUI")

#define SMALL_BUFFER_SIZE		256
#define OSVERSION_SIZE			30
#define IMAGETYPE_SIZE          30
#define FILTER_GUID_QUERY L"(&(objectClass=computer)(netbootGUID=%ws))"

WCHAR g_wszLDAPPrefix[] = L"LDAP://";
const LONG SIZEOF_g_wszLDAPPrefix = sizeof(g_wszLDAPPrefix);

//
// AddPagesEx()
//
// Creates and adds a property page.
//
HRESULT
AddPagesEx(
    ITab ** pTab,
    LPCREATEINST pfnCreateInstance,
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam,
    LPUNKNOWN punk )
{ 
    TraceFunc( "AddPagesEx( ... )\n" );

    HRESULT hr = S_OK;
    ITab * lpv;

    if ( pTab == NULL )
    {
        pTab = &lpv;
    }

    *pTab = (LPTAB) pfnCreateInstance( );
    if ( !*pTab )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    hr = THR( (*pTab)->AddPages( lpfnAddPage, lParam, punk ) );
    if (hr)
        goto Error;

Cleanup:
    RETURN(hr); 

Error:
    if ( *pTab )
    {
        delete *pTab;
        *pTab = NULL;
    }

    goto Cleanup;
} 


//
// CheckClipboardFormats( )
//
HRESULT
CheckClipboardFormats( )
{
    TraceFunc( "CheckClipboardFormats( )\n" );

    HRESULT hr = S_OK;

    if ( !g_cfDsObjectNames && hr == S_OK )
    {
        g_cfDsObjectNames = RegisterClipboardFormat( CFSTR_DSOBJECTNAMES );
        if ( !g_cfDsObjectNames )
        {
            hr = E_FAIL;
        }
    }

    if ( !g_cfDsDisplaySpecOptions && hr == S_OK )
    {
        g_cfDsDisplaySpecOptions = RegisterClipboardFormat( CFSTR_DS_DISPLAY_SPEC_OPTIONS );
        if ( !g_cfDsDisplaySpecOptions )
        {
            hr = E_FAIL;
        }
    }

    if ( !g_cfDsPropetyPageInfo && hr == S_OK )
    {
        g_cfDsPropetyPageInfo = RegisterClipboardFormat( CFSTR_DSPROPERTYPAGEINFO );
        if ( !g_cfDsObjectNames )
        {
            hr = E_FAIL;
        }
    }

    if ( !g_cfMMCGetNodeType && hr == S_OK )
    {
        g_cfMMCGetNodeType = RegisterClipboardFormat( CCF_NODETYPE );
        if ( !g_cfMMCGetNodeType )
        {
            hr = E_FAIL;
        }
    }


    RETURN(hr);
}


//
// DNtoFQDN( )
//
// Changes a MAO DN to and FQDN. 
//
// Input:   pszDN - string e.g cn=HP,cn=computers,dc=GPEASE,dc=DOM
//
// Output:  *pszFQDN - LocalAlloc'ed string with the generated FQDN
//
HRESULT
DNtoFQDN( 
    LPWSTR pszDN,
    LPWSTR * pszFQDN )
{
    TraceFunc( "DNtoFQDN( " );
    TraceMsg( TF_FUNC, "pszDN = '%s', *pszFQDN = 0x%08x )\n", pszDN, (pszFQDN ? *pszFQDN : NULL) );

    if ( !pszFQDN )
        RRETURN(E_POINTER);

    HRESULT hr = S_OK;
    LPWSTR  pszNext;

    // skip the "cn=" and duplicate
    *pszFQDN = (LPWSTR) TraceStrDup( &pszDN[3] );
    if ( !*pszFQDN )
    {
        hr = THR(E_OUTOFMEMORY);
        goto Error;
    }

    pszNext = *pszFQDN;
    while ( pszNext && *pszNext )
    {
        LPWSTR  psz;

        psz = StrChr( pszNext, L',' );
        if ( !psz )
            break;

        *psz = L'.';
        pszNext = psz;
        pszNext++;

        psz = StrStrI( pszNext, L"dc=" );
        Assert( psz ); // this shouldn't happen
        if (!psz)
            break;

        psz += 3;
        StrCpy( pszNext, psz );
    }

Error:
    HRETURN(hr);
}

//
// PopulateListView( )
//
HRESULT
PopulateListView( 
    HWND hwndList, 
    IEnumIMSIFs * penum )
{
    TraceFunc( "PopulateListView( ... )\n" );

    HRESULT hr = S_OK;
    INT iCount;
    LV_ITEM lvI;

    if ( !penum )
        HRETURN(E_POINTER);

    lvI.mask        = LVIF_TEXT | LVIF_PARAM;
    lvI.iSubItem    = 0;
    lvI.cchTextMax  = REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT;

    ListView_DeleteAllItems( hwndList );

    iCount = 0;
    while ( hr == S_OK )
    {
        WIN32_FILE_ATTRIBUTE_DATA fda;
        WCHAR szBuf[ MAX_PATH ];
        LPSIFINFO pSIF;
        LPWSTR pszFilePath;
        LPWSTR pszBegin;
        INT i;  // general purpose
        
        hr = penum->Next( 1, &pszFilePath, NULL );
        if ( hr )
        {
            if ( pszFilePath )
                TraceFree( pszFilePath );
            break;  // abort
        }

        // Create private storage structure
        pSIF = (LPSIFINFO) TraceAlloc( LPTR, sizeof(SIFINFO) );
        if ( !pSIF )
        {
            if ( pszFilePath )
                TraceFree( pszFilePath );
            continue;   // oh well, try again next OS
        }

        // Save this
        pSIF->pszFilePath = pszFilePath;

        // Get the description
        pSIF->pszDescription = (LPWSTR) TraceAllocString( LMEM_FIXED, REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT );
		if ( !pSIF->pszDescription )
			goto Cleanup;
        GetPrivateProfileString( OSCHOOSER_SIF_SECTION, 
                                 OSCHOOSER_DESCRIPTION_ENTRY, 
                                 L"??", 
                                 pSIF->pszDescription,
                                 REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT,  // doesn't need -1
                                 pszFilePath );

        // Grab any help text
		pSIF->pszHelpText = (LPWSTR) TraceAllocString( LMEM_FIXED, REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT );
		if ( !pSIF->pszHelpText )
			goto Cleanup;
        GetPrivateProfileString( OSCHOOSER_SIF_SECTION, 
                                 OSCHOOSER_HELPTEXT_ENTRY, 
                                 L"", 
                                 pSIF->pszHelpText,
                                 REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT, // doesn't need -1
                                 pszFilePath );

        // Grab the OS Version
		pSIF->pszVersion= (LPWSTR) TraceAllocString( LMEM_FIXED, OSVERSION_SIZE );
		if ( !pSIF->pszVersion )
			goto Cleanup;
        GetPrivateProfileString( OSCHOOSER_SIF_SECTION, 
                                 OSCHOOSER_VERSION_ENTRY, 
                                 L"", 
                                 pSIF->pszVersion,
                                 OSVERSION_SIZE, 
                                 pszFilePath );

        // Grab the last modified Time/Date stamp
        if ( GetFileAttributesEx( pszFilePath, GetFileExInfoStandard, &fda ) )
        {
            pSIF->ftLastWrite = fda.ftLastWriteTime;
        } else {
            ZeroMemory( &pSIF->ftLastWrite, sizeof(pSIF->ftLastWrite) );
        }

        // Figure out the language and architecture. 
        // These are retrieved from the FilePath.
        // \\machine\REMINST\Setup\English\Images\nt50.wks\i386\templates\rbstndrd.sif
        pszBegin = pSIF->pszFilePath;
        for( i = 0; i < 5; i ++ ) 
        {
            pszBegin = StrChr( pszBegin, L'\\' );
            if ( !pszBegin )
                break;
            pszBegin++;
        }
        if ( pszBegin )
        {
            LPWSTR pszEnd = StrChr( pszBegin, L'\\' );
            if ( pszEnd )
            {
                *pszEnd = L'\0';   // terminate
                pSIF->pszLanguage = (LPWSTR) TraceStrDup( pszBegin );
                *pszEnd = L'\\';   // restore
            }
        }

        for( ; i < 7; i ++ ) 
        {
            pszBegin = StrChr( pszBegin, L'\\' );
            if ( !pszBegin )
                break;
            pszBegin++;
        }
        if ( pszBegin )
        {
            LPWSTR pszEnd = StrChr( pszBegin, L'\\' );
            if ( pszEnd )
            {
                *pszEnd = L'\0';
                pSIF->pszDirectory = (LPWSTR) TraceStrDup( pszBegin );
                *pszEnd = L'\\';
            }
        }

        for( ; i < 8; i ++ ) 
        {
            pszBegin = StrChr( pszBegin, L'\\' );
            if ( !pszBegin )
                break;
            pszBegin++;
        }
        if ( pszBegin )
        {
            LPWSTR pszEnd = StrChr( pszBegin, L'\\' );
            if ( pszEnd )
            {
                *pszEnd = L'\0';
                pSIF->pszArchitecture = (LPWSTR) TraceStrDup( pszBegin );
                *pszEnd = L'\\';
            }
        }

        // Figure out what kind of image it is
        pSIF->pszImageType = (LPWSTR) TraceAllocString( LMEM_FIXED, IMAGETYPE_SIZE );
		if ( !pSIF->pszImageType )
			goto Cleanup;
        GetPrivateProfileString( OSCHOOSER_SIF_SECTION, 
                                 OSCHOOSER_IMAGETYPE_ENTRY, 
                                 L"??", 
                                 pSIF->pszImageType,
                                 IMAGETYPE_SIZE, 
                                 pszFilePath );

        // Figure out what image it uses
        GetPrivateProfileString( OSCHOOSER_SIF_SECTION, 
                                 OSCHOOSER_LAUNCHFILE_ENTRY, 
                                 L"??", 
                                 szBuf,
                                 ARRAYSIZE( szBuf ), 
                                 pszFilePath );

        pszBegin = StrRChr( szBuf, &szBuf[wcslen(szBuf)], L'\\' );
        if ( pszBegin )
        {
            pszBegin++;
            pSIF->pszImageFile = (LPWSTR) TraceStrDup( pszBegin );
        }

        // Add the item to list view
        lvI.lParam   = (LPARAM) pSIF;
        lvI.iItem    = iCount;
        lvI.pszText  = pSIF->pszDescription; 
        iCount = ListView_InsertItem( hwndList, &lvI );
        Assert( iCount != -1 );
        if ( iCount == -1 )
            goto Cleanup;
        if ( pSIF->pszArchitecture )
        {
            ListView_SetItemText( hwndList, iCount, 1, pSIF->pszArchitecture );
        }
        if ( pSIF->pszLanguage )
        {
            ListView_SetItemText( hwndList, iCount, 2, pSIF->pszLanguage );
        }
        if ( pSIF->pszVersion )
        {
            ListView_SetItemText( hwndList, iCount, 3, pSIF->pszVersion );
        }

        continue;   // next!
Cleanup:
        if ( pSIF )
        {
            if (pSIF->pszDescription != NULL) {
                TraceFree( pSIF->pszDescription );
            }

            TraceFree( pSIF->pszFilePath );

            if (pSIF->pszHelpText != NULL) {
                TraceFree( pSIF->pszHelpText );
            }

            if (pSIF->pszImageType != NULL) {
                TraceFree( pSIF->pszImageType );
            }

            TraceFree( pSIF->pszLanguage );
            
            if (pSIF->pszVersion != NULL) {
                TraceFree( pSIF->pszVersion );
            }
            TraceFree( pSIF->pszImageFile );
            TraceFree( pSIF );
        }
    }

    HRETURN(hr);
}


//
// LDAPPrefix( )
//
// Returns:
//     E_OUTOFMEMORY - if out of memory
//     S_OK          - added LDAP:// to the pszObjDN
//     S_FALSE       - didn't have to add anything and copied the pszObjDN
//                     into ppszObjLDAPPath
HRESULT
LDAPPrefix(
    PWSTR pszObjDN, 
    PWSTR * ppszObjLDAPPath)
{
    TraceFunc( "LDAPPrefix( ... )\n" );

    if (pszObjDN == NULL)
        HRETURN(E_POINTER);

    HRESULT hr;

    const LONG cchPrefix = ARRAYSIZE(g_wszLDAPPrefix) - 1;
    LONG cch = wcslen(pszObjDN);

    if (wcsncmp(pszObjDN, g_wszLDAPPrefix, cchPrefix))
    {
        LPWSTR psz;
        psz = (LPWSTR) TraceAllocString( LPTR, cch + cchPrefix + 1 );
        if ( !psz ) {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        wcscpy(psz, g_wszLDAPPrefix);
        wcscat(psz, pszObjDN);

        *ppszObjLDAPPath = psz;
        hr = S_OK;
    }
    else
    {
        *ppszObjLDAPPath = pszObjDN;
        hr = S_FALSE;
    }

Error:
    HRETURN(hr);
}

//
// Create a message box from resource strings.
//
int
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType )
{
    TCHAR szText[ SMALL_BUFFER_SIZE * 2 ];
    TCHAR szCaption[ SMALL_BUFFER_SIZE ];
    DWORD dw;

    szCaption[0] = TEXT('\0');
    szText[0] = TEXT('\0');
    dw = LoadString( g_hInstance, idsCaption, szCaption, ARRAYSIZE(szCaption) );
    Assert( dw );
    dw = LoadString( g_hInstance, idsText, szText, ARRAYSIZE(szText));
    Assert( dw );

    return MessageBox( hParent, szText, szCaption, uType );
}

//
// MessageBoxFromError( )
//
// Creates a error message box
//
void 
MessageBoxFromError(
    HWND hParent,
    UINT idsCaption,
    DWORD dwErr )
{
    WCHAR szTitle[ SMALL_BUFFER_SIZE ];
    LPTSTR lpMsgBuf = NULL;
    DWORD dw;

    if ( dwErr == ERROR_SUCCESS ) {
        AssertMsg( dwErr, "Why was MessageBoxFromError() called when the dwErr == ERROR_SUCCES?" );
        return;
    }

    if ( !idsCaption ) {
        idsCaption = IDS_ERROR;
    }

    szTitle[0] = TEXT('\0');
    dw = LoadString( g_hInstance, idsCaption, szTitle, ARRAYSIZE(szTitle) );
    Assert( dw );

    FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwErr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL 
    );

    if (lpMsgBuf == NULL) {
        AssertMsg( (lpMsgBuf != NULL), "MessageBoxFromError() called with unknown message." );
        return;
    }

    MessageBox( hParent, lpMsgBuf, szTitle, MB_OK | MB_ICONERROR );
    LocalFree( lpMsgBuf );
}

//
// MessageBoxFromError( )
//
// Creates a error message box
//
void
MessageBoxFromHResult(
    HWND hParent,
    UINT idsCaption,
    HRESULT hr )
{
    WCHAR szTitle[ SMALL_BUFFER_SIZE ];
    LPTSTR lpMsgBuf = NULL;
    DWORD dw;

    if ( SUCCEEDED( hr ) ) {
        AssertMsg( SUCCEEDED( hr ), "Why was MessageBoxFromHResult() called when the HR succeeded?" );
        return;
    }

    if ( !idsCaption ) {
        idsCaption = IDS_ERROR;
    }

    szTitle[0] = TEXT('\0');
    dw = LoadString( g_hInstance, idsCaption, szTitle, ARRAYSIZE(szTitle) );
    Assert( dw );

    FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        hr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL 
    );

    if (lpMsgBuf == NULL) {
        AssertMsg( (lpMsgBuf != NULL), "MessageBoxFromHResult() called with unknown message." );
        return;
    }

    MessageBox( hParent, lpMsgBuf, szTitle, MB_OK | MB_ICONERROR );
    LocalFree( lpMsgBuf );
}

//
// VerifySIFText( )
//
BOOL
VerifySIFText(
    LPWSTR pszText )
{
    TraceFunc( "VerifySIFText()\n" );
    BOOL fReturn = FALSE;

    if ( !pszText )
        RETURN(fReturn);

    while ( *pszText >= 32 && *pszText < 128 )
        pszText++;

    if ( *pszText == L'\0' )
    {
        fReturn = TRUE;
    }

    RETURN(fReturn);
}

#ifndef ADSI_DNS_SEARCH
//
// Ldap_InitializeConnection( )
//
DWORD
Ldap_InitializeConnection(
    PLDAP  * LdapHandle )
{
    TraceFunc( "Ldap_InitializeConnection( ... )\n" );

    PLDAPMessage OperationalAttributeLdapMessage;
    PLDAPMessage CurrentEntry;

    DWORD LdapError = LDAP_SUCCESS;

    if ( !( *LdapHandle ) ) {
        ULONG temp = DS_DIRECTORY_SERVICE_REQUIRED |
                     DS_IP_REQUIRED |
                     DS_GC_SERVER_REQUIRED;

        *LdapHandle = ldap_init( NULL, 3268);

        if ( !*LdapHandle ) 
        {
            LdapError = LDAP_UNAVAILABLE;
            goto e0;
        }

        ldap_set_option( *LdapHandle, LDAP_OPT_GETDSNAME_FLAGS, &temp );

        temp = LDAP_VERSION3;
        ldap_set_option( *LdapHandle, LDAP_OPT_VERSION, &temp );

        LdapError = ldap_connect( *LdapHandle, 0 );

        if ( LdapError != LDAP_SUCCESS )
            goto e1;

        LdapError = ldap_bind_s( *LdapHandle, NULL, NULL, LDAP_AUTH_SSPI );

        if ( LdapError != LDAP_SUCCESS ) 
            goto e1;
    }

e0:
    RETURN( LdapError );

e1:
    ldap_unbind( *LdapHandle );
    *LdapHandle = NULL;
    goto e0;
}

#endif // ADSI_DNS_SEARCH

//
// ValidateGuid( )
//
// Returns: S_OK if a complete, valid GUID is in pszGuid.
//          S_FALSE if an valid but incomplete GUID is in pszGuid. "Valid but
//              incomplete" is defined below.
//          E_FAIL if an invalid character is encountered while parsing.
//
// Valid characters are 0-9, A-F, a-f and "{-}"s. All spaces are ignored.
// The GUID must appear in one of the following forms:
//
// 1. 00112233445566778899aabbccddeeff
//      This corresponds to the actual in-memory storage order of a GUID.
//      For example, it is the order in which GUID bytes appear in a
//      network trace.
//
// 2. {33221100-5544-7766-8899-aabbccddeeff}
//      This corresponds to the "standard" way of printing GUIDs. Note
//      that the "pretty" GUID shown here is the same as the GUID shown
//      above.
//
// Note that the DEFINE_GUID macro (see sdk\inc\objbase.h) for the above
// GUID would look like this:
//      DEFINE_GUID(name,0x33221100,0x5544,0x7766,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff)
//
// "Valid but incomplete" means that the input consists of an even number
// of hex characters (no lone nibbles), and if the input is in "pretty"
// format, the input must terminate at one of the dashes or after the
// second-to-the-last dash.
//
// The following are valid but incomplete entries:
//      001122
//      {33221100
//      {33221100-5544
//      {33221100-5544-7766-88
//      
// The following are invalid incomplete entries:
//      00112
//      {332211
//      {33221100-5544-77
//      

//
// In the xxxGuidCharacters arrays, values [0,31] indicate nibble positions within
// the in-memory representation of the GUID. Value 32 indicates the end of the
// GUID string. Values 33 and up indicate special characters (nul,'-','{','}') and
// are used to index into an array containing those characters.
//

#define VG_DONE     32
#define VG_NULL     33
#define VG_DASH     34
#define VG_LBRACK   35
#define VG_RBRACK   36

CHAR InMemoryFormatGuidCharacters[] = {
     1,          0,          3,          2,          5,          4,          7,          6,     
     9,          8,         11,         10,         13,         12,         15,         14,     
    17,         16,         19,         18,         21,         20,         23,         22,     
    25,         24,         27,         26,         29,         28,         31,         30,     
    VG_NULL,    VG_DONE };

CHAR PrettyFormatGuidCharacters[] = {
    VG_LBRACK,   7,          6,          5,          4,          3,          2,          1,    
     0,         VG_DASH,    11,         10,          9,          8,         VG_DASH,    15,     
    14,         13,         12,         VG_DASH,    17,         16,         19,         18,    
    VG_DASH,    21,         20,         23,         22,         25,         24,         27,     
    26,         29,         28,         31,         30,         VG_RBRACK,  VG_NULL,    VG_DONE };

WCHAR SpecialCharacters[] = {
    0,      // VG_NULL
    L'-',   // VG_DASH
    L'{',   // VG_LBRACK
    L'}',   // VG_RBRACK
    };

PWSTR ByteToHex = L"0123456789ABCDEF";

HRESULT
ValidateGuid(
    IN LPWSTR pszGuid,
    OUT LPBYTE uGuid OPTIONAL,
    OUT LPDWORD puGuidLength OPTIONAL )
{
    TraceFunc( "ValidateGuid( " );
    TraceMsg( TF_FUNC, "pszGuid = '%s'\n", pszGuid );

    HRESULT hr;
    PCHAR expectedCharacter;
    CHAR e;
    WCHAR g;
    BOOL parsingPrettyFormat;
    DWORD numberOfHexDigitsParsed;

#ifdef DEBUG
    if ( uGuid != NULL ) {
        for ( e = 0; e < 16; e++ ) {
            uGuid[e] = 0;
        }
    }
#endif

    if ( *pszGuid == L'{' ) {
        expectedCharacter = PrettyFormatGuidCharacters;
        parsingPrettyFormat = TRUE;
    } else {
        expectedCharacter = InMemoryFormatGuidCharacters;
        parsingPrettyFormat = FALSE;
    }

    numberOfHexDigitsParsed = 0;

    do {

        e = *expectedCharacter++;
        do {
            g = *pszGuid++;
        } while (iswspace(g));

        switch ( e ) {
        
        case VG_NULL:
        case VG_DASH:
        case VG_LBRACK:
        case VG_RBRACK:
            if ( g != SpecialCharacters[e - VG_NULL] ) {
                if ( g == 0 ) {
                    // valid but incomplete
                    hr = S_FALSE;
                } else {
                    hr = E_FAIL;
                }
                goto done;
            }
            break;

        default:
            Assert( (e >= 0) && (e < VG_DONE) );
            g = towlower( g );
            if ( ((g >= L'0') && (g <= L'9')) ||
                 ((g >= L'a') && (g <= L'f')) ) {
                if ( uGuid != NULL ) {
                    BYTE n = (BYTE)((g > L'9') ? (g - L'a' + 10) : (g - '0'));
                    if ( e & 1 ) {
                        Assert( uGuid[e/2] == 0 );
                        uGuid[e/2] = n << 4;
                    } else {
                        uGuid[e/2] += n;
                    }
                }
                numberOfHexDigitsParsed++;
            } else {
                if ( (g == 0) &&
                     (!parsingPrettyFormat ||
                      (parsingPrettyFormat && (numberOfHexDigitsParsed >= 16))) ) {
                    hr = S_FALSE;
                } else {
                    hr = E_FAIL;
                }
                goto done;
            }
            break;
        }

    } while ( *expectedCharacter != VG_DONE );

    hr = S_OK;

done:

    if ( puGuidLength != NULL ) {
        *puGuidLength = numberOfHexDigitsParsed / 2;
    }

    HRETURN(hr);
}

//
// PrettyPrintGuid( )
//
LPWSTR
PrettyPrintGuid( 
    LPBYTE uGuid )
{
    TraceFunc( "PrettyPrintGuid( " );

    LPWSTR pszPrettyString = (LPWSTR) TraceAlloc( LMEM_FIXED, PRETTY_GUID_STRING_BUFFER_SIZE );
    if ( pszPrettyString )
    {
        PCHAR characterType = PrettyFormatGuidCharacters;
        LPWSTR pszDest = pszPrettyString;
        CHAR ct;
        BYTE n;

        do {
    
            ct = *characterType++;
    
            switch ( ct ) {
            
            case VG_NULL:
            case VG_DASH:
            case VG_LBRACK:
            case VG_RBRACK:
                *pszDest = SpecialCharacters[ct - VG_NULL];
                break;
    
            default:
                if ( ct & 1 ) {
                    n = uGuid[ct/2] >> 4;
                } else {
                    n = uGuid[ct/2] & 0xf;
                }
                *pszDest = ByteToHex[n];
                break;
            }

            pszDest++;

        } while ( *characterType != VG_DONE );
    }

    RETURN(pszPrettyString);
}


//
// CheckForDuplicateGuid( )
//
// Returns: S_OK if no duplicates found
//          S_FALSE if a duplicate was found
//          E_FAIL if the query failed
//
HRESULT
CheckForDuplicateGuid(
    LPBYTE uGuid )
{
    TraceFunc( "CheckForDuplicateGuid( " );

    HRESULT hr = S_OK;
    WCHAR   szGuid[ MAX_INPUT_GUID_STRING * 2 ];  // room for escaped GUID
    WCHAR   szFilter[ARRAYSIZE(szGuid)+ARRAYSIZE(FILTER_GUID_QUERY)];
    PLDAP   LdapHandle = NULL;
    LPWSTR  ComputerAttrs[2];
    DWORD   LdapError;
    DWORD   count;
    PLDAPMessage LdapMessage;
    
    LdapError = Ldap_InitializeConnection( &LdapHandle );
    Assert( LdapError == LDAP_SUCCESS );
    if ( LdapError != LDAP_SUCCESS ) 
    {
        hr = THR( HRESULT_FROM_WIN32( LdapMapErrorToWin32( LdapError ) ) );
        goto e0;
    }

    ZeroMemory( szGuid, sizeof(szGuid) );
    ldap_escape_filter_element( (PCHAR)uGuid, 16, szGuid, sizeof(szGuid) );

    wsprintf( szFilter, FILTER_GUID_QUERY, szGuid );
    DebugMsg( "Dup Guid Filter: %s\n", szFilter );

    ComputerAttrs[0] = DISTINGUISHEDNAME;
    ComputerAttrs[1] = NULL;

    LdapError = ldap_search_ext_s( LdapHandle,
                                   NULL,
                                   LDAP_SCOPE_SUBTREE,
                                   szFilter,
                                   ComputerAttrs,
                                   FALSE,
                                   NULL,
                                   NULL,
                                   NULL,
                                   0,
                                   &LdapMessage);
    Assert( LdapError == LDAP_SUCCESS );
    if ( LdapError != LDAP_SUCCESS )
    {
        hr = THR( HRESULT_FROM_WIN32( LdapMapErrorToWin32( LdapError ) ) );
        goto e1;
    }

    count = ldap_count_entries( LdapHandle, LdapMessage );
    if ( count != 0 )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    ldap_msgfree( LdapMessage );

e1:
    ldap_unbind( LdapHandle );

e0:
    HRETURN(hr);
}


//
// AddWizardPage( )
//
// Adds a page to the wizard.
//
void 
AddWizardPage(
    LPPROPSHEETHEADER ppsh, 
    UINT id, 
    DLGPROC pfn,
    UINT idTitle,
    UINT idSubtitle,
    LPARAM lParam )
{
    PROPSHEETPAGE psp;
    TCHAR szTitle[ SMALL_BUFFER_SIZE ];
    TCHAR szSubTitle[ SMALL_BUFFER_SIZE ];

    ZeroMemory( &psp, sizeof(psp) );
    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT | PSP_USETITLE;
    psp.pszTitle    = MAKEINTRESOURCE( IDS_ADD_DOT_DOT_DOT );
    psp.hInstance   = ppsh->hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(id);
    psp.pfnDlgProc  = pfn;
    psp.lParam      = lParam;

    if ( idTitle )
    {
        DWORD dw;
        dw = LoadString( g_hInstance, idTitle, szTitle, ARRAYSIZE(szTitle) );
        Assert( dw );
        psp.pszHeaderTitle = szTitle;
        psp.dwFlags |= PSP_USEHEADERTITLE;
    }
    else
    {
        psp.pszHeaderTitle = NULL;
    }

    if ( idSubtitle )
    {
        DWORD dw;
        dw = LoadString( g_hInstance, idSubtitle , szSubTitle, ARRAYSIZE(szSubTitle) );
        Assert( dw );
        psp.pszHeaderSubTitle = szSubTitle;
        psp.dwFlags |= PSP_USEHEADERSUBTITLE;
    }
    else
    {
        psp.pszHeaderSubTitle = NULL;
    }
  
    ppsh->phpage[ ppsh->nPages ] = CreatePropertySheetPage( &psp );
    if ( ppsh->phpage[ ppsh->nPages ] )
        ppsh->nPages++;
}

// borrowed from shell\inc\shsemip.h
// unsafe macros
#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

//
// BrowseForRIServersCallback( )
//
INT CALLBACK 
BrowseForRIServersCallback(
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam,
    LPARAM lpData
    )
{
    TraceFunc( "BrowseForRIServersCallback( ... )\n" );

    if ( uMsg == BFFM_SELCHANGED )
    {
        HRESULT hr;
        LPSHARE_INFO_1 psi;
        LPWSTR pszComputerName;
        WCHAR szStatusText[ 256 ];    // random
        LPITEMIDLIST  pidl = (LPITEMIDLIST) lParam;
        IShellFolder * psf = NULL;
        DWORD dw;
        SHORT cbTmp;
        STRRET strret;

        dw = LoadString( g_hInstance, IDC_NOT_A_BINL_SERVER, szStatusText, ARRAYSIZE(szStatusText) );
        
        Assert( dw );

        if (!dw) {
            szStatusText[0] = '\0';
        }

        hr = THR( SHGetDesktopFolder( &psf ) );
        if ( FAILED(hr) )
            goto Error;

        hr = THR( psf->GetDisplayNameOf( pidl, SHGDN_NORMAL | SHGDN_FORPARSING, &strret ) );
        if ( FAILED(hr) )
            goto Error;

        switch( strret.uType )
        {
        case STRRET_WSTR:
            pszComputerName = strret.pOleStr;
            break;

        case STRRET_OFFSET:
            AssertMsg( 0, "I dunno if this is right!\n" );
            pszComputerName = (LPWSTR) ((LPBYTE) pidl) + strret.uOffset;
            break;

        case STRRET_CSTR:
            pszComputerName = (LPWSTR) &strret.cStr[0];
            break;
        }

        if ( pszComputerName[0] != L'\\' || pszComputerName[1] != L'\\' )
            goto Error;

        DebugMsg( "Checking Server: %s\n", pszComputerName );

        if ( NERR_Success == NetShareGetInfo( &pszComputerName[2],
                                              REMINST_SHARE, 
                                              1,
                                              (LPBYTE *) &psi ) )
        {
            szStatusText[0] = L'\0';
            NetApiBufferFree( psi );
        }        
        
Error:
        SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)( szStatusText[0] == '\0' ) );
        SendMessage(hwnd, BFFM_SETSTATUSTEXT, 0, (LPARAM) szStatusText );
    }

    RETURN(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\varconv.h ===
//
// Copyright 1997 - Microsoft
//

//
// VARCONV.CPP - Handlers for converting from/to VARIANTs.
//


#ifndef _VARCONV_H_
#define _VARCONV_H_

HRESULT
StringArrayToVariant( 
    VARIANT * pvData,
    LPWSTR lpszDatap[],    // array of LPWSTRs
    DWORD  dwCount );      // number of items in the array

HRESULT
PackStringToVariant(
    VARIANT * pvData,
    LPWSTR lpszData );

HRESULT
PackBytesToVariant(
    VARIANT* pvData,
    LPBYTE   lpData,
    DWORD    cbBytes );

HRESULT
PackDWORDToVariant(
    VARIANT * pvData,
    DWORD dwData );

HRESULT
PackBOOLToVariant(
    VARIANT * pvData,
    BOOL fData );

#endif // _VARCONV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\utils.h ===
//
// Copyright 1997 - Microsoft
//

//
// UTILS.H - Common non-class specific utility calls.
//

#ifndef _UTILS_H_
#define _UTILS_H_

#include "cenumsif.h"

///////////////////////////////////////
//
// globals
//
extern WCHAR g_wszLDAPPrefix[];
extern const LONG SIZEOF_g_wszLDAPPrefix;

// GUID text size
#define PRETTY_GUID_STRING_BUFFER_SIZE  sizeof(L"{AC409538-741C-11d1-BBE6-0060081692B3}")
#define MAX_INPUT_GUID_STRING       56  // abitrary; allows for spaces in pasted GUIDs

///////////////////////////////////////
//
// structs, enums
//

typedef struct {
    LPWSTR pszFilePath;
    LPWSTR pszDescription;
    LPWSTR pszDirectory;
    LPWSTR pszHelpText;
    LPWSTR pszVersion;
    LPWSTR pszLanguage;
    LPWSTR pszArchitecture;
    LPWSTR pszImageType;
    LPWSTR pszImageFile;
    FILETIME ftLastWrite;
} SIFINFO, *LPSIFINFO;


///////////////////////////////////////
//
// functions
//

HRESULT
AddPagesEx(
    ITab ** pTab,
    LPCREATEINST pfnCreateInstance,
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam,
    LPUNKNOWN );

HRESULT
CheckClipboardFormats( );

HRESULT
DNtoFQDN( 
    LPWSTR pszDN,
    LPWSTR * pszFQDN );

HRESULT
PopulateListView( 
    HWND hwndList, 
    IEnumIMSIFs * penum );


HRESULT
LDAPPrefix(
    PWSTR pwzObjDN, 
    PWSTR * ppwzObjLDAPPath);

int
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType );

void
MessageBoxFromError(
    HWND hParent,
    UINT idsCaption,
    DWORD dwErr );

void
MessageBoxFromHResult(
    HWND hParent,
    UINT idsCaption,
    HRESULT hr );

BOOL
VerifySIFText(
    LPWSTR pszText );

#ifndef ADSI_DNS_SEARCH
#include <winldap.h>
DWORD
Ldap_InitializeConnection(
    PLDAP  * LdapHandle );
#endif // ADSI_DNS_SEARCH

HRESULT
ValidateGuid(
    IN LPWSTR pszGuid,
    OUT LPBYTE uGuid OPTIONAL,
    OUT LPDWORD puGuidLength OPTIONAL );

LPWSTR
PrettyPrintGuid( 
    IN LPBYTE uGuid );

HRESULT
CheckForDuplicateGuid(
    IN LPBYTE uGuid );

void 
AddWizardPage(
    LPPROPSHEETHEADER ppsh, 
    UINT id, 
    DLGPROC pfn,
    UINT idTitle,
    UINT idSubtitle,
    LPARAM lParam );

INT CALLBACK 
BrowseForRIServersCallback(
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam,
    LPARAM lpData
    );


class CWaitCursor
{
private:
    HCURSOR _hOldCursor;

public:
    CWaitCursor( ) { _hOldCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) ); };
    ~CWaitCursor( ) { SetCursor( _hOldCursor ); };
};

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootsec\bootsec.asm ===
;==========================================================================
; BOOTSEC.ASM
;
; Bootsector for Goliath.
;
; This is taken (directly) from NT's boot sector.
;==========================================================================

seg_a		segment	byte public use16
		assume	cs:seg_a, ds:seg_a

ideal
		org	0

P386
Proc start far

	jmp	short entry
	nop

	;------------------------------------------------------------
	; DOS name
	;------------------------------------------------------------
	db	'(PC**SD)'

	;------------------------------------------------------------
	; BPB (BIOS parameter block)
	;------------------------------------------------------------
SectorBytes	dw	200h		; bytes per sector	(00)
ClusterSectors	db	1		; sectors per cluster	(02)
ReservedSectors	dw	1		; reserved sectors	(03)
NumFATS		db	2		; number of FATS	(05)
MaxRootEntries	dw	00E0h		; max root entries	(06)
NumSectors	dw	0B40h		; number of sectors	(08)
MediaType	db	0F0h		; media type		(0A)
FATSectors	dw	9		; FAT sectors		(0B)
TrackSectors	dw	12h		; track sectors		(0D)
Heads		dw	2		; heads			(0F)
HiddenSectorsLo	dw	0		; hidden sectors	(11)
HiddenSectorsHi	dw	0		; hidden sectors	(13)
TotalSectors	dd	0		; number of sectors	(15)
TempDrive	db	0		; reserved		(19)
TempHead	db	0		; reserved		(1A)
Signature	db	29h		; 			(1B)

SerialNumber	dd	0		;			(1C)
		db	'NoName     '	;			(20)
		db	'FAT12   '	;			(2B)

entry:

	xor	ax, ax			; ax = 0
	mov	ss, ax			; stack segment = 0
	mov	sp, 7C00h		; set stack pointer
	push	07C0h			; push 7C0h
	pop	ds			; ds = 07C0h

					; calc the size of the FAT
	mov	al, [NumFATS]		; get number of FATS
	mul	[FATSectors]		; times sectors per track
	add	ax, [ReservedSectors]	; add reserved sectors
					; we now have number of sectors in FAT
	push	ax			; save value
	xchg	cx, ax			; move to cx

	mov	ax, 32			; size of directory entry
	mul	[MaxRootEntries]	; calc total size of root directory

	mov	bx, [SectorBytes]	; get bytes per sector
	add	ax, bx			; add boot sector size
	dec	ax			; less one byte
	div	bx			; divide by sector size
	add	cx, ax			; add to sectors in FAT
					; ax and cx is offset of data on disk
	mov	[208h], cx		; save value

	; read the directory into 1000:0
	push	1000h			; push 1000h
	pop	es			; es = 1000h

	xor	bx, bx			; bx = 0
	pop	[word ptr 213h]		; put number of FAT sectors in 213h
	mov	[215h], bx		; 215h = 0
	call	ReadSectors
	jc	printError2		; exit if there was an error

	xor	bx, bx			; bx = 0					; Zero register
	mov	cx, [MaxRootEntries]	; get max root directory entries

scanDirLoop:							
	mov	di, bx			; directory entry offet into di
	push	cx			; save cx
	mov	cx, 11			; file name size
	mov	si, offset NTLDR
	repe	cmpsb			; look for file name
	pop	cx			; restore cx
	jz	foundEntry		; jump if found
	add	bx, 20h			; next directory offset
	loop	scanDirLoop		; check next entry

foundEntry:
	jcxz	printError1		; exit if entry not found

	mov	dx, [es:bx+1Ah]		; get file starting cluster
	push	dx			; save value
	mov	ax, 1			; sectors to read
	push	2000h			; push 2000h
	pop	es  			; es = 2000h (load segment)
	xor	bx, bx			; bx = 0
	call	ReadCluster
	jc	printError2		; exit if error

	pop	bx			; bx = starting cluster
	mov	si, 0Bh
	mov	di, 20Bh
	push	ds
	pop	[(word ptr di)+2]	; di+2 = ds
	mov	[word ptr di], offset ReadCluster
	push	ds
	pop	[word ptr di+6]		; di+6 = ds
	mov	[word ptr di+4], offset ReadSectors
	mov	dl, [TempDrive]		; get boot drive
	jmp	far 2000h:0		; jump to loader

;--------------------------------------------------------------------
printError1:
	mov	si, offset Error1	; "Couldn't find Goliath"
	jmp	printError

printError2:
	mov	si, offset Error2	; "I/O error reading disk"

printError:
	call	Print			; print message

	mov	si, offset PleaseInsert	; "Please insert another disk"
	call	Print
	sti				; enable interrupts

	jmp	$			; halt

endp

;==========================================================================
; Print
;==========================================================================
Proc Print

	lodsb				; get byte from ds:si
	or	al,al			; did we get a NULL?
	jz	printExit		; got NULL - exit
	mov	ah, 0Eh
	mov	bx, 7
	int	10h			; print character

	jmp	print			; do next character
	
printExit:
	ret

endp

;--------------------------------------------------------------------
; ReadCluster
;
;--------------------------------------------------------------------
Proc ReadCluster far

	push	ax
	dec	dx			; decrease cluster number
	dec	dx			; decrease cluster number
	mov	al, [ClusterSectors]	; get sectors per cluster
	xor	ah, ah			; ah = 0
	mul	dx			; multiply by cluster number
	add	ax, [208h]
	adc	dx, 0
	mov	[213h], ax
	mov	[215h], dx
	pop	ax			; restore ax

Proc ReadSectors far
	mov	[207h], al		; save number of sectors to read

readLoop:
	mov	ax, [213h]
	mov	dx, [215h]
	add	ax, [HiddenSectorsLo]	; add number of hidden sectors
	adc	dx, [HiddenSectorsHi]
	div	[TrackSectors]		; divide by sectors per track
	inc	dl
	mov	[206h], dl

	xor	dx, dx			; dx = 0
	div	[Heads]			; divide by number of heads
	mov	[TempHead], dl		; save head number
	mov	[204h], ax

	mov	ax, [TrackSectors]	; get number of sectors per track
	sub	al, [206h]
	inc	ax
	cmp	al, [207h]
	jbe	loc_11
	mov	al, [207h]		; get number of sectors to read
	xor	ah, ah			; ah = 0

loc_11:
	push	ax
	mov	ah, 2			; read function
	mov	cx, [204h]
	shl	ch, 6
	or	ch, [206h]
	xchg	ch, cl			; cl = sector, ch = track
	mov	dx, [word ptr TempDrive]; dl = drive, dh = head
	int	13h			; read disk
	jnc	readOK			; jump if no error

	add	sp, 2			; clean stack
	stc				; set carry flag (error)
	ret				; exit

readOK:
	pop	ax
	sub	[207h], al
	jbe	readDone		; file read done
	add	[213h], ax
	adc	[word ptr 215h], 0
	mul	[SectorBytes]
	add	bx, ax
	jmp	readLoop

readDone:
	mov	[207h], al
	clc						; Clear carry flag
	ret						; Return far

endp
endp

Error1		db	"BOOT: Couldn't find Goliath", 13, 10, 0
Error2		db	'BOOT: I/O error reading disk', 13, 10, 0
PleaseInsert	db	'Please insert another disk', 0
NTLDR		db	'GOLIATH    '

		org 510
		db	55h,0AAh

ends
end Start
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\varconv.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// VARCONV.CPP - Handlers for converting from/to VARIANTs.
//

#include "pch.h"
#include "varconv.h"

DEFINE_MODULE("IMADMUI")


//
// StringArrayToVariant( )
//
// Creats an array of Vars that are BSTRs.
HRESULT
StringArrayToVariant(
    VARIANT * pvData,
    LPWSTR lpszData[],    // array of LPWSTRs
    DWORD  dwCount )       // number of items in the array
{
    TraceFunc( "StringArrayToVariant( ... )\n" );

    HRESULT hr;
    DWORD   dw;
    VARIANT * pvar;
    SAFEARRAY * sa;
    SAFEARRAYBOUND rgsabound[1];

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = dwCount;

    sa = SafeArrayCreate( VT_VARIANT, 1, rgsabound );
    if ( !sa )
        RRETURN(E_OUTOFMEMORY);

    hr = THR( SafeArrayAccessData( sa, (void**) &pvar ) );
    if (hr)
        goto Error;

    for ( dw = 0; dw < dwCount; dw++ )
    {
        hr = THR( PackStringToVariant( &pvar[dw], lpszData[dw] ) );
        if (hr)
        {
            SafeArrayUnaccessData( sa );
            goto Error;
        }
    }

    SafeArrayUnaccessData( sa );

    pvData->vt = VT_ARRAY | VT_VARIANT;
    pvData->parray = sa;

Error:
    HRETURN(hr);
}


//
// PackStringToVariant( )
//
HRESULT
PackStringToVariant(
    VARIANT * pvData,
    LPWSTR lpszData )
{
    TraceFunc( "PackStringToVariant( )\n" );

    BSTR bstrData = NULL;

    if ( !lpszData || !pvData )
        RRETURN(E_INVALIDARG);

    bstrData = SysAllocString(lpszData);

    if ( !bstrData )
        RRETURN(E_OUTOFMEMORY);

    pvData->vt = VT_BSTR;
    pvData->bstrVal = bstrData;

    HRETURN(S_OK);
}

//
// PackBytesToVariant( )
//
HRESULT
PackBytesToVariant(
    VARIANT* pvData,
    LPBYTE   lpData,
    DWORD    cbBytes )
{
    TraceFunc( "PackBytesToVariant( )\n" );

    HRESULT    hr = S_OK;
    LPBYTE     ptr;
    SAFEARRAY* sa = NULL;
    SAFEARRAYBOUND rgsabound[1];

    if ( !lpData )
        RRETURN(E_INVALIDARG);

    if ( !pvData )
        RRETURN(E_INVALIDARG);

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cbBytes;

    sa = SafeArrayCreate( VT_UI1, 1, rgsabound );
    if ( !sa )
        RRETURN(E_OUTOFMEMORY);

    hr = THR( SafeArrayAccessData( sa, (LPVOID*)&ptr ) );
    if (hr)
        goto Error;

    CopyMemory( ptr, lpData, cbBytes );
    SafeArrayUnaccessData( sa );

    pvData->vt = VT_UI1 | VT_ARRAY;
    pvData->parray = sa;

Cleanup:
    HRETURN(hr);

Error:
    if ( sa )
        SafeArrayDestroy( sa );

    goto Cleanup;
}


//
// PackDWORDToVariant( )
//
HRESULT
PackDWORDToVariant(
    VARIANT * pvData,
    DWORD dwData )
{
    TraceFunc( "PackDWORDToVariant( )\n" );

    if ( !pvData )
        RRETURN(E_INVALIDARG);

    pvData->vt = VT_I4;
    pvData->lVal = dwData;

    HRETURN(S_OK);
}


//
// PackBOOLToVariant( )
//
HRESULT
PackBOOLToVariant(
    VARIANT * pvData,
    BOOL fData )
{
    TraceFunc( "PackBOOLToVariant( )\n" );

    if ( !pvData )
        RETURN(E_INVALIDARG);

    pvData->vt = VT_BOOL;
    V_BOOL( pvData ) = (VARIANT_BOOL)fData;

    RETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\endmark.asm ===
IDEAL
_IDEAL_ = 1

	include "include\drvseg.inc"

START_SPARSE

public RxBuffer
RxBuffer	db 1525 dup (?)

public RxBuffer2
RxBuffer2	db 1525 dup (?)

;align 16
public EndMark
label EndMark
END_SPARSE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\bootware.asm ===
;----------------------------------------------------------------------------
; BOOTWARE.ASM
;
; Main BootWare module for Goliath.
;
; $Histroy: $
;
;----------------------------------------------------------------------------
IDEAL
_IDEAL_ = 1

include "include\drvseg.inc"
include "include\loader.inc"
;include "include\bwstruct.inc"

public	PCIDevice
public	PCIVendor
public	PCIBusDevFunc
public	CSN
public	Verbose

extrn	EndMark:byte
extrn	PrintTitle:near
extrn	Print:near
extrn	AIInitialize:near
extrn	IPStart:near
extrn	SetupPreboot:near

extrn	AITbl:byte
extrn	RxBuffer2:byte
extrn	LangSeg:word

START_CODE
P386

Proc Entry

	jmp	short Start

	dw	EndMark			; module size

public LanOption
LanOption db	80 dup (0)

endp

;--------------------------------------------------------------------
; Start
;
; Parameters:
;	ds:si - pointer to LoaderInfo structure
;--------------------------------------------------------------------
Proc Start

	push	ds
	pop	es			; es = ds
	push	cs
	pop	ds			; ds = cs

	mov	ax, [(LoaderInfo es:si).LangSeg]
	mov	[LangSeg], ax		; save languge segment
	mov	ax, [(LoaderInfo es:si).DeviceID]
	mov	[PCIDevice], ax
	mov	ax, [(LoaderInfo es:si).VendorID]
	mov	[PCIVendor], ax
	mov	ax, [(LoaderInfo es:si).PCIBusDevFunc]
	mov	[PCIBusDevFunc], ax	; save Bus/Device/Function numbers
	mov	ax, [(LoaderInfo es:si).CSN]
	mov	[CSN], ax		; save PnP Card Select Number

	push	es			; save es

	push	0
	pop	es			; es = 0
	mov	ax, cs			; get current segment
	xor	dx, dx
	mov	cx, 64
	div	cx			; convert to size in K
	mov	[es:413h], ax		; set new top of memory

	pop	es			; restore es

	mov	bl, 7
	call	PrintTitle

	mov	bx, [(LoaderInfo es:si).UNDISeg]
	mov	cx, [(LoaderInfo es:si).UNDICode]
	mov	dx, [(LoaderInfo es:si).UNDIData]
	mov	si, offset RxBuffer2	; si = receive buffer
					; bx = UNDI segment
					; cx = UNDI code segment size
					; dx = UNDI data segment size
	push	bx			; save UNDI segment
	call	AIInitialize

	call	IPStart

	pop	dx			; dx = UNDI segment
	mov	bx, offset AITbl	; pass pointer to AI API table
	call	SetupPreboot		; setup Preboot environment

	mov	ax, 5650h		; PXE request code
	int	1Ah			; do int1A to set starting values

	push	cs			; push current segment
	push	offset return		; push return address

	push	0			; push new segment
	push	7C00h			; push new offset
	retf				; jump to bootstrap

return:
	push	cs
	pop	ds

	mov	bx, offset aborted
	call	Print

	jmp	$			; hang system

endp

aborted	db	"Exiting Remote Installation Boot Floppy", 13, 10
	db	"Please remove the floppy disk and reboot the workstation.", 0

;--------------------------------------------------------------------
public BWTable
label BWTable
		db	(Sum-$)+1	;0 size of table

		db	4		;1 Version of the table format

		dw	0100h		;2 ROM version

		dw	-1		;4 BootWare type code

BWTSettings	dd   0001010000010011b	;6 Current settings
					;     0 - initialized
					;   1-2 - protocol
					;   3-4 - sub protocol
					;     5 - default boot
					;     6 - config screen disabled
					;     7 - floppy boot disabled
					;     8 - hard disk boot disabled
					;     9 - config message disabled
					; 10-11 - time-out
					;    12 - wait for key on reboot
					; 13-15 - protocol specific

BWTCapabilities	dd	-1		;6 ROM capabilities
					;  0 - PXE
					;  1 - TCP/IP
					;  2 - NetWare
					;  3 - RPL

BWTDefaults	dd	1413h		;10 Factory defaults
					; bits same as settings

BWTEEMask	dd	-1		;14 EEROM mask

Sum		db	0		;18 checksum of table


BWTSize		db	0

PCIDevice	dw	0
PCIVendor	dw	0
PCIBusDevFunc	dw	0
CSN		dw	0

Verbose		db	1

END_CODE
end Entry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\ai\ai_arp.asm ===
Struc ArpPkt
	Dest		dw	-1, -1, -1	; destination address
	Source		dw	0, 0, 0		; source address
	Type		dw	0608h		; type field
	HwType		dw	0100h		; hardware type
	Prot		dw	8		; protocol
	HLen		db	6		; hardware length
	PLen		db	4		; protocol length
	Code		dw	0100h		; request code
	SendHA		dw	0, 0, 0		; sender hardware address
	SendIP		dd	0		; sender IP
	TargetHA	dw	0, 0, 0		; target hardware address
	TargetIP	dd	0		; target IP
ends

public	AIAppendCache

;--------------------------------------------------------------------
; AIAppendCache
;
; Sets an IP number and hardware address in the cache.
;
; Parameters:
;	ax:dx - IP number
;	si - pointer to hardware address
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc AIAppendCache

	; set the IP number
	mov	[word ptr CurrentIP], ax
	mov	[word ptr CurrentIP+2], dx

	; set the hardware address
	mov	di, offset CurrentAddr
	movsw
	movsw
	movsw

	ret

endp

;--------------------------------------------------------------------
; ResolveIP
;
; Converts an IP address into a hardware address using ARP.
;
; Parameters:
;	eax - IP address
;
; Returns:
;	si - pointer to hardware address
;		(0 if unable to find address)
;--------------------------------------------------------------------
Proc ResolveIP

	; first check for a broadcast IP address
	cmp	eax, -1
	jne	notBroadcast

	mov	si, offset Broadcast	; return broadcast address pointer
	ret

notBroadcast:
	; check if the IP address is in the cache
	cmp	[CurrentIP], eax
	jne	notCached

	mov	si, offset CurrentAddr	; return cache pointer
	ret

notCached:
	;----------------------------------------
	; The address is not a broadcast or in the
	; current cache so we must do an ARP to get
	; the address. Hopefully someone on the
	; network will know the address.
	;----------------------------------------
	push	ds
	pop	es			; es = ds

	call	CreateArpRequest	; create the ARP packet
	mov	[Retrys], 5		; set retry count

	mov	[DoingARP], 1		; set "Doing ARP" flag

doArpLoop:
	mov	cx, size ArpPkt
	mov	di, offset TxArp
	call	AITransmitRaw		; transmit the ARP

	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	mov	[StartTime], dx		; save starting time

noTimeOut:
	cmp	[TempIP], 0		; got a reply?
	je	doneArp			; yes

	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	sub	dx, [StartTime]		; calc elapsed time
	cmp	dx, 9			; is time up (half second)?
	jb	noTimeOut		; loop until times up

	dec	[Retrys]		; increase retry counter
	jne	doArpLoop		; send ARP again

	xor	si, si			; return "no address found"
	jmp	exitResolve

doneArp:
	mov	si, offset CurrentAddr	; return cache pointer

exitResolve:
	mov	[DoingARP], 0		; clear "Doing ARP" flag

	ret

endp

;--------------------------------------------------------------------
; CreateArpRequest
;
; Creates an ARP (address resolution protocol) request.
;
; Parameters:
;	eax - target IP address
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc CreateArpRequest

	push	ax

	;----------------------------------------
	; Put target IP address field.
	;----------------------------------------
	mov	[TxArp.TargetIP], eax
	mov	[TempIP], eax

	;----------------------------------------
	; Put our hardware addresses into source address.
	;----------------------------------------
	lea	di, [TxArp.Source]
	mov	si, offset NetAddress
	movsw				; put our hardware address into
	movsw				; send hardware address field
	movsw

	mov	[TxArp.Code], 0100h	; set code as request

	;----------------------------------------
	; Put our hardware addresses into ARP request packet.
	;----------------------------------------
	lea	di, [TxArp.SendHa]
	mov	si, offset NetAddress
	movsw				; put our hardware address into
	movsw				; send hardware address field
	movsw

	;----------------------------------------
	; Put local IP address into send field.
	;----------------------------------------
	mov	si, offset LocalIP
	movsw
	movsw

	;----------------------------------------
	; Put null hardware address into receive hardware address field
	;----------------------------------------
	xor	ax, ax
	stosw
	stosw
	stosw

	pop	ax
	ret

endp CreateArpRequest

;--------------------------------------------------------------------
; ArpCallback
;
; Checks for a ARP (address resolution protocol) reply.
; Routine is called from Receive interrupt when an ARP has been received.
;
; Parameters:
;	es:di pointer to packet
;
; Returns:
;	carry set if packet processed
;--------------------------------------------------------------------
Proc ArpCallback

	cmp	[(ArpPkt es:di).Code], 100h; check for request code
	jne	notRequest
	jmp	ProcessArpRequest

notRequest:
	cmp	[DoingARP], 0		; is "Doing ARP" flag set?
	je	notReply		; no

	cmp	[(ArpPkt es:di).Code], 200h; check for reply code
	jne	notReply
	jmp	ProcessArpReply

notReply:
	clc				; clear carry - didn't process packet
	ret

endp

;--------------------------------------------------------------------
; ProcessArpReply
;
; Parameters:
;	es:di pointer to packet
;
; Returns:
;	carry set if packet processed
;--------------------------------------------------------------------
Proc ProcessArpReply

	;------------------------------------------------------------
	; Confirm the IP address we are looking for is
	; in the sender field.
	;------------------------------------------------------------
	mov	eax, [(ArpPkt es:di).SendIP]
	cmp	[TempIP], eax
	je	ourARP			; it is ours

	clc				; clear carry - packet not processed
	ret

ourARP:
	push	si			; save si
	push	di			; save di

	;------------------------------------------------------------
	; Copy the hardware address into the cache.
	;------------------------------------------------------------
	lea	bx, [(ArpPkt di).SendHa]

	mov	ax, [es:bx]
	mov	[CurrentAddr], ax
	mov	ax, [es:bx+2]
	mov	[CurrentAddr+2], ax
	mov	ax, [es:bx+4]
	mov	[CurrentAddr+4], ax

	;----------------------------------------
	; Copy the IP address into the cache.
	;----------------------------------------
	mov	eax, [TempIP]
	mov	[CurrentIP], eax

	mov	[TempIP], 0		; clear the temp address

	pop	di			; restore di
	pop	si			; restore si

	stc				; set carry (processed packet)
	ret

endp

;--------------------------------------------------------------------
; ProcessArpRequest
;
; Handles ARP (address resolution protocol) requests.  Routine is called
; from receive interrupt when an ARP packet has been received.
;
; Parameters:
;	es:di - pointer to packet
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc ProcessArpRequest

	push	si			; save si
	push	di			; save di

	mov	bx, di			; move request packet pointer to bx

	;------------------------------------------------------------
	; Check if the target IP address is us.
	;------------------------------------------------------------
	mov	eax, [(ArpPkt es:di).TargetIP]
	cmp	[dword ptr LocalIP], eax
	jne	notOurRequest		; the ARP was not for us

	;------------------------------------------------------------
	mov	si, di			; move request packet address to si
	push	es			; save request packet segment

	push	ds
	pop	es			; es = our segment

	;------------------------------------------------------------
	; The ARP request is for us, so build a reply and send it.
	;------------------------------------------------------------
	lea	di, [TxArp.Code]	; setup pointer for reply packet
	mov	ax, 0200h
	stosw				; set code for reply

	;------------------------------------------------------------
	; The send hardware address is us.
	;------------------------------------------------------------
	mov	si, offset NetAddress
	movsw
	movsw
	movsw

	;----------------------------------------
	; The send IP address is also us.
	;----------------------------------------
	mov	si, offset LocalIP
	movsw
	movsw

	;----------------------------------------
	; Copy the requesters hardware address into the target field.
	;----------------------------------------
	mov	ax, ds			; save our ds in ax
	pop	ds			; set ds to request buffer
	push	ds			; save it again
	lea	si, [(ARPPkt bx).SendHa]
	movsw
	movsw
	movsw

	;----------------------------------------
	; Copy the requesters IP address into the target field.
	;----------------------------------------
	movsw
	movsw

	;----------------------------------------
	; Put our hardware addresses into source address.
	;----------------------------------------
	mov	ds, ax			; restore our ds from ax
	lea	di, [TxArp.Source]
	mov	si, offset NetAddress
	movsw				; put our hardware address into
	movsw				; send hardware address field
	movsw

	mov	cx, size ArpPkt
	mov	di, offset TxArp
	call	AITransmitRaw		; transmit the ARP reply

	pop	es			; restore request buffer segment

	stc				; set carry (processed packet)

notOurRequest:
	pop	di			; restore di
	pop	si			; restore si

	ret

endp

;--------------------------------------------------------------------

Broadcast	dw	-1, -1, -1

TempIP		dd	0
CurrentIP	dd	0
CurrentAddr	dw	0, 0, 0

DoingARP	db	0

TxArp		ArpPkt	{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\common\print.asm ===
;====================================================================
; PRINT.ASM
;
; Print routines for Goliath
;
; $History: PRINT.ASM $
; 
; *****************  Version 2  *****************
; User: Paul Cowan   Date: 17/08/98   Time: 9:26a
; Updated in $/Client Boot/Goliath/BootWare/Common
; Removed _ErrorInit reference
; 
;====================================================================

public DontPrint
DontPrint	db 0

public	LangSeg
LangSeg		dw 0

extrn	_ErrorInit:byte			; AI
extrn	tx_NoServer			; TCP/IP
extrn	tx_NoBINL			; TCP/IP
extrn	tx_toomanytries			; TCP/IP

TABLESIZE = 7

Tbl	dw	ErrorMsg		; 2
	dw	_NodeString		; 4
	dw	tx_NoServer		; 5
	dw	tx_NoBINL		; 6
	dw	tx_toomanytries		; 7
	dw	KeyWait			; 8

;--------------------------------------------------------------------
; Print
;
; Parameters:
;	ds:bx - pointer to string
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc Print

	cmp	[DontPrint], 0		; is printing enabled
	je	doPrint			; yes
	ret

doPrint:
	pusha				; save all registers
	push	es			; save es
	mov	si, bx			; move string address to si

	cmp	[LangSeg], 0		; did we load a language?
	je	notLang			; no

	xor	bx, bx
	mov	cx, TABLESIZE

tblLoop:
	cmp	si, [Tbl+bx]		; is string address in table?
	je	foundString		; yes

	add	bx, 2
	loop	tblLoop
	jmp	notLang			; address not found in table

foundString:
	mov	ax, [LangSeg]
	mov	es, ax			; set es to language segment

	mov	ax, [es:68+bx]		; get pointer from language table
	cmp	ax, 0			; is an address given?
	je	notLang			; no

	mov	si, ax			; use new address
	jmp	printLoop

notLang:
	push	ds
	pop	es			; set es to our segment

printLoop:
	mov	al, [es:si]
	inc	si
	or	al, al			; found NULL?
	jz	done			; found end of message
	mov	ah, 0Eh
	mov	bx, 7
	int	10h			; print character
	jmp	printLoop		; do next character

done:
	pop	es			; restore ds
	popa				; restore all registers
	ret

endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\common\common.asm ===
;====================================================================
; COMMON.ASM
;
; "Common" routines for Goliath
;
; $History: COMMON.ASM $
; 
; *****************  Version 7  *****************
; User: Paul Cowan   Date: 11/08/98   Time: 11:31a
; Updated in $/Client Boot/Goliath/BootWare/Common
; Changed banner string.
; 
; *****************  Version 6  *****************
; User: Paul Cowan   Date: 10/08/98   Time: 4:46p
; Updated in $/Client Boot/Goliath/BootWare/Common
; Changed copyright to include 3Com.
; 
; *****************  Version 5  *****************
; User: Paul Cowan   Date: 27/07/98   Time: 4:27p
; Updated in $/Client Boot/Goliath/BootWare/Common
; Company name change.
; 
; *****************  Version 4  *****************
; User: Paul Cowan   Date: 27/07/98   Time: 10:47a
; Updated in $/Client Boot/Goliath/BootWare/Common
; Added include for config.inc.
;
;====================================================================
IDEAL
_IDEAL_ = 1

include "..\include\drvseg.inc"
include "..\include\bwstruct.inc"
include "..\include\config.inc"

public	ClearScreen
public	Print
public	PrintChar
public	PrintTitle
public	PrintDecimal
public	PrintCRLF
public	PrintSettings
public	StoDec
public	Reboot
public	ErrorMsg

extrn	LanOption:byte			; NAD
extrn	BWTable:BWT

extrn	NIC_RAM:word
extrn	RomBase:word
extrn	NIC_IRQ:byte
extrn	NIC_IO:word
extrn	NetAddress:word

START_CODE
P386

BootWareString	db	"Windows NT Remote Installation Boot Floppy", 13, 10
		db 	"(C) Copyright 1998 Lanworks Technologies Co. a subsidiary of 3Com Corporation", 13, 10
		db	'All rights reserved.'
CRLF		db	13, 10, 0

_NodeString	db	'Node: ', 0
_NodeID		db	'XXXXXXXXXXXX', 0

ErrorMsg	db	'Error: ', 0

include	"print.asm"

;--------------------------------------------------------------------
; PrintTitle
;
; Prints "BootWare Centralized Boot ROM for ..." and copyright
; message at the top of the screen.
;
; Parameters:
;	bl - text attribute
;
; Returns:
;	dx - next screen location for printing
;--------------------------------------------------------------------
Proc PrintTitle

	pusha

	mov	bh, bl			; attribute
	xor	cx, cx			; start row/column
	mov	dx, 194Fh		; end row/column
	mov	ax, 0600h		; scroll up 21 lines
	int	10h			; clear the screen with attribute

	xor	dx, dx
	xor	bh, bh
	mov	ah, 2
	int	10h			; set cursor to top left

	mov	al, bl
	mov	bx, offset BootWareString
	call	Print			; print "Copyright...."

	mov	bx, offset LanOption
	call	Print

	call	PrintCRLF
	call	PrintCRLF

	inc	dh			; next row
	inc	dh			; next row
	xor	dl, dl

	popa
	ret

endp

;--------------------------------------------------------------------
; PrintSettings
;
; Prints the current ROM configuration settings, RAM base, ROM base,
; I/O, IRQ and ethernet standard, if NetWare, using values in the
; NID/NAD table.
;
; Parameters:
;	ax - NAD config text
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc PrintSettings

	pusha				; save everything

	; Convert the node address from binary to ascii and print it
	mov	di, offset _NodeID
	mov	ax, [NetAddress]
	call	StoHex
	xchg	al, ah
	call	StoHex

	mov	ax, [NetAddress+2]
	call	StoHex
	xchg	al, ah
	call	StoHex

	mov	ax, [NetAddress+4]
	call	StoHex
	xchg	al, ah
	call	StoHex

	mov	bx, offset _NodeString
	call	Print

	mov	bx, offset _NodeID
	call	Print

	mov	bx, offset CRLF
	call	Print

	popa				; restore everything
	ret

endp

;----------------------------------------------------------------------
; ClearScreen
;
; Clears the screen.
;
; Parameters:
;	none
;
; Returns:
;	nothng
;----------------------------------------------------------------------
Proc ClearScreen

	mov	ax, 3
	int	010h			; set 80x25 text mode
	mov	ax, 0500h
	int	010h			; page 0

	xor	dx, dx
	xor	bh, bh
	mov	ah, 2
	int	10h			; set cursor to top left

	ret

endp ClearScreen

;----------------------------------------------------------------------
; PrintChar
;
; Prints a single character on the screen.
;
; Parameters:
;	AL - character
;
; Returns:
;	nothing
;----------------------------------------------------------------------
Proc PrintChar

	push	bx			; save bx
	mov	ah, 0Eh
	mov	bx, 0007h		; page 0, normal
	int	10h			; Write TTY

	pop	bx			; restore bx

	ret

endp

;----------------------------------------------------------------------
; PrintDecimal
;
; Prints a decimal value.
;
; Parameters:
;	AX - value to print
;
; Returns:
;	nothing
;----------------------------------------------------------------------
Proc PrintDecimal

	push	bx
	push	cx		; save cx
	push	dx		; save dx

	xor	cx, cx		; clear counter
	mov	bx, 10

__loop1:
	xor	dx, dx
	div	bx		; divide by 10
	add	dl, 30h 	; convert to ASCII character
	push	dx		; save on stack
	inc	cx		; increase counter
	or	ax, ax		; still value remaining?
	jnz	__loop1		; do more

__loop2:
	pop	ax
	mov	ah, 0Eh
	mov	bx, 7
	int	10h
	loop	__loop2

	pop	dx		; restore dx
	pop	cx		; restore cx
	pop	bx

	ret

endp

;----------------------------------------------------------------------
; PrintCRLF
;
;----------------------------------------------------------------------
Proc PrintCRLF

	mov	bx, offset CRLF
	jmp	Print

endp

;----------------------------------------------------------------------
; StoHex - stuff binary AL as 2 hex digits at ES:DI
;
; Parameters:
;	AX - binary digit to print as hex
;	ES:DI ptr to string buffer, CLD flag set
;
; Returns:
;	nothing (ax, di modified)
;
;----------------------------------------------------------------------
Proc StoHex

	push	ax			; save for lower nibble
	shr	al, 4
	call	h_digit
	pop	ax			; now do lower nibble

h_digit:
	and	al, 0Fh
	add	al, 90h
	daa
	adc	al, 40h
	daa
	stosb				; stuff hex digit in buffer
	ret

endp

;----------------------------------------------------------------------
; StoDec - stuff AX as CL decimal digits at ES:DI
;
; Parameters:
;	AX = number to print as decimal
;	ES:DI ptr to leftmost position of field
;	CL has width of field, will zero-fill
;
; Returns:
;	nothing (ax, di modified)
;----------------------------------------------------------------------
Proc StoDec

	push	cx		; save cx
	push	dx		; save dx

	push	ax		; save ax
	mov	al, '0'
	mov	ch, 0
	rep	stosb		; fill with zeroes

	mov	cl, 0Ah 	; divide by 10
	pop	ax		; restore value
	push	di		; save ending DI value

stoDecNext:
	xor	dx, dx
	div	cx		; ax, dx rem=dx:ax/reg
	add	dl, 30h 	; '0'
	dec	di
	mov	[es:di], dl
	or	ax, ax
	jnz	stoDecNext

	pop	di		; restore di
	pop	dx		; restore dx
	pop	cx		; restore cx
	ret

endp

;--------------------------------------------------------------------
; Reboot
;
; Delays 5 seconds then reboots the PC.
;
;--------------------------------------------------------------------
Proc Reboot

	test	[BWTable.Settings], CFG_WAITKEY	; should we wait for a key?
	jz	noKey			; no key wait

	mov	bx, offset CRLF
	call	Print
	mov	bx, offset KeyWait
	call	Print			; print "Press a key..."

getKeyLoop:
	mov	ax, 0100h		; check status
	int	16h
	jb	getKeyLoop		; keep checking keyboard

	xor	ax, ax
	int	16h			; read key
	jmp	doReboot

noKey:
	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	mov	bx, dx			; save starting time
	add	bx, 18*5		; wait 5 seconds

rebootLoop:
	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	cmp	bx, dx			; is time up?
	jnc	rebootLoop		; loop until times up

doReboot:
	cli				; disable interrupts
	db	0EAh, 0, 0, -1, -1	; reboot system

endp Reboot

KeyWait db	"Press a key to reboot system.", 0

END_CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\ai\ai_tftp.asm ===
;--------------------------------------------------------------------
; AIOpenTFTP
;
; Opens and transfers a file via TFTP.
;
; Parameters:
;	es:di - pointer to OpenTFTP structure
;
; Returns:
;	ax - status
;--------------------------------------------------------------------
Proc AIOpenTFTP

	cmp	[(OpenTFTPStruct es:di).Size], size OpenTFTPStruct
	je	@@sizeOK
	mov	ax, -1
	ret

@@sizeOK:
	mov	[word ptr InfoPtr], di
	mov	[word ptr InfoPtr+2], es

	mov	[PacketNum], 1		; set starting packet number
	mov	[WaitTime], 18		; set default timeout to 1 second
	mov	[NoCallbacks], 1	; disable any user callbacks
	mov	[Started], 0
	mov	[PacketSize], 512	; default to normal packet size

	mov	ax, [(OpenTFTPStruct es:di).Flags]
	mov	[Flags], ax		; copy flags into local

	mov	eax, [(OpenTFTPStruct es:di).Callback]
	mov	[CallBackTFTP], eax

	call	BuildTFTP
	
tftpRxLoop1:
	cmp	[Started], 0		; are we waiting for the first packet?
	jne	not0			; no

	push	es			; save es
	push	0
	pop	es			; es = 0
	mov	ax, [es:046ch]		; get clock tick count
	or	ax, 4000h
	mov	[OurPort], ax		; save as "random" number
	mov	[UDP2.SourcePort], ax
	pop	es			; restore es

not0:
	mov	[BufferSize], 0		; clear size value
	mov	di, offset UDP2		; get pointer to UDP info
	call	AITransmitUDP		; send the UDP packet

	cmp	ax, 0			; was there an error?
	je	@@noError		; no

	jmp	tftpExit		; error - exit

@@noError:
	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	mov	[StartTime], dx		; save starting time

tftpRxLoop2:
	call	CheckRxBuffer		; try and get a packet
	or	ax, ax			; did we get anything?
	jne	gotPacket		; we got a packet

	call	CheckTimeout
	jc	tftpRxLoop2		; jump if no timeout

	call	TimeoutCallback		; do client timeout callback
	jne	tftpError		; client wants to stop

	jmp	tftpRxLoop1		; resend the last packet

gotPacket:
	call	ValidatePacket		; validate the packet is TFTP for us
	jc	tftpRxLoop2		; not a good packet

	call	PacketCallback		; do the client callback
	or	ax, ax			; was there an error?
	jne	tftpError		; yes

	or	cx, cx			; was this the last packet?
	jne	tftpRxLoop1		; not last packet

	mov	di, offset UDP2
	call	AITransmitUDP		; send last ACK packet

	mov	ax, 0
	jmp	tftpExit

tftpError:
	mov	ax, -1

tftpExit:
	mov	[NoCallbacks], 0	; enable user callbacks
	ret

endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
Proc CheckTimeout

	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	sub	dx, [StartTime]		; calc elapsed time
	cmp	dx, [WaitTime]		; is time up?
	jb	noTimeOut2		; loop until times up

isTimeOut:
	clc				; clear carry for time out
	ret

noTimeOut2:
	stc				; set carry for no time-out
	ret

endp

;--------------------------------------------------------------------
; BuildTFTP
;
; Builds IP, UDP and data packets needed to do a TFTP.
;
; Parameters:
;	es:di - pointer to OpenTFTP structure
;
; Returns:
;	nothing
;
;--------------------------------------------------------------------
Proc BuildTFTP

	push	es			; save structure segment
	push	di			; save structre pointer

	push	es
	push	0
	pop	es			; es = 0
	mov	ax, [es:046ch]		; get clock tick count
	or	ax, 4000h
	mov	[OurPort], ax		; save as "random" number
	pop	es

	mov	si, [(OpenTFTPStruct es:di).FileName]
	mov	dx, [((OpenTFTPStruct es:di).FileName)+2]

	push	ds
	pop	es			; es = ds

	mov	di, offset TxBuffer
	mov	ax, 0100h		; read request (lo/hi)
	stosw

	;----------------------------------------
	; Copy file name into request packet
	;----------------------------------------
	push	ds			; save our ds
	mov	ds, dx			; set ds to file name segment

	mov	dx, octet_size+2	; start with overhead size

buildLoop:
	lodsb
	stosb
	inc	dx
	or	al, al			; check for terminating null
	jne	buildLoop

	pop	ds			; restore our ds

	mov	si, offset tx_octet
	mov	cx, octet_size		; string length

	rep	movsb			; add "octet" string to buffer

	test	[Flags], 1		; should we do "block size?"
	je	noBlkSize		; no

	mov	si, offset tx_lrgsize
	mov	cx, lrgsize_size
	add	dx, cx			; update packet length
	rep	movsb			; add "blksize" string to buffer

noBlkSize:
	test	[Flags], 2		; should we do "tsize?"
	je	noTSize			; no

	mov	si, offset tx_tsize
	mov	cx, tsize_size
	add	dx, cx			; update packet length
	rep	movsb			; add "blksize" string to buffer

noTSize:
	pop	di			; restore structure pointer
	pop	es			; restore structure segment

	; build the UDP transmit structure
	mov	[UDP2.Size], size TxUDPStruct
	mov	eax, [(OpenTFTPStruct es:di).Address]
	mov	[UDP2.Address], eax
	mov	eax, [((OpenTFTPStruct es:di).Gateway)]
	mov	[(UDP2.Gateway)], eax
	mov	ax, [OurPort]
	mov	[UDP2.SourcePort], ax
	mov	[UDP2.DestPort], 69
	mov	[UDP2.Data], offset TxBuffer
	mov	[(UDP2.Data)+2], ds
	mov	[UDP2.Length], dx

	push	ds
	pop	es			; es = ds

	ret

endp

tx_sumerror	db	'checksum error ', 0

;--------------------------------------------------------------------
; ValidatePacket
;
; Parameters:
;	si - pointer to receive buffer
;
; Returns:
;
;--------------------------------------------------------------------
Proc ValidatePacket

	push	si			; save si

	add	si, 14			; skip MAC header
	mov	al, [(IP si).Protocol]	; get protocol of IP packet
	cmp	al, 17			; is it a UDP packet?
;	je	validateTFTP		; yes

;	cmp	al, 1			; is it a ICMP packet?
	jne	validateBad		; no

;validateTFTP:
	add	si, size IP		; skip IP header

	mov	ax, [si+2]		; get destination port
	xchg	al, ah			; change from network order
	cmp	[OurPort], ax		; is packet on our port?
	jne	validateBad		; no

	mov	ax, [si]		; get source port
	xchg	al, ah			; change from network order
	mov	[UDP2.DestPort], ax	; change destination port

	add	si, size UDP		; skip UDP header

	cmp	[word ptr si], 0600h	; is this an OACK packet?
	jne	notOACK			; no

	add	si, 2			; skip packet type
	call	CheckOACK		; we will process packet 0
	jmp	validateBad

notOACK:
	cmp	[word ptr si], 0500h	; is this an Error packet?
	je	gotError		; yes

	mov	ax, [si+2]		; get packet number
	xchg	al, ah			; flip bytes
	cmp	[PacketNum], ax		; is this the packet we want?
	jne	validateBad		; wrong packet

gotError:
	mov	[Started], 1

	pop	si			; restore si
	clc
	ret				; return no error

validateBad:
	pop	si			; restore si
	mov	[BufferSize], 0		; clear buffer size value
	stc
	ret				; return with error

endp

;--------------------------------------------------------------------
; PacketCallback
;
; Parameters:
;	si - address of receive buffer
;
; Returns:
;
;--------------------------------------------------------------------
Proc PacketCallback

	mov	di, si			; get address of receive buffer
	add	di, 14 + size IP	; skip MAC and IP header

	mov	cx, [di+4]		; get packet size
	xchg	cl, ch			; change from network order
	sub	cx, 12			; subtract UDP & TFTP header size

	add	di, size UDP		; skip UDP header
	mov	ax, [di]		; get packet type
	xchg	al, ah			; change from network order

	mov	bx, [di+2]		; get packet number
	xchg	bl, bh			; change from network order

	add	di, 4			; skip TFTP header

	push	ax			; save packet type
	push	bx			; save packet number
	push	cx			; save packet size
	call	[CallbackTFTP]
	mov	dx, ax			; move return code to dx
	pop	cx			; restore packet size
	pop	bx			; restore packet number
	pop	ax			; restore packet type

	cmp	ax, 5			; was this an error packet?
	je	eof			; yes, return as if done file

	or	dx, dx			; did the callback return an error?
	jne	callBad			; yes

	call	SendAck

	inc	[PacketNum]

	cmp	[PacketSize], cx	; was this a full packet?
	je	notEnd			; yes

	xor	cx, cx			; clear cx to indicate end of file

notEnd:
	xor	ax, ax
eof:
	ret				; return no error

callBad:
	mov	ax, dx			; move error code back to ax
	call	SendNAK
	mov	ax, 1
	ret				; return with error

endp

;--------------------------------------------------------------------
; TimeoutCallback
;
; Parameters:
;	none
;
; Returns:
;
;--------------------------------------------------------------------
Proc TimeoutCallback

	les	di, [InfoPtr]		; get pointer to info structure

	mov	ax, -2			; set packet type as time-out
	mov	cx, [WaitTime]		; get current wait time
	call	[CallbackTFTP]
	mov	[WaitTime], cx		; set new wait time

	or	ax, ax			; check if an error was returned
	ret				; return with client return status

endp

;--------------------------------------------------------------------
; CheckOACK
;
; Parameters:
;	cx - packet size
;	ds:si - pointer to packet
;
; Returns:
;
;--------------------------------------------------------------------
Proc CheckOACK

	mov	di, offset tx_lrgsize
	mov	cx, 7
	rep	cmpsb			; check for blksize string
	jne	badOACK			; string not found

	inc	si

	; convert the ascii value to binary
	xor	ax, ax			; clear start value
	mov	cx, 10			; radix

convertLoop:
	mov	bl, [si]		; get a character
	inc	si
	cmp	bl, 0			; at end of string?
	je	valueDone		; yes

	cmp	bl, '9'
	ja	badOACK			; bad character

	sub	bl, '0'			; convert to numeric
	jb	badOACK			; bad value

	mul	cx			; multiply running value by 10
	add	ax, bx			; add new digit

	jmp	convertLoop		; do next character

valueDone:
	cmp	ax, 1450		; compare with our max value
	ja	badOACK			; bad value

	mov	[PacketSize], ax	; save our new packet size
	mov	[Started], 1

	mov	bx, 0			; packet number is 0
	call	SendACK			; ACK the offer

	mov	di, offset UDP2		; get pointer to UDP info
	call	AITransmitUDP		; send the UDP packet

	xor	ax, ax			; return "no error"
	mov	cx, 1			; return "not last packet"
	ret

badOACK:
	mov	bx, 8
	call	SendNAK2
	mov	ax, 1			; return "error"
	mov	cx, 0			; return "last packet"
	ret

endp

;--------------------------------------------------------------------
; SendAck
;
; Sends back an acknowledgment packet for the data packet just received.
;
; Parameters:
;	bx - packet number
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc SendAck

	mov	di, offset TxBuffer	; pointer to transmit data
	mov	[word ptr di], ACK	; save value

	xchg	bl, bh
	mov	[di+2], bx		; send packet number

	mov	[UDP2.Length], 4	; update length

	ret

endp

;--------------------------------------------------------------------
; SendNAK
;
; Sends back an acknowledgment packet for the data packet just received.
;
; Parameters:
;	ax - error code
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc SendNAK

	mov	bx, NAK			; default value

SendNAK2:
	mov	di, offset TxBuffer	; pointer of transmit data
	mov	[word ptr di], bx	; save value

	xchg	al, ah
	mov	[di+2], ax		; send error code

	mov	[UDP2.Length], 4	; update length

	mov	di, offset UDP2		; get pointer to UDP info
	call	AITransmitUDP		; send the UDP packet

	ret

endp

;--------------------------------------------------------------------

tx_octet	db 'octet', 0
octet_size	equ 6

tx_lrgsize	db 'blksize', 0
		db '1450', 0
lrgsize_size	equ 13

tx_tsize	db 'tsize', 0
tsize_size	equ 6

Started		db	?
Flags		dw	?
PacketNum	dw	?
PacketSize	dw	512
InfoPtr		dd	?
OurPort		dw	?
WaitTime	dw	?
UDP2		TxUDPStruct	<?>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\include\ai.inc ===
BW_GETINFO	= 0
BW_DISENGAGE	= 1
BW_RECEIVE	= 2
BW_SETCALLBACK	= 3
BW_CHANGEMASK	= 4
BW_TRANSMITRAW	= 5
BW_TRANSMITIP	= 6
BW_TRANSMITUDP	= 7
BW_OPENTFTP	= 8
BW_TRANSMITPKT	= 9

;------------------------------------------------
; API Structures
;------------------------------------------------
Struc AIINFOStruct
	Ver		dw	?	; version of the info structure
	RomVer		dw	?	; version of the ROM
	RomType		dw	?	; type of ROM
	MaxFrame	dw	?	; maximum frame size
	BootPro		dw	?	; current boot protocol
	NetAddress	dw	?,?,?	; MAC address
	LocalIP		dw	?,?	; local IP address
	ServerIP	dw	?,?	; server IP address
	BOOTPPkt	dw	?, ?	; address of BOOTP/DHCP packet
	DiscoverPkt	dw	?, ?	; address of DHCP discover packet
	BINLPkt		dw	?, ?	; address of BINL packet
ends

Struc TxPktStruct
	Size		dw	?
	Address		dw	?, ?, ?
	Data		dw	?, ?
	Length		dw	?
	Type		dw	?
ends

Struc TxIPStruct
	Size		dw	?
	Address		dd	?
	Gateway		dd	?
	Data		dw	?, ?
	Length		dw	?
	Protocol	db	?
ends

Struc TxUDPStruct
	Size		dw	?
	Address		dd	?
	Gateway		dd	?
	SourcePort	dw	?
	DestPort	dw	?
	Data		dw	?, ?
	Length		dw	?
ends

Struc OpenTFTPStruct
	Size		dw	?
	Address		dd	?
	Gateway		dd	?
	Flags		dw	?
	FileName	dw	?,?
	Callback	dd	?
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\include\bwnid.inc ===
;====================================================================
; BWNID.INC
;
; Include for for BootWare NID modules.
;
; 970116 PC - first version
;====================================================================

	include "..\include\bwstruct.inc"
	include "..\include\ai.inc"

;--------------------------------------------------------------------
; COMMON.OBJ functions
;--------------------------------------------------------------------
extrn	PrintTitle:near
extrn	Print:near
extrn	PrintChar:near
extrn	PrintCRLF:near
extrn	PrintDecimal:near
extrn	ClearScreen:near
extrn	StoDec:near
extrn	Reboot:near
extrn	ErrorMsg:byte

;--------------------------------------------------------------------
; Adapter interface functions
;--------------------------------------------------------------------
extrn	AIInitialize:near
extrn	AITransmit:near
extrn	AIReceive:near
extrn	AIChangeReceiveMask:near
extrn	AIDisengage:near
extrn	AITransmitPkt:near
extrn	AITransmitRaw:near
extrn	AITransmitIP:near
extrn	AITransmitUDP:near
extrn	AIOpenTFTP:near
extrn	AISetCallBack:near
extrn	ReceiveExp:near
extrn	CheckRxBuffer:near
extrn	NetAddress:byte
extrn	Verbose:byte
extrn	BWTable:BWT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\include\bwstruct.inc ===
;====================================================================
; BWSTRUCT.INC
;
; Include for for BootWare, defines common structures.
;
; $Author: Paul Cowan $
; $Modtime: 7/20/98 17:25 $
; $Revision: 5 $
;====================================================================

;--------------------------------------------------------------------
; Common equates
;---------------------------------------------------------------------

LOADER_FLOPPY 	= 1
LOADER_TSR	= 2
LOADER_BBS	= 4
LOADER_BIOS	= 4000h

Struc	Header
	Jump		dw	?
	ID		dd	?
	Size		dw	?
	Ver		dw	?
	Patches		db	?, ?, ?, ?
			dw	?
ends

Struc	UNDIHdr
			dw	?
	ID		dd	?
	Size		dw	?
	Ver		dw	?
	Patches		db	?, ?, ?, ?
			dw	?
	SizeHdr		dw	?
	SizeCode	dw	?
	SizeData	dw	?
	SizeBSS 	dw	?
	LanOption	db	?
ends

Struc	BWT
	Size		db	?	; size of table
	Ver		db	?	; table version
	RomVer		dw	?	; ROM version
	RomType		dw	?	; ROM BootWare type
	Settings	dd	?	; current configuration settings
	Capabilities	dd	?	; ROM capabilities
	Defaults	dd	?	; factory defaults
	EEMask		dd	?	; EEROM mask
	NWFile		db 14 dup(?)	; NetWare default file name
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\include\config.inc ===
;--------------------------------------------------------------------------
; CONFIG.INC
;
; Include file for BootWare ROM Configuration screen.
;
; $Author: Paul Cowan $
; $Modtime: 21/08/98 9:38a $
; $Revision: 8 $
;--------------------------------------------------------------------------

CFG_INITIALIZED	equ	0000000000000001b
CFG_METHOD	equ	0000000000000110b
CFG_PROTOCOL	equ	0000000000011000b
CFG_LOCAL	equ	0000000000100000b
CFG_CONFIG	equ	0000000001000000b
CFG_NOLOCAL	equ	0000000010000000b
CFG_NOTNEXTBBS	equ	0000000100000000b
CFG_MESSAGE	equ	0000001000000000b
CFG_TIMEOUT	equ	0000110000000000b
CFG_WAITKEY	equ	0001000000000000b
CFG_OTHER	equ	1110000000000000b

CFG_VERSION	equ	00010000000000000000b

API_VER		equ	0100h

PROT_PXE	equ	000b
PROT_TCPIP	equ	010b
PROT_NETWARE	equ	100b
PROT_RPL	equ	110b

NW_8022		equ	00000b
NW_8023		equ	01000b
NW_ETHII	equ	10000b

IP_BOOTP	equ	00000b
IP_DHCP		equ	01000b
IP_BINL		equ	10000b

TIME0		equ	0000000000000000b
TIME1		equ	0000010000000000b
TIME2		equ	0000100000000000b
TIME3		equ	0000110000000000b

CAP_PXE		equ	1
CAP_TCPIP	equ	2
CAP_NETWARE	equ	4
CAP_RPL		equ	8

IFDEF _IDEAL_
Struc	CfgData
	Row		db	?	; screen row
	Item		db	?	; current item
	Title		dw	?	; pointer to field name
	Type		db	?	; field type
	Changed		db	?	; field changed flag
	Width		db	?	; field text width
	Options		db	?	; number of options in field
	OldVal		dw	?	; orignal value
	NewVal		dw	?	; new value
	Values		dw	?	; pointer to values
	Text		dw	?	; pointer to value strings
ends
ELSE
CfgData Struc
	ConfigRow	db	?	; screen row
	ConfigItem	db	?	; current item
	ConfigTitle	dw	?	; pointer to field name
	ConfigType	db	?	; field type
	ConfigChanged	db	?	; field changed flag
	ConfigWidth	db	?	; field text width
	ConfigOptions	db	?	; number of options in field
	ConfigOldVal	dw	?	; orignal value
	ConfigNewVal	dw	?	; new value
	ConfigValues	dw	?	; pointer to values
	ConfigText	dw	?	; pointer to value strings
CfgData ends
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\include\drvseg.inc ===
;----------------------------------------------------------------------
; DRVSEG.INC
;
; Segment definitions for all BootWare ROMs.
;
; 961226 PC - added Code_NID and Code_NAD, changed alignments to para
;	    - added IDEAL mode support
; 960105 PC - added INIT segment
; 951030 PC
;----------------------------------------------------------------------
Group	cGroup Code, Sparse
	assume	cs:cGroup, ds:cGroup, es:nothing,ss:nothing

Macro	START_CODE
Segment	Code Public "Code"
	assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
endm

Macro	END_CODE
ends
endm

Macro	START_SPARSE
Segment	Sparse Public "Code"
endm

Macro	END_SPARSE
ends
endm

;====================================================================
; Use all the marcos to set the order of the segments.
;====================================================================

START_CODE
END_CODE

START_SPARSE
END_SPARSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\include\loader.inc ===
Struc	LoaderInfo
	LangSeg		dw	?
	PCIBusDevFunc	dw	?
	VendorID	dw	?
	DeviceID	dw	?
	CSN		dw	?
	UNDICode	dw	?	; UNDI code size
	UNDIData	dw	?	; UNDI data size
	UNDISeg		dw	?	; UNDI segment
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\include\undi_api.inc ===
;--------------------------------------------------------------------
; PXE UNDI constants and structures
;
;--------------------------------------------------------------------

BUS_ISA		equ	0
BUS_PCI		equ	3

SUCCESS		equ	0
DELAY		equ	-1

UNDI_STARTUP	 	equ	01h
UNDI_CLEANUP	 	equ	02h
UNDI_INITIALIZE 	equ	03h
UNDI_RESET_NIC		equ	04h
UNDI_SHUTDOWN		equ	05h
UNDI_OPEN		equ	06h
UNDI_CLOSE		equ	07h
UNDI_TRANSMIT		equ	08h
UNDI_SET_MCAST_ADDR	equ	09h
UNDI_SET_STATION_ADDR	equ	0Ah
UNDI_SET_PACKET_FILTER	equ	0Bh
UNDI_GET_INFORMATION	equ	0Ch
UNDI_GET_STATISTICS	equ	0Dh
UNDI_CLEAR_STATISTICS	equ	0Eh
UNDI_INITIATE_DIAGS	equ	0Fh
UNDI_FORCE_INTERRUPT	equ	10h
UNDI_GET_MCAST_ADDR	equ	11h
UNDI_GET_NIC_TYPE	equ	12h
UNDI_GET_NDIS_INFO	equ	13h

ADDR_LEN		equ	16
MAXNUM_MCADDR		equ	8

struc S_UNDI_MCAST_ADDR
	MCastAddrCount	dw	?
	MCastAddr	db (8*16) dup (?)
ends

struc S_FORCE_INTERRUPT
	Status		dw	?
ends

struc S_UNDI_CLOSE
	Status		dw	?
ends

struc S_UNDI_STARTUP_PCI
	Status		dw	?
	BusType		db	?
	AddrType	db	?
	DataSegment	dw	?
	DataSegAddr	dd	?
	DataSegSize	dw	?
	CodeSegSize	dw	?
	BusDevFunc	dw	?
	PCI_ds_off	dw	?
	PCI_ds_seg	dw	?
ends

struc S_UNDI_STARTUP_PNP
	Status		dw	?
	BusType		db	?
	AddrType	db	?
	DataSegment	dw	?
	DataSegAddr	dd	?
	DataSegSize	dw	?
	CodeSegSize	dw	?
	CSN		dw	?
	PnP_eh_off	dw	?
	PnP_eh_seg	dw	?
ends

struc S_UNDI_INITIALIZE
	Status		dw	?
	ProtocolIni	dd	?
	ReceiveOffset	dw	?
	ReceiveSegment	dw	?
	GeneralIntOff	dw	?
	GeneralIntSeg	dw	?
ends

struc S_UNDI_OPEN
	Status		dw	?
	OpenFlag	dw	?
	PktFilter	dw	?
	MCastBuffer	S_UNDI_MCAST_ADDR <?>
ends

FLTR_DIRECTED	equ	1
FLTR_BDRCST	equ	2
FLTR_PRMSCS	equ	4
FLTR_SRC_RTG	equ	8

struc S_UNDI_GET_INFO
	Status		dw	?
	BaseIo		dw	?
	IntNumber	dw	?
	MaxTranUnit	dw	?
	HwType		dw	?
	HwAddrLen	dw	?
	CurrentNodeAddress db	ADDR_LEN dup(?)
	PermNodeAddress db	ADDR_LEN dup(?)
	RomAddress	dw	?
	RxBufCt		dw	?
	TxBufCt		dw	?
ends

ETHER_TYPE = 1

struc S_UNDI_GET_NIC_TYPE_PCI
	Status		dw	?
	NicType		db	?
	Vendor_ID	dw	?
	Dev_ID		dw	?
	Base_Class	db	?
	Sub_Class	db	?
	Prog_Intf	db	?
	Rev		db	?
	BusDevFunc	dw	?
ends

struc S_UNDI_GET_NIC_TYPE_PNP
	Status		dw	?
	NicType		db	?
	EISA_Dev_ID	dd	?
	Base_Class	db	?
	Sub_Class	db	?
	Prog_Intf	db	?
	CardSelNum	dw	?
ends

;--------------------------------------------------------------------
; Transmit structures
;--------------------------------------------------------------------

struc DATABLK
	PtrType		db	?
	Reserved	db	?
	Len		dw	?
	Off		dw	?
	Seg		dw	?
ends

struc UNDI_TBD
	Length		dw	?
	XmitOffset	dw	?
	XmitSegment	dw	?
	DataBlkCount	dw	?
ends

struc S_UNDI_TRANSMIT
	Status		dw	?
	Protocol	db	?
	XmitFlag	db	?
	DestAddrOffset	dw	?
	DestAddrSegment	dw	?
	TBDOffset	dw	?
	TBDSegment	dw	?
	Reserved	dd	?, ?
ends

P_RAW	equ	0
P_IP	equ	1
P_ARP	equ	2

struc S_UNDI_SET_PACKET_FILTER
	Status		dw	?
	Filter		db	?
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\pxe\tftp.asm ===
Struc	DESCRIPTOR
	Dummy		dw	?, ?, ?, ?
	GDT_LOC 	dw	?, ?, ?, ?
	SourceLimit	dw	?
	SourceLoWord	dw	?
	SourceHiByte	db	?
	SourceRights	db	?
	SourceInternal	db	?
	SourceHiByteHi	db	?
	TargetLimit	dw	?
	TargetLoWord	dw	?
	TargetHiByte	db	?
	TargetRights	db	?
	TargetInternal	db	?
	TargetHiByteHi	db	?
	Bios		dw	?, ?, ?, ?
	Temp		dw	?, ?, ?, ?
ends

even
TFTP		OpenTFTPStruct <>
GDT		DESCRIPTOR <?>			; global descriptor table
Address		dd	0
Bytes		dd	0
TimeOutCounter	dw	0

;--------------------------------------------------------------------
; TFTPRestart
;
;--------------------------------------------------------------------
Proc TFTPRestart

	call	TFTPReadFile		; get the file
	jc	readError		; was there an error ?

	mov	ax, 5650h
	int	1Ah			; get PXE entry structure pointer

	push	0			; new segment
	push	7C00h			; new offset
	retf				; jump to downloaded file

readError:
	ret

endp

;--------------------------------------------------------------------
; TFTPReadFile
;
;--------------------------------------------------------------------
Proc TFTPReadFile

	; Clear some variables.
	mov	[Bytes], 0
	mov	[TimeOutCounter], 0

;db 0F1h
;extrn break:byte
;mov [break], 0F1h

	; Copy the destination RAM address.
	mov	eax, [(s_PXENV_TFTP_READ_FILE es:di).BufferOffset]
	mov	[Address], eax

	; Fill BootWares' OpenTFTP data structure.
	mov	[TFTP.Size], size TFTP
	mov	[TFTP.Flags], 1                 ; 1 = use large packets
	mov	eax, [dword ptr (s_PXENV_TFTP_READ_FILE es:di).ServerIP]
	mov	[dword ptr TFTP.Address], eax
	mov	eax, [dword ptr (s_PXENV_TFTP_READ_FILE es:di).GatewayIP]
	mov	[TFTP.Gateway], eax
	mov	[(TFTP.FileName)+2], es
	lea	ax, [(s_PXENV_TFTP_READ_FILE es:di).FileName]
	mov	[TFTP.FileName], ax
	mov	[word ptr TFTP.Callback], offset TFTPCallback
	mov	[word ptr (TFTP.Callback)+2], cs

	push	cs
	pop	es			; es = cs

	mov	bx, BW_OPENTFTP		; Function number.
	lea	di, [TFTP]		; es:di -> OpenTFTP structure.
	call	[BWAPI]			; transfer the file

	les	di, [PxePtr]		; Get a pointer to PXE structure.

	or	ax, ax			; was there an error?
	je	gotFile			; no

	; Return the size of the file written into the buffer.
	mov	eax, [Bytes]
	mov	[(s_PXENV_TFTP_READ_FILE es:di).BufferSize], eax

	mov	ax, PXENV_STATUS_FAILURE
	ret

gotFile:
	; Return the size of the file written into the buffer.
	mov	eax, [Bytes]
	mov	[(s_PXENV_TFTP_READ_FILE es:di).BufferSize], eax

	mov	ax, PXENV_STATUS_SUCCESS
	ret

endp

;--------------------------------------------------------------------
; TftpCallback
;
; Callback function for TFTP transfer.
;
; Parameters:
;	ax - packet type
;	bx - packet number
;	cx - packet size
;	es:di - pointer to data
;
; Returns:
;	ax - status (0 = OK)
;--------------------------------------------------------------------
Proc TftpCallback far

	pusha

	cmp	ax, -2			; is this a timeout callback?
	je	checkTimeOut		; yes

        cmp     ax, 5                   ; is this an error packet ?
        jne     noError
        popa                            ; yes...retry.
        mov     ax, 1                   ; indicate some error.
        ret

noError:
        mov     [TimeOutCounter], 0     ; clear any previous time outs.

	add	[word ptr Bytes], cx	; update byte counter
	adc	[(word ptr Bytes)+2], 0

	call	CopyMemory

	popa
	xor	ax, ax			; indicate success
	jnc	copyOK			; no error

	inc	ax			; return error

copyOK:
	ret

checkTimeOut:
	les	di, [PxePtr]		; Get a pointer to PXE structure.

        mov     ax, [TimeOutCounter]
        cmp     [(s_PXENV_TFTP_READ_FILE es:di).TFTPReopenDelay], ax
        jne     timeoutOK               ; have we reached retry limit?...no

        inc     [TimeOutCounter]
        popa
        add     cx, 18                  ; add ~second to time out
        inc     ax                      ; yes...indicate error
        ret

timeoutOK:
        inc     [TimeOutCounter]
        popa
        add     cx, 18                  ; add ~second to time out
        xor     ax,ax                   ; clear return status
	ret

endp

;--------------------------------------------------------------------
; CopyMemory
;
; Copies image into extended RAM.
;
; On entry:
;	cx - size to copy
;	es:di pointer to data
;
; Returns:
;	carry clear - everything OK
;	carry set - something went wrong
;--------------------------------------------------------------------
Proc CopyMemory

	push	cx			; save data size

	push	di			; save data offset
	push	es			; save data segment

	push	ds
	pop	es			; es = ds

	mov	di, offset GDT		; get GDT location
	mov	cx, (size DESCRIPTOR)/2
	xor	ax, ax
	rep	stosw			; zero the GDT (es:di)

	; source address must be converted to 24 bit address for extended
	; memory INT15 copy function
	pop	ax			; ax = data segment
	xor	dx, dx			; dx = 0
	mov	cx, 16
	mul	cx			; dx:ax = ax * 16
	pop	bx			; get data offset
	add	bx, ax			; add to offset
	adc	dx, 0			; dx:bx is now 24 bit source address

	pop	cx			; restore byte count
	push	cx			; save it again

	mov	[GDT.SourceLimit], cx	; set copy size
	mov	[GDT.TargetLimit], cx	; set copy size
	mov	[GDT.SourceRights], 93h ; set copy rights
	mov	[GDT.TargetRights], 93h ; set copy rights

	mov	[GDT.SourceLoWord], bx	; set source address lo word
	mov	[GDT.SourceHiByte], dl	; set source address hi byte
	mov	[GDT.SourceHiByteHi], dh

	mov	si, [word ptr Address]	; get 24 bit extended memory address
	mov	dx, [(word ptr Address)+2]
	mov	[GDT.TargetLoWord], si	; set dest address low word
	mov	[GDT.TargetHiByte], dl	; set dest address hi byte
	mov	[GDT.TargetHiByteHi], dh

	inc	cx			; increase to evenize
	shr	cx, 1			; now cx is word count
	mov	si, offset GDT		; address of GDT (ds:di)
	mov	ah, 87h
	int	15h			; move data to/from extended memory

	pop	cx			; restore byte count in CX

	pushf				; save INT15 status

	add	[word ptr Address], cx	; calc next address
	adc	[(word ptr Address)+2], 0

	popf				; restore INT15 status
	ret				; return - carry set/cleared in INT15

endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\pxe\pxe_api.inc ===
;--------------------------------------------------------------------
; PXE TFTP constants and structures
;
;--------------------------------------------------------------------

PXENV_EXIT_SUCCESS	equ	0
PXENV_EXIT_FAILURE	equ	1

PXENV_STATUS_SUCCESS	equ	00h
PXENV_STATUS_FAILURE	equ	01h
PXENV_STATUS_BAD_FUNC	equ	02h
PXENV_STATUS_UNSUPPORTED equ	03h

PXENV_UNLOAD_STACK	equ	070h
PXENV_GET_BINL_INFO	equ	071h
PXENV_RESTART_DHCP	equ	072h
PXENV_RESTART_TFTP	equ	073h
PXENV_MODE_SWITCH	equ	074h

struc S_PXENV_ENTRY
	Signature	db	6 dup(?)
	Ver		dw	?
	Bytes		db	?
	Checksum	db	?
	rm_entry_off	dw	?
	rm_entry_seg	dw	?
	pm_entry_off	dw	?
	pm_entry_base	dd	?
	stack_sel	dw	?
	stack_size	dw	?
	base_cs_sel	dw	?
	base_cs_size	dw	?
	base_ds_sel	dw	?
	base_ds_size	dw	?
	mlid_ds_sel	dw	?
	mlid_ds_size	dw	?
	mlid_cs_sel	dw	?
	mlid_cs_size	dw	?
ends

struc S_PXENV_GET_BINL_INFO
	Status		dw	?
	PacketType	dw	?
	BufferSize	dw	?
	BufferOffset	dw	?
	BufferSegment	dw	?
ends

PXENV_PACKET_TYPE_DHCP_DISCOVER	equ	1
PXENV_PACKET_TYPE_DHCP_ACK	equ	2
PXENV_PACKET_TYPE_BINL_REPLY	equ	3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\pxe\tftp_api.inc ===
;--------------------------------------------------------------------
; PXE TFTP constants and structures
;
;--------------------------------------------------------------------

PXENV_TFTP_OPEN		equ	20h
PXENV_TFTP_CLOSE	equ	21h
PXENV_TFTP_READ		equ	22h
PXENV_TFTP_READ_FILE	equ	23h

struc S_PXENV_TFTP_OPEN
	Status		dw	?
	ServerIP	db	4 dup(?)
	GatewayIP	db	4 dup(?)
	Filename	db	128 dup(?)
	TFTPPort	dw	?
	Flags		dw	?
ends

struc S_PXENV_TFTP_CLOSE
	Status		dw	?
ends

struc S_PXENV_TFTP_READ
	Status		dw	?
	PacketNumber	dw	?
	BufferSize	dw	?
	BufferOff	dw	?
	BufferSeg	dw	?
ends

struc S_PXENV_TFTP_READ_FILE
        Status		dw	?
        FileName	db	128 dup(?)
        BufferSize	dd	?
        BufferOffset	dd	?
        ServerIP	db	4 dup(?)
        GatewayIP	db	4 dup(?)
        McastIP		db	4 dup(?)
        TFTPClntPort	dw	?
        TFTPSrvPort	dw	?
        TFTPOpenTimeOut	dw	?
        TFTPReopenDelay dw	?
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\pxe\udp_api.inc ===
;--------------------------------------------------------------------
; PXE UDP constants and structures
;
;--------------------------------------------------------------------

PXENV_UDP_OPEN	equ	30h
PXENV_UDP_CLOSE	equ	31h
PXENV_UDP_READ	equ	32h
PXENV_UDP_WRITE	equ	33h

struc S_PXENV_UDP_OPEN
	status		dw	?
	src_ip		dd	?
ends

struc S_PXENV_UDP_CLOSE
	status		dw	?
ends

struc S_PXENV_UDP_READ
	status		dw	?
	src_ip		dd	?
	dest_ip		dd	?
	s_port		dw	?
	d_port		dw	?
	buffer_size	dw	?
	buffer_off	dw	?
	buffer_seg	dw	?
ends

UDP_READ_ANY_IP	  equ	0	; Accept packets sent to any IP.
UDP_READ_CHECK_IP equ	1	; Only accept packets sent to a
				; specific IP address.

struc S_PXENV_UDP_WRITE
	status		dw	?
	ip		dd	?
	gw		dd	?
	src_port	dw	?
	dst_port	dw	?
	buffer_size	dw	?
	buffer_off	dw	?
	buffer_seg	dw	?
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\ai\ai.asm ===
;====================================================================
; AI.ASM
;
; Adapter interface layer for BootWare.
;
; $History: AI.ASM $
; 
; *****************  Version 6  *****************
; User: Paul Cowan   Date: 11/08/98   Time: 4:50p
; Updated in $/Client Boot/BW98/BootWare/AI
; Improved handling of UNDI initialization errors.
;
; *****************  Version 5  *****************
; User: Paul Cowan   Date: 7/21/98    Time: 15:16
; Updated in $/Client Boot/BW98/BootWare/AI
; Corrected AIChangeReceiveMask return codes.
;
; *****************  Version 4  *****************
; User: Paul Cowan   Date: 06/10/98    Time: 12:54
; Updated in $/Client Boot/BW98/BootWare/AI
; Removed printing of UNDI error code.
;
; *****************  Version 3  *****************
; User: Paul Cowan   Date: 05/28/98    Time: 17:44
; Updated in $/Client Boot/BW98/BootWare/AI
; Changed to new config table format.
;
; *****************  Version 2  *****************
; User: Paul Cowan   Date: 05/25/98    Time: 12:05
; Updated in $/Client Boot/BW98/BootWare/AI
; Received ARP's are only processed if we sent the request.
;
;====================================================================

IDEAL
_IDEAL_ = 1
Locals
	include "..\include\drvseg.inc"
	include "..\include\bwstruct.inc"
	include "..\tcpip\tcpip.inc"
	include "..\include\undi_api.inc"
	include "..\include\ai.inc"

MTU = 1525

public	AIInitialize
public	AIChangeReceiveMask
public	AIDisengage
public	AIDisengageNW
public	AITransmitPkt
public	AITransmitIP
public	AITransmitUDP
public	AIOpenTFTP
public	AISetCallback
public	AIPoll

public	CheckRxBuffer

public	AITbl

public	TxBuffer
public	BufferSize

public	UNDI

public	TxData				; public for NW NID
public	TxTBD
public	TxData0
public	TxData1
public	TxData2

public	NIC_IRQ
public	NIC_IO
public	NetAddress

extrn	BootWareSize:word
extrn	ConfigSize:word
extrn	PCIBusDevFunc:word
extrn	CSN:word
extrn	Verbose:byte

extrn	BWTable:BWT

;--------------------------------------------------------------------
; COMMON.OBJ functions
;--------------------------------------------------------------------
extrn	PrintSettings:near
extrn	Print:near
extrn	PrintDecimal:near
extrn	PrintCRLF:near
extrn	Reboot:near

;------------------------------------------------
; TCP/IP NID labels
;------------------------------------------------
extrn	LocalIP:word
extrn	ServerIP:word
extrn	BootPkt:word
extrn	DiscoverPkt:word
extrn	BINLPkt:word

ERROR_UNKNOWNIP	= 25

;====================================================================
;			  Code segment
;====================================================================
START_CODE
P386

public _AIStart
label _AIStart

ID	db	'BWAPI'		; identifer string (don't change)
	db	2		; version of the API table (don't change)
	dw	0		; offset of NAD table
AITbl	dw	ApiEntry, 0	; external jump table

	db	'AI*980525*'	; build date
	dw	0200h		; build version

CallBackRaw	dd	0
CallBackIP	dd	0
CallBackUDP	dd	0
CallBackTFTP	dd	0
ListenPort	dw	0

NoCallbacks	db	0

Ident		dw	0

LastError	dw	0

UNDI		dd	0

Initializing	db	'Initializing adapter...', 13, 10, 0

;public _ErrorInit
;_ErrorInit	db	7, "Error: Unable to initialize adapter", 0

;----------------------------------------------------------------------
; AIInitialize
;
; Parameters:
;	bx - UNDI segment
;	cx - UNDI code size
;	dx - UNDI data size
;	si - pointer to receive buffer
;	ds - RAM segment
;
; Returns:
;	doesn't
;----------------------------------------------------------------------
Proc AIInitialize

	push	cx			; save UNDI code size
	push	dx			; save UNDI data size

	mov	[word ptr UNDI+2], bx	; save UNDI segment
	mov	[RxBuffer], si		; set receive buffer area

	mov	[AITbl+2], ds		; set API segment

	cmp	[Verbose], 0		; is verbose mode on
	je	skip1

	mov	bx, offset Initializing
	call	Print			; print "Initializing adapter"

skip1:
	pop	dx			; restore UNDI data size
	pop	cx			; restore UNDI code size

	call	InitUNDI		; initialize the UNDI
	cmp	ax, 0			; was an error message returned?
	je	undiOK			; no error

;	call	PrintCRLF
;	mov	bx, offset _ErrorInit
;	call	Print			; display the error message

	jmp	Reboot			; reboot the workstation

undiOK:
	call	PrintSettings		; print the adapters settings

	call	InitMemory		; initialize our memory buffers

	ret				; we are initialized

endp

;-----------------------------------------------------------------------------
; InitUNDI
;
; Parameters:
;	cx - UNDI code size
;	dx - UNDI data size
;
; Returns:
;	ax - error code (0 = OK)
;-----------------------------------------------------------------------------
Proc InitUNDI

	push	ds
	pop	es			; es = ds

	push	cx			; save UNDI code size

	mov	di, offset CallBuff
	mov	cx, size S_UNDI_STARTUP_PCI
	xor	ax, ax
	rep	stosb			; clear data structure

	mov	di, offset CallBuff

	mov	ax, [PCIBusDevFunc]	; get PCI Bus/Device/Function value
	cmp	ax, 0			; do we have a value?
	je	notPCI			; no - it's not PCI

	mov	[(S_UNDI_STARTUP_PCI di).BusType], BUS_PCI
	mov	[(S_UNDI_STARTUP_PCI di).BusDevFunc], ax

	jmp	@@skip

notPCI:
	mov	ax, [CSN]		; get PnP card selction number
	mov	[(S_UNDI_STARTUP_PNP di).BusType], BUS_ISA
	mov	[(S_UNDI_STARTUP_PNP di).CSN], ax

@@skip:
	; store UNDI data size
	mov	[(S_UNDI_STARTUP_PCI di).DataSegSize], dx

	; store UNDI code size
	pop	ax			; get UNDI code size
	mov	[(S_UNDI_STARTUP_PCI di).CodeSegSize], ax

	; calc starting location for UNDI data from UNDI segment
	add	ax, 0Fh			; so address will start on a paragraph
	shr	ax, 4			; divide by 16
	add	ax, [word ptr UNDI+2]	; add UNDI starting segment

	mov	[(S_UNDI_STARTUP_PCI di).DataSegment], ax
;	mov	di, offset CallBuff
	mov	bx, UNDI_STARTUP
	call	[UNDI]			; call UNDI_STARTUP

	mov	[(S_UNDI_INITIALIZE di).Status], 0
	mov	[(S_UNDI_INITIALIZE di).ProtocolIni], 0
	mov	[(S_UNDI_INITIALIZE di).ReceiveOffset], offset RxInt
	mov	[(S_UNDI_INITIALIZE di).ReceiveSegment], cs
	mov	[(S_UNDI_INITIALIZE di).GeneralIntOff], offset GeneralInt
	mov	[(S_UNDI_INITIALIZE di).GeneralIntSeg], cs
	mov	di, offset CallBuff
	mov	bx, UNDI_INITIALIZE
	call	[UNDI]			; call UNDI_INITIALIZE
	jnc	initOK			; jump if no error

	; handle returned error message
	mov	bx, offset InitError
	call	Print			; print "UNDI Initialize failed, "

	mov	ax, [(S_UNDI_INITIALIZE CallBuff).Status]
	cmp	ax, 61h			; is error media?
	jne	notMedia		; no

	mov	bx, offset MediaError
	call	Print			; print media error message
	jmp	initBad

notMedia:
	mov	bx, offset InitError2
	call	Print

	mov	ax, [(S_UNDI_INITIALIZE CallBuff).Status]
	call	PrintDecimal

	jmp	initBad

initOK:
	mov	di, offset CallBuff
	mov	bx, UNDI_GET_INFORMATION
	call	[UNDI]			; call UNDI_GET_INFORMATION

	mov	ax, [(S_UNDI_GET_INFO CallBuff).IntNumber]
	mov	[NIC_IRQ], al

	mov	ax, [(S_UNDI_GET_INFO CallBuff).BaseIo]
	mov	[NIC_IO], ax

	lea	si, [(S_UNDI_GET_INFO CallBuff).PermNodeAddress]
	mov	di, offset NetAddress
	movsw
	movsw
	movsw

	; open the adapter
	mov	[(S_UNDI_OPEN CallBuff).Status], 0
	mov	[(S_UNDI_OPEN CallBuff).OpenFlag], 0
	mov	[(S_UNDI_OPEN CallBuff).PktFilter], FLTR_DIRECTED
	mov	di, offset CallBuff
	mov	bx, UNDI_OPEN
	call	[UNDI]			; call UNDI_OPEN
	jnc	openOK

	mov	bx, offset OpenError
	call	Print

initBad:
	mov	ax, [(S_UNDI_INITIALIZE CallBuff).Status]
	ret				; return with error

openOK:
	xor	ax, ax			; return - no error
	ret

endp

InitError  db "UNDI Initialize failed, ", 0
MediaError db "no media detected.", 0
InitError2 db "error # ", 0

OpenError db "UNDI Open failed.", 0

;--------------------------------------------------------------------
; InitMemory
;
; Parameters:
;	none
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc InitMemory

	push	ds
	pop	es			; set es=ds

	; Initialize the pointers in the Transmit data structure
	mov	[TxData.TBDOffset], offset TxTBD
	mov	[TxData.TBDSegment], ds
	mov	[TxTBD.Length], 0		; no immediate data
	xor	al, al
	mov	[TxData.XmitFlag], al	; we will always supply dest address
	mov	[TxData.Protocol], al	; we will build the MAC header

	inc	al			; al =1
	mov	[TxData0.PtrType], al	; pounter type is seg:offset
	mov	[TxData1.PtrType], al
	mov	[TxData2.PtrType], al

	mov	[BufferSize], 0		; clear buffer size

	ret

endp

;----------------------------------------------------------------------
;----------------------------------------------------------------------
Proc GeneralInt far

	xor	ax, ax			; return success
	ret

endp


;--------------------------------------------------------------------
; AIChangeReceiveMask
;
; Returns:
;	TRUE/FALSE
;--------------------------------------------------------------------
Proc AIChangeReceiveMask

	test	bx, 2			; are we changing broadcasts?
	je	notBroadcasts		; no

	; enable only unicast packets
	mov	[(S_UNDI_SET_PACKET_FILTER CallBuff).Filter], FLTR_DIRECTED

	test	bx, 1			; are we enabling broadcasts?
	je	disableBroadcasts	; no

	; enable broadcast and unicast packets
	mov	[(S_UNDI_SET_PACKET_FILTER CallBuff).Filter], FLTR_BDRCST or FLTR_DIRECTED

disableBroadcasts:
	mov	di, offset CallBuff
	mov	bx, UNDI_SET_PACKET_FILTER
	call	[UNDI]			; call UNDI_SET_PACKET_FILTER

	cmp	[(S_UNDI_SET_PACKET_FILTER CallBuff).Status], 0
	jne	notBroadcast		; UNDI returned error
	mov	ax, 1			; return TRUE
	ret

notBroadcasts:
	xor	ax, ax			; return FALSE
	ret

endp

;====================================================================
;				Exported functions
;====================================================================
EVEN
APITable	dw	AIGetInfo	; 0
		dw	AIDisengage	; 1
		dw	AIReceive	; 2
		dw	AISetCallBack	; 3
		dw	AIChangeRxMask	; 4
		dw	AITransmitRaw	; 5
		dw	AITransmitIP	; 6
		dw	AITransmitUDP	; 7
		dw	AIOpenTFTP	; 8
		dw	AITransmitPkt	; 9

MAX_API = 9

;--------------------------------------------------------------------
; ApiEntry
;
; Parameters:
;	bx - function number
;
; Returns:
;	what ever the called function returns
;--------------------------------------------------------------------
Proc ApiEntry far

	cmp	bx, MAX_API		; is the function a valid value?
	ja	badAPI			; not valid

	push	ds			; save caller ds
	push	cs
	pop	ds			; ds = cs

	shl	bx, 1			; value times 2
	call	[APITable+bx]		; call the function

	pop	ds			; restore caller ds

	ret

badAPI:
	mov	ax, -1
	ret

endp

;--------------------------------------------------------------------
; AIGetInfo
;
; Returns current settings and information from the ROM.
;
; Parameters:
;	none
;
; Returns:
;	es:di - pointer to Info structure
;--------------------------------------------------------------------
Proc AIGetInfo

	push	ax			; save ax
	push	si			; save si

	push	ds
	pop	es			; es = ds

	mov	[RomInfo.Ver], 2	; version of ROM info structure

	mov	ax, [BWTable.RomVer]
	mov	[RomInfo.RomVer], ax	; set ROM version

	mov	ax, [BWTable.RomType]
	mov	[RomInfo.RomType], ax	; set ROM type

	mov	[RomInfo.MaxFrame], 1500

	xor	ax, ax
;	mov	al, [BWTable.LANOS]
	mov	[RomInfo.BootPro], ax	; set current boot protocol

	mov	di, offset RomInfo.NetAddress
	mov	si, offset NetAddress	; get offset of our network address
	movsw				; copy network address
	movsw
	movsw

	mov	ax, [LocalIP]		; copy local IP address
	mov	[RomInfo.LocalIP], ax
	mov	ax, [LocalIP+2]
	mov	[(RomInfo.LocalIP)+2], ax

	mov	ax, [ServerIP]		; copy server IP address
	mov	[RomInfo.ServerIP], ax
	mov	ax, [ServerIP+2]
	mov	[(RomInfo.ServerIP)+2], ax

	mov	[RomInfo.BOOTPPkt], offset BootPkt
	mov	[(RomInfo.BOOTPPkt)+2], cs

ifdef GOLIATH
	mov	[RomInfo.DiscoverPkt], offset DiscoverPkt
	mov	[(RomInfo.DiscoverPkt)+2], cs

	mov	[RomInfo.BINLPkt], offset BINLPkt
	mov	[(RomInfo.BINLPkt)+2], cs
endif ;GOLIATH

	mov	di, offset RomInfo	; return offset of structure

	pop	si			; restore si
	pop	ax			; restore ax
	ret

endp

;--------------------------------------------------------------------
; AIDisengage
;
; Shuts down the adapter.  Simply calls NADDisengage to do the work.
;
; Parameters:
;	none
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc AIDisengage

	; close the adapter
	mov	di, offset CallBuff
	mov	bx, UNDI_CLOSE
	call	[UNDI]			; call UNDI_CLOSE

	; shutdown the adapter
	mov	di, offset CallBuff
	mov	bx, UNDI_SHUTDOWN
	call	[UNDI]			; call UNDI_SHUTDOWN

	; shutdown the adapter
	mov	di, offset CallBuff
	mov	bx, UNDI_CLEANUP
	call	[UNDI]			; call UNDI_CLEANUP

	mov	[word ID], 0		; kill our API ID string
	ret

endp

;--------------------------------------------------------------------
; AIDisengageNW
;
; Special disengage function used with NetWare.  Removes the UNDI
; without shutting down the adapter.
;
; Parameters:
;	none
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc AIDisengageNW

	; shutdown the adapter
	mov	di, offset CallBuff
	mov	bx, UNDI_CLEANUP
	call	[UNDI]			; call UNDI_CLEANUP

	mov	[word ID], 0		; kill our API ID string
	ret

endp

;--------------------------------------------------------------------
; AISetCallBack
;
; Returns current settings and information from the ROM.
;
; Parameters:
;	none
;
; Returns:
;	es:di - pointer to call back function
;--------------------------------------------------------------------
Proc AISetCallBack

	cmp	cx, -1			; are we clearing callbacks?
	jne	notClearing

	mov	[word ptr CallBackRaw], 0
	mov	[word ptr CallBackIP], 0
	mov	[word ptr CallBackUDP], 0
	ret

notClearing:
	cmp	cx, 1			; are we setting a raw call back?
	jne	notRaw			; no

	mov	[word ptr CallBackRaw], di
	mov	[word ptr CallBackRaw+2], es
	jmp	setCallBackExit

notRaw:
	cmp	cx, 2			; are we setting an IP call back?
	jne	notIP			; no

	mov	[word ptr CallBackIP], di
	mov	[word ptr CallBackIP+2], es
	jmp	setCallBackExit

notIP:
	cmp	cx, 3			; are we setting a UDP call back?
	jne	notUDP			; no

	mov	[word ptr CallBackUDP], di
	mov	[word ptr CallBackUDP+2], es
	xchg	dl, dh			; flip bytes into network order
	mov	[ListenPort], dx	; save listening port

notUDP:
setCallBackExit:
	ret

endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
Proc AIChangeRxMask

	mov	bx, ax			; move bit mask into bx for NAD
	call	AIChangeReceiveMask
	ret

endp

;--------------------------------------------------------------------
; AITransmitRaw
;
; Exportable version of Transmit.
;
; Parameters:
;	es:di - pointer to complete packet
;	cx - packet length
;
; Returns:
;	ax - transmit status
;--------------------------------------------------------------------
Proc AITransmitRaw

	pusha				; save everything
	push	es			; save es

	mov	[TxData0.Len], cx	; set data lenght
	mov	[TxData0.Off], di	; set data offset
	mov	[TxData0.Seg], es	; set data segment

	mov	ax, cs
	mov	es, ax			; es = cs

	mov	[TxTBD.DataBlkCount], 1	; set number of data blocks

	mov	di, offset TxData 	; get pointer to transmit structure
	mov	bx, UNDI_TRANSMIT
	call	[UNDI]			; transmit the packet

	pop	es			; restore es
	popa				; restore everything

	mov	ax, [TxData.Status]	; get any returned error code
	ret

endp

;--------------------------------------------------------------------
; AITransmitPkt
;
; Exportable version of Transmit.
;
; Parameters:
;	es:di - pointer to TxPkt structure
;
; Returns:
;	ax - transmit status
;--------------------------------------------------------------------
Proc AITransmitPkt

	cmp	[(TxPktStruct es:di).Size], size TxPktStruct
	je	@@sizeOK
	mov	ax, -1
	ret

@@sizeOK:

	pusha				; save everything
	push	es			; save es

	; Setup data block 1 to supplied data.
	mov	ax, [(TxPktStruct es:di).Length]
	mov	[TxData1.Len], ax		; set the length of the data
	mov	ax, [(word ptr (TxPktStruct es:di).Data)]
	mov	[TxData1.Off], ax		; set the offset of the data
	mov	ax, [(word ptr (TxPktStruct es:di).Data)+2]
	mov	[TxData1.Seg], ax		; set the segment of the data

	;----------------------------------------
	; Build MAC destination address
	;----------------------------------------
	mov	[TxData0.Len], 14
	mov	[TxData0.Off], offset MACHeader
	mov	[TxData0.Seg], ds

	push	ds

	lea	si, [(TxPktStruct es:di).Address]

	push	es
	push	ds
	pop	es			; es = our segment
	pop	ds			; ds = caller segment

	mov	di, offset MACHeader
	movsw				; set destination address
	movsw
	movsw

	pop	ds			; restore our ds

	mov	si, offset NetAddress	; source address is us
	movsw
	movsw
	movsw

	mov	ax, [TxData1.Len]
	xchg	al, ah
	stosw				; set type/lenght field

	mov	[TxTBD.DataBlkCount], 2	; set number of data blocks

	mov	di, offset TxData 	; get pointer to transmit structure
	mov	bx, UNDI_TRANSMIT
	call	[UNDI]			; transmit the packet

	pop	es			; restore es
	popa				; restore everything

	mov	ax, [TxData.Status]	; get any returned error code
	ret

endp

;--------------------------------------------------------------------
; AITransmitIP
;
; IP layer transmit packet.
;
; Parameters:
;	es:di - pointer to TxIP structure
;
; Returns:
;	ax - transmit status
;--------------------------------------------------------------------
Proc AITransmitIP

	cmp	[(TxIPStruct es:di).Size], size TxIPStruct
	je	@@sizeOK
	mov	ax, -1
	ret

@@sizeOK:
	pusha				; save everything
	push	es			; save es

	; Setup data block 2 to supplied data.
	mov	ax, [(TxIPStruct es:di).Length]
	mov	[TxData2.Len], ax		; set the length of the data
	mov	ax, [(word ptr (TxIPStruct es:di).Data)]
	mov	[TxData2.Off], ax		; set the offset of the data
	mov	ax, [(word ptr (TxIPStruct es:di).Data)+2]
	mov	[TxData2.Seg], ax		; set the segment of the data

	;----------------------------------------
	; Build the IP header.
	;----------------------------------------
	mov	ax, [word ptr (TxIPStruct es:di).Address]
	mov	dx, [word ptr ((TxIPStruct es:di).Address)+2]
	mov	bl, [(TxIPStruct es:di).Protocol]
	mov	cx, [(TxIPStruct es:di).Length]
	call	BuildHeaderIP		; build the IP header

	;----------------------------------------
	; Build the MAC header.
	;----------------------------------------
	mov	eax, [(TxIPStruct es:di).Gateway]
	cmp	eax, 0			; is there a gateway IP address?
	jne	haveGW			; yes, use it

	mov	eax, [(TxIPStruct es:di).Address]
haveGW:
	call	BuildHeaderMAC		; build the MAC header
	je	@@skip

	pop	es			; restore es
	popa				; restore everything
	mov	ax, [LastError]		; return the error code
	ret

@@skip:
	;----------------------------------------
	; Build the transmit structure
	;----------------------------------------
	mov	[TxTBD.DataBlkCount], 3	; set number of data blocks

	; data block 0 is MAC header.
	mov	[TxData0.Len], 14
	mov	[TxData0.Off], offset MACHeader
	mov	[TxData0.Seg], ds

	; fragment 1 is IP header.
	mov	[TxData1.Len], size IP
	mov	[TxData1.Off], offset IPHdr
	mov	[TxData1.Seg], ds

	mov	di, offset TxData 	; get pointer to transmit structure
	mov	bx, UNDI_TRANSMIT
	call	[UNDI]			; transmit the packet

	pop	es			; restore es
	popa				; restore everything

	mov	ax, [TxData.Status]	; get any returned error code
	ret

endp

;--------------------------------------------------------------------
; AITransmitUDP
;
; Transmit packet for UDP layer.
;
; Parameters:
;	es:di - pointer to TxUDP structure
;
; Returns:
;	ax - transmit status
;--------------------------------------------------------------------
Proc AITransmitUDP

	cmp	[(TxUDPStruct es:di).Size], size TxUDPStruct
	je	@@sizeOK
	mov	ax, -1
	ret

@@sizeOK:
	pusha				; save everything
	push	es			; save es

	;----------------------------------------
	; Setup data block 2 to supplied data.
	;----------------------------------------
	mov	ax, [(TxUDPStruct es:di).Length]
	mov	[TxData2.Len], ax
	mov	ax, [(TxUDPStruct es:di).Data]
	mov	[TxData2.Off], ax
	mov	ax, [((TxUDPStruct es:di).Data)+2]
	mov	[TxData2.Seg], ax

	;----------------------------------------
	; Build the IP header.
	;----------------------------------------
	mov	ax, [word ptr (TxUDPStruct es:di).Address]
	mov	dx, [word ptr ((TxUDPStruct es:di).Address)+2]
	mov	bl, 17			; protocol is UDP
	mov	cx, [(TxUDPStruct es:di).Length]
	add	cx, size UDP		; add UDP header size
	call	BuildHeaderIP		; build the IP header

	;----------------------------------------
	; Build the UDP header.
	;----------------------------------------
	mov	ax, [(TxUDPStruct es:di).SourcePort]
	xchg	al, ah			; flip bytes
	mov	[UDPHdr.SourcePort], ax
	mov	ax, [(TxUDPStruct es:di).DestPort]
	xchg	al, ah			; flip bytes
	mov	[UDPHdr.DestPort], ax
	mov	ax, [(TxUDPStruct es:di).Length]
	add	ax, size UDP		; add UDP header size
	xchg	al, ah			; flip bytes
	mov	[UDPHdr.Len], ax
	mov	[UDPHdr.Sum], 0

	call	CalcUDPSum
	mov	[UDPHdr.Sum], ax	; save sum in header

	;----------------------------------------
	; Build the MAC header.
	;----------------------------------------
	mov	eax, [(TxUDPStruct es:di).Gateway]
	cmp	eax, 0			; is there a gateway IP address?
	jne	haveGW2			; yes, use it

	mov	eax, [(TxUDPStruct es:di).Address]

haveGW2:
	call	BuildHeaderMAC		; build the MAC header
	je	@@skip

	pop	es			; restore es
	popa				; restore everything
	mov	ax, [LastError]		; return the error code
	ret

@@skip:
	;----------------------------------------
	; Build the transmit structure
	;----------------------------------------
	mov	[TxTBD.DataBlkCount], 3	; set number of data blocks

	; data block 0 is MAC header.
	mov	[TxData0.Len], 14
	mov	[TxData0.Off], offset MACHeader
	mov	[TxData0.Seg], ds

	; data block 1 is IP header & UDP header.
	mov	[TxData1.Len], size IP + size UDP
	mov	[TxData1.Off], offset IPHdr
	mov	[TxData1.Seg], ds

	mov	di, offset TxData 	; get pointer to transmit structure
	mov	bx, UNDI_TRANSMIT
	call	[UNDI]			; transmit the packet

	pop	es			; restore es
	popa				; restore everything

	mov	ax, [TxData.Status]	; get any returned error code
	ret

endp

;--------------------------------------------------------------------
; CalcUdpSum
;
; Calculates checksum for UDP header.
;
; Parmeters:
;	es:di - pointer to TxUDP structure
;
; Returns:
;	ax	- sum
;--------------------------------------------------------------------
Proc CalcUdpSum

	xor	bx, bx			; sum = 0, carry clear

	;------------------------------------------------------------
	; Add items in the IP header.
	;------------------------------------------------------------
	mov	ah, [IPHdr.Protocol]	; get IP protocol byte
	mov	al, 0
	adc	bx, ax

	; add IP source and destination address values
	adc	bx, [IPHdr.SourceIP]
	adc	bx, [(IPHdr.SourceIP)+2]
	adc	bx, [IPHdr.DestIP]
	adc	bx, [(IPHdr.DestIP)+2]

	;------------------------------------------------------------
	; Add the UDP header.
	;------------------------------------------------------------
	adc	bx, [UDPHdr.Len]	; add value of UDP length

	mov	si, offset UDPHdr	; add all the items in UDP
	mov	cx, (size UDP)/2

sumLoop2:
	lodsw
	adc	bx, ax
	loop	sumLoop2

	;------------------------------------------------------------
	; Add all the words in data buffer.
	;------------------------------------------------------------
	push	ds			; save our ds

	lds	si, [dword ptr (TxUDPStruct es:di).Data]
	mov	cx, [(TxUDPStruct es:di).Length]
	mov	dx, cx			; save length in dx

	pushf				; save flags (carry)
	shr	cx, 1			; change to word count
	popf				; restore flags

sumLoop3:
	lodsw
	adc	bx, ax
	loop	sumLoop3

	adc	bx, 0			; add the carry bit
					; (the next test will clear carry)
	test	dx, 1			; was size odd number?
	je	size_even		; no - it's even

	lodsb				; get last byte
	mov	ah, 0			; change to word
	adc	bx, ax			; add last value

size_even:
	pop	ds			; restore our ds

	adc	bx, 0			; add the last carry bit
	not	bx			; do 1's complement

	or	bx, bx			; was the result 0?
	jne	sumNot0

	not	bx			; change sum to -1

sumNot0:
	mov	ax, bx
	ret				 ; ax has sum

endp

;--------------------------------------------------------------------
; BuildHeaderIP
;
; Builds an IP header.
;
; Parameters:
;	ax:dx - destination IP address
;	bl - IP protocol
;	cx - length of data
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc BuildHeaderIP

	;----------------------------------------
	; Build IP header
	;----------------------------------------
	mov	[IPHdr.Ver], 45h	; set version
	mov	[IPHdr.Type], 0		; set type
	mov	[IPHdr.FragOffSet], 0	; set fragment offset to 0
	mov	[IPHdr.Time], 60	; set time-to-live

	mov	[IPHdr.Protocol], bl	; set protocol

	add	cx, size IP		; add IP header size to length
	xchg	cl, ch			; flip words
	mov	[IPHdr.Len], cx		; set length

	mov	[IPHdr.DestIP], ax
	mov	[(IPHdr.DestIP)+2], dx	; set destination IP address

	mov	ax, [LocalIP]
	mov	[IPHdr.SourceIP], ax	; set source IP address
	mov	ax, [LocalIP+2]
	mov	[(IPHdr.SourceIP)+2], ax

	inc	[Ident]
	mov	ax, [Ident]		; get current identification
	xchg	al, ah			; flip words
	mov	[IPHdr.Ident], ax	; set identification

	;------------------------------------------------------------
	; Calc checksum of IP header.
	;------------------------------------------------------------
	mov	cx, (size IP)/2
	xor	ax, ax			; clear sum
	mov	[IPHdr.CheckSum], ax	; clear checksum

	mov	bx, offset IPHdr	; get location of IP header

ip_sum_loop:
	adc	ax, [bx]
	inc	bx
	inc	bx
	loop	ip_sum_loop

	adc	ax, 0			; add carry bit
	not	ax
	mov	[IPHdr.CheckSum], ax	; save checksum in packet

	ret

endp

;--------------------------------------------------------------------
; BuildHeaderMAC
;
; Builds a MAC header.
;
; Parameters:
;	ax:dx - destination IP address
;	bl - IP protocol
;	cx - length of data
;
; Returns:
;	ax - status (0 = OK)
;--------------------------------------------------------------------
Proc BuildHeaderMAC

	; resolve the IP address into a physical address
	call	ResolveIP		; get the physical address from IP
	or	si, si			; did we get an address?
	jne	resolvedIP		; yes

	; we were unable to resolve the IP address, so return an error
	mov	ax, ERROR_UNKNOWNIP	; return error message
	or	ax, ax
	jmp	@@exit

resolvedIP:
	push	ds
	pop	es			; es = ds

	; set MAC destination address
	mov	di, offset MACHeader
	movsw
	movsw
	movsw

	; set MAC source address
	mov	si, offset NetAddress
	movsw
	movsw
	movsw

	; set packet type
	mov	ax, 8
	stosw

	xor	ax, ax			; return "no error"

@@exit:
	mov	[LastError], ax
	ret

endp

;--------------------------------------------------------------------
; AIReceive
;
; Exportable version of Receive.
;
; Parameters:
;	es:di - pointer for complete packet
;	cx - max packet size
;
; Returns:
;	ax - received packet size
;--------------------------------------------------------------------
Proc AIReceive

	push	si			; save si
	push	di			; save di
	push	cx			; save cx

	push	di
	push	es
	call	CheckRxBuffer		; check for available data
	pop	es
	pop	di
	je	noData			; no data available

	mov	cx, ax			; move size to cx
	mov	si, [RxBuffer]		; get address of receive buffer

	rep	movsb			; copy data into caller buffer

	mov	[BufferSize], 0		; free our buffer

noData:
	pop	cx			; restore cx
	pop	di			; restore di
	pop	si			; restore si
	ret

endp

;====================================================================
;			Receive functions
;====================================================================

;----------------------------------------------------------------------
; RxInt
;
; Receive interrupt, called by UNDI when a packet is received.
;
; Parameters:
;	ax - length of media header
;	bl - protocol
;	bh - receive flag
;	cx - length of data
;	es:di - pointer to received buffer
;
; Returns:
;	ax = SUCCESS - packet processed
;	   = DELAY - packet not processed, keep it
;----------------------------------------------------------------------
Proc RxInt far

	pusha				; save everything
	push	ds			; save caller ds

	push	cs
	pop	ds			; ds = cs

	push	di			; save di
	push	cx			; save cx
	call	CheckCallBack		; check for a callback function
	pop	cx			; restore cx
	pop	di			; restore di
	jc	didCallback		; callback was called

	; a callback was not done, so we save the packet in our buffer,
	; but we can only save one packet
	cmp	[BufferSize], 0		; is there a packet in the buffer?
	je	bufferEmpty		; no, it's empty

	; we can't handle the packet now, so tell the UNDI to delay it
	pop	ds			; restore caller ds
	popa				; restore everything else
	mov	ax, DELAY		; return "delay"
	ret

bufferEmpty:
	mov	[BufferSize], cx	; save packet size

	push	es			; save es

	mov	si, di			; move source adddress to si
	mov	di, [RxBuffer]		; get address of receive buffer

	push	ds
	push	es
	pop	ds			; ds = packet segment
	pop	es			; es = our segment

	rep	movsb			; copy packet into RxBuffer

	pop	es			; restore es

didCallback:
	pop	ds			; restore caller ds
	popa				; restore everything
	mov	ax, SUCCESS		; return success
	ret

endp

;--------------------------------------------------------------------
; CheckCallBack
;
; Parameters:
;	es:di - received packet buffer
;	cs - packet length
;
; Returns:
;	carry set if callback done
;--------------------------------------------------------------------
Proc CheckCallBack

	mov	ax, [word ptr es:di+12]	; get packet type value

	cmp	ax, 0608h		; check for an ARP
	jne	noARP			; not an ARP packet

	call	ArpCallback		; process the ARP
	jnc	noARP			; ARP was not processed

	ret

noARP:
	cmp	[NoCallbacks], 0	; are call backs allowed?
	jne	noRawCallBack		; skip the callbacks

	cmp	ax, 8			; check for IP type code
	jne	noIPCallBack		; not an IP packet

	cmp	[word ptr CallBackUDP], 0; is there a UDP callback?
	je	noDUPCallBack		; no

	add	di, 14 + 20		; skip MAC and IP header
	mov	ax, [ListenPort]	; get our listening port
	cmp	[word ptr di+2], ax	; check if destination is our port
	jne	noDUPCallBack		; not on our port

	mov	cx, [word ptr di+4]	; get data length
	sub	cx, 8			; subtrack header size
	mov	ax, [word ptr di]	; get source port
	add	di, 8			; skip UDP header
	call	[CallBackUDP]		; do UDP call back
	stc				; set carry (callback done)
	ret

noDUPCallBack:
	cmp	[word ptr CallBackIP], 0; is a call back set for IP?
	je	noIPCallBack		; no

	sub	cx, 14+20		; subtrack header sizes
	add	di, 14+20		; skip MAC header and IP header
	call	[CallBackIP]		; do raw call back
	stc				; set carry (callback done)
	ret

noIPCallBack:
	cmp	[word ptr CallBackRaw], 0; is a call back set for raw?
	je	noRawCallBack		; no

	call	[CallBackRaw]		; do raw call back
	stc				; set carry (callback done)
	ret

noRawCallBack:
	clc				; clear carry - no callback
	ret

endp

;--------------------------------------------------------------------
; CheckRxBuffer
;
; Checks for data in the receive buffer.
;
; Parameters:
;	none
;
; Returns:
;	ax - received packet size
;	si - buffer address
;--------------------------------------------------------------------
Proc CheckRxBuffer

	cmp	[BufferSize], 0		; is there data in the buffer?
	jne	gotData			; buffer has data

	mov	di, offset CallBuff
	mov	bx, UNDI_FORCE_INTERRUPT
	call	[UNDI]			; call UNDI_FORCE_INTERRUPT

gotData:
	mov	ax, [BufferSize]
	mov	si, [RxBuffer]		; get address of receive buffer
	or	ax, ax
	ret

endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
Proc AIPoll

	pusha

	mov	di, offset CallBuff
	mov	bx, UNDI_FORCE_INTERRUPT
	call	[UNDI]			; call UNDI_FORCE_INTERRUPT

	popa
	ret

endp

;--------------------------------------------------------------------

include "ai_arp.asm"
include "ai_tftp.asm"

public _AIEnd
label _AIEnd

END_CODE

;====================================================================

START_SPARSE

public	_AIStartSparse
label _AIStartSparse

even
TxData		S_UNDI_TRANSMIT <?>
TxTBD		UNDI_TBD	<?>
TxData0		DATABLK		<?>
TxData1		DATABLK		<?>
TxData2		DATABLK		<?>

MACHeader	db	20 dup (?)	; transmit MAC header
IPHdr		IP	<?>	; transmit IP header
UDPHdr		UDP	<?>	; transmit UDP header

RomInfo		AIINFOStruct	<?>

NetAddress	dw	?, ?, ?	; our network address

StartTime	dw	?
Retrys		db	?

NIC_IRQ 	db	?	; adapter IRQ
NIC_IO		dw	?	; adapter I/O base

BufferSize	dw	?
RxBuffer	dw	?
TxBuffer	db	512 dup (?)

CallBuff	db	64 dup (?)

public	_AIEndSparse
label _AIEndSparse

END_SPARSE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\pxe\pxe.asm ===
;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------
ideal
_IDEAL_ = 1

include "..\include\drvseg.inc"
include "..\include\ai.inc"

include "pxe_api.inc"
include "udp_api.inc"
include "tftp_api.inc"
include "undi_api.inc"

extrn PCIDevice:word
extrn PCIVendor:word
extrn PCIBusDevFunc:word
extrn NIC_IO:word
extrn NIC_IRQ:byte
extrn NetAddress:word
extrn RxBuffer:byte

START_CODE
P386

public	SetupPreboot

BWAPI		dd	0
OldInt1A	dd	0

PXE		db 'PXENV+'

PXEPtr		dd	0

UNDI		dw	0
UNDISeg		dw	0

align 16
PxeEntry	s_pxenv_entry <>

;--------------------------------------------------------------------
; SetupPreboot
;
; Parameters:
;	bx - pointer to BootWare AI API table
;	dx - UNDI segment (if 0 then no UNDI available)
;
;--------------------------------------------------------------------
Proc SetupPreboot

	mov	[UNDISeg], dx		; save UNDI segment

	mov	eax, [bx]		; get address of BootWare API
	mov	[BWAPI], eax

	push	cs
	pop	es			; es = current

	;------------------------------------------------------------
	; Fill in values of structure.
	;------------------------------------------------------------
	mov	si, offset PXE
	lea	di, [PxeEntry.signature]
	movsw
	movsw
	movsw

	mov	[PxeEntry.ver], 98
	mov	[PxeEntry.bytes], size PxeEntry

	mov	[PxeEntry.rm_entry_seg], cs
	mov	[PxeEntry.rm_entry_off], offset ApiEntry

	xor	bx, bx			; clear sum
	mov	cx, size PxeEntry	; size of structure
	mov	si, offset PxeEntry

sumLoop:
	add	bl, [byte ptr si]
	inc	si
	loop	sumLoop

	sub	[PxeEntry.checksum], bl	; set structure sum

	;------------------------------------------------------------
	; hook INT1A to us.
	;------------------------------------------------------------
	push	0
	pop	es			; es = 0

	mov	ax, offset Int1A	; our INT 1A offset
	xchg	ax, [es:1Ah*4]		; get/set INT 1A offset
	mov	[word ptr OldInt1A], ax ; save original offset

	mov	ax, cs
	xchg	ax, [es:(1Ah*4)+2]	; get/set INT 1A segment
	mov	[word ptr OldInt1A+2], ax	; save original segment

	ret

endp

;--------------------------------------------------------------------
; Int1A
;
;--------------------------------------------------------------------
Proc Int1A far

	cmp	ax, 5650h		; is this a PXE request?
	je	doPXE			; yes

	jmp	[cs:OldInt1A]		; clain to old int1A

doPXE:
	push	cs
	pop	es			; es = current segment
	mov	bx, offset PxeEntry	; es:bx is offset to structure

	; We need to return with carry cleared, but the iret will restore
	; the flags from the stack, so lets pull it off the stack, set the
	; carry and put it back so iret can return correctly.  To make
	; matters worse the flags are hidden behind the return address so
	; we must remove and restore them as well.
	pop	ax
	pop	dx
	popf				; get calls flags
	clc				; clear carry
	pushf				; replace the flags
	push	dx
	push	ax

	; return edx = physical address of structure
	xor	edx, edx
	xor	eax, eax
	mov	dx, cs
	shl	edx, 4
	mov	ax, offset PxeEntry	; physical address of structure
	add	edx, eax

	mov	ax, 564Eh		; return code

	iret				; we are done

endp


;--------------------------------------------------------------------
; ApiEntry
;
;--------------------------------------------------------------------
Proc ApiEntry far

	; If we have an UNDI, and the function being called is an UNDI
	; function, then call the UNDI to handle the function.
	cmp	[cs:UNDISeg], 0		; do we have an UNDI?
	je	noUNDI			; no

	cmp	bx, 1Fh			; is this an UNDI function call?
	ja	noUNDI			; no

	call	[dword ptr cs:UNDI]	; call UNDI
	ret

noUNDI:
	push	ds			; save caller ds
	push	bx
	push	cx
	push	dx
	push	si

	push	cs
	pop	ds			; ds = cs

	; Store pointer to the PXE structure.
	mov	[word ptr PxePtr], di
	mov	[word ptr PxePtr+2], es

	xor	si, si

apiLoop:
	mov	ax, [JmpTable+si]
	cmp	ax, 0			; are we at the end of the table?
	je	tableEnd		; yes

	cmp	ax, bx			; found our function?
	je	foundEntry		; yes

	add	si, 4
	jmp	apiLoop

foundEntry:
	call	[JmpTable+si+2]
	jmp	exit

tableEnd:
	mov	ax, PXENV_STATUS_UNSUPPORTED

exit:
	les	di, [PxePtr]		; reload PXE pointer

	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ds

	mov	[es:di], ax		; set return status

	cmp	ax, PXENV_STATUS_SUCCESS; were we succesfull?
	jne	error			; no

	mov	ax, PXENV_EXIT_SUCCESS	; return success
	clc				; clear carry for success
	ret

error:
	mov	ax, PXENV_EXIT_FAILURE	; return error
	stc				; set carry to error
	ret

endp

even
JmpTable	dw	PXENV_GET_BINL_INFO, GetBinlInfo
		dw	PXENV_UNDI_GET_INFORMATION, UndiGetInfo
		dw	PXENV_UNDI_GET_NIC_TYPE, UndiGetNicType
		dw	PXENV_UDP_OPEN, UDPopen
		dw	PXENV_UDP_WRITE, UDPwrite
		dw	PXENV_UDP_READ, UDPread
		dw	PXENV_UDP_CLOSE, UDPclose
		dw	PXENV_TFTP_READ_FILE, TFTPReadFile
		dw	73h, TFTPRestart
		dw	0, 0

;--------------------------------------------------------------------
; GetBinlInfo
;
; Parameters:
;	es:di = pointer to PXENV_GET_BINL_INFO structure
;
;--------------------------------------------------------------------
Proc GetBinlInfo

	mov	ax, [(s_PXENV_GET_BINL_INFO es:di).PacketType]

	push	es
	push	di			; save "GetBinlInfo" pointer

	mov	bx, BW_GETINFO
	call	[BWAPI]			; call BWAPI "GetInfo"

	lea	si, [(AIINFOStruct es:di).DiscoverPkt]
	cmp	ax, 1			; do they want the discover packet?
	je	gotIt			; yes

	lea	si, [(AIINFOStruct es:di).BOOTPPkt]
	cmp	ax, 2			; do they want the ACK packet?
	je	gotIt			; yes

	lea	si, [(AIINFOStruct es:di).BINLPkt]

gotIt:
	mov	ax, [es:si]
	mov	bx, [(es:si)+2]

	pop	di
	pop	es			; restore BINL structure

	; If size and address is NULL then we return the address and
	; size of our buffer.
	mov	cx, [(s_PXENV_GET_BINL_INFO es:di).BufferSize]
	or	cx, [(s_PXENV_GET_BINL_INFO es:di).BufferOffset]
	or	cx, [(s_PXENV_GET_BINL_INFO es:di).BufferSegment]
	jne	hasBuffer

	; set address to our buffer
	mov	[(s_PXENV_GET_BINL_INFO es:di).BufferOffset], ax
	mov	[(s_PXENV_GET_BINL_INFO es:di).BufferSegment], bx
	jmp	getInfoExit

hasBuffer:
	cmp	[(s_PXENV_GET_BINL_INFO es:di).BufferSize], 0
	je	getInfoExit

	push	es
	push	di
	push	ds

	; A buffer is specified, so copy the packet into it.
	mov	si, ax
	push	bx
	pop	ds			; ds:si is source address

	les	di, [dword ptr ((s_PXENV_GET_BINL_INFO es:di).BufferOffset)]
	mov	cx, 512
	rep	movsb			; copy data into buffer

	pop	ds			; restore ds
	pop	di
	pop	es

getInfoExit:
	mov	[(s_PXENV_GET_BINL_INFO es:di).BufferSize], 512

	mov	ax, PXENV_STATUS_SUCCESS
	ret

endp

;--------------------------------------------------------------------
; UndiGetInfo
;
; Parameters:
;	es:di = pointer to PXENV_UNDI_GET_INFORMATION structure
;
;--------------------------------------------------------------------
Proc UndiGetInfo

	mov	ax, [NIC_IO]
	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).BaseIo], ax

	mov	al, [NIC_IRQ]
	xor	ah, ah
	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).IntNumber], ax

	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).MaxTranUnit], 1500
	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).HwType], ETHER_TYPE
	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).HwAddrLen], 6

	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).RomAddress], 0

	mov	bx, di
	mov	cx, 6
	mov	si, offset NetAddress
	lea	di, [(s_PXENV_UNDI_GET_INFORMATION es:di).CurrentNodeAddress]
	rep	movsb

	mov	cx, 6
	mov	si, offset NetAddress
	lea	di, [(s_PXENV_UNDI_GET_INFORMATION es:bx).PermNodeAddress]
	rep	movsb

	mov	di, bx
	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).RxBufCt], 5
	mov	[(s_PXENV_UNDI_GET_INFORMATION es:di).TxBufCt], 1

	mov	ax, PXENV_STATUS_SUCCESS
	ret

endp

;--------------------------------------------------------------------
; UndiGetNicType
;
; Parameters:
;	es:di = pointer to PXENV_UNDI_GET_NIC_TYPE structure
;
;--------------------------------------------------------------------
Proc UndiGetNicType

	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).NicType], 2

	mov	ax, [PCIVendor]		; get vendor ID
	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).Vendor_ID], ax

	mov	ax, [PCIDevice]		; get device ID
	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).Dev_ID], ax

	mov	ax, [PCIBusDevFunc]	; get Bus/Device/Function numbers
	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).BusDevFunc], ax

	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).Base_Class], 2
	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).Sub_Class], 0
	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).Prog_Intf], 0
	mov	[(s_PXENV_UNDI_GET_NIC_TYPE_PCI es:di).Rev], 0

	mov	ax, PXENV_STATUS_SUCCESS
	ret


endp

include "tftp.asm"
include "udp.asm"

END_CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\pxe\udp.asm ===
;--------------------------------------------------------------------
; UDPopen
;
;--------------------------------------------------------------------
Proc UDPopen

	mov	bx, BW_GETINFO		; Call BootWare to get info for us.
	call	[BWAPI]

	mov	eax, [dword ptr (AIINFOStruct es:di).LocalIP]
	les	di, [PxePtr]		; Get a pointer to PXE structure.
	mov	[(s_pxenv_udp_open es:di).src_ip], eax

	mov	ax, PXENV_STATUS_SUCCESS; return success
	ret
endp

;--------------------------------------------------------------------
; UDPclose
;
; A useless function that does nothing!
;--------------------------------------------------------------------
Proc UDPclose

	mov	ax, PXENV_STATUS_SUCCESS; return success
	ret

endp

;--------------------------------------------------------------------
; UDPread
;
;--------------------------------------------------------------------
; Casting structure for dealing with UDP/IP packets.
struc   s_RxPacket
        MACheader    db 14 dup (0)      ; ethernet address, ...
        IPdummy1     db 02 dup (0)      ; version, header length, TOS
        IPlength     dw 00              ; total length (IP+UDP+Data)
        IPdummy2     db 05 dup (0)      ; identification, flags, fragment, TTL
        IPprotocol   db 00              ; protocol number following
        IPchecksum   dw 00              ; 16-bit IP header checksum
        IPsourceip   dd 00              ; source IP address
        IPdestip     dd 00              ; destination IP address
        ;-------------------------------------------------------
        UDPsource    dw 00              ; source port number
        UDPdest      dw 00              ; destination port number
        UDPlength    dw 00              ; length
        UDPchecksum  dw 00              ; 16-bit UDP header checksum
ends

Proc    UDPread

; American ;
;  Arium   ;
;db 0F1h

	; Get a full packet.
	mov	bx, BW_RECEIVE
	push	ds

	pop	es			; es = ds
	mov	di, offset RxBuffer
	mov	cx, 1500
	call	[BWAPI]			; Call ReceivePacket function.

	cmp	ax, 0			; did we get a packet?
        je      noPacket

	;------------------------------------------------------------
	; We got a packet
	;------------------------------------------------------------

	; Check for a UDP protocol packet.
	cmp	[(s_RxPacket RxBuffer).IPprotocol], 17  ; 11h
        jne     noPacket                ; not a UDP packet

	les	di, [PxePtr]		; get pointer to PXE structure.

	; Check if caller specified a destination IP address, if so
	; we only accept packets sent to that address.
	mov	eax, [(s_pxenv_udp_read es:di).dest_ip]
	cmp	eax, 0			; is an address specified?
	je	acceptANYip		; no - accept any address

	; check specified address with received packet
	cmp	eax, [(s_RxPacket RxBuffer).IPdestip]
	je	ipOK			; address match, keep it
        jmp     noPacket                ; nope, no match

acceptANYip:
	; copy destination IP address into UDPRead structure
	mov	eax, [(s_RxPacket RxBuffer).IPdestip]
	mov	[(s_pxenv_udp_read es:di).dest_ip], eax

ipOK:
	; Check if caller specified a destination UDP port, if so
	; we only accept packets sent to that port.
	mov	ax, [(s_pxenv_udp_read es:di).d_port]
	cmp	ax, 0			; was a port specified?
	je	acceptANYudp		; no - accept all packets

	; check specified port with received packet
	cmp	[(s_RxPacket RxBuffer).UDPdest], ax
	je	portOK			; ports match
        jmp     noPacket

acceptANYudp:
	; packets from any port are wanted, so copy the port number
	mov	ax, [(s_RxPacket RxBuffer).UDPdest]
	mov	[(s_pxenv_udp_read es:di).d_port], ax

portOK:
	; copy the senders IP address into UDPRead structure
	mov	eax, [(s_RxPacket RxBuffer).IPsourceip]
	mov	[(s_pxenv_udp_read es:di).src_ip], eax

	; copy the source port number into UDPRead structure
	mov	ax, [(s_RxPacket RxBuffer).UDPsource]
	mov	[(s_pxenv_udp_read es:di).s_port], ax

	; copy packet length into UDPRead structure
	mov	ax, [(s_RxPacket RxBuffer).IPlength]
	xchg	al, ah
	sub	ax, 20 + 8		; subtract IP and UDP header sizes
	mov	[(s_pxenv_udp_read es:di).buffer_size], ax

	; copy the packet into the supplied buffer
	mov	si, offset RxBuffer
	add	si, 14 + 20 + 8		; skip MAC, IP & UDP headers
	mov	bx, [(s_pxenv_udp_read es:di).buffer_seg]
	mov	di, [(s_pxenv_udp_read es:di).buffer_off]
	mov	es, bx
	mov	cx, ax
	rep	movsb			; copy the packet data.

	mov	ax, PXENV_STATUS_SUCCESS
	ret				; return successful

noPacket:
	mov	ax, PXENV_STATUS_FAILURE
	ret				; return failure

endp

;--------------------------------------------------------------------
; UDPwrite
;
;--------------------------------------------------------------------
UDPStruct     TxUDPStruct <>

Proc    UDPwrite

	; Fill the transmit UDP structure.
	mov	[UDPStruct.Size], size TxUDPStruct

	; copy destination IP address
	mov	eax, [(s_pxenv_udp_write es:di).ip]
	mov	[UDPStruct.Address], eax

	; copy gateway IP address
	mov	eax, [(s_pxenv_udp_write es:di).gw]
	mov	[UDPStruct.Gateway], eax

	; copy source port
	mov	ax, [(s_pxenv_udp_write es:di).src_port]
	xchg	al, ah
	cmp	ax, 0			; was a port value given?
	jne	gotPortVal		; yes
	mov	ax, 2069		; default port number

gotPortVal:
	mov	[UDPStruct.SourcePort], ax

	; copy destination port
	mov	ax, [(s_pxenv_udp_write es:di).dst_port]
	xchg	al, ah
	mov	[UDPStruct.DestPort], ax

	push	[word ptr (s_pxenv_udp_write es:di).buffer_off]
	push	[word ptr (s_pxenv_udp_write es:di).buffer_seg]
	pop	[(UDPStruct.Data)+2]
	pop	[(UDPStruct.Data)+0]

	mov	ax, [(s_pxenv_udp_write es:di).buffer_size]
	mov	[UDPStruct.Length], ax

	mov	bx, BW_TRANSMITUDP
	push	cs

	pop	es			; es = cs
	lea	di, [UDPStruct]
	call	[BWAPI]
	cmp	ax, 0			; was there an error?
	je	txUDPOK			; no error

	mov	ax, PXENV_STATUS_FAILURE
	ret				; return failure

txUDPOK:
	mov	ax, PXENV_STATUS_SUCCESS
	ret				; return success

endp

;------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\tcpip\bootp.asm ===
;===================================================================
; BOOTP.ASM
;
;$History: BOOTP.ASM $
; 
; *****************  Version 8  *****************
; User: Paul Cowan   Date: 17/08/98   Time: 10:30a
; Updated in $/Client Boot/Goliath/BootWare/TCPIP
; BINL server IP address was always used for TFTP, now the ServerIP field
; in the BINL reply is used.
; 
; *****************  Version 7  *****************
; User: Paul Cowan   Date: 11/08/98   Time: 4:49p
; Updated in $/Client Boot/BW98/BootWare/TCPIP
; Better error message handling for failed transmit.
; 
; *****************  Version 6  *****************
; User: Paul Cowan   Date: 11/08/98   Time: 11:37a
; Updated in $/Client Boot/Goliath/BootWare/TCPIP
; Change: BOOTP vendor field now terminated correctly.
; Change: Gateway address retrieved from BINL packet.
; Change: DHCP server IP was not retrieved if no file name was specifeid.
; 
; *****************  Version 5  *****************
; User: Paul Cowan   Date: 22/07/98   Time: 5:34p
; Updated in $/Client Boot/BW98/BootWare/TCPIP
; DHCP ACK packet was being saved (for Goliath) and overwritting OFFER
; packet so no image file name was found.  ACK is only saved if doing
; BINL.
; 
; *****************  Version 4  *****************
; User: Paul Cowan   Date: 7/07/98    Time: 14:33
; Updated in $/Client Boot/BW98/BootWare/TCPIP
; Replaced missing label.
; 
; *****************  Version 3  *****************
; User: Paul Cowan   Date: 7/07/98    Time: 14:17
; Updated in $/Client Boot/Goliath/BootWare/TCP-IP
; Fixed problems with BINL - BINL options could be incorrectly
; included with standard DHCP request.
;===================================================================

TEMPSEG = 5000h

;--------------------------------------------------------------------
; DoBOOTP
;
; Main BOOTP processing loop.
;
;--------------------------------------------------------------------
Proc DoBOOTP

	call	InitBOOTP		; initialize BOOT/DHCP

startLoop:
	mov	[Replies], 0		; clear reply counter

	mov	[word ptr Transfer], 0
	mov	[(word ptr Transfer)+2], TEMPSEG

bootpLoop:
	call	Transmit		; transmit a packet

	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	mov	[StartTime], dx		; save starting time

	; -----------------------------------------------------------
	; We sit and wait a while to collect any replies, this
	; allows us to receive more then one reply then pick which
	; reply we want later.  If a key is pressed the waiting stops,
	; unless the ESCAPE key is pressed, then we abort the boot.
	; -----------------------------------------------------------
waitLoop:
	mov	ah, 1
	int	16h			; check keyboard for a key
	jz	noKey			; no key pressed

	xor	ax, ax
	int	16h			; read keyboard

	cmp	ax, 011Bh		; ESC code
	jne	waitDone		; not ESC - exit wait loop

	cmp	ax, 0			; set flags for not equal
	jmp	exit			; abort

noKey:
	xor	ah, ah			; get system tick count
	int	1Ah			; timer services
	sub	dx, [StartTime]		; calc elapsed time
	cmp	dx, [WaitTime]		; is time up?
	jb	waitLoop		; loop until times up

	inc	[Counter]		; increase transmit count

waitDone:
	cmp	[Replies], 0		; did we get any replies?
	jne	gotSome			; yes

	cmp	[Counter], 20		; have we tried 20 times?
	jne	bootpLoop		; no, keep trying

	call	PrintCRLF
	mov	bx, offset tx_NoServer
	call	Print			; say "No reply from a server."

	xor	ax, 1			; set error state to reboot
	jmp	exit

gotSome:
	call	ProcessReplies		; process the replies we got
	cmp	[State], 0		; are we still doing something?
	jne	startLoop		; more to do

	xor	ax, ax

exit:
	pushf				; save return status
	mov	bx, 2
;	call	AIChangeReceiveMask	; disable broadcast reception

	mov	di, 0
	mov	cx, 1
	call	AISetCallBack		; clear callback

	popf				; restore return status
	ret				; BOOTP, or DHCP is done, return

endp

;--------------------------------------------------------------------
; InitBOOTP
;
; Sets up for BOOTP or DHCP depending on the method selected in
; the BootWare table.
;
; Parameters:
;	none
;
; Returns:
;	nothing (first packet is built and sent)
;
;--------------------------------------------------------------------
Proc InitBOOTP

	mov	[WaitTime], 18		; start timeout at 1 second
	mov	[Counter], 0		; clear counter

	xor	dx, dx
	mov	es, dx			; es=0
	mov	edx, [es:046ch]		; get clock tick count
	mov	[TickStart], edx
	mov	[Random], dx		; save low word as "random" number

	push	ds
	pop	es			; es = ds

	mov	bx, offset tx_bootp	; get pointer to BOOTP string
	cmp	[Protocol], IP_BOOTP	; are we doing BOOTP?
	je	init2			; yes

	mov	bx, offset tx_dhcp	; get pointer to DHCP string

init2:
	call	Print			; print "BOOTP:"

	mov	bx, 3
	call	AIChangeReceiveMask	; enable broadcast reception

	mov	di, offset BootpCallback
	mov	cx, 1
	call	AISetCallBack		; setup Raw callback

	call	CreateRequest		; create the request packet
	ret

endp

;--------------------------------------------------------------------
; CreateRequest
;
; Build a BOOTP request or DHCP discover packet.
;
;--------------------------------------------------------------------
Proc CreateRequest

	; Clear the packet buffer.
	xor	ax, ax
	mov	di, offset TxBuffer
	mov	cx, (size BOOTP) / 2
	rep	stosw

	; build the UDP transmit structure
	mov	[TxUDP.Size], size TxUDP
	mov	[TxUDP.Address], -1	; IP address is broadcast
	mov	[TxUDP.SourcePort], 68
	mov	[TxUDP.DestPort], 67
	mov	[TxUDP.Data], offset TxBuffer
	mov	[(TxUDP.Data)+2], ds
	mov	[TxUDP.Length], size BOOTP

	; fill in request packet details
	mov	bx, offset TxBuffer
	mov	[(BOOTP bx).OP], 1	; set op code for request
	mov	[(BOOTP bx).htype], 1	; hardware type is ethernet
	mov	[(BOOTP bx).hlen], 6	; hardware address length is 6

	mov	ax, [Random]		; get the "random" number
	inc	ax
	mov	[(BOOTP bx).xid], ax	; save as transaction ID
	mov	[(BOOTP bx).xid2], 'cp'
	mov	[Random], ax

	; put local hardware address into BOOTP packet
	lea	di, [(BOOTP bx).chaddr]
	mov	si, offset NetAddress
	movsw
	movsw
	movsw

	lea	di, [(BOOTP bx).options]; get offset for options field

	; stuff RFC 1048 magic cookie
	mov	ax, 8263h
	stosw
	mov	ax, 6353h
	stosw

	mov	[State], STATE_BOOTP	; default to BOOTP state

	cmp	[Protocol], IP_BOOTP	; are we doing BOOTP?
	je	createExit		; yes

	mov	[State], STATE_OFFER	; we are waiting for an offer reply

	; stuff DHCP options
	mov	al, 53
	stosb				; DHCP message type
	mov	al, 1
	stosb				; field length
	stosb				; DHCP discover 

	cmp	[Protocol], IP_BINL	; are we doing BINL?
	jne	createExit		; no

	;------------------------------------------------------------
	; We are doing BINL so add the BINL data to the options field.
	;------------------------------------------------------------
	mov	cx, BINLID_SIZE
	mov	si, offset BINLID	; put BINL option in packet
	rep	movsb

	; copy the packet into local memory buffer
	push	di
	mov	si, offset TxBuffer
	mov	di, offset DiscoverPkt	; get location for packet
	mov	cx, size BOOTP
	rep	movsb			; copy discover packet
	pop	di

createExit:
	mov	al, -1
	stosb				; truncate option field

	ret

endp

;--------------------------------------------------------------------
; BootpCallback
;
; Calls the interface layer to check if a packet has been received.
; If a packet has been received the packet is processed on our current
; state.
;
; Parameters:
;	cx - packet length
;	es:di - packet buffer address
;
; Returns:
;	ax - new state
;	carry set if packet received for us
;--------------------------------------------------------------------
Proc BootpCallback far

	pusha				; save everything
	push	es			; save es
	push	ds			; save ds

	push	es
	pop	ds			; ds = packet buffer segment

	push	cs
	pop	es			; es = cs

	mov	si, di			; move packet address into si

	; Skip the MAC header so we don't have to worry about it later.
	add	si, 14			; skip MAC header
	sub	cx, 14

	call	VerifyPacket
	jc	@@skipPacket		; not for us or bad

	les	di, [cs:Transfer]	; get current buffer location

	mov	ax, cx
	stosw				; save packet size
	rep	movsb			; copy packet into our buffer

	mov	[word ptr es:di], 0

	mov	[word ptr cs:Transfer], di

	inc	[cs:Replies]		; increase reply count

@@skipPacket:
	pop	ds			; restore ds
	pop	es			; restore es
	popa				; restore everything
	ret

endp

;--------------------------------------------------------------------
; VerifyPacket
;
; Verifys that the packet given to us is a BOOT, or DHCP, reply
; for us.
;
; Parameters:
;	ds:si - pointer to received packet
;	cs - packet size
;	es set to our current segment
;
; Returns:
;	carry set if we want the packet
;--------------------------------------------------------------------
Proc VerifyPacket

	push	si			; save packet pointer
	push	cx			; save packet size

	lea	bx, [si + 20]		; skip IP header

	; check the UDP destination port for BOOTP client
	cmp	[word ptr bx+2], 4400h	; is dest bootp client?
	jne	@@badPacket		; no good

	add	bx, 8			; skip UDP header

	; check if the packet is a BOOTP reply for us
	cmp	[(BOOTP bx).OP], 2	; check for a reply packet
	jne	@@badPacket		; no good

	; check for our hardware address in the hardware field
	lea	si, [(BOOTP bx).chaddr]
	mov	di, offset NetAddress
	mov	cx, 3
	rep	cmpsw
	jne	@@badPacket		; no good

	cmp	[es:Protocol], IP_BOOTP	; are we doing BOOTP?
	je	@@goodPacket		; yes

	lea	di, [((BOOTP bx).Options)+4]

	cmp	[byte ptr di], 53	; make sure this is a DHCP reply
	jne	@@badPacket		; not DHCP

	mov	al, [di+2]		; get DHCP message type
	cmp	al, [es:DHCPType]	; is this the type we want?
	jne	@@badPacket		; no

@@goodPacket:
	clc				; clear carry - packet good
	jmp	@@verifyExit

@@badPacket:
	stc				; set carry - bad packet

@@verifyExit:
	pop	cx			; restore packet szie
	pop	si			; restore packet pointer
	ret

endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
Proc ProcessReplies

	cmp	[State], STATE_BOOTP	; are we doing BOOTP?
	jne	@@skip1			; no

	jmp	ProcessBOOTP

@@skip1:
	cmp	[State], STATE_OFFER	; are we doing DHCP offer?
	jne	@@skip2

	jmp	ProcessOffer		; process the offer reply

@@skip2:
	cmp	[State], STATE_ACK	; are we doing DHCP ACK?
	jne	@@skip3

	jmp	ProcessACK		; process the ACK reply

@@skip3:
	cmp	[State], STATE_BINL	; are we doing BINL reply?
	jne	@@skip4

	jmp	ProcessBINL		; process the BINL reply

@@skip4:
	ret				; we shouldn't be here

endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
Proc ProcessBOOTP

	call	SelectReply
	jnc	@@done			; didn't find anything

	call	ProcessReply

	mov	[State], STATE_DONE	; set state to done

@@done:
	ret

endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
Proc ProcessOffer

	cmp	[Protocol], IP_BINL	; are we doing TCP/IP BINL?
	jne	@@skip1			; no

	call	SelectProxy		; select a proxy reply packet

@@skip1:
	call	SelectReply		; select a DHCP reply
	jnc	@@done			; didn't find anything

	call	ProcessReply
	call	DhcpRequestTx

@@done:
	ret

endp

;--------------------------------------------------------------------
; ProcessBINL
;
; Processes the BINL reply packet.  It's assumed only one packet
; is in the buffer so we use the fist packet.
;
;--------------------------------------------------------------------
Proc ProcessBINL

	mov	si, TEMPSEG
	mov	es, si
	xor	si, si			; start at beginning of buffer

	; copy the entire reply packet into local memory buffer
	mov	di, offset BINLPkt	; get location for packet
	call	CopyPacket

	lea	si, [(BOOTP di).filename]
	cmp	[byte ptr ds:si], 0	; did we get a file name?
	je	@@skip			; no name specified

	mov	[NamePtr], si		; save pointer to file name

@@skip:
	mov	eax, [(BOOTP di).siaddr]; get server IP
	cmp	eax, 0			; get a value?
	jne	gotIP			; yes

	mov	eax, [BINLIP]		; use BINL server IP address

gotIP:
	mov	[ServerIP], eax

	mov	eax, [(BOOTP di).gwaddr]; get gateway IP
	mov	[GatewayIP], eax

	mov	[State], STATE_DONE	; now we are done
	ret

endp

;--------------------------------------------------------------------
; SelectReply
;
; Scans all the BOOTP/DHCP replies we got to find one that has a file
; name and an IP address for us.  If a reply is found with a file
; then the first reply with an IP address will be used and the file
; name will default to "bootware.img".
;
; Parameters:
;	none
;
; Returns:
;	si - pointer to full packet
;	carry set if packet selected
;--------------------------------------------------------------------
Proc SelectReply

	cmp	[State], STATE_BOOTP	; are we doing BOOTP?
	jne	@@notBOOTP		; yes

	call	SelectBOOTP		; select a BOOTP reply
	jc	@@selected
	ret				; nothing selected

@@notBOOTP:
	call	SelectDHCP		; select a DHCP reply
	jc	@@selected		; found a reply

	ret				; no packet selected

@@selected:
	mov	di, offset BootPkt
	call	CopyPacket		; copy packet into local memory

	stc				; set carry
	ret

endp

;--------------------------------------------------------------------
; SelectBOOTP
;
; Scans all the BOOTP replies we got to find one that has an IP
; address for us and a file name.  If no entry with a file name is
; found we check the replies again and accept the first one that has
; an IP address.  The image will default to "bootware.img".
;
; Parameters:
;	none
;
; Returns:
;	si - pointer to selected packet (carry set)
;--------------------------------------------------------------------
Proc SelectBOOTP

	mov	si, TEMPSEG
	mov	es, si

	xor	ax, ax			; clear file name skip flag

@@selectStart:
	xor	si, si			; start at beginning of buffer

@@processNext:
	cmp	[word ptr es:si], 0	; does this packet have data?
	je	@@notFound		; end of data packets
	lea	bx, [si+2+20+8]		; skip size word, IP & UDP headers
	cmp	[word ptr (BOOTP es:bx).yiaddr], 0; is there an IP address?
	je	@@noIP			; no - skip packet

	cmp	ax, 0			; first time checking?
	jne	@@gotName		; no - skip file name check

	cmp	[(BOOTP es:bx).filename], 0; is there a file name?
	jne	@@gotName		; yes

@@noIP:
	add	si, [es:si]		; add size of packet
	add	si, 2			; skip size byte
	jmp	@@processNext		; check the next packet

@@notFound:
	cmp	ax, 0
	jne	@@noneFound

	inc	ax
	jmp	@@selectStart		; check again

@@noneFound:
	clc				; clear carry - we didn't find a packet
	ret

@@gotName:
	stc				; set carry - we found a packet
	ret

endp

;--------------------------------------------------------------------
; SelectDHCP
;
; Scans all the DHCP replies we got to find one that has a file name,
; and a DHCP server IP number.
; If no reply if found with a file name then the first packet is used
; to get just our IP number and we will default to "bootware.img" for
; the image.
;
; Parameters:
;	none
;
; Returns:
;	si - pointer to selected packet
;	carry set if packet selected
;--------------------------------------------------------------------
Proc SelectDHCP

	call	SelectBOOTP		; find a reply with a file name
	jc	@@selected
	ret

@@selected:
	lea	di, [si+2+20+8]		; skip size word, IP & UDP headers
	mov	bl, 54
	call	FindDhcpOption		; look for server IP

	cmc				; flip carry
	ret				; return - we found a packet

	;------------------------------------------------------------
	; We didn't find a reply that had both a file name and a 
	; DHCP server IP number, so let's use the first one that
	; does have a server IP number.
	;------------------------------------------------------------
;@@noIP:
;	mov	si, TEMPSEG
;	mov	es, si
;	xor	si, si			; start at beginning of buffer

;@@processNext:
;	cmp	[word ptr es:si], 0	; does this packet have data?
;	je	@@notFound		; end of data packets

;	lea	di, [si+2+20+8]		; skip size word, IP & UDP headers
;	mov	bl, 54
;	call	FindDhcpOption		; look for server IP
;	jc	@@gotIP			; option found

;	add	si, [es:si]		; add size of packet
;	add	si, 2			; skip size byte
;	jmp	@@processNext		; check the next packet

;@@notFound:
;	clc				; clear carry - bad
;	ret

;@@gotIP:
;	stc				; set carry - OK
;	ret

endp

;--------------------------------------------------------------------
; SelectProxy
;
; Scans all the replies we got to find one that is a PXE proxy reply.
;
; Parameters:
;	none
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc SelectProxy

	mov	si, TEMPSEG
	mov	es, si
	xor	si, si			; start at beginning of buffer

@@checkNext:
	cmp	[word ptr es:si], 0	; does this packet have data?
	je	@@notFound		; end of data packets
	lea	di, [si+2+20+8]		; skip size word, IP & UDP headers
	mov	bl, 60
	call	FindDhcpOption		; look for class identifier
	jnc	@@found			; option was found

@@next:
	add	si, [es:si]		; add size of packet
	add	si, 2			; skip size byte
	jmp	@@checkNext		; check the next packet

@@notFound:
	xor	si, si			; set zero flag - not found
	ret

@@found:
	push	si			; save si
	mov	si, offset PXE		; offset to static text
	mov	cx, 9
	rep	cmpsb			; check for "PXEClient" string
	pop	si			; restore si
	jne	@@next			; string not found

	lea	di, [si+2+20+8]		; skip size word, IP & UDP headers
	mov	bl, 54
	call	FindDhcpOption		; look for server IP
	jc	@@next			; option was not found

	mov	eax, [es:di]		; get the BINL server's IP address
	mov	[BinlIP], eax

	xor	di, 1			; clear flag
	ret

endp

;--------------------------------------------------------------------
; Parameters:
;	es:si - pointer to entire packet
;--------------------------------------------------------------------
Proc ProcessReply

	;------------------------------------------------------------
	; Copy the replying servers IP address from the IP header.
	; For now assume the replying server is going to be the only
	; server.
	;------------------------------------------------------------
	add	si, 2			; skip buffer size word

	mov	eax, [dword ptr (IP es:si).SourceIP]
	mov	[ReplyIP], eax
	mov	[ServerIP], eax

	;------------------------------------------------------------
	; Set pointer to BOOTP packet.
	;------------------------------------------------------------
	mov	bx, offset BootPkt	; get location for BOOTP packet
	push	ds
	pop	es			; es = ds

	;------------------------------------------------------------
	; Get our IP number.
	;------------------------------------------------------------
	lea	si, [(BOOTP bx).yiaddr]	; get our IP address from reply
	mov	di, offset LocalIP
	movsw
	movsw

	mov	eax, [(BOOTP bx).gwaddr]; gateway IP
	mov	[GatewayIP], eax

	;------------------------------------------------------------
	; Check if a different server IP address was specified in the
	; BOOTP server IP field, if it was then use that servers address.
	;------------------------------------------------------------
	mov	eax, [(BOOTP bx).siaddr]; get IP address
	cmp	eax, 0			; is there a value?
	je	sameIP			; no

	cmp	[ReplyIP], eax		; is the IP the same as the servers
	je	sameIP			; yes

	mov	[ServerIP], eax		; update servers IP address

sameIP:
	lea	si, [(BOOTP bx).filename]
	cmp	[byte ptr ds:si], 0	; did we get a file name?
	je	@@noName		; no name specified

	mov	[NamePtr], si		; save pointer to file name

@@noName:
	cmp	[Protocol], IP_BOOTP	; are we doing BOOTP?
	je	@@processExit		; yes - we are done

	;------------------------------------------------------------
	; We are doing DHCP so get the servers IP address.
	;------------------------------------------------------------
	mov	bl, 54			; get and save server IP address
	mov	di, offset BOOTPkt	; skip IP and UDP headers
	call	FindDhcpOption
	mov	si, offset ServerIP
	xchg	di, si
	movsw				; save DHCP servers IP number
	movsw

@@processExit:
	ret

endp

;-----------------------------------------------------------------------------
; DhcpRequestTx
;
; Build and send a DHCP request packet (an offer packet has been received).
;
;-----------------------------------------------------------------------------
Proc DhcpRequestTx

	lea	di, [((BOOTP TxBuffer).Options)+4]

	; stuff DHCP options
	mov	al, 53
	stosb				; DHCP message type
	mov	al, 1
	stosb				; field length
	mov	al, 3
	stosb				; DHCP request

;	mov	cx, 6				
;	mov	si, offset DHCPRequest
;	rep	movsb			; add DHCP request option

;	mov	cx, 6
;	mov	si, offset NetAddress
;	rep	movsb			; add our node address

	mov	ax, 0432h
	stosw				; add host IP token

	mov	si, offset LocalIP
	movsw				; add our IP
	movsw

	mov	ax, 0436h
	stosw				; add server IP token

	mov	si, offset ServerIP
	movsw
	movsw				; add DHCP's server IP

	mov	al, -1
	stosb				; truncate options

	mov	[DHCPType], 5		; set next type
	mov	[State], STATE_ACK	; next we are waiting for an ACK
	ret

endp

;--------------------------------------------------------------------
; DhcpAckRx - Server responds to the REQUEST with an ACK which means
;		that the IP address is ours.
;--------------------------------------------------------------------
Proc ProcessACK

	cmp	[Protocol], IP_BINL	; are we doing TCP/IP BINL?
	je	@@doingBINL		; yes

@@noBINL:
	mov	[State], STATE_DONE	; set state to done
	ret

@@doingBINL:
	mov	si, TEMPSEG
	mov	es, si
	xor	si, si			; start at beginning of buffer

	mov	di, offset BootPkt
	call	CopyPacket		; copy packet into local memory

	push	ds
	pop	es			; es = ds

	; check if we got an image file name, if we did we don't
	; need to do the BINL request
	cmp	[NamePtr], offset DefaultFile
	jne	@@noBINL

	jmp	RequestBINL		; send BINL request

endp

;------------------------------------------------------------------------------
; FindDhcpOption
; 	- scan dhcp options fields of packet for DHCP option
; 
; Parameters:
;	bl = option value
;	es:di - pointer to packet
;
; Returns:
;	di - pointer to option data
;	carry clear if option found
;------------------------------------------------------------------------------
Proc FindDhcpOption

	lea	di, [((BOOTP di).Options)+4]

look4Option:
	mov	bh, [es:di]
	cmp	bh, 0ffh
	je	noOption
	cmp	bh, bl			; have we found the option ?
	je	foundOption		; jump if yes
	xor	ax, ax
	mov	al, [byte ptr es:di+1]
	add	di, ax
	add	di, 2
	jmp	look4Option

foundOption:
	add	di, 2			; point past the option and size bytes
	clc
	ret				; found - return no carry

noOption:
	stc
	ret				; not found - return with carry

endp

;--------------------------------------------------------------------
; Transmit
;
; Updates a packet (IP & UDP checksums, if needed) and transmits it.
;
; Parameters:
;	none
;
; Returns:
;	al - status of transmit
;--------------------------------------------------------------------
Proc Transmit

	mov	ax, 0E2Eh
	int	10h			; print .

	cmp	[Counter], 0		; is this the first packet?
	je	firstTx			; yes

	push	0
	pop	es			; es = 0;
	mov	eax, [es:046ch]		; get clock tick count
	sub	eax, [TickStart]	; subtract starting time
	mov	edx, eax		; convert to two words
	shr	edx, 16
	mov	cx, 18			; ticks per second
	div	cx			; calc number of seconds since start

	mov	[(BOOTP TxBuffer).secs], ax; update seconds
	inc	[(BOOTP TxBuffer).xid]	; change transaction ID

firstTx:
	push	ds
	pop	es			; es = ds

	mov	di, offset TxUDP	; get pointer to UDP info
	call	AITransmitUDP		; send the UDP packet

	or	ax, ax			; check for returned error code
	je	txOK

	cmp	ax, 25			; is it IP address error?
	je	ipError

	push	ax
	mov	bx, offset tx_TransmitError
	call	Print			; print "Transmit error"

	pop	ax
	call	PrintDecimal		; print error number

	jmp	Reboot			; reboot the system

ipError:
	call	PrintCRLF
	mov	bx, offset ErrorMsg
	call	Print			; print "Error: "

	mov	bx, offset tx_CantResolve
	call	Print

	lea	si, [TxUDP.Address]
	call	PrintIP

	jmp	Reboot			; reboot the system

txOK:
	; increase the time-out by 0.5 seconds.
	add	[WaitTime], 9		; add 0.5 seconds
	ret

endp

;-----------------------------------------------------------------------------
; RequestBINL
;
; Build and send a DHCP request packet (an offer packet has been received).
;
;-----------------------------------------------------------------------------
Proc RequestBINL

	mov	eax, [BinlIP]
	cmp	eax, 0
	jne	@@skip

	call	PrintCRLF
	mov	bx, offset tx_NoBINL
	call	Print			; say "No reply from a server."

	jmp	Reboot

@@skip:
	lea	di, [((BOOTP TxBuffer).Options)+4]

	; stuff DHCP options
	mov	al, 53
	stosb				; DHCP message type
	mov	al, 1
	stosb				; field length
	mov	al, 3
	stosb				; DHCP request

	mov	cx, BINLID_SIZE
	mov	si, offset BINLID	; put BINL option in packet
	rep	movsb

	mov	al, -1
	stosb				; truncate options

	mov	[DHCPType], 5		; set next type

;	mov	[TxUDP.Size], size TxUDP
	mov	eax, [BinlIP]
	mov	[TxUDP.Address], eax
	mov	[TxUDP.SourcePort], 68
	mov	[TxUDP.DestPort], 4011
	mov	[TxUDP.Length], size BOOTP

	mov	[State], STATE_BINL	; set state to BINL request

	ret

endp

;-----------------------------------------------------------------------------
; CopyPacket
;
; Copies packet into local memory.
;
; Parameters:
;	es:si - pointer to packet to copy
;	ds:di - pointer to packet buffer
;-----------------------------------------------------------------------------
Proc CopyPacket

	push	es			; save es
	push	ds			; save ds
	push	si			; save si
	push	di			; save di

	push	es
	pop	ds			; set ds to source segment
	push	cs
	pop	es			; set es to our segment

	mov	cx, [si]		; get packet size
	add	si, 2+28		; skip size word & IP/UDP headers
	rep	movsb			; copy packet

	pop	di			; restore di
	pop	si			; restore si
	pop	ds			; restore ds	
	pop	es			; restore es

;	mov	di, offset BootPkt	; get location for packet
;	mov	al, [BWType]		; get BootWare type from table
;	mov	[(BOOTP di).hlen], al	; save in packet for BPPATCH
;	mov	ax, [NIC_IO]		; get IO address from table
;	mov	[(BOOTP di).secs], ax	; save in packet for BPPATCH
;	mov	ax, [NIC_RAM]		; get RAM address from table
;	mov	[(BOOTP di).spare], ax	; save in packet for BPPATCH

	ret

endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\pxe\undi_api.inc ===
;--------------------------------------------------------------------
; PXE UNDI constants and structures
;
;--------------------------------------------------------------------

PXENV_UNDI_STARTUP	 	equ	01h
PXENV_UNDI_CLEANUP	 	equ	02h
PXENV_UNDI_INITIALIZE 		equ	03h
PXENV_UNDI_RESET_NIC		equ	04h
PXENV_UNDI_SHUTDOWN		equ	05h
PXENV_UNDI_OPEN			equ	06h
PXENV_UNDI_CLOSE		equ	07h
PXENV_UNDI_TRANSMIT		equ	08h
PXENV_UNDI_SET_MCAST_ADDR	equ	09h
PXENV_UNDI_SET_STATION_ADDR	equ	0Ah
PXENV_UNDI_SET_PACKET_FILTER	equ	0Bh
PXENV_UNDI_GET_INFORMATION	equ	0Ch
PXENV_UNDI_GET_STATISTICS	equ	0Dh
PXENV_UNDI_CLEAR_STATISTICS	equ	0Eh
PXENV_UNDI_INITIATE_DIAGS	equ	0Fh
PXENV_UNDI_FORCE_INTERRUPT	equ	10h
PXENV_UNDI_GET_MCAST_ADDR	equ	11h
PXENV_UNDI_GET_NIC_TYPE		equ	12h
PXENV_UNDI_GET_NDIS_INFO	equ	13h

ADDR_LEN			equ	16
MAXNUM_MCADDR			equ	8

struc S_PXENV_FORCE_INTERRUPT
	Status		dw	?
ends

struc S_PXENV_UNDI_CLOSE
	Status		dw	?
ends

struc S_PXENV_UNDI_STARTUP
	Status		dw	?
	BusType		db	?
	AddrType	db	?
	DataSegA	dw	?
	DataSegAddr	dd	?
	DataSegSize	dw	?
	CodeSegSize	dw	?
	BusDevFunc	dw	?
	PCI_ds_off	dw	?
	PCI_ds_seg	dw	?
	PnP_csn		dw	?
	PnP_eh_off	dw	?
	PnP_eh_seg	dw	?
ends

struc S_PXENV_UNDI_INITIALIZE
	Status		dw	?
	ProtocolIni	dd	?
	ReceiveOffset	dw	?
	ReceiveSegment	dw	?
	GeneralIntOff	dw	?
	GeneralIntSeg	dw	?
ends

struc S_PXENV_UNDI_GET_INFORMATION
	Status		dw	?
	BaseIo		dw	?
	IntNumber	dw	?
	MaxTranUnit	dw	?
	HwType		dw	?
	HwAddrLen	dw	?
	CurrentNodeAddress db	ADDR_LEN dup(?)
	PermNodeAddress db	ADDR_LEN dup(?)
	RomAddress	dw	?
	RxBufCt		dw	?
	TxBufCt		dw	?
ends

ETHER_TYPE = 1

struc S_PXENV_UNDI_GET_NIC_TYPE_PCI
	Status		dw	?
	NicType		db	?
	Vendor_ID	dw	?
	Dev_ID		dw	?
	Base_Class	db	?
	Sub_Class	db	?
	Prog_Intf	db	?
	Rev		db	?
	BusDevFunc	dw	?
ends

struc S_PXENV_UNDI_GET_NIC_TYPE_PNP
	Status		dw	?
	NicType		db	?
	EISA_Dev_ID	dd	?
	Base_Class	db	?
	Sub_Class	db	?
	Prog_Intf	db	?
	CardSelNum	dw	?
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\language\lang.asm ===
;----------------------------------------------------------------------------
; LANG.ASM
;
; Language module for BootWare Goliath.
;
;----------------------------------------------------------------------------

assume	cs:code, ds:code, es:nothing,ss:nothing
code segment public 'code'
.386

	org 0

	db	"BootWare Goliath Language module: "
ifdef ENGLISH
	db	"English"
endif

ifdef FRENCH
	db	"French"
endif

	db	26, 0

	org	60
	db	"PCSD"

	dw	text0, text1, text2, text3, text4, text5, text6, text7
	dw	text8

	org	128
ifdef ENGLISH
text0	db	"Error: Not a PCI PC!", 0
text1	db	"Error: Couldn't find an adapter!", 0
text2	db	"Error: ", 0
text3	db	"Error: Unable to initialize adapter", 0
text4	db	"MAC: ", 0
text5	db	"No reply from a DHCP server.", 0
text6	db	"No reply from a BINL server.", 0
text7	db	"Too many retries.", 0
text8	db	"Press a key to reboot system.", 0
endif

ifdef FRENCH
text0	db	"Erreur: Ce PC n'est pas PCI!", 0
text1	db	"Erreur: Incapable de trouver l'adapteur!", 0
text2	db	"Erreur: ", 0
text3	db	"Erreur: Incapable d'initialiser l'adapteur!", 0
text4	db	"MAC: ", 0
text5	db	"Le serveur DHCP ne rpond pas!", 0
text6	db	"Le serveur BINL ne rpond pas!", 0
text7	db	"Limite d'erreurs excede.", 0
text8	db	"Appuyez sur une touche pour redmarrer le systme.", 0
endif

	org	1023
	db	0

code ends
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\tcpip\tcpip.inc ===
;----------------------------------------------------------------------
;
; File Name:	   BOOTP.INC
;
; Program Name:    BOOTP Boot ROM Module
;
; Companion Files: None
;
; Function:	This module contains all the data strcuture definitions
;		for the various BOOTP Frame formats.
;
; History:
; 96-Jul-24     JJ - added support for DHCP.
; 94-Jun-23 1.1 GK - added SMCELITE conditional for XY_DESCRIPT
; 93-Apr-19 1.0 PC - first release
;----------------------------------------------------------------------

;---------------------------------------------------------------------
; Internet Protocol structure.
;---------------------------------------------------------------------
Struc IP
	Ver		db	?
	Type 		db	?
	Len		dw	?
	Ident		dw	?
	FragOffSet	dw	?
	Time 		db	?
	Protocol	db	?
	CheckSum	dw	?
	SourceIP	dw	2 dup (?)
	DestIP		dw	2 dup (?)
ends

;---------------------------------------------------------------------
; User Datagram Protocol structure.
;---------------------------------------------------------------------
Struc	UDP
	SourcePort	dw	?
	DestPort	dw	?
	Len		dw	?
	Sum		dw	?
ends

;---------------------------------------------------------------------
; other values
;---------------------------------------------------------------------

; TFTP ACK NAK values

ACK		equ	0400h
NAK		equ	0500h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\loader\loader.inc ===
Struc	LoaderInfo
	LangSeg		dw	?
	PCIBusDevFunc	dw	?
	VendorID	dw	?
	DeviceID	dw	?
	CSN		dw	?
	UNDICode	dw	?	; UNDI code size
	UNDIData	dw	?	; UNDI data size
	UNDISeg		dw	?	; UNDI segment
ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\tcpip\ipdata.inc ===
;====================================================================
; IPDATA.INC
;
; Global data for TCP/IP NID
;
;====================================================================
public	LocalIP
public	ServerIP
public	BootPkt
public	DiscoverPkt
public	BINLPkt

public tx_NoServer
public tx_NoBINL
public tx_toomanytries

STATE_DONE	equ	0
STATE_BOOTP	equ	1
STATE_OFFER	equ	2
STATE_ACK	equ	4
STATE_BINL	equ	8

;---------------------------------------------------------------------
;  BOOTP bootstrap packet structure
;---------------------------------------------------------------------
Struc	BOOTP
	OP		db	?		; Op Code
	htype		db	?		; hardware address type
	hlen		db	?		; hardware address lenght
	hops		db	?		; hop count
	xid		dw	?		; transaction id
	xid2		dw	?
	secs		dw	?		; seconds counter
	spare 		dw	?		; spare word
	ciaddr		dd	?		; client IP address
	yiaddr		dd	?		; "your" address, from server
	siaddr		dd	?		; server IP address
	gwaddr		dd	?		; gateway address
	chaddr		db	16 dup(?)	; hardware address
	sname		db	64 dup(?)	; server name
	filename	db	128 dup(?)	; boot file name
	options		db	64 dup(?)	; vender information
ends

;---------------------------------------------------------------------
; Extended memory global descriptor structure
;---------------------------------------------------------------------
Struc	DESCRIPTOR
	Dummy		dw	?, ?, ?, ?
	GDT_LOC 	dw	?, ?, ?, ?
	SourceLimit	dw	?
	SourceLoWord	dw	?
	SourceHiByte	db	?
	SourceRights	db	?
	SourceInternal	dw	?
	TargetLimit	dw	?
	TargetLoWord	dw	?
	TargetHiByte	db	?
	TargetRights	db	?
	TargetInternal	dw	?
	Bios		dw	?, ?, ?, ?
	Temp		dw	?, ?, ?, ?
ends

START_CODE

Even

State		dw	0		; current state
LocalIP		dd	0		; workstation IP address
ServerIP	dd	-1		; server IP address
GatewayIP	dd	0		; gateway IP address
BinlIP		dd	0		; IP number from proxy server
PacketNum	dw	0		; TFTP packet number
ExtFlag		db	0		; extended memory flag
NoDisengage	db	0		; don't disengage when jump to image
WaitTime	dw	18		; wait time between retries
NamePtr		dw	DefaultFile	; pointer to file name
DHCPType	db	2		; type of DHCP packet we want

BINLID		db	55, 9, 1, 3, 2, 4, 6, 12, 15, 60, 43
		db	57, 2, 4, 236
		db	93, 2, 0, 0
		db	94, 3, 1, 2, 0
		db	60, 9
PXE		db	'PXEClient'

BINLID_SIZE	equ	35

;----------------------------------------------------------------------
; Message Definitions
;----------------------------------------------------------------------
tx_bootp	db	"BOOTP", 0
tx_dhcp		db	"DHCP", 0
;tx_binl	db	"BINL", 0
tx_TFTP		db	"TFTP", 0
tx_ServerIP	db	"Server: ", 0
tx_LocalIP	db	"Local: ",0
tx_Gateway	db	"Gateway: ", 0
tx_NoServer	db	"No reply from a server.", 0
tx_NoBINL	db	"No reply from a BINL server.", 0
tx_Transfering	db	"Transferring ", 0
tx_extmemerror	db	"Not enough extended memory for image.", 0
tx_toomanytries	db	"Too many retries.", 0
tx_error	db	"File transfer error: ", 0
tx_toolarge	db	"Image file too large for low memory.", 0
tx_CantResolve	db	"Can't resolve IP address ", 0
tx_TransmitError db	"Transmit error # ", 0
DefaultFile	db	"bootware.img", 0

END_CODE

;----------------------------------------------------------------------
; Uninitialized data
;----------------------------------------------------------------------
START_SPARSE

public _IPSparseStart
label _IPSparseStart

Protocol	dw	?
ReplyIP		dd	?	; IP number that replied to us
DestPort	dw	?	; destination port for TFTP
Random		dw	?	; a "random" value (from clock tick)
HeadSize	dw	?	; # byte in packet header
StartTime	dw	?	; starting time of transmitting
Transfer	dd	?	; dword ptr
ExtendedAddress	dw	?	; current extended memory address
		dw	?	; extended address high word
GDT		DESCRIPTOR <?>	; global descriptor table
Counter		dw	?	; retry counter
Replies		dw	?	; number of BOOTP/DHCP replies we got
TickStart	dd	?

TxUDP		TxUDPStruct <?>
TFTP		OpenTFTPStruct <?>

BootPkt		db 512 dup (?)

IFDEF GOLIATH
	DiscoverPkt	db 512 dup (?)
	BINLPkt		db 512 dup (?)
ELSE
	extrn NetWareStart:byte
	DiscoverPkt 	= NetWareStart + 512
	BINLPkt		= DiscoverPkt + 512
ENDIF
StringBuffer	= BINLPkt + 512

public	_IPEndSparse
label _IPEndSparse

END_SPARSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\tcpip\ipnid.asm ===
;====================================================================
; BOOTPNID.ASM - Generic code for BootWare for TCP/IP
;
; Includes the file IPCODE.ASM which contains the real TCP/IP code.
;
; Copyright 1993-98 Lanworks Technologies
;
; Revision history:
;
;$History: IPNID.ASM $
; 
; *****************  Version 5  *****************
; User: Paul Cowan   Date: 7/20/98    Time: 17:23
; Updated in $/Client Boot/BW98/BootWare/TCPIP
; Added config.inc include
; 
; *****************  Version 4  *****************
; User: Paul Cowan   Date: 7/13/98    Time: 11:28
; Updated in $/Client Boot/BW98/BootWare/TCPIP
; Added a CS: override in the INT2F handler.
;
; 980408 3.0  PC - BootWare98 version
;		 - complete rewrite to use UDP & TFTP APIs in AI
;		 - supports TFTP large block size
;		 - supports BINL
; 970814 2.1  PC - added INT2F memory protection if not disengaging
; 970310 2.0  PC - major reworking:
;		   - uses new AI layer
;		   - changed screen layout
;		   - added disengage checking for new API
;		   - changed NID/NAD calls to use new jump table
;		   - removed screen timer
;		   - removed unneeded "PROTOCOL" and "NOTIMER" conditionals
;		   - changed printing to "common" functions
;		   - removed NIDStatus function
;		   - removed ARP and RARP
;		   - added reboot on fatal errors and timeouts
;		   - combined DHCP states into main state loop
;		   - change to TASM IDEAL mode
; 960806 1.52 GY - BPDATANI.INC doesn't allocate enough data area 
;		   for BPPatch BootP Reply Packet (350 bytes -> 544 bytes)
; 960724      JJ - added support for DHCP
; 960112 1.51 GY - Change year to 96 
;		 - Change TCPStart
;		 - All ROM should use CRightStr in AUTOSCAN
;		 - ChgProtBP replaced by TCPStart
;		 - Move Strings and Global Data to end of file
; 951218 1.50 GY - Paul change CRight_Str to CRightStr
; 951128 1.50 GY - Utilize \ROM\GENR\AUTOSCAN\AUTOSCAN.ASM 
;		 - Take out /dNOAS
; 950913      PC - fixed checksum function which would incorrectly report
;		   checksum errors on odd sized packets (mainly TFTP error
;		   packets)
; 950718 1.25 GY - Gbl_RomLocation not updated properly for /dprotocol
; 950201 1.25 GY - Change year to 1995
; 941024 1.25 GY - (BPCODE.INC) Use PrintMessage rather than PrintMsgLoc
;		   in NIDStatus
; 941021 1.25 GY - drop BWTStatus. No longer print BWTStatus
; 941003 1.24 GY - for /dPROTOCOL rely on NW NID for tx_copyright (CRight_Str)
;		 - take out /dIBM4694 and all code that setup CX for PrintMsgLoc
; 940808 1.24 GY - Add /dNOTIMER for AT1500 (no space)
; 940805      PC - TFTP gets file name from saved BOOTP packet
; 940804 1.23 GY - move Timer code from BPCODE.INC to here
; 940721 1.23 GY - Add /dIBM4694.
;                - Use CUI for Print routines.
;                - (BPCODE) Convert all screen output to use CUI
; 940520 1.22 GY - BWTCpyRAM is misused when copying code from ROM to RAM
; 940506 1.22 GY - Add OS/2 support by adding more info in API Table
;                  and all NID routines are far.
; 940221 1.21 Gy - change year to 1994. Change string to "Centralized
;                  boot ROM for TCP/IP"
;                - Take out Gbl_BIOSMemSize
; 931209 1.21 GY - Use BPCODE.INC version 2.00
;                - Use BPDATA.INC. Copy changes from GENERIC.ASM
; 931028 1.2  GY - when calling NADInitialize, the ROMBase at AX is
;                  wiped out.
; 931026 1.2  GY - use SEGNID.INC rather than DRVSEG.INC
; 931022 1.2  GY - To print message from NADInit, use PrintMax rather than
;                  Print
; 931012 1.2  GY - replace Gbl_EtherType with BWTEthStd. Gbl_EtherType is
;                  byte reverse
;                - change SetInitState to properly handle "error" condition
;                  from NADInitialize
;                - update ED structure in BootP.INC
; 931011 1.2  GK - reworked to conform to NID/NAD
; 930810      GK - consolidated code into core .include file
; 930714 1.1  PC
; 930412 1.0  PC - first release
;====================================================================

IDEAL
_IDEAL_ = 1
locals

	include "..\include\drvseg.inc"
	include "..\include\bwnid.inc"
	include "..\include\config.inc"

public	IPStart
P386

extrn	AIAppendCache:near	; AI layer
extrn	TxBuffer:byte		; common transmit buffer
extrn	AITbl:byte		; BWAPI table address

;extrn	BWTable:BWT
extrn	Verbose:byte


;====================================================================
;                         Code segment
;====================================================================
START_CODE

public _TCPIPStart
_TCPIPStart:

IPStart:
	jmp	TCPIP

;	db	'IP*980408*'		; build date
;	dw	0300h			; build version

	include "tcpip.inc"
	include "ipdata.inc"		; include all global data

IPFeature db 0

;--------------------------------------------------------------------	
; IPStart
;
; Entry function for BootWare TCP/IP.
;
;--------------------------------------------------------------------	
Proc TCPIP

	sti				; enable interrupts

	mov	eax, [BWTable.Settings]	; get current settings
	and	ax, CFG_PROTOCOL	; keep protocol bits
	mov	[Protocol], ax		; save setting

	call	DoBootP
	je	doneBOOTP

rebootJmp:	
	jmp	Reboot

doneBOOTP:
	cmp	[Verbose], 0		; are we in verbose mode?
	je	noIP			; no

	; display the BOOTP server and our assigned IP address
	call	ShowIPs			; show server & local IPs

noIP:
	call	TransferFile
	jne	rebootJmp

	;------------------------------------------------------------
	; The boot image is now in memory.
	;------------------------------------------------------------

	call	PrintCRLF

	sti

	cmp	[Protocol], IP_BINL	; are we doing TCP/IP BINL?
	jne	@@notBINL		; no

	ret				; return to an upper layer

@@notBINL:
	cmp	[NoDisengage], 0	; should we disengage?
	je	doDisengage		; yes

	call	SetupInt2F		; setup our Int2F handler

	jmp	skipDisengage

doDisengage:
	call	AIDisengage		; call interface to disengage

;	mov	[BWTAPI], 0

	mov	[word ptr AITbl-8], 0	; remove "BWAPI" identifer

skipDisengage:
	; and relinquish control to new boot image...
	mov	ax, 1000h
	push	ax			; push new code segment
	xor	ax, ax			; offset to jump to is 0
	push	ax			; push offset (ax = 0 from above)
	mov	ax, cs			; put ROM code segment in ax
	mov	bx, offset BootPkt	; BOOTP packet address in BX
	xor	cx, cx			; cx = 0
	mov	dx, offset AITbl	; get address of API table
	retf				; far return to new address

endp

OldInt2F	dd	0

;--------------------------------------------------------------------
; SetupInt2F
;
;--------------------------------------------------------------------
Proc SetupInt2F

	xor	ax, ax
	mov	es, ax			; es = 0

	mov	ax, offset Int2F	; our INT 2F offset
	xchg	ax, [es:2Fh*4]		; get/set INT 2F offset
	mov	[word ptr OldInt2F], ax ; save original offset

	mov	ax, cs
	xchg	ax, [es:(2Fh*4)+2]	; get/set INT 2F segment
	mov	[word ptr OldInt2F+2], ax	; save original segment

	ret

endp

;--------------------------------------------------------------------
; Int2F
;
;--------------------------------------------------------------------
Proc Int2F far

	jmp	short skipString	; explicitly specify short and add NOP
	db	90h			; to make sure not optimized out

	db	'RPL'			; DOS5 looks for this @ INT2F+3

skipString:
	cmp	ax, 4A06h		; is this DOS5.0 IO.SYS request?
	jz	returnBase

	cmp	[word ptr cs:OldInt2F+2], 0
	je	intRet			; there was no INT 2F, just iret

	jmp	[cs:OldInt2F] 

returnBase:
	mov	dx, cs
	dec	dx

intRet:
	iret

endp

;===================================================================
; NID CODE
;===================================================================

include "bootp.asm"			; BOOTP/DHCP code module
include "tftp.asm"			; file transfer code module

;----------------------------------------------------------------------
;----------------------------------------------------------------------
Proc PrintTransferValue

	cmp	[Verbose], 0		; are we in verbose mode?
	jne	@@doIt			; yes

	test	[PacketNum], 32
	jne	@@back

	mov	ax, 0E2Eh
	int	10h			; print '.'
	ret

@@back:
	mov	ax, 0E08h
	int	10h			; backspace
	mov	ax, 0E20h
	int	10h			; print ' '
	mov	ax, 0E08h
	int	10h			; backspace

	ret

@@doIt:
	push	cx

	mov	di, offset StringBuffer

	mov	[byte ptr di], '('
	inc	di

	mov	ax, [Counter]
	mov	cx, 2
	call	StoDec
	
	mov	al, '-'
	stosb

	mov	ax, [PacketNum]
	mov	cx, 4
	call	StoDec

	mov	[word ptr di], 0029h	; print ')'

	mov	bx, offset StringBuffer
	call	Print

	mov	cx, 9

backLoop:
	mov	ax, 0E08h
	int	10h			; backspace
	loop	backLoop

	pop	cx
	ret

endp

;----------------------------------------------------------------------
; ShowIP
;
; Displays the IP address of a server and the local workstation.
;
; Parameters:
;----------------------------------------------------------------------
Proc ShowIPs

	call	PrintCRLF
	mov	bx, offset tx_ServerIP
	call	Print

	mov	si, offset ServerIP
	call	PrintIP			; print servers IP address

	call	PrintCRLF
	mov	bx, offset tx_LocalIP
	call	Print			; Print "Local IP:"

	mov	si, offset LocalIP
	call	PrintIP			; print our IP number
	call	PrintCRLF

	cmp	[GatewayIP], 0		; is there a gateway?
	je	notgate			; no

	mov	bx, offset tx_Gateway
	call	Print			; Print "Gateway:"

	mov	si, offset GatewayIP
	call	PrintIP			; print our IP number
	call	PrintCRLF

notGate:
	ret

endp

;--------------------------------------------------------------------
; PrintIP
;
; Prints a 4 number period delimited IP address on the screen.
;
; Input:
;       si - pointer to IP address
;	dx - screen location
;--------------------------------------------------------------------
Proc PrintIP

	mov	cx, 4
	jmp	printip2

printIPLoop:
	mov	ax, 0E2Eh
	int	10h			; print '.'

printip2:
	lodsb
	xor	ah, ah
	call	PrintDecimal

	loop	printIPLoop

	ret

endp

;----------------------------------------------------------------------
; Input bx=ptr error msg
;----------------------------------------------------------------------
Proc PrintError

	push	bx			; save pointer to error message

	call	PrintCRLF
	mov	bx, offset tx_error
	call	Print

	pop	bx			; restore pointer to error message
	call	Print
	ret

endp

public _TCPIPEnd
label _TCPIPEnd

END_CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\bootware\tcpip\tftp.asm ===
;===================================================================
; TFTP.ASM
;
; TFTP file transfer code for TCP/IP NID.
;===================================================================

;--------------------------------------------------------------------
; TransferFile
;
; Main BOOTP processing loop.
;
;--------------------------------------------------------------------
Proc TransferFile

	push	ds
	pop	es			; es = ds

	call	PrintCRLF

	cmp	[Verbose], 0		; are we in verbose mode?
	jne	@@doIt			; yes

	mov	bx, offset tx_TFTP
	call	Print
	jmp	@@skip

@@doIt:
	mov	bx, offset tx_Transfering
	call	Print

;	mov	bx, 3
;	call	AIChangeReceiveMask	; enable broadcast reception

	mov	bx, [NamePtr]		; get pointer to file name
	call	Print			; print image file name

	mov	al, ' '
	call	PrintChar

@@skip:
	mov	[Counter], 1
	call	PrintTransferValue	; update screen counter

	mov	ax, 1000h		; BootWare load segment
	cmp	[Protocol], IP_BINL	; are we doing TCP/IP BINL?
	jne	@@notBINL

	mov	ax, 7c0h		; PXE load segment

@@notBINL:
	; set starting pointer for image (1000:0)
	mov	[word ptr Transfer+2], ax
	mov	[word ptr Transfer], 0

	mov	[PacketNum], 0

	mov	[TFTP.Size], size OpenTFTPStruct
	mov	[TFTP.Flags], 1		; enable large block size
	mov	eax, [GatewayIP]
	mov	[(TFTP.Gateway)], eax
	mov	eax, [ServerIP]
	mov	[TFTP.Address], eax
	mov	ax, [NamePtr]
	mov	[TFTP.FileName], ax
	mov	[(TFTP.FileName)+2], ds
	mov	[word ptr TFTP.Callback], offset TFTPCallback
	mov	[(word ptr TFTP.Callback)+2], cs

	mov	di, offset TFTP
	call	AIOpenTFTP		; transfer the file
	or	ax, ax			; was there an error?
	je	@@notIP			; no error

	push	ax
	call	PrintCRLF
	mov	bx, offset ErrorMsg
	call	Print			; print "Error: "

	pop	ax
	cmp	ax, 25			; IP error?
	jne	@@notIP

	mov	bx, offset tx_CantResolve
	call	Print

	lea	si, [GatewayIP]
	cmp	[GatewayIP], 0		; is there a gateway?
	jne	isGW

	lea	si, [ServerIP]

isGW:
	call	PrintIP

	xor	ax, 1			; set flags to return with error

@@notIP:
	ret

endp

;--------------------------------------------------------------------
; TftpCallback
;
; Callback function for TFTP transfer.
;
; Parameters:
;	ax - packet type
;	bx - packet number
;	cx - packet size
;	es:di - pointer to data
;
; Returns:
;	ax - status
;--------------------------------------------------------------------
Proc TftpCallback far

	push	ds			; save caller ds

	push	cs
	pop	ds			; set ds = cs

	cmp	ax, -2			; is this a timeout callback?
	jne	notTimeout		; no

	call	Timeout
	jmp	callbackExit

notTimeout:
	call	ProcessPacket
	or	ax, ax			; was there an error?
	jne	callbackExit		; yes

	call	PrintTransferValue	; update screen counter

	inc	[PacketNum]		; increase packet number

	xor	ax, ax			; return "no error"

callbackExit:
	pop	ds			; restore ds
	ret				; status returned in ax

endp

;--------------------------------------------------------------------
; CheckTimeout
;
; Parameters:
;	none
;
; Returns:
;	ax = 0 if ok
;--------------------------------------------------------------------
Proc Timeout

	mov	ah, 1
	int	16h			; check keyboard for a key
	jz	noKey2			; no key pressed

	xor	ax, ax
	int	16h			; read keyboard

	cmp	ax, 011Bh		; ESC code
	je	timeoutDone		; ESC - time's up

noKey2:
	inc	[Counter]
	call	PrintTransferValue	; update screen

	add	cx, 9			; add half second to time out

	xor	ax, ax			; clear return status
	cmp	[Counter], 20		; have we reached retry limit?
	jne	timeoutOK		; no

timeoutDone:
	inc	ax			; return error value

timeoutOK:
	ret

endp

;--------------------------------------------------------------------
; ProcessPacket
;
; Parameters:
;	es:di - pointer to data
;	bx - packet number
;	cx - packet size
;
; Returns:
;	ax = 0 if ok
;--------------------------------------------------------------------
Proc ProcessPacket

	cmp	ax, 5			; is this an error packet
	jne	no_error		; nope
	call	ErrorTFTP		; handle the error

tftp_error:
	mov	ax, -1
	ret				; return with error

no_error:
	cmp	ax, 3			; is this a data packet
	jne	tftp_error		; nope

	;------------------------------------------------------------
	; Copy data from packet into memory
	;------------------------------------------------------------
	cmp	[PacketNum], 0		; is this the first packet?
	jne	not_first		; no

	call	CheckAPI		; check if image uses the ROMs API

	call	CheckExtended		; check if extended image
	jc	tftp_error		; there was an error

not_first:
	cmp	[HeadSize], 0		; data left in header?
	jne	saveHeader		; yes put data in conventional RAM

	cmp	[ExtFlag], 1		; are we using extended memory
	je	doExtended		; copy to extended memory

	call	CopyRam			; copy all to convetional RAM
	jc	tftp_error		; if error - send NAK
	jmp	processOK		; no error - done

saveHeader:
	mov	ax, cx			; save total size in ax
	cmp	[HeadSize], cx		; do we have more data then needed?
	ja	moreTogo

	mov	cx, [HeadSize]

moreTogo:
	sub	[HeadSize], cx

notExtended:
	call	CopyRam			; copy to convetional RAM
	jc	tftp_error		; if error - send NAK

	add	di, cx			; update new starting offset

	sub	ax, cx			; subtract what we saved from total
	cmp	ax, 0
	je	processOK		; nothing remaining
	mov	cx, ax

doExtended:
	call	CopyExtended		; put packet in extended RAM
	jc	tftp_error		; if error - send NAK

processOK:
	xor	ax, ax
	ret				; return with no error

endp

;--------------------------------------------------------------------
; CheckAPI
;
; Checks the contents of the first packet received to see if the image
; is a BWAPI image, if it is we set a flag to not disengage the ROM.
;
; Parameters:
;	es:di - pointer to packet data
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc CheckAPI

	cmp	[word ptr es:di+2], 'WB'
	jne	notAPI			; look for "BWAPI" at offset 2

	cmp	[word ptr es:di+4], 'PA'
	jne	notAPI

	mov	[NoDisengage], 1	; set flag to not disengage

notAPI:
	ret

endp

;--------------------------------------------------------------------
; CheckExtended
;
; Checks the contents of the first packet received to see if the image
; should be saved in extended memory.
;
; Parameters:
;	es:di - pointer to packet data
;
; Returns:
;	ax = 0 if OK
;--------------------------------------------------------------------
Proc CheckExtended

	; look for extended memory signature
	cmp	[word ptr es:di+14], 'xE'
	jne	not_extended		; no signature

	cmp	[word ptr es:di+16], 'xT'
	jne	not_extended		; no signature

	mov	ah, 88h
	int	15h			; get extended memory size

	cmp	[es:di+12], ax		; compare with size of image
	ja	exterror		; not enough memory

	mov	ax, [es:di+10]		; get size of header code
	mov	[HeadSize], ax		; save header size
	mov	[ExtFlag], 1		; set extended memory flag

	mov	[ExtendedAddress], 0	; set starting extended memory address
	mov	[ExtendedAddress+2], 11h

not_extended:
	clc
	ret				; return no error

exterror:
	mov	bx, offset tx_extmemerror
	call	PrintError

	stc
	ret				; return with error

endp

;--------------------------------------------------------------------
; CopyRam
;
; Copies image into conventional RAM.
;
; On entry:
;	cx - size to copy
;	es:di pointer to data packet
;
; Returns:
;	carry clear - everything OK
;	carry set - something went wrong
;--------------------------------------------------------------------
Proc CopyRam

ifdef TSR
	clc				; clear carry for OK
	ret
endif

	push	ax
	push	cx			; save count
	push	di			; save data address

	push	es			; save data segment
	push	ds			; save our ds

	; set ds:si to packet address, es:di to RAM address
	mov	si, di			; move source address into si
	push	es
	les	di, [Transfer]		; get RAM pointer into es:di
	pop	ds			; ds = packet segment

	rep	movsb			; copy packet

	pop	ds			; restore our ds

	mov	ax, di			; move ending offset to ax
	mov	cl, 16			; divide offset into a paragraph
	div	cl			; number

	xor	cx, cx			; cx = 0
	xchg	cl, ah			; cx is new offset,
					; ax is paragraph count

	mov	bx, es			; add paragraphs to segment
	add	bx, ax

	mov	[word ptr Transfer], cx	; save new offset
	mov	[word ptr Transfer+2], bx	; save new segment

	pop	es			; restore our es

	;------------------------------------------------------------
	; Check new segment to make sure the image is not going to
	; over write our code.  If it is print error message and
	; set error state.
	;------------------------------------------------------------
	mov	ax, cs			; get our current code segment
	cmp	bx, ax
	jb	copyRamOk		; not going to over write

	mov	bx, offset tx_toolarge
	call	PrintError		; error: "Image file too large."

	stc				; set carry for error
	jc	copyRamExit

copyRamOk:
	clc				; clear carry for OK

copyRamExit:
	pop	di			; restore data pointer
	pop	cx			; restore packet size
	pop	ax
	ret

endp

;--------------------------------------------------------------------
; CopyExtended
;
; Copies image into extended RAM.
;
; On entry:
;	cx - size to copy
;	es:di pointer to data
;
; Returns:
;	carry clear - everything OK
;	carry set - something went wrong
;--------------------------------------------------------------------
Proc CopyExtended

	push	es			; save es
	pusha				; save all registers

	;------------------------------------------------------------
	; Source address must be converted to 24 bit address for
	; extended memory INT15 copy function
	;------------------------------------------------------------
	push	cx			; save packet size
	push	di			; save packet address
	push	es			; save packet segment

	push	ds
	pop	es			; es = our segment

	mov	di, offset GDT		; get GDT location
	mov	cx, (size DESCRIPTOR)/2
	xor	ax, ax
	rep	stosw			; zero the GDT (es:di)

	pop	ax			; ax = packet segment
	pop	bx			; bx = packet offset
	xor	dx, dx			; dx = 0
	mov	cx, 16
	mul	cx			; dx:ax = ax * 16
	add	ax, bx			; add offset
	adc	dx, 0			; dx:ax is now 24 bit source address

	pop	cx			; get copy bytes size
	push	cx			; save it again

	mov	[GDT.SourceLimit], cx	; set copy size
	mov	[GDT.TargetLimit], cx	; set copy size
	mov	[GDT.SourceRights], 93h	; set copy rights
	mov	[GDT.TargetRights], 93h	; set copy rights

	mov	[GDT.SourceLoWord], ax	; set source address lo word
	mov	[GDT.SourceHiByte], dl	; set source address hi byte

	mov	ax, [ExtendedAddress]	; get 24 bit extended memory address
	mov	dx, [ExtendedAddress+2]
	mov	[GDT.TargetLoWord], ax	; set dest address low word
	mov	[GDT.TargetHiByte], dl	; set dest address hi byte

	inc	cx
	shr	cx, 1			; now cx is word count
	mov	si, offset GDT		; address of GDT (ds:di)
	mov	ah, 87h
	int	15h			; move data to/from extended memory

	pop	cx			; restore byte count in CX

	pushf				; save INT15 status

	add	[ExtendedAddress], cx	; calc next address
	adc	[ExtendedAddress+2], 0

	popf				; restore INT15 status

	popa				; restore registers
	pop	es			; restore es
	ret				; return - carry set/cleared in INT15

endp

;--------------------------------------------------------------------
; ErrorTFTP
;
; Something is wrong with the TFTP transfer.
;
; Parameters:
;	ds:di - pointer to packet
;
;--------------------------------------------------------------------
Proc ErrorTFTP

	mov	si, di
	mov	di, offset StringBuffer

err_loop:				; copy error message into local memory
	lodsb
	stosb
	or	al, al			; was a null moved?
	jne	err_loop

	call	PrintCRLF
	mov	bx, offset tx_error
	call	Print

	mov	bx, offset StringBuffer
	call	Print

	ret

endp

;--------------------------------------------------------------------
; Check4SecureMode
;
; Checks if TFTP secure mode is enabled, if it is then the path
; is removed from the file name returned from the BOOTP/DHCP server.
;
;--------------------------------------------------------------------
Proc Check4SecureMode

	cmp	[byte ptr si], 0	; check first character of name
	je	noName			; no file name specified

	;------------------------------------------------------------
	; Check for secure mode, if so then we only want the file name.
	;------------------------------------------------------------
	test	[IPFeature], 1		; check for secure mode 
					; clear = non secure, set = secure
	jz	notSecure		; nope

	mov	di, si			; save path start in di

	; find the end of the file name
findEnd:
	inc	si
	cmp	[byte ptr si], 0
	jne	findEnd

	; now scan back to find the beginning of the name
findStart:
	cmp	si, di			; at start of path string?
	je	notSecure		; yep, there is no /
	dec	si
	mov	al, [si]		; get character
	cmp	al, '\'
	je	foundIt
	cmp	al, ':'
	je	foundIt
	cmp	al, '/'
	jne	findStart

foundIt:
	inc	si

notSecure:
	mov	[NamePtr], si		; save pointer to file name

noName:
	ret

endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\loader\loader.asm ===
;----------------------------------------------------------------------------
; loader.asm
;
; Loader code for Goliath.  This code is based (a lot) on Microsoft's
; NTLDR as it is loaded by their NT boot sector.
;
;$History: LOADER.ASM $
; 
; *****************  Version 4  *****************
; User: Paul Cowan   Date: 10/08/98   Time: 4:28p
; Updated in $/Client Boot/Goliath/Loader
; Removed startup banner.
; 
; *****************  Version 3  *****************
; User: Paul Cowan   Date: 27/07/98   Time: 4:41p
; Updated in $/Client Boot/Goliath/Loader
; Changed displayed version number.
;
;----------------------------------------------------------------------------
ideal
_IDEAL_ = 1

Segment Code para public use16
	Assume	cs:code, ds:code

include "loader.inc"

Struc	NICInfo
	VendorID	dw	?
	DeviceID	dw	?
	Offset		dd	?
	DataSize	dw	?
ends

Struc	UNDIHdr
			dw	?
	ID		dd	?
	Size		dw	?
	Ver		dw	?
	Patches		db	?, ?, ?, ?
			dw	?
	SizeHdr		dw	?
	SizeCode	dw	?
	SizeData	dw	?
	SizeBSS 	dw	?
	LanOption	db	?
ends

FATSEG = 5000h
DIRSEG = 1000h

P386

;START_CODE

;==========================================================================
; LoaderEntry
;
; The first 512 bytes are loaded by the boot sector.  The boot sector
; jumps to the start of this code.  Throughout this code, DS remains
; the boot sector segment to use the BPB and disk read functions in
; the boot sector.
;
; Parameters (passed from boot sector):
;	ax =
;	bx = starting cluster
;	cx = 
;	dx = 
;	si = pointer to BPB
;	di = pointer to jump table
;	ds = 07C0h (boot sector segment)
;	es = 2000h
;
; The directory from the disk is in memory at 1000:0, this code has been
; loaded into 2000:0.
;
; Returns:
;	never does
;==========================================================================
Proc Start

	push	si			; save BPB pointer
	push	di			; save jump table pointer

	push	bx			; save file starting cluster

;	push	si			; save si
;	mov	si, offset Banner
;	call	PrintCS			; display program banner
;	pop	si			; restore si

	;------------------------------------------------------------
	; Read the FAT from the floppy into 5000:0h.
	;------------------------------------------------------------
	push	FATSEG
	pop	es			; es = FAT segment

	xor	bx, bx			; load offset = 0
	mov	cx, [si+3]		; get "reserved sectors" from BPB
	mov	[di+8], cx		; update starting sector to read
	mov	[word ptr di+10], 0
 	mov	ax, [si+0Bh]		; get "FAT sectors" from BPB
	call	[dword ptr di+4]	; call boot sector read function

	mov	ax, 0E2Eh
	int	10h			; print first "."

	pop	dx			; restore file starting cluster

	mov	ax, 2000h
	mov	es, ax			; load segment is 2000h

	call	LoadFile		; load the remainder of this file

	pop	di			; restore jump table pointer
	pop	si			; restore BPB pointer
	jmp	Startup			; contine with remainder of loader

endp

;--------------------------------------------------------------------
; LoadFile
;
; Reads an entire file into memory by walking the FAT on the disk.
;
; Parameters:
;	si = pointer to BPB
;	di = pointer to jump table
;	dx = starting cluster
;	es = destination segment
;--------------------------------------------------------------------
Proc LoadFile

	xor	bx, bx			; load offset = 0

	; Two counters are used, al and ah.  ah is the total number of
	; clusters we can read, it starts at 128 which is 64K of data.
	; al is the number of clusters we want to read.
	mov	ah, 128			; ah = number of clusters we can read

readLoop:
	push	dx			; save cluster number
	mov	al, [si+2]		; get "sectors per cluster"
	sub	ah, [si+2]		; subtract from total
	cmp	dx, 0FFFFh		; last cluster?
	jne	more			; no - more to load
	pop	dx			; clean stack
	jmp	fileLoaded		; we are done - start the file

	; Scan the FAT for the file.  If consecutive clusters are found
	; they are done with a single read call.
more:
	mov	cx, dx			; cx = current cluster
	call	ReadFAT			; get next cluster from FAT
	inc	cx			
	cmp	dx, cx			; consecutive cluster?
	jne	doRead			; no
	cmp	ah, 0			; can we read more at this time?
	jne	loc_4			; sure
	mov	ah, 128			; restore ah = 128
	jmp	doRead

loc_4:
	add	al, [si+2]		; add "sectors per cluster"
	sub	ah, [si+2]		; decrease sectors we can read
	jmp	more			; check next cluster

doRead:
	pop	cx			; get current cluster
	push	dx			; save next cluster value
	mov	dx, cx			; dx = current cluster

	mov	cx, 10			; retry count

readRetry:
	push	bx
	push	ax			; save cluster count
	push	dx			; save cluster number
	push	cx			; save retry counter
	call	[dword ptr di]		; read disk clusters
	jnc	readOK			; jump if no error

	; there was an error reading the disk
	xor	ax, ax
	int	13h			; reset disk
	
	xor	ax, ax			; ax =0
	int	13h			; reset disk
	
	xor	ax, ax			; ax = 0

delay:
	dec	ax
	jnz	delay

	pop	cx
	pop	dx
	pop	ax
	pop	bx
	dec	cx			; decrease retry count
	jnz	readRetry		; jump if retries not up

	mov	si, offset error	; pointer to message
	call	PrintCS			; print error message

	jmp	$			; hang

readOK:
	mov	ax, 0E2Eh
	int	10h			; print second "."

	pop	cx
	pop	dx
	pop	ax
	pop	bx
	pop	dx
	mov	cl, al			; cl = cluster read count
	xor	ch, ch			; ch = 0
	shl	cx, 9			; divide cluster count by 512
	add	bx, cx			; update load offset
	jz	changeSeg		; jump if over segment
	jmp	readLoop			; continue loading file

changeSeg:
	mov	ax, es			; get current segment
	add	ax, 1000h		; change segment
	mov	es, ax
	mov	ah, 80h
	jmp	readLoop		; continue loading file

fileLoaded:
	ret

endp

;--------------------------------------------------------------------
; ReadFAT
;
; Reads a value from the FAT in memory.
;
; Parameters:
;	dx = current cluster
;--------------------------------------------------------------------
Proc ReadFAT

	push	bx			; save bx
	push	ds			; save ds

	push	FATSEG
	pop	ds			; set ds to FAT segment

	; current cluster * 1.5
	mov	bx, dx			; bx = current cluster
	shr	dx, 1			; divide cluster by 2
	pushf				; save flags
	add	bx, dx			;

	mov	dx, [bx]		; get next link
	popf				; restore flags
	jc	loc_12			; Jump if carry Set
	and	dx, 0FFFh		; keep lower 3 nibbles
	jmp	loc_13

loc_12:
	shr	dx, 4			; keep upper 3 nibbles

loc_13:
	cmp	dx, 0FF8h		; "end of file" found?
	jb	readFatExit		; no
	mov	dx, 0FFFFh		; return "end of file"

readFatExit:
	pop	ds			; restore ds
	pop	bx			; restore bx
	ret

endp

;--------------------------------------------------------------------
; PrintCS
;
; Prints a string from the code segment.
;
; Parameters:
;	cs:si - pointer to string
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc PrintCS

	mov	al, [cs:si]		; get character
	inc	si
	or	al, al			; found NULL?
	jz	printDone		; found end of message
	mov	ah, 0Eh
	mov	bx, 7
	int	10h			; print character
	jmp	printCS			; do next character

printDone:
	ret

endp

;Banner	db 'BootWare Goliath Beta 2', 0

Error	db 13, 10
	db 'Goliath: I/O error reading disk', 13, 10
	db '         Please insert another disk', 13, 10, 0

org	510
	dw	offset DataTable	; pointer to data table

;--------------------------------------------------------------------
; Startup
;
; Entry function after entire file has been loaded into memory.
;
; Parameters:
;	si = pointer to BPB
;	di = pointer to jump table
;	ds = bootsector segment
;--------------------------------------------------------------------
Proc Startup

	mov	ax, 0E2Ah
	int	10h			; print "*"

	call	LoadLanguage		; load the language file

	push	cs
	pop	ds			; ds = cs

	jnc	noLang			; jump if no language was loaded

	mov	[Info.LangSeg], es	; save language segment

noLang:
	call	CheckPCI		; check for a PCI adapter
	call	CheckISA

	mov	si, offset CRLF
	call	Print
	mov	si, offset NoAdapter
	call	Print			; display "No adapter found"
	jmp	$			; hang the PC

endp

;--------------------------------------------------------------------
; LoadLanguage
;
; Parameters:
;	si = pointer to BPB
;	di = pointer to jump table
;	ds = bootsector segment
;
; Returns:
;	carry set if file loaded
;	es = language segment
;--------------------------------------------------------------------
Proc LoadLanguage

	xor	bx, bx			; bx = 0					; Zero register
	mov	cx, [si+6]		; get max root directory entries

	push	DIRSEG
	pop	es			; set es to directory segment

	push	ds			; save ds
	push	cs
	pop	ds			; ds = current segment

	push	si
	push	di

scanDirLoop:							
	mov	di, bx			; directory entry offet into di
	push	cx			; save cx
	mov	cx, 11			; file name size
	mov	si, offset LangFile
	repe	cmpsb			; look for file name
	pop	cx			; restore cx
	jz	foundEntry		; jump if found
	add	bx, 20h			; next directory offset
	loop	scanDirLoop		; check next entry

foundEntry:
	pop	di
	pop	si
	pop	ds			; restore original ds
	jcxz	noEntry			; exit if entry not found

	; Calc the segment needed to locate the language file
	; at the very top of memory.
	push	es			; save current es
	push	0
	pop	es			; es = 0

	mov	dx, [es:413h]		; get current memory size
	sub	dx, 4			; keep 4K
	shl	dx, 6			; convert to segment

	pop	es			; restore es
	mov	ax, [es:bx+1Ah]		; get file starting cluster
	push	ax			; save it

	mov	eax, [es:bx+1Ch]	; get file size
	mov	cx, 16
	div	cl			; divide into paragraphs
	inc	al
	xor	ah, ah
	sub	dx, ax			; subtract size from top segment

	mov	es, dx			; es = new segment

	pop	dx			; restore starting cluster
	call	LoadFile

	cmp	[word ptr es:60], 'CP'	; check ID string
	jne	noEntry

	stc				; return carry set - file loaded
	ret

noEntry:
;	mov	si, offset NoLangFile
;	call	PrintCS			; print "Warning: Language file not.."
	clc				; return carry clear - no file loaded
	ret

endp

;--------------------------------------------------------------------
; CheckISA
;
; Parameters:
;	none
;
; Returns:
;	only if no adapter is found
;--------------------------------------------------------------------
include "5x9.asm"

Proc CheckISA

	call	Detect5X9
	jnc	noISA

	mov	ebx, [Offset5X9]          ; source offset
	mov	cx, [Size5X9]             ; file size

	jmp	RelocateUNDI

noISA:
	ret

endp

;--------------------------------------------------------------------
; CheckPCI
;
; Parameters:
;	none
;
; Returns:
;	only if no adapter is found
;--------------------------------------------------------------------
Proc CheckPCI

	mov	ax, 0b101h
	int	1ah			; are we running on a PCI PC?

	cmp	edx, ' ICP'		; did we get PCI?
	je	isPCI			; we have PCI!

	ret

isPCI:
	mov	di, offset NICs
	call	FindPCINIC		; check UNDI table
	jnc	notFound		; not found

	mov	[Info.PCIBusDevFunc], bx
	mov	[Info.VendorID], dx
	mov	[Info.DeviceID], cx

	mov	ebx, [(NICInfo di).Offset]; source offset
	mov	cx, [(NICInfo di).DataSize]; cx = file size

	jmp	RelocateUNDI

notFound:
	ret				; return - no adapter found

endp

;--------------------------------------------------------------------
; FindPCINIC
;
; Look for a PCI adapter in the PCI based on a table of supported
; vendor and device IDs.
;
; Parameters:
;	di - pointer to NIC table
;
; Returns:
;	bx - PCI Bus/Device/Function numbers
;	cx - device ID
;	dx - vendor ID
;	di - pointer to entry in NIC table
;	carry set if adapter found
;--------------------------------------------------------------------
Proc FindPCINIC

findLoop:
	mov	dx, [(NICInfo di).VendorID]; get vendor ID from table
	cmp	dx, 0
	je	endLoop

	mov	cx, [(NICInfo di).DeviceID]; get device ID from table

	mov	si, 0			; Device Index (0-n).
	mov	ax, 0B102h		; find PCI device
	int	1Ah			; try and find PCI device

	jnc	found			; found a device

	add	di, size NICInfo
	jmp	findLoop		; do next device

endLoop:
	clc				; clear carry - not found
	ret

found:
	stc				; set carry - adapter found
	ret

endp

;--------------------------------------------------------------------
; RelocateUNDI
;
; Relocates an UNDI to top of memory.  The UNDI has a header attached
; to the beginning of it.
;
; Parameters:
;	ebx - UNDI offset in file
;	cx - UNDI size
;--------------------------------------------------------------------
Proc RelocateUNDI

	shr	ebx, 4
	mov	ax, cs
	add	bx, ax
	mov	es, bx			; set es to UNDI segment

	cmp	[(UNDIHdr es:0).ID], 'IDNU'; check identifer
	je	gotUNDI

	mov	si, offset _noUNDI
	call	Print
	jmp	$			; hang

gotUNDI:
	push	cx			; save UNDI size

	mov	bx, [Info.LangSeg]	; get segment of language module
	cmp	bx, 0			; do we have an language module?
	jne	notTop			; yes

	; no language module was loaded so determine our segment from
	; top of memory
	push	es
	push	0
	pop	es			; es = 0
	mov	bx, [es:413h]		; get current memory size
	sub	bx, 4			; keep 4K
	shl	bx, 6			; convert to segment
	pop	es

notTop:
	; get the size of the UNDI code and data segment from the header
	mov	ax, [(UNDIHdr es:0).SizeCode]; get UNDI code size
	mov	[Info.UNDICode], ax	; save it to pass to BootWare

	mov	cx, [(UNDIHdr es:0).SizeData]
	add	cx, [(UNDIHdr es:0).SizeBSS]
	mov	[Info.UNDIData], cx	; save total data size
	add	ax, cx			; add UNDI data size to code size

	shr	ax, 4			; divide size into paragraphs
	inc	al			; plus one for remainder
	sub	bx, ax			; subtract from top segment
	mov	[Info.UNDISeg], bx	; save UNDI segment

	pop	cx			; get UNDI size

	push	ds			; save ds
	push	es			; save es

	push	es
	pop	ds			; ds = UNDI current segment
	mov	es, bx			; es = new segment

	; copy UNDI to new segment
	xor	di, di			; destination offset
	mov	si, [(UNDIHdr ds:0).SizeHdr]
	rep	movsb			; relocate the UNDI

	;------------------------------------------------------------
	; Copy adapter ID string into the BootWare module.
	;------------------------------------------------------------
	lea	si, [(UNDIHdr ds:0).LanOption]

	push	cs
	pop	es			; es = our segment

	mov	di, [cs:BWOffset]
	add	di, 4

copyID:
	lodsb
	stosb
	cmp	al, 0			; end of string?
	jne	copyID			; no

	pop	es			; restore es
	pop	ds			; restore ds

	;------------------------------------------------------------
	; Now relocate the BootWare module below the UNDI.
	;------------------------------------------------------------
	mov	si, [BWOffset]
	mov	ax, [si+2]		; get size from module
	shr	ax, 4			; divide by 16
	sub	bx, ax			; subtract from UNDI segment

	mov	es, bx			; es is new segment
	mov	cx, [BWSize]		; get our code size
	mov	si, [BWOffset]
	xor	di, di
	rep	movsb			; relocate our code

	mov	si, offset Info		; get address of LoaderInfo structure

	push	es			; setup continuation address on stack
	push	0

	retf				; jump to relocated BootWare

endp

_noUNDI	db	"UNDI not found.", 0

;--------------------------------------------------------------------
; Print
;
; Prints a string from the code segment.
;
; Parameters:
;	cs:si - pointer to string
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Proc Print

	push	es			; save ds
	push	bx			; save bx

	cmp	[Info.LangSeg], 0	; did we load a language?
	je	notLang			; no

	mov	bx, [Info.LangSeg]
	mov	es, bx			; set es to language segment

	cmp	si, offset NoAdapter
	jne	notLang
	
	mov	bx, [es:66]		; get address from language module
	cmp	bx, 0			; did we get a pointer?
	je	notLang			; no

	mov	si, bx			; set new pointer
	jmp	printLoop

notLang:
	push	ds
	pop	es			; set es to our segment

printLoop:
	mov	al, [es:si]
	inc	si
	or	al, al			; found NULL?
	jz	done			; found end of message
	mov	ah, 0Eh
	mov	bx, 7
	int	10h			; print character
	jmp	printLoop		; do next character

done:
	pop	bx			; restore bx
	pop	es			; restore ds
	ret

endp

;====================================================================
LangFile	db 'GOLIATH DAT'
CRLF		db 7, 13, 10, 0
;NoLangFile	db 7, 13, 10, "Warning: Language file not found.", 0
NoAdapter	db "Error: No supported adapter found!", 0

Info		LoaderInfo <?>

align 16
DataTable:
BWSize		dw	0		; size of common BootWare module
BWOffset	dw	0		; starting offset of BootWare

Size5X9         dw	0
Offset5X9       dd	0

;	   VendorID, DeviceID, Offset, Size
NICs	NICInfo <>

	db	0

org	2047
	db	0

ends
end Start
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\loader\5x9.asm ===
;--------------------------------------------------------------------
; BW5X9.ASM
;
; 3Com 3C509/3C509B detection support for the loader.
;
;--------------------------------------------------------------------
include "vulcan.inc"

;--------------------------------------------------------------------
; Detect a 3C5X9 NIC
;
;       Carry Flag set if found.
;       or
;       Carry Flag cleared if not found.
;
;--------------------------------------------------------------------
Proc    Detect5X9

        ; Preserve the environment.
        pushad
        push    ds
        push    es

        sti
        cld
	call	Find_Vulcan

        ; Restore the original environment.
        pop     es
        pop     ds
        popad

        ret

endp    Detect5X9

;--------------------------------------------------------------------
;
;   Find_Vulcan: 
;
;   On Entry:
;
;	sti
;	cld
;
;   On Exit:
;       Carry Flag set if found.
;       or
;       Carry Flag cleared if not found.
;
;--------------------------------------------------------------------

proc    Find_Vulcan

	cli

;-----------------------------------------------------------------------------
;  ISA-specific init code
;-----------------------------------------------------------------------------

		mov    dx, ID_PORT
		call   Write_ID_Sequence 		 ; IDS enters ID_CMD state

		mov    al, SET_TAG_REGISTER + 0		 ; 04-06-92
		out    dx, al				 ; 04-06-92, untag adapter

; look for the first adapter and activate it.  we will use contention test to
; make sure there is at least 1 Vulcan on system bus and activate the first
; Vulcan adapter we find.

		mov    al, EE_MANUFACTURER_CODE
		call   Contention_Test			 ; read EISA manufacturer ID
		cmp    ax, EISA_MANUFACTURER_ID		 ; is it 3Com's EISA ID?
		je     isa_vlucan_found

		sti
                clc
		ret

isa_vlucan_found:
		sti
                stc
		ret

endp    Find_Vulcan

;-----------------------------------------------------------------------------
;   Write_ID_Sequence:
;
;		   This routine writes ID sequence to the specified ID port
;		   on Vulcan adapter; when the complete ID sequence has been
;		   written, the ID sequence State Machine (IDS) enters the
;		   ID_CMD state.  This routine is called when IDS is in
;		   ID_WAIT state.
;
;   On Entry:
;		   dx = the ID port desired (1x0h)
;
;   On Exit:
;		   dx = preserved
;		   ax, cx are not preserved
;-----------------------------------------------------------------------------

proc    Write_ID_Sequence

       mov    al, 0
       out    dx, al				 ; to setup new ID port
       out    dx, al
       mov    cx, 0ffh				 ; 255-byte sequence
       mov    al, 0ffh				 ; initial value of sequence

wr_id_loop:
       out    dx, al
       shl    al, 1
       jnc    wr_id
       xor    al, 0cfh
wr_id:
       loop   wr_id_loop

       ret

endp    Write_ID_Sequence

;--------------------------------------------------------------------
;
;   Contention_Test: This routine, first, writes an "EEPROM Read Command" to
;		     ID port (dx), the write operation actually causes the
;		     content of the specified EEPROM data to be read into
;		     EEPROM data register.  Then it reads ID port 16 times
;		     and saves the results in ax.  During each read, the
;		     hardware drives bit 15 of EEPROM data register out onto
;		     bit 0 of the host data bus, reads this bit 0 back from
;		     host bus and if it does not match what is driven, then
;		     the IDS has a contention failure and returns to ID_WAIT
;		     state.  If the adapter does not experience contention
;		     failure, it will join the other contention tests when
;		     this routine is called again.
;
;		     Eventually, only one adapter is left in the ID_CMD state,
;		     so it can be activated.
;
;   On Entry:
;	      al = word of EEPROM data on which test will contend
;	      dx = ID port (to which ID sequence was written)
;	      cli
;
;   On Exit:
;	      ax = EEPROM data read back by hardware through contention test.
;	      dx = preserved
;	      bx = trashed
;	      cli
;
;--------------------------------------------------------------------
proc    Contention_Test

	push	bx
	push	cx
	push	dx

       add    al, READ_EEPROM			 ; select EEPROM data to
       out    dx, al				 ;  contend on

       cli
       ; seems to solve some problem when Init is ran a few times
       mov     cx, 3000h               ; 5 ms
       call    WaitTime
       sti

       mov    cx, 16				 ; read 16 times
       xor    bx, bx				 ; reset the result

contention_read:
       shl    bx, 1
       in     al, dx				 ; reading ID port causes
						 ;  contention test

       and    ax, 1				 ; each time, we read bit 0
       add    bx, ax
       loop   contention_read

       mov    ax, bx

       pop	dx
       pop	cx
       pop	bx
       ret

endp    Contention_Test

;--------------------------------------------------------------------
; WaitTime - CX has 2*1.1932 the number of microseconds to wait.
;	If CX is small, add 1 to compensate for asynchronous nature
;	of clock.  For example, for 10us, call with CX = 25
;
;  On entry,
;	ints off (especially if CX is small, and accuracy needed)
;  On exit,
;	CX modified
;
; 911223 0.0 GK
;--------------------------------------------------------------------

proc    WaitTime

         	push	ax
		push	bx
		call	ReadTimer0		; get Timer0 value in AX
         	mov	bx, ax			; save in BX

ReadTimer0Loop:
         	call	ReadTimer0
         	push	bx
         	sub	bx, ax
         	cmp	bx, cx
         	pop	bx
         	jc	ReadTimer0Loop
         
		pop	bx
		pop	ax
		ret

endp    WaitTime

proc    ReadTimer0

         	mov	al, 6
         	out	43h, al 		; port 43h, 8253 wrt timr mode 3
         	call	RT0
         
RT0:
         	jmp	short $+2
         	jmp	short $+2
         	jmp	short $+2
         	in	al, 40h 		; port 40h, 8253 timer 0 clock
		xchg	ah, al
		ret

endp    ReadTimer0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\rbfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RBFG.RC
//
#define PB_OK                           1
#define IDS_VERSION                     1
#define PB_CANCEL                       2
#define IDS_TITLE                       2
#define PB_ABOUT                        3
#define IDS_INVALIDFILE                 4
#define IDS_COPYRIGHT                   5
#define IDS_DATAVER                     6
#define IDS_ERRFILERD1                  7
#define IDS_ERRFILERD2                  8
#define IDS_ERROR                       9
#define ST_INFO                         10
#define IDS_ERRFORMAT                   10
#define IDS_ERRFILEWR1                  11
#define IDS_WRITE                       12
#define IDS_READ                        13
#define PB_DRIVEA                       100
#define PB_DRIVEB                       101
#define PB_ADAPTERS                     1005
#define ST_VERSION                      1008
#define ST_DATAVERSION                  1009
#define ST_COPYRIGHT                    1010
#define PB_CREATE                       1011
#define ST_LANGUAGEVERSION              1013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\rbfg\main.cpp ===
#define STRICT
#define _UNICODE
#include <windows.h>
#include <windowsx.h>
#include "rbf1\rbf1.h"
//#include "rbf2\rbf2.h"
#include "resource.h"

#define cbMaxSz  4095

TCHAR szString[cbMaxSz];

typedef struct
{
	WORD	Bytes;
	BYTE	ClusterSectors;
	WORD	Reserved;
	BYTE	Fats;
	WORD	Root;
	WORD	Sectors;
	BYTE	Descript;
	WORD	FatSectors;
	WORD	TrackSectors;
	WORD	Heads;
} BPBSTRUCT;

typedef struct
{
	char	Name[8];
	char	Ext[3];
	BYTE	Attribute;
	char	Reserved[10];
	WORD	Time;
	WORD	Date;
	WORD	Cluster;
	long	Size;
} DIRSTRUCT;

void Start (HWND);
void CreateDisk (HWND, int);
int  WriteBootSector (HWND, int);
int  EraseDisk (HANDLE, BPBSTRUCT *);
int  WriteDataFile (HWND, int);
//int  WriteLanguageFile (HWND, int, int);

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK MainDlgProc (HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK AdapterDlgProc (HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK AboutDlgProc (HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK StatusDlgProc (HWND, UINT, WPARAM, LPARAM);

HINSTANCE Inst;
HWND WndMain;
int Language;

ADAPTERINFO *Info;

ADAPTERINFO *GetAdapterList (void);
void  GetBootSector (LPSTR);
DWORD GetBootFile (HANDLE *);

//LANGINFO *GetLanguageList (void);
DWORD GetLanguage (int, HANDLE *);

/*-------------------------------------------------------------------
	WinMain

-------------------------------------------------------------------*/
int PASCAL WinMain (HINSTANCE inst, HINSTANCE h, LPSTR l, int q)
{
MSG  msg ;
WNDCLASS wndclass;
DWORD dw;

	Inst = inst;

	wndclass.style         = CS_HREDRAW | CS_VREDRAW;
	wndclass.lpfnWndProc   = WndProc;
	wndclass.cbClsExtra    = 0;
	wndclass.cbWndExtra    = 0;
	wndclass.hInstance     = inst;
	wndclass.hIcon         = LoadIcon (inst, MAKEINTRESOURCE (1));
	wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW);
	wndclass.hbrBackground = (HBRUSH) (COLOR_WINDOW+1);
	wndclass.lpszMenuName  = NULL;
	wndclass.lpszClassName = "NTFloppy";

	RegisterClass (&wndclass);

	dw = LoadString(inst, IDS_TITLE, szString, ARRAYSIZE( szString ));
	Assert( dw );
	WndMain = CreateWindow ("NTFloppy", szString,
		WS_OVERLAPPEDWINDOW, 0, 0, 0, 0, NULL, NULL, Inst, NULL);

	if (!WndMain)
		return 0;

	ShowWindow (WndMain, SW_SHOW);

	while (GetMessage (&msg, NULL, 0, 0))
	{
    	TranslateMessage (&msg);
    	DispatchMessage (&msg);
    }

	return msg.wParam;

}

/*-------------------------------------------------------------------
	WndProc

-------------------------------------------------------------------*/
LRESULT CALLBACK WndProc (HWND wnd, UINT msg, WPARAM wParam, LPARAM lParam)
{

	switch (msg)
	{
		case WM_CREATE:
			SendMessage (wnd, WM_USER, 0, 0);
			return TRUE;

		case WM_USER:
			Start (wnd);
			DestroyWindow (wnd);
			return 0;

		case WM_DESTROY:
        	PostQuitMessage (0);
        	return 0;

    }

	return DefWindowProc (wnd, msg, wParam, lParam);
}

/*-------------------------------------------------------------------
	Start

-------------------------------------------------------------------*/
void Start (HWND wnd)
{
	TCHAR szBuf[50];
	DWORD dw;

	Info = GetAdapterList ();

	if (Info->Version != 1)
	{
		dw = LoadString(Inst, IDS_INVALIDFILE, szBuf, ARRAYSIZE(szBuf));
		Assert( dw );
		dw = LoadString(Inst, IDS_TITLE, szString, ARRAYSIZE( szString ));
		Assert( dw );
		MessageBox (wnd, szBuf, szString, MB_OK | MB_ICONSTOP);
		return;
	}

	DialogBox (Inst, MAKEINTRESOURCE (1), wnd, (DLGPROC)MainDlgProc);

}

/*-------------------------------------------------------------------
	MainDlgProc

-------------------------------------------------------------------*/
LRESULT CALLBACK MainDlgProc (HWND wnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
int i;

	switch (msg)
	{
		case WM_INITDIALOG:
			if (GetDriveType ("b:\\") == 1)
				EnableWindow (GetDlgItem (wnd, PB_DRIVEB), FALSE);

			Button_SetCheck (GetDlgItem (wnd, PB_DRIVEA), TRUE);

			return TRUE;

		case WM_COMMAND:
			switch (GET_WM_COMMAND_ID (wParam, lParam))
			{
				case PB_ADAPTERS:
					DialogBox (Inst, MAKEINTRESOURCE (10), wnd, (DLGPROC)AdapterDlgProc);
					return 0;

				case PB_ABOUT:
					DialogBox (Inst, MAKEINTRESOURCE (5), wnd, (DLGPROC)AboutDlgProc);
					return 0;

				case PB_CREATE:
					i = (Button_GetCheck (GetDlgItem (wnd, PB_DRIVEA))) ? 0:1;
					CreateDisk (wnd, i);
					return 0;

				case PB_CANCEL:
					EndDialog (wnd, TRUE);
					return 0;

			} // switch wParam
			break;
    }

	return FALSE;
}

/*-------------------------------------------------------------------
	AdapterDlgProc

-------------------------------------------------------------------*/
LRESULT CALLBACK AdapterDlgProc (HWND wnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
int i;

	switch (msg)
	{
		case WM_INITDIALOG:
			for (i = 0; i < Info->NICCount; i++)
				ListBox_AddString (GetDlgItem (wnd, 10), Info->NICS[i].Name);

			return TRUE;

		case WM_COMMAND:
			switch (GET_WM_COMMAND_ID (wParam, lParam))
			{
				case PB_OK:
					EndDialog (wnd, TRUE);
					return 0;

			} // switch wParam
			break;
    }

	return FALSE;
}

/*-------------------------------------------------------------------
	AboutDlgProc

-------------------------------------------------------------------*/
LRESULT CALLBACK AboutDlgProc (HWND wnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
TCHAR s[256];
DWORD dw;

	switch (msg)
	{
		case WM_INITDIALOG:
			dw = LoadString(Inst, IDS_DATAVER, s, ARRAYSIZE(s));
			Assert( dw );
			wsprintf (szString, s, Info->DataVersion/256, Info->DataVersion&255);
			SetWindowText (GetDlgItem (wnd, ST_DATAVERSION), szString);

			dw = LoadString(Inst, IDS_VERSION, s, ARRAYSIZE(s));
			Assert( dw );
			SetWindowText (GetDlgItem (wnd, ST_VERSION), s);
			dw = LoadString(Inst, IDS_COPYRIGHT, s, ARRAYSIZE(s));
			Assert( dw );
			SetWindowText (GetDlgItem (wnd, ST_COPYRIGHT), s);

			return TRUE;

		case WM_COMMAND:
			switch (GET_WM_COMMAND_ID (wParam, lParam))
			{
				case PB_OK:
					EndDialog (wnd, TRUE);
					return 0;

			} // switch wParam
			break;
    }

	return FALSE;

}

/*-------------------------------------------------------------------
	CreateDisk

-------------------------------------------------------------------*/
void CreateDisk (HWND wnd, int drive)
{
HWND dlg;

	dlg = CreateDialog (Inst, MAKEINTRESOURCE (20), wnd, (DLGPROC)StatusDlgProc);

	SetCursor (LoadCursor (NULL, IDC_WAIT));

	if (WriteBootSector (wnd, drive))
	{
		if (WriteDataFile (wnd, drive))
		{
//			if (Language)
//				WriteLanguageFile (wnd, Language, drive);
		}
	}

	DestroyWindow (dlg);
	SetCursor (LoadCursor (NULL, IDC_ARROW));

}

/*-------------------------------------------------------------------
	StatusDlgProc

-------------------------------------------------------------------*/
LRESULT CALLBACK StatusDlgProc (HWND wnd, UINT msg, WPARAM wParam, LPARAM lParam)
{

	switch (msg)
	{
		case WM_INITDIALOG:
			return TRUE;

		case WM_COMMAND:
			switch (GET_WM_COMMAND_ID (wParam, lParam))
			{
				case PB_OK:
					EndDialog (wnd, TRUE);
					return 0;

			} // switch wParam
			break;
    }

	return FALSE;

}

/*-------------------------------------------------------------------
	WriteBootSector

-------------------------------------------------------------------*/
int WriteBootSector (HWND wnd, int drive)
{
char s[256];
TCHAR s1[256];
HANDLE device;
char dataBuffer[512];
LPSTR diskBuffer;
DWORD d;
DWORD dw;

	GetBootSector (dataBuffer);

	lstrcpy (s, "\\\\.\\?:");
	s[4] = (char)('A' + drive);

	device = CreateFile (s, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (device == INVALID_HANDLE_VALUE)
		return FALSE;

	diskBuffer = (LPSTR)VirtualAlloc (NULL, 512, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	SetFilePointer (device, 0, NULL, FILE_BEGIN);

	if (!ReadFile (device, diskBuffer, 512, &d, NULL))
	{
		d = GetLastError ();
		dw = LoadString(Inst, IDS_ERRFILERD1, s1, ARRAYSIZE(s1));
		Assert( dw );
		wsprintf (szString, s1, d);
		dw = LoadString(Inst, IDS_READ, s1, ARRAYSIZE(s1));
		Assert( dw );
		MessageBox (GetActiveWindow (), szString, s1, MB_OK);
		return FALSE;
	}

	if (*(WORD *)&diskBuffer[510] != 0xAA55)
	{
		dw = LoadString(Inst, IDS_ERRFILERD2, s1, ARRAYSIZE(s1));
		Assert( dw );
		dw = LoadString(Inst, IDS_ERROR, szString, ARRAYSIZE( szString ));
		Assert( dw );
		MessageBox (wnd, s1, szString, MB_ICONSTOP | MB_OK);

		CloseHandle (device);
		VirtualFree (diskBuffer, 0, MEM_RELEASE);
		return FALSE;
	}

	if (memcmp (&diskBuffer[0x0b], &dataBuffer[0x0b], sizeof (BPBSTRUCT)))
	{
		dw = LoadString(Inst, IDS_ERRFORMAT, s1, ARRAYSIZE(s1));
		Assert( dw );
		dw = LoadString(Inst, IDS_ERROR, szString, ARRAYSIZE( szString ));		
		Assert( dw );
		MessageBox (wnd, s1, szString, MB_ICONSTOP | MB_OK);

		CloseHandle (device);
		VirtualFree (diskBuffer, 0, MEM_RELEASE);
		return FALSE;
	}

	memcpy (diskBuffer, dataBuffer, 512);

	SetFilePointer (device, 0, NULL, FILE_BEGIN);

	if (!WriteFile (device, diskBuffer, 512, &d, NULL))
	{
		d = GetLastError ();
		dw = LoadString(Inst, IDS_ERRFILEWR1, s1, ARRAYSIZE(s1));
		Assert( dw );
		wsprintf (szString, s1, d);
		dw = LoadString(Inst, IDS_WRITE, s1, ARRAYSIZE(s1));
		Assert( dw );
		MessageBox (GetActiveWindow (), szString, s1, MB_OK);
		return FALSE;
	}

	EraseDisk (device, (BPBSTRUCT *)&diskBuffer[0x0b]);

	CloseHandle (device);

	VirtualFree (diskBuffer, 0, MEM_RELEASE);

	return TRUE;

}

/*-------------------------------------------------------------------
	EraseDisk

-------------------------------------------------------------------*/
int EraseDisk (HANDLE device, BPBSTRUCT *bpb)
{
int dirSize, fatSize;
HANDLE hFat, hDir;
LPSTR fat, dir;
DWORD d;
DIRSTRUCT *p;

	dirSize = bpb->Root * 32;
	fatSize = bpb->FatSectors * bpb->Bytes;

	hFat = GlobalAlloc (GHND, fatSize);
	fat = (LPSTR)GlobalLock (hFat);

	fat[0] = bpb->Descript;		// copy disk descriptor to FAT
	fat[1] = (BYTE)255;
	fat[2] = (BYTE)255;

	hDir = GlobalAlloc (GHND, dirSize);
	dir = (LPSTR)GlobalLock (hDir);

	p = (DIRSTRUCT *)dir;
	lstrcpy (p->Name, "Lanworks");
	p->Attribute = 8;

	SetFilePointer (device, 512, NULL, FILE_BEGIN);

	WriteFile (device, fat, fatSize, &d, NULL);
	WriteFile (device, fat, fatSize, &d, NULL);

	WriteFile (device, dir, dirSize, &d, NULL);

	GlobalUnlock (hFat);
	GlobalFree (hFat);
	GlobalUnlock (hDir);
	GlobalFree (hDir);

	return TRUE;
}

/*-------------------------------------------------------------------
	WriteDataFile

-------------------------------------------------------------------*/
int WriteDataFile (HWND wnd, int drive)
{
HANDLE h;
LPSTR p;
DWORD len, d;
HANDLE device;
char s[25];

	len = GetBootFile (&h);

	p = (LPSTR)GlobalLock (h);

	lstrcpy (s, " :\\GOLIATH");
	s[0] = (char)('A' + drive);

	device = CreateFile (s, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	WriteFile (device, p, len, &d, NULL);

	CloseHandle (device);

	GlobalUnlock (h);
	GlobalFree (h);

	return TRUE;
}

/*-------------------------------------------------------------------
	WriteLanguageFile

-------------------------------------------------------------------*
int WriteLanguageFile (HWND wnd, int x, int drive)
{
HANDLE h;
LPSTR p;
DWORD len, d;
HANDLE device;
char s[25];

	len = GetLanguage (x, &h);

	p = (LPSTR)GlobalLock (h);

	lstrcpy (s, " :\\GOLIATH.DAT");
	s[0] = (char)('A' + drive);

	device = CreateFile (s, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	WriteFile (device, p, len, &d, NULL);

	CloseHandle (device);

	GlobalUnlock (h);
	GlobalFree (h);

	return TRUE;

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\loader\vulcan.inc ===
;------ VULCAN.INC ----------------------------------------------------------;
;									     ;
;	This file contains Vulcan-specific equates, structures and	     ;
;	macros.  It must be assembled with MASM 5.1 or later.		     ;
;									     ;
;----------------------------------------------------------------------------;
;----------------------------------------------------------------------------;
;									     ;
;	This source file is the property of 3Com Corporation and may not be  ;
;	copied or distributed in any isomorphic form without an appropriate  ;
;	prior licensing arrangement with 3Com Corporation.		     ;
;									     ;
;	Copyright (c) 1988 3Com Corporation				     ;
;									     ;
;	3Com Corporation						     ;
;	5400 Bayfront Plaza, P.O. Box 58145				     ;
;	Santa Clara, CA 95052-8145 USA					     ;
;	(408) 764-6016							     ;
;									     ;
;----------------------------------------------------------------------------;

;
; the compatibility level of this driver
;
CLEVEL		    equ 0

;------ Equates -------------------------------------------------------------;
;
; Command code masks
;
CMD_CMDMASK	    equ 0F800h			; command bits
CMD_ARGMASK	    equ 007FFh			; argument bits
;
; Command codes, word form
;
CMD_GLOBALRESET     equ 00000b shl 11		; global reset
CMD_SELECTWINDOW    equ 00001B shl 11		; select register window
CMD_STARTINTXCVR    equ 00010b shl 11		; start internal transciver
CMD_RXDISABLE	    equ 00011b shl 11		; rx disable
CMD_RXENABLE	    equ 00100b shl 11		; rx enable
CMD_RXRESET	    equ 00101b shl 11		; rx reset
CMD_RXDISCARD	    equ 01000b shl 11		; rx discard top packet
CMD_TXENABLE	    equ 01001b shl 11		; tx enable
CMD_TXDISABLE	    equ 01010b shl 11		; tx disable
CMD_TXRESET	    equ 01011b shl 11		; tx reset
CMD_REQUESTINT	    equ 01100b shl 11		; request interrupt
CMD_ACKNOWLEDGE     equ 01101b shl 11		; acknowledge interrupt
CMD_SETINTMASK	    equ 01110b shl 11		; set interrupt mask
CMD_SETRZMASK	    equ 01111b shl 11		; set read zero mask
CMD_SETRXFILTER     equ 10000b shl 11		; set rx filter
CMD_SETRXEARLY	    equ 10001b shl 11		; set rx early threshold
CMD_SETTXAVAILABLE  equ 10010b shl 11		; set tx available threshold
CMD_SETTXSTART	    equ 10011b shl 11		; set tx start threshold
CMD_STATSENABLE     equ 10101b shl 11		; statistics enable
CMD_STATSDISABLE    equ 10110b shl 11		; statistics disable
CMD_STOPINTXCVR     equ 10111b shl 11		; start internal transciver
;
; Command codes, hibyte form (commands without operands only)
;
CMDH_STARTINTXCVR   equ CMD_STARTINTXCVR shr 8
CMDH_RXDISABLE	    equ CMD_RXDISABLE shr 8
CMDH_RXENABLE	    equ CMD_RXENABLE shr 8
CMDH_RXDISCARD	    equ CMD_RXDISCARD shr 8
CMDH_TXENABLE	    equ CMD_TXENABLE shr 8
CMDH_TXDISABLE	    equ CMD_TXDISABLE shr 8
CMDH_REQUESTINT     equ CMD_REQUESTINT shr 8
CMDH_STATSENABLE    equ CMD_STATSENABLE shr 8
CMDH_STATSDISABLE   equ CMD_STATSDISABLE shr 8
CMDH_STOPINTXCVR    equ CMD_STOPINTXCVR shr 8
;
; Status register bits (INT for interrupt sources, ST for the rest)
;
INT_LATCH	    equ 00001h			; interrupt latch
INT_ADAPTERFAIL     equ 00002h			; adapter failure
INT_TXCOMPLETE	    equ 00004h			; tx complete
INT_TXAVAILABLE     equ 00008h			; tx available
INT_RXCOMPLETE	    equ 00010h			; rx complete
INT_RXEARLY	    equ 00020h			; rx early
INT_REQUESTED	    equ 00040h			; interrupt requested
INT_UPDATESTATS     equ 00080h			; update statistics
ST_FAILED	    equ 00800h			; command failed
ST_BUSY 	    equ 01000h			; command busy
ST_WINDOW	    equ 0E000h			; window bits (13-15)

STH_FAILED	    equ ST_FAILED shr 8
STH_BUSY	    equ ST_BUSY shr 8
STH_WINDOW	    equ ST_WINDOW shr 8

ifdef REV0
INT_OFFTXCOMPLETE   equ ((NOT (INT_TXCOMPLETE or INT_ADAPTERFAIL or INT_UPDATESTATS)) and (0FFh))
ifdef NDIS
INT_ONTXCOMPLETE    equ (INT_TXCOMPLETE or INT_UPDATESTATS)
else
INT_ONTXCOMPLETE    equ ((NOT INT_ADAPTERFAIL) and (0FFh))
endif

else
INT_OFFTXCOMPLETE   equ ((NOT (INT_TXCOMPLETE)) and (0FFh))
ifdef NDIS
INT_ONTXCOMPLETE    equ INT_TXCOMPLETE
else
;940107INT_ONTXCOMPLETE    equ MASK_NONE
endif
endif
;
; RxStatus register bits, both forms
;
RXS_INCOMPLETE	    equ 8000h			; not completely received
RXS_ERROR	    equ 4000h			; error in packet
RXS_LENGTH	    equ 07FFh			; bytes in RxFIFO
RXS_ERRTYPE	    equ 3800h			; Rx error type, bit 13-11
ifdef REV0
RXS_OVERRUN	    equ 0000h			; overrun error
RXS_DRIBBLE	    equ 0800h			; dribble bit
RXS_CRC 	    equ 1000h			; CRC error
RXS_RUNT	    equ 1800h			; runt packet error
RXS_OVERSIZE	    equ 2000h			; oversize packet error
RXS_FRAMING	    equ 2800h			; framing error
else
RXS_OVERRUN	    equ 0000h			; overrun error
RXS_OVERSIZE	    equ 0800h			; oversize packet error
RXS_DRIBBLE	    equ 1000h			; dribble bit (not an error)
RXS_RUNT	    equ 1800h			; runt packet error
RXS_CRC 	    equ 2800h			; CRC error
RXS_FRAMING	    equ 2000h			; framing error
endif

RXSH_INCOMPLETE     equ RXS_INCOMPLETE shr 8
RXSH_ERROR	    equ RXS_ERROR shr 8
RXSH_ERRTYPE	    equ RXS_ERRTYPE shr 8
RXSH_OVERRUN	    equ RXS_OVERRUN shr 8
RXSH_DRIBBLE	    equ RXS_DRIBBLE shr 8
RXSH_CRC	    equ RXS_CRC shr 8
RXSH_RUNT	    equ RXS_RUNT shr 8
RXSH_OVERSIZE	    equ RXS_OVERSIZE shr 8
RXSH_FRAMING	    equ RXS_FRAMING shr 8
;
; TxStatus register bits
;
TXS_COMPLETE	    equ 80h			; tx completed
TXS_INTREQUESTED    equ 40h			; interrupt on successfull tx
TXS_ERRTYPE	    equ 38h			; error bits
TXS_JABBERERROR     equ 20h			; jabber error
TXS_UNDERRUN	    equ 10h			; tx underrun error
TXS_MAXCOLLISIONS   equ 08h			; max collisions error
TXS_STATUSOVERFLOW  equ 04h			; TX status stack is full
;
; Window Numbers
;
WNO_SETUP	    equ 0			; setup/configuration
WNO_OPERATING	    equ 1			; operating set
WNO_STATIONADDRESS  equ 2			; station address setup/read
WNO_FIFO	    equ 3			; FIFO management
WNO_DIAGNOSTICS     equ 4			; diagnostics
WNO_READABLE	    equ 5			; registers set by commands
WNO_STATISTICS	    equ 6			; statistics
;
; Port offsets, Window 1
;
PORT_CmdStatus	    equ 0Eh			; command/status
PORT_TxFree	    equ 0Ch			; free transmit bytes
PORT_TxStatus	    equ 0Bh			; transmit status (byte)
PORT_Timer	    equ 0Ah			; latency timer (byte)
PORT_RxStatus	    equ 08h			; receive status
PORT_RxFIFO	    equ 00h			; RxFIFO read
PORT_TxFIFO	    equ 00h			; TxFIFO write
;
; Port offsets, Window 0
;
PORT_EEData	    equ 0Ch			; EEProm data register
PORT_EECmd	    equ 0Ah			; EEProm command register
PORT_CfgResource    equ 08h			; resource configuration
PORT_CfgAddress     equ 06h			; address configuration
PORT_CfgControl     equ 04h			; configuration control
PORT_ProductID	    equ 02h			; product id (EISA)
PORT_Manufacturer   equ 00h			; Manufacturer code (EISA)
;
; Port offsets, Window 2
;
PORT_SA0_1	    equ 00h			; station address bytes 0,1
PORT_SA2_3	    equ 02h			; station address bytes 2,3
PORT_SA4_5	    equ 04h			; station address bytes 4,5
;
; Port offsets, Window 3
;
PORT_ALT_TxFree     equ 0Ch			; free transmit bytes (dup)
PORT_RxFree	    equ 0Ah			; free receive bytes
PORT_RomControl     equ 04h			; 940425 RomControl Register

;
; Port offsets, Window 4
;
PORT_MediaStatus    equ 0Ah			; media type/status
PORT_SlingshotStatus equ 08h			; Slingshot status
PORT_NetDiagnostic  equ 06h			; net diagnostic
PORT_FIFODiagnostic equ 04h			; FIFO diagnostic
PORT_HostDiagnostic equ 02h			; host diagnostic
PORT_TxDiagnostic   equ 00h			; tx diagnostic
;
; Port offsets, Window 5
;
PORT_RZMask	    equ 0Ch			; read zero mask
PORT_IntMask	    equ 0Ah			; interrupt mask
PORT_RxFilter	    equ 08h			; receive filter
PORT_RxEarly	    equ 06h			; rx early threshold
PORT_TxAvailable    equ 02h			; tx available threshold
PORT_TxStart	    equ 00h			; tx start threshold
;
; Port offsets, Window 6
;
PORT_TXBYTES	    equ 0Ch			; tx bytes ok
PORT_RXBYTES	    equ 0Ah			; rx bytes ok
PORT_TXDEFER	    equ 08h			; tx frames deferred (byte)
PORT_RXFRAMES	    equ 07h			; rx frames ok (byte)
PORT_TXFRAMES	    equ 06h			; tx frames ok (byte)
PORT_RXDISCARDED    equ 05h			; rx frames discarded (byte)
PORT_TXLATE	    equ 04h			; tx frames late coll. (byte)
PORT_TXSINGLE	    equ 03h			; tx frames one coll. (byte)
PORT_TXMULTIPLE     equ 02h			; tx frames mult. coll. (byte)
PORT_TXNOCD	    equ 01h			; tx frames no CDheartbt (byte)
PORT_TXCARRIERLOST  equ 00h			; tx frames carrier lost (byte)
;
; Various command arguments
;
INT_ALLDISABLED 	equ 00000000000b	    ; all interrupts disabled
ifdef REV0
INT_ALLENABLED		equ 00011111100b	    ; all but AdapterFailure
else
INT_ALLENABLED		equ 00011111110b	    ; all interrupts enabled
endif

MASK_ALL		equ INT_ALLDISABLED
MASK_NONE		equ INT_ALLENABLED

FILTER_INDIVIDUAL	equ 0001b		    ; individual address
FILTER_MULTICAST	equ 0010b		    ; multicast/group addresses
FILTER_BROADCAST	equ 0100b		    ; broadcast address
FILTER_PROMISCUOUS	equ 1000b		    ; promiscuous mode

RXEARLY_DISABLED	equ 2032		    ; RxEarly to disable

TXAVAIL_DISABLED	equ 2040		    ; TxAvailable to disable
TXAVAIL_MIN		equ 4

TXSTART_DISABLED	equ 2040		    ; TxStart to disable
TXSTART_MIN		equ 0
MAX_TXSTART		equ TXSTART_DISABLED

MAX_RXLENGTH		equ 1792		    ; maximum rxlength

TXRXRESET_ALLBUTBM      equ 0100b               ; DUMMY DUMMY This value is copied
						; from 59xp even though it doesn't
						; exist on isa board

;
; Transmit Preamble
;
PREAMBLESIZE		equ 4			    ; transmit preamble size
TXP_INTONSUCCESS	equ 8000h		    ; interrupt on successful tx
;
; Bits in various diagnostics registers
;
MEDIA_TP		equ 8000h		    ; TP transciever
MEDIA_BNC		equ 4000h		    ; Thinnet transciever
MEDIA_INTENDEC		equ 2000h		    ; internal encoder/decoder
MEDIA_SQE		equ 1000h		    ; SQE present
MEDIA_LBEAT		equ 0800h		    ; link beat ok (TP)
MEDIA_POLARITY		equ 0400h		    ; polarity (TP)
MEDIA_JABBER		equ 0200h		    ; jabber (TP)
MEDIA_UNSQUELCH 	equ 0100h		    ; unsquelch (TP)
MEDIA_LBEATENABLE	equ 0080h		    ; link beat enable (TP)
MEDIA_JABBERENABLE	equ 0040h		    ; jabber enable (TP)
MEDIA_CRS		equ 0020h		    ; carrier sense
MEDIA_COLLISION 	equ 0010h		    ; collision
MEDIA_SQEENABLE 	equ 0008h		    ; enable SQE statistics

NETD_EXTLOOPBACK	equ 8000h		    ; TP external loopback
NETD_ENDECLOOPBACK	equ 4000h		    ; ENDEC loopback
NETD_CORELOOPBACK	equ 2000h		    ; ethernet core loopback
NETD_FIFOLOOPBACK	equ 1000h		    ; FIFO loopback
NETD_TXENABLED		equ 0800h		    ; tx enabled
NETD_RXENABLED		equ 0400h		    ; rx enabled
NETD_TXTRANSMITTING	equ 0200h		    ; tx transmitting
NETD_TXRESETREQD	equ 0100h		    ; tx reset required

FIFOD_RXRECEIVING	equ 8000h		    ; rx receiveing
FIFOD_RXUNDERRUN	equ 2000h		    ; rx underrun
FIFOD_RXSTATUSOVER	equ 1000h		    ; rx status overrun
FIFOD_RXOVERRUN 	equ 0800h		    ; rx overrun
FIFOD_TXOVERRUN 	equ 0400h		    ; tx overrun
FIFOD_BISTRESULTS	equ 00FFh		    ; BIST results (mask)

SLING_TXUNDERRUN	equ 2000h		    ; Slingshot TxUnderrun bit
;
; board identification codes, byte swapped in Rev 0
;
ifdef REV0
EISA_MANUFACTURER_ID	equ 0506Dh		    ; EISA manufacturer code
ISA_PRODUCT_ID		equ 05090h		    ; Product ID for ISA board
PRODUCT_ID_MASK 	equ 0FFF0h		    ; Mask off revision nibble
else
EISA_MANUFACTURER_ID	equ 06D50h		    ; EISA manufacturer code
ISA_PRODUCT_ID		equ 09050h		    ; Product ID for ISA board
PRODUCT_ID_MASK 	equ 0F0FFh		    ; Mask off revision nibble
endif
;
; EEProm access
;
EE_BUSY 		    equ 8000h			; EEProm busy bit in EECmd
EE_TCOM_NODE_ADDR_WORD0     equ 00h
EE_TCOM_NODE_ADDR_WORD1     equ 01h
EE_TCOM_NODE_ADDR_WORD2     equ 02h
EE_VULCAN_PROD_ID	    equ 03h
EE_MANUFACTURING_DATA	    equ 04h
EE_SERIAL_NUMBER_WORD0	    equ 05h
EE_SERIAL_NUMBER_WORD1	    equ 06h
EE_MANUFACTURER_CODE	    equ 07h
EE_ADDR_CONFIGURATION	    equ 08h
EE_RESOURCE_CONFIGURATION   equ 09h
EE_OEM_NODE_ADDR_WORD0	    equ 0Ah
EE_OEM_NODE_ADDR_WORD1	    equ 0Bh
EE_OEM_NODE_ADDR_WORD2	    equ 0Ch
EE_SOFTWARE_CONFIG_INFO     equ 0Dh
EE_CWORD		    equ 0Eh
EE_CHECKSUM		    equ 0Fh
EE_CAPABILITIES		    equ	010h
;
; contention logic
;
ID_PORT 		equ 110h
READ_EEPROM		equ 080h
SET_TAG_REGISTER	equ 0D0h
TEST_TAG_REGISTER	equ 0D8h
ACTIVATE_AND_SET_IO	equ 0E0h
ACTIVATE_VULCAN 	equ 0FFh
;
; Resource Configuration Register bits
;
RCONFIG_IRQ		equ 0F000h
;
; Address Configuration Register bits
;
ACONFIG_XCVR		equ 0C000h
ACONFIG_IOBASE		equ 0001Fh
ACONFIG_ROM		equ 03f00h
ACONFIG_ROMSIZE 	equ 03000h
ACONFIG_ROMBASE 	equ 0f00h
;

IOBASE_EISA		equ 0001Fh

TP_XCVR 		equ 00000h
BNC_XCVR		equ 0C000h
AUI_XCVR		equ 04000h

MIN_IO_BASE_ADDR	equ 200h
MAX_IO_BASE_ADDR	equ 3F0h
REGISTER_SET_SIZE	equ 10h
;
; Software Configuration Register bits
;
SW_OPTIMIZE		equ 0030h
SW_MAXCLI		equ 3F00h		; Maximum Modem Speed
SW_LINKBEAT		equ 4000h
SW_BPROT		equ 00007h
SW_CONFIG		equ 00008h		; NOT assigned yet 0=enable, 1=disable
SW_DEFAULT		equ 040h		; 0 = network, 1 = disable
SW_RS			equ 080h		; 1 = enable, 0=disable
SW_BOOTWARE		equ SW_BPROT OR SW_CONFIG OR SW_DEFAULT OR SW_RS	 ; all the bits assigned to BootWare



;
; Possibilities for SW_OPTIMIZE
;
OPTIMIZE_DOS_CLIENT	equ 0010h
OPTIMIZE_WINDOWS_CLIENT equ 0020h
OPTIMIZE_SERVER 	equ 0030h
;
; Configuration Control Register bits
;
ENABLE_ADAPTER		equ 01h
;
; Possibilities for SW_MAXCLI ( Max Modem Speed )
; GY 931007
MODEM_NONE		equ	03F00h
MODEM_1200		equ	03300h
MODEM_2400		equ	02700h
MODEM_9600		equ	01300h
MODEM_19200		equ	0900h
MODEM_38400		equ	0400h
;
; Possible values for SW_BPROT
;
BOOTPROT_UNINIT 	equ 0	; means "virgin" board. Default to 802.2
BOOTPROT_NW_8022	equ 1
BOOTPROT_NW_EII 	equ 2
BOOTPROT_NW_8023	equ 3
BOOTPROT_RPL		equ 4
BOOTPROT_TCPIP		equ 5		; for BW5X9 overlay
BOOTPROT_BOOTP		equ 5
BOOTPROT_DHCP		equ 6

;
; Bus Types
;
BUS_ISA 		equ	1		; ISA card in  ISA mode on ISA	machine
BUS_EISA		equ	2		; EISA card
BUS_MCA 		equ	3		; MCA  card
BUS_EISA_ISAMODE	equ	4		; ISA card in  ISA mode on EISA machine
BUS_EISA_EISAMODE	equ	5		; ISA card in EISA mode on EISA machine
BUS_EISA_ISA2EISA	equ	6		; ISA card on EISA bus switch from ISA->EISA
BUS_EISA_EISA2ISA	equ	7		; ISA card on EISA bus switch from EISA->ISA
BUS_PCI			equ	8		; PCI card

; Current Fail and Warning Level
LEVEL_FAIL		equ	0		; current Fail Level
LEVEL_WARNING		equ	0		; current Warning Level

; RomControl register bits (select 16K ROM Page) Windows 3/Port 5
RomPage0		equ	0
RomPage1		equ	100h
RomPage2		equ	200h
RomPage3		equ	300h
RomPageMask		equ	0fcffh

; 940923 ModeBits, contains system & adapter setting
ModeV2		equ	1
ModeNonISA	equ	4
ModeMCA		equ	8
ModeEISA	equ	10h
ModePCI		equ	20h
ModePnP		equ	40h
ModeAtmel	equ	80h

; 940923 Capabilities Word (EEPROM Offset 010h)
CAPA_PNP		equ	1
CAPA_FULLDUPLEX		equ	2
CAPA_BIGPACKET		equ	4
CAPA_SLAVEDMA		equ	8

;------ Structures ----------------------------------------------------------;
;
; TxStart structure
;
struc           TxStartStruc
txs_thresh	dw	?		; TxStart threshold (+CMD_SETTXSTART)
txs_min 	dw	?		; minimum threshold
txs_uTxOK	dw	?		; TxOK low word at last underrun
txs_uN		dw	?		; number of entries in uSum
txs_uSum	dw	?		; sum of uN x packets between underruns
ends            TxStartStruc

SIZE_TxStart	equ	SIZE TxStartStruc

;
; SelectWindow - select register window specified (must be a constant)
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
macro           SelectWindow wno
		mov	ax, CMD_SELECTWINDOW + wno 
		out     dx, ax
endm

;------ GENERAL.INC ---------------------------------------------------------;
;                                                                            ;
;       General purpose equates, structures and macros.                      ;
;                                                                            ;
;----------------------------------------------------------------------------;

FALSE           equ     0
TRUE            equ     0ffh
;
; I/O ports for the PICs
;
MASTER_MASK_PORT equ    021h
SLAVE_MASK_PORT equ     0A1h
;
; DOUBLEWORD - Thirty-two bit double word layout for sixteen bit word access
;
struc           doubleword
loword          dw      0               ; low order word
hiword          dw      0               ; high order word
ends            doubleword

;
; FARPOINTER - Thirty-two bit 286-style far pointer layout for segment and
;              offset access
;
struc           farpointer
off             dw      0               ; offset
segm            dw      0               ; segment or selector
ends            farpointer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\rbfg\rbf1\rbf1.cpp ===
#include <windows.h>
#include <crtdbg.h>
#include "resource.h"
#include "rbf1.h"

#define NUM_NICS 22
NICINFO NICS[NUM_NICS] = {
	{     0,      0, "3Com 3C509 ISA", 200},
	{0x10B7, 0x9050, "3Com 3C905-TX", 101},
	{0x10B7, 0x9051, "3Com 3C905-T4", 101},
	{0x10B7, 0x9000, "3Com 3C900-TP0", 101},
	{0x10B7, 0x9001, "3Com 3C900-Combo", 101},
	{0x10B7, 0x9004, "3Com 3C900B-TPO", 102},
	{0x10B7, 0x9005, "3Com 3C900B-Combo", 102},
	{0x10B7, 0x9055, "3Com 3C905B-TX", 102},
	{0x10B7, 0x9056, "3Com 3C905B-T4", 102},
	{0x10B7, 0x9058, "3Com 3C905B-Combo", 102},
	{0x10B7, 0x900A, "3Com 3C900B", 102},
	{0x10B7, 0x905A, "3Com 3C905B", 102},
	{0x10B7, 0x9006, "3Com 3C900B-TPC", 102},
	{0x10B8, 0x0005, "SMC 9432", 100},
	{0x8086, 0x1229, "HP DeskDirect 10/100 TX", 103},
	{0x8086, 0x1227, "Intel Pro 100+", 103},
	{0x8086, 0x1226, "Intel Pro 10+", 103},
	{0x8086, 0x1229, "Intel Pro 100B", 103},
	{0x1011, 0x0019, "DEC DE500", 105},
	{0x1011, 0x0014, "SMC 8432", 106},
	{0x1011, 0x0009, "SMC 9332", 107},
	{0x1022, 0x2000, "AMD PCnet", 104},
};

typedef struct
{
	WORD	VendorID;
	WORD	DeviceID;
	DWORD	Offset;
	WORD	DataSize;
} NICTABLE;

typedef struct
{
	WORD	BootWareSize;
	WORD	BootWareOffset;
	WORD	Size5x9;
	DWORD	Offset5x9;
	NICTABLE NICS[16];
} DATATABLE;

ADAPTERINFO Adapters = {1, 0x0100, NUM_NICS, &NICS[0]};

HINSTANCE Inst;

#define DllExport __declspec( dllexport )

DllExport ADAPTERINFO *GetAdapterList (void);
DllExport void GetBootSector (LPSTR);
DllExport DWORD GetBootFile (HANDLE *);

DWORD GetLoader (LPSTR);
DWORD GetBootWare (LPSTR);

/*-------------------------------------------------------------------
	DllMain

-------------------------------------------------------------------*/
BOOL WINAPI DllMain (HINSTANCE inst, DWORD reason, LPVOID p)
{

	if (reason == DLL_PROCESS_ATTACH)
		Inst = inst;

	return TRUE;

}

/*-------------------------------------------------------------------
 GetAdapterList

-------------------------------------------------------------------*/
ADAPTERINFO *GetAdapterList (void)
{
	return &Adapters;
}

/*-------------------------------------------------------------------
	GetBootSector

	Loads the boot sector from resource data.

-------------------------------------------------------------------*/
void GetBootSector (LPSTR p)
{
HGLOBAL h;
LPSTR data;

	h = LoadResource (Inst, FindResource (Inst, MAKEINTRESOURCE (ID_BOOTSECT), MAKEINTRESOURCE (100)));
	_ASSERTE (h != NULL);

	data = (LPSTR)LockResource (h);
	_ASSERTE (data != NULL);

	CopyMemory (p, data, 512);

	UnlockResource (h);

	FreeResource (h);

}

/*-------------------------------------------------------------------
	GetBootFile

-------------------------------------------------------------------*/
DWORD GetBootFile (HANDLE *mem)
{
HGLOBAL h, hMem;
LPSTR data, buffer;
HRSRC res;
DATATABLE *table;
DWORD size, offset, d;
int last = 0, count, i;

	size = 0;
	for (i = 0; i < NUM_NICS; i++)
	{
		if (NICS[i].Resource != last)
		{
			res = FindResource (Inst, MAKEINTRESOURCE (NICS[i].Resource), MAKEINTRESOURCE (500));
			_ASSERTE (res != NULL);
			size += SizeofResource (Inst, res);

			last = NICS[i].Resource;
		}
	}

	// allocate buffer for file
	hMem = GlobalAlloc (GHND, size+32768);
	_ASSERTE (hMem != NULL);
	buffer = (LPSTR)GlobalLock (hMem);

	// add Loader module
	size = GetLoader (buffer);

	// create a pointer to the loader adapter table
	d = *(WORD *)&buffer[510];
	table = (DATATABLE *)&buffer[d];

	offset = size;

	 // add BootWare module
	table->BootWareOffset = (WORD)size;
	size = GetBootWare (&buffer[size]);
	table->BootWareSize = (WORD)size;

	count = 0;
	for (i = 0; i < NUM_NICS; i++)
	{
		if (NICS[i].Resource != last)
		{
			offset += size;

			res = FindResource (Inst, MAKEINTRESOURCE (NICS[i].Resource), MAKEINTRESOURCE (500));
			_ASSERTE (res != NULL);
			h = LoadResource (Inst, res);
			_ASSERTE (h != NULL);

			data = (LPSTR)LockResource (h);
			size = SizeofResource (Inst, res);

			// copy data into buffer
			CopyMemory (&buffer[offset], data, size);

			// free the resource
			UnlockResource (h);
			FreeResource (h);
		}

		if (i == 0)
		{
			table->Offset5x9 = offset;
			table->Size5x9 = (WORD)size;
		}
		else
		{
			// record the starting location and size in the loader table
			table->NICS[count].VendorID = NICS[i].VendorID;
			table->NICS[count].DeviceID = NICS[i].DeviceID;
			table->NICS[count].Offset   = offset;
			table->NICS[count].DataSize = (WORD)size;

			count++;
		}

		last = NICS[i].Resource;
	}

	offset = (offset + size + 1) & 0xfffffffe;

	GlobalUnlock (hMem);

	*mem = hMem;

	return offset;
}

/*-------------------------------------------------------------------
	GetLoader

-------------------------------------------------------------------*/
DWORD GetLoader (LPSTR p)
{
HGLOBAL h;
HRSRC res;
DWORD len;
LPSTR data;

	// get loader.bin from resource data
	res = FindResource (Inst, MAKEINTRESOURCE (ID_LOADER), MAKEINTRESOURCE (100));
	_ASSERTE (res != NULL);
	h = LoadResource (Inst, res);
	_ASSERTE (h != NULL);

	data = (LPSTR)LockResource (h);
	len = SizeofResource (Inst, res);

	// copy loader into buffer
	CopyMemory (p, data, len);

	// free the loader resource
	UnlockResource (h);
	FreeResource (h);

	return len;
}

/*-------------------------------------------------------------------
	GetBootWare

-------------------------------------------------------------------*/
DWORD GetBootWare (LPSTR p)
{
HGLOBAL h;
HRSRC res;
DWORD len;
LPSTR data;

	// get BootWare.bin from resource data
	res = FindResource (Inst, MAKEINTRESOURCE (ID_BOOTWARE), MAKEINTRESOURCE (100));
	_ASSERTE (res != NULL);
	h = LoadResource (Inst, res);
	_ASSERTE (h != NULL);

	data = (LPSTR)LockResource (h);
	len = SizeofResource (Inst, res);

	// copy loader into buffer
	CopyMemory (p, data, len);

	// free the loader resource
	UnlockResource (h);
	FreeResource (h);

	// return length of data
	return len;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\rbfg\rbf1\rbf1.h ===
struct NICINFO
{
	WORD	VendorID;
	WORD	DeviceID;
	PSTR	Name;
	int		Resource;
};

struct ADAPTERINFO
{
	int		Version;
	int		DataVersion;
	int		NICCount;
	NICINFO *NICS;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\rbfg\rbf1\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rbf1.rc
//
#define ID_BOOTSECT                     1
#define ID_LOADER                       10
#define ID_BOOTWARE                     20

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\rbfg\rbf2\rbf2.cpp ===
#include <windows.h>
#include "rbf2.h"

#define NUM_LANG 2
LANGINFO Languages[NUM_LANG] = {
	{"English", 1},
	{"French",  2}};

HINSTANCE Inst;

#define DllExport __declspec( dllexport )

DllExport LANGINFO *GetLanguageList (void);
DllExport DWORD GetLanguage (int, HANDLE *);

/*-------------------------------------------------------------------
	DllMain

-------------------------------------------------------------------*/
BOOL WINAPI DllMain (HINSTANCE inst, DWORD reason, LPVOID p)
{

	if (reason == DLL_PROCESS_ATTACH)
		Inst = inst;

	return TRUE;

}

/*-------------------------------------------------------------------
 GetAdapterList

-------------------------------------------------------------------*/
LANGINFO *GetLanguageList (void)
{
	return &Languages[0];
}

/*-------------------------------------------------------------------
	GetLanguage

-------------------------------------------------------------------*/
DWORD GetLanguage (int index, HANDLE *mem)
{
HGLOBAL h, hMem;
LPSTR data;
HRSRC res;
DWORD size;
LPSTR p;

	if (index >= NUM_LANG)
		return 0;

	res = FindResource (Inst, MAKEINTRESOURCE (Languages[index].Resource), MAKEINTRESOURCE (100));
	if (res == 0)
		return 0;

	h = LoadResource (Inst, res);

	data = (LPSTR)LockResource (h);
	size = SizeofResource (Inst, res);

	hMem = GlobalAlloc (GHND, size);
	p = (LPSTR)GlobalLock (hMem);

	CopyMemory (p, data, size);

	GlobalUnlock (hMem);

	*mem = hMem;

	UnlockResource (h);
	FreeResource (h);

	return size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\bwstruct.inc ===
;====================================================================
; BWSTRUCT.INC
;
; Include for for BootWare, defines common structures.
;
; 970116 PC - first version
;====================================================================

;--------------------------------------------------------------------
; Common equates
;---------------------------------------------------------------------
FEATURE_LOCAL	equ	1
FEATURE_VIRUS	equ	2
FEATURE_MENU	equ	4
FEATURE_KEYWAIT	equ	8
FEATURE_FLOPPY	equ	64
FEATURE_HDRIVE	equ	128

;--------------------------------------------------------------------
; Event Descriptor (ED) Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc	ED
	Ptr		dw	?	; pointer to next ED
	Unused		dw	?	; spare word
	DestAddr	dw	?, ?, ?	; destination Address
	ErrCode		dw	?	; error code
	ErrMsg		dw	?	; pointer to error msg
	Length		dw	?	; total packet length
	FragCount	dw	?	; number of fragments
	FragOff		dw	?	; 1st fragment offset
	FragSeg		dw	?	; 1st fragment segment
	FragLen 	dw	?	; length of fragment
ends
ELSE
ED_Struct      STRUC
	ED_Ptr		dw	?	; pointer to next ED
	ED_Unused	dw	?	; spare word
	ED_DestAddr	dw	?, ?, ?	; destination address
	ED_ErrCode	dw	?       ; error code
	ED_ErrMsg	dw	?       ; Pointer to error msg
	ED_Length	dw	?	; total packet length
	ED_FragCount	dw	?	; Number of descriptors/fragments
	ED_FragOff	dw	?	; Descriptor Pointer
	ED_FragSeg	dw	?	; Descriptor Pointer
	ED_FragLen 	dw	?	; Length of packet descriptor
ED_Struct      ENDS
ENDIF

;--------------------------------------------------------------------
; Descricptor Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc Frag
	Off		dw	?	; offset of fragment
	Seg		dw	?	; segment of fragment
	Len		dw	?	; length of fragment
ends
ELSE
Frag Struc
	FragOff		dw	?	; offset of fragment
	FragSeg		dw	?	; segment of fragment
	FragLen		dw	?	; length of fragment
Frag ends
Descript_Struct STRUC
	DPointer	dd	?	; Descriptor Pointer
	DLen		dw	?	; Length of packet descriptor
Descript_Struct ends
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\rbfg\rbf2\rbf2.h ===
struct LANGINFO
{
	PSTR	Name;
	int		Resource;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\buildcfg.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/BUILDCFG.INV   1.2   19 Sep 1997 21:39:16   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: Compilation Switches used to build NDIS DOS, OS/2 driver
;

;
;   Description      :    Compilation Switches used to build the NDIS DOS
;                         and OS2 drivers.   Controls version numbers,
;                         default values for parameters, debug inclusion.
;
;                         This file will be included in all of the NDIS
;                         driver source files. Any changes to this file must
;                         (through makefile) force a complete remake of the
;                         entire driver.

.386

TRUE        Equ  1
FALSE       Equ  0


Ifndef DOS
DOSNDIS         Equ     FALSE
OS2NDIS         Equ     TRUE
Else
DOSNDIS         Equ     TRUE
OS2NDIS         Equ     FALSE
Endif

OS2             Equ     OS2NDIS
DOS             Equ     DOSNDIS

;- Switch to enable debug breakpoints (int 3)
DEBUG_BP             equ         FALSE

;- Switch to enable Early Receive Code
EARLY_RCV            equ         FALSE

;- Switch to enable Code Profiling
CODE_PROFILE         equ         FALSE

StratStack           equ         TRUE

;- when transmitter hangs, when should we reset?
TRANSMIT_TIMEOUT Equ     2

;- Interval (in seconds) between successive reads of SCB statistics
UPDATE_STATS_INTERVAL    equ     4

MAX_PACKET         Equ       1514      ; Maximum allowable packet size.
MIN_PACKET         Equ       60        ; Minimum allowable packet size.

;- Number Of Multicast Addresses Supported By This Driver
MAX_MULTICAST_ADDRESSES  equ     20

;- Optional data area in TCB for Flexible mode
TXCB_BUFFER_SIZE         equ     60

;- Transmit buffer size is max Eth Size (not incl. CRC) plus slop to 1536
TCB_SLOP                 equ     22
TCB_BUFFER_SIZE          equ     MAX_PACKET+TCB_SLOP

;- Receive buffer size is max Eth size plus CRC plus slop to 1536
RCB_SLOP                 equ     22
RCB_BUFFER_SIZE          equ     MAX_PACKET+RCB_SLOP

;- minimum number of Tx buffers and/or Rx buffers allowed to run driver.
MIN_TXRX_BUF_CTS         equ     2

;- Interframe Spacing 96 Tx Clocks
IFS_SPACING              equ     60h

;- Slot Time 512 Tx Clocks
SLOT_TIME                equ     200h

;- Default CUSTOM parameter values
DEFAULT_TXFIFO           equ     8
DEFAULT_RXFIFO           equ     8
DEFAULT_LINE_SPEED       equ     100
DEFAULT_ADAPTIVE_IFS     equ     0
DEFAULT_TXTHRESHOLD      equ     32
DEFAULT_FORCEFDX         equ     0
DEFAULT_IOMAPMODE        equ     0
DEFAULT_TXDMACOUNT       equ     0
DEFAULT_RXDMACOUNT       equ     0
DEFAULT_PHYADDRESS       equ     0FFh
DEFAULT_FRAME_GAP equ 6
FRAME_GAP_MIN equ  6
FRAME_GAP_MAX equ  15

IF DOS
DEFAULT_TXBUF_COUNT      equ     4
DEFAULT_RXBUF_COUNT      equ     8               ; v40
ENDIF

DEFAULT_CONGENB          equ     0               ; v0.49

USE_DEFAULT_VALUE        equ     (-1)

DEFAULT_MCWA_EventCount  equ     6               ; v44

;- used by timer tick interrupt routine to count out one second
TICKS_PER_SECOND         equ     18



;- this indicates the offset to add to get to the '$' in the driver name
;  '0123456789'
;  'E100B$'
DOLLAR_OFFSET            equ     5               ; v0.38

; TRANSMIT_CHECK equ 1


; EOF - $Workfile:   buildcfg.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\rbfg\rbf2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RBF2.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\nad5x9.asm ===
title	BootWare Boot PROM (C) Lanworks Technologies Inc.
	subttl	3C5x9 EtherLink III
	page	80,132

;************************************************************************
;* NAD5x9.ASM
;*	- Contains modules supporting the NetPC UNDI API for 3Com 5x9 family
;*
;* Modules included:-
;*	NADInit
;*	NADReset
;*	NADShutDown
;*	NADOpen
;*	NADClose
;*	NADSetFilter
;*	NADGetStatistics
;*	NADRequestINT
;*	NADMCastChange
;*	DriverISR_Proc
;*
;* Latest Update: 98
;************************************************************************


;====================================================================
;  5X9NAD.ASM - produces 3Com 3C5X9 EtherLink III version of BootWare
;
;    (C) Lanworks Technologies Inc. 1992 - 1997 All rights reserved.
;
;  Revision History - version numbers refer to 5X9.ASM changes only
;
;
;  970213 3.00  GY - combine CPYPAGE.ASM into this file
;		   - take out check for 286 machine
;  950318 1.71  GY - In NADTransmitPacket, error message pointer is incorrect
;  950123 1.71  GY - take out PIPXDataLen
;  950113 1.71  GY - Clean up RxPIO as suggested by JJ
;  940109 1.71  GY - Release v1.71 which is a patched version of v1.70.
;		     Changes:
;			1. RAMSegment = 5000h not 6000h for Pentium support
;			2. version/date chaged to v1.71 940109
;  941214 1.73  GY - CliBufferSize changed from 64 to 128 bytes. Allow
;		     us to store the whole BootWareTable
;  941213 1.72  GY - Change PEROM so that when BootWareTable is updated, 
;		     both page0 and page1 are updated.
;  941107 1.70  GY - Release version 1.70
;				   - (5X9CONF) BootP -> BOOTP 
;  941104 1.70  GY - In DriverISR when a ISR_IntRequest is found, we
; 		     Acknowledge interrupt and leave ISR. Previously, we
;		     stay in ISR and check if there is any other interrupt
;		     triggered. Solve problem where in some machines with V2,
;		     machine would hung at MSD: after continuous rebooting
;		     for a while (Gateway 486/66 and PS2/E)
;  941007 1.70  GY - For V2, strongly discourage them from using 8/16K ROMSize
;		     In Autoscan, if 8K/16K ROMSize is detected, dump err
;			msg and disable config. menu and ROMShield
;		     In ELNK3CONF, if user choose 8/16K, warn them but still
;			let them change
;  940923 1.66  GY - shrink code
;		   - see 5X9CONF
;		   - PEROMSDP didn't set romPage back to Page0. Cause a 
;		     problem with V2 boot (ROMShield on wrong page)
;		   - replace PEROMSDP with PEROM and AccessPEROM so that
;		     we can write data to Atmel, read/verify Product
; 		     Identification and enable SDP of Atmel
;		   - create EESoft2BWT and BWT2EESoft so that for V2 and
;		     Atmel PEROM, we fetch/save data to PEROM rather than
;		     to NIC EEPROM.
;		   - When ROMBase is changed, need to change ROMShield
;		     Int 13 pointer so that machine doesn't hang.
;		
;  940824 1.61  GY - Integrate McAfee ROMShield into 3C5X9.
;*		     Comments:
;*		     : ROMSH_19, ROMSH_AS are placed on 1st page
;*		     : ROMSH_13 is placed on 2nd page. Code is executed from
;*			ROM and because of the 800h header, all offsets on
;*			2nd page are off by 800hh.
;* 940629 1.60	GY - When a V2 is detected and ROMSize is NOT 8K, enable
;*		     PEROM data protection.
;* 940628 1.60	GY - When Ethernet_802.2U is detected, display message
;*		     to inform user. Press <ENTER> will enter ELNK3CONF
;*		     or wait 8s to boot 802.2
;* 940426 1.52	GY - Add support for OS/2 NetWare boot.
;*		     (CPYPAGE) ROM is moved 32K higher
;*		     (NWNID) BWAPI table, add pointer to NetworkSend,
;*			     ServerAddressTable. All NID calls are far
;*		     (5X9NAD) NAD calls are far routines
;* 940425 1.51	GY - (CPYPAGE) For V2 and virtual paging being used, need to
;*		     support Paging because ROM only appear in 16K window.
;*		     Add variable ASICVersion to distinguish V1 & V2.
;*		     (ROMTOP) Make sure 1st page of ROM is mapped.
;* 940413 1.51	GY - (ROMTOP) change Init_Vulcan so that it will work on
;*		     systems with PnP BIOS, non-PnP PROM (this one) and
;*		     non-PnP OS. Change:
;*		     : Init_Vulcan, use the IOBase I fetch from EEPROM word 8
;*		       and use it to activate the adapter
;*		     : Init_Vulcan, use IRQ from EEPROM word 9 and ignore
;*		       the one from Window 0. Write RCR to IOPort.
;* 940328 1.51	GY - CallBWAPI uses RET 2 rather than RET.
;*		   - Link with new BPCODE.INC for additional features on
;*		     TCP/IP.
;* 940324 1.51	GY - (5X9CONF) Fix problem with Farallon EtherWave
;*		     in InitSpecCase.
;  940314 1.50  GY - First release 
;   		    - Add BootWare Configuration Utility which allows users
;		      to change the configuration of the EtherLink III
;		      adapter (IOBase, IRQ, ROM Setting, Media, Driver Opti,
;		      Modem Speed) and the Boot Protocol Setting of BootWare
;		    - Support ISA, EISA, MCA 509
;		    - Autoconfigure IOBase and ROMBase setting if conflict 
;		      detected
;		    - Under Novell NetWare, default image file ELNK3.SYS
;		      is added in addition to NET$DOS.SYS.
;		    - Wildcard character (?) for network number and node
;		      address in BOOTCONF.SYS is supported
;		    - Support for NetWare, RPL and BootP is included in
;		      this BootWare. 
;  		    - By default, BootProt is UNINIT ( assume 802.2 ). Once
;		      Bootware is used to save any setting, BootProt will
;		      become 802.2, 802.3, II, RPL or TCPIP. 
;		    - change the way ROMSize of 8/16k is supported
;		      Scheme - : ROMTOP on every page
;				 ROMTOP will contain Init_Vulcan and code to
;				   expand ROM into 32k
;			       : ROMTOP for Page 0
;				 hook into Int C0 and C1 and replace with
;				   ISRRomSize which "shrink" PROM back to its
;				   original size
;				 Copy last 24k of PROM into RAM. Make sure
;				   that the ROMTOP portions of page1,2,3 are
;				   skipped
;			       : HookConfig
;				 Call ISRRomSize to shrink PROM back to
;				   8/16k
;====================================================================

ACR_MEDIA	equ	0c000h


SUCCESSFUL		    EQU	0000h

TRANSMIT_ERROR		EQU	000bh


SlaveEOIPort        EQU 0A0h

MasterEOIPort       EQU 20h



CR	equ	0Dh
LF	equ	0Ah
COMMONCODE	equ	0380h	; amount of memory allocated to ROMTOP Common Code

;-------------------------------------
; Include all general companion files
;-------------------------------------

;	include \rom\sdk\include\drvseg.inc
;	include \rom\sdk\include\bwnad.inc
;	include ..\cui.ext
	include     vulcan.inc


include 	undi_equ.inc
include 	pxe_stru.inc
include 	bwstruct.inc
include 	spdosegs.inc


_TEXT	Segment para public

	assume	cs:CGroup, ds:DGroup


public	NADInit
public	NADReset
public	NADShutDown
public	NADOpen
public	NADClose
public	NADSetFilter
public	NADGetStatistics
public  NADInitiateDiags 
public  NADSetMACAddress


public  OrgIntVector_OFF  
public  OrgIntVector_SEG  


ifdef HARD_INT
    public	NADRequestINT
endif

public	NADMCastChange
public	DriverISR_Proc

extrn	GetED:near
extrn	PostED:near
extrn	Net_Address:byte
extrn	Node_Address:byte
extrn	UNDI_DriverISR:far
extrn	IOBase:word
extrn	IRQNumber:byte
;extern GenIntCallBack:dword
;extern RxCallback:dword
extrn EDListHead:word
extrn EDListTail:word
;extern IntReqPending:byte




extrn	MultiCast_Addresses:word
extrn	EDListHead:word
extrn	EDListCurrent:word
extrn	ApiEntry:word


; definition for BWTADDRRES
;;BWTTCPBOOTP	equ	1
;;BWTTCPDHCP	equ	4

public		LanOption
public		NADDescription

public	NADDisengage
				; for CUI...
public	ErrConfSpace

public	MemBase
public	WaitEEBusy

public	AConfig_Value
	
;-----------------------------------
; External Data/Variable References
;-----------------------------------

	extrn	IOBase:word		; ROMTOP.ASM

	extrn	BusType:byte		; ROMTOP.ASM

	
;;	extrn	ErrIRQ7:byte		; 5X9CONF.ASM


	
;;	extrn	StartTime:near		; NWNID.ASM
;;	extrn	CheckTime:near		; NWNID.ASM


; enable mask for all BootWare-supported interrupts

BOOTWARE_INTS equ      INT_LATCH + INT_ADAPTERFAIL + INT_RXCOMPLETE + INT_TXCOMPLETE + INT_REQUESTED
;BOOTWARE_INTS equ      INT_LATCH + INT_ADAPTERFAIL + INT_RXCOMPLETE + INT_REQUESTED
ReverseAttr	equ	070h		; Attribute for reverse video
NormalAttr	equ	07h		; attribute for normal video

	.386


;	include \rom\sdk\include\bwnadapi.asm



;--------------------------------------------------------------------
; NADInit
;
; Initializes the network adapter 
; 
;
;
; Parameters:
;	dx - screen location for message
;	ax - PCI adapter ID
;	ds - RAM segment
;	es - ROM base
;
; Returns:
;	ax = 0 if no error else pointer to fatal error
;--------------------------------------------------------------------

NADInit	proc	near

        push    es

		push	ds
		pop	es

		sti

		; Copy rest of ROM into RAM. For V2, need to switch page

;;        int     03
		call	FindIOBase
		mov	    DGroup:IOBase, ax

		call	BringUp

		call	Init_Vulcan
		call	Init_hw


		mov	    si, COMMONCODE + 04000h

		mov	    dx, ax
       	mov	    al, EE_CAPABILITIES
       	call	ReadEE

       	test	ax, CAPA_PNP
		jz	CpyPage

		or	DGroup:Modebits, ModeV2

		; switch to Page 1 
		mov	dx, IOBase
		add	dx, PORT_CmdStatus
	
		SelectWindow WNO_FIFO			  ; switch to window 3
		add	dx, PORT_RomControl - PORT_CmdStatus
		in	ax, dx
		and	ax, ROMPageMask 		; clear last 2 bits
		or	ax, RomPage1			; choose Page1
		out	dx, ax

		add	dx, PORT_CmdStatus - PORT_RomControl
		SelectWindow WNO_SETUP

IFNDEF  	TSR
		; verify if ROM is Atmel PEROM. modebits.MODEATMEL will be 
		; set accordingly
;;		mov	cx, 3
;;		call	PEROM
		
		; enable Software Data Production
;;		mov	cx, 1
;;		call	PEROM
		
ENDIF		

		mov	si, COMMONCODE

CpyPage:	; copy last 16K of code

;;;		push	ds
;;;		mov	ds, ROMBase
;;;		mov	di, 04000h
;;;		mov	cx, 04000h-COMMONCODE
;;;		rep	movsb
;;;		pop	ds

		; Make sure Page0 is mapped. DX still points to PortCmdStatus
;;		mov	cx, 0
;;		call	AccessPEROM

		call	Init_Vulcan			; init vulcan hardware and
				  		      	;  variables


		; Check Fail/Warning Level to see if PROM should
		; dump any messages
		mov	al, EE_CWORD
		call	ReadEEPROM

        pop     es

;        jmp short NADInitExit   ; !!!!!!!!!!!!

		cmp	ah, LEVEL_FAIL		; is fail level ok?
		jbe	ChkWarnLevel
        
        stc
;;		mov	ax, offset DGroup:StrFailLevel
		jmp	NADInitErrExit

ChkWarnLevel:
		cmp	al, LEVEL_WARNING	; is warning level ok?
		jbe	NADInitExit
        stc

NADInitErrExit:	
                xor ax, ax
                ret

NADInitExit:clc	
            xor	ax, ax
    		ret

NADInit	endp



;=========================================================================
; NADReset
;==========
;	- Reset and Reinitialize the adapter
;	- Enables the Tx and Rx units
;
; Parameters:	DS = DataSeg
;
; Returns:
;=========================================================================
NADReset	proc	near


;;		call	Init_Vulcan2

		mov	dx, PortCmdStatus
		mov	ax, CMD_STATSENABLE
		out	dx, ax			;enable statistics counters
        clc            
    
    	ret

NADReset	endp



;=========================================================================
; NADShutDown
;=============
;	- reset the adapter and enables
;	- unhook our ISR
;
; Parameters:
;
; Returns:
;=========================================================================

NADShutDown	proc	near


	call	NADDisengage	; stop adapter, unhook ISR


	ret

NADShutDown	endp


;=========================================================================
; NADOpen
;=========
;	- Enables the Tx and Rx units
;
; Parameters:	DS = CGroup
;
; Returns:
;=========================================================================
NADOpen 	proc	near


; not sure whether we have to do anything here, since NADTransmit does a
; reset of the adapter and re-inits everytime.

		mov	dx, PortCmdStatus
		call	TxReset
		
		mov	ax, CMD_TXENABLE
		out	dx, ax			;enable Tx

		mov	ax, CMD_RXENABLE
		out	dx, ax			;enable Rx

        clc

		ret

NADOpen 	endp


;=========================================================================
; NADClose
;==========
;	- Disables the Tx and Rx units
;
; Parameters:	DS = CGroup
;
; Returns:
;=========================================================================
NADClose	proc	near


		mov	dx, PortCmdStatus
		mov	ah, CMDH_TXDISABLE
		out	dx, ax			;disable Tx
		mov	ah, CMDH_RXDISABLE
		out	dx, ax			;disable Rx
        clc
    	ret

NADClose	endp



NADInitiateDiags    proc    near
;;    stc
    clc
    ret
NADInitiateDiags    endp



NADSetMACAddress    proc    near
;;    stc
    clc
    ret
NADSetMACAddress    endp



;=========================================================================
; DriverISR_Proc
;================
;	- ISR procedure to be called by UNDI_DriverISR
;
; Parameters:	DS = CGroup
;
; Returns:	CF = a if not our int
;=========================================================================
DriverISR_Proc	proc	near

;
; check whether our board caused the interrupt
;


		pushf
		call	BootISR 	; (BWAMD.INC)
        sti
		ret

DriverISR_Proc	endp

;=========================================================================
; NADSetFilter
;==============
;	- Change the rx unit's filter to a new one
;	- Handle the promiscuous/broadcast/multicast mode for the
;		rx unit accordingly if necessary
;
; Parameters:	AX = filter value, 1 = directed/multicast
;				   2 = broadcast
;				   4 = promiscuous
; Return:
;=========================================================================
NADSetFilter	proc	near

;;		SelectWindow WNO_SETUP
		push	ax
		mov	dx, DGroup:PortCmdStatus
		mov	ah, CMDH_RXDISABLE	;disable Rx
		out	dx, ax
		pop	ax

;db  0f1h
		shl	al, 1
		test	al, 00000010b
		jz	go_set_filter
		or	al, 00000001b	;set bit 0 if bit 1 is set
go_set_filter:
		mov	ah, CMD_SETRXFILTER/256
		mov	DGroup:HWFilter, ax
		out	dx, ax
;
; if the filter setting was non-zero, enable the receiver.  otherwise, disable
; the receiver.
;
		test	al, al			; zero filter?
		jz	SetFilterEnd
;
; handle multicast addresses here if necessary
;
		mov	ah, CMDH_RXENABLE	;enable Rx
		out	dx, ax			;set Rx unit
SetFilterEnd:
;;		SelectWindow WNO_OPERATING
        clc
		ret

NADSetFilter	endp


;=========================================================================
; NADGetStatistics
;==================
;	- Read the adapter's statistics
;
; Parameters:	ds:si points to variables to hold the result
;			TxGoodFrames	dd	0	;1
;			RxGoodFrames	dd	0	;2
;			RxCRCErrors	dd	0	;3
;			RxDiscarded	dd	0	;3
;
; Returns:
;=========================================================================
NADGetStatistics	proc	 near

;int 03        

		push	dx
; more code here

		pop	dx
;;        stc
        clc
		ret

NADGetStatistics	endp


ifdef HARD_INT


;=========================================================================
; NADRequestINT
;================
;	- Generate an interrupt to the host
;
; Parameters:
;
; Returns:
;=========================================================================
NADRequestINT	proc	near


;		sti
		ret



NADRequestINT	endp


endif



;==========================================================================
; NADMCastChange
;================
;	- Modify the multicast buffer to receive the multicast addresses
;	  listed in the multicast table.
;         Each entry in the multicast table is as follows:
;                 Bytes 0-5 = Multicast Address
;         All addresses are contiguous entries
;
; Parameters:	CX =  Number of multicast entries.
;               ES:SI -> Multicast Table.
;		AX = 1 means save the list
;		AX = 0 means use the saved list
;
; Return:	All registers may be destroyed.
;==========================================================================
NADMCastChange	proc	near

		push	ds

;		mov	dx, PortCmdStatus
;		mov	ax, CMD_RXDISABLE
;		out	dx, ax			;disable Rx

		push	ds
		push	es
		pop	ds		;ds:si -> mc table
		pop	es		;es = ds

		or 	ax, ax
		jz	UseSavedList

		cmp	cx, MAXNUM_MCADDR
		jbe	MCsave
		mov	cx, MAXNUM_MCADDR
MCsave:
		lea	di, DGroup:MultiCast_Addresses
		mov	(Eth_MCastBuf ptr es:[di]).MCastAddrCount, cx
		jcxz	MC_SaveDone
;
; copy addresses from ds:si to es:di
;
		lea	di, (Eth_MCastBuf ptr es:[di]).MCastAddr
MC_SaveLoop:
		mov	eax, dword ptr [si]
		mov	dword ptr es:[di], eax
		mov	ax, word ptr [si+4]
		mov	word ptr es:[di+4], ax

		add	si, ADDR_LEN		; each unit is 16 bytes long
		add	di, ETH_ADDR_LEN
		loop	MC_SaveLoop
MC_SaveDone:
UseSavedList:
		pop	ds

;		mov	dx, PortCmdStatus
;		mov	ax, CMD_RXENABLE
;		out	dx, ax			;enable Rx

		lea	si, DGroup:MultiCast_Addresses
		mov	cx, (Eth_MCastBuf ptr [si]).MCastAddrCount
		lea	si, (Eth_MCastBuf ptr [si]).MCastAddr

		ret

NADMCastChange	endp




;--------------------------------------------------------------------
;
;   Init_Vulcan: Initializes NIC variables and enable NIC hardware (txmitter,
;		 receiver, ...)
;
;   On Entry:
;	Assume set to window 0
;
;   On Exit:
;      ax  = 0, init successful
;	   = offset of an error message indicating type of error
;
;	Initialization code is split into 3 parts:
;	      FindIOBase:
;		   1. Find IOBase of 509 (509, 509B, 527, 529)
;		   2. Switch to Window 0
;	      BringUp:
;		   1. Activate NIC (only called during Autoscan)
;	      Init_Vulcan:
;		   1. determine resource config and enable resources (DMA, Int)
;		   2. initialze and determine driver variables, tables
;	      Init_hw
;		   1. enable vulcan hardware (txmitter, receiver, xcvr, etc.)
;--------------------------------------------------------------------

Init_Vulcan	proc	near

		; setup all ports
		mov	ax, DGroup:IOBase
		mov	di, offset DGroup:PortCmdStatus
		mov	cx, 7
		rep	stosw
	
		mov	di, offset DGroup:PortCmdStatus
		add	word ptr [di], PORT_CmdStatus
		add	word ptr [di+2], PORT_TxFree
		add	word ptr [di+4], PORT_TxSTatus
		add	word ptr [di+6], PORT_Timer
		add	word ptr [di+8], PORT_RxStatus
		add	word ptr [di+14], PORT_RxFree

		mov    dx, DGroup:PortCmdStatus
		SelectWindow WNO_SETUP

; read OEM node address and software config from EEPROM

;         	mov	ax, ds
;         	mov    es, ax
;         	assume es:CGroup
         
                mov    di, offset DGroup:Net_Address
         
                mov    al, EE_OEM_NODE_ADDR_WORD0
                call   ReadEEProm		; read word 0 of node addr
                xchg   ah, al
                stosw
         
                mov    al, EE_OEM_NODE_ADDR_WORD1
                call   ReadEEProm		; read word 1 of node addr
                xchg   ah, al
                stosw
         
                mov    al, EE_OEM_NODE_ADDR_WORD2
                call   ReadEEProm		; read word 2 of node addr
                xchg   ah, al
                stosw


        		mov	    si, offset DGroup:Net_Address
        		mov	    di, offset DGroup:Node_Address
        		movsw
        		movsw
        		movsw


                mov    al, EE_SOFTWARE_CONFIG_INFO
                call   ReadEEProm
                mov    DGroup:EESoftConfigInfo, ax	; save it for later use
         
                mov    al, EE_CWORD
                call   ReadEEProm
                mov    DGroup:Cword, ax
         
         	    mov	    al, EE_CAPABILITIES
             	call	ReadEEProm
             	mov	    DGroup:EECapabilities, ax
         

         	; find out what AConfig_Value and RConfig_Value are
             	add    dx, ( PORT_CfgAddress - PORT_CmdStatus )
         						 ; address configuration reg
             	in     ax, dx
             	mov    DGroup:AConfig_Value, ax		  ; save it
         
         	; Fetch RCR from EEPROM rather than PnP. Write EEPROM RCR
         	; to IOPort to force card to use EEPROM RCR.
						 ; resource configuration reg
             	add    dx, ( PORT_CfgResource - PORT_CfgAddress )
             	in     ax, dx
             	mov    DGroup:RConfig_Value, ax		  ; save it
         
		mov    dx, DGroup:PortCmdStatus
		SelectWindow WNO_SETUP

		mov    ax, 0
		ret

Init_Vulcan	endp

;--------------------------------------------------------------------
;
;   Init_hw: enable vulcan hardware (txmitter, receiver, xcvr, etc.)
;
;   On Entry:
;	dx = IOBase
;
;   On Exit:
;      ax  = 0, init successful
;	   = offset of an error message indicating type of error
;
;	Initialization code is split into 3 parts:
;	      FindIOBase:
;		   1. Find IOBase of 509 (509, 509B, 527, 529)
;		   2. Switch to Window 0
;	      BringUp:
;		   1. Activate NIC (only called during Autoscan)
;	      Init_Vulcan:
;		   1. determine resource config and enable resources (DMA, Int)
;		   2. initialze and determine driver variables, tables
;	      Init_hw
;		   1. enable vulcan hardware (txmitter, receiver, xcvr, etc.)
;--------------------------------------------------------------------
Init_hw		proc	near

		mov    dx, DGroup:PortCmdStatus
		SelectWindow WNO_SETUP

		mov    ax, DGroup:RConfig_Value
		and    ax, RCONFIG_IRQ			 ; strip out the IRQ level
		rol    ax, 4
		mov    DGroup:IRQNumber, al			 ; save it
		call   SetInterruptVector

;------------------------------------------------------------------------------
; initialize Vulcan hardware, driver variables & tables

		call   init_vulcan_hw		; initialize Vulcan hardware

;------------------------------------------------------------------------------
; enable int at 8259, turn on Ethernet Core Transciever and Receiver

       mov    dx, DGroup:Int_mask_port
       in     al, dx

       and    al, DGroup:IntMaskOnBit
       jmp    $+2

       out    dx, al

       cmp    dx, MASTER_MASK_PORT		 ; are we using IRQ from slave?
       je     turn_on_tx_rx			 ; no

       in     al, MASTER_MASK_PORT		 ; yes, turn on cascaded input
       and    al, not 04			 ;  on master 8259
       out    21h, al

turn_on_tx_rx:

; setup TxStartThreshold, RxEarlyThreshold, RxFilter

		mov    dx, DGroup:PortCmdStatus

		mov    ax, DGroup:CurTxStart
		out    dx, ax

		mov    ax, CMD_SETRXEARLY+RXEARLY_DISABLED ; early threshold = 2032 (off)
		out    dx, ax				 ;  too many runt packets

		mov    ax, CMD_SETRXFILTER+FILTER_INDIVIDUAL ; ---no bcasts for BootWare!
		out    dx, ax
		mov    DGroup:HWFilter, ax

		mov    ax, CMD_SETINTMASK + BOOTWARE_INTS ; all BootWare-supported ints on
		out    dx, ax

		mov     ah, CMDH_TXENABLE
		out     dx, ax

		mov     ah, CMDH_RXENABLE
		out     dx, ax

		SelectWindow WNO_SETUP

		mov    ax, 0
		ret
Init_hw		endp

;--------------------------------------------------------------------
;
;   SetInterruptVector: this routine determine the mask value for the selected
;			IRQ level and EOI values for both master and slave
;			8259s, remaps IRQ vector to our ISR and save current
;			IRQ vector in case DriverUnhook needs it.  We do not
;			mask on the selected IRQ in this routine, instead, it
;			will be turned on and off as init goes on.
;
;   On Entry:
;	      al = IRQ level
;	      sti
;   On Exit:
;	      sti
;
; 920717 0.0 GK modified, rewrote DOS get/setint calls
;--------------------------------------------------------------------


SetInterruptVector proc near

;;	assume	ds:CGroup, es:CGroup

	push	es

;--------------------------------------------------------------------
; determine the mask value for the selected IRQ level

       mov    cl, al				 ; al = IRQ level
       and    cl, 0f7h				 ; strip out IRQ on slave
       mov    ch, 1
       shl    ch, cl
       mov    DGroup:IRQBit, ch			 ; IRQ bit postion (1), maskoff)
       not    ch				 ; all bits 1 except channel
       mov    DGroup:IntMaskOnBit, ch			 ; Mask on bit position (0)

       mov    word ptr DGroup:int_mask_port, MASTER_MASK_PORT
       cmp    al, 7
       jbe    SetInt1
       mov    word ptr DGroup:int_mask_port, SLAVE_MASK_PORT
SetInt1:

;--------------------------------------------------------------------
; determine EOI values for both master and slave 8259

       mov    al, DGroup:IRQNumber
       cmp    al, 8				 ; IRQ on slave?
       jae    SetInt2				 ; yes

       mov    ah, al				 ;
       or     ah, 60h				 ; specific EOI to master 8259
       mov    al, 40h				 ; nop to slave to 8259
       jmp    short save_eoi

SetInt2:
       mov    ax, 6220h 			 ; non-specific EOI to slave
						 ; specific EOI to master 8259
save_eoi:
       mov    DGroup:eoi_value, ax			 ; ah = EOI for master
						 ; al = EOI for slave

;--------------------------------------------------------------------
; save and remap IRQ vector

; convert IRQ to interrupt vector number

       mov    al, DGroup:IRQNumber		    ; al = IRQ level
       mov    ah, 8			    ; IRQ 0-7 => int vector # 08h-0fh
       cmp    al, 8
       jb     SetInt3

       mov    ah, (70h-8)		    ; IRQ 8-15 => int vector # 70h-77h
SetInt3:
       add    al, ah			    ; al = int vector number
       cli

; save old interrupt vector

	xor	bx, bx
	mov	es, bx			; ES = 0
	cbw
	mov	bx, ax
	shl	bx, 1
	shl	bx, 1
	les	bx, es:[bx]

;;    mov    DGroup:OldInterrupt.loword, bx
;;    mov    DGroup:OldInterrupt.hiword, es

	mov	DGroup:OrgIntVector_OFF,bx ; old interrupt pointer is stored in
	mov	DGroup:OrgIntVector_SEG,es ; this variable

; remap int vector to our DriverISR

	mov	dx, offset CGroup:UNDI_DriverISR
	xor	di, di
	mov	es, di			; ES = 0
	cbw
	mov	di, ax
	shl	di, 1
	shl	di, 1

	mov	DGroup:IntVectorAddress, di

	mov	ax, dx
	stosw
	mov	ax, cs
	stosw

;970227 mov RemapInt, YES		 ; indicate vector remapped 
	pop	es

       sti
       ret

SetInterruptVector endp

;--------------------------------------------------------------------
;   init_vulcan_hw:  this routine initializes most of vulcan hardware required
;		     to operate the adapter.  TxEnable and RxEnable will not
;		     be done in this routine, since we need to compute some
;		     timing-sensitive variables (ex. TxCopyCli & RxCopyCli).
;		     system DMA channel is also initialized if specified.
;
;   On Entry:
;	      adapter has been activated and window 0 is active.
;
;	      the following variables are valid and available:
;
;			1. IOBase
;			2. IRQNumber
;			3. DMAChannel	 - if ff, no DMA specified.
;			4. RConfig_Value - content of Resource Config Reg
;			5. AConfig_Value - content of Address Config Reg
;			6. NIDNetAddress - ethernet addr of the adapter
;
;   On Exit:
;	      window 1 is active
;	      dx = port CmdStatus
;
;--------------------------------------------------------------------

		   public    init_vulcan_hw
init_vulcan_hw	   proc      near



;--------------------------------------------------------------------
; enable INT & DRQ drivers.  since we need to use timer to time events, so this
; command must be done before we intend to do timing measurements.

       mov    dx, DGroup:IOBase
       add    dx, PORT_CfgControl
       mov    ax, 01				 ; EnableAdapter
       out    dx, ax

;--------------------------------------------------------------------
; Setup Station Address.  the adapter's Ethernet Address has been read out of
; EEPROM, we need to program it into window 2, so Ethernet Core Receiver can
; receive packets properly.  the active window is 0, switch to window 2 first.

       add    dx, (PORT_CmdStatus - PORT_CfgControl)
       mov    ax, CMD_SELECTWINDOW+WNO_STATIONADDRESS	   ; window 2
       out    dx, ax				 ; switch to window 2

       mov    si, offset DGroup:Net_Address

       sub    dx, PORT_CmdStatus-PORT_SA0_1	 ; dx = port addr 5, 4
       lodsw
       out    dx, ax

       add    dx, 2				 ; dx = port addr 3, 2
       lodsw
       out    dx, ax

       add    dx, 2				 ; dx = port addr 1, 0 = IO base
       lodsw
       out    dx, ax

; do not enable SQE statistics collection; BootWare doesn't keep stats
	   mov	  dx, DGroup:PortCmdStatus
       mov    ax, CMD_SELECTWINDOW+WNO_DIAGNOSTICS
       out    dx, ax				 ; switch to window 4

       add    dx, PORT_MediaStatus-PORT_CmdStatus
       in     ax, dx

						 ; 04-01-92
       test   DGroup:AConfig_Value, ACONFIG_XCVR	 ; bit<15,14>=00, if TP
       jnz    Init1				 ;
						 ;
       or     ax, MEDIA_JABBERENABLE		 ;
						 ;
       test   DGroup:EESoftConfigInfo, SW_LINKBEAT	 ;
       jnz    Init1				 ;
						 ;
       or     ax, MEDIA_LBEATENABLE		 ;
Init1:						 ; 04-01-92

       out    dx, ax

       add    dx, PORT_CmdStatus-PORT_MediaStatus
       mov    ax, CMD_SELECTWINDOW+WNO_OPERATING ; window 1
       out    dx, ax				 ; switch to window 1

;--------------------------------------------------------------------
; configure Ethernet Core.  this piece of code sets up operational features
; required to run the adapter properly. (in window 1)

       mov    ax, CMD_SETRZMASK+MASK_NONE
       out    dx, ax

; just enable request int bit during configuration of Ethernet Core.

       mov    ax, CMD_SETINTMASK+(INT_LATCH+INT_REQUESTED)
       out    dx, ax				 ; unmask request int bit
       cli

; mask off int channel on 8259

       mov    dx, DGroup:int_mask_port
       in     al, dx

       or     al, DGroup:IRQBit			 ; read 8259's mask port
       jmp    $+2
       out    dx, al
       sti

		mov	  dx, DGroup:PortCmdStatus

       mov    ax, CMD_TXRESET			 ; 03-02-92
       out    dx, ax

       mov    ax, CMD_RXRESET
       out    dx, ax

; disable statistics

       mov    ax, CMD_STATSDISABLE	; *** BootWare doesn't enable statistics...
       out    dx, ax

;--------------------------------------------------------------------
; start internal transciever if specified

       mov    ax, DGroup:AConfig_Value
       and    ax, ACONFIG_XCVR
       cmp    ax, BNC_XCVR
       mov    ax, CMD_STARTINTXCVR		 ; if BNC, start internal xcvr
       je     Init2
       mov    ax, CMD_STOPINTXCVR		 ; not BNC, stop internal xcvr
Init2:
       out    dx, ax

; issue request interrupt command

       mov    ax, CMD_ACKNOWLEDGE+INT_REQUESTED+INT_LATCH
       out    dx, ax				 ; clear previous timer int
       mov    ax, CMD_REQUESTINT
       out    dx, ax				 ; "request int" starts timer

; wait till timer reaches the max value 0ffh

       add    dx, (PORT_TIMER-PORT_CmdStatus)	 ; dx = port timer
Init3:
       in     al, dx				 ; delay at least 800 us
       cmp    al, 0ffh				 ;  before using internal
       jne    Init3				 ;   transciever


; acknowlege request int, so it can be re-used later on

       add    dx, (PORT_CmdStatus-PORT_TIMER)	 ; dx = port CmdStatus
       mov    ax, CMD_ACKNOWLEDGE+INT_REQUESTED+INT_LATCH
       out    dx, ax

       ret

init_vulcan_hw	   endp

;-----------------------------------------------------------------------------
;   Driver Unhook
;
;   assumes:
;	     DS is setup
;	     Interrupts are DISABLED
;
;   returns:
;	     interrupt disabled
;	     no registers need to be preserved.
;-----------------------------------------------------------------------------

DriverUnhook  proc near


       push   es   
       xor    ax, ax
       mov    es, ax
       mov    di,word ptr DGroup:IntVectorAddress



       mov	  ax, DGroup:OrgIntVector_OFF	 ; segment
;;;       mov    ax, OldInterrupt.off
       mov    es: [di].off, ax
	   mov	  ax, DGroup:OrgIntVector_SEG   ; offset
;;;       mov    ax, OldInterrupt.segm
       mov    es: [di].segm, ax

unhook_rtn:
       pop    es   
       ret

DriverUnhook  endp

;------ ReadEEProm/ReadEE ---------------------------------------------------;
;									     ;
;	This routine reads a word from the EEProm.  It can only be used      ;
;	once the board has been brought up at a particular IOBase.	     ;
;									     ;
;	Entry:								     ;
;	AL	= EEProm word to read					     ;
;	Window	= 0							     ;
;	dx = IOBase (for ReadEE) 
;	IOBase	= valid (for ReadEEPROM)
;	cli								     ;
;									     ;
;	Exit:								     ;
;	AX	= that EEProm word					     ;
;	cli								     ;
;									     ;
;	Destroys BX, CX, DX, SI, DI and ES.  All other registers are	     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
ReadEE		proc	near
		push	dx
		jmp	short ReadEECont

       public  ReadEEProm
ReadEEProm     proc    near
		push	dx

; issue an EEProm read command

                mov    dx, DGroup:IOBase

ReadEECont:
                add    dl, PORT_EECmd
                add    al, READ_EEPROM
                out    dx, al

; spin until the EEProm busy bit goes off

		call   WaitEEBusy

; fetch the data from the EEProm data register

                add    dl, PORT_EEData - PORT_EECmd
                in     ax, dx
         
         	pop	dx
		ret
ReadEEProm	endp
ReadEE		endp

;-----------------------------------------------------------------------------
; WaitEEBusy	Poll until the EEPROM_BUSY bit in EECommand Register is cleared
;
; Input:	dx = IOBase+ PORT_EECmd
;		ax = 0 no problem, ax != 0 problem
;-----------------------------------------------------------------------------
WaitEEBusy	proc	near
         	push	cx
         
         	mov	cx, 0
         
WaitEELoop:

         	in	ax, dx
         	test	ax, EE_BUSY
         	jz	WaitEEBusyExit
         
		loop	WaitEELoop


WaitEEBusyExit: and	ax, EE_BUSY		; only consider bit 15 for Errcode
		pop	cx
		ret
WaitEEBusy	endp


;------ WriteEEProm ---------------------------------------------------------;
;									     ;
;	This routine writes  a word to the EEProm.  It can only be used      ;
;	once the board has been brought up at a particular IOBase.	     ;
;									     ;
;	Entry:								     ;
;	BL	= EEProm word to write					     ;
;	CX	- Value to write
;	Window	= 0							     ;
;	RealIOBase  = valid						     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;									     ;
;	Destroys BX, CX, DX, SI, DI and ES.  All other registers are	     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
public		WriteEEProm
WriteEEProm	proc	near
	push	bx
	push	cx
	push	dx

	; To write a word to EEPROM, sequence of events are
	;	1. Issue Erase/Write Enable Cmd ( Port IOBase+A, Value 30h )
	;	2. Issue Erase Cmd ( Port IOBase+A, Value C0h or Address )
	;	3. Issue Erase/Write Enable Cmd again ( Port IOBase+A, Value 30h )
	;	4. Load data into EEPROM Data Reg ( Port IOBase+C, Value Data )
	;	5. Issue Write Cmd ( Port IOBase+A, Value 40 or Address )
	;
	; Always check if EEPROM Busy bit is cleared
	mov	dx, DGroup:IOBase
	add	dl, PORT_EECmd
	call	WaitEEBusy

	mov	ax, 030h
	out	dx, ax				; issue Erase/Write Enable Cmd

	call	WaitEEBusy

	xor	ax, ax
	mov	al, bl
	add	al, 0c0h
	out	dx, ax				; issue Erase EEPROM Cmd

	call	WaitEEBusy

	mov	ax, 030h
	out	dx, ax				; issue Erase/Write Enable Cmd

	call	WaitEEBusy

	mov	ax, cx
	add	dx, ( PORT_EEData - PORT_EECmd )
	out	dx, ax				; load data

	add	dx, ( PORT_EECmd - PORT_EEData )
	xor	ax, ax
	mov	al, bl
	add	al, 040h
	out	dx, ax

	call	WaitEEBusy

	pop	dx
	pop	cx
	pop	bx
	ret
WriteEEProm    endp

;--------------------------------------------------------------------
; NADChangeReceiveMask
;
; Change the receive mask of the controller. Can force the adapter to
; enable/disable broadcast, multicast or promiscuous receptions
;
; Parameters:
;	BL - new receive bit mask:
;		bit 0:	set   = enable
;			clear = disable
;		bit 1:	change broadcast mask based on bit 0 flag
;		bit 2:	change multicast mask based on bit 0 flag
;		bit 3:	change Multicast Address Table:
;			if bit 0 is set, ES:DI will point to the
;				multicast address to add
;			if bit 0 is cleared, ES:DI will point to
;				multicast address to delete.
;			if bit 0 is cleared and DI = 0,
;				clear whole Multicast Table
;
;	ES:DI pointer to multicast address 
;
; Returns:
;	bx - TRUE/FALSE status if change was made
;--------------------------------------------------------------------

NADChangeReceiveMask	proc	far

		push	si
		push	dx
		push	ax

		; ** 509 does NOT allow you to read the current
		; ** receive mask. I will assume that broadcast
		; ** and multicast will NOT be concurrently
		; ** enabled

		mov	dx, DGroup:PortCmdStatus
		SelectWindow WNO_SETUP

		test	bl, 2			; want to change broadcast?
		jnz	NADChgReceiveBroad

		test	bl, 4			; want to change Multicast?
		jnz	NADChgReceiveMulti
	
		jmp	short NADChgReceiveMaskEnd

NADChgReceiveBroad:
	 	mov    ax, CMD_SETRXFILTER+FILTER_BROADCAST+FILTER_INDIVIDUAL

		test	bl, 1
		jnz	NADChgRxBroad

		mov    ax, CMD_SETRXFILTER+FILTER_INDIVIDUAL
NADChgRxBroad:
		out	dx, ax
		mov	DGroup:HWFilter, ax
		jmp	short NADChgReceiveMaskEnd

NADChgReceiveMulti:
		mov    ax, CMD_SETRXFILTER+FILTER_INDIVIDUAL

		test	bl, 1
		jz	NADChgRxMulti

		mov	si, offset DGroup:NIDGroupAddr
		mov	ax, es:[di]
		mov	ds:[si], ax

		add	si, 2
		add	di, 2
		mov	ax, es:[di]
		mov	ds:[si], ax

		add	si, 2
		add	di, 2
		mov	ax, es:[di]
		mov	ds:[si], ax

		mov    ax, CMD_SETRXFILTER+FILTER_MULTICAST+FILTER_INDIVIDUAL

NADChgRxMulti:
		out    dx, ax
		mov    DGroup:HWFilter, ax

NADChgReceiveMaskEnd:
		pop	ax
		pop	dx
		pop	si
		mov	bx, 1
		retf

NADChangeReceiveMask	endp




;--------------------------------------------------------------------
;
;   FindIOBase:	Find IOBase & ACR of EtherLink III (509, 509B, 527, 529)
;
;   On Entry:
;      ds = es = CGroup
;
;   On Exit:
;	ax = IO Address or 0 if failure
;	bx = Address Config. Register
;
;	Initialization code is split into 4 parts:
;	      FindIOBase:
;		   1. Find IOBase of 509 (509, 509B, 527, 529)
;		   2. Switch to Window 0
;	      BringUp:
;		   1. Activate NIC (only called during Autoscan)
;	      Init_Vulcan:
;		   1. determine resource config and enable resources (DMA, Int)
;		   2. initialze and determine driver variables, tables
;	      Init_hw
;		   1. enable vulcan hardware (txmitter, receiver, xcvr, etc.)
;--------------------------------------------------------------------
FindIOBase	proc	near

;;            assume ds:CGroup
         
            cli					 ; 01-14
         
    		call   GetBusType

            mov     DGroup:BusType, al

;;;            int 03

         	cmp	al, BUS_MCA
         	je	inite_mca
         
         	cmp	al, BUS_EISA
         	je	inite_eisa
         	
         	jmp	init_isa

;-----------------------------------------------------------------------------
;  MCA-specific init code
;-----------------------------------------------------------------------------
FindIOBaseBadJmp:
		jmp	FindIOBaseBad

inite_mca:
		call	Find529
		jnz	FindIOBaseBadJmp

       	; Find IOBase
       	mov	dx, 104h		; POS[4]
       	in	al, dx
         
       	xchg	ah, al
       	and	ax, 0fc00h		; only consider higher 6 bits
       	or	ax, 0200h		; bit 9 is always set

		push	ax
       	mov	dx, 0096h
       	xor	al, al
       	out	dx, al			; turn setup mode off
		pop	ax
		jmp	init_ACR
         
;-----------------------------------------------------------------------------
;  EISA-specific init code
;-----------------------------------------------------------------------------
		; search the slots from 1 to 15 until we find a Vulcan adapter.
inite_eisa:
		xor    cl, cl			; slot number

inite_loop:
        inc    cl			; next slot
        cmp    cl, 15
        ja     init_isa			; if not found, try ISA

		call   CheckEISASlot		; check slot CL
		jnz    inite_loop		; nope? keep looking
;		jnc    inite_loop		; nope? keep looking

; found a Vulcan adapter in slot CL.  set the IOBase for EISA slot-specific
; addressing (I/O address x000 where x is a don't care).

		mov    ch, cl			; IOBase = x000 where
		xor    cl, cl			; x is the slot number
		shl    cx, 4
		mov	ax, cx

init_ACR:
		push	ax
		mov	dx, ax
       	add 	dx, PORT_CfgAddress
       	in	ax, dx
		mov	bx, ax
		pop	ax
        xor cx, cx          ; it's not an ISA , definitely
		jmp	FindIOBaseExit

;-----------------------------------------------------------------------------
;  ISA-specific init code
;-----------------------------------------------------------------------------

init_isa:
;;;        int     03
		mov    dx, ID_PORT
		call   Write_ID_Sequence 		 ; IDS enters ID_CMD state
         
		mov    al, SET_TAG_REGISTER + 0
		out    dx, al				 ; untag adapter

; look for the first adapter and activate it.  we will use contention test to
; make sure there is at least 1 Vulcan on system bus and activate the first
; Vulcan adapter we find.

        mov    al, EE_MANUFACTURER_CODE
        call   Contention_Test			 ; read EISA manufacturer ID
        cmp    ax, EISA_MANUFACTURER_ID		 ; is it 3Com's EISA ID?
        jnz	FindIOBaseBad

		jmp	$+2
		jmp	$+2
		jmp	$+2

        mov    al, EE_ADDR_CONFIGURATION
        call   Contention_Test
		mov	bx, ax
                and	ax, ACONFIG_IOBASE		 ; strip off IO base
                shl	ax, 4
		add	ax, MIN_IO_BASE_ADDR		 ; ax = IO base of adapter

        mov cx, 1                       ; it's an ISA card, no matter what
                                        ; bus is

FindIOBaseExit:
		push	ax
                mov	dx, ax				; set to window 0,
                add	dx, PORT_CmdStatus		;  so warm boot will
                mov	ax, CMD_SELECTWINDOW+WNO_SETUP	;   not confuse the
                out	dx, ax				;    hardware
		pop	ax
         	sti
         	ret

FindIOBaseBad:
		xor	ax, ax
		jmp	short FindIOBaseExit

FindIOBase	endp

;--------------------------------------------------------------------
;
;   BringUp: Activate NIC
;
;   On Entry:
;      ax = IOBase
;
;   On Exit:
;      bx     = 0, init successful
;	      = pointer to error message
;
;	Initialization code is split into 4 parts:
;	      FindIOBase:
;		   1. Find IOBase of 509 (509, 509B, 527, 529)
;		   2. Switch to Window 0
;	      BringUp:
;		   1. Activate NIC (only called during Autoscan)
;	      Init_Vulcan:
;		   1. determine resource config and enable resources (DMA, Int)
;		   2. initialze and determine driver variables, tables
;	      Init_hw
;		   1. enable vulcan hardware (txmitter, receiver, xcvr, etc.)
;--------------------------------------------------------------------

BringUp		proc	near

		; Should only do it for ISA board?????????????
		push	ax
		push	ax
		mov	dx, ID_PORT
		sub	ax, MIN_IO_BASE_ADDR
		shr	ax, 4
		add	ax, 0e0h	 ; value to write to ID_PORT
		out	dx, ax		; IO is changed !!
		pop	dx

;----------------------------------------------------------------------------
;  ISA/EISA/MCA common init code
;----------------------------------------------------------------------------

init_found:

	       add    dx, PORT_CmdStatus		 ;  so warm boot will
	       mov    ax, CMD_SELECTWINDOW+WNO_SETUP	 ;   not confuse the
	       out    dx, ax				 ;    hardware
	
; the adapter has been brought up, read some information out of register set
; to make sure there is no I/O conflict.  Note that the adapter is in Window
; 0 after being activated.

		add    dx, PORT_ProductID - PORT_CmdStatus
		in     ax, dx
	
		xor	bx, bx
		; first check for MCA card
		cmp	 ax, 0627Ch			 ; 32bit 10 Base2
		je	 IOBaseOk
	
		cmp	ax, 0627Dh			; 32bit 10 Base-T
		je	IOBaseOk
	
		cmp	ax, 062F7h			; TP only
		je	IOBaseOk
	
		cmp	ax, 062F6h			; WHAT IS THIS ??????? Found it
		je	IOBaseOk			; in ODI drv

		cmp	ax, 061d8h			; Test mode. Prom is disabled in
		je	IOBaseOk			; anyways but ...
	
	       ; ISA/EISA ??
		and    ax, PRODUCT_ID_MASK
		cmp    ax, ISA_PRODUCT_ID		 ; is it 5X9?
		je     IOBaseOk
	
		sti

IOBaseOk:	pop	ax
		ret
BringUp		endp


;-----------------------------------------------------------------------------
;   Write_ID_Sequence:
;
;		   This routine writes ID sequence to the specified ID port
;		   on Vulcan adapter; when the complete ID sequence has been
;		   written, the ID sequence State Machine (IDS) enters the
;		   ID_CMD state.  This routine is called when IDS is in
;		   ID_WAIT state.
;
;   On Entry:
;		   dx = the ID port desired (1x0h)
;
;   On Exit:
;		   dx = preserved
;		   ax, cx are not preserved
;-----------------------------------------------------------------------------

Write_ID_Sequence  proc      near

		mov    al, 0
		out    dx, al			 ; to setup new ID port
		out    dx, al
		mov    cx, 0ffh			 ; 255-byte sequence
		mov    al, 0ffh			 ; initial value of sequence

wr_id_loop:
                out    dx, al
                shl    al, 1
                jnc    wr_id
                xor    al, 0cfh
wr_id:
	       loop   wr_id_loop
	
	       ret

Write_ID_Sequence  endp

;--------------------------------------------------------------------
;
;   Contention_Test: This routine, first, writes an "EEPROM Read Command" to
;		     ID port (dx), the write operation actually causes the
;		     content of the specified EEPROM data to be read into
;		     EEPROM data register.  Then it reads ID port 16 times
;		     and saves the results in ax.  During each read, the
;		     hardware drives bit 15 of EEPROM data register out onto
;		     bit 0 of the host data bus, reads this bit 0 back from
;		     host bus and if it does not match what is driven, then
;		     the IDS has a contention failure and returns to ID_WAIT
;		     state.  If the adapter does not experience contention
;		     failure, it will join the other contention tests when
;		     this routine is called again.
;
;		     Eventually, only one adapter is left in the ID_CMD state,
;		     so it can be activated.
;
;   On Entry:
;	      al = word of EEPROM data on which test will contend
;	      dx = ID port (to which ID sequence was written)
;	      cli
;
;   On Exit:
;	      ax = EEPROM data read back by hardware through contention test.
;	      dx = preserved
;	      bx = trashed
;	      cli
;
;--------------------------------------------------------------------

Contention_Test    proc      near

;;                assume ds:CGroup, es:CGroup
         
                add    al, READ_EEPROM			 ; select EEPROM data to
                out    dx, al				 ;  contend on

         	cli
         	; seems to solve some problem when Init is ran a few times
         	mov	cx, 3000h		; 5 ms
         	call	WaitTime
         	sti
         
                mov    cx, 16				 ; read 16 times
                xor    bx, bx				 ; reset the result

contention_read:
                shl    bx, 1
                in     al, dx				 ; reading ID port causes
         						 ;  contention test
         
                and    ax, 1				 ; each time, we read bit 0
                add    bx, ax
         
                loop   contention_read

                mov    ax, bx
                ret
         
Contention_Test    endp

;--------------------------------------------------------------------
; WaitTime - CX has 2*1.1932 the number of microseconds to wait.
;	If CX is small, add 1 to compensate for asynchronous nature
;	of clock.  For example, for 10us, call with CX = 25
;
;  On entry,
;	ints off (especially if CX is small, and accuracy needed)
;  On exit,
;	CX modified
;
; 911223 0.0 GK
;--------------------------------------------------------------------

WaitTime	proc	near

         	push	ax
         	push	bx
         	call	ReadTimer0		; get Timer0 value in AX
         	mov	bx, ax			; save in BX

ReadTimer0Loop:
         	call	ReadTimer0
         	push	bx
         	sub	bx, ax
         	cmp	bx, cx
         	pop	bx
         	jc	ReadTimer0Loop
         
         	pop	bx
		pop	ax
		ret

WaitTime	endp


ReadTimer0	proc	near

         	mov	al, 6
         	out	43h, al 		; port 43h, 8253 wrt timr mode 3
         	call	RT0
         
RT0:
         	jmp	short $+2
         	jmp	short $+2
         	jmp	short $+2
         	in	al, 40h 		; port 40h, 8253 timer 0 clock
		xchg	ah, al
		ret

ReadTimer0	endp

;------ GetBusType ----------------------------------------------------------;
;									     ;
;	Identify the type of system we are executing on.		     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	AL = ISA, EISA or MCA (also saved in BusType)			     ;
;									     ;
;	Destroys AH, BX, CX, DX, SI, DI.  All other registers are     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;

		public	GetBusType
GetBusType	proc	near

		push	es

; point ES at Real Mode F000:0000

		mov	ax, 0F000h
		mov	es, ax

; to determine if this is an EISA system or not we look for the string "EISA"
; in the ROM at F000:FFD9 thru FFDC.

		mov	di, 0FFD9h
		cmp	word ptr es:[di][0], 4945h	; "EI"?
		jne	gst_not_eisa
		cmp	word ptr es:[di][2], 4153h	; "SA"?
		jne	gst_not_eisa

		mov	al, BUS_EISA
		jmp	short gst_ret

; for the moment, if its not an EISA system, then its an ISA system

		public	gst_not_eisa
gst_not_eisa:

       	mov	ah, 0C0h
       	int	15h			; see if running on uC machine
         
       	; with Compaq DeskPro 486/33, the AL is wiped out if carry is cleared
       	mov	al, BUS_ISA
       	jc	NotMCA
         
       	test	byte ptr es:[bx+5], 00000010b ; check if micro-channel bit set
		stc
		jz	NotMCA			; not micro-channel machine

IsMChannel:
		mov	al, BUS_MCA		; BUS_MCA is defined by GY

NotMCA:

; save the bus type in AL in BusType

		public	gst_ret
gst_ret:
; temptemp		mov	BusType, al

; return with the system type in AL

		pop	es
		ret
GetBusType	endp

;------ CheckEISASlot -------------------------------------------------------;
;									     ;
;	This routine checks the EISA slot number specified for a Vulcan      ;
;	adapter and returns a yes/no indication.			     ;
;									     ;
;	Entry:								     ;
;	CL	= EISA slot number to check (0-15)			     ;
;									     ;
;	Exit:								     ;
;	carry	= set if Vulcan adapter found in that slot		     ;
;		= clear if not						     ;
;									     ;
;----------------------------------------------------------------------------;
		public	CheckEISASlot
CheckEISASlot	proc	near
		pusha

; under EISA all boards must respond at port xC80 and xC82 (where x is the
; slot number) with the manufacturer code and product id.  Compute xC80
; from the slot number in CL

		xor	dx, dx		    ; 0000
		mov	dh, cl		    ; 0x00
		shl	dx, 4		    ; x000
		add	dx, 0C80h	    ; xc80

; check for 3Com's manufacturer code

		in	ax, dx
		cmp	ax, EISA_MANUFACTURER_ID ; correct manufacturer?
		jne	ces_ret

; check for Vulcan's product id

		add	dx, PORT_ProductID - PORT_Manufacturer
		in	ax, dx
		and	ax, PRODUCT_ID_MASK	; mask off revision level
		cmp	ax, ISA_PRODUCT_ID	; correct product id?
		jne	ces_ret

ces_ret:
		popa
		ret
CheckEISASlot	endp



;----------------------------------------------------------------------
; Find529	Go to POS and find 3C529
;
; Assume	we are on MCA machine
;
; Exit		zf	set	3C529 found and adapter enabled
;			clear	3C529 not found or adapter not enabled
;		BX
;----------------------------------------------------------------------
Find529		proc	near

		; it's a 3C529 !!
		; search slot for Vulcan adapter
		mov	bl, 08			; start with slot 0
		cli				; ints off

AccessPOSLoop:
		mov	dx, 0096h
		mov	al, bl
		out	dx, al
		jmp	$+2
		mov	dx, 101h
		in	al, dx			; read MSB ID
		jmp	$+2
		xchg	al, ah
		dec	dx			; read LSB ID
		in	al, dx
		jmp	$+2
		cmp	ax, 0627Ch		; 3C529 ? 10 Base-2
		jz	Found529
       	
		cmp	ax, 0627Dh		; 3C529 ? 10 Base-T
		jz	Found529
       	
		cmp	ax, 062F7h		; 3C529 ? TP only
		jz	Found529
       	
		cmp	ax, 062F6h		; What is THIS ??????
		jz	Found529
       	
		cmp	ax, 061D8h		; Adapter in test mode. In test mode
		jz	Found529	      ; PROM should be disabled anyways.
       	
		inc	bl
		cmp	bl, 10h
		jb	AccessPOSLoop		 ; try next slot
		
		jmp	short Find529Bad
       	
Found529:
		; make sure adapter is enabled
		mov	dx, 102h		; POS[2]
		in	al, dx
		jmp	$+2
		test	al, 1			; is CDEN cleared ? (Card enabled )
		jnz	CardEnable
       	
Find529Bad:	sti
		or	bx, bx			; clear ZF. BX cannot be zero
		ret
       	
CardEnable:	sti
		xor	ax, ax			; set ZF
		ret
Find529		endp



Delay500ns	proc	 near

		push	ax
		push	bx
		push	dx
		mov	ax, DelayOneUsec.loword
		mov	dx, DelayOneUsec.hiword
		shr	ax, 1			; divide 1 Usec in half
		shr	dx, 1
		jnc	F2
		or	ax, 8000h		; move low order bit of dx into ax
F2:
		sub	ax, 1
		sbb	dx, 0
		mov	bx, ax
		or	bx, dx
		jnz	F2
		pop	dx
		pop	bx
		pop	ax
		ret

Delay500ns	endp




include		bw5x9.inc



_TEXT	ends




_DATA	segment	para public

; Data variables

NADDescription	label byte	     

LanOption   db  'LAN option: AMD PCnet - PCI II/PCnet - FAST Ethernet Adapter', CR, LF, 0

EthOption		db	' '
;EthOption		db	' Ethernet '
;EthProtString		db	'802.3 v'               ; Print correct protocol
VersionString		db	'v2.0 (971202)',0  ; Print correct version


;----------------- Device Driver Data Definitions --------------------
MaxPhysicalPacketSize  dw   1024		 ; max data request will handle

ErrConfSpace	db	09h,011h,' '
NothingString	db	0


NoNetMsg	db	'Ethernet card improperly installed or not connected.',0
TxMsg		db	'Transmit error', 0

		   ALIGN       4

NormalRxEarly	   dw	     ?		; set RxEarly cmd + threshold
CurTxStart	   dw	     CMD_SETTXSTART+TXSTART_DISABLED


; error messages - note BootWare prefaces them with a CR,LF
StrPrompt	db	01h,02h,'Initializing EtherLink III Adapter',0
StrEndless	db	'Reboot system for changes to take effect',0
StrWarnLevel	db	'Newer UNDI version is available for this adapter.',0
StrFailLevel	db	'New EtherLink III found. Need new UNDI version.',0
Str8022U	db	06h,08h,'BootWare/3C5X9 supports NetWare, RPL & TCP/IP boot protocols:',0
		db	09h,0ah,'To configure & save protocol/frame type, type <ENTER>',0
		db	0bh,0bh,'Default boot protocol is NetWare Ethernet_802.2',0
		db	03h,0fh,'This message will appear until boot protocol information is saved.',0
		db	0ffh
StrNull 	db	0


ISRErrFlag	db	FALSE		; flag indicating if error condition is
TxRetryCnt	dw	1		; Number of times to retry transmit
StoreDS     dw  0

padbytes    db  0

flag        dw  0

ModeBits	dw	0	; Contains System & Adapter Setting

Delayoneusec	dd	0




_DATA	ends


_BSS	segment

		db	'5N'
		
StartTick	dw	0		; save area for tick value
MaxTicks	dw	0		; save area for max ticks
CurTicks	dw	0		; save area for current ticks
DestID		db	6 dup (?)	; save area for destination node ID

RxPend		db	0		; b7 set if pending for Rx packet
					;  XXXXX NO XXX  else has rx status (0, 1)
TxEDPtr 	dd	?		; save area for transmit ED
RxEDPtr 	dd	?		; save area for receive ED
StatusMsgFlag	dw	0		; pointer to msg to be printed in DLCStatus

BWTFileName		db	65 dup(0)
IntVectorAddress	dw	     ?

OrgIntVector_OFF    dw  0
OrgIntVector_SEG    dw  0

;;OldInterrupt		dd	     0
IRQBit			db	     ?
AConfig_Old		dw	0	; old ACR before calling
					; ELNK3Conf
MemBase 		dw	0	; for TCP/IP Generic
OldEESoftConfigInfo	dw	0	; store old EESoftConfigInfo (Before
					; ELNK3CONF)
OldBWTLANOS		db	0	; store old BWTLANOS (before ELNK3CONF)

AConfig_Value		dw	?	; value of address config reg
RConfig_Value		dw	?	; value of resource config reg
EESoftConfigInfo	dw	?	; EEPROM word 0d
CWord			dw	?	; EEPROM word 0e
EECapabilities		dw	0	; EEPROM word 010h


;----------------------------------------------------------------------------
; variables to be initialized during init time
;----------------------------------------------------------------------------

		   ALIGN     4
		   even
eoi_value	   dw	?			 ; ah = master, al = slave
int_mask_port	   dw	?
HwFilter	   dw	?

IntMaskOnBit	   db	?
MsgCoord		dw	0

; DON'T SEPARATE THE FOLLOWING VARIABLES (FROM PortCmdStatus to PortRxFree)
; port variables for window 1
public		PortCmdStatus
		   even
PortCmdStatus	   dw	?			 ; offset 0e
PortTxFree	   dw	?			 ; offset 0c
PortTxStatus	   dw	?			 ; offset 0b
PortTimer	   dw	?			 ; offset 0a
PortRxStatus	   dw	?			 ; offset 08
PortRxFIFO	   dw	?			 ; offset 00
PortTxFIFO	   dw	?			 ; offset 00

; port variables for window 3

PortRxFree	   dw	?			 ; offset 0a

; port variables for window 4

PortFIFODiag       dw        ?                   ; offset 04

CliBufferSize		equ	128
		   ALIGN     4
CliBuffer	   db	     CliBufferSize dup (?) ; ** not needed, may be removed
						; along with other code in init
						; that computes copycli

NIDGroupAddr	db	6 dup(0)	; GroupAddr



_BSS	ends


	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\genmacro.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/GENMACRO.INV   1.2   19 Sep 1997 21:39:10   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: Generic macros used by all Speedo3 ASM driver
;

IFDEF            GENMACRO_INC
ELSE
GENMACRO_INC     equ       1

;--------------------------------------------------------------------------
; Small/quick way to set a register to NULL, all F's (avoid 32-bit constants).
;--------------------------------------------------------------------------
@NULLPTR macro reg
    xor     reg, reg
    dec     reg
    ENDM

;--------------------------------------------------------------------------
; Port I/O macros
;--------------------------------------------------------------------------
;- 32-bit Output
@OUTPD     MACRO    portid, low, high
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    push   high
    push   low
    pop    eax
    out    dx, eax
.SALL
    ENDM

;- 16-bit Output
@OUTPW     MACRO    portid, value
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
IFNB       <value>
    mov    ax, value
ENDIF
    out    dx, ax
.SALL
    ENDM

;- 8-bit Output
@OUTPB     MACRO    portid, value
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
IFNB       <value>
    mov    al, value
ENDIF
    out    dx, al
.SALL
    ENDM

;- 32-bit Input
@INPD      MACRO    portid
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    in     eax, dx
.SALL
    ENDM

;- 16-bit Input
@INPW      MACRO    portid
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    in     ax, dx
.SALL
    ENDM

;- 8-bit Input
@INPB      MACRO    portid
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    in     al, dx
.SALL
    ENDM

;--------------------------------------------------------------------------
; Macro @POPF (DESTROYS AX!!!)                   v1.6
;--------------------------------------------------------------------------
@POPF MACRO                                      
    pop     ax      
    test    ax, 200H
    jz      @F      
    sti                
@@:
    ENDM

;--------------------------------------------------------------------------
; FASTCOPY
; Macro to perform fast DWORD memory copy
; Handles data transfers that are not multiples of 4
;--------------------------------------------------------------------------
@FASTCOPY  MACRO
.XALL
    push   cx
    shr    cx, 2
    rep    movsd
    pop    cx
    and    cx, 3
    rep    movsb
.SALL
    ENDM

;--------------------------------------------------------------------------
; REALLY_FASTCOPY
; Macro to perform fast DWORD memory copy, optimized by processor type.
; Handles data transfers that are not multiples of 4, or not dword-aligned.
;
; Each time REALLY_FASTCOPY is invoked, make sure that:
;  - pass macro value returned by "GetCpuType" (=PENTIUM_CPU does special move)
;  - CX has length
;  - ES:EDI points to destination (must clear upper 16 bits under DOS, OS/2)
;  - DS:ESI points to source      (must clear upper 16 bits under DOS, OS/2)
;--------------------------------------------------------------------------
@REALLY_FASTCOPY  MACRO CpuTypeValue
    local   CopyDword, RepCopy, CopyRemainder, CopyByte, Exit
    push    ax                                             ; v1.04
    push    dx                                             ; v1.04

    mov     dx, cx
    cmp     dx, 4
    jb      CopyRemainder

;--------------------------------------------------
;  Align destination to dword boundary
;--------------------------------------------------
    movsd
    sub     dx, 4

    mov     ax, di
    and     ax, 00003h
    sub     di, ax
    sub     si, ax
    add     dx, ax

    cmp     CpuTypeValue, PENTIUM_CPU                      ; v1.04
    jb      RepCopy

;-------------------------------------------------
; Do Pentium Optimized Block Copy
;-------------------------------------------------
    mov     ax, dx
    shr     ax, 2
    jz      CopyRemainder

CopyDword:
    movsd
    dec     ax
    jnz     CopyDword
    jmp     CopyRemainder

;-------------------------------------------------
; Do i386 and i486 Optimized Block Copy
;-------------------------------------------------
RepCopy:
    mov     cx, dx
    shr     cx, 2
    rep     movsd

;------------------------------------------------
; Copy any remaining bytes
;------------------------------------------------
CopyRemainder:
    mov     ax, dx
    and     ax, 00003h
    jz      Exit

CopyByte:
    movsb
    dec     ax
    jnz     CopyByte

Exit:
    pop     dx                                             ; v1.04
    pop     ax                                             ; v1.04
    ENDM

;--------------------------------------------------------------------------
; SLOW
; Macro to delay execution
; Processor speed independent. Executes an I/O to the keyboard port.  We
; use port 61h and not port 60h, because polling 60h can cause the
; "crazy mouse" problem under windows.
;--------------------------------------------------------------------------
@SLOW      MACRO
.XALL
    push   ax
    in     al,61h
    pop    ax
.SALL
    ENDM

;--------------------------------------------------------------------------
; READ_TICK_COUNTER
; This macro reads the 16-bit Timer Tick Count register 
; (8254 System Board Timer 0).
; The count register decrements by 2 (even numbers) every 838ns.
;
; Entry:    Interrupts disabled
;
; Exit:     AX with the current count
;           Interrupts disabled
;--------------------------------------------------------------------------
@READ_TICK_COUNTER     MACRO
;- Setup 8254 To Latch T0's Current Count
    xor     al, al
    out     43h, al
;- Read The Latched Counter Value, LSB First and MSB Next
    in      al, 40h
    mov     ah, al
    in      al, 40h
;- Swap The Counter Bytes To Correct Format
    xchg    al, ah
    ENDM


;--------------------------------------------------------------------------
; DELAY 
; This macro inserts a delay of specified milliseconds. 
;
; Entry:    Interrupts disabled
;
; Exit:     AX , CX destroyed
;           Interrupts disabled
;--------------------------------------------------------------------------
@DELAY MACRO MSEC
    local   Delay_Loop

    @READ_TICK_COUNTER
    mov     cx, ax
Delay_Loop:
    @READ_TICK_COUNTER
    neg     ax
    add     ax, cx
    cmp     ax, MSEC
    jb      Delay_Loop
    ENDM

;--------------------------------------------------------------------------
; INC32  
; This macro increments a 32 bit counter. 
;
; Entry:    Interrupts disabled
;
; Exit:     AX , CX destroyed
;           Interrupts disabled
;--------------------------------------------------------------------------
@INC32      MACRO     num32
    add     word ptr num32[0], 1
    adc     word ptr num32[2], 0
    ENDM

;--------------------------------------------------------------------------
; @FATAL
;
; Description : Macro to Halt execution (TRAP) in case of Fatal error
;
; Entry       : none
;
; Exit        : none
;--------------------------------------------------------------------------
@FATAL     MACRO 
    int 3
    ENDM

;--------------------------------------------------------------------------
; @INT3BP
;
; Description : inserts an INT 3 in way that is easy to find with an editor.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@INT3BP macro
    Int    3
endm


;--------------------------------------------------------------------------
; @BP_IFDEBUG
; Description : inserts an INT 3 instruction if debug switch has been set.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@BP_IFDEBUG macro
IF  DEBUG_BP
    @INT3BP
ENDIF    
endm

ENDIF


; EOF - $Workfile:   genmacro.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\pci.inc ===
VENDOR_ID	equ 1022h	     ;4 ; Vendor Identification

DEVICE_ID	equ 2000h 	     ;6 ; Device Identification (AT2450)

DEVICE_ID1   equ     0AE34h     ; 32


;PCI BIOS call constants definition
;----------------------------------
PCI_BIOS_INT             equ     1Ah
PCI_FUNCTION_ID          equ    0B1h
PCI_BIOS_PRESENT         equ     01h
FIND_PCI_DEVICE          equ     02h
FIND_PCI_CLASS_CODE      equ     03h
GENERATE_SPECIAL_CYCLE   equ     06h
READ_CONFIG_BYTE         equ     08h
READ_CONFIG_WORD         equ     09h
READ_CONFIG_DWORD        equ     0Ah
WRITE_CONFIG_BYTE        equ     0Bh
WRITE_CONFIG_WORD        equ     0Ch
WRITE_CONFIG_DWORD       equ     0Dh

;PCI BIOS returned values constants definition
;---------------------------------------------
PCI_SUCCESSFUL           equ     00h
PCI_FUNC_NOT_SUPPORTED   equ     81h
PCI_BAD_VENDOR_ID        equ     83h
PCI_DEVICE_NOT_FOUND     equ     86h
PCI_BAD_REGISTER_NUMBER  equ     87h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\bw5x9.inc ===
; Routines in BW5X9.INC
;  : shared by 3C5X9, 3C59X-PCI and 3C59X-EISA
;
; Modules included:
;  - NADTransmitPacket
;  - DoRxDiscard
;  - SoftRxReset
;  - NADPoll
;  - NADDisengage
;  - Interrupt Service Routines
;  - TxReset
;  - RxReset
;  - RxDiscard
;
; 960618 GY    - Add support for Broadcast
; 960401 GY - Replace some MACROS with code
;        - standardize port access
;******************************************************************************



;------------------------------------------------------------------------------
; StartTime - save maxtick count, get current tick value
;	Timeout is ticks, each tick is 55 ms.
;	Note: this routine can only be called once the PC timer
;	and its interrupt are setup (INT19 and beyond are OK)
;
; On entry,
;	AX = max ticks to wait
;	ints enabled
;
; On exit,
;	all preserved
;
; 881030 1.0 GK
;------------------------------------------------------------------------------

StartTime	proc	near

		push	ax
		push	cx
		push	dx
        push    di  
        push    es

		mov	DGroup:MaxTicks, ax
;;		mov	ah, 0
;;db  0f1h
;;		int	1Ah				; get current tick value
        mov     ax, 40h
        mov     es, ax
        mov     di, 6Ch
        mov     dx, es:[di]
        mov     cx, es:[di+2]
		mov	DGroup:StartTick, dx		; save it

        pop es
        pop di
		pop	dx
		pop	cx
		pop	ax
		ret

StartTime	endp

;------------------------------------------------------------------------------
; CheckTime - gets current tick value, compares with maxticks
;	Timeout is ticks, each tick is 55 ms.
;	Note: this routine can only be called once the PC timer
;	and its interrupt are setup (INT19 and beyond are OK)
;
; On entry,
;	maxticks set by StartTime
;	ints enabled
;
; On exit,
;	CY set if timeout
;	all registers preserved
;
; 881030 1.0 GK
;------------------------------------------------------------------------------

CheckTime	proc	near

		push	ax
		push	cx
		push	dx
        push    di  
        push    es

;;		mov	ah, 0
;;		int	1Ah			; get current tick

        mov     ax, 40h
        mov     es, ax
        mov     di, 6Ch
        mov     dx, es:[di]
        mov     cx, es:[di+2]

		sub	dx, DGroup:StartTick
		cmp	dx, DGroup:MaxTicks
		cmc

        pop es
        pop di
		pop	dx
		pop	cx
		pop	ax

		ret				; return with CY set if timeout

CheckTime	endp



;----------------------------------------------------------------------
;  Routine Name:  NADTransmitPacket Routine
;
;  Description: The NADTransmitPacket Routine accepts all directed
;     send requests from the RIPL ROM NID code.  This
;     routine determines the validity of the request and
;     works with the adapter to carry it out.
;
;  Input:   ES:SI - pointer to ED
;     DS - Data Segment of RPL Module
;     ints disabled (spec says enabled)
;
;  Output:  ED Completion Code field updated
;     DS preserved
;     ints enabled (doesn't matter)
;
;  Calls:   TransmitPacket
;----------------------------------------------------------------------
public   NADTransmitPacket ; for DEBUGGING
NADTransmitPacket  PROC near

	push	ds			; save caller ds


;	mov	word ptr TxEDPtr, si	; save ED pointer
;	mov	word ptr TxEDPtr+2, es

;	assume   ds:CGroup

	cld				; Clear direction

	; calc number of bytes needed to pad to dword size
	mov	cx, es:[si].ED_Length	; get total packet length
	mov	bx, cx
	neg	cl
	and	cl, 3
	mov	DGroup:PadBytes, cl

	cli				; ints off

;;int 03

	mov	dx, DGroup:PortCmdStatus
	mov	ax, 801h
	out	dx, ax

	mov	dx, DGroup:PortTxFree
	in	ax, dx
	cmp	ax, bx
	jae	ww

    mov es:[si].ED_ErrCode, TRANSMIT_ERROR
    jmp NetSendRet
; write preamble & MAC header to Tx FIFO

ww:
	mov	dx, DGroup:PortCmdStatus
	mov	ax, 804h
	out	dx, ax
	mov	dx, DGroup:IOBASE	
	add	dx, 6
	in	ax, dx
	test	ax, 300h
	jz	ww1

;;int 03

ww1:
	sub	dx, 2
	in	ax, dx
	test	ax, 400h
	jz	ww2

ww2:

	mov	dx, DGroup:PortCmdStatus
	mov	ax, 801h
	out	dx, ax

	mov	dx, DGroup:PortTxFIFO

	mov	ax, es:[si].ED_Length	; get total packet length
	inc	ax

	and	al, 0feh		; len field in preamble evenized
	or	ah, high TXP_INTONSUCCESS ; generate TxStatus on all completions

	; write preamble
	out	dx, ax			; preamble
	xor	ax, ax
	out	dx, ax			; unused word

;	assume   ds:CGroup

	push	si			; save ED offset

;	lds	bx, cs:TxEDPtr
	mov	cx, es:[si].ED_FragCount; get fragment count
	lea	bx, [si].ED_FragOff	; point to first fragment descriptor

    push    ds

Tx_Frag_Loop:
	push	cx			; save fragment count
;	push	ds			; save fragment descriptor list segment
	mov	cx, es:[bx].FragLen	; length of this fragment

; !!!!!!!!!! Dmitry !!!!!!!!!!!!!
	lds	si, es:[bx].DPointer	; location of this fragment
	rep	outsb			; output bytes to adapter

Tx_Frag_End:
;	pop	ds			; restore frag descriptor list segment
	pop	cx			; restore fragment count
	add	bx, size Frag		; next descriptor
	loop	Tx_Frag_Loop		; loop through all fragments



Start_Tx:
	pop	ds			; restore ds
;	assume ds:CGroup


	mov	cl, DGroup:PadBytes
	rep	outsb			; pad packet to dword

	pop	si			; restore ED offset

	mov	DGroup:RxPend, TRUE		; indicate ready for a receive

	; wait for completion, and check for errors
	sti				; ints on again
	mov	ax, 5 ; 20 ; 5
	call	StartTime
;;	mov	ah, 0			; get current system tick count
;;	int	1Ah			; timer services
;;	mov	DGroup:StartTick, dx		; save timer value

WaitForEndTx:
;;;	mov   dx, DGroup:PortTxSTatus
;;;	in al, dx
;;;	in al, dx	
;;;	test  al, TXS_COMPLETE  ; done yet?
       cmp DGroup:flag, 1
       je    TxFinish  
;;;	jnz   TxFinish       ; jump if Tx complete

	call	CheckTime
	jnc	    WaitForEndTx	; check status again if not timeout
;;	mov   ah, 0       ; get current system tick count
;;	int   1Ah         ; timer services
;;	sub   dx, DGroup:StartTick     ; subtract start time
;;	cmp   dx, 5       ; 5 ticks time-out
;;	jb   WaitForEndTx      ; loop until time-out

BadConnection:
        mov   DGroup:flag, 0  
;;int 03
	mov   dx, DGroup:PortTxSTatus
	in al, dx
	mov   DGroup:RxPend, 0      ; clear Rx flag
	mov   dx, DGroup:PortCmdStatus
	call  TxReset     ; make sure FIFO is flushed

		; enable the transmitter
	mov     ah, CMDH_TXENABLE
	out     dx, ax

	mov   bx, offset DGroup:NoNetMsg

;		mov   cs:[StatusMsgFlag],bx   ; only for RPL

;	les   si, TxEDPtr

;    db 0F1h
	; set ErrStruct to print msg
;;	mov   es:[si].ED_ErrMsg, bx   ; should be ES:

	; Set return code to transmit error
	mov   es:[si].ED_ErrCode, TRANSMIT_ERROR

    stc
	jmp   short NetSendRet

; copy done, return

TxFinish:
	mov	dx, DGroup:PortCmdStatus
	mov	ax, 801h
	out	dx, ax
	mov   dx, DGroup:PortTxSTatus
	in al, dx
    mov   DGroup:flag, 0  
;;	out   dx, al         ; pop Tx status
	test  al, TXS_ERRTYPE   ; any error bits set?
	jnz   NetSendError

;	les   si, TxEDPtr

	; Set return code to successful
	mov   es:[si].ED_ErrCode, SUCCESSFUL
    clc

NetSendRet:
	pop	ds			; restore callers ds
	ret

NetSendError:
;		mov   cs:[StatusMsgFlag], offset CGroup:TxMsg ; only for RPL

;    db 0F1h
	push  ax
;	les   si, TxEDPtr

	; set ErrStruct to print msg
	mov   es:[si].ED_ErrMsg, offset DGroup:TxMsg

	; Set return code to transmit error
	mov   es:[si].ED_ErrCode, TRANSMIT_ERROR
	pop   ax

	mov   DGroup:RxPend, 0      ; clear Rx flag
	test  al, TXS_UNDERRUN or TXS_JABBERERROR
	jz NotTxUnderOrJabber

;;int 03
	call  TxReset     ; reset transmitter
	; enable the transmitter
	mov     ah, CMDH_TXENABLE
	out     dx, ax

    stc
	jmp   short NetSendRet

NotTxUnderOrJabber:
	; enable the transmitter
	mov     ah, CMDH_TXENABLE
	out     dx, ax

    stc
	jmp   short NetSendRet

NADTransmitPacket  ENDP



;------------------------------------------------------------------------------
; packet completed, but RxStatus.Err indicates the packet experienced an error
; during receiving.


ip_bad:
;        db 0F1h
		mov   dx, DGroup:PortCmdStatus
		call  RxDiscard      ; preserve all regs, except ah
		jmp    int_next      ; go directly to int_next without
          					 ; updating errcounts (BootWare doesnt
		    				 ;   keep count)

;------------------------------------------------------------------------------
; various errors: No ECB, pkt too small, pkt too big, pkt with bad size

ip_bad_llc:
not_eii_pkt:
ip_discard_pkt:
;    db 0F1h
;;int 03
	mov   dx, DGroup:PortCmdStatus
	call  RxDiscard 
	jmp   int_next    ; dx = port CmdStatus


;--------------------------------------------------------------------
;
;  Rx Complete interrupt.  PIO only.
;
;--------------------------------------------------------------------
; entry:
;   interrupt is disabled at adapter level. (through SetIntMask cmd).
;   EOIs have been issued to PICs.
;   we've not done sti
;
;   dx = port CmdStatus
;   ds = cs (CGroup)
;   cli
;   cld
;
;--------------------------------------------------------------------


			 public isr_RxPIO

isr_RxPIO:


    	mov	    dx, DGroup:PortCmdStatus
    	mov	    ax, 801h
    	out	    dx, ax

		mov     dx, DGroup:PortRxStatus

		in      ax, dx         ; ax = RxStatus
		test    ah, RXSH_ERROR    ; error reported?
		jnz     ip_bad


	; get Packet Length from RxStatus register (win 1,port8)
	mov	dx, PortRxStatus
	in	ax, dx			; ax = RxStatus
	and	ax, 07ffh		; keep only last 11 bits

   	call	GetED
	jz	ip_discard_pkt		; we didn't get an ED

	mov	bx, si			; move ED offset to bx

	mov	es:[si].ED_Length, ax	; save length in ED

	mov	cx, es:[si].ED_FragCount; get number of fragments

	lea	bx, [si].ED_FragOff	; point to 1st descriptor

	mov	dx, ax			; move packet size to dx

DRxNxtF:
	push	cx
	push	es
	mov	cx, es:[bx].Dlen	; get fragment length
;;	les	di, es:[bx].Dpointer	; get fragment pointer
	mov	ax, ds
	mov	es, ax
	mov	di, word ptr es:[bx].Dpointer	; get fragment pointer

ChkMovSize:
	cmp	dx, cx
	ja	MoveFrag		; more data after this frag

	mov	cx, dx			; no more data after this frag

MoveFrag:
	sub	dx, cx			; subtract size of this frag
	jcxz	DrxDoNxt 		; zero count -- skip data read

	push	dx
	mov	dx, PortRxFIFO
	rep	insb
	pop	dx

DrxDoNxt:
	pop   es
	pop   cx
	add   bx, 6    ; point to next fragment desc
	loop  DRxNxtF  ; do next frag, if any

; -- DX has # of bytes that couldn't fit in receive descriptors

NoRxFrag:

    	mov	es:[si].ED_ErrCode, 0	; Set good completion


;;IFDEF	UNDI
		lea	bx, es:[si].ED_FragOff	; point to 1st descriptor
		mov	ax, ds
		mov	es, ax
		mov	di, word ptr es:[bx].Dpointer	; get fragment pointer

		cmp	byte ptr es:[di], 01h
		jnz	NoMCastCheck		; not a MC address
;;db  0f1h
		mov	si, offset DGroup:MultiCast_Addresses
		mov	cx, (Eth_MCastBuf ptr [si]).MCastAddrCount
		jcxz	NoMCastCheck		; no MC address

		lea	si, (Eth_MCastBuf ptr [si]).MCastAddr
CheckMC:
		push	cx
		mov	cx, 6		;length of address in byte
    	repz	cmpsb
		jcxz	MCastFound	;this is our MC address

		add	si, 6
		pop	cx
		loop	CheckMC
;
; not our MC address, kill the recently saved ED
;
		mov	si, DGroup:[EDListCurrent]	; get current ED
		mov	word ptr [si].ED_Length, 0	;kill the data
		mov	DGroup:[EDListHead], si	; move the head backward
		jmp	DiscardRxData

MCastFound:
		pop	cx
NOMCastCheck:


;;	call	[AIPostEDJmp]		; post the received packet

; we've copied all packet data out of RxFIFO, now discard postamble and any
; pad bytes inserted by hardware.

DiscardRxData:
	mov   dx, DGroup:PortCmdStatus
	call  RxDiscard         ; discard padding & postamble

; copy is done, now tell foreground that a packet is available

	jmp    int_next


;--------------------------------------------------------------------
;
; TxReset - reset the transmitter
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
;--------------------------------------------------------------------
TxReset     proc  near
  
;int 03

    	mov   ax, CMD_TXRESET + TXRXRESET_ALLBUTBM
		out   dx, ax

?txrloop:   in      ax, dx
		test  ah, STH_BUSY
		jnz   ?txrloop                    ;; loop while busy

			ret
TxReset     endp

;--------------------------------------------------------------------
;
; RxReset - reset the receiver
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
;--------------------------------------------------------------------
RxReset     proc  near
		mov   ax, CMD_RXRESET
		out     dx, ax

?rxrloop:   in      ax, dx
		test    ah, STH_BUSY
		jnz     ?rxrloop                    ;; loop while busy
		ret
RxReset     endp

;--------------------------------------------------------------------
;
; RxDiscard - discard top packet in RxFIFO
;
; entry:
;   ds = DGROUP
;   dx = cmd/status port
;   cli
;
; exit:
;   cli
;
; destroys:
;   ax
;
;--------------------------------------------------------------------
RxDiscard   proc  near

		mov   ax, CMD_RXDISCARD
		out     dx, ax
?rxdloop:   in ax, dx
		test  ah, STH_BUSY
		jnz   ?rxdloop                    ;; loop while busy

		ret
RxDiscard   endp


;------ DoRxDiscard -------------------------------------------------
;
;  This routine performs an RxDiscard, including the workarounds
;  required by the Rev 1 versions of the ASIC.  It has been made a
;  procedure because the workarounds were getting too ungainly.
;
;  Entry:
;  DS = DGROUP
;  DX = port CmdStatus
;  cli
;
;  Exit:
;  cli
;  Destroys AX.  All other registers preserved.
;--------------------------------------------------------------------

		public   DoRxDiscard

DoRxDiscard proc  near

	mov   dx, DGroup:PortCmdStatus

; issue the RxDiscard and wait for it to complete

	mov   ah, CMDH_RXDISCARD
	out   dx, ax         ; discard the packet

discard_busy:
	in    ax, dx
	test  ah, STH_BUSY
	jnz   discard_busy       ; loop while busy

; check RxStatus.  if complete, everything is fine--just return.

	mov   dx, DGroup:PortRxStatus
	in ax, dx

	mov   dx, DGroup:PortCmdStatus

	ret

DoRxDiscard endp

;------ SoftRxReset -------------------------------------------------
;
;  This routine does an RxReset to clear out the RxFIFO and its
;  associated logic.  After the RxReset, it reenables and restores
;  the current RxFilter and RxEarly thresholds.
;
;  Entry:
;  DS = DGROUP
;  DX = port CmdStatus
;  cli
;
;  Exit:
;  cli
;  Destroys AX.  All other registers preserved.
;
;--------------------------------------------------------------------

		 public SoftRxReset
SoftRxReset   proc   near

	call  RxReset

	mov   dx, DGroup:PortCmdStatus
	mov   ax, DGroup:HWFilter      ; has CMD_SETFILTER in it
;db  0f1h
	out   dx, ax

		; enable the receiver
		mov     ah, CMDH_RXENABLE
		out     dx, ax


	mov   ax, DGroup:NormalRxEarly ; has CMD_SETRXEARLY in it
	out   dx, ax

	ret
SoftRxReset endp



;----------------------------------------------------------------------
;  Routine Name:  NADDisengage Routine

;  Description: The NADDisengage routine is used by the RIPL ROM NID
;     portion of the RIPL ROM to signal the Network Driver
;     to release its IRQ, DMA, and memory resources.
;
;  Input:   DS - Data Segment of RPL Module
;     ints enabled
;
;  Output:  DS preserved
;     ints enabled
;     ax = offset to error string or 0 if successful
;
;  Calls:   none
;
; July 10,91   implement NIDDisengage version 0.8
;----------------------------------------------------------------------
NADDisengage   PROC  FAR
	push  ds
	push  es

	cli



		; 3Com 5X9 NDIS driver place ISR at IRQ 2 rather than IRQ 9 ( compatibility
		; with IBM 3270 program ). Thus, this routine needs to restore the old
		; BIOS IRQ9 handler to invoke IRQ2. Also, this routine should NOT
		; mask IRQ9.

		mov    dx, DGroup:Int_mask_port
		in     al, dx
	
		or     al, DGroup:IRQBit
		jmp    $+2

		out    dx, al

		; restore handler
		call  DriverUnhook

		; unmask IRQ 9 again so that interrupt will pass to IRQ2 ISR
		cmp   DGroup:IRQNumber, 9
		jnz   DisengageExit

		mov   dx, 0a1h
		in al, dx
		and   al, 0fdh
		out   dx, al

DisengageExit:
		pop   es
		pop   ds

		sti
		xor   ax, ax

;;        int 03

        clc
		retf        ; Return to caller

NADDisengage   endp


;------------------------------------------------------------------
;
; DriverISR:  Interrupt Service Routine for Vulcan
;
;------------------------------------------------------------------

;;		 public DriverISR
		 public isr_1st_pass
		 public int_next
		 public isr_return
		 public isr_again
		 public isr_enable

		 ALIGN  4
		 db     'ISR'

BootISR     proc   far
;;db  0f1h
		 pusha
		 push   ds
		 push   es


	cld
	mov   dx, DGroup:PortCmdStatus


; make sure the adapter is in window 1, which is where it should always
; be post-init with interrupt enabled

; mask off all interrupts at adapter level. and release the system interrupt


		 mov    ax, CMD_SETINTMASK + MASK_ALL
		 out    dx, ax           ; disable all interrupts

		; acknowledge interrupt
		mov    ax, CMD_ACKNOWLEDGE + INT_LATCH
		out    dx, ax

		mov    ax, DGroup:eoi_value          ; ah = EOI for master PIC
						 ; if int < 8, eoi_value = 6040h
						 ;   else eoi_value = 6220h

		 cmp    al, 40h             ; Int level < 8 ? (i.e. NOP)
		 jz   EOIMaster         ; No, need EOI to Slave PIC

		 out    SlaveEOIPort, al          ; al = EOI for slave PIC

	jmp   $+2
	jmp   $+2
	jmp   $+2
	jmp   $+2
	jmp   $+2
	jmp   $+2


EOIMaster:
		 mov    al, ah           ; send EOI to Master 8259 PIC
		 out    MasterEOIPort, al

;----------------------------------------------------------------------------
; read the reason for the interrupt and dispatch control to the appropriate
; routine through jump table.  When that reason has been handled the routine
; will jump  to int_next.  if there is no reason for the interrupt
; we will simply end up at isr_return. the following types of interrupt
; are handled:
;
;      a. Adapter Failure
;      b. Rx Complete
;      c. Interrupt Request (not supported, ack and return)

		 public isr_1st_pass

isr_1st_pass:
	mov   dx, DGroup:PortCmdStatus

		 in     ax, dx           ; 05-21-92
		 jmp    IntDispatch

; there is another interrupt reason.  since we might be close to our disable
; time limit, enable before we handle it.

isr_again:           ; AL has CmdStatus contents
;int 03
		 sti
		 nop
		 cli
		 jmp    IntDispatch

; once the code entered through IntDispatch has completed its task, it jumps
; to this label. check for any remaining reasons.

		 public int_next

int_next:

	mov   dx, DGroup:PortCmdStatus

		 in     ax, dx       ; read status reg see if any
		 test   al, al       ; more interrupts to be
		 jnz    isr_again       ; serviced?

;-----------------------------------------------------------------------------
; nothing left showing in status.


isr_return:

;----------------------------------------------------------------------------
; reenable interrupts from the adapter.
;
; note: if indications are disabled, they are masked off through the
; ReadZeroMask so reenabling interrupts will have no effect on those bits.

isr_enable:
;;db  0f1h
		cli

		mov   dx, DGroup:PortCmdStatus
		mov   ax, CMD_SETINTMASK + BOOTWARE_INTS
		out   dx, ax

;950214       port   cs:CmdStatus          ; 03-24-92
		pop   es
		pop   ds
		popa

		iret

BootISR   endp

; 3Com's driver used a 128-word jmp table - faster, but too much room for us...

IntDispatch:            ; prioritized dispatch (err, Rx, Tx)
	test  al, INT_ADAPTERFAIL
	jz IntNotFail

;    db 0F1h
	jmp   isr_AdapterFailure

IntNotFail:
	test  al, INT_RXCOMPLETE
	jz IntNotRxComplete

;;db  0f1h
	jmp   isr_RxPIO

IntNotRxComplete:
;int 03
;    db 0F1h
	test  al, INT_TXCOMPLETE   ; shouldn't happen, only if cable
					; not connected
	jz IntNotTxComplete

	mov	dx, DGroup:PortCmdStatus
	mov	ax, 801h
	out	dx, ax

;;int 03
	mov   dx, DGroup:PortTxStatus
    in    al, dx
    cmp   al, 0C0h
    jne    xx
    mov DGroup:flag, 1
xx:
	out   dx, al         ; pop tx status to turn the bit off
	mov   dx, DGroup:PortCmdStatus
	mov    ax, CMD_ACKNOWLEDGE + 4
	out	dx,	ax
	jmp   int_next

IntNotTxComplete:
;;int 03
	test  al, INT_REQUESTED
	jnz   isr_return

isr_IntRequest:
		; acknowledge interrupt
		mov    ax, CMD_ACKNOWLEDGE + INT_REQUESTED
		out     dx, ax

		jmp   isr_return     ; Solve mysterious problem with V2

;--------------------------------------------------------------------
;
;  Adapter Failure interrupt.
;
;--------------------------------------------------------------------
; entry:
;   interrupt is disabled at adapter level. (through SetIntMask cmd).
;   EOIs have been issued to PICs.
;   we've not done sti
;
;   dx = port CmdStatus
;   ds = cs (CGroup)
;   cli
;   cld
;
; description:
;
;   Three possible reasons that force adapter to generate Adapter
;   Failure Interrupt are:
;
;        1. Rx DMA Trouble (DMA is enabled on a non-dword boundary)
;        2. Rx Underrun
;        3. Tx Overrun
;
;   Diagnostics Register offset 4, window 4 contains information of
;   what causes this interrupt.  Since this interrupt will hardly
;   be generated if software and hardware work properly, we should
;   not see it happen.
;
;   For the moment the only conditins we attempt any workaround for is
;   RxUnderrun and TxOverrun.  For RxUnderrun, we simply reset the
;   receiver by calling SoftRxReset.  For TxOverrun, we simply reset
;   the transmitter and start things going again.
;
;   Other than that, we do not attempt any workarounds to get the board
;   up and running again.  We simply die a graceful death in as little
;   code space as possible.
;
;--------------------------------------------------------------------

		 public isr_AdapterFailure

isr_AdapterFailure:

;;int 03

		SelectWindow WNO_DIAGNOSTICS        ; switch to window 4

		mov   dx, DGroup:PortFIFODiag
		in     ax, dx

		mov   dx, PortCmdStatus

		test   ax, FIFOD_RXUNDERRUN
		jz     chk_tx_overrun

; RxUnderrun.  ASIC (rev 1) adapter failure int. due to a false RxUnderrun.
; we just call SoftRxReset to reset the receiver and return to int_next as
; a software workaround to a hardware problem.

		 public AdapterFailure_Rxunderrun

AdapterFailure_Rxunderrun:
		SelectWindow WNO_OPERATING

		mov   dx, DGroup:PortCmdStatus
		call   SoftRxReset
		jmp    int_next

chk_tx_overrun:
		test   ax, FIFOD_TXOVERRUN
		jz     ia_shutdown

; TxOverrun.  Probably a software error, but since its probably on the back end
; of the TxFIFO and the error shuts down the transmitter, we won't have sent
; any bad packets yet (with rev 1 silicon).  Reset the transmitter and start
; things up again.

		public AdapterFailure_TxOverrun

AdapterFailure_TxOverrun:
		call  TxReset

		mov    ax, DGroup:CurTxStart
		out    dx, ax

		; enable the transmitter
		mov     ah, CMDH_TXENABLE
		out     dx, ax


		SelectWindow WNO_OPERATING

; shut off the transmitter and receiver
		public ia_shutdown

ia_shutdown:
		mov   dx, DGroup:PortCmdStatus
		SelectWindow WNO_OPERATING

		; Tx Disable
		mov     ah, CMDH_TXDISABLE
		out     dx, ax

				; Disable the receiver
		mov     ah, CMDH_RXDISABLE
		out     dx, ax

; disable additional interrupts from the adapter

		mov    ax, CMD_SETRZMASK + MASK_ALL
		out    dx, ax
		jmp    int_next
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\undi_equ.inc ===
;
;--- Miscellaneous Equates
;
CR		equ	0Dh           ;- Carriage Return
LF		equ	0Ah           ;- Line Feed
FALSE		equ	0
TRUE		equ	1
;
;--- Ethernet Frame Sizes
;
ETHERNET_ADDRESS_LENGTH		equ	6
ETHERNET_HEADER_SIZE		equ	14
MINIMUM_ETHERNET_PACKET_SIZE	equ	60
;MAXIMUM_ETHERNET_PACKET_SIZE	equ	1514
MAXIMUM_ETHERNET_PACKET_SIZE	equ	1500 ;; just data, not media header

MAX_PACKET         Equ       1514      ; Maximum allowable packet size.
MIN_PACKET         Equ       60        ; Minimum allowable packet size.
; 
;--- Packet filter bit definitions
; 
FLTR_DIRECTED                Equ       01H
FLTR_MLTCST                  Equ       01H
FLTR_BRDCST                  Equ       02H
FLTR_PRMSCS                  Equ       04H
FLTR_SRC_RTG                 Equ       08H
;
;--- Processor Type Equates
;
EIGHT_BIT          equ       0001H
SIXTEEN_BIT        equ       0002H
PROC_TYPE_MASK     equ       0030H

PROC_8086          equ       0000H OR EIGHT_BIT
PROC_80286         equ       0010H OR SIXTEEN_BIT
PROC_80386         equ       0020H
PROC_80486         equ       0040H
;
;--- Result codes returned in AX by a PXE API service.
;
PXENV_EXIT_SUCCESS		equ	0
PXENV_EXIT_FAILURE		equ	1
PXENV_EXIT_CHAIN		equ	0FFFFh	; used internally
;
;--- Status codes returned in the status word of PXE API parameter structures.
;
PXENV_STATUS_SUCCESS		equ	0
PXENV_STATUS_FAILURE		equ	1	;general failure
PXENV_STATUS_BAD_FUNC		equ	2	;invalid function number
PXENV_STATUS_UNSUPPORTED	equ	3	;not yet supported
PXENV_STATUS_1A_HOOKED		equ	4	;Int 1AH cannot be unhooked

; Driver errors (60 to 0x6F)
; These errors are for UNDI compatible NIC drivers.
PXENV_STATUS_UNDI_MEDIATEST_FAILED 		equ	61h
PXENV_STATUS_UNDI_CANNOT_INIT_NIC_FOR_MCAST	equ	62h
;
;
EISA_ADAPTER             equ    1
PCI_ADAPTER              equ    2
PnP_ADAPTER              equ    3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\pxe_stru.inc ===
;
NUM_MCADDRS    	Equ	8		; max number of multicast addresses.
MAX_DATABLK    	Equ	8		; max number of data blocks supported 
					;	in a descriptor.
MAX_IMMED_LEN	Equ	64		; max immediate data buffer length
MAX_TX_DATABLK	Equ	MAX_DATABLK	; max number of data blocks supported 
					;	in a Tx descriptor.
MAX_TD_DATABLK	Equ	MAX_DATABLK	; max number of TransferData blocks
		
APIMaxFunc	EQU	0011h

ADDR_LEN	EQU	16
ETH_ADDR_LEN	EQU	6
MAXNUM_MCADDR	EQU	8

;
; protocol values in transmit buffer
;
P_UNKNOWN	EQU	0		;; no media header
P_IP	 	EQU	1		;; IP type
P_ARP		EQU	2		;; ARP type
P_RARP		EQU	3		;; RARP type

TYPE_IP	 	EQU	0800h		;; IP type
TYPE_ARP	EQU	0806h		;; ARP type
TYPE_RARP	EQU	8035h		;; RARP type
;
; xmitflag values in transmit buffer
;
PKT_DESTADDR	EQU 0	;; destination address given 
PKT_BROADCAST	EQU 1h	;; use broadcast address 
PKT_MULTICAST	EQU 2h	;; multicast addr given

;; Hardware type values
ETHER_TYPE 		EQU 1
EXP_ETHER_TYPE	EQU 2
IEEE_TYPE  	EQU 6
ARCNET_TYPE   	EQU 7


Eth_MCastBuf	Struc
MCastAddrCount	DW	?
MCastAddr	DB MAXNUM_MCADDR * ETH_ADDR_LEN dup (0)
Eth_MCastBuf	Ends

MC_MCastBuf		Struc
MC_MCastAddrCount	DW	?
MC_MCastAddr  		DB MAXNUM_MCADDR * ADDR_LEN dup (0)
MC_MCastBuf		Ends

NIC_StartUp	Struc
S_Status	DW	?
S_BusType	DB	?
S_AddrType	DB	?
S_DataSeg	DW	?
S_DataSegAddr	DD	?
S_DataSegSize	DW	?
S_CodeSegSize	DW	?
S_BusDevFunc	DW	?	;; PCI Dev_ID
S_PCI_ds_off	dw	?	;; Far pointer to PCI data structure
S_PCI_ds_seg	dw	?
S_PnP_csn	dw	?	; Card select number.-1 for non-PnP BBS device
S_PnP_eh_off	dw	?	; Far pointer to PnP expansion header
S_PnP_eh_seg	dw	?
NIC_StartUp	Ends

NIC_CleanUp	Struc
CL_Status	DW	?
NIC_CleanUp	Ends

NIC_Initialize	Struc
I_Status	DW	?
I_Prot_ini	DD	?
I_RcvInt	DD	?
I_GenInt	DD	?
NIC_Initialize  Ends

NIC_Reset	Struc
R_Status	DW	?
R_MCBuf		MC_MCastBuf <>
NIC_Reset	Ends

NIC_ShutDown	Struc
SD_Status	DW	?
NIC_ShutDown	Ends

NIC_Open	Struc
O_Status	DW	?
O_OpenFlg	DW	?
O_PktFilter	DW	?
O_MCBuf		MC_MCastBuf <>
NIC_Open	Ends

NIC_Close	Struc
C_Status	DW	?
NIC_Close	Ends

X_DataBlock	Struc
X_TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
X_TxRsvdByte	DB	?	; Reservered, must be zero.
X_TxDataLen	DW	?	; Data block length in bytes.
X_TxDataPtr	DD	?	; Far pointer to data block.
X_DataBlock Ends

NIC_TBD		Struc
X_Length	DW	?
X_BufOff	DW	?
X_BufSeg	DW	?
X_DataBlkCount	DW	?		; will always be zero for base code
X_DataBlk	DB	MAX_DATABLK * SIZE X_DataBlock dup (0)	
NIC_TBD		Ends

NIC_Transmit		Struc
T_Status		DW	?
T_Protocol		DB	?
T_XmitFlag		DB	?
T_DestAddrOffset 	DW	?	; 16-bit segment & offset of the
T_DestAddrSegment 	DW	?	; destination media address 
T_TBDOffset		DW	?	; 16-bit segment & offset 
T_TBDSegment		DW	?	; transmit buffer descriptor 
T_Reserved		DD	2 dup(0)	; for future use	
NIC_Transmit Ends

NIC_SetMCastAddr	Struc
SM_Status		DW	?
SM_MCBuf		MC_MCastBuf <>
NIC_SetMCastAddr	Ends

NIC_SetStationAddr	Struc
SS_Status		DW	?
SS_StationAddr		DB	ADDR_LEN dup (0)
NIC_SetStationAddr	Ends

NIC_SetPacketFilter	Struc
SP_Status		DW	?
;;SP_NewFilter		DW  ?
SP_NewFilter		DB  ?
;;SP_MCBuf		MC_MCastBuf <>
NIC_SetPacketFilter	Ends

NIC_GetInfo	Struc
GI_Status		DW	?
GI_BaseIo		DW	?
GI_IntNumber		DW	?
GI_MTU			DW	?
GI_HwType		DW	?
GI_HwAddrLen		DW	?
GI_CurrentNodeAddress	DB ADDR_LEN dup (0)
GI_PermNodeAddress	DB ADDR_LEN dup (0)
GI_ROMAddress		DW 	?
GI_RxBufCt		DW	?
GI_TxBufCt		DW	?
NIC_GetInfo	Ends

NIC_GetNICType_pci 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
Vendor_ID	DW	?	; /* OUT:  */
Dev_ID		DW	?	;  /* OUT:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */ 
Rev		DB	?	;  /* OUT: Revision number */ 
BusDevFunc	DW	?	; /* OUT: Bus, Device & Function numbers */
NIC_GetNICType_pci 	Ends

NIC_GetNICType_pnp 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
EISA_Dev_ID	DD	?	; /* Out:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */
CardSelNum	DW	?	; /* OUT: Card Selector Number */
Res		DB	0	;
NIC_GetNICType_pnp 	Ends

NIC_GetStatistics	Struc
GS_Status		DW	?
GS_XmtGoodFrames	dd    ?
GS_RcvGoodFrames	dd    ?
GS_RcvCRCErrors		dd    ?
GS_RcvResourceErrors	dd    ?
NIC_GetStatistics	Ends

NIC_ClearStatistics	Struc
CS_Status		DW	?
NIC_ClearStatistics	Ends

NIC_InitDiags	Struc
ID_Status	DW	?
NIC_InitDiags   Ends

NIC_ForceInterrupt	Struc
FI_Status		DW	?
NIC_ForceInterrupt	Ends

NIC_GetMCastAddr	Struc
GM_Status		DW	?
GM_InetAddr		DD	?
GM_HwAddr		DB	ADDR_LEN dup (0)
NIC_GetMCastAddr	Ends

;NIC_API_Entry	Struc
;Signature 	DB	'PXENV+'	;; not null terminated
;Version		DW	0100h		;; 1.0
;StrucLength	DB	0		;; length of this structure
;CheckSum	DB	0		;; fill in later
;rm_entry_off	DW	0		;; real mode driver entry offset
;rm_entry_seg	DW	0		;; real mode driver entry segment
;pm_entry_off	DW	0		;; protected mode driver entry offset
;pm_entry_seg	DW	0		;; protected mode driver entry segment
;NIC_API_Entry	Ends

s_PXENV_ENTRY	Struc
signature	db	6 dup(?)	; 'PXENV+'
ver             dw      ?               ; MSB=major, LSB=minor
bytes		db	?		; sizeof s_pxenv_entry
checksum	db	?		; 8-bit checksum of structure,
					; including this byte shoube be zero.
rm_entry_off	dw	?		; 16-bit real-mode segment & offset.
rm_entry_seg	dw	?
pm_entry_off	dw	?		; 16-bit protected mode 32-bit physical
pm_entry_base	dd	?		; address and 16-bit offset.
stack_sel	dw	?		; PROM stack segment.  Will be set
stack_size	dw	?		; to 0 when removed from memory.
base_cs_sel	dw	?		; Base code segment.  Will be set
base_cs_size	dw	?		; to 0 when removed from memory.
base_ds_sel	dw	?		; Base data segment.  Will be set
base_ds_size	dw	?		; to 0 when removed from memory.
mlid_ds_sel	dw	?		; MLID data segment.
mlid_ds_size	dw	?
mlid_cs_sel	dw	?		; MLID code segment.
mlid_cs_size	dw	?
s_PXENV_ENTRY	Ends

;; Ethernet II protocol header
EtherHeader	Struc
E_DestAddr	DB 6 dup (0)	;; destination ethernet addr
E_SrcAddr	DB 6 dup (0)	;; destination ethernet addr
E_Type		DW  ?	;; protocol type
EtherHeader	Ends

ETHER_HEADER_LEN	Equ	SIZE EtherHeader

; 
; * Data structures for TransmitChain (Tx), TransferData (TD)
; 
TxDataBlock	Struc
TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TxRsvdByte	DB	?	; Reservered, must be zero.
TxDataLen	DW	?	; Data block length in bytes.
TxDataPtr	DD	?	; Far pointer to data block.
TxDataBlock	Ends

; 
; * TransmitChain descriptor structure definition
; 
TxBufDesc	Struc
TxImmedLen	DW	?	; Byte count of immediate data, max=64
TxImmedPtr	DD	?	; Virtual address of Immediate data
TxDataCount	DW	?	; Number of Data Blocks (max = 8)
TxDataBlk	DB	size TxDataBlock * MAX_TX_DATABLK dup(0)
TxBufDesc	Ends

TxBufDescrSize	Equ	Size TxImmedLen + Size TxImmedPtr + Size TxDataCount

; 
; * TransferData data block description
; 
TDDataBlock	Struc
TDPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TDRsvdByte	DB	?	; Reservered, must be zero.
TDDataLen	DW	?	; Data block length in bytes.
TDDataPtr	DD	?	; Far pointer to data block.
TDDataBlock	Ends

; 
; * TransferData descriptor structure
; 
TDBufDesc	Struc
TDDataCount	DW	?	; No of Data Blocks (max 8 for V1.01).
TDDataBlk	DB	size TDDataBlock*MAX_TD_DATABLK dup(0)
TDBufDesc	Ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\spdosegs.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/SPDOSEGS.INV   1.5   19 Sep 1997 21:39:18   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: segment declaration and ordering for NDIS driver
;


;-----------------------------------------------------------------------
;
; Functional Description
;
;   This file defines the segments used by a MAC driver and the order
;   in which they are loaded. The groups DGROUP (for data) and CGROUP
;   (for code) are also defined, as are macros to open and close
;   segments (which also set up the default segment assumptions).
;
;-----------------------------------------------------------------------

;=======================================================================
;** Segment Definitions - order counts!
;
; DOS Order:
;      CGROUP, DGROUP
;         DevHeaderSeg
;         _TEXT
;         _DATA 
;         CONST
;         _BSS
;   ; Code and data will be cut off here.	;; AVL - not any more
;         ICODE
;         IDATA
;
; AVL - NEW Order:
;   CGROUP
;         DevHeaderSeg
;         _TEXT
;		  ICODE		;; DOS driver specific init routines, not needed for ROM
;	 DGROUP
;         _DATA 
;         CONST
;         _BSS
;         IDATA		;; just to mark the upper boundary.
;
;========================================================================


;==========================================================================
; DOS segment definitions and ordering.
;==========================================================================
Ifdef DRV
DevHeaderSeg   segment para public USE16 'CODE'
DevHeaderSeg   ends
Endif	;; DRV
;--------------------------------------------------------------------------
; Resident Code segment - code that is used after init time
; (unfortunately, this includes code to bind another driver, and
; initializations that take place at bind time) should be placed in this
; segment.
;--------------------------------------------------------------------------
_TEXT       segment para public USE16 'CODE'
_TEXT       ends

Ifdef DRV
ICODE       segment para public USE16 'INIT'
ICODE       ends
Endif	;; DRV
;--------------------------------------------------------------------------
; Resident Data segment - things put here will remain in memory after
; init time. At the present time, this is in low memory, so data that is
; not used after init time should NOT be put in this segment.
;--------------------------------------------------------------------------
_DATA       segment para public USE16 'DATA'
_DATA       ends

Ifdef DRV
_BSS       segment para public USE16 'DATA'
_BSS       ends
IDATA       segment para public USE16 'DATA'
IDATA       ends
Else
_BSS       segment para public USE16 'BSS'
_BSS       ends
Endif	;; DRV
;--------------------------------------------------------------------------
; Make sure the segment order defined in this file is respected.
;--------------------------------------------------------------------------
.SEQ               


;--------------------------------------------------------------------------
; DOS Group is all one 64K segment, CS=SS=DS, use equate for DGROUP.
;--------------------------------------------------------------------------

;DGROUP      equ     CGROUP
;CGROUP      group   DevHeaderSeg, _TEXT, _DATA, CONST, _BSS, ICODE, IDATA

Ifdef DRV
CGROUP      group   DevHeaderSeg, _TEXT, ICODE
DGROUP      group   _DATA, _BSS, IDATA
ELSE
CGROUP      group   _TEXT
DGROUP      group   _DATA, _BSS
Endif	;; DRV
;--------------------------------------------------------------------------
; Group is 64K data, 64K code, CS!=SS=DS, actual group for Code.
;--------------------------------------------------------------------------

;--------------------------------------------------------------------------
; Assume statement here takes care of for any source, same for OS2 and DOS.
;--------------------------------------------------------------------------
    Assume   CS:CGROUP, DS:DGROUP, ES:NOTHING, SS:NOTHING


; EOF - $Workfile:   spdosegs.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\sstrucs.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/SSTRUCS.INV   1.4   19 Sep 1997 21:39:20   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description      :    NDIS structures and bit definitions for fields
;                         within those structures, name of driver, etc.
;                         THIS FILE HAS BEEN MODIFIED FROM NDIS NDK VERSION.
;

;
; File: sStrucs.inc    - Support Structures include NDIS specific.
;
;

;-----------------------------------------------------------------------------
;
;    The following equates are the primary configuration for the driver.
;
; * maximum number of multicast addresses.
;
NUM_MCADDRS        Equ       8
;
; * Maximum number of data blocks supported in a descriptor.
;
MAX_DATABLK        Equ    8
;

;-----------------------------------------------------------------------------
;
;    The following equates and structures should only be changed when
;    upgrading to a newer NDIS specification.
;

; * define the length of names and addresses in the Common Characteristics
; * and Specific Characteristics table.
;
NAME_LEN    Equ    16
ADDR_LEN    Equ    16
ADDR_SIZE   Equ    6

;
MIN_LOOKAHEAD_DEFAULT        Equ       MIN_PACKET+4
MAX_LOOKAHEAD                Equ       256

DELAY_COPY					 Equ	   -1
SUCCESS                      Equ       0000H
WAIT_FOR_RELEASE             Equ       0001H
REQUEST_QUEUED               Equ       0002H
FRAME_NOT_RECOGNIZED         Equ       0003H
FRAME_REJECTED               Equ       0004H
FORWARD_FRAME                Equ       0005H
OUT_OF_RESOURCE              Equ       0006H
INVALID_PARAMETER            Equ       0007H
INVALID_FUNCTION             Equ       0008H
NOT_SUPPORTED                Equ       0009H
HARDWARE_ERROR               Equ       000AH
TRANSMIT_ERROR               Equ       000BH
NO_SUCH_DESTINATION          Equ       000CH
ALREADY_STARTED              Equ       0020H
INCOMPLETE_BINDING           Equ       0021H
DRIVER_NOT_INITIALIZED       Equ       0022H
HARDWARE_NOT_FOUND           Equ       0023H
HARDWARE_FAILURE             Equ       0024H
CONFIGURATION_FAILURE        Equ       0025H
INTERRUPT_CONFLICT           Equ       0026H
INCOMPATIBLE_MAC             Equ       0027H
INITIALIZATION_FAILED        Equ       0028H
GENERAL_FAILURE              Equ       00FFH

; 
; * Packet filter bit definitions.
; 
FLTR_DIRECTED                Equ       01H
FLTR_MLTCST                  Equ       01H
FLTR_BRDCST                  Equ       02H
FLTR_PRMSCS                  Equ       04H
FLTR_SRC_RTG                 Equ       08H

; 
; * MAC status bits in the MAC Specific Characteristics table.
; * Bits 0-2 are coded to reflect the hardware status.
; 
HW_MISSING                   Equ       0000H
HW_BUD_ERR                   Equ       0001H
HW_CFG_ERR                   Equ       0002H
HW_FAULT                     Equ       0003H
HW_SOFT_ERR                  Equ       0004H
HW_OK                        Equ       0007H
MS_HW_MASK                   Equ       HW_OK

MS_BOUND                     Equ       0008H
MS_OPEN                      Equ       0010H
MS_DIAGS_ON                  Equ       0020H

;
;    Definintions for the MAC Service Supported Flags.
;    Bits 0-15.
;
BroadcastSupport             Equ       TRUE
MulticastSupport             Equ       TRUE
FunctionalGroupSupport       Equ       FALSE
PromiscuousSupport           Equ       TRUE
SetStationAddrSupport        Equ       TRUE
StatusAlwaysCurrent          Equ       FALSE
DiagnosticsSupport           Equ       FALSE
LoopBackSupport              Equ       FALSE
ReceiveChainPrimary          Equ       FALSE
IBMSourceRouting             Equ       FALSE
ResetMACSupport              Equ       TRUE
OpenAdapterSupport           Equ       TRUE
InterruptRequestSupp         Equ       TRUE
SourceRoutingBridge          Equ       FALSE
GDTAddressesSupported        Equ       TRUE
MultipleXferDatas            Equ       TRUE      ; Also set MaxXferDatas
RcvLkFrameSizeZero           Equ       FALSE

;
; * Definintions for the MAC Service Supported Flags.
; * Bits 0-14.
;
ServiceFlags    =  00000000H
ServiceFlags    =  ServiceFlags Or BroadcastSupport
ServiceFlags    =  ServiceFlags Or (MulticastSupport Shl 1)
ServiceFlags    =  ServiceFlags Or (FunctionalGroupSupport Shl 2)
ServiceFlags    =  ServiceFlags Or (PromiscuousSupport Shl 3)
ServiceFlags    =  ServiceFlags Or (SetStationAddrSupport Shl 4)
ServiceFlags    =  ServiceFlags Or (StatusAlwaysCurrent Shl 5)
ServiceFlags    =  ServiceFlags Or (DiagnosticsSupport Shl 6)
ServiceFlags    =  ServiceFlags Or (LoopBackSupport Shl 7)
ServiceFlags    =  ServiceFlags Or (ReceiveChainPrimary Shl 8)
ServiceFlags    =  ServiceFlags Or (IBMSourceRouting Shl 9)
ServiceFlags    =  ServiceFlags Or (ResetMACSupport Shl 10)
ServiceFlags    =  ServiceFlags Or (OpenAdapterSupport Shl 11)
ServiceFlags    =  ServiceFlags Or (InterruptRequestSupp Shl 12)
ServiceFlags    =  ServiceFlags Or (SourceRoutingBridge Shl 13)
ServiceFlags    =  ServiceFlags Or (GDTAddressesSupported Shl 14)
ServiceFlags    =  ServiceFlags Or (MultipleXferDatas Shl 15)
ServiceFlags    =  ServiceFlags Or (RcvLkFrameSizeZero Shl 16)

MAC_Type    Equ    <'DIX+802.3'>       ; Specific Characteristic Type.
;
; Protocol Manager opcodes used by the generic model
;
GetPMInfo                    Equ       1
RegisterModule               Equ       2
BindAndStart                 Equ       3
GetPMLinkage                 Equ       4

Ifdef AVL
;-----------------------------------------------------------------------------
; 
; * multicast address structure is ADDR_LEN bytes long
; 
MCastAddr   Struc
mAddr       DB     ADDR_LEN dup(0)
MCastAddr   Ends

; 
; * the multicast address buffer manages NUM_MCADDRS multicast address
; * structures.
; 
MCastBuf    Struc
McbMax      DW     ?    ;  max # of multicast addresses
McbCnt      DW     ?    ;  curr# "        "

McbAddrs    DB     size MCastAddr*NUM_MCADDRS dup(0)
MCastBuf    Ends
Endif	;; AVL 

;-----------------------------------------------------------------------------
;
;    Structures defined by the NDIS specification and used by the generic
;    model.
;
;-----------------------------------------------------------------------------
; * immediate data buffer length cannot exceed 64 bytes.
; 
MAX_IMMED_LEN      Equ       64
; 
; * Maximum number of data blocks supported in a Tx descriptor.
; 
MAX_TX_DATABLK     Equ       MAX_DATABLK
; 
; * Max number of TransferData blocks
; 
MAX_TD_DATABLK     Equ       MAX_DATABLK
; 
; * MAx number of ReceiveChain data blocks
; 
MAX_RX_DATABLK     Equ       MAX_DATABLK

; 
; * Data structures for TransmitChain (Tx), TransferData (TD), and
; * ReceiveChain (Rx).
; 
TxDataBlock Struc
TxPtrType   DB     ?        ; 0 => Phys pointer, 1 => GDT pointer
TxRsvdByte  DB     ?        ; Reservered, must be zero.
TxDataLen   DW     ?        ; Data block length in bytes.
TxDataPtr   DD     ?        ; Far pointer to data block.
TxDataBlock Ends

; 
; * TransmitChain descriptor structure definition
; 
TxBufDesc   Struc
TxImmedLen  DW     ?        ; Byte count of immediate data, max=64
TxImmedPtr  DD     ?        ; Virtual address of Immediate data
TxDataCount DW     ?        ; Number of Data Blocks (max = 8)
TxDataBlk   DB     size TxDataBlock * MAX_TX_DATABLK dup(0)
TxBufDesc   Ends

TxBufDescrSize    Equ    Size TxImmedLen + Size TxImmedPtr + Size TxDataCount

; 
; * TransferData data block description
; 
TDDataBlock Struc
TDPtrType   DB     ?        ; 0 => Phys pointer, 1 => GDT pointer
TDRsvdByte  DB     ?        ; Reservered, must be zero.
TDDataLen   DW     ?        ; Data block length in bytes.
TDDataPtr   DD     ?        ; Far pointer to data block.
TDDataBlock Ends

; 
; * TransferData descriptor structure
; 
TDBufDesc   Struc
TDDataCount DW    ?        ; No of Data Blocks (max 8 for V1.01).
TDDataBlk   DB    size TDDataBlock*MAX_TD_DATABLK dup(0)
TDBufDesc   Ends

; 
; * ReceiveChain data block structure definition
; 
RxDataBlock Struc
RxDataLen   DW    ?        ; Length of the Data Block
RxDataPtr   DD    ?        ; Far Pointer to Data Block
RxDataBlock Ends

; 
; * ReceiveChain descriptor structure definition
; 
RxBufDesc   Struc
RxDataCount DW    ?        ; No of Data Blocks. (max 8 for V1.01).

RxDataBlk   DB    size RxDataBlock*MAX_RX_DATABLK dup(0)
RxBufDesc   Ends


;-----------------------------------------------------------------------------
; 
;    Structures used in Protocol.Ini parsing.
;
;  
; * Data structures for the "Module Configuration" structure parsed from
; * the PROTOCOL.INI file. see NDIS spec for details.
; 
Param       Struc
ParamType   DW    ?    ; 0 => 31 bit signed integer, 1 => string
ParamLen    DW    ?    ; String length (including null) or 4.
ParmStart   DB    ?    ; Start of actual parameter.
Param       Ends

KeywordEntry       Struc
NextKeywordEntry   DD        ?                   ;  Forward pointer
PrevKeywordEntry   DD        ?                   ;  Back Pointer
KeyWord            DB        NAME_LEN Dup(?)     ;  Keyword on left side of "="
NumParams          DW        ?                   ;  Number of parameters on r. side of "="
Params             DB        Size Param dup(?)   ;  Actual size depends on NumParams
KeywordEntry       Ends


ModCfg      Struc
NextModCfg  DD     ?                   ;  Module config images are in a
PrevModCfg  DD     ?                   ;  double-linked list.
ModName     DB     NAME_LEN Dup(?)     ;  Bracketed Module Name.
KE          DB     Size KeywordEntry Dup(?) ;  Head of Keyword list
ModCfg      Ends

ProIni      Struc
MC          DB     Size ModCfg*1 dup(?)  ; Head of Module config list.
ProIni      Ends

PI_Record   Struc
Srchkeyword        DB        '                ' ; keyword.
SrchParmType       DW        ?         ; 0 - numeric, 1 - string. see below.
ParamField         DD        ?         ; If numeric, will contain value, 
                                       ; If string, will contain the pointer to string.
RequiredField      DB        ?         ; Set to 1 if parameter is required.
SetFCN             DW        ?         ; Offset to Parser function.
PI_Record   Ends


;
; Processor Type Equates.
;
EIGHT_BIT          equ       0001H
SIXTEEN_BIT        equ       0002H
PROC_TYPE_MASK     equ       0030H

PROC_8086          equ       0000H OR EIGHT_BIT
PROC_80286         equ       0010H OR SIXTEEN_BIT
PROC_80386         equ       0020H
PROC_80486         equ       0040H


; EOF - $Workfile:   sstrucs.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90x\59x90x.asm ===
title	BootWare Boot PROM (C) Lanworks Technologies Inc.
	subttl	3C59X-90X 
	page	80,132
;===============================================================================
;  59X90X.ASM - produces 3Com 3C59X/3C90X EtherLink PCI version of BootWare
;
;    (C) Lanworks Technologies Inc. 1992 - 1996 All rights reserved.
;
;       No /d   Assemble for 3C59X only
;	/dBW90X	Assemble for 3C90X only
;	/dUNDI	Assemble for NetPC UNDI
;	
;  Revision History - version numbers refer to 59XP.ASM changes only
;
;   970509       RL - Add new functions for NetPC UNDI
;   970303 3.00  RL - Adapted to new AI interface
;   970207 2.10  RL - Modified to adapt the new NID/NAD API changes
;   961029 2.00  RL - Add /dBW90x switch and split the ROM into two separated ones
;   960905 1.81  RL - Fix a bug on BWTable checksum, 2 pages of ROM RD/WR
;   960730 1.80  RL - Add the support for 3c595-T4 & 3c90x
;   960618 1.63  GY - NADChgReceiveMask redo to support broadcast & disable
;   960517 1.62  GY - Autoscan code from ROMTOP is moved here.
;   960328 1.5X  GY - Take out EISA related code (eg EISAV3Conf)
;		    - Use \rom\genr\rpl\src\bwapi.asm
;		    - standardize port access
;		    - eliminate ethernet.inc, netware.inc, general.inc
;		    - clean up macros in vulcan.inc and general.inc
;		    - merge general.inc into vulcan.inc
;		    - clean up BW5X9.INC
;   960129 1.51  GY - use \ROM\GENR\AUTOSCAN\AUTOSCAN and new GENRs
;   950605 1.41  GY - With EISA, need to copy 2nd 16K BootROM into RAM
;   950318 1.00  GY - In NADTransmitPacket, error message pointer is incorrect
;*  950316 1.00  GY - Initial Release
;*==============================================================================
CR		equ	0Dh
LF		equ	0Ah

ASReverseAttr	equ	070h		; Attribute for reverse video
ASNormalAttr	equ	07h		; attribute for normal video

MasterEOIPort 	equ	20h
SlaveEOIPort 	equ	0a0h

FALSE           equ     0
TRUE            equ     0ffh

;
; the number of times through a timed loop to stay off the bus while polling
; for bus master completion to avoid slowing the bus master transfers down
;
Delay3us	equ	8
Delay3ms	equ	01c20h
Delay25ms	equ	0ea60h

InitSTACKPTR	equ	07f00h		; stack pointer for AutoScan Code

T4_PHY_ADDR     equ     01h
NWAY_PHY_ADDR   equ     18h

;BOOTWARE_INTS equ      INT_LATCH + INT_ADAPTERFAIL + INT_RXCOMPLETE + INT_REQUESTED

;-------------------------------------
; Include all general companion files
;-------------------------------------

	.xlist
IFDEF	UNDI
	include	spdosegs.inc
	include	pxe_stru.inc
ELSE
	include \rom\sdk\include\drvseg.inc
	include \rom\genr\include\cui.ext
ENDIF
	include bwnad.inc
	include	vulcan.inc
	.list


IFNDEF	UNDI
public	RunROMTOP
public	InternalConfig
public	WaitEEBusy

;public	HookConfig
				; for CUI...
public	HookEditInput
public	HookHyphen
public	HookEditSpec
public	HookChkChar
public	HookChkInput
public	ErrConfSpace
public	MemBase
public	StoHex			; for 5X9CONF
public	ChkForCfg
public	ChkKey

public	NormalRxEarly
public	CurTxStart

public	eoi_value
public	int_mask_port

public	NADPCIConfig
public	LANOption
public	setchksum
ENDIF

public	IRQLevel
public	HWFilter
public	RxReset
public	TxReset
public	Int_Vector_Loc
public	OrgINTVector_Off
public	OrgINTVector_Seg

;-----------------------------------
; External Data/Variable References
;-----------------------------------

IFDEF	UNDI
	extrn	UNDI_DriverISR:near
ENDIF

	extrn	PCIBusDevFunc:word
	extrn	IOBase:word			; ROMTOP.ASM

IFNDEF	UNDI
	extrn	Start:near

	extrn	PrintErrMsg:near		; 5X9CONF.ASM
	extrn	ErrIRQ7:byte			; 5X9CONF.ASM
	extrn	NormalAttr:byte			; CUI.ASM
	extrn	ReverseAttr:byte		; CUI.ASM

	extrn	elnk3conf:near			; 5X9CONF.ASM
	extrn	Elnk3ConfSparse:byte		; 5X9CONF.ASM
	extrn	ROMCodeStart:word		; ROMTOP.ASM
	extrn	PrintAt:near
	extrn	NADIntFD:near
ENDIF

IFDEF	DEBUG
	extrn	StringAH:byte
	extrn	StringAL:byte
	extrn	StringPCI:byte
ENDIF

IFNDEF	UNDI
; the following structure is template for received lookahead data, it contains
; MAC header and the 1st 18 bytes of IPX Header.

LookAheadBuf_stru  struc
	;
DestAddr      db   6 dup (?)	       ; this part is
SrcAddr       db   6 dup (?)	       ;  MAC header of
LenType       dw   ?		       ;   received packet
;
IpxChkSum     dw   ?		       ; this portion
IpxPktLen     dw   ?		       ;  is the first
IpxTransContr db   ?		       ;   18 bytes
IpxPktType    db   ?		       ;    of IPX
IpxDestNet    db   4 dup (?)	       ;      header of
IpxDestNode   db   6 dup (?)	       ;	received
IpxDestSocket dw   ?		       ;	  packet.
;
LookAheadBuf_stru  ends

LxBufSize     equ  size LookAheadBuf_stru

LookAhead8022	struc
;
DestAddr8022	  db   6 dup (?)	   ; this part is
SrcAddr8022	  db   6 dup (?)	   ;  MAC header of
LenType8022	  dw   ?		   ;   received packet

; 802.2 LLC
DSAP	      db   0
SSAP	      db   0
Control       db   0
;
LookAhead8022	ends
ENDIF

MACHDRSIZE   		equ 	14
ETHADDRSIZE   		equ	6      		; address size

	.386

IFDEF	UNDI
_TEXT		Segment para public
	assume	cs:CGroup, ds:DGroup
ELSE
START_NAD
ENDIF

IFDEF	BW90X
LanOption	db	'3Com 3C90X EtherLink PCI v3.00 (970303)',0
ELSE		
LanOption	db	'3Com 3C59X EtherLink PCI v3.00 (970303)',0
ENDIF

NoNetMsg	db	'Ethernet card improperly installed or not connected.',CR,LF,0
TxMsg		db	'Transmit error                                      ',0

IFNDEF	UNDI
	include \rom\sdk\include\bwnadapi.asm

;----------------- Device Driver Data Definitions --------------------
ErrConfSpace	db	09h,011h,' '
NothingString	db	0

StrEndless	db	013h,0ah,'Reboot system for changes to take effect',0

CfgStr 		db	'Configuring Ethernet Adapter, press Ctrl-Alt-B to modify configuration', 0

;-----------------------------------------------------------------------------
;      V A R I A B L E S
;-----------------------------------------------------------------------------

		   ALIGN     4

LookAheadBufferPtr label     dword
		   dw	     offset LookAheadBuffer
		   dw	     ?

; error messages - note BootWare prefaces them with a CR,LF

IFDEF	BW90X
StrPrompt	db	'Initializing 3C90X EtherLink PCI Adapter',0
ELSE
StrPrompt	db	'Initializing 3C59X EtherLink PCI Adapter',0
ENDIF
BlankStr	db	'                                        ',0

IFDEF	BW90X
Str8022U	db	06h,08h,'BootWare 3C90X supports NetWare, RPL & TCP/IP boot protocols:',0
ELSE
Str8022U	db	06h,08h,'BootWare 3C59X supports NetWare, RPL & TCP/IP boot protocols:',0
ENDIF
		db	09h,0ah,'To configure & save protocol/frame type, type <ENTER>',0
		db	0bh,0bh,'Default boot protocol is NetWare Ethernet_802.2',0
		db	03h,0fh,'This message will appear until boot protocol information is saved.',0
		db	0ffh
StrNull 	db	0


MsgROM64K	db	'Only ROMSize of 64K is supported',0

ErrPressF1		db	'. Press <F1> to continue',0

StrWarnLevel	db	010h,0ah,'Newer BootWare version is available for this adapter.',0
StrFailLevel	db	0bh,0ah,'New EtherLink found. Need new BootWare version.',0

; Msg put here so it won't be on every page
IFDEF	BW90X
MsgUpdateErr	db	06h,0ah,'Unable to update BootWare 3C90X. Configuration changes are not saved.',0
ELSE
MsgUpdateErr	db	06h,0ah,'Unable to update BootWare 3C59X. Configuration changes are not saved.',0
ENDIF

MsgVerifyBad	db	012h,0ah,'BootWare Update verification failed.',0
MsgUpdateOk	db	018h,0ah,'Update Successful ('
MsgUpdateCnt	db	'00)',0
ENDIF

IFDEF	BW90X
MsgVulcanNotFound	db	'Could not find 3C90X', 0
ELSE
MsgVulcanNotFound	db	'Could not find 3C59X', 0
ENDIF

IFDEF	UNDI
NADGetBootInfo	proc	near
NADInitialize	proc	near
NADConfig	proc	near
NADStart	proc	near
		ret
NADStart	endp
NADConfig	endp
NADInitialize	endp
NADGetBootInfo	endp

ELSE
;--------------------------------------------------------------------
; NADGetBootInfo
;
; This function is called at the start of INT19 read the current
; configuration from the ROM.  The configuration is returned in ax.
;
; Values:
;	  1  local boot is default
;	  2  ROMShield enabled
;	  4  config menu enabled
;	 64  floppy drive disabled
;	128  hard drive disabled
;
; Parameters:
;	DS = RAM segment
;
; Returns:
;	ax - boot info
;--------------------------------------------------------------------

		xor	ax, ax
		test	BWTFeature, 1
		jz	no_local
		or	ax,1
no_local:
		test	BWTFeature, 2
		jz	no_rs  
		or	ax,2
no_rs:
		test	BWTFeature, 4
		jnz	no_menu
		or	ax,4
no_menu:
		test	BWTLanOS, 1
		jz	floppy
		or	ax,64
floppy:
		test	BWTLanOS, 2
		jz	hard
		or	ax,128
hard:
		ret

NADGetBootInfo	endp


;--------------------------------------------------------------------
; NADInitialize
;
; Initializes the network adapter and connects the adapter to the
; physical media.
;
; Parameters:
;	AX = PCIBusDevFunc #
;	DX = screen location to dislay initializing string
;	DS = RAM segment
;	ES = ROM Base
;
; Returns:
;	AX = 0 if no error else pointer to fatal error
;--------------------------------------------------------------------
NADInitialize	proc	near

		push	ds
		push	es

		mov	DGroup:PCIBusDevFunc, ax
		mov	ax,es
		mov	ROMBase, ax

		push	cs
		pop	ds
		mov	bx, offset CGroup:StrPrompt
		call	PrintAt

		push	cs
		pop	es

		; Update some init variables (BusType, IOBase, IRQ ...)
		mov	BusType, BUS_PCI

		call	Init_Vulcan		; init vulcan hardware and
						;  variables
		cld
		mov	cx, 6
		mov	di, offset NetAddress
		mov	si, offset BoardID
		rep	movsb

		call	Init_Vulcan2

		mov	LookAheadBufferPtr.segm, cs

		call	HookIntVector

		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING		 ; switch to window 1

		xor	ax,ax
NADInitExit:
		pop	es
		pop	ds
		ret

NADInitialize	endp


IFNDEF	UNDI
;--------------------------------------------------------------------
; NADConfig
;
; Displays an optional configuration screen for the user to change
; ROM settings.
;
; Parameters:
;	dx = screen location for initialize string
;	ds = RAM segment
;
; Returns:
;	ax - pointer to configuration message
;--------------------------------------------------------------------
NADConfig	proc	near

		push	ds

		push	cs
		pop	ds
		mov	bx, offset CGroup:BlankStr
		call	PrintAt

		mov	ax, IOBase
		mov	NIC_IO, ax		; copy I/O base to NAD table

		mov	al, IRQLevel
		mov	NIC_IRQ, al		; copy IRQ to NAD table

;		cld
;		mov	cx, 6
;		mov	di, offset CGroup:NetAddress
;		mov	si, offset CGroup:BoardID
;		rep	movsb

;		call   ClearScreen
		xor	ax,ax

		pop	ds
		ret

NADConfig	endp


;--------------------------------------------------------------------
; NADStart
;
; Determine the protocol the ROM is configured, then jump to it.
;
; Parameters:
;	none
;--------------------------------------------------------------------
NADStart	proc near

		call	BuildNADAPI

		mov	al, BWTLANOS
		and	al, BWTLANMASK
		cmp	al, BWTLANRPL
		jnz	NotRPL
		jmp	CGroup:RPLStart

NotRPL:
	 	cmp	al, BWTLANIP
		jnz	NotIP
		jmp	CGroup:IPStart
NotIP:
		jmp	CGroup:NetWareStart

NADStart	endp


;--------------------------------------------------------------------
; NADPCIConfig
;
; Displays configuration screen for the user to change ROM settings.
;
; Parameters:
;	ds = RAM segment
;--------------------------------------------------------------------
NADPCIConfig	proc	near

		push	ds

		mov	al, NormalAttr
		mov	ah, ReverseAttr
		mov	CUIAttr, ax
		mov	NormalAttr, ASNormalAttr
		mov	ReverseAttr, ASReverseAttr

		call	ASConfig		; autoscan config
		mov	NormalAttr, ASNormalAttr
		mov	ReverseAttr, ASReverseAttr
		jnc	ConfigNoUpdate

	; Problem with Phoenix BIOS where SS is required to be
	; the same as CS
	; Assume that NOTHING is on the STACK!!!
;		cli
;		mov	ax, cs
;		mov	ss, ax
;		sti

		call	UpdatePCI_PEROM

	; Problem updating ROM. Just dump error message and let
	; them proceed
		xor	al, al		; Get user to press <ENTER> for acknowledge
		call	PrintErrMsg
		call	ClearScreen
ConfigNoUpdate:
		pop	ds
		ret

NADPCIConfig	endp


;--------------------------------------------------------------------
RomTopExitJmp:
		jmp	RomTopExit	;already init. Never run in RAM.

RunROMTOP:
		pusha
		push	ds
		push	es

		push	cs
		push	cs
		pop	ds
		pop	es

		cld

IFDEF		TSR
		mov	ax, 040h
ENDIF
IFDEF		DEBUG
		int	3
ENDIF
		push	ax


IFDEF		DEBUG
		mov	di, offset CGroup:StringAL
 		call	StoHex

	 	xchg	al, ah
	 	mov	di, offset CGroup:StringAH
	 	call	StoHex

	 	mov	ax, cs
	 	mov	di, offset CGroup:StringCS
	 	call	ROMStoHex

		mov	bx, offset CGroup:StringPCI
		call	PrintMessage

		mov	bx, offset CGroup:ErrPressF1
		call	PrintMessage

ChkF1F2Lp:
		sti			; enable interrupt

		mov	ah, 0		; Read char. Char is removed from buffer
		int	016h		; Keyboard interrupt

		cmp	ah, 3Bh ; <F1> pressed?
		jz	TempCont

		cmp	ah, 3Ch ; <f2> pressed?
		jnz	ChkF1F2Lp

		pop	ax

ASExitEarly:
		pop	es
		pop	ds
		popa
		retf
TempCont:

ENDIF		; DEBUG

		call	GetBusType
		cmp	al, BUS_PCI
		jz	ASPCI

		cmp	al, BUS_EISA_PCI
		jz	ASPCI

		; Bus could be EISA or PCI_EISA
		mov	bx, offset CGroup:MsgVulcanNotFound
		pop	ax
		jmp	AutoScanErr

ASPCI:
IFNDEF		TSR

		pop	ax
		mov	PCIBusDevFunc, ax
		pop	ax
		push	ax			;ROMBase
		mov	ROMBase, ax

		; to save space, OldStackPtr is not used. Replaced by Old MsgIOConflict
		; use our own stack
		mov	word ptr [OldStackPtr], sp
		mov	word ptr [OldStackPtr+2], ss

		call	FindStack
		cli
		mov	ss, ax
		mov	sp, InitSTACKPTR
		sti

ENDIF		; TSR
		push	cs
		pop	ds

		mov	BusType, BUS_PCI
		call	Init_Vulcan		; init vulcan hardware and
						;  variables
		cmp	ax, 0
		jz	Init_VulcanOk


		; Print Message. Can't use the one in CUI because it's not on
		; every page.
		mov	bx, offset CGroup:MsgVulcanNotFound

AutoScanErr:	call	PrintMessage
		mov	bx, offset CGroup:ErrPressF1
		call	PrintMessage

ChkF1Lp:
		sti			; enable interrupt

		mov	ah, 0		; Read char. Char is removed from buffer
		int	016h		; Keyboard interrupt

		cmp	ax, 3B00h	; <F1> pressed?
		jnz	ChkF1Lp

		; restore stack
		mov	ss, word ptr [OldStackPtr+2]
		mov	sp, word ptr [OldStackPtr]

		pop	es
		pop	ds
		popa
		retf

Init_VulcanOk:
		; Make sure ROMSize is set to 64K. Otherwise, print error
		; msg, wait and continue
		mov	bx, offset CGroup:MsgROM64K
		mov	ax, InternalConfig.loword
		and	ax, 0c0h		; consider only bit 6,7
		cmp	ax, 0c0h
		jnz	AutoScanErr

		; Setup PrintAttribute so that color will only be used
		; in Config Facility
;		mov	al, NormalAttr
;		mov	ah, ReverseAttr
;		mov	CUIAttr, ax
;		mov	NormalAttr, ASNormalAttr
;		mov	ReverseAttr, ASReverseAttr

;		call	ASConfig		; autoscan config
;		mov	NormalAttr, ASNormalAttr
;		mov	ReverseAttr, ASReverseAttr
;		jnc	AutoScanNoUpdate

		; Problem with Phoenix BIOS where SS is required to be
		; the same as CS
		; Assume that NOTHING is on the STACK!!!
;		cli
;		mov	ax, cs
;		mov	ss, ax
;		sti

;		call	UpdatePCI_PEROM

		; Problem updating ROM. Just dump error message and let
		; them proceed
;		xor	al, al		; Get user to press <ENTER> for acknowledge
;		call	PrintErrMsg
;		call	ClearScreen

AutoScanNoUpdate:

		push	cs
		pop	ds

IFNDEF		TSR
		; restore stack
		mov	ss, word ptr [OldStackPtr+2]
		mov	sp, word ptr [OldStackPtr]
ENDIF

RomTopExit:
 		pop	es
		pop	ds
		popa

		jmp	Start


;-----------------------------------------------------------------------------
; AutoConfig	Called by Autoscan routine
;
;		Exit:	ax = offset of checksum byte (whole ROM)
;-----------------------------------------------------------------------------
;AutoConfig	proc	near
;		ret
;AutoConfig	endp


;-----------------------------------------------------------------------------
; SetChkSum	Calculate checksum of a specified block of data and
;		write checksum to specified location
;
;		Entry:	ds:si = point to block of data to checksum
;			di = offset in block of data to write checksum
;			cx = length of data to checksum
;		Exit:	checksum ok block of data
;-----------------------------------------------------------------------------
SetChkSum	proc	near
		xor	ax, ax

SetChkSumLoop:
		lodsb
		add	ah, al
		loop	SetChkSumLoop

		neg	ah
		mov	ds:[di], ah		; write checksum

		ret
SetChkSum	endp
ENDIF

;------ GetBusType ----------------------------------------------------------;
;									     ;
;	Identify the type of system we are executing on.		     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	AL = EISA or PCI or EISA_PCI (also saved in BusType)			     ;
;									     ;
;	Destroys AH, BX, CX, DX, SI, DI.  All other registers are     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
		public	GetBusType
GetBusType	proc	near

		push	es
; point ES at Real Mode F000:0000
		mov	ax, 0F000h
		mov	es, ax

; to determine if this is an EISA system or not we look for the string "EISA"
; in the ROM at F000:FFD9 thru FFDC.

		mov	ax, 0			; clear BusFlag
		mov	di, 0FFD9h
		cmp	word ptr es:[di][0], 4945h	; "EI"?
		jne	gst_not_eisa
		cmp	word ptr es:[di][2], 4153h	; "SA"?
		jne	gst_not_eisa

		mov	al, BUS_EISA

; for the moment, if its not an EISA system, see if it's PCI

gst_not_eisa:
		push	ax

		; Is machine PCI?
		mov	ax, PCI_FUNCTION_ID shl 8 + PCI_BIOS_PRESENT
		int	1ah
		jc	GetBusRet

		or	ah, ah
		jne	GetBusRet

		cmp	dx, 4350h		; EDX = "PCI "
		jne	GetBusRet

		pop	ax
		add	al, BUS_PCI
		push	ax

GetBusRet:
		pop	ax
		pop	es
		ret
GetBusType	endp
ENDIF

IFDEF	UNDI
	include	nad90x.asm
ENDIF

public		WaitTime
;--------------------------------------------------------------------
; WaitTime - CX has 2*1.1932 the number of microseconds to wait.
;	If CX is small, add 1 to compensate for asynchronous nature
;	of clock.  For example, for 10us, call with CX = 25
;
;  On entry,
;	ints off (especially if CX is small, and accuracy needed)
;  On exit,
;
; 911223 0.0 GK
;--------------------------------------------------------------------
WaitTime	proc	near

		push	ax
		push	bx
		push	cx

		call	ReadTimer0		; get Timer0 value in AX
		mov	bx, ax			; save in BX

ReadTimer0Loop:
		call	ReadTimer0
		push	bx
		sub	bx, ax
		cmp	bx, cx
		pop	bx
		jc	ReadTimer0Loop

		pop	cx
		pop	bx
		pop	ax
		ret

WaitTime	endp


ReadTimer0	proc	near

		mov	al, 6
		out	43h, al 		; port 43h, 8253 wrt timr mode 3
		call	RT0

RT0:
		jmp	short $+2
		jmp	short $+2
		jmp	short $+2
		in	al, 40h 		; port 40h, 8253 timer 0 clock
		xchg	ah, al

		jmp	short $+2
		jmp	short $+2
		jmp	short $+2

		ret

ReadTimer0	endp


;------ ReadEEProm ----------------------------------------------------------;
;									     ;
;	This routine reads a word from the EEProm.  It can only be used      ;
;	once the board has been brought up at a particular IOBase.	     ;
;									     ;
;	Entry:								     ;
;	AL	= EEProm word to read					     ;
;	Window	= 0							     ;
;	DX 	= IOBase
;	cli								     ;
;									     ;
;	Exit:								     ;
;	AX	= that EEProm word					     ;
;	cli								     ;
;									     ;
;	Destroys BX, CX, DX, SI, DI and ES.  All other registers are	     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
	  	public  ReadEEProm
ReadEEProm	proc    near
		push	dx

; issue an EEProm read command

;		mov    dx, IOBase
;		add    dx, PORT_EECmd_PCI
		add    al, READ_EEPROM
		out    dx, al

; spin until the EEProm busy bit goes off

		call   WaitEEBusy

; fetch the data from the EEProm data register

;960401		add    dx, PORT_EEData - PORT_EECmd
		mov	dx, PortEEData
		in     ax, dx

		pop	dx
		ret
ReadEEProm    endp


;-----------------------------------------------------------------------------
; WaitEEBusy	Poll until the EEPROM_BUSY bit in EECommand Register is cleared
;
; Input:	dx = IOBase+ PORT_EECmd
;		ax = 0 no problem, ax != 0 problem
;-----------------------------------------------------------------------------
WaitEEBusy	proc	near
		push	cx

		mov	cx, 0
WaitEELoop:
		in	ax, dx
		test	ax, EE_BUSY
		jz	WaitEEBusyExit
		loop	WaitEELoop
WaitEEBusyExit: 
		and	ax, EE_BUSY		; only consider bit 15 for Errcode
		pop	cx
		ret
WaitEEBusy	endp


		public	MediaEnable		 ; 10/20/94, cj
MediaEnable	label	word
		dw	MEDIA_JABBERENABLE + MEDIA_LBEATENABLE
		dw	MEDIA_SQEENABLE
		dw	0			; not used
		dw	0
		dw	MEDIA_LBEATENABLE
		dw	MEDIA_LBEATENABLE
		dw	0


;-----------------------------------------------------------------------------
; FindV3PCI
;
; Return	dx = 0		not found
;		     IOBase	found
;		al = IRQLevel
;-----------------------------------------------------------------------------
FindV3PCI	proc	near

		call	PCISearch
		jc	no_pci

IFDEF BW90X
; Check whether bus mastering has been forced off.  If so, set MasterOK to NO
		
	       mov     ah, 0B1h		; PCI BIOS Function
	       mov     al, 009h		; PCI Read Config Word
	       mov     bx, PCIBusDevFunc
	       mov     di, PCIC_COMMAND	; read PCICommand
	       int     1Ah
       
	       test    cx, PCIC_BMENABLE       ; bus mastering enabled?
	       jnz     bm_set
       
	       or      cx, PCIC_BMENABLE       ; force it on
	       mov     ah, 0B1h		; PCI BIOS Function
	       mov     al, 00Ch		; PCI Write Config Word
	       mov     bx, PCIBusDevFunc
	       mov     di, PCIC_COMMAND	; write it back to PCICommand
	       int     1Ah
bm_set:
ENDIF

; PCI device has been found, read IO address from config space

		mov	bx, PCIBusDevFunc
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		mov	di, CFGREG_IOBASE
		int	1ah
		jc	no_pci

		and	cx, 0ffe0h			 ; drop last 5 bits
		mov	dx, cx

		mov    ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_BYTE
		mov    bx, PCIBusDevFunc
		mov    di, CFGREG_INTLINE
		int    1ah
		mov    al, cl

		ret

no_pci: 	xor	dx, dx
		ret
FindV3PCI	endp


;------ PCISearch -----------------------------------------------------------;
;									     ;
;	Attempt to find a match against a PCI adapter.	The caller can	     ;
;	specify the exact busno/slot to check or leave either unspecified    ;
;	in which case a search will be performed among the allowed	     ;
;	busno/slot combinations for a match.				     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Slot  = slot number to search, -1 if not specified		     ;
;	BusNo = bus number to search, -1 if not specified		     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	carry = set if no match 					     ;
;	      = clear if a match					     ;
;	BusNo = set for the matching adapter if carry clear		     ;
;	Slot  = set for the matching adapter if carry clear		     ;
;	PCIBusDevFunc = set for the matching adapter if carry clear	     ;
;									     ;
;	All registers are preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	PCISearch
PCISearch	proc	near

		pusha

;
; Read the PciCommand register to see if the adapter has been activated.  if
; not, pretend we didn't find it
;
		mov	ah, 0B1h		; PCI BIOS Function
		mov	al, 009h		; PCI Read Config Word
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_COMMAND
		int	1Ah
		jc	pcis_no

		test	ah, ah
		jnz	pcis_no


		test	cx, PCIC_IOENABLE	; I/O access enabled?
		jz	pcis_no

		clc
;
; exit with carry flag as set
;
		public	pcis_exit
pcis_exit:
		popa
		ret

;
; no PCI support or adapter not found or failure after found
;
		public	pcis_no
pcis_no:
		stc
		jmp	pcis_exit
PCISearch	endp


;*****************************************************************************
;
;   Init_Vulcan: This routine initializes hardware of Fast EtherLink and
;		 variables required by this driver. The following are
;		 performed in this routine:
;
;		   1. activate adapter
;		   2. determine resource config and enable resources
;		   3. initialze and determine driver variables, tables
;		   4. enable vulcan hardware (txmitter, receiver, xcvr, etc.)
;
;   On Entry:
;
;      ds = es = CGroup
;      sti
;      cld
;
;   On Exit:
;
;      sti
;      ax     = 0, init successful
;	      = offset of an error message indicating type of error
;
;*****************************************************************************

nohardware:	sti
		mov	ax, offset CGroup:MsgVulcanNotFound
		ret

Init_Vulcan	proc	  near

		call	FindV3PCI
		cmp	dx, 0
		jz	nohardware

		mov	DGroup:IOBase, dx
		mov	IRQLevel, al
;;;970808 RL
		call	CalibrateDelay

		mov	cx, 1			; 1us
		call	ComputeDelay
		mov	Delayoneusec.loword, ax
		mov	Delayoneusec.hiword, dx
;;;
;
; initialize IO Port Variables
;
		mov	ax, IOBase
		mov	cx, NumOfPorts
		mov	di, offset DGroup:PortCmdStatus
InitPorts:
		add	[di], ax
		add	di, 2
		loop	InitPorts

		mov	dx, PortCmdStatus
		mov	ax, CMD_SELECTWINDOW+WNO_SETUP	   ;   unload/reload &
		out	dx, ax				   ;	boot PROMs

;		mov	ax, cs
		mov	ax, ds
		mov	es, ax
		mov	di, offset DGroup:BoardID

		mov	dx, PortEECmd
		mov	al, EE_OEM_NODE_ADDR_WORD0
		call	ReadEEProm		  ; read word 0 of node addr
		xchg	ah, al
		stosw

		mov	al, EE_OEM_NODE_ADDR_WORD1
		call	ReadEEProm		  ; read word 1 of node addr
		xchg	ah, al
		stosw

		mov	al, EE_OEM_NODE_ADDR_WORD2
		call	ReadEEProm		  ; read word 2 of node addr
		xchg	ah, al
		stosw
;
; check to make sure the board is visible (ie. no conflict with IOBase).  since
; the PCI adapter doesn't have the EISA manufacturer ID in Window 0 anymore, we
; now use the Window 5 to check this
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_READABLE

		mov	ax, CMD_SETTXSTART + 0
		out	dx, ax

		mov	dx, PortTxStart
		in	ax, dx
		test	ax, ax
		jnz	bind_ioconflict

		mov	dx, PortCmdStatus
		mov	ax, CMD_SETTXSTART + (TXSTART_DISABLED / 4)
		out	dx, ax

		mov	dx, PortTxStart
		in	ax, dx
		cmp	ax, TXSTART_DISABLED
		je	InitTxDisable

bind_ioconflict:
		jmp	nohardware

InitTxDisable:

;-------------------------------------------------------------------------------
;
; read a few things off the board
;
; note: because of the delays required for the EEProm accesses, we're going to
;	have interrupts disabled for a rather long time (hundreds of usec), but
;	since this is only init time, and our only other choice would be to
;	do this resident, we're going to do it anyway.
;

		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

		mov	dx, PortResetOptions
		in	ax, dx
		mov	ResetOptions, ax

		mov	dx, PortInternalCfgH
		in	ax, dx
		mov	InternalConfig.hiword, ax

		mov	dx, PortInternalCfgL
		in	ax, dx
		mov	InternalConfig.loword, ax

		mov	dx, PortCmdStatus
		SelectWindow WNO_SETUP

		mov	al, EE_SOFTWARE_CONFIG_INFO
		mov	dx, PortEECmd
		call	ReadEEProm		  ; read software info
		mov	EESoftConfigInfo, ax

		mov	al, EE_SOFTWARE_CONFIG_INFO2
		call	ReadEEProm		  ; read software info 2
		mov	EESoftConfigInfo2, ax

		mov	al, EE_CAPABILITY_WORD
		call	ReadEEProm
		mov	EECapabilities, ax

		mov	al, EE_INT_CONFIG_0
		call	ReadEEProm
		mov	EEIntConfig0,ax

		mov	al, EE_INT_CONFIG_1
		call	ReadEEProm
		mov	EEIntConfig1,ax

		mov	al, EE_CWORD
		call	ReadEEProm		  ; read Compatibility word
		mov	CWord, ax

		mov	al, EE_MII_SELECT
		call	ReadEEProm
		and	ax, EE_MII_SELECT_MASK
		mov	EEMiiPhySelect,ax

; initialize IRQ on 8259 and remap vector to our interrupt service routine

		mov	al, IRQLevel
		call	SetInterruptVector

		mov    ax, 0

init_vulcan_rtn:
		sti
		ret

Init_Vulcan	endp


IFNDEF	UNDI
;--------------------------------------------------------------------------;
; ASConfig	autoscan Configuration Utility for 5X9. Will call Elnk3Conf
;
; Exit		cf	= clear No Change
;			= set	Changes are made
;
;--------------------------------------------------------------------------;
ASConfig	proc	near

  		; Check Fail/Warning Level to see if PROM should
		; dump any messages
		mov	dx, PortEECmd
		mov	al, EE_CWORD
		call	ReadEEPROM

		cmp	ah, LEVEL_FAIL		; is fail level ok?
		jbe	ChkWarnLevel

		call	ClearScreen
		mov	bx, offset CGroup:StrFailLevel
		xor	al, al
		call	PrintErrMsg
		call	ClearScreen

NoConfigJmp:	clc
		jmp	NoConfig

ChkWarnLevel:
		cmp	al, LEVEL_WARNING	; is warning level ok?
		jbe	ChkLevelDone

		call	ClearScreen
		mov	dx, word ptr CGroup:[StrWarnLevel]
		mov	ah, NormalAttr
		mov	bx, offset CGroup:StrWarnLevel+2
		call	PrintMsgLoc

		mov	si, 3			; 3 seconds
		call	ChkKey
		call	ClearScreen

ChkLevelDone:	; 940107 is CFG disabled by BW5X9.EXE ?
		mov	ax, BWTFeature
		test	ax, BWTFEA_CONF
		jnz	NoConfigJmp

; 930916 all 5X9Conf code will be here {
		call   ClearScreen
		call   ChkForCfg
		jnz    NoConfigJmp

		; setup ScreenAttributes
		mov	ax, CUIAttr
		mov	NormalAttr, al
		mov	ReverseAttr, ah

		mov	bx, InternalConfig.hiword
		mov	dx, EESoftConfigInfo

		mov	si, offset BoardID
		mov	di, IOBase
		mov	al, BusType

		call	ELNK3CONF
		jnc	NoConfig

		mov	EESoftConfigInfo, dx

		stc
NoConfig:
		pushf
		call   ClearScreen
		popf
		ret

ASConfig	endp


;--------------------------------------------------------------------------;
; UpdatePCI_PEROM	Update the BootWare Table of the PEROM for PCI V3
;
; Exit		bx  = 0, no problem
;		   != 0, pointer to error Message
;--------------------------------------------------------------------------;
UpdatePCI_PEROM proc	near

		mov	bx, 8
		call	FixRAMWidth

		; find a clean/free extend memory region
		call	FindExtendMemory
		cmp	UseExtendMem, 0
		jnz	ExtendMemFound

UpdateErr:
		mov	bx, offset CGroup:MsgUpdateErr
		jmp	UpdatePEROMExit

ExtendMemFound:
		; Use Word rather than DWord when READing/WRITing to config
		; space so that I can use Periscope to look at it
		; Fetch current Expansion +ROMBase Address so that we can
		; restore it later
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_BIOSROMCONTROL + 2
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		int	01ah
		mov	OldPCIROMAddr+2, cx

		; assume bx preserved
		mov	di, PCIC_BIOSROMCONTROL
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		int	01ah
		mov	OldPCIROMAddr, cx

		; map BootROM at UseExtendMem.
		mov	cx, UseExtendMem
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_BIOSROMCONTROL + 2
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		; assume bx preserved
		mov	cx, 01			; enable ROM
		mov	di, PCIC_BIOSROMCONTROL
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		; Update Physical BootROM with the appropriate information
		; Steps:
		; 1. Copy the first 256 bytes from BootROM to Elnk3ConfSparse
		; 2. Verify 1st 2 bytes are 55 AA
		; 3. Update appropriate data
		; 4. Copy data from AutoScanBuffer to BootROM
		; 5. Verify results and retry is necessary

		; First, Copy 256 bytes from BootROM to Elnk3ConfSparse
		; On entry	BX:DI is destination address
		;		DX:SI is source address
		;		CX    is byte count.

		mov	UpdateRetry, 3

UpdateMemRetry:
		cmp	UseExtendMem, 0ah
		jnz	CopyFromExtend

		; Segment A000 Update {
		push	ds
		mov	cx, 40h
		xor	esi, esi
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		xor	edi, edi
		mov	di, AutoScanBuffer
		mov	ax, 0a000h
		mov	ds, ax
;		rep	movsd
CopyA000Lp1:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp1
		pop	ds
		jmp	short UpdateChk55AA
		; Segment A000 Update }

CopyFromExtend:
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	bx, dx
		mov	di, ax
		add	di, AutoScanBuffer
		adc	bx, 0

		mov	dx, UseExtendMem
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		mov	cx, 100h
		call	CopyMemory

UpdateChk55AA:
		; Should at least make sure that AutoScanBuffer
		; contains the 55 AA signature
		mov	bx, offset CGroup:MsgUpdateErr
		mov	di, AutoScanBuffer
		cmp	word ptr [di], 0aa55h
		jnz	UpdateMemRemap

		; Update BWTLANOS, BWTFeature, BWTEthStd
;960529		mov	di, AutoScanBuffer

		mov	al, BWTLANOS
		mov	byte ptr [di+offset BWTLANOS], al

		mov	ax, BWTFeature
		mov	word ptr [di+offset BWTFeature], ax

;970219		mov	ax, BWTEthStd
;		mov	word ptr [di+offset BWTEthStd], ax

;		mov	al, BWTAddrRes
;		mov	byte ptr [di+offset BWTAddrRes], al


		; Calculate checksum of BootROM Table
		xor	cx, cx
		mov	cl, byte ptr cs:[8]
		dec	cl
		mov	si, AutoScanBuffer
		add	si, 8
		add	di, offset BWTChkSum		; di still points to AutoScanBuffer
		call	SetChkSum


		cmp	UseExtendMem, 0ah
		jnz	CopyToExtend

		; Segment A000 Update {
		push	es
		mov	ax, 0a000h
		mov	es, ax
		mov	cx, 20h
		xor	esi, esi
		xor	edi, edi
;960529		mov	di, AtmelOffset
		mov	di, ROMCODESTART
		mov	si, AutoScanBuffer
;		rep	movsd
CopyA000Lp2:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp2

		mov	cx, Delay25ms
		call	WaitTime

		mov	cx, 20h
CopyA000Lp3:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp3

		pop	es
		jmp	short UpdateVerify
		; Segment A000 Update }

CopyToExtend:
		; Extend Memory Update {
		; Copy First 256 bytes to Physical BootROM
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	si, ax
		add	si, AutoScanBuffer
		adc	dx, 0

		mov	bx, UseExtendMem
;960529		mov	di, AtmelOffset
		mov	di, ROMCODESTART
		mov	cx, 80h
		call	CopyMemory

		mov	cx, Delay25ms
		call	WaitTime

		mov	cx, 80h
		call	CopyMemory
		; Extend Memory Update }

UpdateVerify:
		mov	cx, Delay25ms
		call	WaitTime

		cmp	UseExtendMem, 0ah
		jnz	CopyToVerify

		; Segment A000 Update {
		jmp	$+2
		jmp	$+2
		jmp	$+2

		push	ds
		mov	cx, 40h
		xor	esi, esi
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		xor	edi, edi
		mov	di, AutoScanBuffer
		add	di, 100h
		mov	ax, 0a000h
		mov	ds, ax

CopyA000Lp4:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp4

		pop	ds
		jmp	short UpdateCompare
		; Segment A000 Update }

CopyToVerify:
		; Verify PEROM content
		; es:di points to AutoScanBuffer
		; ds:si points to AutoScanBuffer+100h
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	bx, dx
		mov	di, ax
		add	di, AutoScanBuffer
		adc	bx, 0
		add	di, 100h
		adc	bx, 0

		mov	dx, UseExtendMem
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		mov	cx, 100h
		call	CopyMemory

UpdateCompare:
		mov	bx, offset CGroup:MsgUpdateOk

		mov	di, AutoScanBuffer
		mov	si, di
		add	si, 100h
		mov	cx, 100h
		repz	cmpsb
		jz	UpdateMemRemap

		mov	bx, offset CGroup:MsgVerifyBad
		dec	UpdateRetry
		jz	UpdateMemRemap

		jmp	UpdateMemRetry

UpdateMemRemap:
		push	bx
		; Restore Expansion ROM Base Adress Register
		mov	bx, PCIBusDevFunc
		mov	cx, OldPCIROMAddr	; Disable ROM first
		mov	di, PCIC_BIOSROMCONTROL
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		; assume bx preserved
		mov	cx, OldPCIROMAddr + 2
		mov	di, PCIC_BIOSROMCONTROL + 2
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		mov	bx, 0fff7h
		call	FixRAMWidth
		pop	bx

UpdatePEROMExit:
		ret
UpdatePCI_PEROM endp

; Extended memory global descriptor structure:

DESCRIPTOR	STRUC
Dummy		DW	0, 0, 0, 0
GDT_LOC 	DW	0, 0, 0, 0
SourceLimit	DW	0
SourceLoWord	DW	0
SourceHiByte	DB	0
SourceRights	DB	0
SourceInternal	db	0
SourceHiByteHi	db	0
TargetLimit	DW	0
TargetLoWord	DW	0
TargetHiByte	DB	0
TargetRights	DB	0
TargetInternal	db	0
TargetHiByteHi	db	0
Bios		DW	0, 0, 0, 0
Temp		DW	0, 0, 0, 0
DESCRIPTOR	ENDS

GDT		Descriptor <>

;--------------------------------------------------------------------
; FixRAMWidth()
;
;	- When we detect that InternalConfig.ramWidth is byte-wide,
;	  we need to fix an ASIC problem where we cannot
;	  write to the Atmel PEROM. All the odd location bytes are
;	  overwritten with zero
;	- toggle 3C590.InternalConfig.ramWidth between Byte-wide and
;	  Word-wide. Because InternalConfig.ramWidth toggles, we
;	  can't use ramWidth to determine if adapter need Fix
;
; Input 	bx = 8		to change ramWidth to WordWide
;		   = 0fff7h	to change ramWidth to ByteWide
;--------------------------------------------------------------------
FixRAMWidth	proc	near

		; is adapter 3C590, 3C592 or 3C597?
		cmp	BusType, BUS_EISA
		jz	FixRAMWidthNow

		; Goto ConfigSpace DeviceID (offset2) to distinguish
		; between 3C590 and 3C595. CANNOT use PCIStructure
		; in ROM because Award uses BootWare/3C595
		; rather than BootWare/3C590 for the 3C590 adapter.
		push	bx
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_DEVICEID
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		int	01ah
		pop	bx
		cmp	cx, PCI_DeviceID
		jnz	FixRAMWidthExit

FixRAMWidthNow:
		; Does version of ASIC contain bug?????????
		mov    dx, PortCmdStatus
		SelectWindow WNO_FIFO
;960401		port	InternalCfgL, CmdStatus
		mov	dx, PortInternalCfgL
		in	ax, dx

		test	bx, 8
		jnz	FixRAMWidthWord

		and	ax, bx
		jmp	short SetRAMWidth

FixRAMWidthWord:
		or	ax, bx

SetRAMWidth:
		out	dx, ax

		mov	dx, PortCmdStatus
		SelectWindow WNO_SETUP

FixRAMWidthExit:
		ret
FixRAMWidth	endp

;--------------------------------------------------------------------
; CopyMemory	Copy block of memory to/from extended memory
;
; On entry	BX:DI is destination address
;		DX:SI is source address
;		CX    is byte count.
;
;	Addresses is 32bit address
;	Assume CS=ES=DS
;--------------------------------------------------------------------
CopyMemory proc near

  	push	di
	push	cx
	mov	di, offset GDT
	mov	cx, (size DESCRIPTOR)/2
	xor	ax, ax
	rep	stosw
	pop	cx
	pop	di

	mov	ax, bx
	mov	bx, OffSet GDT	; address of GDT (es:si)
	mov	[bx].SourceLimit, cx	; set copy size
	mov	[bx].TargetLimit, cx	; set copy size
	mov	[bx].SourceRights, 93h	; set copy rights
	mov	[bx].TargetRights, 93h	; set rights

	mov	[bx].SourceLoWord, si	; set source address lo word
	mov	[bx].SourceHiByte, dl	; set source address LowByte of HighWord
	mov	[bx].SourceHiByteHi, dh ; set source address HighByte of HighWord

	mov	[bx].TargetLoWord, di	; set dest address low word
	mov	[bx].TargetHiByte, al	; set dest address lowbyte of High Word
	mov	[bx].TargetHiByteHi, ah ; set dest address highbyte of high word

	shr	cx, 1			; now cx is word count

	mov	si, bx			; es:si = GDT
	mov	ah, 87h
	int	15h			; move data to/from extended memory

	ret

CopyMemory EndP

;--------------------------------------------------------------------
; FindExtendMemory	- From Top of extended memory, find a region
;			  of extended memory we can use and return the
;			  Most Significant Word of the 32 bit address
;			- verify that the region we choose is unoccupied
;			  by examing the first 128 bytes of the 64K region
;			  and make sure the values are the same
;			- if region is occupied, goto next 64K region
;			  until we reach f000 0000
;
; Return:	ax =  Most Sign. Word of the 32Bit address that ROM code
;			can be copied to
;		   = error
;
;--------------------------------------------------------------------
FindExtendMemory	proc	near

		; Setup AutoScanBuffer
		; ** Elnk3ConfSparse is memory that we will throw away
		;    after AutoScan. Use it as a temporary buffer **
		; 950306 There are 1B0h bytes in Elnk3ConfSparse I can use
		mov	di, offset Elnk3ConfSparse
		inc	di
		and	di, 0fffeh		; make sure Buffer is Word Align
		mov	AutoScanBuffer, di


		; Before using Extended memory, check if A000:0 region is
		; available. Since A000:0 is below 1M, no need to use
		; CopyMemory to verify result
		push	ds
		mov	ax, 0a000h
		mov 	ds, ax
		xor	si, si
		mov	cx, 0ffffh

		lodsb
		mov	ah, al

FindA000Loop:
		lodsb
		cmp	ah, al
		jnz	FindA000

		loop	FindA000Loop

FindA000:	pop	ds

		cmp	cx, 0
		jnz	FindExtendMem

		mov	ax, 0ah
		mov	UseExtendMem, ax
		ret

FindExtendMem:
		mov	ah, 088h
		int	15h

		push	cx
		mov	cx, 040h
		div	cl		; divide by 40 to get starting 32bit
					; address
		xor	ah, ah		; ignore remainder
		add	ax, 020h	; add 1M for conventional RAM &
					; choose 1M above top of ExtendRAM
		mov	UseExtendMem, ax

		; Copy 128 bytes to AutoScanBuffer
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	bx, dx
		mov	di, ax
		add	di, AutoScanBuffer
		adc	bx, 0

		push	bx
		push	di

ExtendMemNextLp:
		pop	di
		pop	bx

		push	bx
		push	di

		mov	dx, UseExtendMem
		xor	si, si
		mov	cx, 080h
		call	CopyMemory

		; Make sure values in the AutoScanBuffer are identical
		;
		mov	cx, 07fh
		mov	si, AutoScanBuffer

		lodsb
		mov	ah, al

ExtendMemChkLoop:
		lodsb
		cmp	ah, al
		jnz	ExtendMemNext		; exit with zf cleared

		loop	ExtendMemChkLoop

FindExtendMemExit:
		mov	ax, UseExtendMem

		pop	di
		pop	bx

		pop	cx
		ret

ExtendMemNExt:
		inc	UseExtendMem		; goto next 64K region
		cmp	UseExtendMem, 0f000h
		jb	ExtendMemNextLp

		mov	UseExtendMem, 0
		jmp	short FindExtendMemExit

FindExtendMemory	endp

;--------------------------------------------------------------------
; FindStack	- From Top of conventional memory, find 1K of RAM
;		  we can use and return the Segment Value
;		- verify that the region we choose is unoccupied by
;		  examing the 1K region (make sure the values are identical)
;		- if region is occupied, goto next 1K region below
;		  until we reach 1000:0
;
; Entry
; Return:	ax = Segment Value of Stack
;
;--------------------------------------------------------------------
FindStack	proc	near
		push	ds
		push	bx
		push	cx
		int	12h
		sub	ax, 020h		; subtract 32K
		mov	cl, 6
		shl	ax, cl			; convert to segment form
		mov	ds, ax			; ES = Stack base

FindStackAgain:
		mov	cx, 07fh		; test 256 bytes
		mov	si, InitStackPtr
		lodsw
		mov	bx, ax

FindStackLoop:
		lodsw
		cmp	bx, ax
		jnz	FindStackNext

		loop	FindStackLoop

		; Carry would be cleared

		; ES is the stack segment!!
		mov	ax, ds
FindStackExit:
		pop	cx
		pop	bx
		pop	ds
		ret

FindStackNext:	mov	ax, ds
		sub	ax, 0800h
		mov	ds, ax

		cmp	ax, 01000h
		jae	FindStackAgain

		; No way. Can't find 1K free anywhere.
		; Just use ROMBase
		mov	ax, cs		; cs = ROMBase
		jmp	short FindStackExit

FindStack	endp
ENDIF


IFDEF	BW90X
;	include		\rom\3com\90x.p\src\new\bw90xp.inc
	include		bw90xp.inc
ELSE
	include		\rom\3com\59x.p\src\new\bw59xp.inc
ENDIF

include		bw5x9.inc

comment %
;---------------------------------------------------------------------------
; HookConfig - called by NWNID's GET_MEM_BASE. Find the RomBase, IOBase
;	       IRQ and DMA to use.
;	     - Build API Jump Table
;	     - Run ELNK3Conf is selected
;	     - setup BWTLANOS and BWTEthStd, ConfigString
;
;	Input:	ds = ROMBase
;	Output: ds = ROMBase
;
; Currently, NetWareStart, RPLStart & TCPStart do not take care
; of Error Condition
;---------------------------------------------------------------------------
HookConfig	proc	near
	
		push	ds
		push	es

		mov	bx, ds
		mov	cs:ROMBase, bx

		push	cs
		pop	ds

		push	cs
		pop	es

		; Update some init variables (BusType, IOBase, IRQ ...)
		mov	BusType, BUS_PCI

		mov	PCIBusDevFunc, ax

		call	ClearScreen
		call	Init_Vulcan		; init vulcan hardware and
						;  variables

IFDEF	DEBUG
		mov	bx, offset NodeID
		call	PrintMessage
ENDIF

     		call	BuildNADAPI

		cld

		push	cs
		pop	ds

		push	cs
		pop	es

		mov	cx, 6
		mov	di, offset NetAddress
		mov	si, offset BoardID
		rep	movsb

		call	Init_Vulcan2

		mov	LookAheadBufferPtr.segm, cs

		call	HookIntVector

		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING		 ; switch to window 1

		; if Boot Protocol is changed, change BWTEthStd or
		; BWTLANOS
		mov	al, BWTLANOS
		and	al, BWTLANMASK

		cmp	al, BWTLANRPL
		jnz	NotRPL

		; RPL is actually 802.2 but BWTEthStd has to contain
		; BWTETH8023
		mov	byte ptr [EthProtString+4], '2'

		mov 	ax, offset CGroup:RPLStart
		jmp	ax

NotRPL: 	cmp	al, BWTLANIP
		jnz	NotIP

		; TCPIP !!
		mov	cx, ETHIISTRINGLEN
		mov	di, offset CGroup:EthProtString
		mov	si, offset CGroup:EthIIString
		rep	movsb

		mov 	ax, offset CGroup:TCPStart
		jmp	ax

NotIP:
;970219		mov	ax, BWTEthStd
;		cmp	ax, BWTETHEII
		mov	ax, BWTLANOS
		cmp	ax, 12h
		jb	NotNW_EII

		; NW_EthII !!
		mov	cx, ETHIISTRINGLEN
		mov	di, offset CGroup:EthProtString
		mov	si, offset CGroup:EthIIString
		rep	movsb

		jmp	short BWTBProt

NotNW_EII:	; if PROM is uninit, also assume PROM is 802.2
		cmp	ax, BWTETH8022
		jnz	BWTBProt

NW_8022:
		; NW_802.2 !!
		mov	byte ptr [EthProtString+4], '2'
BWTBProt:
		xor	ax, ax		; should not display error condition
					; NADInitialize will print err msg
					; for us.

		; change Protocol Change code if stack is modified
		pop	es
		pop	ds

		mov 	ax, offset CGroup:NetWareStart
		jmp	ax

HookConfig	endp

%

IFNDEF	UNDI
; ************************************************************************
; HOOKS for CUI.ASM
HookChkChar	proc	near
HookEditInput	proc	near
HookChkInput	proc	near
HookHyphen	proc	near
HookEditSpec	proc	near
		stc
		ret
HookEditSpec	endp
HookHyphen	endp
HookChkInput	endp
HookEditInput	endp
HookChkChar	endp

;----------------------------------------------------------------------
; StoHex - stuff binary AL as 2 hex digits at ES:DI
;
; On entry,
;	AL = binary digit to print as hex
;	ES:DI ptr to string buffer, CLD flag set
; On exit,
;	AX modified, ES:DI ptr to next location in buffer
;
; 920728 1.0 GK adapted from PutHex
;----------------------------------------------------------------------

StoHex	proc	near

	push	ax			; save for lower nibble
	shr	al,1
	shr	al,1
	shr	al,1
	shr	al,1
	call	h_digit
	pop	ax			; now do lower nibble

h_digit:
	and	al,00001111b
	add	al,90h
	daa
	adc	al,40h
	daa
	stosb				; stuff hex digit in buffer
	ret

StoHex	endp

;----------------------------------------------------------------------
; StoDec - stuff AX as CL decimal digits at ES:DI
;
; On entry,
;	AX = number to print as decimal
;	ES:DI ptr to leftmost position of field
;	CL has width of field, will zero-fill
; On exit,
;	AX, CX, DX modified, ES:DI ptr to beyond rightmost position
;
; 920728 1.0 GK adapted from PutHex
;----------------------------------------------------------------------

StoDec		proc	near

		push	ax		; save value
		mov	al, '0'
		mov	ch, 0
		rep	stosb		; fill with zeroes

		mov	cl, 0Ah 	; divide by 10
		pop	ax		; restore value
		push	di		; save ending DI value

StoDecNext:
		xor	dx, dx
		div	cx		; ax, dx rem=dx:ax/reg
		add	dl, 30h 	; '0'
		dec	di
		mov	es:[di], dl
		or	ax, ax
		jnz	StoDecNext

		pop	di		; return with DI pointing after field
		ret

StoDec		endp
ENDIF

;--------------------------------------------------------------------
;
;   SetInterruptVector: this routine determine the mask value for the selected
;			IRQ level and EOI values for both master and slave
;			8259s, remaps IRQ vector to our ISR and save current
;			IRQ vector in case DriverUnhook needs it.  We do not
;			mask on the selected IRQ in this routine, instead, it
;			will be turned on and off as init goes on.
;
;   On Entry:
;	      al = IRQ level
;	      sti
;   On Exit:
;	      sti
;
; 920717 0.0 GK modified, rewrote DOS get/setint calls
;--------------------------------------------------------------------

HookIntVector	proc	near
		push	es

; convert IRQ to interrupt vector number

		mov    al, IRQLevel		    ; al = IRQ level
		mov    ah, 8			    ; IRQ 0-7 => int vector # 08h-0fh
		cmp    al, 8
		jb     int_8tof
	
		mov    ah, (70h-8)		    ; IRQ 8-15 => int vector # 70h-77h
int_8tof:
		add    al, ah			    ; al = int vector number
		cli

; save old interrupt vector

		xor	bx, bx
		mov	es, bx			; ES = 0
		cbw
		mov	bx, ax
		shl	bx, 1
		shl	bx, 1
		les	bx, es:[bx]
		mov	OrgINTVector_Off, bx
		mov	OrgINTVector_Seg, es

; remap int vector to our DriverISR
IFDEF	UNDI
		mov    dx, offset CGroup:UNDI_DriverISR   ; ds:dx = ptr to DriverISR
ELSE
		mov    dx, offset CGroup:DriverISR   ; ds:dx = ptr to DriverISR
ENDIF
		xor	di, di
		mov	es, di			; ES = 0
		cbw
		mov	di, ax
		shl	di, 1
		shl	di, 1

		mov	cs:Int_Vector_Loc, di
	
		mov	ax, dx
		stosw
		mov	ax, cs		;971030
		stosw

		; PCInit (GENR.ASM) will mask out IRQ9. Need to
		; unmask again
		mov	al, IRQLevel		    ; al = IRQ level
		cmp	al, 7
		jbe	HookInt9

		in	al, 0A1h		; get slave PIC mask
		jmp	$+2
		and	al, 0fdh		; unmask int 9
		out	0A1h, al

HookInt9:
		; unmask Interrupt now
		mov    dx, int_mask_port
		in     al, dx

		and    al, IntMaskOnBit
		jmp    $+2

		out    dx, al

		cmp    dx, MASTER_MASK_PORT		  ; are we using IRQ from slave?
		je     HookIntVectorExit		 ; no

		in     al, MASTER_MASK_PORT		  ; yes, turn on cascaded input
		and    al, not 04			  ;  on master 8259
		out    21h, al

HookIntVectorExit:
		pop	es
		sti
		ret

HookIntVector	endp


;-----------------------------------------------------------------------------
;   Driver Unhook
;
;   assumes:
;	     DS is setup
;	     Interrupts are DISABLED
;
;   returns:
;	     interrupt disabled
;	     no registers need to be preserved.
;-----------------------------------------------------------------------------

DriverUnhook  proc near

	       xor    ax, ax
	       mov    es, ax
	       mov    di,word ptr cs:Int_Vector_Loc

	       mov    ax, OrgINTVector_Off
	       or     ax, OrgINTVector_Seg
	       jz     unhook_rtn		;nothing to unhook
	       mov    ax, OrgINTVector_Off
	       mov    es:[di].off, ax
	       mov    ax, OrgINTVector_Seg
	       mov    es:[di].segm, ax

unhook_rtn:
	       ret

DriverUnhook  endp

IFNDEF	UNDI
;----------------------------------------------------------------------------;
;      E I S A	  S U P P O R T    R O U T I N E S
;----------------------------------------------------------------------------;
;------ WriteEEProm ---------------------------------------------------------;
;									     ;
;	This routine writes  a word to the EEProm.  It can only be used      ;
;	once the board has been brought up at a particular IOBase.	     ;
;									     ;
;	Entry:								     ;
;	BL	= EEProm word to write					     ;
;	CX	- Value to write
;	Window	= 0							     ;
;	RealIOBase  = valid						     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;									     ;
;	Destroys BX, CX, DX, SI, DI and ES.  All other registers are	     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
public		WriteEEProm
WriteEEProm	proc	near
	push	bx
	push	cx
	push	dx

	; To write a word to EEPROM, sequence of events are
	;	1. Issue Erase/Write Enable Cmd ( Port IOBase+A, Value 30h )
	;	2. Issue Erase Cmd ( Port IOBase+A, Value C0h or Address )
	;	3. Issue Erase/Write Enable Cmd again ( Port IOBase+A, Value 30h )
	;	4. Load data into EEPROM Data Reg ( Port IOBase+C, Value Data )
	;	5. Issue Write Cmd ( Port IOBase+A, Value 40 or Address )
	;
	; Always check if EEPROM Busy bit is cleared
;960401	mov	dx, IOBase
;960401	add	dx, PORT_EECmd
	mov	dx, PortEECmd
	call	WaitEEBusy

	mov	ax, 030h
	out	dx, ax				; issue Erase/Write Enable Cmd

	call	WaitEEBusy

	xor	ax, ax
	mov	al, bl
	add	al, 0c0h
	out	dx, ax				; issue Erase EEPROM Cmd

	call	WaitEEBusy

	mov	ax, 030h
	out	dx, ax				; issue Erase/Write Enable Cmd

	call	WaitEEBusy

	mov	ax, cx
;960401	add	dx, ( PORT_EEData - PORT_EECmd )
	mov	dx, PortEEData
	out	dx, ax				; load data

;960401	add	dx, ( PORT_EECmd - PORT_EEData )
	mov	dx, PortEECmd
	xor	ax, ax
	mov	al, bl
	add	al, 040h
	out	dx, ax

	call	WaitEEBusy

	pop	dx
	pop	cx
	pop	bx
	ret
WriteEEProm    endp


;----------------------------------------------------------------------------;
; NADChgReceiveMask - Called by NAD to change the receive mask of adapter.
;		       Change RxFilter to accept Multicast packets
;
; Input:	    bl	  command
;			  b0: set   = enable
;			      clear = disable
;			  b1: change broadcast mask
;			  b2: change multicast mask
;			  b3: change promiscuous mask (not supported yet)
;
;		    es:di pointer to multicast address (FOUND.Dest_Addr)
;
; no reg. changed
;----------------------------------------------------------------------------;
NADChangeReceiveMask	proc	far

		push	si
		push	dx
		push	ax

		mov	dx, PortCmdStatus

	; For the 3Com Chipset, enabling group address reception implies
	; broadcast reception. 
		test	bl, 2			; want to change Broadcast?
		jnz	NADChgBroad

		test	bl, 4			; want to change Multicast?
		jz	NADChgMaskEnd

NADChgMulti:
		test	bl, 1
		jz	NADChgMultiOff

NADChgMultiOn:
		mov	si, offset NIDGroupAddr
		mov	ax, es:[di]
		mov	ds:[si], ax

		add	si, 2
		add	di, 2
		mov	ax, es:[di]
		mov	ds:[si], ax

		add	si, 2
		add	di, 2
		mov	ax, es:[di]
		mov	ds:[si], ax

		mov	ax, HWFilter
		or	ax, FILTER_MULTICAST
		out	dx, ax
		jmp	short NADChgMaskEnd

NADChgMultiOff:
		mov	ax, HWFilter
		and	ax, NOT FILTER_MULTICAST
		out	dx, ax
		jmp	short NADChgMaskEnd

NADChgBroad:
		test	bl, 1
		jz	NADChgBroadOff

NADChgBroadOn:
		mov	ax, HWFilter
		or	ax, FILTER_BROADCAST
		out	dx, ax
		jmp	short NADChgMaskEnd

NADChgBroadOff:
		mov	ax, HWFilter
		and	ax, NOT FILTER_BROADCAST
		out	dx, ax

NADChgMaskEnd:
		mov	HWFilter, ax

		pop	ax
		pop	dx
		pop	si
		retf

NADChangeReceiveMask	endp


;--------------------------------------------------------------------
; ChkForCfg - prompt for config, wait up to 3s for Ctrl-Alt-B or Ctrl-Alt-Z
;
; On exit,
;	ZF set if user selected config option
;
; 911230 0.0 GK
;--------------------------------------------------------------------
ChkForCfg	proc	near
		push	es

		mov	ax, 0040h
		mov	es, ax			; ES = BIOS segment. For ChkKey

;		mov	al, BWTLANOS
;		and	al, BWTLANMASK
;		cmp	al, BWTLANTRI
;		jnz	NotFirst

		; dump "BootWare/3C5x9 supports NetWare..." string & wait for
		; user input
;		mov	ah, NormalAttr
;		mov	si, offset CGroup:Str8022U
;		call	PrintTemplate

;		mov	si, 8			; 8 seconds
;		call	ChkKey

		; check ah to see if <ENTER> is pressed
;		cmp	ah, 01ch	; ZF
;		jmp	short ChkForCfgExit

NotFirst:
		; dump "Press <CTRL><ALT><B>..." string & wait for user input
;		mov	bx, offset CGroup:StrPrompt
;		mov	dx, word ptr [bx]
;		mov	ah, NormalAttr
;		add	bx, 2
;		call	PrintMsgLoc
		mov	dx, 0
		mov	bx, offset cGroup:CfgStr
		call	PrintAt

		mov	si, 3			; 3 seconds
		call	ChkKey

ChkForCfgExit:
		pop	es
		ret			; ret ZF = 1 if config selected

ChkForCfg	endp

;--------------------------------------------------------------------
; ChkKey - prompt for config, wait up to 3s for Ctrl-Alt-B or Ctrl-Alt-Z
;
; On exit,
;	si  = # of seconds
;	ZF set if user selected config option
;
;	For 802.2U, ax = -1 if timeout
;		    ah = keyboard input (scan code)
;
; 911230 0.0 GK
;--------------------------------------------------------------------

ChkKey		proc	near

ChkKeyLoop1:
		mov	ax, 18		; 18 ticks = 1 second

		mov	cs:MaxTicks, ax
		mov	ah, 0
		int	1Ah			; get current tick value
		mov	cs:StartTick, dx	; save it


ChkKeyLoop:
	mov	ah, 1
	int	016h		; Keyboard interrupt - check keyboard status

	jz	ChkKeyTime	; No char available; Check time

; character available. check if char is Ctrl-Alt-B
; checking kybd status will not remove char from buffer

	mov	ah, 0		; Read char. Char is removed from buffer
	int	016h		; Keyboard interrupt

	cmp	ah, 030h	; "B"
	jz	ChkCtrlAlt	; are Ctrl & Alt keys pressed?

	cmp	ah, 02ch	; "Z"
	jnz	ChkKeyEnd

ChkCtrlAlt:
	mov	al, es:[17h]	; keyboard status flag 1
	and	al, 00001100b	; keep Ctrl and Alt bits
	cmp	al, 00001100b	; were they set?
;	 jz	 ChkKeyEnd	 ; yes, exit with ZF set
	jmp	short ChkKeyEnd ; exit with ZF

ChkKeyTime:
	mov	ah, 0
	int	1Ah			; get current tick
	sub	dx, cs:StartTick
	mov	cs:Curticks, dx
	cmp	dx, cs:MaxTicks
	cmc


	jnc	ChkKeyLoop	; Is 1 second yet ????

	mov	al, '.'
	call	PutChr
	dec	si
	jnz	ChkKeyLoop1

	mov	al, -1
	or	al, al		; ret ZF = 0, timeout

ChkKeyEnd:
		ret
ChkKey		endp


;--------------------------------------------------------------------
; Print
;
; Prints string given by DS:BX at current location.
;
; Parameters:
;	ds:bx - pointer to null terminated string
;
; Returns:
;	nothing
;--------------------------------------------------------------------
public	Print
Print	proc	near

	push	ax			; save ax
	push	si			; save si

	mov	si, bx			; put string address into si

printLoop:
	lodsb				; get a character
	or	al, al			; check for end of line NULL
	je	printDone		; got end of line
	mov	ah, 0Eh
	int	010h			; write TTY
	jmp	short printLoop 	; next char

printDone:
	pop	si			; restore si
	pop	ax			; restore ax
	ret

Print	endp
ENDIF


Int_Vector_Loc		dw	?


IFDEF	UNDI
_TEXT		ends

_DATA		segment	para public
ENDIF
OrgINTVector_Off	dw	0	;save area for original INT vector
OrgINTVector_Seg	dw	0

	even
;------------------------------------------------------------------------------
;	Adapter configuration set by DriverInit during initialization
;------------------------------------------------------------------------------
EEIntConfig0	dw	?		;value of internal config reg
EEIntConfig1	dw	?		;value of internal config reg
EEMiiPhySelect	dw	-1

		even
;
; the various TxStart thresholds, set at INIT time.  must be contiguous and
; MasterTxStart must follow PioTxStart.
;
		even
		public	PioTxStart
PioTxStart	label	word
		rept 4
		TxStartStruc <?, 4, 0, 0, 0, 0>
		endm

		public	AfterTxStart
AfterTxStart	label	word			; marks the end of them

TxFreeMax	dw	?

IntMaskOnBit	db	?
IRQLevel	db	?

		   even

public		BoardID
BoardID 	db	6 dup (0)
LineSpeed	dw	10		;10/100 Mb determined at init

		even

ResetOptions		dw	?
InternalConfig		dd	?

	public	xcvr
xcvr		dw	?		; 10/20/94, cj

OldStackPtr	dw	0		; save Stack Pointer
		dw	0

		   even

PortCmdStatus		dw	0eh	; Win 0	; Command/Status Register

PortBadSsdCount    	label	word	; Win 4
PortTxFree		label	word	; Win 1 
PortEEData  		dw	0Ch	; Win 0 ; EEProm data register

PortMediaStatus		label	word	; Win 4 ; Media type/status
PortRxFree		label 	word	; Win 3	; Rx Free
PortTimer		label	word	; Win 1 ; 
PortEECmd      		dw	0Ah	; Win 0 ; EEProm command register

PortResetOptions  	label 	word	; Win 3 ; ResetOptions
PortPhyMgmt		label	word	; Win 4 ; MII Management 
PortRxStatus		label	word	; Win 1
PortCfgResource 	dw	08h	; Win 0 ; resource configuration

PortNetDiag		label	word 	; Win 4 ; net diagnostic
PortMacControl		label	word	; Win 3 ; MacControl
PortCfgAddress  	dw	06h	; Win 0 ; address configuration

PortFIFODiag		label	word	; Win 4 ; FIFO Diagnostic
PortCfgControl  	dw	04h	; Win 0 ; configuration control

PortInternalCfgH   	label 	word    ; Win 3 ; InternalConfig High
PortProductID   	dw	02h	; Win 0 ; product id (EISA)

PortTxStart		label	word	; Win 5 ; tx start threshold
PortInternalCfgL   	label 	word	; Win 3 ; InternalConfig Low
PortSA0_1  		label	word	; win 2 ; station address bytes 0,1
PortRxFIFO	   	label 	word	; Win 1 ; offset 00
PortTxFIFO	   	label 	word	; Win 1 ; offset 00
PortManufacturer	dw	00h	; Win 0; Manufacturer code (EISA)

; port variables for window 1
PortTxStatus		dw	0bh	; offset 0b

NumOfPorts	equ	( $ - PortCmdStatus )/ 2 

; PCI and Extended Memory Stuff
UseExtendMem	dw	0

OldPCIROMAddr	dw	0
		dw	0

AutoScanBuffer	dw	0

CUIAttr 	dw	0		; Store Screen Attribute for CUI
UpdateRetry	db	3		; times to retry before giving up

 		   ALIGN       4

NormalRxEarly	   dw	     ?		; set RxEarly cmd + threshold

CurTxStart	   dw	     CMD_SETTXSTART+TXSTART_DISABLED

PadBytes	   db	     ?

EESoftConfigInfo	dw	?	; EEPROM word 0d
EESoftConfigInfo2	dw	?
CWord			dw	?	; EEPROM word 0e
EECapabilities		dw	0	; EEPROM word 010h
BusType 		db	?	;

		ALIGN	4
eoi_value	dw	?		; ah = master, al = slave
int_mask_port	dw	?

		ALIGN	4
HwFilter	dw	?
IRQBit			db	?

StartTick	dw	0		; save area for tick value
RxPend		db	0		; b7 set if pending for Rx packet
					;  XXXXX NO XXX  else has rx status (0, 1)
IFNDEF	UNDI
MaxTicks	dw	0		; save area for max ticks
CurTicks	dw	0		; save area for current ticks

TxRetries	db	0		; transmission retry count
DestID		db	6 dup (?)	; save area for destination node ID

StatusMsgFlag	dw	0		; pointer to msg to be printed in DLCStatus

MemBase 		dw	0	; for TCP/IP Generic
					; also used to store OldBWTFeature

		ALIGN	4		; always dword-aligned
LookAheadBuffer    db	     LxBufSize+3 dup (?)   ; receive lookahead buffer

		ALIGN   4
TxEDPtr 	dd	?		; save area for transmit ED
RxEDPtr 	dd	?		; save area for receive ED

		ALIGN     4
public		CliBuffer
CliBufferSize	equ	128
CliBuffer	db	CliBufferSize dup (?)	; ** not needed, may be removed
						; along with other code in init
						; that computes copycli

		even
NIDGroupAddr	db	6 dup(0)	; GroupAddr
;ErrStruct	ErrorStruct < 0, 0, 0 >

;public		APITbl
;APITbl		dw	'WB'            ; start of BootWare API table
;		dw	30 dup (0)	; allocate 60 bytes ?
ENDIF

flag		dw	0

MiiPhyUsed	dw	0
MIIPhyOui	dw	-1
MIIPhyModel	dw	-1
MiiRegValue	dw	-1

MIIPhyAddr	db	0
phyANLPAR	dw	0
phyANAR 	dw	0

LinkDetected	db	0
forcemode	db	0
broadcom	db	0

Calibration	dd	0
Delayoneusec	dd	0

IFDEF	UNDI
_DATA		ends
_BSS	segment
		db	1024 dup(0)

_BSS	ends

ELSE
END_NAD
ENDIF

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\vulcan.inc ===
;------ VULCAN.INC ----------------------------------------------------------;
;									     ;
;	This file contains Vulcan-specific equates, structures and	     ;
;	macros.  It must be assembled with MASM 5.1 or later.		     ;
;									     ;
;----------------------------------------------------------------------------;
;----------------------------------------------------------------------------;
;									     ;
;	This source file is the property of 3Com Corporation and may not be  ;
;	copied or distributed in any isomorphic form without an appropriate  ;
;	prior licensing arrangement with 3Com Corporation.		     ;
;									     ;
;	Copyright (c) 1988 3Com Corporation				     ;
;									     ;
;	3Com Corporation						     ;
;	5400 Bayfront Plaza, P.O. Box 58145				     ;
;	Santa Clara, CA 95052-8145 USA					     ;
;	(408) 764-6016							     ;
;									     ;
;----------------------------------------------------------------------------;

;
; the compatibility level of this driver
;
CLEVEL		    equ 0

;------ Equates -------------------------------------------------------------;
;
; Command code masks
;
CMD_CMDMASK	    equ 0F800h			; command bits
CMD_ARGMASK	    equ 007FFh			; argument bits
;
; Command codes, word form
;
CMD_GLOBALRESET     equ 00000b shl 11		; global reset
CMD_SELECTWINDOW    equ 00001B shl 11		; select register window
CMD_STARTINTXCVR    equ 00010b shl 11		; start internal transciver
CMD_RXDISABLE	    equ 00011b shl 11		; rx disable
CMD_RXENABLE	    equ 00100b shl 11		; rx enable
CMD_RXRESET	    equ 00101b shl 11		; rx reset
CMD_RXDISCARD	    equ 01000b shl 11		; rx discard top packet
CMD_TXENABLE	    equ 01001b shl 11		; tx enable
CMD_TXDISABLE	    equ 01010b shl 11		; tx disable
CMD_TXRESET	    equ 01011b shl 11		; tx reset
CMD_REQUESTINT	    equ 01100b shl 11		; request interrupt
CMD_ACKNOWLEDGE     equ 01101b shl 11		; acknowledge interrupt
CMD_SETINTMASK	    equ 01110b shl 11		; set interrupt mask
CMD_SETRZMASK	    equ 01111b shl 11		; set read zero mask
CMD_SETRXFILTER     equ 10000b shl 11		; set rx filter
CMD_SETRXEARLY	    equ 10001b shl 11		; set rx early threshold
CMD_SETTXAVAILABLE  equ 10010b shl 11		; set tx available threshold
CMD_SETTXSTART	    equ 10011b shl 11		; set tx start threshold
CMD_STATSENABLE     equ 10101b shl 11		; statistics enable
CMD_STATSDISABLE    equ 10110b shl 11		; statistics disable
CMD_STOPINTXCVR     equ 10111b shl 11		; start internal transciver
;
; Command codes, hibyte form (commands without operands only)
;
CMDH_STARTINTXCVR   equ CMD_STARTINTXCVR shr 8
CMDH_RXDISABLE	    equ CMD_RXDISABLE shr 8
CMDH_RXENABLE	    equ CMD_RXENABLE shr 8
CMDH_RXDISCARD	    equ CMD_RXDISCARD shr 8
CMDH_TXENABLE	    equ CMD_TXENABLE shr 8
CMDH_TXDISABLE	    equ CMD_TXDISABLE shr 8
CMDH_REQUESTINT     equ CMD_REQUESTINT shr 8
CMDH_STATSENABLE    equ CMD_STATSENABLE shr 8
CMDH_STATSDISABLE   equ CMD_STATSDISABLE shr 8
CMDH_STOPINTXCVR    equ CMD_STOPINTXCVR shr 8
;
; Status register bits (INT for interrupt sources, ST for the rest)
;
INT_LATCH	    equ 00001h			; interrupt latch
INT_ADAPTERFAIL     equ 00002h			; adapter failure
INT_TXCOMPLETE	    equ 00004h			; tx complete
INT_TXAVAILABLE     equ 00008h			; tx available
INT_RXCOMPLETE	    equ 00010h			; rx complete
INT_RXEARLY	    equ 00020h			; rx early
INT_REQUESTED	    equ 00040h			; interrupt requested
INT_UPDATESTATS     equ 00080h			; update statistics
ST_FAILED	    equ 00800h			; command failed
ST_BUSY 	    equ 01000h			; command busy
ST_WINDOW	    equ 0E000h			; window bits (13-15)

STH_FAILED	    equ ST_FAILED shr 8
STH_BUSY	    equ ST_BUSY shr 8
STH_WINDOW	    equ ST_WINDOW shr 8

ifdef REV0
INT_OFFTXCOMPLETE   equ ((NOT (INT_TXCOMPLETE or INT_ADAPTERFAIL or INT_UPDATESTATS)) and (0FFh))
ifdef NDIS
INT_ONTXCOMPLETE    equ (INT_TXCOMPLETE or INT_UPDATESTATS)
else
INT_ONTXCOMPLETE    equ ((NOT INT_ADAPTERFAIL) and (0FFh))
endif

else
INT_OFFTXCOMPLETE   equ ((NOT (INT_TXCOMPLETE)) and (0FFh))
ifdef NDIS
INT_ONTXCOMPLETE    equ INT_TXCOMPLETE
else
;940107INT_ONTXCOMPLETE    equ MASK_NONE
endif
endif
;
; RxStatus register bits, both forms
;
RXS_INCOMPLETE	    equ 8000h			; not completely received
RXS_ERROR	    equ 4000h			; error in packet
RXS_LENGTH	    equ 07FFh			; bytes in RxFIFO
RXS_ERRTYPE	    equ 3800h			; Rx error type, bit 13-11
ifdef REV0
RXS_OVERRUN	    equ 0000h			; overrun error
RXS_DRIBBLE	    equ 0800h			; dribble bit
RXS_CRC 	    equ 1000h			; CRC error
RXS_RUNT	    equ 1800h			; runt packet error
RXS_OVERSIZE	    equ 2000h			; oversize packet error
RXS_FRAMING	    equ 2800h			; framing error
else
RXS_OVERRUN	    equ 0000h			; overrun error
RXS_OVERSIZE	    equ 0800h			; oversize packet error
RXS_DRIBBLE	    equ 1000h			; dribble bit (not an error)
RXS_RUNT	    equ 1800h			; runt packet error
RXS_CRC 	    equ 2800h			; CRC error
RXS_FRAMING	    equ 2000h			; framing error
endif

RXSH_INCOMPLETE     equ RXS_INCOMPLETE shr 8
RXSH_ERROR	    equ RXS_ERROR shr 8
RXSH_ERRTYPE	    equ RXS_ERRTYPE shr 8
RXSH_OVERRUN	    equ RXS_OVERRUN shr 8
RXSH_DRIBBLE	    equ RXS_DRIBBLE shr 8
RXSH_CRC	    equ RXS_CRC shr 8
RXSH_RUNT	    equ RXS_RUNT shr 8
RXSH_OVERSIZE	    equ RXS_OVERSIZE shr 8
RXSH_FRAMING	    equ RXS_FRAMING shr 8
;
; TxStatus register bits
;
TXS_COMPLETE	    equ 80h			; tx completed
TXS_INTREQUESTED    equ 40h			; interrupt on successfull tx
TXS_ERRTYPE	    equ 38h			; error bits
TXS_JABBERERROR     equ 20h			; jabber error
TXS_UNDERRUN	    equ 10h			; tx underrun error
TXS_MAXCOLLISIONS   equ 08h			; max collisions error
TXS_STATUSOVERFLOW  equ 04h			; TX status stack is full
;
; Window Numbers
;
WNO_SETUP	    equ 0			; setup/configuration
WNO_OPERATING	    equ 1			; operating set
WNO_STATIONADDRESS  equ 2			; station address setup/read
WNO_FIFO	    equ 3			; FIFO management
WNO_DIAGNOSTICS     equ 4			; diagnostics
WNO_READABLE	    equ 5			; registers set by commands
WNO_STATISTICS	    equ 6			; statistics
;
; Port offsets, Window 1
;
PORT_CmdStatus	    equ 0Eh			; command/status
PORT_TxFree	    equ 0Ch			; free transmit bytes
PORT_TxStatus	    equ 0Bh			; transmit status (byte)
PORT_Timer	    equ 0Ah			; latency timer (byte)
PORT_RxStatus	    equ 08h			; receive status
PORT_RxFIFO	    equ 00h			; RxFIFO read
PORT_TxFIFO	    equ 00h			; TxFIFO write
;
; Port offsets, Window 0
;
PORT_EEData	    equ 0Ch			; EEProm data register
PORT_EECmd	    equ 0Ah			; EEProm command register
PORT_CfgResource    equ 08h			; resource configuration
PORT_CfgAddress     equ 06h			; address configuration
PORT_CfgControl     equ 04h			; configuration control
PORT_ProductID	    equ 02h			; product id (EISA)
PORT_Manufacturer   equ 00h			; Manufacturer code (EISA)
;
; Port offsets, Window 2
;
PORT_SA0_1	    equ 00h			; station address bytes 0,1
PORT_SA2_3	    equ 02h			; station address bytes 2,3
PORT_SA4_5	    equ 04h			; station address bytes 4,5
;
; Port offsets, Window 3
;
PORT_ALT_TxFree     equ 0Ch			; free transmit bytes (dup)
PORT_RxFree	    equ 0Ah			; free receive bytes
PORT_RomControl     equ 04h			; 940425 RomControl Register

;
; Port offsets, Window 4
;
PORT_MediaStatus    equ 0Ah			; media type/status
PORT_SlingshotStatus equ 08h			; Slingshot status
PORT_NetDiagnostic  equ 06h			; net diagnostic
PORT_FIFODiagnostic equ 04h			; FIFO diagnostic
PORT_HostDiagnostic equ 02h			; host diagnostic
PORT_TxDiagnostic   equ 00h			; tx diagnostic
;
; Port offsets, Window 5
;
PORT_RZMask	    equ 0Ch			; read zero mask
PORT_IntMask	    equ 0Ah			; interrupt mask
PORT_RxFilter	    equ 08h			; receive filter
PORT_RxEarly	    equ 06h			; rx early threshold
PORT_TxAvailable    equ 02h			; tx available threshold
PORT_TxStart	    equ 00h			; tx start threshold
;
; Port offsets, Window 6
;
PORT_TXBYTES	    equ 0Ch			; tx bytes ok
PORT_RXBYTES	    equ 0Ah			; rx bytes ok
PORT_TXDEFER	    equ 08h			; tx frames deferred (byte)
PORT_RXFRAMES	    equ 07h			; rx frames ok (byte)
PORT_TXFRAMES	    equ 06h			; tx frames ok (byte)
PORT_RXDISCARDED    equ 05h			; rx frames discarded (byte)
PORT_TXLATE	    equ 04h			; tx frames late coll. (byte)
PORT_TXSINGLE	    equ 03h			; tx frames one coll. (byte)
PORT_TXMULTIPLE     equ 02h			; tx frames mult. coll. (byte)
PORT_TXNOCD	    equ 01h			; tx frames no CDheartbt (byte)
PORT_TXCARRIERLOST  equ 00h			; tx frames carrier lost (byte)
;
; Various command arguments
;
INT_ALLDISABLED 	equ 00000000000b	    ; all interrupts disabled
ifdef REV0
INT_ALLENABLED		equ 00011111100b	    ; all but AdapterFailure
else
INT_ALLENABLED		equ 00011111110b	    ; all interrupts enabled
endif

MASK_ALL		equ INT_ALLDISABLED
MASK_NONE		equ INT_ALLENABLED

FILTER_INDIVIDUAL	equ 0001b		    ; individual address
FILTER_MULTICAST	equ 0010b		    ; multicast/group addresses
FILTER_BROADCAST	equ 0100b		    ; broadcast address
FILTER_PROMISCUOUS	equ 1000b		    ; promiscuous mode

RXEARLY_DISABLED	equ 2032		    ; RxEarly to disable

TXAVAIL_DISABLED	equ 2040		    ; TxAvailable to disable
TXAVAIL_MIN		equ 4

TXSTART_DISABLED	equ 2040		    ; TxStart to disable
TXSTART_MIN		equ 0
MAX_TXSTART		equ TXSTART_DISABLED

MAX_RXLENGTH		equ 1792		    ; maximum rxlength

TXRXRESET_ALLBUTBM      equ 0100b               ; DUMMY DUMMY This value is copied
						; from 59xp even though it doesn't
						; exist on isa board

;
; Transmit Preamble
;
PREAMBLESIZE		equ 4			    ; transmit preamble size
TXP_INTONSUCCESS	equ 8000h		    ; interrupt on successful tx
;
; Bits in various diagnostics registers
;
MEDIA_TP		equ 8000h		    ; TP transciever
MEDIA_BNC		equ 4000h		    ; Thinnet transciever
MEDIA_INTENDEC		equ 2000h		    ; internal encoder/decoder
MEDIA_SQE		equ 1000h		    ; SQE present
MEDIA_LBEAT		equ 0800h		    ; link beat ok (TP)
MEDIA_POLARITY		equ 0400h		    ; polarity (TP)
MEDIA_JABBER		equ 0200h		    ; jabber (TP)
MEDIA_UNSQUELCH 	equ 0100h		    ; unsquelch (TP)
MEDIA_LBEATENABLE	equ 0080h		    ; link beat enable (TP)
MEDIA_JABBERENABLE	equ 0040h		    ; jabber enable (TP)
MEDIA_CRS		equ 0020h		    ; carrier sense
MEDIA_COLLISION 	equ 0010h		    ; collision
MEDIA_SQEENABLE 	equ 0008h		    ; enable SQE statistics

NETD_EXTLOOPBACK	equ 8000h		    ; TP external loopback
NETD_ENDECLOOPBACK	equ 4000h		    ; ENDEC loopback
NETD_CORELOOPBACK	equ 2000h		    ; ethernet core loopback
NETD_FIFOLOOPBACK	equ 1000h		    ; FIFO loopback
NETD_TXENABLED		equ 0800h		    ; tx enabled
NETD_RXENABLED		equ 0400h		    ; rx enabled
NETD_TXTRANSMITTING	equ 0200h		    ; tx transmitting
NETD_TXRESETREQD	equ 0100h		    ; tx reset required

FIFOD_RXRECEIVING	equ 8000h		    ; rx receiveing
FIFOD_RXUNDERRUN	equ 2000h		    ; rx underrun
FIFOD_RXSTATUSOVER	equ 1000h		    ; rx status overrun
FIFOD_RXOVERRUN 	equ 0800h		    ; rx overrun
FIFOD_TXOVERRUN 	equ 0400h		    ; tx overrun
FIFOD_BISTRESULTS	equ 00FFh		    ; BIST results (mask)

SLING_TXUNDERRUN	equ 2000h		    ; Slingshot TxUnderrun bit
;
; board identification codes, byte swapped in Rev 0
;
ifdef REV0
EISA_MANUFACTURER_ID	equ 0506Dh		    ; EISA manufacturer code
ISA_PRODUCT_ID		equ 05090h		    ; Product ID for ISA board
PRODUCT_ID_MASK 	equ 0FFF0h		    ; Mask off revision nibble
else
EISA_MANUFACTURER_ID	equ 06D50h		    ; EISA manufacturer code
ISA_PRODUCT_ID		equ 09050h		    ; Product ID for ISA board
PRODUCT_ID_MASK 	equ 0F0FFh		    ; Mask off revision nibble
endif
;
; EEProm access
;
EE_BUSY 		    equ 8000h			; EEProm busy bit in EECmd
EE_TCOM_NODE_ADDR_WORD0     equ 00h
EE_TCOM_NODE_ADDR_WORD1     equ 01h
EE_TCOM_NODE_ADDR_WORD2     equ 02h
EE_VULCAN_PROD_ID	    equ 03h
EE_MANUFACTURING_DATA	    equ 04h
EE_SERIAL_NUMBER_WORD0	    equ 05h
EE_SERIAL_NUMBER_WORD1	    equ 06h
EE_MANUFACTURER_CODE	    equ 07h
EE_ADDR_CONFIGURATION	    equ 08h
EE_RESOURCE_CONFIGURATION   equ 09h
EE_OEM_NODE_ADDR_WORD0	    equ 0Ah
EE_OEM_NODE_ADDR_WORD1	    equ 0Bh
EE_OEM_NODE_ADDR_WORD2	    equ 0Ch
EE_SOFTWARE_CONFIG_INFO     equ 0Dh
EE_CWORD		    equ 0Eh
EE_CHECKSUM		    equ 0Fh
EE_CAPABILITIES		    equ	010h
;
; contention logic
;
ID_PORT 		equ 110h
READ_EEPROM		equ 080h
SET_TAG_REGISTER	equ 0D0h
TEST_TAG_REGISTER	equ 0D8h
ACTIVATE_AND_SET_IO	equ 0E0h
ACTIVATE_VULCAN 	equ 0FFh
;
; Resource Configuration Register bits
;
RCONFIG_IRQ		equ 0F000h
;
; Address Configuration Register bits
;
ACONFIG_XCVR		equ 0C000h
ACONFIG_IOBASE		equ 0001Fh
ACONFIG_ROM		equ 03f00h
ACONFIG_ROMSIZE 	equ 03000h
ACONFIG_ROMBASE 	equ 0f00h
;

IOBASE_EISA		equ 0001Fh

TP_XCVR 		equ 00000h
BNC_XCVR		equ 0C000h
AUI_XCVR		equ 04000h

MIN_IO_BASE_ADDR	equ 200h
MAX_IO_BASE_ADDR	equ 3F0h
REGISTER_SET_SIZE	equ 10h
;
; Software Configuration Register bits
;
SW_OPTIMIZE		equ 0030h
SW_MAXCLI		equ 3F00h		; Maximum Modem Speed
SW_LINKBEAT		equ 4000h
SW_BPROT		equ 00007h
SW_CONFIG		equ 00008h		; NOT assigned yet 0=enable, 1=disable
SW_DEFAULT		equ 040h		; 0 = network, 1 = disable
SW_RS			equ 080h		; 1 = enable, 0=disable
SW_BOOTWARE		equ SW_BPROT OR SW_CONFIG OR SW_DEFAULT OR SW_RS	 ; all the bits assigned to BootWare



;
; Possibilities for SW_OPTIMIZE
;
OPTIMIZE_DOS_CLIENT	equ 0010h
OPTIMIZE_WINDOWS_CLIENT equ 0020h
OPTIMIZE_SERVER 	equ 0030h
;
; Configuration Control Register bits
;
ENABLE_ADAPTER		equ 01h
;
; Possibilities for SW_MAXCLI ( Max Modem Speed )
; GY 931007
MODEM_NONE		equ	03F00h
MODEM_1200		equ	03300h
MODEM_2400		equ	02700h
MODEM_9600		equ	01300h
MODEM_19200		equ	0900h
MODEM_38400		equ	0400h
;
; Possible values for SW_BPROT
;
BOOTPROT_UNINIT 	equ 0	; means "virgin" board. Default to 802.2
BOOTPROT_NW_8022	equ 1
BOOTPROT_NW_EII 	equ 2
BOOTPROT_NW_8023	equ 3
BOOTPROT_RPL		equ 4
BOOTPROT_TCPIP		equ 5		; for BW5X9 overlay
BOOTPROT_BOOTP		equ 5
BOOTPROT_DHCP		equ 6

;
; Bus Types
;
BUS_ISA 		equ	1		; ISA card in  ISA mode on ISA	machine
BUS_EISA		equ	2		; EISA card
BUS_MCA 		equ	3		; MCA  card
BUS_EISA_ISAMODE	equ	4		; ISA card in  ISA mode on EISA machine
BUS_EISA_EISAMODE	equ	5		; ISA card in EISA mode on EISA machine
BUS_EISA_ISA2EISA	equ	6		; ISA card on EISA bus switch from ISA->EISA
BUS_EISA_EISA2ISA	equ	7		; ISA card on EISA bus switch from EISA->ISA
BUS_PCI			equ	8		; PCI card

; Current Fail and Warning Level
LEVEL_FAIL		equ	0		; current Fail Level
LEVEL_WARNING		equ	0		; current Warning Level

; RomControl register bits (select 16K ROM Page) Windows 3/Port 5
RomPage0		equ	0
RomPage1		equ	100h
RomPage2		equ	200h
RomPage3		equ	300h
RomPageMask		equ	0fcffh

; 940923 ModeBits, contains system & adapter setting
ModeV2		equ	1
ModeNonISA	equ	4
ModeMCA		equ	8
ModeEISA	equ	10h
ModePCI		equ	20h
ModePnP		equ	40h
ModeAtmel	equ	80h

; 940923 Capabilities Word (EEPROM Offset 010h)
CAPA_PNP		equ	1
CAPA_FULLDUPLEX		equ	2
CAPA_BIGPACKET		equ	4
CAPA_SLAVEDMA		equ	8

;------ Structures ----------------------------------------------------------;
;
; TxStart structure
;
TxStartStruc	struc
txs_thresh	dw	?		; TxStart threshold (+CMD_SETTXSTART)
txs_min 	dw	?		; minimum threshold
txs_uTxOK	dw	?		; TxOK low word at last underrun
txs_uN		dw	?		; number of entries in uSum
txs_uSum	dw	?		; sum of uN x packets between underruns
TxStartStruc	ends

SIZE_TxStart	equ	SIZE TxStartStruc

;
; SelectWindow - select register window specified (must be a constant)
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
SelectWindow macro  wno
		mov	ax, CMD_SELECTWINDOW + wno 
		out     dx, ax
endm

;------ GENERAL.INC ---------------------------------------------------------;
;                                                                            ;
;       General purpose equates, structures and macros.                      ;
;                                                                            ;
;----------------------------------------------------------------------------;

FALSE           equ     0
;;TRUE            equ     0ffh
;
; I/O ports for the PICs
;
MASTER_MASK_PORT equ    021h
SLAVE_MASK_PORT equ     0A1h
;
; DOUBLEWORD - Thirty-two bit double word layout for sixteen bit word access
;
doubleword      struc
loword          dw      0               ; low order word
hiword          dw      0               ; high order word
doubleword      ends

;
; FARPOINTER - Thirty-two bit 286-style far pointer layout for segment and
;              offset access
;
farpointer      struc
off             dw      0               ; offset
segm            dw      0               ; segment or selector
farpointer      ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90x\bwstruct.inc ===
;====================================================================
; BWSTRUCT.INC
;
; Include for for BootWare, defines common structures.
;
; 970116 PC - first version
;====================================================================

;--------------------------------------------------------------------
; Common equates
;---------------------------------------------------------------------
FEATURE_LOCAL	equ	1
FEATURE_VIRUS	equ	2
FEATURE_MENU	equ	4
FEATURE_KEYWAIT	equ	8
FEATURE_FLOPPY	equ	64
FEATURE_HDRIVE	equ	128

;--------------------------------------------------------------------
; Event Descriptor (ED) Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc	ED
	Ptr		dw	?	; pointer to next ED
	Unused		dw	?	; spare word
	DestAddr	dw	?, ?, ?	; destination Address
	ErrCode		dw	?	; error code
	ErrMsg		dw	?	; pointer to error msg
	Length		dw	?	; total packet length
	FragCount	dw	?	; number of fragments
	FragOff		dw	?	; 1st fragment offset
	FragSeg		dw	?	; 1st fragment segment
	FragLen 	dw	?	; length of fragment
ends
ELSE
ED_Struct      STRUC
	ED_Ptr		dw	?	; pointer to next ED
	ED_Unused	dw	?	; spare word
	ED_DestAddr	dw	?, ?, ?	; destination address
	ED_ErrCode	dw	?       ; error code
	ED_ErrMsg	dw	?       ; Pointer to error msg
	ED_Length	dw	?	; total packet length
	ED_FragCount	dw	?	; Number of descriptors/fragments
	ED_FragOff	dw	?	; Descriptor Pointer
	ED_FragSeg	dw	?	; Descriptor Pointer
	ED_FragLen 	dw	?	; Length of packet descriptor
ED_Struct      ENDS
ENDIF

;--------------------------------------------------------------------
; Descricptor Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc Frag
	Off		dw	?	; offset of fragment
	Seg		dw	?	; segment of fragment
	Len		dw	?	; length of fragment
ends
ELSE
Frag Struc
	FragOff		dw	?	; offset of fragment
	FragSeg		dw	?	; segment of fragment
	FragLen		dw	?	; length of fragment
Frag ends
Descript_Struct STRUC
	DPointer	dd	?	; Descriptor Pointer
	DLen		dw	?	; Length of packet descriptor
Descript_Struct ends
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c5x9\portable.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/portable.INV   1.2   19 Sep 1997 21:39:10   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: MACROS which drive the way portable code is built
;

IFDEF              PORTABLE_INC
ELSE
PORTABLE_INC       equ    1

;--------------------------------------------------------------------------
; This file requires the inclusion of "equates.inc" before it is included.
;--------------------------------------------------------------------------
; This file must follow the definition (via inclusion or in-line) of one of
; the following configuration assemble-time switches.  The following IFNDEF
; statements take care of two situations:
;   1) the user of this file only needs to define the model it using as TRUE,
;      all other models will not be defined and will therefore be set FALSE,
;      which means all references to the model will use IF (not IFDEF or IFE).
;   2) a user who does not define any model will find that nothing is defined,
;      since all of the IFNDEF's will assemble.  A model must be selected.
;--------------------------------------------------------------------------

IFDEF DOSNDIS
ELSE
DOSNDIS              equ         FALSE
ENDIF

IFDEF OS2NDIS
ELSE
OS2NDIS              equ         FALSE
ENDIF

IFDEF NWSERVER
ELSE
NWSERVER             equ         FALSE
ENDIF

IFDEF DOSODI
ELSE
DOSODI               equ         FALSE
ENDIF

IFDEF OS2ODI
ELSE
OS2ODI               equ         FALSE
ENDIF

;--------------------------------------------------------------------------
; @CPUSH
;
; Description : Each driver inserts code that pushes the registers that must 
;               not be changed by a function called from C.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@CPUSH macro  name
IF DOSODI
 IFDEF XMIT_NO_COPY_DMA
    push    ebp            
    push    ebx
    push    esi
    push    edi
 ELSE
    push    bp
    push    bx
    push    di
    push    si
 ENDIF
ENDIF
IF OS2ODI
    push    ebp            
    push    ebx
    push    edi
    push    esi
ENDIF
IF DOSNDIS
    push    bp
    push    bx
    push    di
    push    si
ENDIF
IF OS2NDIS
    push    ebp
    push    ebx
    push    edi
    push    esi
ENDIF
IF NWSERVER
    CPush
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @CPOP
;
; Description : Each driver inserts code that pops the registers that must 
;               not be changed by a function called from C.  
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@CPOP macro  name
IF DOSODI
 IFDEF XMIT_NO_COPY_DMA
    pop     edi            
    pop     esi
    pop     ebx
    pop     ebp
 ELSE
    pop     si
    pop     di
    pop     bx
    pop     bp
 ENDIF
ENDIF
IF OS2ODI
    pop     esi
    pop     edi            
    pop     ebx
    pop     ebp
ENDIF
IF DOSNDIS
    pop     si
    pop     di
    pop     bx
    pop     bp
ENDIF
IF OS2NDIS
    pop     esi
    pop     edi            
    pop     ebx
    pop     ebp
ENDIF
IF NWSERVER
    CPop
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @PUSH_MUSTSAVE
;
; Description : Each driver inserts code that pushes the registers that must 
;               NEVER be changed by a function, others may be saved at times.
;               PUSH_MUSTSAVE contents must correlate to POP_MUSTSAVE.
;               PUSH_MUSTSAVE can't be written to allow POP_SAVE to save flags.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@PUSH_MUSTSAVE macro  name
IF DOSODI
    push    bx
ENDIF
IF OS2ODI
    push    ebx
ENDIF
IF DOSNDIS
ENDIF
IF OS2NDIS
ENDIF
IF NWSERVER
    push    ebp
    push    ebx
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @POP_MUSTSAVE
;
; Description : Each driver inserts code that pops the registers that must 
;               NEVER be changed by a function, others may be saved at times.
;               POP_MUSTSAVE contents must correlate to PUSH_MUSTSAVE.
;               POP_MUSTSAVE cannot save contents of Flags Register.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@POP_MUSTSAVE macro  name
IF DOSODI
    pop     bx
ENDIF
IF OS2ODI
    pop     ebx
ENDIF
IF DOSNDIS
ENDIF
IF OS2NDIS
ENDIF
IF NWSERVER
    pop     ebx
    pop     ebp
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @PROC_BEGIN
;
; Description : Each driver inserts code that defines a procedure header.
;
; Entry       : The "name" is required as it precedes the "proc" directive,
;               the "distance" is optional, and will default to the size 
;               as specified by SEGMENT directives if it is not provided.
;
; Exit        : none
;
;--------------------------------------------------------------------------
@PROC_BEGIN macro  name, distance
IF DOSODI
            align 4
    public  name
name        proc   distance
ENDIF
IF OS2ODI
            align 4
    public  name
name        proc   distance
ENDIF
IF DOSNDIS
;            align 16
    public  name
name        proc   distance
ENDIF
IF OS2NDIS
            align 16
    public  name
name        proc   distance
ENDIF
IF NWSERVER
            align 16
    public  name
name        proc   distance
ENDIF
            ENDM

;--------------------------------------------------------------------------
; @PROC_END
;
; Description : Each driver inserts code that concludes a procedure, WITHOUT
;               the Return statement (avoids forcing jump-to-end to return).
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@PROC_END   macro  name
IF DOSODI
name        endp
ENDIF
IF OS2ODI
name        endp
ENDIF
IF DOSNDIS
name        endp
ENDIF
IF OS2NDIS
name        endp
ENDIF
IF NWSERVER
name        endp
ENDIF
            ENDM


;--------------------------------------------------------------------------
; BREG
;
; Description : Each driver defines an equate which will be used by portable
;               code when referring to variables in the data segment.
;               The value of the EQU must evaluate to a valid value when
;               used, the EQU is always used within [] brackets.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
IF DOSODI
BREG    equ    0
ENDIF

IF OS2ODI
BREG    equ    bx
ENDIF

IF DOSNDIS
BREG    equ    0
ENDIF

IF OS2NDIS
BREG    equ    0
ENDIF

IF NWSERVER
BREG    equ    ebp
ENDIF

;--------------------------------------------------------------------------
; Macro for virtual to physical address conversion, only necessary for users 
; of LINEAR mode as opposed to SEGMENTED mode.  If using LINEAR mode, base
; register is 0, all virtual addresses must be converted to true physical 
;   (therefore this mode requires that the macro convert "source").
;
; If using SEGMENTED mode AND not running under a memory maanager, then DS
; is the true paragraph number to be assigned to the CURU base register, and
; any offset with the data segment is valid value to give CU/RU as an address 
;   (therefore this mode requires that the macro leave "source" as-is).
;
; If using SEGMENTED mode AND loaded under a memory manager, the DS value is
; not necessarily the TRUE paragraph number, but OFFSETs will be correct.
; At initialization time DS must converted if needed under memory manager. 
; In this situation, whether DS is same as TRUE paragraph or not, BUILD_PHYSICAL
; will leave "source" alone since is offsets are correct within TRUE paragraph.
;
; NOTE that can't use SEGMENTED mode and point to memory outside base Segment,
; because the SCB MACROs and structures always force the high-16 bits to zero.
;--------------------------------------------------------------------------
;- Build A Physical Address From A Logical Address
@BUILD_PHYS_OFFSET  MACRO    Source
    ENDM

;- Build A Physical Address From A Logical Address
@BUILD_PHYS_ADDRESS MACRO    Source
IF NWSERVER
    xchg    eax, Source
    call    MSMGetPhysical
    xchg    Source, eax
ENDIF
IF OS2ODI
    ;- call    DevHlp:VirtToPhys          ; NOTE macro can be used ANYTIME!
    mov     esi, Source
    call    ConvertToPhysicalAddress
    mov     Source, eax
ENDIF
IF (DOSNDIS OR OS2NDIS)
    mov     ax, ds
    mov     es, ax
    mov     esi, Source
    call    ConvertToPhysicalAddress
    mov     Source, eax
ENDIF
    ENDM


;--------------------------------------------------------------------------
; Macro to Output a string under Various and Random Netware Requirements.
;--------------------------------------------------------------------------
@PrintWarning  macro Msg
IF NWSERVER
    push    esi
    mov     esi, OFFSET Msg
    call    MSMPrintStringWarning
    pop     esi
ENDIF

IF (OS2ODI OR DOSODI)
    push    dx
IF  OS2ODI
    mov     dx, Msg
ENDIF    
IF  DOSODI
    mov     dx, OFFSET CGROUP:Msg
ENDIF    
    push    ax
    push    bx
    call    MSMPrintStringZero 
    pop     bx
    pop     ax
    pop     dx
ENDIF
    ENDM

;--------------------------------------------------------------------------
; Macro Used by routines which load a pointer to a string in AX to indicate
; that the routine encountered an error (therefore NDIS must return non-zero).
;--------------------------------------------------------------------------
@LOAD_MSGPTR macro msg
IF NWSERVER
    lea     eax, msg 
ENDIF
IF DOSODI
    lea     ax, msg 
ENDIF
IF OS2ODI
    mov     eax, msg 
ENDIF
IF (OS2NDIS OR DOSNDIS)
    xor     eax, eax
    dec     eax
ENDIF
    ENDM

;--------------------------------------------------------------------------
; Generic Register names used in portable code:
;
; Assumption here is that the NWSERVER code is using Flat 32-bit model, all
; pointers must be 32-bit pointers (relative to DS, whatever that is).  All
; other drivers using this code are assumed to be 16-bit Segment Model code.
;--------------------------------------------------------------------------

IF NWSERVER

RDI equ     edi
RSI equ     esi
RDX equ     edx
RCX equ     ecx
RBX equ     ebx
RAX equ     eax
RBP equ     ebp

ELSE

RDI equ     di
RSI equ     si
RDX equ     dx
RCX equ     cx
RBX equ     bx
RAX equ     ax
RBP equ     bp

ENDIF

ENDIF


; EOF - $Workfile:   portable.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90x\pxe_stru.inc ===
;
NUM_MCADDRS    	Equ	8		; max number of multicast addresses.
MAX_DATABLK    	Equ	8		; max number of data blocks supported 
					;	in a descriptor.
MAX_IMMED_LEN	Equ	64		; max immediate data buffer length
MAX_TX_DATABLK	Equ	MAX_DATABLK	; max number of data blocks supported 
					;	in a Tx descriptor.
MAX_TD_DATABLK	Equ	MAX_DATABLK	; max number of TransferData blocks
		
APIMaxFunc	EQU	0011h

ADDR_LEN	EQU	16
ETH_ADDR_LEN	EQU	6
MAXNUM_MCADDR	EQU	8

;
; protocol values in transmit buffer
;
P_UNKNOWN	EQU	0		;; no media header
P_IP	 	EQU	1		;; IP type
P_ARP		EQU	2		;; ARP type
P_RARP		EQU	3		;; RARP type

TYPE_IP	 	EQU	0800h		;; IP type
TYPE_ARP	EQU	0806h		;; ARP type
TYPE_RARP	EQU	8035h		;; RARP type
;
; xmitflag values in transmit buffer
;
PKT_DESTADDR	EQU 0	;; destination address given 
PKT_BROADCAST	EQU 1h	;; use broadcast address 
PKT_MULTICAST	EQU 2h	;; multicast addr given

;; Hardware type values
ETHER_TYPE 		EQU 1
EXP_ETHER_TYPE	EQU 2
IEEE_TYPE  	EQU 6
ARCNET_TYPE   	EQU 7


Eth_MCastBuf	Struc
MCastAddrCount	DW	?
MCastAddr	DB MAXNUM_MCADDR * ETH_ADDR_LEN dup (0)
Eth_MCastBuf	Ends

MC_MCastBuf		Struc
MC_MCastAddrCount	DW	?
MC_MCastAddr  		DB MAXNUM_MCADDR * ADDR_LEN dup (0)
MC_MCastBuf		Ends

NIC_StartUp	Struc
S_Status	DW	?
S_BusType	DB	?
S_AddrType	DB	?
S_DataSeg	DW	?
S_DataSegAddr	DD	?
S_DataSegSize	DW	?
S_CodeSegSize	DW	?
S_BusDevFunc	DW	?	;; PCI Dev_ID
S_PCI_ds_off	dw	?	;; Far pointer to PCI data structure
S_PCI_ds_seg	dw	?
S_PnP_csn	dw	?	; Card select number.-1 for non-PnP BBS device
S_PnP_eh_off	dw	?	; Far pointer to PnP expansion header
S_PnP_eh_seg	dw	?
NIC_StartUp	Ends

NIC_CleanUp	Struc
CL_Status	DW	?
NIC_CleanUp	Ends

NIC_Initialize	Struc
I_Status	DW	?
I_Prot_ini	DD	?
I_RcvInt	DD	?
I_GenInt	DD	?
NIC_Initialize  Ends

NIC_Reset	Struc
R_Status	DW	?
R_MCBuf		MC_MCastBuf <>
NIC_Reset	Ends

NIC_ShutDown	Struc
SD_Status	DW	?
NIC_ShutDown	Ends

NIC_Open	Struc
O_Status	DW	?
O_OpenFlg	DW	?
O_PktFilter	DW	?
O_MCBuf		MC_MCastBuf <>
NIC_Open	Ends

NIC_Close	Struc
C_Status	DW	?
NIC_Close	Ends

X_DataBlock	Struc
X_TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
X_TxRsvdByte	DB	?	; Reservered, must be zero.
X_TxDataLen	DW	?	; Data block length in bytes.
X_TxDataPtr	DD	?	; Far pointer to data block.
X_DataBlock Ends

NIC_TBD		Struc
X_Length	DW	?
X_BufOff	DW	?
X_BufSeg	DW	?
X_DataBlkCount	DW	?		; will always be zero for base code
X_DataBlk	DB	MAX_DATABLK * SIZE X_DataBlock dup (0)	
NIC_TBD		Ends

NIC_Transmit		Struc
T_Status		DW	?
T_Protocol		DB	?
T_XmitFlag		DB	?
T_DestAddrOffset 	DW	?	; 16-bit segment & offset of the
T_DestAddrSegment 	DW	?	; destination media address 
T_TBDOffset		DW	?	; 16-bit segment & offset 
T_TBDSegment		DW	?	; transmit buffer descriptor 
T_Reserved		DD	2 dup(0)	; for future use	
NIC_Transmit Ends

NIC_SetMCastAddr	Struc
SM_Status		DW	?
SM_MCBuf		MC_MCastBuf <>
NIC_SetMCastAddr	Ends

NIC_SetStationAddr	Struc
SS_Status		DW	?
SS_StationAddr		DB	ADDR_LEN dup (0)
NIC_SetStationAddr	Ends

NIC_SetPacketFilter	Struc
SP_Status		DW	?
;;SP_NewFilter		DW  ?
SP_NewFilter		DB  ?
;;SP_MCBuf		MC_MCastBuf <>
NIC_SetPacketFilter	Ends

NIC_GetInfo	Struc
GI_Status		DW	?
GI_BaseIo		DW	?
GI_IntNumber		DW	?
GI_MTU			DW	?
GI_HwType		DW	?
GI_HwAddrLen		DW	?
GI_CurrentNodeAddress	DB ADDR_LEN dup (0)
GI_PermNodeAddress	DB ADDR_LEN dup (0)
GI_ROMAddress		DW 	?
GI_RxBufCt		DW	?
GI_TxBufCt		DW	?
NIC_GetInfo	Ends

NIC_GetNICType_pci 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
Vendor_ID	DW	?	; /* OUT:  */
Dev_ID		DW	?	;  /* OUT:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */ 
Rev		DB	?	;  /* OUT: Revision number */ 
BusDevFunc	DW	?	; /* OUT: Bus, Device & Function numbers */
NIC_GetNICType_pci 	Ends

NIC_GetNICType_pnp 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
EISA_Dev_ID	DD	?	; /* Out:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */
CardSelNum	DW	?	; /* OUT: Card Selector Number */
Res		DB	0	;
NIC_GetNICType_pnp 	Ends

NIC_GetStatistics	Struc
GS_Status		DW	?
GS_XmtGoodFrames	dd    ?
GS_RcvGoodFrames	dd    ?
GS_RcvCRCErrors		dd    ?
GS_RcvResourceErrors	dd    ?
NIC_GetStatistics	Ends

NIC_ClearStatistics	Struc
CS_Status		DW	?
NIC_ClearStatistics	Ends

NIC_InitDiags	Struc
ID_Status	DW	?
NIC_InitDiags   Ends

NIC_ForceInterrupt	Struc
FI_Status		DW	?
NIC_ForceInterrupt	Ends

NIC_GetMCastAddr	Struc
GM_Status		DW	?
GM_InetAddr		DD	?
GM_HwAddr		DB	ADDR_LEN dup (0)
NIC_GetMCastAddr	Ends

;NIC_API_Entry	Struc
;Signature 	DB	'PXENV+'	;; not null terminated
;Version		DW	0100h		;; 1.0
;StrucLength	DB	0		;; length of this structure
;CheckSum	DB	0		;; fill in later
;rm_entry_off	DW	0		;; real mode driver entry offset
;rm_entry_seg	DW	0		;; real mode driver entry segment
;pm_entry_off	DW	0		;; protected mode driver entry offset
;pm_entry_seg	DW	0		;; protected mode driver entry segment
;NIC_API_Entry	Ends

s_PXENV_ENTRY	Struc
signature	db	6 dup(?)	; 'PXENV+'
ver             dw      ?               ; MSB=major, LSB=minor
bytes		db	?		; sizeof s_pxenv_entry
checksum	db	?		; 8-bit checksum of structure,
					; including this byte shoube be zero.
rm_entry_off	dw	?		; 16-bit real-mode segment & offset.
rm_entry_seg	dw	?
pm_entry_off	dw	?		; 16-bit protected mode 32-bit physical
pm_entry_base	dd	?		; address and 16-bit offset.
stack_sel	dw	?		; PROM stack segment.  Will be set
stack_size	dw	?		; to 0 when removed from memory.
base_cs_sel	dw	?		; Base code segment.  Will be set
base_cs_size	dw	?		; to 0 when removed from memory.
base_ds_sel	dw	?		; Base data segment.  Will be set
base_ds_size	dw	?		; to 0 when removed from memory.
mlid_ds_sel	dw	?		; MLID data segment.
mlid_ds_size	dw	?
mlid_cs_sel	dw	?		; MLID code segment.
mlid_cs_size	dw	?
s_PXENV_ENTRY	Ends

;; Ethernet II protocol header
EtherHeader	Struc
E_DestAddr	DB 6 dup (0)	;; destination ethernet addr
E_SrcAddr	DB 6 dup (0)	;; destination ethernet addr
E_Type		DW  ?	;; protocol type
EtherHeader	Ends

ETHER_HEADER_LEN	Equ	SIZE EtherHeader

; 
; * Data structures for TransmitChain (Tx), TransferData (TD)
; 
TxDataBlock	Struc
TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TxRsvdByte	DB	?	; Reservered, must be zero.
TxDataLen	DW	?	; Data block length in bytes.
TxDataPtr	DD	?	; Far pointer to data block.
TxDataBlock	Ends

; 
; * TransmitChain descriptor structure definition
; 
TxBufDesc	Struc
TxImmedLen	DW	?	; Byte count of immediate data, max=64
TxImmedPtr	DD	?	; Virtual address of Immediate data
TxDataCount	DW	?	; Number of Data Blocks (max = 8)
TxDataBlk	DB	size TxDataBlock * MAX_TX_DATABLK dup(0)
TxBufDesc	Ends

TxBufDescrSize	Equ	Size TxImmedLen + Size TxImmedPtr + Size TxDataCount

; 
; * TransferData data block description
; 
TDDataBlock	Struc
TDPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TDRsvdByte	DB	?	; Reservered, must be zero.
TDDataLen	DW	?	; Data block length in bytes.
TDDataPtr	DD	?	; Far pointer to data block.
TDDataBlock	Ends

; 
; * TransferData descriptor structure
; 
TDBufDesc	Struc
TDDataCount	DW	?	; No of Data Blocks (max 8 for V1.01).
TDDataBlk	DB	size TDDataBlock*MAX_TD_DATABLK dup(0)
TDBufDesc	Ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90x\bwequ.inc ===
;--------------------------------------------------------------------
; BootWare Table variables
;--------------------------------------------------------------------
;extrn	BWTLANOS:byte			; ROMTOP.ASM
;extrn	BWType:byte			; ROMTOP.ASM
;extrn	BWTCpyRAM:word			; ROMTOP.ASM
;extrn	BWTFeature:word 		; ROMTOP.ASM
;extrn	BWTEthStd:word			; ROMTOP.ASM
;extrn	BWTAddrRes:byte 		; ROMTOP.ASM  ; GK 970126
;extrn	BWTChkSum:byte			; ROMTOP.ASM

;extrn	RomBase:word			; autoscan.asm

;extrn	PrintAt:near			; common.asm
;extrn	ChangeTitleAttrib:near

;--------------------------------------------------------------------
; Protocol starting functions
;--------------------------------------------------------------------
;extrn	NetWareStart:near
;extrn	RPLStart:near
;extrn	IPStart:near

;--------------------------------------------------------------------
; EQUATES
;--------------------------------------------------------------------

; NAD Return Codes
SUCCESSFUL		EQU	0000h
REQUEST_QUEUED		EQU	0002h
OUT_OF_RESOURCE 	EQU	0006h
INVALID_PARAMETER	EQU	0007h
INVALID_FUNCTION	EQU	0008h
NOT_SUPPORTED		EQU	0009h
HARDWARE_ERROR		EQU	000ah
TRANSMIT_ERROR		EQU	000bh
NO_SUCH_DESTINATION	EQU	000ch
HARDWARE_NOT_FOUND	EQU	0023h
HARDWARE_FAILURE	EQU	0024h
CONFIGURATION_FAILURE	EQU	0025h
INTERRUPT_CONFLICT	EQU	0026h
INITIALIZATION_FAILED	EQU	0028h
RECEIVE_TIMEOUT 	EQU	0080h		; Rx2 in NetWare
GENERAL_FAILURE 	EQU	00ffh

; definition for BWTEthStd
BWTETH8023	equ	0
BWTETH8022	equ	1
BWTETHSOFT	equ	2
BWTETHEII	equ	1500		; if BWTEthStd >1500, then E_II
BWTETH8137	equ	08137h
;BWTETH800	equ	0800h		; used for tcp/ip bootp
;BWTETH806	equ	0806h		; used for tcp/ip bootp/arp

; definition for BWTLANOS
BWTLANNW	equ	010h
BWTLANRPL	equ	020h
BWTLANIP	equ	040h
BWTLANMASK	equ	0F0h
BWTLANTRI	equ	070h
BWTLANLOCAL	equ	3h		; Bit 0,1

; definition for BWTFEATURE
BWTFEA_DEFAULT	equ	1
BWTFEA_RS	equ	2
BWTFEA_CONF	equ	4

MasterEOIPort	equ	20h
SlaveEOIPort	equ	0a0h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90x\bwnad.inc ===
;====================================================================
; BWNAD.INC
;
; Include for for BootWare NAD modules.
;
; 970116 PC - first version
;====================================================================

;--------------------------------------------------------------------
; Include the common structures.
;--------------------------------------------------------------------

IFDEF _IDEAL_
	include "bwstruct.inc"
ELSE
	include bwstruct.inc

ENDIF

;--------------------------------------------------------------------
; NAD publics
;--------------------------------------------------------------------
public	NADGetBootInfo
public	NADInitialize
public	NADConfig
public	NADStart
public	LanOption

IFDEF _IDEAL_
	include "bwequ.inc"
ELSE
	include bwequ.inc

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90x\pcinic.inc ===
;
; Modifications:   $Header: /Client Boot/NICS/Generic/UNDI_NAD/PCINIC.INC 1     16/07/98 5:33p Dmitry Klimenko $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: PCI Configuration Space Definitions
;

IFDEF            PCI_INC
ELSE
PCI_INC          equ    1
include pci.inc

;--------------------------------------------------------------------------
; Configuration Space Header
;--------------------------------------------------------------------------
PCI_CONFIG_STRUC       struc
    PciVendorId        dw    ?                ;- PCI Vendor ID
    PciDeviceId        dw    ?                ;- PCI Device ID
    PciCommand         dw    ?
    PciStatus          dw    ?
    PciRevisionId      db    ?
    PciClassCode       db    3  dup (?)
    PciCacheLineSize   db    ?
    PciLatencyTimer    db    ?
    PciHeaderType      db    ?
    PciBIST            db    ?
    PciBaseReg0        dd    ?
    PciBaseReg1        dd    ?
    PciBaseReg2        dd    ?
    PciBaseReg3        dd    ?
    PciBaseReg4        dd    ?
    PciBaseReg5        dd    ?
    PciReserved0       dd    0
    PciReserved1       dd    0
    PciExpROMAddress   dd    ?
    PciReserved2       dd    0
    PciReserved3       dd    0
    PciInterruptLine   db    ?
    PciInterruptPin    db    ?
    PciMinGnt          db    ?
    PciMaxLat          db    ?
PCI_CONFIG_STRUC       ends

;--------------------------------------------------------------------------
; Config Space Register Offsets
; Refer To The PCI Specification For Detailed Explanations
;--------------------------------------------------------------------------
VENDOR_ID_REGISTER       equ     00h          ;- PCI Vendor ID Register
DEVICE_ID_REGISTER       equ     02h          ;- PCI Device ID Register
COMMAND_REGISTER         equ     04h          ;- PCI Command Register
STATUS_REGISTER          equ     06h          ;- PCI Status Register
REV_ID_REGISTER          equ     08h          ;- PCI Revision ID Register
CLASS_CODE_REGISTER      equ     09h          ;- PCI Class Code Register
CACHE_LINE_REGISTER      equ     0Ch          ;- PCI Cache Line Register
LATENCY_TIMER            equ     0Dh          ;- PCI Latency Timer Register
HEADER_TYPE              equ     0Eh          ;- PCI Header Type Register
BIST_REGISTER            equ     0Fh          ;- PCI Built-In SelfTest Register
BAR_0_REGISTER           equ     10h          ;- PCI Base Address Register 0
BAR_1_REGISTER           equ     14h          ;- PCI Base Address Register 1
BAR_2_REGISTER           equ     18h          ;- PCI Base Address Register 2
BAR_3_REGISTER           equ     1Ch          ;- PCI Base Address Register 3
BAR_4_REGISTER           equ     20h          ;- PCI Base Address Register 4
BAR_5_REGISTER           equ     24h          ;- PCI Base Address Register 5
SUB_VENDOR_ID_REGISTER           equ     2Ch          ;- PCI Base Address Register 5
SUB_DEVICE_ID_REGISTER           equ     2Eh          ;- PCI Base Address Register 5
EXPANSION_ROM            equ     30h          ;- PCI Expansion ROM Base Register
INTERRUPT_LINE           equ     3Ch          ;- PCI Interrupt Line Register
INTERRUPT_PIN            equ     3Dh          ;- PCI Interrupt Pin Register
MIN_GNT_REGISTER         equ     3Eh          ;- PCI Min-Gnt Register
MAX_LAT_REGISTER         equ     3Fh          ;- PCI Max_Lat Register

;--------------------------------------------------------------------------
; Configuration space DWORD register offsets
;--------------------------------------------------------------------------
CONFIG_SPACE_REG0        equ     0
CONFIG_SPACE_REG1        equ     1
CONFIG_SPACE_REG2        equ     2
CONFIG_SPACE_REG3        equ     3
CONFIG_SPACE_REG4        equ     4
CONFIG_SPACE_REG5        equ     5
CONFIG_SPACE_REG6        equ     6
CONFIG_SPACE_REG7        equ     7
CONFIG_SPACE_REG8        equ     8
CONFIG_SPACE_REG9        equ     9
CONFIG_SPACE_REGA        equ     0Ah
CONFIG_SPACE_REGB        equ     0Bh
CONFIG_SPACE_REGC        equ     0Ch
CONFIG_SPACE_REGD        equ     0Dh
CONFIG_SPACE_REGE        equ     0Eh
CONFIG_SPACE_REGF        equ     0Fh

;--------------------------------------------------------------------------
; Byte/Word Offsets In A Config DWORD
; These offsets can be used to move a Byte or Word into the lower half of
; a register.
;--------------------------------------------------------------------------
CONFIG_BYTE_0            equ     0
CONFIG_BYTE_1            equ     8
CONFIG_BYTE_2            equ     16
CONFIG_BYTE_8            equ     24
CONFIG_WORD_0            equ     0
CONFIG_WORD_1            equ     16

;--------------------------------------------------------------------------
; Configuration Mechanism Registers
;--------------------------------------------------------------------------
CF1_CONFIG_ADDR_REGISTER   equ   0CF8h        ;- Config Space Address Register
CF1_CONFIG_DATA_REGISTER   equ   0CFCh        ;- Config Space Data Register
CF2_SPACE_ENABLE_REGISTER  equ   0CF8h        ;- CSE Register
CF2_FORWARD_REGISTER       equ   0CFAh        ;- Forward Register
CF2_BASE_ADDRESS           equ   0C000h       ;- Configuration #2 Base

;--------------------------------------------------------------------------
; PCI Class Code Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
PCI_BASE_CLASS           equ     02h          ;- Base Class - Network Controller
PCI_SUB_CLASS            equ     00h          ;- Sub Class - Ethernet Controller
PCI_PROG_INTERFACE       equ     00h          ;- Prog I/F - Ethernet COntroller

;--------------------------------------------------------------------------
; PCI Command Register Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
CMD_IO_SPACE             equ     BIT_0
CMD_MEMORY_SPACE         equ     BIT_1
CMD_BUS_MASTER           equ     BIT_2
CMD_SPECIAL_CYCLES       equ     BIT_3
CMD_MEM_WRT_INVALIDATE   equ     BIT_4
CMD_VGA_PALLETTE_SNOOP   equ     BIT_5
CMD_PARITY_RESPONSE      equ     BIT_6
CMD_WAIT_CYCLE_CONTROL   equ     BIT_7
CMD_SERR_ENABLE          equ     BIT_8
CMD_BACK_TO_BACK         equ     BIT_9

;--------------------------------------------------------------------------
; PCI Status Register Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
STAT_BACK_TO_BACK        equ     BIT_7
STAT_DATA_PARITY         equ     BIT_8
STAT_DEVSEL_TIMING       equ     BIT_9 OR BIT_10
STAT_SIGNAL_TARGET_ABORT equ     BIT_11
STAT_RCV_TARGET_ABORT    equ     BIT_12
STAT_RCV_MASTER_ABORT    equ     BIT_13
STAT_SIGNAL_MASTER_ABORT equ     BIT_14
STAT_DETECT_PARITY_ERROR equ     BIT_15

;--------------------------------------------------------------------------
; PCI Base Address Register For Memory (BARM) Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
BARM_LOCATE_BELOW_1_MEG  equ     BIT_1
BARM_LOCATE_IN_64_SPACE  equ     BIT_2
BARM_PREFETCHABLE        equ     BIT_3

;--------------------------------------------------------------------------
; PCI Base Address Register For I/O (BARIO) Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
BARIO_SPACE_INDICATOR    equ     BIT_0

;--------------------------------------------------------------------------
; PCI BIOS Definitions
; Refer To The PCI BIOS Specification
;--------------------------------------------------------------------------
;- Function Code List

;IFE  NWSERVER
;;- Server can use the defines in ODI.INC
;PCI_FUNCTION_ID          equ     0B1h         ;- AH Register
;PCI_BIOS_PRESENT         equ     01h          ;- AL Register
;FIND_PCI_DEVICE          equ     02h          ;- AL Register
;FIND_PCI_CLASS_CODE      equ     03h          ;- AL Register
;GENERATE_SPECIAL_CYCLE   equ     06h          ;- AL Register
;READ_CONFIG_BYTE         equ     08h          ;- AL Register
;READ_CONFIG_WORD         equ     09h          ;- AL Register
;READ_CONFIG_DWORD        equ     0Ah          ;- AL Register
;WRITE_CONFIG_BYTE        equ     0Bh          ;- AL Register
;WRITE_CONFIG_WORD        equ     0Ch          ;- AL Register
;WRITE_CONFIG_DWORD       equ     0Dh          ;- AL Register
;ENDIF

; Function Return Code List
SUCCESSFUL               equ     00h
FUNC_NOT_SUPPORTED       equ     81h
BAD_VENDOR_ID            equ     83h
DEVICE_NOT_FOUND         equ     86h
BAD_REGISTER_NUMBER      equ     87h

;- PCI BIOS Calls
PCI_BIOS_INTERRUPT       equ     01Ah         ;- PCI BIOS Int 1Ah Function Call
PCI_PRESENT_CODE         equ     20494350h    ;- Hex Equivalent Of 'PCI '
                                              ;- ASCII Codes for ' ICP'
PCI_PRESENT_CODE_WORD    equ     4350h        ;- Hex Equivalent Of 'CP'
PCI_SERVICE_IDENTIFIER   equ     49435024h    ;- ASCII Codes for 'ICP$'

;- PCI Device and Vendor IDs
;; JL - Removed nic specifics!
;;SPEEDO_DEVICE_ID         equ     1227h
;;SPLASH1_DEVICE_ID        equ     1226h
;;D100_DEVICE_ID           equ     1229h
;;D100_VENDOR_ID           equ     8086h

;- Maximum bus slots supported under Configuration mechanisms 1 and 2
CONFIG1_MAX_PCI_SLOTS    equ     32
CONFIG2_MAX_PCI_SLOTS    equ     16

;- Maximum buses supported
MAX_PCI_BUSES            equ     255

ENDIF


; EOF - $Workfile: PCINIC.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90x\nad90x.asm ===
page	,132
;************************************************************************
;* NAD90X.ASM
;*	- Contains modules supporting the NetPC UNDI API for 3c90x
;*
;* Modules included :-
;*	NADInit
;*	NADReset
;*	NADShutDown
;*	NADOpen
;*	NADClose
;*	NADSetFilter
;*	NADGetStatistics
;*	NADRequestINT
;*	NADMCastChange
;*	DriverISR_Proc
;*
;************************************************************************

.xlist


public	NADInit
public	NADReset
public	NADShutDown
public	NADOpen
public	NADClose
public	NADSetFilter
public	NADGetStatistics
public	NADRequestINT
public	NADMCastChange
public	DriverISR_Proc

public  NADSetMACAddress       ; * NEW
public  NADInitiateDiags       ; * NEW

extrn	IRQNumber:byte
extrn	Net_Address:byte
extrn	Node_Address:byte
extrn	MultiCast_Addresses:word

.list
	.386
;================
NADSetMACAddress	proc	near		; NEW

		push	di
		mov	di, offset DGroup:Node_Address
		mov	eax, dword ptr [si]
		mov	dword ptr ds:[di], eax
		mov	ax, word ptr [si+4]
		mov	word ptr ds:[di+4], ax
		xor	ax, ax
		pop	di
		ret

NADSetMACAddress	endp

;
;================
NADInitiateDiags	proc	near		; New

		stc
		ret

NADInitiateDiags	endp


;=========================================================================
; NADInit
;=========
;	- Initializes the adapter but does not enable the Tx and Rx units
;	- Hook receiving ISR
;
; Parameters:
;
; Return:	If CF = 0 then success,
;		else failure with  AX = 1 -> hardware failure
;			           AX = 2 -> media failure
;
; Remark:	Don't hook INT if this function fails
;=========================================================================
NADInit 	proc	near

;		push	ds
		push	es

;		mov	ax, cs
		mov	ax, ds
		mov	es, ax

		call	Init_Vulcan		;init vulcan hardware and
						;  variables, IOBase, IRQLevel
		or	ax, ax
		jnz	NADInitErr

		mov	al, IRQLevel
		mov	DGroup:IRQNumber, al

		cld
;		mov	cx, 6
;		mov	di, offset DGroup:NodeAddress
;		mov	si, offset DGroup:BoardID
;	rep	movsb

		mov	cx, 6
		mov	di, offset DGroup:Net_Address
		mov	si, offset DGroup:BoardID
	rep	movsb

		call	Init_Vulcan2

		cmp	LinkDetected, 0
		jz	no_media

		mov	dx, PortCmdStatus
		mov	ax, CMD_STATSENABLE
		out	dx, ax			;enable statistics counters

		call	HookIntVector

		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING		 ; switch to window 1

		clc
		jmp	NADInitx

no_media:
		mov	ax, 2
		jmp	initerr
NADInitErr:
		mov	ax, 1
initerr:
		stc
NADInitx:
		pop	es
;		pop	ds
		ret

NADInit 	endp


;=========================================================================
; NADReset
;==========
;	- Reset and Reinitialize the adapter
;	- Enables the Tx and Rx units
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADReset	proc	near

		call	Init_Vulcan2

		mov	dx, PortCmdStatus
		mov	ax, CMD_STATSENABLE
		out	dx, ax			;enable statistics counters

		clc
		ret

NADReset	endp


;=========================================================================
; NADShutDown
;=============
;	- reset the adapter and enables
;	- unhook our ISR
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADShutDown	proc	near

		mov	dx, PortCmdStatus
		xor	ax,ax			   ; global reset
		out	dx,ax
GResetWait:
		in      ax, dx
		test    ah, STH_BUSY
		jnz	GResetWait		   ; loop while busy
;;;
		call	DriverUnhook

		mov	ax, IOBase
		mov	cx, NumOfPorts
		mov	di, offset DGroup:PortCmdStatus
KillPorts:
		sub	ds:[di], ax
		add	di, 2
		loop	KillPorts

		clc
		ret

NADShutDown	endp


;=========================================================================
; NADOpen
;=========
;	- Enables the Tx and Rx units
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADOpen 	proc	near

		mov	dx, PortCmdStatus
		call	TxReset
		
		mov	ax, CMD_TXENABLE
		out	dx, ax			;enable Tx

		mov	ax, CMD_RXENABLE
		out	dx, ax			;enable Rx

		clc
		ret

NADOpen 	endp


;=========================================================================
; NADClose
;==========
;	- Disables the Tx and Rx units
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADClose	proc	near

		mov	dx, PortCmdStatus
		mov	ah, CMDH_TXDISABLE
		out	dx, ax			;disable Tx
		mov	ah, CMDH_RXDISABLE
		out	dx, ax			;disable Rx

		clc
		ret

NADClose	endp


;=========================================================================
; DriverISR_Proc
;================
;	- ISR procedure to be called by UNDI_DriverISR
;
; Parameters:	DS = DataSeg
;
; Return:	CF = a if not our int
;=========================================================================
DriverISR_Proc	proc	near

		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING
;
; check whether our board caused the interrupt
;
		in	ax, dx			; AL=Interrupt Reasons
		test	al, INT_LATCH
		jnz	isr_ours
not_ours:
		stc
		ret

isr_ours:
		pushf
		push	cs
		call	DriverISR	;a near call with IRET
		clc
		ret

DriverISR_Proc	endp


;=========================================================================
; NADSetFilter
;==============
;	- Change the rx unit's filter to a new one
;	- Handle the promiscuous/broadcast/multicast mode for the
;		rx unit accordingly if necessary
;
; Parameters:	AX = filter value, 1 = directed/multicast
;				   2 = broadcast
;				   4 = promiscuous
; Return:	carry set if failure
;=========================================================================
NADSetFilter	proc	near

		push	ax
		mov	dx, PortCmdStatus
		mov	ah, CMDH_RXDISABLE	;disable Rx
		out	dx, ax
		pop	ax

		shl	al, 1
		test	al, 00000010b
		jz	go_set_filter
		or	al, 00000001b	;set bit 0 if bit 1 is set
go_set_filter:
		mov	ah, CMD_SETRXFILTER/256
		mov	HWFilter, ax
		out	dx, ax
;
; if the filter setting was non-zero, enable the receiver.  otherwise, disable
; the receiver.
;
		test	al, al			; zero filter?
		jz	SetFilterEnd
;
; handle multicast addresses here if necessary
;
		mov	ah, CMDH_RXENABLE	;enable Rx
		out	dx, ax			;set Rx unit
SetFilterEnd:
		clc
		ret

NADSetFilter	endp


;=========================================================================
; NADGetStatistics
;==================
;	- Read the adapter's statistics
;
; Parameters:	ds:si points to variables holding the result
;			TxGoodFrames	dd	0	;1
;			RxGoodFrames	dd	0	;2
;			RxCRCErrors	dd	0	;3
;			RxDiscarded	dd	0	;3
;		ax = 0 means get the result
;		   = 1 means clear the statistics
;
; Return:	Carry clear if data obtained successfully
;=========================================================================
NADGetStatistics	proc	 near

		push	dx
		push	ax

		mov	dx, PortCmdStatus
		SelectWindow WNO_STATISTICS

		pop	ax
		or	ax, ax
		jz	get_data
		
		xor	ax, ax
		add	dx, 6			;PORT_TXFRAMES
		out	dx, al

		mov	dx, PortCmdStatus
		add	dx, 7			;PORT_RXFRAMES
		out	dx, al

		mov	dx, PortCmdStatus
		add	dx, 5			;PORT_RXDISCARDED
		out	dx, al
		
		jmp	short GetStatRet

get_data:
		xor	eax, eax
		add	dx, 6			;PORT_TXFRAMES
		in	al, dx
		mov	dword ptr [si], eax
		add	si, 4

		mov	dx, PortCmdStatus
		add	dx, 7			;PORT_RXFRAMES
		in	al, dx
		mov	dword ptr [si], eax
		add	si, 4

		mov	dword ptr [si], 0
		add	si, 4

		mov	dx, PortCmdStatus
		add	dx, 5			;PORT_RXDISCARDED
		in	al, dx
		mov	dword ptr [si], eax

GetStatRet:
		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING
		pop	dx

		clc
		ret

NADGetStatistics	endp


;=========================================================================
; NADRequestINT
;================
;	- Generate an interrupt to the host
;
; Parameters:
;
; Return:
;=========================================================================
NADRequestINT	proc	near

		mov	dx, PortCmdStatus
		mov	ax, CMD_REQUESTINT
		out	dx, ax
		ret

NADRequestINT	endp


;==========================================================================
; NADMCastChange
;================
;	- Modify the multicast buffer to receive the multicast addresses
;	  listed in the multicast table.
;         Each entry in the multicast table is as follows:
;                 Bytes 0-5 = Multicast Address
;         All addresses are contiguous entries
;
; Parameters:	CX =  Number of multicast entries.
;               ES:SI -> Multicast Table.
;
; Return:	All registers may be destroyed.
;==========================================================================
NADMCastChange	proc	near

		push	ds

;		mov	dx, PortCmdStatus
;		mov	ax, CMD_RXDISABLE
;		out	dx, ax			;disable Rx

		push	ds
		push	es
		pop	ds		;ds:si -> mc table
		pop	es		;es = ds

		cmp	cx, MAXNUM_MCADDR
		jbe	MCsave
		mov	cx, MAXNUM_MCADDR
MCsave:
		lea	di, DGroup:MultiCast_Addresses
		mov	(Eth_MCastBuf ptr es:[di]).MCastAddrCount, cx
		jcxz	MC_SaveDone
;
; copy addresses from ds:si to es:di
;
		lea	di, (Eth_MCastBuf ptr es:[di]).MCastAddr
MC_SaveLoop:
		mov	eax, dword ptr [si]
		mov	dword ptr es:[di], eax
		mov	ax, word ptr [si+4]
		mov	word ptr es:[di+4], ax

		add	si, ADDR_LEN		; each unit is 16 bytes long
		add	di, ETH_ADDR_LEN
		loop	MC_SaveLoop
MC_SaveDone:
		pop	ds

;		mov	dx, PortCmdStatus
;		mov	ax, CMD_RXENABLE
;		out	dx, ax			;enable Rx

		lea	si, DGroup:MultiCast_Addresses
		mov	cx, (Eth_MCastBuf ptr [si]).MCastAddrCount
		lea	si, (Eth_MCastBuf ptr [si]).MCastAddr

		clc
		ret

NADMCastChange	endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90x\spdosegs.inc ===
; Modifications:   $Header: /Client Boot/NICS/3Com/3C90x/UNDI/SPDOSEGS.INC 1     17/07/98 5:08p Dmitry Klimenko $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;
;   Description: segment declaration and ordering for NDIS driver
;-----------------------------------------------------------------------
; Functional Description
;
;   This file defines the segments used by a MAC driver and the order
;   in which they are loaded. The groups DGROUP (for data) and CGROUP
;   (for code) are also defined, as are macros to open and close
;   segments (which also set up the default segment assumptions).
;-----------------------------------------------------------------------
; DOS segment definitions and ordering.
;==========================================================================
Ifdef DRV
DevHeaderSeg   segment para public USE16 'CODE'
DevHeaderSeg   ends
Endif	
;--------------------------------------------------------------------------
; Resident Code segment - code that is used after init time
; (unfortunately, this includes code to bind another driver, and
; initializations that take place at bind time) should be placed in this
; segment.
;--------------------------------------------------------------------------
_TEXT       segment para public USE16 'CODE'
_TEXT       ends

Ifdef DRV
ICODE       segment para public USE16 'INIT'
ICODE       ends
ENDIF	
;--------------------------------------------------------------------------
; Resident Data segment - things put here will remain in memory after
; init time. At the present time, this is in low memory, so data that is
; not used after init time should NOT be put in this segment.
;--------------------------------------------------------------------------
_DATA       segment para public USE16 'DATA'
_DATA       ends

Ifdef DRV
_BSS       segment para public USE16 'DATA'
_BSS       ends
IDATA       segment para public USE16 'DATA'
IDATA       ends
Else
_BSS       segment para public USE16 'BSS'
_BSS       ends
ENDIF
;--------------------------------------------------------------------------
; Make sure the segment order defined in this file is respected.
;--------------------------------------------------------------------------
.SEQ               
;--------------------------------------------------------------------------
; DOS Group is all one 64K segment, CS=SS=DS, use equate for DGROUP.
;--------------------------------------------------------------------------
Ifdef DRV
    CGROUP      group   DevHeaderSeg, _TEXT, ICODE
    DGROUP      group   _DATA, _BSS, IDATA
ELSE
    CGROUP      group   _TEXT
    DGROUP      group   _DATA, _BSS
ENDIF	
;--------------------------------------------------------------------------
; Group is 64K data, 64K code, CS!=SS=DS, actual group for Code.
;--------------------------------------------------------------------------
; Assume statement here takes care of for any source, same for OS2 and DOS.
;--------------------------------------------------------------------------
    Assume   CS:CGROUP, DS:DGROUP, ES:NOTHING, SS:NOTHING

START_CODE	macro
_TEXT		segment Public 'Code'
		assume ds:DGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_CODE	macro
_TEXT		ends
		endm

START_DATA	macro
_Data		segment Public 'Data'
		assume ds:DGroup,cs:CGroup,es:nothing,ss:nothing
		endm

END_DATA	macro
_Data		ends
		endm

; 2 macros by John to let you easily insert data fragments into code
;
; This macro assumes that Code is open, closes it, and opens data.
OPEN_DATA       macro
    END_CODE
    START_DATA
                endm

; This macro closes the open data and re-opens the Code segment.
CLOSE_DATA      macro
    END_DATA
    START_CODE
                endm


; EOF - $Workfile: SPDOSEGS.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90x\pci.inc ===
;************************************************
;*	PCI Config Space Header Register	*
;************************************************
PCI_VENDOR_ID_REG	EQU	0
PCI_DEVICE_ID_REG	EQU	2
PCI_COMMAND_REG		EQU	4
PCI_STATUS_REG		EQU	6
PCI_REV_ID_REG		EQU	8
PCI_CLASS_CODE_REG	EQU	9
PCI_HEADER_TYPE_REG	EQU	0EH
PCI_BASE_ADDR_REG	EQU	10H
PCI_ROM_BASE_ADDR	equ	30H

;*************************************
;*	PCI BIOS Function ID's	     *
;*************************************
PCI_FUNCTION_ID         EQU     0B1H
PCI_GET_BIOS	        EQU     01H
PCI_FIND_DEVICE     	EQU     02H
PCI_FIND_CLASS_CODE	EQU	03H
PCI_READ_CONFIG_BYTE	EQU	08H
PCI_READ_CONFIG_WORD	EQU	09H
PCI_READ_CONFIG_DWORD   EQU     0AH
PCI_WRITE_CONFIG_WORD	EQU	0CH
PCI_WRITE_CONFIG_DWORD	EQU	0DH
PCI_GET_INT_ROUTING	EQU     0EH
PCI_DEVICE_NOT_FOUND    EQU     86H
PCI_SUCCESSFUL          EQU     00H

;**********************************
;*	PCI Class Code Data	  *
;**********************************
NETWORK_ETHERNET	EQU	020000H
NETWORK_TOKEN_RING	EQU	020100H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90x\bw90xp.inc ===
; Routines in BW90XP.INC
;
; Modules included:
;	- Init_Vulcan2
; 	- SetInterruptVector
;	- init_vulcan_hw
;	- AutoSelect
;	- TryLinkBeat 
;	- TryLoopback
;	- SetupConnector 
;


;******************************************************************************
; Init_Vulcan2
;******************************************************************************
public	Init_Vulcan2
Init_Vulcan2	proc	near

;
; set up initial TxStart thresholds.
;
		mov	si, offset DGroup:PioTxStart

		public	init_txs_loop
init_txs_loop:
		mov	[si].txs_min, 0 	; Disable MinTxStart
;960408		max	ax, 16, dx

;960408 {
		; Replace "max	ax, 16, dx"
		cmp	ax, 16
		ja	init_txs_max

		mov	ax, 16
init_txs_max:	
;960408 }
		mov	[si].txs_value, ax
		add	ax, 2			; round
		shr	ax, 2			; then scale
		add	ax, CMD_SETTXSTART	; add command
		mov	[si].txs_thresh, ax	; for direct use
		mov	[si].txs_marker, 0D1CEh ; debug flag
		add	si, SIZE_TxStart	; next TxStart threshold
		cmp	si, offset DGroup:AfterTxStart
		jb	init_txs_loop		; around again
;
;------------------------------------------------------------------------------
; initialize Vulcan hardware, driver variables & tables
;

		call   init_vulcan_hw		; initialize Vulcan hardware
;960119       call   init_vt			; init variables and tables

;------------------------------------------------------------------------------
; enable int at 8259, turn on Ethernet Core Transciever and Receiver
;

mask_on_IRQ:

; setup initial TxStart & RxEarly Thresholds
; disable Tx and Rx Early Thresholds

;960403       port    CmdStatus
		mov	dx, PortCmdStatus

      ;mov    ax, CMD_SETRXEARLY+((1514+3) shr 2); early threshold = 0
		mov	ax, CMD_SETRXEARLY+RXEARLY_DISABLED
		mov	NormalRxEarly, ax	; will be adjusted later
		out	dx, ax

		mov	ax, CurTxStart
		out	dx, ax

; set rx filter
		mov	ax, CMD_SETRXFILTER+FILTER_INDIVIDUAL
		mov	HWFilter, ax		; save for SoftRxReset
		out	dx, ax

		mov	ax, CMD_SETINTMASK + BOOTWARE_INTS
		out	dx, ax

IFNDEF	UNDI
		; enable the transmitter
		mov     ah, CMDH_TXENABLE
		out     dx, ax

		; enable the receiver
		mov     ah, CMDH_RXENABLE
		out     dx, ax
ENDIF
		mov	ax, 0
		ret

Init_Vulcan2	endp



;******************************************************************************
;
;   SetInterruptVector: this routine determine the mask value for the selected
;			IRQ level and EOI values for both master and slave
;			8259s. We do not mask on the selected IRQ in this
;			routine, instead, it will be turned on and off as
;			initialization goes on.
;
;   On Entry:
;	      al = IRQ level
;	      cli
;
;   On Exit:
;
;******************************************************************************


SetInterruptVector proc near

;
;------------------------------------------------------------------------------
; determine the mask value for the selected IRQ level
;

       mov    cl, al				 ; al = IRQ level
       and    cl, 0f7h				 ; strip out IRQ on slave
       mov    ch, 1
       shl    ch, cl
       mov    IRQBit, ch			 ; IRQ bit postion (1), maskoff)
       not    ch				 ; all bits 1 except channel
       mov    IntMaskOnBit, ch			 ; Mask on bit position (0)

       mov    word ptr int_mask_port, MASTER_MASK_PORT
       cmp    al, 7
       jbe    SetIRQMaster
       mov    word ptr int_mask_port, SLAVE_MASK_PORT

SetIRQMaster:

;------------------------------------------------------------------------------
; determine EOI values for both master and slave 8259
;

       mov    al, IRQLevel
       cmp    al, 8				 ; IRQ on slave?
       jae    SetEOI				 ; yes

       mov    ah, al				 ;
       or     ah, 60h				 ; specific EOI to master 8259
       mov    al, 40h				 ; nop to slave to 8259
       jmp    short save_eoi

SetEOI:
       mov    ax, 6220h 			 ; non-specific EOI to slave
						 ; specific EOI to master 8259
save_eoi:
       mov    eoi_value, ax			 ; ah = EOI for master
						 ; al = EOI for slave
       ret

SetInterruptVector endp

;******************************************************************************
;   init_vulcan_hw:  this routine initializes most of vulcan hardware required
;		     to operate the adapter.  TxEnable and RxEnable will not
;		     be done in this routine
;
;   On Entry:
;	      adapter has been activated and window 0 is active.
;	      the following variables are valid and available:
;
;			1. IOBase
;			2. IRQLevel
;			5. NetAddress - ethernet addr of the adapter
;
;   On Exit:
;	      window 1 is active
;	      dx = port CmdStatus
;
;*****************************************************************************

init_vulcan_hw	   proc      near

	; for EISA board, cannot reset board.
		cmp	BusType, BUS_EISA
		jz	Init_SkipReset

;960403       port   CmdStatus
		mov	dx, PortCmdStatus
		xor	ax,ax			   ; global reset
		out	dx,ax

GlobalResetWait:
		in      ax, dx
		test    ah, STH_BUSY
		jnz	GlobalResetWait		   ; loop while busy

Init_SkipReset:
;
;------------------------------------------------------------------------------
; Setup Station Address.  the adapter's Ethernet Address has been read out of
; EEPROM, we need to program it into window 2, so Ethernet Core Receiver can
; receive packets properly.  the active window is 0, switch to window 2 first.
;

;960403       port   CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow	WNO_STATIONADDRESS

IFDEF	UNDI
		lea	si, DGroup:BoardID	;971030
ELSE
		lea	si, NetAddress
ENDIF
;960403       sub    dx, PORT_CmdStatus-PORT_SA0_1	 ; dx = port addr 5, 4
		mov	dx, PortSA0_1
		lodsw
		out	dx, ax

		add	dx, 2			; dx = port addr 3, 2
		lodsw
		out	dx, ax

		add	dx, 2			; dx = port addr 1, 0 = IO base
		lodsw
		out	dx, ax
;
; Initialize the mask registers to 0's, so we get only messages meant for us
;
		xor    ax,ax
		add    dx,2			; dx = station mask lo
		out    dx,ax
		add    dx,2			; dx = station mask mid
		out    dx,ax
		add    dx,2			; dx = station mask hi
		out    dx,ax
;
;----------------------------------------------------------------------------
; determine the connector to use.
;
; we set the default to EEProm InternalConfiguration.  Then we check
;	for auto-selection
;

;  Autoselect and ComputeSpeeds expect CLI.  force it.

		cli

		mov	ax, EEIntConfig1
		and	ax, ICH_XCVR_MASK
		shr	ax, ICH_XCVR_SHIFT
		mov	Xcvr, ax
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

;960403		port	InternalCfgH, CmdStatus
		mov	dx, PortInternalCfgH
		in	ax, dx
		test	ax, ICH_AUTOSELECT
		jz	not_auto_select
		mov	EEMiiPhySelect, -1
		call	AutoSelect		;if autoselect failed, Xcvr is
						;back to default
		cmp     Xcvr, XCVR_MII
		je      check_mii_speed

not_mii_connector:
;
;;980429, check link for single connector's adapter
;
		mov	LinkDetected, 0
		cmp     Xcvr, XCVR_100TX
		jz	test_100link
		cmp     Xcvr, XCVR_100FX
		jnz	not_100FX
test_100link:
		call	TryLinkbeat
		jc      fast_connector
		mov	LinkDetected, 1
		jmp     fast_connector

not_100FX:
		cmp	Xcvr, XCVR_10TP
		jnz	not_10TP
		call	TryLinkbeat
		jmp	short connector10

not_10TP:					;not 10TP, then 
		call	TryLoopback		;  either 10AUI or 10BNC
connector10:
		jc	slow_connector
		mov	LinkDetected, 1
		jmp	short slow_connector
;;
not_auto_select:
		cmp     Xcvr, XCVR_MII
		jne     not_mii_connector

                mov     forcemode, 100          ; force it to 100 Mb
                mov     ax, EEMiiPhySelect
                and     ax, 000fh               ; mask off all bits except 0 - 3
                cmp     ax, 1			;BASE100_T4; check EEPROM value
                je      forcing

                mov     forcemode, 10           ; force it to 10 Mb
                cmp     ax, 2			;BASE10_T; check EEPROM value
                je      forcing

                mov     forcemode, 100          ; since it doesn't match, force it
forcing:
		mov	dx, PortResetOptions
		in	ax, dx
		mov	bx, ax			; BX=ResetOptions

		mov     MIIPhyAddr, NWAY_PHY_ADDR
		test    bx, RO_MII
		jnz	forceMII
		test    bx, RO_BASET4
		jz      check_mii_speed
		mov     MIIPhyAddr, T4_Phy_ADDR
forceMII:
		call    TryMII
		jc      chk_mii_speed
		mov	LinkDetected, 0
	      	jmp	check_mii_speed

chk_mii_speed:
		mov	LinkDetected, 1
check_mii_speed:
		cmp     LineSpeed, 100
		je      fast_connector
		jmp     slow_connector

;
; determine link speed from connector.	also set BytesPerTick to 4 for 10Mbps
; operation (3.2us ticks=4 x 800ns) and 40 for 100Mbps operation (40 x 80ns).
;
fast_connector:
		mov	LineSpeed, 100		; Mbps
;960119		mov	BytesPerTick, 40
		jmp	short InitMediaAuto

;		cmp	Xcvr, XCVR_100TX
;		je	InitMediaAuto

;		cmp	Xcvr, XCVR_100FX
;		je	InitMediaAuto

;		cmp	Xcvr, XCVR_MII
;		je	InitMediaAuto

slow_connector:
		mov	LineSpeed, 10		; Mbps
;960119		mov	BytesPerTick, 4

InitMediaAuto:
;
; determine some tuning parameters
;
;  first make sure the internal DC DC converter is disabled
;

;960403       port    CmdStatus
		mov	dx, PortCmdStatus
		mov     ah, CMDH_STOPINTXCVR
		out     dx, ax		       ; issue command
;
; now give the transceiver 3ms to stabilize before we enable transmit or
; receive traffic thru it.
;
		mov	cx, Delay3ms
		call	WaitTime

; set up the connector (possibly for the second time)

		call    SetupConnector

;960403       port    CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO
;960403       port    RxFree, CmdStatus
		mov	dx, PortRxFree
		in      ax, dx
;960403       port    CmdStatus, RxFree
		mov	dx, PortCmdStatus

		SelectWindow	WNO_OPERATING		 ;

		mov    ax, CMD_SETRZMASK+MASK_NONE	 ; enable all interrupts for Rev. 1
		out    dx, ax

		ret

init_vulcan_hw	endp


;------ AutoSelect ----------------------------------------------------------;
;									     ;
;	This routine attempts to auto-select the connector.  It should be    ;
;	called only if the autoselect bit is set.  If it fails, it will      ;
;	leave the current connector in InternalConfig set.		     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Station Address has been set up on adapter.			     ;
;	Xcvr set to the connector to use if AutoSelect fails (this should    ;
;	    be read from the EEProm, NOT from InternalConfig)		     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	Delay25ms set up for a 50ms delay.				     ;
;	MediaEnable table defined.					     ;
;	Specific.mc_caddr set up with the station address.		     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	MediaStatus, MacControl, InternalConfig set up for connector chosen. ;
;	DC-DC converter stopped/started as required.			     ;
;	TxFIFO/RxFIFO reset and disabled.				     ;
;	RZMask/IntMask disabled (0).					     ;
;	NetDiag modified for no loopback.				     ;
;	No interrupts pending.						     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

AutoSelect	proc	near
		pusha
;
; set the IntMask and RZMask not to allow any interrupts through
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		mov	ax, CMD_SETINTMASK + 0
		out	dx, ax
		mov	ax, CMD_SETRZMASK + 0
		out	dx, ax
;
; save the default connector
;
		mov	bp, Xcvr		; save original Xcvr value
;
; determine what connectors are available
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

;960403		port	ResetOptions, CmdStatus
		mov	dx, PortResetOptions
		in	ax, dx
		mov	bx, ax			; BX=ResetOptions
;
; if 100TX connector is available, try that.  we do 100Mbps first to avoid
; generating any 10Mbps traffic on a hub that might be autosensing and might
; switch to 10Mbps to match us.
;
; note: sending 100Mbps stuff on a 10TP connection will generally partition
;	us.  we'll need to clear this up before we're done.
;
		public	auto_try_100tx
auto_try_100TX:
		test	bx, RO_BASETX
		jz	auto_try_MII

		mov	Xcvr, XCVR_100TX
		call	TryLinkbeat
		jnc	auto_exit
		mov	LinkDetected, 0
;
; if MII is available, try that
;
		public	auto_try_MII
auto_try_MII:
		mov     MIIPhyAddr, NWAY_PHY_ADDR
		test    bx, RO_MII
		jnz	try_MII
		test    bx, RO_BASET4
		jz      auto_try_10TP
		mov     MIIPhyAddr, T4_Phy_ADDR
try_MII:
		mov	Xcvr, XCVR_MII
		mov	forcemode,0
		call	TryMII
		jc	auto_exit
		mov	LinkDetected, 0
;
; if 10TP connector is available, try that
;
		public	auto_try_10TP
auto_try_10TP:
		test	bx, RO_TP
		jz	auto_try_aui

		mov	Xcvr, XCVR_10TP
		call	TryLinkbeat
		jnc	auto_exit
		mov	LinkDetected, 0
;
; if 10AUI connector is available, try that
;
		public	auto_try_aui
auto_try_aui:
		test	bx, RO_AUI
		jz	auto_try_bnc

		mov	Xcvr, XCVR_10AUI
		call	TryLoopback
		jnc	auto_exit
		mov	LinkDetected, 0
;
; if 10BNC connector is available, try that
;
		public	auto_try_bnc
auto_try_bnc:
		test	bx, RO_COAX
		jz	auto_fail

		mov	Xcvr, XCVR_10BNC
		call	TryLoopback
		jnc	auto_exit
		mov	LinkDetected, 0
;
; nothing worked.  just switch back to the default connector
;
		public	auto_fail
auto_fail:
		mov	Xcvr, bp
		call	SetupConnector
		jmp	autox
;
; done.  leave.
;
		public	auto_exit
auto_exit:
		mov	LinkDetected, 1
autox:
		popa
		ret
AutoSelect	endp


;------ TryLinkBeat ---------------------------------------------------------;
;									     ;
;	This routine sets up the adapter to use one of the linkbeat-capable  ;
;	connectors: 10TP or 100TX.  Since the port might be partitioned by   ;
;	the hub (a previous attempt at an incorrect speed might cause this   ;
;	for example), we send a packet first to clear this up.	Then we      ;
;	look for linkbeat.						     ;
;									     ;
;	This routine is part of the auto-select logic and is called by	     ;
;	AutoSelect to do its work.					     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Xcvr set to the connector to set up.				     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	Delay25ms set up for a 50ms delay.				     ;
;	MediaEnable table defined.					     ;
;	Specific.mc_caddr set up with the station address.		     ;
;	no interrupts pending.						     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	clc if we get linkbeat, the connector seems fine.  stc if not.	     ;
;	DC-DC converted started/stopped.				     ;
;	MediaStatus set up.						     ;
;	MacControl set up.						     ;
;	InternalConfig set up.						     ;
;	Rx/TxFIFO's reset and disabled.                                      ;
;	NetDiag modified for no loopback.				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	TryLinkbeat
TryLinkbeat	proc	near
		pusha
;
; go quiet for 1.5 seconds to get any N-Way hub into a receptive state to
; sense the new speed.  we go quiet by switching to the 10BaseT connector
; with no linkbeat
;
		call    QuietConnector

		mov     cx, 30		  ; 30 x 1/20th = 1.5 sec
tlb_qloop:
		push	cx
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime		; assume cx preserved
		pop	cx
		loop    tlb_qloop

;
; set up the connector
;
		call	SetupConnector
;
; enable statistics
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
;960403		StatsEnable
;
; give settling time. Run WaitTime twice to get enough delay
;
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime		; assume cx preserved

;
; zero the Bad SSD Count stat
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS
;960403		port	BadSsdCount, CmdStatus
		mov	dx, PortBadSsdCount
		in	al,dx
;
; we might be partitioned.  some hubs won't clear the partition until we
; send a packet.  so send one.	the good news is that if we are partitioned
; then there is no receive traffic incoming so we don't have to wait that
; long for backoffs or retries.
;
; set up a 14-byte packet to send.  ourselves as the destination.
;
;960403		port	TxFIFO
		mov	dx, PortTxFIFO

		mov	ax, 14			; preamble
		out	dx, ax
		xor	ax, ax
		out	dx, ax

IFDEF	UNDI
		lea	si, DGroup:BoardID	;971030
ELSE
		lea	si, NetAddress
ENDIF
		mov	cx, 6
		rep outsb			    ; destination address
		mov	cx, 6
		sub	si, 6
		rep outsb			    ; source address

		xor	ax, ax			; IEEE length=0
		out	dx, ax
		out	dx, ax			; pad to 16 bytes
;
; enable transmission.
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus

		; enable the Tx
		mov     ah, CMDH_TXENABLE
		out     dx, ax

;
; wait 1/4 second for the linkbeat detect logic at 10Mbps, and 1.25sec (!)
; for the linkbeat detect logic at 100Mbps (MII spec).
;
		mov	cx, 5			; 5 x 1/20th = 1/4 sec
		cmp	Xcvr, XCVR_100TX
		jne	Delay100TX
		mov	cx, 25			; 25 x 1/20th = 1.25 sec
Delay100TX:

tlb_loop:
		push	cx
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime
		pop	cx

		loop	tlb_loop
;
; check for linkbeat
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS

;960403		port	MediaStatus, CmdStatus
		mov	dx, PortMediaStatus
		in	ax, dx			; AX=MediaStatus
		test	ax, MEDIA_LBEAT 	; got linkbeat?
		jnz     tlb_gotlink
;
; no linkbeat.	connector probably not connected to a network.
;
		public	tlb_bad
tlb_bad:
		stc
		jmp	short tlb_exit
;
; got linkbeat.  if we're testing 10BaseT, that's good enough.
;
		public  tlb_gotlink
tlb_gotlink:
		cmp     Xcvr, XCVR_10TP
		je      tlb_good_10
;
; with 100BaseTX the problem is that 10Mbps traffic makes the 100Mbps link beat
; indication go on.  so we need to do some sanity checking of the result.  we
; want to loop around for a while looking for linkbeat to go off (there was
; a long enough gap in the 10Mbps traffic) or a packet to be received (if good,
; then its a real 100Mbps network).  we also sample carrier during this loop.
; if we see carrier enough of the time during the loop, then we should have
; received a packet.  if not, its just 10Mbps traffic giving us a false linkbeat.
; this is acceptable only because this loop runs for a very long time relative
; to the wire.  on current PCI systems with a single I/O taking around 600ns,
; this loop run run around 1/16th of a second.  this is long enough for 150
; max size 4500 byte packets plus 333 additional slot times for backoff.  this
; seems a reasonable period to require a packet to show up if we have carrier.
; the only exposure here is if some future system has massively faster single
; I/O cycles, which doesn't seem too worrisome.
;
;		port    CmdStatus
		mov	dx, PortCmdStatus
		mov     ax, CMD_SETRXFILTER + FILTER_PROMISCUOUS
		out     dx, ax
;		RxEnable
		; enable the receiver
		mov     ah, CMDH_RXENABLE
		out     dx, ax

		xor     bx, bx		  ; BX=# CRS's seen=0
		mov     cx, 0FFFFh	      ; CX=# loops to do
tlb_outer:
;		port    RxStatus
		mov	dx, PortRxStatus
		in      ax, dx
		test    ax, RXS_INCOMPLETE      ; got a packet?
		jnz	nopkg			; ...nope
		test    ax, RXS_ERROR		; any errors?
		jz      tlb_good		; ...no errors, must be 100Mbps

;		port    RxStatus, CmdStatus
		mov	dx, PortRxStatus
nopkg:
;		port    MediaStatus, RxStatus
		mov	dx, PortMediaStatus
		in      ax, dx

		test    ax, MEDIA_LBEAT		; still got linkbeat?
		jz      tlb_bad			; nope--bad link

		test    ax, MEDIA_CRS		; count CRS's seen
		jz      crss
		inc     bx			; ++BX = # of CRS's seen
crss:
		loop    tlb_outer
;
; fell out of loop.  linkbeat the whole time.  no good packets received.  if
; carrier sense was on a lot of the time, then we should have got a packet.
; if not, its a false reading.
;
		cmp     bx, 4000h		; CRS on 1/4 of the time?
		jae     tlb_bad			; if so, false reading
;
; connector good.  return carry clear.
;
tlb_good:
tlb_good_10:
		clc
;
; return current carry flag setting after disabling.
;
		public	tlb_exit
tlb_exit:
		pushf

;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		call	TxReset
		call	RxReset

		popf
		popa
		ret
TryLinkbeat	endp


;------ QuietConnector ------------------------------------------------------;
;
;       This routine shuts down all output from the adapter.  It does this
;       by selecting the 10BaseT connector and disabling linkbeat.
;
;       Entry:
;       cli
;       DelayXcvr set for 3ms delay.
;
;       Exit:
;       cli
;       DC-DC stopped.
;       InternalConfig set to use 10BaseT.
;       MediaStatus set to linkbeat disabled.
;       Rx/TxFIFO's reset and disabled.
;
;       All registers preserved.
;
;----------------------------------------------------------------------------;

		public  QuietConnector
QuietConnector  proc    near
		pusha
;
; set up the InternalConfig for 10BaseT
;
;		port    CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO
;		port    InternalCfgH, CmdStatus
		mov	dx, PortInternalCfgH
		in      ax, dx
		and     ax, NOT ICH_XCVR_MASK
		or      ax, XCVR_10TP SHL ICH_XCVR_SHIFT
		out     dx, ax
;
; in MediaStatus, disable linkbeat generation
;
;		port    CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS

;		port    MediaStatus, CmdStatus
		mov	dx, PortMediaStatus
		in      ax, dx		  ; AX=media status
		and     ax, NOT (MEDIA_LBEATENABLE)
		out     dx, ax		  ; write it back
;
; reset the Tx/RxFIFO's
;
;		port    CmdStatus
		mov	dx, PortCmdStatus
		call	TxReset
		call	RxReset

		popa
		ret

QuietConnector  endp


;------ TryLoopback ---------------------------------------------------------;
;									     ;
;	This routine sets up the adapter to use one of the		     ;
;	non-linkbeat-capable connectors: 10BNC or 10AUI.  For these	     ;
;	connectors we enable external loopback and transmit a packet to      ;
;	ourselves.  If we receive it (or any other packet without errors)    ;
;	the connector works.						     ;
;									     ;
;	This routine is part of the auto-select logic and is called by	     ;
;	AutoSelect to do its work.					     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Xcvr set to the connector to set up.				     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	Delay25ms set up for a 50ms delay.				     ;
;	MediaEnable table defined.					     ;
;	Specific.mc_caddr set up with the station address.		     ;
;	no interrupts pending.						     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	clc if we get linkbeat, the connector seems fine.  stc if not.	     ;
;	DC-DC converted started/stopped.				     ;
;	MediaStatus set up.						     ;
;	MacControl set up.						     ;
;	InternalConfig set up.						     ;
;	Rx/TxFIFO's reset and disabled.                                      ;
;	NetDiag modified for no loopback.				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	TryLoopback
TryLoopback	proc	near
		pusha
;
; set up the connector
;
		call	SetupConnector
;
; enable external loopback so that we can see our own packets
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS
;960403		port	NetDiagnostic, CmdStatus
		mov	dx, PortNetDiag
		in	ax, dx
		and	ax, NETD_NOLOOPBACK_MASK
		or	ax, NETD_EXTLOOPBACK
		out	dx, ax
;
; up to three times (we might get collisions) try to loop a packet thru
;
		mov	bp, 3			; outer loop count

		public	tlp_loop
tlp_loop:
;
; reset both transmitter and receiver, enable both and set up our packet
; filter to receive anything
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		call	TxReset
;960403		TxEnable
		; enable the transmitter
		mov     ah, CMDH_TXENABLE
		out     dx, ax

		call	RxReset

		; enable the receiver
		mov     ah, CMDH_RXENABLE
		out     dx, ax

		mov	ax, CMD_SETRXFILTER + FILTER_PROMISCUOUS
		out	dx, ax
;
; send a 14-byte packet to ourselves.
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING
;960403		port	TxFIFO
		mov	dx, PortTxFIFO

		mov	ax, 14			; preamble
		out	dx, ax
		xor	ax, ax
		out	dx, ax

IFDEF	UNDI
		lea	si, DGroup:BoardID	;971030
ELSE
		lea	si, NetAddress
ENDIF
		mov	cx, 6
	    rep outsb				; destination address
		mov	cx, 6
		sub	si, 6
	    rep outsb				; source address

		xor	ax, ax			; IEEE length=0
		out	dx, ax
		out	dx, ax			; pad to 16 bytes
;
; wait for the packet to show up in RxStatus.  give it up to 1/4 second.
;
		mov	cx, 5			; 5 x 1/20th = 1/4 second
tlp_rxloop:
;960403		port	RxStatus
		mov	dx, PortRxStatus
		in	ax, dx
		test	ax, RXS_INCOMPLETE
		jz	tlp_rxcomplete

		push	cx			; 950511
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime
		pop	cx			; 950511

		loop	tlp_rxloop
;
; no complete packets received.  try again.
;
		public	tlp_rxfail
tlp_rxfail:
		dec	bp
;960402		djnz	tlp_loop
		jnz	tlp_loop
		jmp	tlp_bad
;
; a complete RxStatus.	check for any errors.
;
		public	tlp_rxcomplete
tlp_rxcomplete:
		test	ax, RXS_ERROR
		jnz	tlp_rxfail
;
; got a good receive packet.  connector seems good.
;
		public	tlp_good
tlp_good:
		clc
		jmp	short tlp_exit
;
; no packets received.	connector probably not connected to a network.
;
		public	tlp_bad
tlp_bad:
		stc
;
; return current carry flag setting after disabling/resetting.
;
		public	tlp_exit
tlp_exit:
		pushf

;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS
;960403		port	NetDiagnostic, CmdStatus
		mov	dx, PortNetDiag
		in	ax, dx
		and	ax, NETD_NOLOOPBACK_MASK
		out	dx, ax			; disable any loopback modes
;960403		port	CmdStatus
		mov	dx, PortCmdStatus

		call	TxReset
		call	RxReset

		popf
		popa
		ret
TryLoopback	endp


;------ SetupConnector ------------------------------------------------------;
;									     ;
;	This routine sets up the adapter to use the specified connector.     ;
;	It sets up the connector in InternalConfig, sets bits in MacControl  ;
;	and MediaStatus as appropriate, and starts/stops the DC-DC converter ;
;	as required.							     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Xcvr set to the connector to set up.				     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	MediaEnable table defined.					     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	DC-DC converted started/stopped.				     ;
;	MediaStatus set up.						     ;
;	MacControl set up.						     ;
;	InternalConfig set up.						     ;
;	Rx/TxFIFO's reset and disabled.                                      ;
;	NetDiag modified for no loopback.				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	SetupConnector
SetupConnector	proc	near
		pusha
;
; disable any loopback modes in effect
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS
;960403		port	NetDiagnostic, CmdStatus
		mov	dx, PortNetDiag
		in	ax, dx
		and	ax, NETD_NOLOOPBACK_MASK
		out	dx, ax
;
; set up the connector in InternalConfig
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO
;960403		port	InternalCfgH, CmdStatus
		mov	dx, PortInternalCfgH
		in	ax, dx
		and	ax, NOT ICH_XCVR_MASK
		mov	cx, Xcvr
		shl	cx, ICH_XCVR_SHIFT
		or	ax, cx
		out	dx, ax
;
; if full-duplex operation is specified, go enable it.	disable all the weird
; stuff for now.
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

;960403		port	MacControl, CmdStatus
		mov	dx, PortMacControl
		in	ax, dx
		and	ax, NOT MACC_FULLDUPLEX ; not full duplex
		and	ax, NOT MACC_ALLOWLARGE ; no large packets
		and	ax, NOT MACC_DEFEREXTEND ; normal 802.3 deferrence
;;;;;;
		cmp     Xcvr, XCVR_MII
		jne     check_duplex   ; if it not an MII connector, check the software info
			      ; to decide to enable full-duplex or not

; if we are using MII connector, then check are we in autoselect mode. If we are
; useing autoselect, then do not use the the SW_FULLDUPLEX bit to set duplex mode,
; read the auto-negoation result to set the duplex mode.

		cmp    EEMiiPhySelect, -1
		jne     check_duplex

		test    MiiPhyUsed, MII_100BASEX_FD + MII_10BASET_FD
		jnz     set_full_duplex
		jmp     nset_full_duplex

; Cehck the SW_FULLDUPLEX bit, when we are using the Force mode with MII connector
; and when the non-MII connector being used.

check_duplex:
		test	EESoftConfigInfo, SW_FULLDUPLEX
		jz	ConnectDuplex

set_full_duplex:
		or	ax, MACC_FULLDUPLEX

nset_full_duplex:
ConnectDuplex:
		out	dx, ax
;
; setup various bits in MediaStatus (jabber, linkbeat, sqe) as appropriate
; for the connector.  the user can force linkbeat off if desired at 10Mbps.
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS

;960403		port	MediaStatus, CmdStatus
		mov	dx, PortMediaStatus
		in	ax, dx			; AX=media status
		and	ax, NOT MEDIA_XCVRBITS	; mask bits off first
		mov	bx, Xcvr		; transceiver type
		shl	bx, 1			; use as index into table
		or	ax, MediaEnable[bx]	; on bits appropriate to xcvr

		test	EESoftConfigInfo, SW_LINKBEAT	; if set, don't enable linkbeat
		jz	ConnectLinkBeat
		cmp	Xcvr, XCVR_10TP 	; but only for 10TP
		jne	ConnectLinkBeat
		and	ax, NOT (MEDIA_LBEATENABLE)
ConnectLinkBeat:
		out	dx, ax			; write it back
;
; if configured for 10Base2 we must start the internal transceiver.  if not
; we stop it (just in case the configuration has changed and we haven't cold
; booted).
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		mov	ah, CMDH_STARTINTXCVR	; if BNC, start
		cmp	Xcvr, XCVR_10BNC
		je	ConnectXcvr
		mov	ah, CMDH_STOPINTXCVR	; else, stop
ConnectXcvr:	out	dx, ax			; issue command
;
; now give the transceiver 3ms to stabilize before we enable transmit or
; receive traffic thru it.
;
		mov	cx, Delay3ms
		call	WaitTime

;
; reset the Tx/RxFIFO's
;
;960403		port	CmdStatus
		mov	dx, PortCmdStatus
		call	TxReset
		call	RxReset

		popa
		ret
SetupConnector	endp


;------ TryMII --------------------------------------------------------------;
;
;	Auto negotiates the speed and duplex with link partner.
;
;	Entry:
;	none
;
;	Exit:
;	Carry bit set: found MII
;	Carry bit clear: MII test failed
;	zf = 0	hardware failure
;	zf = 1	recoverable failure
;----------------------------------------------------------------------------;

		public	TryMII
TryMII		proc	near
		pusha
;
; First, to detect if there is anything connected to the MII
;
;		mov	auto_negotiated, 0	    ; clear auto negotiated flag
		call	FindMIIPhy
		jnz	tm01
		jmp	tm_fail_hw

tm01:
;
; The MII Phy exists. Reset it.
; DX has the offset of control reg. AX return the value of control reg.
;
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	tm02
		jmp	tm_fail_hw

tm02:
		or	ax, MII_CTL_RESET
		call	WriteMIIPhy

		mov	cx, 10
tm_loop1:
		push	cx
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		pop	cx
		jc	tm03
		jmp	tm_fail_hw

tm03:
		test	ax, MII_CTL_RESET
		jz	mii_reset_done

		call	Delay200ms			 ; delay 200 ms
		loop	tm_loop1
		jmp	tm_fail_hw

mii_reset_done:
; Force mode is used when autoselect is not enabled and we have to read the
; EEPROM.
		cmp	forcemode, 0
		je	not_force_mode
		jmp	force_the_speed

not_force_mode:
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	tm04
		jmp	tm_fail_hw

tm04:
		mov	cx, ax			; cx <= control reg.
;
; now we can read the status and try to figure out what's out there.
;
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm05
		jmp	tm_fail_hw

tm05:
;
; bit 15 = 100BaseT4,
; bit 14 = 100BaseTX (full duplex),
; bit 13 = 100BaseTX (half duplex),
; bit 12 = 10BaseT (full duplex),
; bit 11 = 10BaseT (half duplex)
;
		test	ax, MII_STS_100MB_MASK+MII_STS_10MB_MASK
		jnz	handle_both
		jmp	tm_fail_hw		; sanity check

handle_both:
;
; if MII does not have extended registers, we have no way to tell
; what the link speed is after the completion of auto negotiation.
; (no ANLPAR register, no PAR regiater)
;
		test	ax, MII_STS_EXTENDED
		jnz	tm06
		jmp	no_auto_nego

tm06:
;
; see if it is capable of auto negotiation
;
		test	ax, MII_STS_AUTO
		jnz	tm07
		jmp	no_auto_nego

tm07:
;
; it is capable of auto negotiation, see if it has been done already.
; if not, re-initialize autoselect. otherwise, accept the results.
;
; special hack for National part.  We know we are NWAY capable
; and we are not the Broadcom T4 part which is not NWAY capable
		push	cx
		push	ax
		mov	dx, MII_PHY_PCR
		call	ReadMIIPhy
		jc	force_link_disc
		jmp	tm_fail_hw

force_link_disc:
		or	ax, 0020h			; set bit 5 = 1, force
							; disconnect to bypass
		mov	dx, MII_PHY_PCR
		call	WriteMIIPhy
		pop	ax
		pop	cx

		test	cx, MII_CTL_ENABLE_AUTO
		jz	auto_not_enabled

		test	ax, MII_STS_AUTO_DONE
		jz	auto_not_enabled
		jmp	auto_nego_done

auto_not_enabled:
		mov	ax, cx			; AX <= control reg.
		or	ax, MII_CTL_START_AUTO
		or	ax, MII_CTL_ENABLE_AUTO
		mov	dx, MII_PHY_CONTROL
		call	WriteMIIPhy

		mov	cx, 10
tm_loop2:
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm08
		jmp	tm_fail_hw

tm08:
		test	ax, MII_STS_AUTO_DONE
		jnz	auto_nego_done

		call	Delay200ms			 ; delay 200 ms
		loop	tm_loop2
;
; pending: if MII_STS_AUTO_DONE never set in status reg. so just get out
;
		jmp	tm_fail

auto_nego_done:

; check link status.  Since it is a latch function, read status register again.
;		mov	mii_mode, 0
;		mov	auto_negotiated, 1
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		jc	tm09
		jmp	tm_fail_hw

tm09:
		test	ax, MII_STS_LINK_UP
		jnz	tm10
		jmp	tm_fail

tm10:
		mov	dx, MII_PHY_ANLPAR
		call	ReadMIIPhy
		jnc	tm_fail_hw

		mov	phyANLPAR, ax

		mov	dx, MII_PHY_ANAR
		call	ReadMIIPhy
		jnc	tm_fail_hw

		mov	phyANAR, ax

		mov	bx, phyANLPAR		; link partner's abilities
		test	bx, 03e0h		; bits 9 - 5 set?
		jz	nway_patch		; nope, go to NWAY patch for National part

		mov	ax, phyANAR		; my abilities
		test	bx, MII_ANLPAR_100BASET4 + MII_ANLPAR_100BASEX_FD + MII_ANLPAR_100BASEX_HD
		jz	tm11

		test	ax, MII_ANLPAR_100BASET4 + MII_ANLPAR_100BASEX_FD + MII_ANLPAR_100BASEX_HD
		jnz	auto_nego_must_be_100

tm11:
		and	ax, MII_ANLPAR_10BASET_FD + MII_ANLPAR_10BASET_HD
		and	bx, MII_ANLPAR_10BASET_FD + MII_ANLPAR_10BASET_HD
		test	ax, bx
		jnz	auto_nego_must_be_10
		jmp	tm_fail 		; just get out

auto_nego_must_be_100:
;		mov	full_duplex, 1		; it is full duplex
		test	ax, MII_ANLPAR_100BASEX_FD
		jz	tm12

		test	bx, MII_ANLPAR_100BASEX_FD
		jnz	must_be_100mb

tm12:
;		mov	full_duplex, 0		; half duplex
		jmp	must_be_100mb

auto_nego_must_be_10:
;		mov	full_duplex, 1
		test	ax, MII_ANLPAR_10BASET_FD
		jz	tm13

		test	bx, MII_ANLPAR_10BASET_FD
		jnz	must_be_10mb

tm13:
;		mov	full_duplex, 0
		jmp	must_be_10mb

;
; PATCH for National n-way chip problem.
; Should read the ANLPAR reg. and ANAR reg. to determine the link used.
; See P010.C, a workaround solution is to read PAR reg. instead.
;
nway_patch:
;		mov	full_duplex, 0		; since link partner not NWAY default to half duplex
		mov	dx, MII_PHY_PAR
		call	ReadMIIPhy
		jc	tm14
		jmp	tm_fail

tm14:
		test	ax, 0040h		; SPEED_10 = bit 6
		jnz	must_be_10mb
;
; *** end of PATCH
;
must_be_100mb:
		mov	LineSpeed, 100
		stc				; return success
		jmp	tm_exit

must_be_10mb:
		mov	LineSpeed, 10
		stc				; return success
		jmp	tm_exit

;
; auto negotiation didn't work.
;
no_auto_nego:
;		mov	auto_negotiated, 0	; didn't auto negotiate
;
; need to read the MIIPhyOui and MIIPhyModel reg. to check if a Broadcom part
; AX = status reg. CX = control reg.
;
		push	ax
		push	cx
		mov	dx, MII_PHY_OUI
		call	ReadMIIPhy
		mov	MIIPhyOui, ax
		jc	tm15
		pop	cx
		pop	ax
		jmp	tm_fail_hw

tm15:
		mov	dx, MII_PHY_MODEL
		call	ReadMIIPhy
		mov	MIIPhyModel, ax
		pop	cx
		pop	ax
		jc	tm16
		jmp	tm_fail_hw		; just get out

; It might be a Broadcom part that only supports T4
tm16:
		cmp	MIIPhyOui, 03e0h
		je	tm17
		jmp	tm_fail_hw		; just get out

tm17:
		cmp	MIIPhyModel, 0
		je	tm18
		jmp	tm_fail_hw

tm18:
; need to set some flags for bug fixes for Broadcom T4 part.
		mov	broadcom, 1			; do broadcom fix
		push	ax
		push	cx
		test	cx, MII_CTL_ENABLE_AUTO ; here it is auto-selection
						; not auto-negotiation
		jz	bcm_auto_not_enabled

		test	ax, MII_STS_AUTO_DONE
		jz	bcm_auto_not_enabled
		jmp	bcm_auto_done

bcm_auto_not_enabled:
		mov	ax, cx
		or	ax, MII_CTL_ENABLE_AUTO ; enable auto selection
		and	ax, NOT MII_CTL_FULL_DUPLEX
;		test	SWConfig, SW_FULLDUPLEX
;		jz	@F
;
;		or	ax, MII_CTL_FULL_DUPLEX
;@@:
		mov	dx, MII_PHY_CONTROL
		call	WriteMIIPhy

bcm_auto_done:
		pop	cx
		pop	ax

; check link status.  Since it is a latch function, read status register again.
		mov	cx, 10

link_status_loop:
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm19
		jmp	tm_fail_hw

tm19:
		test	ax, MII_STS_LINK_UP
		jnz	read_ext_reg

		call	Delay200ms

		loop	link_status_loop
		jmp	tm_fail

;
; read address reg. 10h
;
read_ext_reg:
		mov	dx, MII_EXT_REG0
		call	ReadMIIPhy		; read extended reg. 0 to get speed
		jc	tm20
		jmp	tm_fail_hw

tm20:
		test	ax, MII_EXT_SPEED	; speed is (1=100, 0=10)
		jnz	tm21
		jmp	must_be_10mb

tm21:
		jmp	must_be_100mb

;
; Force the speed to whatever was set in the EEPROM
;
force_the_speed:
		mov	broadcom, 0
		mov	dx, MII_PHY_OUI
		call	ReadMIIPhy
		mov	MIIPhyOui, ax
		jc	tm22
		jmp	tm_fail_hw

tm22:
		 mov	 dx, MII_PHY_MODEL
		 call	 ReadMIIPhy
		 mov	MIIPhyModel, ax
		 jc	 tm23
		 jmp	 tm_fail_hw		 ; just get out

; It might be a Broadcom part that only supports T4
tm23:
		mov	broadcom, 1		; this is a broadcom part
		cmp	MIIPhyOui, 03e0h
		je	tm24

tm24:
		cmp	MIIPhyModel, 0
		je	tm25

		mov	broadcom, 0		; not a broadcom
; special hack for National part.
		mov	dx, MII_PHY_PCR 	; yes, do National fix
		call	ReadMIIPhy
		jc	forcemode_link_disc
		jmp	tm_fail_hw

forcemode_link_disc:
		or	ax, 0020h			; set bit 5 = 1, force
							; disconnect to bypass
		mov	dx, MII_PHY_PCR
		call	WriteMIIPhy

tm25:
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jnc	tm_fail_hw

		mov	cx, ax
; determine duplex
;
set_duplex:
		and	ax, NOT MII_CTL_FULL_DUPLEX	; half duplex
;		test	SWConfig, SW_FULLDUPLEX
;		jz	@F
;
;		or	ax, MII_CTL_FULL_DUPLEX 	; full duplex
;@@:
		and	ax, not MII_CTL_ENABLE_AUTO	; disable auto negotiation
		or	ax, MII_CTL_100MB		; select 100Mb
		mov	LineSpeed, 100
		cmp	forcemode, 100			; am I forcing to 100?
		je	tm26				; yes

		and	ax, not MII_CTL_100MB		; select 10 MB
		mov	LineSpeed, 10
tm26:
		mov	dx, MII_PHY_CONTROL
		call	WriteMIIPhy

		push	cx

; check link status.  Since it is a latch function, read status register again.
		mov	cx, 10
link_stat_loop:
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm27
		pop	cx
		jmp	tm_fail_hw

tm27:
		test	ax, MII_STS_LINK_UP
		jnz	linkup

		call	Delay200ms
		loop	link_stat_loop
		pop	cx
		jmp	tm_fail

linkup:
		pop	cx
; workaround for T4 bug
		cmp	broadcom, 1
		je	tm28

;nway_bug_fix:
		test	cx, 2000h			; if previous speed=100
		jnz	tm28				; don't reset

		cmp	LineSpeed, 100			; prev. speed = 10, check current speed
		jne	tm28

		mov	dx, MII_CTL_RESET		; current speed = 100,
		call	WriteMiiPhy			; need to reset
tm28:
;		mov	mii_mode, 03h			; forced by user
		stc
		jmp	short tm_exit

tm_fail_hw:
;		mov	mii_mode, 0ffh
		or	ax, 1				; zf = 0
		clc					; cf = 0
		jmp	short tm_exit

tm_fail:
;		mov	mii_mode, 0ffh
		xor	ax, ax				; zf = 1
		clc					; cf = 0
tm_exit:
		popa
		ret

TryMII		endp

			
;------ FindMIIPhy ----------------------------------------------------------;
;        
;       Exit:
;       ZF set: not found
;       ZF clear: found
;----------------------------------------------------------------------------;

                public  FindMIIPhy
FindMIIPhy      proc    near
                pusha
;                port    CmdStatus
		mov	dx, PortCmdStatus
                SelectWindow    WNO_DIAGNOSTICS
;                port    SlingshotStatus, CmdStatus      ; dx: mii port
		mov	dx, PortPhyMgmt
;
; drop everything, so we are not driving the data, and run the clock
; through 32 cycles in case the PHY is trying to tell us something. Then
; read the data line, since the PHY's pull-up will read as a 1 if it's
; present.
;
                xor     ax, ax
                out     dx, ax

                mov     cx, 32
fmp_loop:
                call	Delay500ns
                mov     ax, MGMT_PHY_CLOCK
                out     dx, ax
                call	Delay500ns
                xor     ax, ax
                out     dx, ax
                loop    fmp_loop

                in      ax, dx
                test    ax, MGMT_PHY_DATA1

                popa
                ret
FindMIIPhy      endp


;------ SendOneBitToMII --------------------------------------------------------;
;
; send one bit out on MDIO.
;
; On Entry:
;     bit 0 in AX - the bit to be sent.
;
; On Exit:
;     none
;----------------------------------------------------------------------------;

                public  SendOneBitToMII
SendOneBitToMII proc    near

                or      ax, MGMT_PHY_WRITE
                out     dx, ax
                call	Delay500ns

                or      ax, MGMT_PHY_CLOCK
                out     dx, ax
                call	Delay500ns

                and     ax, NOT MGMT_PHY_CLOCK
                out     dx, ax
                call	Delay500ns

                ret
SendOneBitToMII endp


;------ WriteMIIPhy ---------------------------------------------------------;
;
;	Entry:
;	DX = the register offset
;	AX = the data to be written to the register of xcvr
;
;	Exit:
;	All registers are preserved.
;
;----------------------------------------------------------------------------;

		public	WriteMIIPhy
WriteMIIPhy	proc	near
		pusha

		push	ax
		push	dx
;		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow	WNO_DIAGNOSTICS
;		port	PhysicalMgmt, CmdStatus      ; dx: mii port
		mov	dx, PortPhyMgmt

		mov	cx, 32
wmp_preamblebits:
		mov	ax, MGMT_PHY_DATA1
		call	SendOneBitToMII
		loop	wmp_preamblebits
; start of frame = 01
		xor	ax, ax
		call	SendOneBitToMII
		mov	ax, MGMT_PHY_DATA1
		call	SendOneBitToMII
; op code = 01h
		xor	ax, ax
		call	SendOneBitToMII
		mov	ax, MGMT_PHY_DATA1
		call	SendOneBitToMII
; PHY address = 18h (nway), 01h (T4)
		  mov	  bl, miiphyaddr
		  shl	  bl, 3 			; phy addr is 5 bits
		  mov	  cx, 5

send_phy_addr:
		  xor	  ax, ax
		  sal	  bl, 1
		  jnc	  wMii1

		  mov	  ax, MGMT_PHY_DATA1
wMii1:
		  call	  SendOneBitToMII
		  loop	  send_phy_addr
; Reg. address
		pop	bx
		mov	cx, 5
wmp_outregaddr:
		xor	ax, ax
		test	bx, 0010h
		jz	wMii2
		mov	ax, MGMT_PHY_DATA1
wMii2:
		call	SendOneBitToMII
		shl	bx, 1
		loop	wmp_outregaddr
; turnaround
		mov	ax, MGMT_PHY_DATA1
		call	SendOneBitToMII
		xor	ax, ax
		call	SendOneBitToMII

		pop	bx
		mov	cx, 16
write16bits:
		xor	ax, ax
		test	bx, 8000h
		jz	wMii3

		mov	ax, MGMT_PHY_DATA1
wMii3:
		call	SendOneBitToMII
		shl	bx, 1
		loop	write16bits
;
; OK now give it a clock with nobody driving.
;
		mov	ax, MGMT_PHY_CLOCK
		out	dx, ax
		call	Delay500ns
		xor	ax, ax
		out	dx, ax
		call	Delay500ns

		popa
		ret
WriteMIIPhy	endp


;------ ReadMIIPhy ----------------------------------------------------------;
;
;	Entry:
;	DX = the register offset
;
;	Exit:
;	Carry bit set: success
;	Carry bit clear: failed
;	AX = the value of the register in xcvr
;
;----------------------------------------------------------------------------;

		public	ReadMIIPhy
ReadMIIPhy	proc	near

		push	bx
		push	cx
		push	dx
;		port	CmdStatus
		mov	dx, PortCmdStatus
		SelectWindow	WNO_DIAGNOSTICS
;		port	PhysicalMgmt, CmdStatus      ; dx: mii port
		mov	dx, PortPhyMgmt

		mov	cx, 32
rmp_preamblebits:
		mov	ax, MGMT_PHY_DATA1
		call	SendOneBitToMII
		loop	rmp_preamblebits
; start of frame
		xor	ax, ax
		call	SendOneBitToMII
		mov	ax, MGMT_PHY_DATA1
		call	SendOneBitToMII
; op code
		mov	ax, MGMT_PHY_DATA1
		call	SendOneBitToMII
		xor	ax, ax
		call	SendOneBitToMII
; PHY address = 18H
		  mov	  bl, miiphyaddr
		  shl	  bl, 3 			; phy addr is 5 bits
		  mov	  cx, 5

read_send_phy_addr:
		  xor	  ax, ax
		  sal	  bl, 1
		  jnc	  rMii1

		  mov	  ax, MGMT_PHY_DATA1
rMii1:
		  call	  SendOneBitToMII
		  loop	  read_send_phy_addr
; Reg. address
		pop	bx
		mov	cx, 5
rmp_outregaddr:
		xor	ax, ax
		test	bx, 0010h
		jz	rMii2
		mov	ax, MGMT_PHY_DATA1
rMii2:
		call	SendOneBitToMII
		shl	bx, 1
		loop	rmp_outregaddr
; turnaround
		xor	ax, ax
		out	dx, ax
		call	Delay500ns
		mov	ax, MGMT_PHY_CLOCK
		out	dx, ax
		call	Delay500ns
		xor	ax, ax
		out	dx, ax
		call	Delay500ns

		in	ax, dx
		test	ax, MGMT_PHY_DATA1
		jz	rMii3
		;SelectWindow WNO_OPERATING
		clc
		jmp	rmp_exit
rMii3:
		mov	ax, MGMT_PHY_CLOCK
		out	dx, ax
		call	Delay500ns
		xor	ax, ax
		out	dx, ax
		call	Delay500ns

		xor	bx, bx
		mov	cx, 16
read16bits:
		shl	bx, 1
		in	ax, dx

		test	ax, MGMT_PHY_DATA1
		jz	rMii4

		or	bx, 0001h
rMii4:
		mov	ax, MGMT_PHY_CLOCK
		out	dx, ax
		call	Delay500ns
		xor	ax, ax
		out	dx, ax
		call	Delay500ns
		loop	read16bits
;
; OK now give it a couple of clocks with nobody driving.
;
		mov	ax, MGMT_PHY_CLOCK
		out	dx, ax
		call	Delay500ns
		xor	ax, ax
		out	dx, ax
		call	Delay500ns

		mov	ax, bx
		stc		; should take out this
rmp_exit:
		pop	cx
		pop	bx
		ret
ReadMIIPhy	endp


;------ TestMIILink ---------------------------------------------------------;
;        
; Read the "link is up" bit, (this will reset it in case it was latched
; low due to a failure) and then read it again to see if the link is up.
;
;       Exit:
;       Carry set: success
;       Carry clear: failed
;----------------------------------------------------------------------------;

                public  TestMIILink
TestMIILink     proc    near
                pusha

                mov     dx, MII_PHY_STATUS
                call    ReadMIIPhy
                jnc     tml_exit
                
                mov     dx, MII_PHY_STATUS
                call    ReadMIIPhy
                mov     ax, MiiRegValue
                jnc     tml_exit
                test    ax, MII_STS_LINK_UP
                jz      tml_exit
                stc
tml_exit:
                popa
                ret
TestMIILink     endp


;------ CalibrateDelay ------------------------------------------------------;
;									     ;
;	This routine computes the number of loop iterations for 5 timer      ;
;	ticks.	From this ComputeDelay can then compute the number of loop   ;
;	iterations to delay a specified number of microseconds.  Note that   ;
;	the delay loop and the compute loop must use the same instructions.  ;
;									     ;
;	Note: since interrupts must be enabled during this operation in      ;
;	order to accumulate timer ticks, we minimize the possible overhead   ;
;	by masking off all other interrupts through the PIC temporarily.     ;
;									     ;
;	Entry:								     ;
;	DS	= DGROUP						     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli (enables during processing) 				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	CalibrateDelay
CalibrateDelay	proc	near

		pusha
		push	es
;
; mask off all but the timer interrupt through the PIC
;
		in	al, MASTER_MASK_PORT
		push	ax			; save original mask on stack
		jmp	$+2
		mov	al, NOT 1		; mask off all but timer
		out	MASTER_MASK_PORT, al
;
; enable interrupts... we need to take timer ticks in here
;
		sti
;
; set DI to the current count
;
; to limit our error watch the timer tick and wait until we see it change.
;
; under DOS we use the tick count in the BIOS data area.  under OS/2 we have
; access to a msec counter in the GlobalInfoSeg.
;
		mov	ax, 0
		mov	es, ax

		mov	di, es:[46ch]		;bios_ticks.loword
B1:		cmp	di, es:[46ch]		;bios_ticks.loword
		je	B1
		mov	di, es:[46ch]		;bios_ticks.loword
;
; set CX to zero.  this will be our outer loop count, the number of times we
; have run thru the calibration loop.
;
		xor	cx, cx
;
; now do 10000 iterations of our calibration loop.  we want a large enough count
; that the overhead of fetching the system time cause a significant error in
; our calculations.  on a 486DX2/66 this loop takes about 1ms so its unlikely
; to take too long on even the slowest computer we run on.
;
		public	cal_loop
cal_loop:
		inc	cx			; increment our outer loop count

		mov	ax, 10000		; DX:AX is our loop count
		xor	dx, dx

		align	16
B2:		sub	ax, 1
		sbb	dx, 0
		mov	bx, ax
		or	bx, dx
		jnz	B2
;
; if we wait for at least 5 ticks to go by our measurement error will be below
; 20% which is probably good enough
;
; check the system time to see if at least 5 ticks or 1/4 second have gone by.
; if not, run through the calibration loop again.
;
		mov	ax, es:[46ch]		;bios_ticks.loword
		sub	ax, di
		cmp	ax, 5
		jb	cal_loop
;
; compute iterations per 50ms.
;
; under DOS, 5 ticks at 18.20651 MHz = approx 275,000us. or 275ms.  so ticks
; per 50ms is:
;
;   cx * 10,000     cx * 10,000     cx * 20,000
;   -----------  =  -----------  =  -----------
;     275/50		5.5		11
;
; the result will likely exceed a single word in size, so we do long division.
; say the numerator is H:L, both letters being digits base 64k
;
;	Dh :  Dl
;    ------------
; 11 )	H  :  L
;	Rh :  L
;
		mov	ax, 20000
		mul	cx			; DX:AX = H:L

		mov	cx, 11

		mov	bx, ax			; save L

		mov	ax, dx
		xor	dx, dx			; 0:H

		div	cx			; 0:H / 11
		mov	Calibration.hiword, ax

		mov	ax, bx			; Rh:L

		div	cx			; Rh:L / 11
		mov	Calibration.loword, ax
;
; disable interrupts again
;
		cli
;
; enable interrupts through the PIC again
;
		pop	ax			; original PIC mask
		out	MASTER_MASK_PORT, al	; restore it

		pop	es
		popa
		ret

CalibrateDelay	endp


;------ ComputeDelay --------------------------------------------------------;
;									     ;
;	This routine computes a value to delay a specified number of	     ;
;	microseconds on this machine.  This count can then be passed to      ;
;	the DelayN routine to delay for that amount of time.		     ;
;									     ;
;	CalibateDelay has already been used to compute the number of	     ;
;	iterations of our delay loop in 50ms, so the calculations here are   ;
;	straight-forward.  See CalibrateDelay for details.		     ;
;									     ;
;	Entry:								     ;
;	CX	= number of microseconds to compute for 		     ;
;									     ;
;	Exit:								     ;
;	DX:AX	= loop count						     ;
;									     ;
;	Destroys BX, CX, SI, DI.  All other registers are preserved.	     ;
;									     ;
;----------------------------------------------------------------------------;

		public	ComputeDelay
ComputeDelay	proc	near
;
; Calibration contains the number of loop iterations for 50ms.	So the number
; of iterations for cx usec is:
;
;   Calibration * cx
;   ----------------
;	 50,000
;
; again the result may be three words in size after the multiply, so we do
; the multiplication and division long form as above.
;
		mov	ax, Calibration.loword
		mul	cx
		mov	si, ax			; SI=L
		mov	di, dx			; DI=M

		mov	ax, Calibration.hiword
		mul	cx
		add	ax, di			; AX=M
		adc	dx, 0			; DX=H, finished multiply

		mov	di, ax			; DI=M

		mov	ax, dx
		xor	dx, dx			; 0:H

		mov	bx, 50000		; 50ms=50000us
		div	bx			; assume Dh=0, ignore it

		mov	ax, di			; Rh:M

		div	bx			; Rh:M / usec
		mov	di, ax			; DI=Dm

		mov	ax, si			; Rm:L

		div	bx			; Rm:L / usec
		mov	dx, di			; DX:AX = Dm:Dl
;
; make sure its at least one
;
		mov	bx, ax
		or	bx, dx
		jnz	F1
		inc	ax
F1:
		ret
ComputeDelay	endp

public	Delay500ns
Delay500ns	proc	 near

		push	ax
		push	bx
		push	dx
		mov	ax, DelayOneUsec.loword
		mov	dx, DelayOneUsec.hiword
		shr	ax, 1			; divide 1 Usec in half
		shr	dx, 1
		jnc	F2
		or	ax, 8000h		; move low order bit of dx into ax
F2:
		or	ax, dx			;980429
		jnz	F3			;safety check in case of 0
		mov	ax, 1
F3:
		sub	ax, 1
		sbb	dx, 0
		mov	bx, ax
		or	bx, dx
		jnz	F3
		pop	dx
		pop	bx
		pop	ax
		ret

Delay500ns	endp


Delay200ms	proc	near

		push	cx
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		pop	cx
		ret

Delay200ms	endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\bwequ.inc ===
;--------------------------------------------------------------------
; BootWare Table variables
;--------------------------------------------------------------------
;extrn	BWTLANOS:byte			; ROMTOP.ASM
;extrn	BWType:byte			; ROMTOP.ASM
;extrn	BWTCpyRAM:word			; ROMTOP.ASM
;extrn	BWTFeature:word 		; ROMTOP.ASM
;extrn	BWTEthStd:word			; ROMTOP.ASM
;extrn	BWTAddrRes:byte 		; ROMTOP.ASM  ; GK 970126
;extrn	BWTChkSum:byte			; ROMTOP.ASM

;extrn	RomBase:word			; autoscan.asm

;extrn	PrintAt:near			; common.asm
;extrn	ChangeTitleAttrib:near

;--------------------------------------------------------------------
; Protocol starting functions
;--------------------------------------------------------------------
;extrn	NetWareStart:near
;extrn	RPLStart:near
;extrn	IPStart:near

;--------------------------------------------------------------------
; EQUATES
;--------------------------------------------------------------------

; NAD Return Codes
SUCCESSFUL		EQU	0000h
REQUEST_QUEUED		EQU	0002h
OUT_OF_RESOURCE 	EQU	0006h
INVALID_PARAMETER	EQU	0007h
INVALID_FUNCTION	EQU	0008h
NOT_SUPPORTED		EQU	0009h
HARDWARE_ERROR		EQU	000ah
TRANSMIT_ERROR		EQU	000bh
NO_SUCH_DESTINATION	EQU	000ch
HARDWARE_NOT_FOUND	EQU	0023h
HARDWARE_FAILURE	EQU	0024h
CONFIGURATION_FAILURE	EQU	0025h
INTERRUPT_CONFLICT	EQU	0026h
INITIALIZATION_FAILED	EQU	0028h
RECEIVE_TIMEOUT 	EQU	0080h		; Rx2 in NetWare
GENERAL_FAILURE 	EQU	00ffh

; definition for BWTEthStd
BWTETH8023	equ	0
BWTETH8022	equ	1
BWTETHSOFT	equ	2
BWTETHEII	equ	1500		; if BWTEthStd >1500, then E_II
BWTETH8137	equ	08137h
;BWTETH800	equ	0800h		; used for tcp/ip bootp
;BWTETH806	equ	0806h		; used for tcp/ip bootp/arp

; definition for BWTLANOS
BWTLANNW	equ	010h
BWTLANRPL	equ	020h
BWTLANIP	equ	040h
BWTLANMASK	equ	0F0h
BWTLANTRI	equ	070h
BWTLANLOCAL	equ	3h		; Bit 0,1

; definition for BWTFEATURE
BWTFEA_DEFAULT	equ	1
BWTFEA_RS	equ	2
BWTFEA_CONF	equ	4

MasterEOIPort	equ	20h
SlaveEOIPort	equ	0a0h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90x\bw5x9.inc ===
;******************************************************************************
; Routines in BW5X9.INC
;  : shared by 3C5X9, 3C59X-PCI and 3C59X-EISA
;
; Modules included:
;  - NADTransmitPacket
;  - DoRxDiscard
;  - SoftRxReset
;  - NADPoll
;  - NADDisengage
;  - Interrupt Service Routines
;  - TxReset
;  - RxReset
;  - RxDiscard
;
; 960618 GY    - Add support for Broadcast
; 960401 GY - Replace some MACROS with code
;        - standardize port access
;******************************************************************************


IFDEF	UNDI
extrn	GETED:near
extrn	MultiCast_Addresses:word
extrn	EDListHead:word
extrn	EDListCurrent:word
extrn	ApiEntry:word
ENDIF


;NADReset proc far
;	ret
;NADReset endp

NADRelocate proc far
	ret
NADRelocate endp

;----------------------------------------------------------------------
;  Routine Name:  NADTransmitPacket Routine
;
;  Description: The NADTransmitPacket Routine accepts all directed
;     send requests from the RIPL ROM NID code.  This
;     routine determines the validity of the request and
;     works with the adapter to carry it out.
;
;  Input:   ES:SI - pointer to ED
;     DS - Data Segment of RPL Module
;     ints disabled (spec says enabled)
;
;  Output:  ED Completion Code field updated
;     DS preserved
;     ints enabled (doesn't matter)
;
;  Calls:   TransmitPacket
;----------------------------------------------------------------------
public   NADTransmitPacket ; for DEBUGGING
NADTransmitPacket  PROC near		;FAR

	push	ds			; save caller ds

;	push	cs
;	pop	ds			; set ds = cs
	mov 	ax, cs:ApiEntry.mlid_ds_sel
	mov	ds, ax

;	mov	word ptr TxEDPtr, si	; save ED pointer
;	mov	word ptr TxEDPtr+2, es

	cld				; Clear direction

	; calc number of bytes needed to pad to dword size
	mov	cx, es:[si].ED_Length	; get total packet length
	mov	bx, cx
	neg	cl
	and	cl, 3
	mov	PadBytes, cl

	cli				; ints off

	mov	dx, PortTxFree
	in	ax, dx
	cmp	ax, bx
	jae	ww

;;;970613
	mov	es:[si].ED_ErrCode, TRANSMIT_ERROR
	jmp	NetSendRet
   		
; write preamble & MAC header to Tx FIFO

ww:
	mov	dx, PortCmdStatus
	mov	ax, 804h
	out	dx, ax
	mov	dx, IOBASE	
	add	dx, 6
	in	ax, dx
	test	ax, 300h
	jz	ww1

ww1:
	sub	dx, 2
	in	ax, dx
	test	ax, 400h
	jz	ww2

ww2:
	mov	dx, PortCmdStatus
	mov	ax, 801h
	out	dx, ax

	mov	dx, PortTxFIFO

	mov	ax, es:[si].ED_Length	; get total packet length
;RL 970626
;	inc	ax
;	and	al, 0feh		; len field in preamble evenized

	or	ah, high TXP_INTONSUCCESS ; generate TxStatus on all completions

	; write preamble
	out	dx, ax			; preamble
	xor	ax, ax
	out	dx, ax			; unused word

	push	si			; save ED offset

;	lds	bx, cs:TxEDPtr
	mov	cx, es:[si].ED_FragCount; get fragment count
	lea	bx, [si].ED_FragOff	; point to first fragment descriptor

Tx_Frag_Loop:
	push	cx			; save fragment count
;	push	ds			; save fragment descriptor list segment
	mov	cx, es:[bx].FragLen	; length of this fragment
	lds	si, es:[bx].DPointer	; location of this fragment
	rep	outsb			; output bytes to adapter

Tx_Frag_End:
;	pop	ds			; restore frag descriptor list segment
	pop	cx			; restore fragment count
	add	bx, size Frag		; next descriptor
	loop	Tx_Frag_Loop		; loop through all fragments

Start_Tx:
;	push	cs
;	pop	ds			; restore cs = ds
	mov 	ax, cs:ApiEntry.mlid_ds_sel
	mov	ds, ax

	mov	cl, PadBytes
	rep	outsb			; pad packet to dword

	pop	si			; restore ED offset

	mov	RxPend, TRUE		; indicate ready for a receive

	; wait for completion, and check for errors
	sti				; ints on again
;	mov	ah, 0			; get current system tick count
;	int	1Ah			; timer services
;	mov	StartTick, dx		; save timer value
		mov	cx, 10000

WaitForEndTx:
		push	cx

	mov	dx, PortTxSTatus
	in	al, dx
	in	al, dx	
	test	al, TXS_COMPLETE  ; done yet?
;!        cmp cGroup:flag, 1
;!        je    TxFinish  
	jnz	TxFinish       ; jump if Tx complete

;	mov	ah, 0		; get current system tick count
;	int	1Ah		; timer services
;	sub	dx, StartTick   ; subtract start time
;	cmp	dx, 5		; 5 ticks time-out
;	jb	WaitForEndTx    ; loop until time-out

		mov	cx, 20
		call	Delay500ns
		pop	cx
		loop	WaitforEndTx

BadConnection:
;!        mov   cGroup:flag, 0  
	mov	RxPend, 0      ; clear Rx flag
	mov	dx, PortCmdStatus
	call	TxReset     ; make sure FIFO is flushed

		; enable the transmitter
	mov     ah, CMDH_TXENABLE
	out     dx, ax

	mov	bx, offset CGroup:NoNetMsg
;	mov	cs:[StatusMsgFlag],bx   ; only for RPL

;	les   si, TxEDPtr

	; set ErrStruct to print msg
	mov	es:[si].ED_ErrMsg, bx   ; should be ES:

	; Set return code to transmit error
	mov	es:[si].ED_ErrCode, TRANSMIT_ERROR

	jmp	short NetSendRet

; copy done, return

TxFinish:
		pop	cx		;971031

;!        mov   cGroup:flag, 0  
	out	dx, al			; pop Tx status
	test	al, TXS_ERRTYPE		; any error bits set?
	jnz	NetSendError

;	les   si, TxEDPtr

	; Set return code to successful
	mov   es:[si].ED_ErrCode, SUCCESSFUL

NetSendRet:
	pop	ds			; restore callers ds
	ret

NetSendError:
;		mov   cs:[StatusMsgFlag], offset CGroup:TxMsg ; only for RPL

	push	ax
;	les	si, TxEDPtr

	; set ErrStruct to print msg
	mov	es:[si].ED_ErrMsg, offset CGroup:TxMsg

	; Set return code to transmit error
	mov	es:[si].ED_ErrCode, TRANSMIT_ERROR
	pop	ax

	mov	RxPend, 0      ; clear Rx flag
	test	al, TXS_UNDERRUN or TXS_JABBERERROR
	jz	NotTxUnderOrJabber

	call	TxReset     ; reset transmitter

	; enable the transmitter
	mov	ah, CMDH_TXENABLE
	out	dx, ax

	jmp	short NetSendRet

NotTxUnderOrJabber:
	; enable the transmitter
	mov     ah, CMDH_TXENABLE
	out     dx, ax

	jmp	short NetSendRet

NADTransmitPacket  ENDP

;------------------------------------------------------------------------------
; packet completed, but RxStatus.Err indicates the packet experienced an error
; during receiving.

ip_bad:
		mov	dx, PortCmdStatus
		call	RxDiscard	; preserve all regs, except ah
		jmp	int_next	; go directly to int_next without
					; updating errcounts (BootWare doesnt
					;   keep count)

;------------------------------------------------------------------------------
; various errors: No ECB, pkt too small, pkt too big, pkt with bad size

ip_bad_llc:
not_eii_pkt:
ip_discard_pkt:

		mov   dx, PortCmdStatus
		call  RxDiscard 
		jmp   int_next    ; dx = port CmdStatus

;--------------------------------------------------------------------
;
;  Rx Complete interrupt.  PIO only.
;
;--------------------------------------------------------------------
; entry:
;   interrupt is disabled at adapter level. (through SetIntMask cmd).
;   EOIs have been issued to PICs.
;   we've not done sti
;
;   dx = port CmdStatus
;   cli
;   cld
;
;--------------------------------------------------------------------

	public isr_RxPIO

isr_RxPIO:
		mov	dx, PortRxStatus
		in	ax, dx			; ax = RxStatus
		test	ah, RXSH_ERROR		; error reported?
		jnz	ip_bad

; get Packet Length from RxStatus register (win 1,port8)
		mov	dx, PortRxStatus
		in	ax, dx			; ax = RxStatus
		and	ax, 07ffh		; keep only last 11 bits

IFDEF UNDI
		call	GetED
ELSE
		call	[AIGetEDJmp]		; get an ED (ES:SI)
ENDIF
		jz	ip_discard_pkt		; we didn't get an ED

		mov	bx, si			; move ED offset to bx
		mov	es:[si].ED_Length, ax	; save length in ED
		mov	cx, es:[si].ED_FragCount; get number of fragments
		lea	bx, [si].ED_FragOff	; point to 1st descriptor

		mov	dx, ax			; move packet size to dx
DRxNxtF:
		push	cx
		push	es
		mov	cx, es:[bx].Dlen	; get fragment length
;		les	di, es:[bx].Dpointer	; get fragment pointer
		mov	ax, ds
		mov	es, ax
		mov	di, word ptr es:[bx].Dpointer	; get fragment pointer
ChkMovSize:
		cmp	dx, cx
		ja	MoveFrag		; more data after this frag

		mov	cx, dx			; no more data after this frag
MoveFrag:
		sub	dx, cx			; subtract size of this frag
		jcxz	DrxDoNxt 		; zero count -- skip data read

		push	dx
		mov	dx, PortRxFIFO
	rep	insb
		pop	dx
DrxDoNxt:
		pop	es
		pop	cx
		add	bx, 6    ; point to next fragment desc
		loop	DRxNxtF  ; do next frag, if any

; -- DX has # of bytes that couldn't fit in receive descriptors

NoRxFrag:
;		push	cs
;		pop	ds			; restore DS = CS

		mov	es:[si].ED_ErrCode, 0	; Set good completion

IFDEF	UNDI
		lea	bx, [si].ED_FragOff	; point to 1st descriptor
;		les	di, es:[bx].Dpointer	; get fragment pointer
		mov	ax, ds
		mov	es, ax
		mov	di, word ptr es:[bx].Dpointer	; get fragment pointer

		cmp	byte ptr es:[di], 01h
		jnz	NoMCastCheck		; not a MC address
		mov	si, offset DGroup:MultiCast_Addresses
		mov	cx, (Eth_MCastBuf ptr [si]).MCastAddrCount
		jcxz	NoMCastCheck		; no MC address

		lea	si, (Eth_MCastBuf ptr [si]).MCastAddr
CheckMC:
		push	cx
		mov	cx, 6		;length of address in byte
	repz	cmpsb
		jcxz	MCastFound	;this is our MC address

		add	si, 6
		pop	cx
		loop	CheckMC
;
; not our MC address, kill the recently saved ED
;
		mov	si, DGroup:[EDListCurrent]	; get current ED
		mov	word ptr [si].ED_Length, 0	;kill the data
		mov	DGroup:[EDListHead], si	; move the head backward
		jmp	DiscardRxData

MCastFound:
		pop	cx
NOMCastCheck:
ELSE
		call	[AIPostEDJmp]		; post the received packet
ENDIF

; we've copied all packet data out of RxFIFO, now discard postamble and any
; pad bytes inserted by hardware.

DiscardRxData:
;		mov   ax, cs
;		mov   ds, ax

		mov	dx, PortCmdStatus
		call	RxDiscard         ; discard padding & postamble

; copy is done, now tell foreground that a packet is available

		jmp    int_next

;--------------------------------------------------------------------
;
; TxReset - reset the transmitter
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
;--------------------------------------------------------------------
TxReset     proc  near
IFDEF	BW90X
		mov   ax, CMD_TXRESET
ELSE
		mov   ax, CMD_TXRESET + TXRXRESET_ALLBUTBM
ENDIF
		out   dx, ax

?txrloop:   in      ax, dx
		test  ah, STH_BUSY
		jnz   ?txrloop                    ;; loop while busy

			ret
TxReset     endp

;--------------------------------------------------------------------
;
; RxReset - reset the receiver
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
;--------------------------------------------------------------------
RxReset     proc  near
		mov   ax, CMD_RXRESET
		out     dx, ax

?rxrloop:   in      ax, dx
		test    ah, STH_BUSY
		jnz     ?rxrloop                    ;; loop while busy
		ret
RxReset     endp

;--------------------------------------------------------------------
;
; RxDiscard - discard top packet in RxFIFO
;
; entry:
;   ds = DGROUP
;   dx = cmd/status port
;   cli
;
; exit:
;   cli
;
; destroys:
;   ax
;
;--------------------------------------------------------------------
RxDiscard   proc  near

		mov	ax, CMD_RXDISCARD
		out	dx, ax
?rxdloop:
		in	ax, dx
		test	ah, STH_BUSY
		jnz	?rxdloop                    ;; loop while busy
		ret

RxDiscard   endp


;------ DoRxDiscard -------------------------------------------------
;
;  This routine performs an RxDiscard, including the workarounds
;  required by the Rev 1 versions of the ASIC.  It has been made a
;  procedure because the workarounds were getting too ungainly.
;
;  Entry:
;  DS = DGROUP
;  DX = port CmdStatus
;  cli
;
;  Exit:
;  cli
;  Destroys AX.  All other registers preserved.
;--------------------------------------------------------------------

		public   DoRxDiscard
DoRxDiscard proc  near

		mov   dx, PortCmdStatus

; issue the RxDiscard and wait for it to complete

	mov   ah, CMDH_RXDISCARD
	out   dx, ax         ; discard the packet

discard_busy:
	in    ax, dx
	test  ah, STH_BUSY
	jnz   discard_busy       ; loop while busy

; check RxStatus.  if complete, everything is fine--just return.

	mov   dx, PortRxStatus
	in ax, dx

	mov   dx, PortCmdStatus

	ret

DoRxDiscard endp

;------ SoftRxReset -------------------------------------------------
;
;  This routine does an RxReset to clear out the RxFIFO and its
;  associated logic.  After the RxReset, it reenables and restores
;  the current RxFilter and RxEarly thresholds.
;
;  Entry:
;  DS = DGROUP
;  DX = port CmdStatus
;  cli
;
;  Exit:
;  cli
;  Destroys AX.  All other registers preserved.
;
;--------------------------------------------------------------------

		 public SoftRxReset
SoftRxReset   proc   near

	call  RxReset

	mov   dx, PortCmdStatus
	mov   ax, HWFilter      ; has CMD_SETFILTER in it
	out   dx, ax

		; enable the receiver
		mov     ah, CMDH_RXENABLE
		out     dx, ax


	mov   ax, NormalRxEarly ; has CMD_SETRXEARLY in it
	out   dx, ax

	ret
SoftRxReset endp


IFNDEF	UNDI
;----------------------------------------------------------------------
;  Routine Name:  NADPoll Routine
;
;  Description: The NADPoll routine is used by the RIPL ROM NID
;     portion of the RIPL ROM to poll the driver portion so
;     that the driver portion can do timeout work.
;
;  Input:   DS - Data Segment of RPL Module
;     ints enabled
;
;  Output:  DS preserved
;     ints enabled
;
;  Calls:   none
;----------------------------------------------------------------------
NADPoll  proc  far
	retf				; nothing to do...
NADPoll  endp

;----------------------------------------------------------------------
;  Routine Name:  NADDisengage Routine

;  Description: The NADDisengage routine is used by the RIPL ROM NID
;     portion of the RIPL ROM to signal the Network Driver
;     to release its IRQ, DMA, and memory resources.
;
;  Input:   DS - Data Segment of RPL Module
;     ints enabled
;
;  Output:  DS preserved
;     ints enabled
;     ax = offset to error string or 0 if successful
;
;  Calls:   none
;
; July 10,91   implement NIDDisengage version 0.8
;----------------------------------------------------------------------
NADDisengage   PROC  FAR
	push  ds
	push  es

	cli

	; is it RPL ?
	test  cs:BWTLANOS, BWTLANRPL
	jz DisengageRPL

	; change IntFD to point to NADIntFD in ROMTOP.ASM. Depending on
	; the ROMSize, RPLBOOT.SYS might call the IntFD that is not
	; even mapped on the system and hang the machine
	xor   ax, ax
	mov   es, ax
	mov   di, 0FDh*4
	mov   ax, offset CGroup:NADIntFD
	stosw
	mov   ax, cs:ROMBase    ; 940118
	stosw

	; make sure that it works on every page. Int13 should point to NADIntFD
	; also.
	mov   di, 013h*4
	mov   ax, offset CGroup:NADIntFD
	stosw
	mov   ax, cs:ROMBase
	stosw

	push  cs
	pop   es

DisengageRPL:

		; 3Com 5X9 NDIS driver place ISR at IRQ 2 rather than IRQ 9 ( compatability
		; with IBM 3270 program ). Thus, this routine needs to restore the old
		; BIOS IRQ9 handler to invoke IRQ2. Also, this routine should NOT
		; mask IRQ9.

		mov    dx, Int_mask_port
		in     al, dx
	
		or     al, cs:IRQBit
		jmp    $+2

		out    dx, al

		; restore handler
		call  DriverUnhook

		; unmask IRQ 9 again so that interrupt will pass to IRQ2 ISR
		cmp   cs:IRQLevel, 9
		jnz   DisengageExit

		mov   dx, 0a1h
		in al, dx
		and   al, 0fdh
		out   dx, al

DisengageExit:
		pop   es
		pop   ds

		sti
		xor   ax, ax
		retf        ; Return to caller

NADDisengage   endp
ENDIF


;------------------------------------------------------------------
;
; DriverISR:  Interrupt Service Routine for Vulcan
;
;------------------------------------------------------------------

		 public DriverISR
		 public isr_1st_pass
		 public int_next
		 public isr_return
		 public isr_again
		 public isr_enable

		 ALIGN  4
		 db     'ISR'

DriverISR     proc   near

		pusha
		push   ds
		push   es
;		mov    ax, cs
		mov 	ax, cs:ApiEntry.mlid_ds_sel
		mov	ds, ax

		cld
		mov	dx, PortCmdStatus

; make sure the adapter is in window 1, which is where it should always
; be post-init with interrupt enabled

; mask off all interrupts at adapter level. and release the system interrupt

		mov    ax, CMD_SETINTMASK + MASK_ALL
		out    dx, ax           ; disable all interrupts

		; acknowledge interrupt
		mov    ax, CMD_ACKNOWLEDGE + INT_LATCH
		out     dx, ax

		mov	ax, eoi_value          ; ah = EOI for master PIC
						 ; if int < 8, eoi_value = 6040h
						 ;   else eoi_value = 6220h

		cmp	al, 40h             ; Int level < 8 ? (i.e. NOP)
		jz	EOIMaster         ; No, need EOI to Slave PIC

		out	SlaveEOIPort, al          ; al = EOI for slave PIC

		jmp	$+2
		jmp	$+2
		jmp	$+2
		jmp	$+2
		jmp	$+2
		jmp	   $+2

EOIMaster:
		 mov    al, ah           ; send EOI to Master 8259 PIC
		 out    MasterEOIPort, al

;----------------------------------------------------------------------------
; read the reason for the interrupt and dispatch control to the appropriate
; routine through jump table.  When that reason has been handled the routine
; will jump  to int_next.  if there is no reason for the interrupt
; we will simply end up at isr_return. the following types of interrupt
; are handled:
;
;      a. Adapter Failure
;      b. Rx Complete
;      c. Interrupt Request (not supported, ack and return)

		 public isr_1st_pass

isr_1st_pass:
		mov	dx, PortCmdStatus
		in	ax, dx           ; 05-21-92
		jmp	IntDispatch

; there is another interrupt reason.  since we might be close to our disable
; time limit, enable before we handle it.

isr_again:           ; AL has CmdStatus contents

		sti
		nop
		cli

		jmp    IntDispatch

; once the code entered through IntDispatch has completed its task, it jumps
; to this label. check for any remaining reasons.

		public int_next
int_next:
;		mov	ax, cs
;		mov	ds, ax
		mov	dx, PortCmdStatus

		in	ax, dx       ; read status reg see if any
		test	al, al       ; more interrupts to be
		jnz	isr_again       ; serviced?

;-----------------------------------------------------------------------------
; nothing left showing in status.


isr_return:

;----------------------------------------------------------------------------
; reenable interrupts from the adapter.
;
; note: if indications are disabled, they are masked off through the
; ReadZeroMask so reenabling interrupts will have no effect on those bits.

isr_enable:
		cli

		mov   dx, PortCmdStatus
		mov   ax, CMD_SETINTMASK + BOOTWARE_INTS
		out   dx, ax

;950214       port   cs:CmdStatus          ; 03-24-92
		pop   es
		pop   ds
		popa
		iret


DriverISR   endp

; 3Com's driver used a 128-word jmp table - faster, but too much room for us...

IntDispatch:            ; prioritized dispatch (err, Rx, Tx)
		test	al, INT_ADAPTERFAIL
		jz	IntNotFail
		jmp	isr_AdapterFailure

IntNotFail:
		test	al, INT_RXCOMPLETE
		jz	IntNotRxComplete
		jmp	isr_RxPIO

IntNotRxComplete:
		test	al, INT_TXCOMPLETE   ; shouldn't happen, only if cable
					; not connected
		jz	IntNotTxComplete

		mov	dx, PortTxStatus
		in	al, dx
		cmp	al, 0C0h
		jne	xx
		mov	flag, 1
xx:
		out	dx, al         ; pop tx status to turn the bit off
		mov	dx, PortCmdStatus
		mov	ax, CMD_ACKNOWLEDGE + 4
		out	dx, ax
		jmp	int_next

IntNotTxComplete:
		test	al, INT_REQUESTED
		jz	isr_return

isr_IntRequest:
		; acknowledge interrupt
		mov	ax, CMD_ACKNOWLEDGE + INT_REQUESTED
		out     dx, ax

		jmp   isr_return     ; Solve mysterious problem with V2

;--------------------------------------------------------------------
;
;  Adapter Failure interrupt.
;
;--------------------------------------------------------------------
; entry:
;   interrupt is disabled at adapter level. (through SetIntMask cmd).
;   EOIs have been issued to PICs.
;   we've not done sti
;
;   dx = port CmdStatus
;   cli
;   cld
;
; description:
;
;   Three possible reasons that force adapter to generate Adapter
;   Failure Interrupt are:
;
;        1. Rx DMA Trouble (DMA is enabled on a non-dword boundary)
;        2. Rx Underrun
;        3. Tx Overrun
;
;   Diagnostics Register offset 4, window 4 contains information of
;   what causes this interrupt.  Since this interrupt will hardly
;   be generated if software and hardware work properly, we should
;   not see it happen.
;
;   For the moment the only conditins we attempt any workaround for is
;   RxUnderrun and TxOverrun.  For RxUnderrun, we simply reset the
;   receiver by calling SoftRxReset.  For TxOverrun, we simply reset
;   the transmitter and start things going again.
;
;   Other than that, we do not attempt any workarounds to get the board
;   up and running again.  We simply die a graceful death in as little
;   code space as possible.
;
;--------------------------------------------------------------------

		 public isr_AdapterFailure

isr_AdapterFailure:
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS        ; switch to window 4

		mov	dx, PortFIFODiag
		in	ax, dx

		mov	dx, PortCmdStatus
		test	ax, FIFOD_RXUNDERRUN
		jz	chk_tx_overrun

; RxUnderrun.  ASIC (rev 1) adapter failure int. due to a false RxUnderrun.
; we just call SoftRxReset to reset the receiver and return to int_next as
; a software workaround to a hardware problem.

		 public AdapterFailure_Rxunderrun

AdapterFailure_Rxunderrun:
		SelectWindow WNO_OPERATING

		mov   dx, PortCmdStatus
		call   SoftRxReset

		jmp    int_next

chk_tx_overrun:
		test   ax, FIFOD_TXOVERRUN
		jz     ia_shutdown

; TxOverrun.  Probably a software error, but since its probably on the back end
; of the TxFIFO and the error shuts down the transmitter, we won't have sent
; any bad packets yet (with rev 1 silicon).  Reset the transmitter and start
; things up again.

		public AdapterFailure_TxOverrun

AdapterFailure_TxOverrun:
		call  TxReset

		mov    ax, CurTxStart
		out    dx, ax

		; enable the transmitter
		mov     ah, CMDH_TXENABLE
		out     dx, ax


;		SelectWindow WNO_OPERATING

; shut off the transmitter and receiver
		public ia_shutdown

ia_shutdown:
IFNDEF	UNDI
		SelectWindow WNO_OPERATING

		; Tx Disable
		mov     ah, CMDH_TXDISABLE
		out     dx, ax

				; Disable the receiver
		mov     ah, CMDH_RXDISABLE
		out     dx, ax

; disable additional interrupts from the adapter

		mov    ax, CMD_SETRZMASK + MASK_ALL
		out    dx, ax
ENDIF
		jmp    int_next
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90x\version.inc ===
;
; Modifications:   $Header:   H:/Archives/Client/Include/version.inv   1.22.1.1   31 Jan 1998 23:08:08   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

ifndef _VERSION_INC
_VERSION_INC=1


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Equates
;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Version number of current LSA build.
;
LSA_MAJOR	equ	0
LSA_MINOR	equ	99
LSA_EDIT	equ	'd'

LSA_EISA_ID	equ   ((('L'-'@') shl 26)+(('S'-'@') shl 21)+(('A'-'@') shl 16))

LSA_PMM_HANDLE	equ	((LSA_EISA_ID)+2000h+((LSA_MAJOR) shl 8)+(LSA_MINOR))


; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Product & manufacturer ID strings.
;
MFG_STR		textequ	<'Intel'>
PROD_STR	textequ	<'LANDesk (R) Service Agent II'>
COPYRIGHT_STR	textequ	<'Copyright (C) 1997  Intel Corporation.  All rights reserved.'>


endif ;_VERSION_INC

; EOF - $Workfile:   version.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90x\undi_equ.inc ===
;
;--- Miscellaneous Equates
;
NULL            equ     0
CR		equ	0Dh           ;- Carriage Return
LF		equ	0Ah           ;- Line Feed
FALSE		equ	0
TRUE		equ	1
;
;--- Ethernet Frame Sizes
;
ETHERNET_ADDRESS_LENGTH		equ	6
ETHERNET_HEADER_SIZE		equ	14
MINIMUM_ETHERNET_PACKET_SIZE	equ	60
;MAXIMUM_ETHERNET_PACKET_SIZE	equ	1514
MAXIMUM_ETHERNET_PACKET_SIZE	equ	1500 ;; just data, not media header

MAX_PACKET         Equ       1514      ; Maximum allowable packet size.
MIN_PACKET         Equ       60        ; Minimum allowable packet size.
; 
;--- Packet filter bit definitions
; 
FLTR_DIRECTED                Equ       01H
FLTR_MLTCST                  Equ       01H
FLTR_BRDCST                  Equ       02H
FLTR_PRMSCS                  Equ       04H
FLTR_SRC_RTG                 Equ       08H
;
;--- Processor Type Equates
;
EIGHT_BIT          equ       0001H
SIXTEEN_BIT        equ       0002H
PROC_TYPE_MASK     equ       0030H

PROC_8086          equ       0000H OR EIGHT_BIT
PROC_80286         equ       0010H OR SIXTEEN_BIT
PROC_80386         equ       0020H
PROC_80486         equ       0040H
;
;--- Result codes returned in AX by a PXE API service.
;
PXENV_EXIT_SUCCESS		equ	0
PXENV_EXIT_FAILURE		equ	1
PXENV_EXIT_CHAIN		equ	0FFFFh	; used internally
;
;--- Status codes returned in the status word of PXE API parameter structures.
;
PXENV_STATUS_SUCCESS		equ	0
PXENV_STATUS_FAILURE		equ	1	;general failure
PXENV_STATUS_BAD_FUNC		equ	2	;invalid function number
PXENV_STATUS_UNSUPPORTED	equ	3	;not yet supported
PXENV_STATUS_1A_HOOKED		equ	4	;Int 1AH cannot be unhooked

; Driver errors (60 to 0x6F)
; These errors are for UNDI compatible NIC drivers.
PXENV_STATUS_UNDI_MEDIATEST_FAILED 		equ	61h
PXENV_STATUS_UNDI_CANNOT_INIT_NIC_FOR_MCAST	equ	62h
;
;
EISA_ADAPTER             equ    1
PCI_ADAPTER              equ    2
PnP_ADAPTER              equ    3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90x\vulcan.inc ===
;------ VULCAN.INC ----------------------------------------------------------;
;                                                                            ;
;       This file contains Vulcan-specific equates, structures and           ;
;       macros.  It must be assembled with MASM 5.1 or later.                ;
;                                                                            ;
;----------------------------------------------------------------------------;
;----------------------------------------------------------------------------;
;                                                                            ;
;       This source file is the property of 3Com Corporation and may not be  ;
;       copied or distributed in any isomorphic form without an appropriate  ;
;       prior licensing arrangement with 3Com Corporation.                   ;
;                                                                            ;
;       Copyright (c) 1993 3Com Corporation                                  ;
;                                                                            ;
;       3Com Corporation                                                     ;
;       5400 Bayfront Plaza, P.O. Box 58145                                  ;
;       Santa Clara, CA 95052-8145 USA                                       ;
;       (408) 764-6016                                                       ;
;                                                                            ;
;----------------------------------------------------------------------------;
;
;      10/06/94    delete MEDIA_SQE, add MEDIA_TXINPROG, add PORT_RxError
;                  redefine RxStatus/RxError register bits
;      10/18/94    delete BUS_MCA, add BUS_UNKNOWN, BUS_PCI
;      10/19/94    define new port offsets for window 3 and window 7
;      10/19/94    add adapter codes
;      10/20/94    add new equs: MEDIA_CRCSTRIPDISABLE, MEDIA_DATARATE100,
;                  MEDIA_XCVRBITS
;      11/27/94    Did some clean-up of the V3 bus master additions
;----------------------------------------------------------------------------;

BOOTWARE_INTS equ      INT_LATCH + INT_ADAPTERFAIL + INT_RXCOMPLETE + INT_REQUESTED
;
;  sizes for array of danger regions used in hardware workaround for V3
;  at 10 Mbit
;
RAID_N                  equ     256             ; entries in RaidArray table
RAID_MASK               equ     ((RAID_N * 4) - 1)
RX_FIFO_GOOD            equ     020H            ; Bit 5 of 2nd SW config word
EISA_RXPACE_FIX		equ	040H		; Bit 6 of 2nd SW config word
;
; Default TxStart Thresholds
;
DEFAULT_TXSTART         equ     16
DEFAULT_AVATXSTART      equ     256

;
; Multicast Table Entry Structure
;
MCTableEntry    struc

MCTableAddress  db      6 dup (?)
MCTableInUse    db      ?
		db      ?
MCTableEntry    ends

;
; the compatibility level of this driver
;
CLEVEL              equ 1

;------ Equates -------------------------------------------------------------;


;
; Command code masks
;
CMD_CMDMASK         equ 0F800h                  ; command bits
CMD_ARGMASK         equ 007FFh                  ; argument bits
;
; Command codes, word form
;
CMD_GLOBALRESET     equ 00000b shl 11           ; global reset
CMD_SELECTWINDOW    equ 00001B shl 11           ; select register window
CMD_STARTINTXCVR    equ 00010b shl 11           ; start internal transciver
CMD_RXDISABLE       equ 00011b shl 11           ; rx disable
CMD_RXENABLE        equ 00100b shl 11           ; rx enable
CMD_RXRESET         equ 00101b shl 11           ; rx reset
CMD_TXDONE          equ 00111b shl 11           ; tx done
CMD_RXDISCARD       equ 01000b shl 11           ; rx discard top packet
CMD_TXENABLE        equ 01001b shl 11           ; tx enable
CMD_TXDISABLE       equ 01010b shl 11           ; tx disable
CMD_TXRESET         equ 01011b shl 11           ; tx reset
CMD_REQUESTINT      equ 01100b shl 11           ; request interrupt
CMD_ACKNOWLEDGE     equ 01101b shl 11           ; acknowledge interrupt
CMD_SETINTMASK      equ 01110b shl 11           ; set interrupt mask
CMD_SETRZMASK       equ 01111b shl 11           ; set read zero mask
CMD_SETRXFILTER     equ 10000b shl 11           ; set rx filter
CMD_SETRXEARLY      equ 10001b shl 11           ; set rx early threshold
CMD_SETTXAVAILABLE  equ 10010b shl 11           ; set tx available threshold
CMD_SETTXSTART      equ 10011b shl 11           ; set tx start threshold
CMD_STARTDMA        equ 10100b shl 11           ; start dma upload/download
CMD_STATSENABLE     equ 10101b shl 11           ; statistics enable
CMD_STATSDISABLE    equ 10110b shl 11           ; statistics disable
CMD_STOPINTXCVR     equ 10111b shl 11           ; start internal transciver
CMD_SETTXRECLAIM    equ 11000b shl 11           ; set tx reclaim threshold
;
; Command codes, hibyte form (commands without operands only)
;
CMDH_STARTINTXCVR   equ CMD_STARTINTXCVR shr 8
CMDH_RXDISABLE      equ CMD_RXDISABLE shr 8
CMDH_RXENABLE       equ CMD_RXENABLE shr 8
CMDH_RXDISCARD      equ CMD_RXDISCARD shr 8
CMDH_TXENABLE       equ CMD_TXENABLE shr 8
CMDH_TXDISABLE      equ CMD_TXDISABLE shr 8
CMDH_REQUESTINT     equ CMD_REQUESTINT shr 8
CMDH_STATSENABLE    equ CMD_STATSENABLE shr 8
CMDH_STATSDISABLE   equ CMD_STATSDISABLE shr 8
CMDH_STOPINTXCVR    equ CMD_STOPINTXCVR shr 8
CMDH_ACKNOWLEDGE    equ CMD_ACKNOWLEDGE shr 8

CMD_DMARESET            equ     00BFh                                   ;global reset with only dma set
;
; Status register bits (INT for interrupt sources, ST for the rest)
;
INT_LATCH           equ 00001h                  ; interrupt latch
INT_ADAPTERFAIL     equ 00002h                  ; adapter failure
INT_TXCOMPLETE      equ 00004h                  ; tx complete
INT_TXAVAILABLE     equ 00008h                  ; tx available
INT_RXCOMPLETE      equ 00010h                  ; rx complete
INT_RXEARLY         equ 00020h                  ; rx early
INT_REQUESTED       equ 00040h                  ; interrupt requested
INT_UPDATESTATS     equ 00080h                  ; update statistics

ST_FAILED           equ 00800h                  ; command failed
ST_BUSY             equ 01000h                  ; command busy
ST_WINDOW           equ 0E000h                  ; window bits (13-15)
ST_DMABUSY          equ 00800h                  ; dma in progress

STH_FAILED          equ ST_FAILED shr 8
STH_BUSY            equ ST_BUSY shr 8
STH_WINDOW          equ ST_WINDOW shr 8
STH_DMABUSY         equ ST_DMABUSY shr 8

INT_OFFTXCOMPLETE   equ ((NOT (INT_TXCOMPLETE)) and (0FFh))
ifdef NDIS
INT_ONTXCOMPLETE    equ INT_TXCOMPLETE
else
INT_ONTXCOMPLETE    equ MASK_NONE
endif



;
; RxStatus/RxError register bits, both forms
;
RXS_INCOMPLETE      equ 8000h                   ; not completely received
RXS_ERROR           equ 4000h                   ; error in packet
RXS_LENGTH          equ 1FFFh                   ; bytes in RxFIFO
;RXS_ERRTYPE         equ 3800h                   ; Rx error type, bit 13-11
;RXS_OVERRUN         equ 0000h                   ; overrun error
;RXS_OVERSIZE        equ 0800h                   ; oversize packet error
;RXS_DRIBBLE         equ 1000h                   ; dribble bit (not an error)
;RXS_RUNT            equ 1800h                   ; runt packet error
;RXS_CRC             equ 2800h                   ; CRC error
;RXS_FRAMING         equ 2000h                   ; framing error

RXSH_INCOMPLETE     equ RXS_INCOMPLETE shr 8
RXSH_ERROR          equ RXS_ERROR shr 8
;RXSH_ERRTYPE        equ RXS_ERRTYPE shr 8
RXSH_OVERRUN        equ 01h
RXSH_DRIBBLE        equ 80h
RXSH_CRC            equ 08h
RXSH_RUNT           equ 02h
RXSH_OVERSIZE       equ 10h
RXSH_FRAMING        equ 04h
;
; TxStatus register bits
;
TXS_COMPLETE        equ 80h                     ; tx completed
TXS_INTREQUESTED    equ 40h                     ; interrupt on successfull tx
TXS_ERRTYPE         equ 38h                     ; error bits
TXS_JABBERERROR     equ 20h                     ; jabber error
TXS_UNDERRUN        equ 10h                     ; tx underrun error
TXS_MAXCOLLISIONS   equ 08h                     ; max collisions error
TXS_STATUSOVERFLOW  equ 04h                     ; TX status stack is full
TXS_RECLAIMERROR    equ 02h                     ; collision after reclaim threshold
;
; InternalConfig register bits
;
ICL_RAMSIZE_MASK    equ 0007h
RAM_8K              equ 000b
RAM_32K             equ 010b
RAM_64K             equ 011b
RAM_128K            equ 100b

ICL_RAM16BIT        equ 0008h                   ; set if word wide ram

ICH_RAMPART_MASK    equ 0003h
PART_5TO3           equ 00b
PART_3TO1           equ 01b
PART_1TO1           equ 10b

ICH_XCVR_MASK       equ 0070h                   ; transceiver select
ICH_XCVR_SHIFT      equ 4
;
; transceiver types
;
XCVR_10TP           equ 000b                    ; 10BaseT/TP
XCVR_10AUI          equ 001b                    ; 10Mbps AUI
XCVR_10BNC          equ 011b                    ; 10Base2/Coax/BNC
XCVR_100TX          equ 100b                    ; 100BaseTX (scrambled)
XCVR_100FX          equ 101b                    ; 100BaseFX (unscrambled)
XCVR_MII            equ 110b                    ; MII
;
; Window Numbers
;
WNO_SETUP           equ 0                       ; setup/configuration
WNO_OPERATING       equ 1                       ; operating set
WNO_STATIONADDRESS  equ 2                       ; station address setup/read
WNO_FIFO            equ 3                       ; FIFO management
WNO_DIAGNOSTICS     equ 4                       ; diagnostics
WNO_READABLE        equ 5                       ; registers set by commands
WNO_STATISTICS      equ 6                       ; statistics
WNO_BUSMASTER       equ 7                       ; bus master control
;
; Port offsets, Window 1
;
PORT_CmdStatus      equ 0Eh                     ; command/status
PORT_TxFree         equ 1Ch                     ; free transmit bytes
PORT_TxStatus       equ 1Bh                     ; transmit status (byte)
PORT_Timer          equ 1Ah                     ; latency timer (byte)
PORT_RxStatus       equ 18h                     ; receive status
PORT_RxError        equ 14h                     ; rx error code register
PORT_RxFIFO         equ 10h                     ; RxFIFO read
PORT_TxFIFO         equ 10h                     ; TxFIFO write
;
; Port offsets, Window 0
;
PORT_EEData         equ 0Ch                     ; EEProm data register
PORT_EECmd          equ 0Ah                     ; EEProm command register
PORT_CfgResource    equ 08h                     ; resource configuration
PORT_CfgAddress     equ 06h                     ; address configuration
PORT_CfgControl     equ 04h                     ; configuration control
PORT_ProductID      equ 02h                     ; product id (EISA)
PORT_Manufacturer   equ 00h                     ; Manufacturer code (EISA)
;
; Port offsets, Window 2
;
PORT_SA0_1          equ 00h                     ; station address bytes 0,1
PORT_SA2_3          equ 02h                     ; station address bytes 2,3
PORT_SA4_5          equ 04h                     ; station address bytes 4,5
PORT_SM0_1          equ 06h                     ; station address bytes 0,1
PORT_SM2_3          equ 08h                     ; station address bytes 2,3
PORT_SM4_5          equ 0Ah                     ; station address bytes 4,5
;
; Port offsets, Window 3                        ; 10/19/94, cj
;
PORT_ALT_TxFree     equ 0Ch                     ; free transmit bytes (dup)
PORT_RxFree         equ 0Ah                     ; free receive bytes
PORT_ResetOptions   equ 08h                     ; ResetOptions
PORT_MacControl     equ 06h                     ; MacControl
PORT_InternalCfgH   equ 02h                     ; InternalConfig High
PORT_InternalCfgL   equ 00h                     ; InternalConfig Low
;
; Port offsets, Window 4
;
PORT_BadSsdCount    equ 0Ch
PORT_MediaStatus    equ 0Ah                     ; media type/status
PORT_SlingshotStatus equ 08h                    ; Slingshot status
PORT_NetDiagnostic  equ 06h                     ; net diagnostic
PORT_FIFODiagnostic equ 04h                     ; FIFO diagnostic
PORT_HostDiagnostic equ 02h                     ; host diagnostic
PORT_TxDiagnostic   equ 00h                     ; tx diagnostic
;
; Port offsets, Window 5
;
PORT_RZMask         equ 0Ch                     ; read zero mask
PORT_IntMask        equ 0Ah                     ; interrupt mask
PORT_RxFilter       equ 08h                     ; receive filter
PORT_RxEarly        equ 06h                     ; rx early threshold
PORT_TxAvailable    equ 02h                     ; tx available threshold
PORT_TxStart        equ 00h                     ; tx start threshold
;
; Port offsets, Window 6
;
PORT_TXBYTES        equ 0Ch                     ; tx bytes ok
PORT_RXBYTES        equ 0Ah                     ; rx bytes ok
PORT_UPPERFRAMES    equ 09h                     ; upper bits of tx/rx frames ok
PORT_TXDEFER        equ 08h                     ; tx frames deferred (byte)
PORT_RXFRAMES       equ 07h                     ; rx frames ok (byte)
PORT_TXFRAMES       equ 06h                     ; tx frames ok (byte)
PORT_RXDISCARDED    equ 05h                     ; rx frames discarded (byte)
PORT_TXLATE         equ 04h                     ; tx frames late coll. (byte)
PORT_TXSINGLE       equ 03h                     ; tx frames one coll. (byte)
PORT_TXMULTIPLE     equ 02h                     ; tx frames mult. coll. (byte)
PORT_TXNOCD         equ 01h                     ; tx frames no CDheartbt (byte)
PORT_TXCARRIERLOST  equ 00h                     ; tx frames carrier lost (byte)
;
; Port offsets, Window 7
;
PORT_MasterStatus   equ 0Ch
PORT_MasterLen      equ 06h
PORT_MasterAddressH equ 02h
PORT_MasterAddress  equ 00h
;
; masks for UpperFramesOk
;
UPPER_RXFRAMES_MASK equ 00Fh
UPPER_TXFRAMES_MASK equ 0F0h
UPPER_TXFRAMES_SHIFT equ 4
;
; bits in ResetOptions
;
RO_AVAILBITS        equ 00FFh

RO_BASET4           equ 0001h
RO_BASETX           equ 0002h
RO_BASEFX           equ 0004h
RO_TP               equ 0008h
RO_COAX             equ 0010h
RO_AUI              equ 0020h
RO_MII              equ 0040h
RO_T4               equ 0080h
;
; Various command arguments
;
INT_ALLDISABLED         equ 00000000000b            ; all interrupts disabled
INT_ALLENABLED          equ 00011111110b            ; all interrupts enabled
ACK_ALL                 equ 00111111111b            ; ack everything

MASK_ALL                equ INT_ALLDISABLED
MASK_NONE               equ INT_ALLENABLED

FILTER_INDIVIDUAL       equ 0001b                   ; individual address
FILTER_MULTICAST        equ 0010b                   ; multicast/group addresses
FILTER_BROADCAST        equ 0100b                   ; broadcast address
FILTER_PROMISCUOUS      equ 1000b                   ; promiscuous mode

RXEARLY_DISABLED        equ 2032                    ; RxEarly to disable

TXAVAIL_DISABLED        equ 2040                    ; TxAvailable to disable
TXAVAIL_MIN             equ 4

TXSTART_DISABLED        equ 2040                    ; TxStart to disable
TXSTART_MIN             equ 0
MAX_TXSTART             equ TXSTART_DISABLED

TXRECLAIM_DISABLED      equ 1792                    ; TxReclaim to disable
TXRECLAIM_MIN           equ 256
TXRECLAIM_MAX           equ 1792
TXRECLAIM_INC           equ 256

MASK_AISM_RESET         equ 00010000b               ; mask off auto-init
						    ; reload from EEPROM on
						    ; reset
MASK_HOST_RESET                 equ     00100000b
;
; start dma command bits
;
DMA_UPLOAD              equ 00h
DMA_DOWNLOAD            equ 01h

MAX_RXLENGTH            equ 1792                    ; maximum rxlength

TXRXRESET_ALLBUTBM      equ 01000000b               ; Tx/Rx reset all but bus master ;

; Transmit Preamble
;
PREAMBLESIZE            equ 4                       ; transmit preamble size
TXP_INTONSUCCESS        equ 8000h                   ; interrupt on successful tx

;
; bits in MasterStatus
;
MS_INPROGRESS       equ 8000h                   ; bus master operation in progress
MS_UPLOAD           equ 4000h                   ; upload complete/ack
MS_DOWNLOAD         equ 1000h                   ; download complete/ack
MS_MASTERABORT      equ 0001h                   ; no response from slave
MS_TARGETABORT      equ 0002h                   ; aborted by slave


;
; Bits in various diagnostics registers
;
MEDIA_TP                equ 8000h                   ; TP transciever
MEDIA_BNC               equ 4000h                   ; Thinnet transciever
MEDIA_INTENDEC          equ 2000h                   ; internal encoder/decoder
;MEDIA_SQE               equ 1000h                   ; SQE present
MEDIA_TXINPROG          equ 1000h                   ;
MEDIA_LBEAT             equ 0800h                   ; link beat ok (TP)
MEDIA_POLARITY          equ 0400h                   ; polarity (TP)
MEDIA_JABBER            equ 0200h                   ; jabber (TP)
MEDIA_UNSQUELCH         equ 0100h                   ; unsquelch (TP)
MEDIA_LBEATENABLE       equ 0080h                   ; link beat enable (TP)
MEDIA_JABBERENABLE      equ 0040h                   ; jabber enable (TP)
MEDIA_CRS               equ 0020h                   ; carrier sense
MEDIA_COLLISION         equ 0010h                   ; collision
MEDIA_SQEENABLE         equ 0008h                   ; enable SQE statistics
MEDIA_CRCSTRIPDISABLE   equ 0004h                   ; disable Rx CRC stripping
MEDIA_DATARATE100       equ 0002h                   ; operating at 100Mbps

MEDIA_XCVRBITS          equ MEDIA_LBEATENABLE+MEDIA_JABBERENABLE+MEDIA_SQEENABLE


NETD_NOLOOPBACK_MASK    equ 0FFFh                   ; no loopbacks
NETD_EXTLOOPBACK        equ 8000h                   ; TP external loopback
NETD_ENDECLOOPBACK      equ 4000h                   ; ENDEC loopback
NETD_MACLOOPBACK        equ 2000h                   ; ethernet core loopback
NETD_FIFOLOOPBACK       equ 1000h                   ; FIFO loopback
NETD_TXENABLED          equ 0800h                   ; tx enabled
NETD_RXENABLED          equ 0400h                   ; rx enabled
NETD_TXTRANSMITTING     equ 0200h                   ; tx transmitting
NETD_TXRESETREQD        equ 0100h                   ; tx reset required
NETD_ASICREV            equ 003Eh                   ; ASIC revision

NETD_ASICREV_SHIFT      equ 1                       ; shr 1 to get revision

FIFOD_RXRECEIVING       equ 8000h                   ; rx receiveing
FIFOD_RXUNDERRUN        equ 2000h                   ; rx underrun
FIFOD_RXSTATUSOVER      equ 1000h                   ; rx status overrun
FIFOD_RXOVERRUN         equ 0800h                   ; rx overrun
FIFOD_TXOVERRUN         equ 0400h                   ; tx overrun
FIFOD_BISTRESULTS       equ 00FFh                   ; BIST results (mask)

SLING_TXUNDERRUN        equ 2000h                   ; Slingshot TxUnderrun bit
;
; bits in MacControl
;
MACC_DEFEREXTEND    equ 0010h
MACC_FULLDUPLEX     equ 0020h
MACC_ALLOWLARGE     equ 0040h
;
; Capabilities bits
;
SUPPORTS_FULLDUPLEX     equ 0002h
SUPPORTS_LARGEPACKETS   equ 0004h
SUPPORTS_FRAGBUSMASTER  equ 0040h
SUPPORTS_100MBPS        equ 1000h


;
; board identification codes
;
EISA_MANUFACTURER_ID    equ 06D50h                  ; EISA manufacturer code

EISA_10_100_ID          equ 07059h                  ; Product ID for EISA board
EISA_10_ONLY_ID         equ 02059h                  ; Product ID for EISA board
PRODUCT_ID_MASK         equ 0F0FFh                  ; Mask off revision nibble

ISAID_TP                equ 5090h                   ; ISA Product ID: TP/AUI
ISAID_BNC               equ 5091h                   ; ISA Product ID: BNC/AUI
ISAID_COMBO             equ 5094h                   ; ISA Product ID: Combo
ISAID_TPONLY            equ 5095h                   ; ISA Product ID: TP only

EISAID_TP               equ 5092h                   ; EISA Product ID: TP/AUI
EISAID_BNC              equ 5093h                   ; EISA Product ID: BNC/AUI
EISAID_COMBO            equ 5096h                   ; EISA Product ID: Combo (future)
EISAID_TPONLY           equ 5097h                   ; EISA Product ID: TP only (future)

MCAID_BNC               equ 627Ch                   ; MCA Adapter ID: BNC/AUI
MCAID_TP                equ 627Dh                   ; MCA Adapter ID: TP/AUI
MCAID_COMBO             equ 61DBh                   ; MCA Adapter ID: Combo (future)
MCAID_TPCOAX            equ 62F6h                   ; MCA Adapter ID: TP/COAX (future)
MCAID_TPONLY            equ 62F7h                   ; MCA Adapter ID: TP only (future)
;
; EEProm access
;
EE_BUSY                     equ 8000h                   ; EEProm busy bit in EECmd
EE_TCOM_NODE_ADDR_WORD0     equ 00h
EE_TCOM_NODE_ADDR_WORD1     equ 01h
EE_TCOM_NODE_ADDR_WORD2     equ 02h
EE_VULCAN_PROD_ID           equ 03h
EE_MANUFACTURING_DATA       equ 04h
EE_SERIAL_NUMBER_WORD0      equ 05h
EE_SERIAL_NUMBER_WORD1      equ 06h
EE_MANUFACTURER_CODE        equ 07h
EE_ADDR_CONFIGURATION       equ 08h
EE_RESOURCE_CONFIGURATION   equ 09h
EE_OEM_NODE_ADDR_WORD0      equ 0Ah
EE_OEM_NODE_ADDR_WORD1      equ 0Bh
EE_OEM_NODE_ADDR_WORD2      equ 0Ch
EE_SOFTWARE_CONFIG_INFO     equ 0Dh
EE_CWORD                    equ 0Eh
EE_SOFTWARE_CONFIG_INFO2    equ 0Fh
EE_CAPABILITY_WORD          equ 10h

EE_INT_CONFIG_0             equ 12h
EE_INT_CONFIG_1             equ 13h

EE_MII_SELECT		    equ 15h
EE_MII_SELECT_MASK	    equ 000Fh
;
; contention logic
;
ID_PORT                 equ 110h
READ_EEPROM             equ 080h
SET_TAG_REGISTER        equ 0D0h
TEST_TAG_REGISTER       equ 0D8h
ACTIVATE_AND_SET_IO     equ 0E0h
ACTIVATE_VULCAN         equ 0FFh
;
; Resource Configuration Register bits
;
RCONFIG_IRQ             equ 0F000h
RCONFIG_SYNCH           equ 00040h
;
; Address Configuration Register bits
;
ACONFIG_XCVR            equ 0C000h
ACONFIG_IOBASE          equ 0001Fh

IOBASE_EISA             equ 0001Fh

TP_XCVR                 equ 00000h
BNC_XCVR                equ 0C000h
AUI_XCVR                equ 04000h

ICH_AUTOSELECT          equ 100h              ; Internal Config word 1 autosel

MIN_IO_BASE_ADDR        equ 200h
MAX_IO_BASE_ADDR        equ 3F0h
REGISTER_SET_SIZE       equ 10h
;
; Software Configuration Register bits
;
SW_OPTIMIZE             equ 0030h
SW_MAXCLI               equ 3F00h
SW_LINKBEAT             equ 4000h
SW_FULLDUPLEX           equ 8000h

SW_BPROT		equ 00007h
SW_CONFIG		equ 00008h		; NOT assigned yet 0=enable, 1=disable
SW_DEFAULT		equ 040h		; 0 = network, 1 = disable
SW_RS			equ 080h		; 1 = enable, 0=disable
SW_LOCALBOOT		equ 0100h		; 1 = Enable, 0 = Disable
SW_BOOTWARE		equ SW_BPROT OR SW_CONFIG OR SW_DEFAULT OR SW_RS OR SW_LOCALBOOT	 ; all the bits assigned to BootWare

;
; Possibilities for SW_OPTIMIZE
;
OPTIMIZE_DOS_CLIENT     equ 0010h
OPTIMIZE_WINDOWS_CLIENT equ 0020h
OPTIMIZE_SERVER         equ 0030h
;
; Configuration Control Register bits
;
ENABLE_ADAPTER          equ 01h
					     ; CCR High-Byte Masks

AUI_AVAIL               equ 20h              ; CCR Bit 13: AUI Available
BNC_AVAIL               equ 10h              ; CCR Bit 12: BNC Available
TP_AVAIL                equ 02h              ; CCR Bit  9: TP  Available

;
;       Capabilities Word Mask Definitions
;
PNP_SUPPORT_MASK        equ     0001h
;
; V2 Internal Configuration Register bits
;
PNP_ENABLE_MASK         equ 0008h
ID_ENABLE_MASK          equ 0004h
PNP_AND_ID_MASK         equ 000Ch

PNP_ENABLE              equ 0008h
ID_ENABLE               equ 0004h

TXCOMPLETE_INT          equ 8000h            ; Interrupt on Tx Complete
TEST_PKT_LEN            equ 14               ; Loop Back Test Packet Length
MAX_RETRY_AUTOSEL       equ 3                ; Auto-Selection Test Max Retry

;
; Bus Types
;
BUS_UNKNOWN             equ     0
BUS_ISA                 equ     1
BUS_EISA                equ     2
BUS_PCI                 equ     3
BUS_EISA_PCI		equ	5

;
; adapter codes                                  ; 10/19/94
;
ACODE_PCI_10_TPO        equ     42
ACODE_PCI_10_COMBO      equ     43
ACODE_EISA_10_TPO       equ     44
ACODE_EISA_10_COMBO     equ     45
ACODE_PCI_100_TX        equ     46
ACODE_EISA_100_TX       equ     47
ACODE_PCI_T4		equ	63

;
; offsets in PCI configuration space
;
PCIC_INTERRUPTLINE      equ     003Ch
PCIC_BIOSROMCONTROL     equ     0030h
PCIC_IOBASE             equ     0010h
PCIC_LATENCYTIMER       equ     000Dh
PCIC_STATUS             equ     0006h
PCIC_COMMAND            equ     0004h
PCIC_DEVICEID           equ     0002h
PCIC_VENDORID           equ     0000h
;
; bits in PciCommand
;
PCIC_IOENABLE           equ     00001h
PCIC_BMENABLE           equ     00004h
;
; bits in LatencyTimer
;
LATE_MAX                equ     255
LATE_MASK               equ     (NOT 7)

BIND_BYTES              equ     1500
MAX_RXBYTES             equ     1792
;
; Possible values for Bus Master Lock
;
BMLOCK_UNLOCKED   equ   0
BMLOCK_RX         equ   1
BMLOCK_TX         equ   2
BMLOCK_DISABLE    equ   3

; 940923 ModeBits, contains system & adapter setting
ModeV2		equ	1
ModeNonISA	equ	4
ModeMCA		equ	8
ModeEISA	equ	10h
ModePCI		equ	20h
ModePnP		equ	40h
ModeAtmel	equ	80h

; RomControl register bits (select 16K ROM Page) Windows 3/Port 5
RomPage0		equ	0
RomPage1		equ	100h
RomPage2		equ	200h
RomPage3		equ	300h
RomPageMask		equ	0fcffh


;
; Possible values for SW_BPROT
;
BOOTPROT_UNINIT 	equ 0	; means "virgin" board. Default to 802.2
BOOTPROT_NW_8022	equ 1
BOOTPROT_NW_EII 	equ 2
BOOTPROT_NW_8023	equ 3
BOOTPROT_RPL		equ 4
BOOTPROT_TCPIP		equ 5
BOOTPROT_BOOTP_ARP	equ 6	; for V1 only. Can use Atmel for V2


; Current Fail and Warning Level
LEVEL_FAIL		equ	0		; current Fail Level
LEVEL_WARNING		equ	0		; current Warning Level

;IF CABLE_DISCONNECT
CABLE_TP          equ   0
CABLE_COAX        equ   1
;ENDIF

; constants for 3COM PCI device ID and vendor ID

PCI_V3_DEVICE_ID        equ     5950h
PCI_3COM_ID             equ     10b7h
PCI_DEVICEID_MASK       equ 0FF00h                  ; mask off last digit/rev
PCI_DEVICEID            equ 05900h                  ; PCI Device ID (masked)

; PCI BIOS function code

PCI_FUNCTION_ID         equ     0b1h
PCI_BIOS_PRESENT        equ     001h
FIND_PCI_DEVICE         equ     002h
READ_CONFIG_BYTE        equ     008h
READ_CONFIG_WORD        equ     009h
READ_CONFIG_DWORD       equ     00ah
WRITE_CONFIG_BYTE	equ	0bh
WRITE_CONFIG_WORD	equ	0Ch
WRITE_CONFIG_DWORD	equ	0Dh

; PCI BIOS function return code

PCI_CALL_SUCCESSFUL     equ     00h
PCI_DEVICE_NOT_FOUND    equ     86h
PCI_BAD_VENDOR_ID       equ     83h

; 3Com PCI configuration space

PCIC_STATUS             equ     0006h
PCIC_COMMAND            equ     0004h
PCIC_DEVICEID           equ     0002h
PCIC_VENDORID           equ     0000h
CFGREG_PCIC_COMMAND     equ     0004h
CFGREG_IOBASE           equ     010h
CFGREG_INTLINE          equ     03ch
CFGREG_INTERNALCFG      equ     040h
CFGREG_BIOSROMCONTROL   equ     030h

;
; bits in PciCommand
;
PCIC_IOENABLE           equ     00001h
PCIC_BMENABLE           equ     00004h
;
; adapter codes
;
ACODE_PCI_10_TPO        equ     42
ACODE_PCI_10_COMBO      equ     43
ACODE_EISA_10_TPO       equ     44
ACODE_EISA_10_COMBO     equ     45
ACODE_PCI_100_TX        equ     46
ACODE_EISA_100_TX       equ     47

;IF CABLE_DISCONNECT
CABLE_TP          equ   0
CABLE_COAX        equ   1
;ENDIF

;------ Structures ----------------------------------------------------------;
;
; TxStart structure.  Padded to 16 bytes for easy indexing.
;
TxStartStruc    struc
txs_thresh      dw      ?               ; TxStart threshold (+CMD_SETTXSTART)
txs_value       dw      ?               ; value, no cmd, unscaled
txs_min         dw      ?               ; minimum threshold, this bin
txs_count       dw      ?               ; packets since last underrun
txs_uN          dw      ?               ; number of entries in uSum
txs_uSum        dw      ?               ; sum of uN x packets between underruns
txs_pad         dw      ?               ; pad to 16 bytes
txs_marker      dw      ?               ; pad to 16 bytes, marker for debug
TxStartStruc    ends

SIZE_TxStart    equ     SIZE TxStartStruc
;
; constants used by the TxStart algorithm
;
; these are currently set up for 4 bins.  none of these variables can be
; changed independently!
;
; we assign packets to bins based on packet size.  here we set up 4 bins 512
; bytes in size.  these bins cover packets of size:
;
;           Bin     Size Range          Mid-Point
;           0       0-255 bytes         128
;           1       256-767 bytes       512
;           2       768-1279 bytes      1024
;           3       1280-1768 bytes     1536
;
; Bin 0 should collect all of the small packets, most likely a lot
; of 60-100 byte packets.  Bin 1 will likely be mostly empty unless
; some protocol is using 512 byte packets.  Bin 2 should contain all
; of the 1024-1100 byte packets (IPX for example).  And Bin 3 should
; contain the full-size packets, mostly high 1400's to 1514.
;
TXBIN_COUNT             equ     4               ; four bins
TXBIN_WIDTH             equ     512             ; 512 bytes wide
TXBIN_OFFSET            equ     256             ; first bin starts at -OFFSET
;
; these are used to convert a packet size to an index into a TxStart array
; where each TxStart entry in the array is 16 bytes in size.
;
TXBIN_ADD               equ     (TXBIN_WIDTH/2) ; size+ADD
TXBIN_SHIFT             equ     5               ; (size+ADD) >> SHIFT
TXBIN_MASK              equ     0110000b        ; ((size+ADD) >> SHIFT) AND MASK
;
; this value is used to adjust an index from PioTxStart into MasterTxStart
; which is assumed to follow it immediately.
;
TXBIN_MASTER_OFFSET     equ     (TXBIN_COUNT * SIZE_TxStart)


;------ VDS Stuff -----------------------------------------------------------;
;
; a flag to test in the BIOS data segment.  if set, must use VDS.  if not,
; you can compute physical addresses by (segment << 4) + offset.
;
VDS_FLAG_SEG        equ     0040h
VDS_FLAG_OFF        equ     007Bh
VDS_FLAG_TEST       equ     20h                 ; if set, use VDS
;
; the VDS interrupt
;
VDS_INT             equ     04Bh
;
; VDS functions (into AX)
;
VDS_SCATTER_LOCK    equ     8105h               ; scatter/gather lock region
VDS_SCATTER_UNLOCK  equ     8106h               ; scatter/gather unlock region

;
; MII register definitions.   The following are definitions of the standard
; MII registers, common to all implementations of the MII interface.
;
MII_PHY_CONTROL     equ    0       ; control reg address
MII_PHY_STATUS      equ    1       ; status reg address
MII_PHY_OUI         equ    2       ; most of the OUI bits
MII_PHY_MODEL       equ    3       ; model/rev bits, and rest of OUI
MII_PHY_ANAR        equ    4       ; AutoNegotiation Adverisement Register
MII_PHY_ANLPAR      equ    5       ; AutoNegotiation Link Partner Ability Reg.
MII_PHY_ANER        equ    6       ; AutoNegotiation Expantion Reg.
MII_PHY_PAR         equ    19h     ; PHY Address Register
MII_EXT_REG0	    equ    10h     ; Broadcom chip extended register 0
MII_BCM_EXTREG0     equ    10h     ; Broadcom chip extended register 0
MII_EXT_REG1        equ    14h     ; Broadcom chip extended register 1
MII_BCM_EXTREG1     equ    14h     ; Broadcom chip extended register 1
MII_PHY_PCR	    equ    17h	   ; PCS Configuration Reg.
;
; bit fields in the standard MII control register
;
MII_CTL_RESET       equ    8000h   ; reset bit in control reg
MII_CTL_100MB       equ    2000h   ; 100Mbit or 10 Mbit flag
MII_CTL_ENABLE_AUTO equ    1000h   ; autonegotiate enable
MII_CTL_ISOLATE     equ    0400h   ; islolate bit
MII_CTL_START_AUTO  equ    0200h   ; restart autonegotiate
MII_CTL_FULL_DUPLEX equ    0100h   ; enable full duplex
;
; bit fields in the standard MII status register
;
MII_STS_100MB_MASK  equ    0E000h  ; any of these indicate 100 Mbit
MII_STS_10MB_MASK   equ    1800h   ; either of these indicate 10 Mbit
MII_STS_100BASET4   equ    08000h  ; 100BaseT4
MII_STS_100BASEX_FD equ    04000h  ; 100BaseX Full Duplex
MII_STS_100BASEX_HD equ    02000h  ; 100BaseX Half Duplex
MII_STS_10BASET_FD  equ    01000h  ; 10BaseT Full Duplex
MII_STS_10BASET_HD  equ    0800h   ; 10BaseT Half Duplex
MII_STS_AUTO_DONE   equ    0020h   ; auto negotiation complete
MII_STS_AUTO        equ    0008h   ; auto negotiation is available
MII_STS_LINK_UP     equ    0004h   ; link status bit
MII_STS_EXTENDED    equ    0001h   ; extended regs exist
;
; bit fields in the extended MII auto-negotiation link partner ability reg.
; bit 5-12 are technology ability bits in MII spec.
; national n-way uses bit 5-9 only.
;
MII_ANLPAR_100BASET4   equ    0200h  ; 100BaseT4
MII_ANLPAR_100BASEX_FD equ    0100h  ; 100BaseX Full Duplex
MII_ANLPAR_100BASEX_HD equ    0080h  ; 100BaseX Half Duplex
MII_ANLPAR_10BASET_FD  equ    0040h  ; 10BaseT Full Duplex
MII_ANLPAR_10BASET_HD  equ    0020h  ; 10BaseT Half Duplex
;
; Physical Management bits
;
MGMT_PHY_CLOCK      equ    0001h
MGMT_PHY_DATA1      equ    0002h
MGMT_PHY_WRITE      equ    0004h
;
; MiiPhyUsed
;
MII_100BASET4       equ    1       ; 100BaseT4
MII_100BASEX_FD     equ    2       ; 100BaseX Full Duplex
MII_100BASEX_HD     equ    3       ; 100BaseX Half Duplex
MII_10BASET_FD      equ    4       ; 10BaseT Full Duplex
MII_10BASET_HD      equ    5       ; 10BaseT Half Duplex
;
; bit field in the extended register 0 for broadcom
MII_EXT_SPEED	       equ    0002h  ; Speed Indication (1=100, 0=10)
;
; Phy addr
;
NWAY		    equ    18h
T4		    equ    01h

;
; The structure filled in by INT 4B
;
PhysicalMapStruc   struc

VirtualSizeLo      dw        0
VirtualSizeHi      dw        0
LinearOffsetLo     dw        0
LinearOffsetHi     dw        0
LinearSegment      dw        0
		   dw        0
SegsProvided       dw        3
SegsNeeded         dw        0

PhysAddLo          dw        0
PhysAddHi          dw        0
PhysLenLo          dw        0
PhysLenHi          dw        0

Phys1AdrLo         dw        0
Phys1AdrHi         dw        0
Phys1LenLo         dw        0
Phys1LenHi         dw        0

Phys2AdrLo         dw        0
Phys2AdrHi         dw        0
Phys2LenLo         dw        0
Phys2LenHi         dw        0

PhysicalMapStruc   ends

PhysicalArrayStruc struc
PhysAAdrLo         dw        0
PhysAAdrHi         dw        0
PhysALenLo         dw        0
PhysALenHi         dw        0
PhysicalArrayStruc ends

;
; SelectWindow - select register window specified (must be a constant)
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
SelectWindow macro  wno
		mov	ax, CMD_SELECTWINDOW + wno 
		out     dx, ax
endm


;------ GENERAL.INC ---------------------------------------------------------;
;                                                                            ;
;       General purpose equates, structures and macros.                      ;
;                                                                            ;
;----------------------------------------------------------------------------;

;
; I/O ports for the PICs
;
MASTER_MASK_PORT equ    021h
SLAVE_MASK_PORT equ     0A1h
;
; DOUBLEWORD - Thirty-two bit double word layout for sixteen bit word access
;
doubleword      struc
loword          dw      0               ; low order word
hiword          dw      0               ; high order word
doubleword      ends

;
; FARPOINTER - Thirty-two bit 286-style far pointer layout for segment and
;              offset access
;
farpointer      struc
off             dw      0               ; offset
segm            dw      0               ; segment or selector
farpointer      ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\bwnad.inc ===
;====================================================================
; BWNAD.INC
;
; Include for for BootWare NAD modules.
;
; 970116 PC - first version
;====================================================================

;--------------------------------------------------------------------
; Include the common structures.
;--------------------------------------------------------------------

IFDEF _IDEAL_
	include "bwstruct.inc"
ELSE
	include bwstruct.inc

ENDIF

;--------------------------------------------------------------------
; NAD publics
;--------------------------------------------------------------------
public	NADGetBootInfo
public	NADInitialize
public	NADConfig
public	NADStart
public	LanOption

IFDEF _IDEAL_
	include "bwequ.inc"
ELSE
	include bwequ.inc

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\bwstruct.inc ===
;====================================================================
; BWSTRUCT.INC
;
; Include for for BootWare, defines common structures.
;
; 970116 PC - first version
;====================================================================

;--------------------------------------------------------------------
; Common equates
;---------------------------------------------------------------------
FEATURE_LOCAL	equ	1
FEATURE_VIRUS	equ	2
FEATURE_MENU	equ	4
FEATURE_KEYWAIT	equ	8
FEATURE_FLOPPY	equ	64
FEATURE_HDRIVE	equ	128

;--------------------------------------------------------------------
; Event Descriptor (ED) Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc	ED
	Ptr		dw	?	; pointer to next ED
	Unused		dw	?	; spare word
	DestAddr	dw	?, ?, ?	; destination Address
	ErrCode		dw	?	; error code
	ErrMsg		dw	?	; pointer to error msg
	Length		dw	?	; total packet length
	FragCount	dw	?	; number of fragments
	FragOff		dw	?	; 1st fragment offset
	FragSeg		dw	?	; 1st fragment segment
	FragLen 	dw	?	; length of fragment
ends
ELSE
ED_Struct      STRUC
	ED_Ptr		dw	?	; pointer to next ED
	ED_Unused	dw	?	; spare word
	ED_DestAddr	dw	?, ?, ?	; destination address
	ED_ErrCode	dw	?       ; error code
	ED_ErrMsg	dw	?       ; Pointer to error msg
	ED_Length	dw	?	; total packet length
	ED_FragCount	dw	?	; Number of descriptors/fragments
	ED_FragOff	dw	?	; Descriptor Pointer
	ED_FragSeg	dw	?	; Descriptor Pointer
	ED_FragLen 	dw	?	; Length of packet descriptor
ED_Struct      ENDS
ENDIF

;--------------------------------------------------------------------
; Descricptor Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc Frag
	Off		dw	?	; offset of fragment
	Seg		dw	?	; segment of fragment
	Len		dw	?	; length of fragment
ends
ELSE
Frag Struc
	FragOff		dw	?	; offset of fragment
	FragSeg		dw	?	; segment of fragment
	FragLen		dw	?	; length of fragment
Frag ends
Descript_Struct STRUC
	DPointer	dd	?	; Descriptor Pointer
	DLen		dw	?	; Length of packet descriptor
Descript_Struct ends
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\boom.inc ===
;------ BOOM.INC ------------------------------------------------------------;
;									     ;
;	This file contains Boomerang specific equates, structures and	     ;
;	macros. It must be assembled with MASM 5.1 or later.		     ;
;									     ;
;									     ;
;----------------------------------------------------------------------------;
;----------------------------------------------------------------------------;
;									     ;
;	This source file is the property of 3Com Corporation and may not be  ;
;	copied or distributed in any isomorphic form without an appropriate  ;
;	prior licensing arrangement with 3Com Corporation.		     ;
;									     ;
;	Copyright (c) 1994 3Com Corporation				     ;
;									     ;
;	3Com Corporation						     ;
;	5400 Bayfront Plaza, P.O. Box 58145				     ;
;	Santa Clara, CA 95052-8145 USA					     ;
;	(408) 764-6016							     ;
;									     ;
;----------------------------------------------------------------------------;
;----------------------------------------------------------------------------;
;									     ;
;	Revision History:						     ;
;									     ;
;	11-95 Sidenblad 						     ;
;	Original version adapted from V3.INC				     ;
;									     ;
;	6-96 Elaine Mar 						     ;
;	Clean up done							     ;
;									     ;
;----------------------------------------------------------------------------;

;
; the compatibility level of this driver
;
CLEVEL		    equ 0
;
; number of I/O ports used
;
REGISTER_SET_SIZE   equ 64

;------ Equates -------------------------------------------------------------;
;
; Command code masks
;
CMD_CMDMASK	    equ 0F800h			; command bits
CMD_ARGMASK	    equ 007FFh			; argument bits
;
; Command codes, word form
;
CMD_GLOBALRESET     equ 00000b shl 11		; global reset
CMD_SELECTWINDOW    equ 00001B shl 11		; select register window
CMD_STARTINTXCVR    equ 00010b shl 11		; start internal transciver
CMD_RXDISABLE	    equ 00011b shl 11		; rx disable
CMD_RXENABLE	    equ 00100b shl 11		; rx enable
CMD_STALLCTL	    equ 00110b shl 11		; scatter/gather stall control
CMD_RXRESET	    equ 00101b shl 11		; rx reset
CMD_TXDONE	    equ 00111b shl 11		; tx done
CMD_RXDISCARD	    equ 01000b shl 11		; rx discard top packet
CMD_TXENABLE	    equ 01001b shl 11		; tx enable
CMD_TXDISABLE	    equ 01010b shl 11		; tx disable
CMD_TXRESET	    equ 01011b shl 11		; tx reset
CMD_REQUESTINT	    equ 01100b shl 11		; request interrupt
CMD_ACKNOWLEDGE     equ 01101b shl 11		; acknowledge interrupt
CMD_SETINTMASK	    equ 01110b shl 11		; set interrupt mask
CMD_SETRZMASK	    equ 01111b shl 11		; set read zero mask
CMD_SETRXFILTER     equ 10000b shl 11		; set rx filter
CMD_SETRXEARLY	    equ 10001b shl 11		; set rx early threshold
CMD_SETTXAVAILABLE  equ 10010b shl 11		; set tx available threshold
CMD_SETTXSTART	    equ 10011b shl 11		; set tx start threshold
CMD_STARTDMA	    equ 10100b shl 11		; start dma upload/download
CMD_STATSENABLE     equ 10101b shl 11		; statistics enable
CMD_STATSDISABLE    equ 10110b shl 11		; statistics disable
CMD_STOPINTXCVR     equ 10111b shl 11		; start internal transciver
CMD_SETHASHFILTER   equ 11001b shl 11		; set hash filter bit
;
; Command codes, hibyte form (commands without operands only)
;
CMDH_STARTINTXCVR   equ CMD_STARTINTXCVR shr 8
CMDH_RXDISABLE	    equ CMD_RXDISABLE shr 8
CMDH_RXENABLE	    equ CMD_RXENABLE shr 8
CMDH_STALLCTL	    equ CMD_STALLCTL shr 8
CMDH_TXDONE	    equ CMD_TXDONE shr 8
CMDH_RXDISCARD	    equ CMD_RXDISCARD shr 8
CMDH_TXENABLE	    equ CMD_TXENABLE shr 8
CMDH_TXDISABLE	    equ CMD_TXDISABLE shr 8
CMDH_REQUESTINT     equ CMD_REQUESTINT shr 8
CMDH_STATSENABLE    equ CMD_STATSENABLE shr 8
CMDH_STATSDISABLE   equ CMD_STATSDISABLE shr 8
CMDH_STOPINTXCVR    equ CMD_STOPINTXCVR shr 8
;
; Status register bits (INT for interrupt sources, ST for the rest)
;
INT_LATCH	    equ 00001h			; interrupt latch
INT_ADAPTERFAIL     equ 00002h			; adapter failure
INT_TXCOMPLETE	    equ 00004h			; tx complete
;INT_TXAVAILABLE     equ 00008h			; tx available
INT_RXCOMPLETE	    equ 00010h			; rx complete
INT_RXEARLY	    equ 00020h			; rx early
INT_REQUESTED	    equ 00040h			; interrupt requested
INT_UPDATESTATS     equ 00080h			; update statistics
INT_DMADONE	    equ 00100h			; V3 bus master complete
INT_DNCOMPLETE	    equ 00200h			; Download bus master complete
INT_UPCOMPLETE	    equ 00400h			; Upload bus master complete

ST_DMABUSY	    equ 00800h			; dma in progress
ST_BUSY 	    equ 01000h			; command busy
ST_WINDOW	    equ 0E000h			; window bits (13-15)

INTH_DMADONE	    equ INT_DMADONE shr 8
STH_DMABUSY	    equ ST_DMABUSY shr 8
STH_BUSY	    equ ST_BUSY shr 8
STH_WINDOW	    equ ST_WINDOW shr 8

MASK_ALL	    equ 000000000000b
MASK_NONE	    equ 011011111110b		; actually, V3 bus master
						; masked
MASK_MASTER	    equ 000011111110b		; all bus master masked

ACK_ALL 	    equ 011111111111b		; ack everything

TXRXRESET_ALLBUTDN  equ 0000000101000000b	; Tx/Rx reset all but bus master
						; and download logic
TXRXRESET_ALLBUTBM  equ 0000000001000000b	; Tx/Rx reset all but bus master
;
; PktStatus register bits
;
PS_DNINPROGRESS     equ 0080h			; dnInProgress
;
; RxStatus register bits, both forms
;
RXS_INCOMPLETE	    equ 8000h			; not completely received
RXS_ERROR	    equ 4000h			; error in packet
RXS_LENGTH	    equ 1FFFh			; bytes in RxFIFO

RXSH_INCOMPLETE     equ RXS_INCOMPLETE shr 8
RXSH_ERROR	    equ RXS_ERROR shr 8
;
; RxError register bits
;
RXE_OVERRUN	    equ 0001h
RXE_RUNT	    equ 0002h
RXE_FRAMING	    equ 0004h
RXE_CRC 	    equ 0008h
RXE_OVERSIZE	    equ 0010h
RXE_DRIBBLE	    equ 0080h
RXE_OVERFLOW	    equ 0100h
;
; TxStatus register bits
;
TXS_COMPLETE	    equ 80h			; tx completed
TXS_INTREQUESTED    equ 40h			; interrupt on successfull tx
TXS_ERRTYPE	    equ 3Ch			; error bits
TXS_JABBERERROR     equ 20h			; jabber error
TXS_UNDERRUN	    equ 10h			; tx underrun error
TXS_MAXCOLLISIONS   equ 08h			; max collisions error
TXS_STATUSOVERFLOW  equ 04h			; TX status stack is full
;
; start dma command bits
;
DMA_UPLOAD	    equ 00h
DMA_DOWNLOAD	    equ 01h
;
; Stall/unstall scatter/gather command bits
;
UP_STALL	    equ 000b
UP_UNSTALL	    equ 001b
DN_STALL	    equ 010b
DN_UNSTALL	    equ 011b
FRAGLAST	    equ 80000000h		; last frag. indicator in dnFraglen
FSH_DNCOMPLETE	    equ 0001h			; dnComplete in FSH
;
; PktStatus/DMACtrl register bits
UPPKTCOMPLETE	    equ 8000h
COUNTERSPEED_10     equ 0100h			; bit 8 = 1  10 MB
COUNTERSPEED_100    equ 0000h			; bit 8 = 0  100 Mb
UPRXEARLYENABLE     equ 0020h
DNCOMPLETE	    equ 0010h			;
UPCOMPLETE	    equ 0008h
;
; InternalConfig register bits
;
ICL_RAMSIZE_MASK    equ 0007h
RAM_8K		    equ 000b
RAM_32K 	    equ 010b
RAM_64K 	    equ 011b
RAM_128K	    equ 100b

ICL_RAM16BIT	    equ 0008h			; set if word wide ram

ICH_RAMPART_MASK    equ 0003h
PART_5TO3	    equ 00b
PART_3TO1	    equ 01b
PART_1TO1	    equ 10b

;ICH_XCVR_MASK	     equ 0070h			 ; transceiver select
ICH_XCVR_MASK	    equ 00F0h			; transceiver select
ICH_XCVR_SHIFT	    equ 4

ICH_AUTOSELECT	    equ 0100h			; auto-select bit
;
; transceiver types
;
XCVR_10TP	    equ 000b			; 10BaseT/TP
XCVR_10AUI	    equ 001b			; 10Mbps AUI
XCVR_10BNC	    equ 011b			; 10Base2/Coax/BNC
XCVR_100TX	    equ 100b			; 100BaseTX (scrambled)
XCVR_100FX	    equ 101b			; 100BaseFX (unscrambled)
XCVR_MII	    equ 110b			; MII
XCVR_AUTO	    equ 1000b			; Cyclone autonegotiation
;
; bits in ResetOptions
;
RO_AVAILBITS	    equ 00FFh

RO_BASET4	    equ 0001h
RO_BASETX	    equ 0002h
RO_BASEFX	    equ 0004h
RO_TP		    equ 0008h
RO_COAX 	    equ 0010h
RO_AUI		    equ 0020h
RO_MII		    equ 0040h
RO_BASEFL	    equ 0100h		;980514
;
; Window Numbers
;
WNO_SETUP	    equ 0			; setup/configuration
WNO_OPERATING	    equ 1			; operating set
WNO_STATIONADDRESS  equ 2			; station address setup/read
WNO_FIFO	    equ 3			; FIFO management
WNO_DIAGNOSTICS     equ 4			; diagnostics
WNO_READABLE	    equ 5			; registers set by commands
WNO_STATISTICS	    equ 6			; statistics
WNO_BUSMASTER	    equ 7			; bus master stuff
comment %
;
; Port offsets, Window 1.  Set up for the alternate decode.
;
PORT_CmdStatus	    equ 0Eh			; command/status
PORT_TxFree	    equ 1Ch			; free transmit bytes
PORT_TxStatus	    equ 1Bh			; transmit status (byte)
;PORT_TxStatus	     equ 0Bh			 ; transmit status (byte)
PORT_Timer	    equ 1Ah			; latency timer (byte)
PORT_RxStatus	    equ 18h			; receive status
PORT_RxError	    equ 14h			; receive error bits
PORT_RxFIFO	    equ 10h			; RxFIFO read
PORT_TxFIFO	    equ 10h			; TxFIFO write
; cyclone changes
PORT_TxPktID	    equ 18h			; Tx Packed ID
PORT_IntStatusAuto  equ 1Eh
;
; Port offsets, Window 0
;
PORT_EEData	    equ 0Ch
PORT_EECmd	    equ 0Ah			; EEProm command register
PORT_CfgResource    equ 08h			; resource configuration (EISA)
PORT_CfgAddress     equ 06h			; address configuration (EISA)
PORT_CfgControl     equ 04h			; configuration control (EISA)
PORT_ProductID	    equ 02h			; product id (EISA)
PORT_Manufacturer   equ 00h			; manufacturer code (EISA)
; Cyclone specific
PORT_BiosRomData    equ 08h			; data port for direct I/O to BIOS
PORT_BiosRomAddr    equ 04h			; addr. port for I/O to BIOS
;
; Port offsets, Window 2
;
PORT_SA0_1	    equ 00h			; station address bytes 0,1
PORT_SA2_3	    equ 02h			; station address bytes 2,3
PORT_SA4_5	    equ 04h			; station address bytes 4,5
PORT_SM0_1	    equ 06h			; station mask bytes 0,1
PORT_SM2_3	    equ 08h			; station mask bytes 0,1
PORT_SM4_5	    equ 0Ah			; station mask bytes 0,1
; cyclone specific
PORT_cycloneresetoptions equ 0ch		; resetOptions
;
; Port offsets, Window 3
;
PORT_ALT_TxFree     equ 0Ch			; free transmit bytes (dup)
PORT_RxFree	    equ 0Ah			; free receive bytes
PORT_ResetOptions   equ 08h			; ResetOptions
PORT_MacControl     equ 06h			; MacControl
PORT_InternalCfgH   equ 02h			; InternalConfig High
PORT_InternalCfgL   equ 00h			; InternalConfig Low
; cyclone specific
PORT_MediaOptions   equ 08h			; Media Options
PORT_MaxPktSize     equ 04h			; Max pkt for Oversized pkt
;
; Port offsets, Window 4
;
PORT_UpperBytesOk   equ 0Dh			; upper 4 bits of tx bytes ok and rx bytes ok
PORT_BadSsdCount    equ 0Ch			; rx bad frame start stat
PORT_MediaStatus    equ 0Ah			; media type/status
PORT_PhysicalMgmt   equ 08h			; physical management
PORT_NetDiagnostic  equ 06h			; net diagnostic
PORT_FIFODiagnostic equ 04h			; FIFO diagnostic
PORT_VCODiagnostic  equ 02h			; VCO diagnostic
; cyclone specific
PORT_AnalogDiagnostic equ 00h
;
; Port offsets, Window 5
;
PORT_RZMask	    equ 0Ch			; read zero mask
PORT_IntMask	    equ 0Ah			; interrupt mask
PORT_RxFilter	    equ 08h			; receive filter
PORT_RxEarly	    equ 06h			; rx early threshold
PORT_TxAvailable    equ 02h			; tx available threshold
PORT_TxStart	    equ 00h			; tx start threshold
; cyclone specific
PORT_TxReClaim	    equ 09h
;
; Port offsets, Window 6
;
PORT_TXBYTES	    equ 0Ch			; tx bytes ok
PORT_RXBYTES	    equ 0Ah			; rx bytes ok
PORT_UPPERFRAMES    equ 09h			; upper bits of tx/rx frames ok
PORT_TXDEFER	    equ 08h			; tx frames deferred (byte)
PORT_RXFRAMES	    equ 07h			; rx frames ok (byte)
PORT_TXFRAMES	    equ 06h			; tx frames ok (byte)
PORT_RXDISCARDED    equ 05h			; rx frames discarded (byte)
PORT_TXLATE	    equ 04h			; tx frames late coll. (byte)
PORT_TXSINGLE	    equ 03h			; tx frames one coll. (byte)
PORT_TXMULTIPLE     equ 02h			; tx frames mult. coll. (byte)
PORT_TXNOCD	    equ 01h			; tx frames no CDheartbt (byte)
PORT_TXCARRIERLOST  equ 00h			; tx frames carrier lost (byte)
;
; Port offsets, Window 7
;
PORT_MasterStatus   equ 0Ch
PORT_MasterLen	    equ 06h
PORT_MasterAddressH equ 02h
PORT_MasterAddress  equ 00h
; cyclone specific
PORT_VlanMask	    equ 00h
PORT_PowerMgmt	    equ 0ch
;
; Port offsets, Boomerang Extensions
;
PORT_PKTSTATUS	    equ 020h			; scatter/gather state bits
PORT_DNLISTPTR	    equ 024h			; phys addr of current DPD
PORT_FRAGADDR	    equ 028h			; phys addr of current fragment
PORT_FRAGLEN	    equ 02Ch			; current fragment length
PORT_LISTOFF	    equ 02Eh			; current DPD or UPD index
PORT_TXFREETHRESH   equ 02Fh			; minimum TX free
PORT_UPPKTSTATUS    equ 030h			; upload packet status
PORT_COUNTDOWN	    equ 036h			; countdown timer
PORT_UPLISTPTR	    equ 038h			; phys addr of current UPD
; cyclone specific
PORT_DmaCtrl	    equ 20h			; formerly Pktstatus
PORT_DnTgtBurst     equ 2Ah
PORT_DnReq	    equ 2Ch
PORT_DnPoll	    equ 2Dh
PORT_FreeTimer	    equ 34h
PORT_UpReq	    equ 3Ch
PORT_UpPoll	    equ 3Dh
PORT_UpTgtBurst     equ 3Eh
PORT_RealTimeCnt    equ 40h
%
;
; masks for UpperFramesOk
;
UPPER_RXFRAMES_MASK equ 00Fh
UPPER_TXFRAMES_MASK equ 0F0h
UPPER_TXFRAMES_SHIFT equ 4
;
; bits in MasterStatus
;
MS_INPROGRESS	    equ 8000h			; bus master operation in progress
MS_UPLOAD	    equ 4000h			; upload complete/ack
MS_DOWNLOAD	    equ 1000h			; download complete/ack
MS_MASTERABORT	    equ 0001h			; no response from slave
MS_TARGETABORT	    equ 0002h			; aborted by slave
;
; bits in RCR (EISA)
;
RCR_IRQ_MASK	    equ 0F000h
RCR_IRQ_SHIFT	    equ 12
;
; bits in CCR (EISA)
;
CCR_ENABLE	    equ 00001h
;
; bits in MacControl
;
MACC_DEFEREXTEND    equ 0010h
MACC_FULLDUPLEX     equ 0020h
MACC_ALLOWLARGE     equ 0040h
MACC_FLOWCTRL_EN    equ 0100h			; new for cyclone
;
; Various command arguments
;
FILTER_INDIVIDUAL	equ 0001b		    ; individual address
FILTER_MULTICAST	equ 0010b		    ; multicast/group addresses
FILTER_BROADCAST	equ 0100b		    ; broadcast address
FILTER_PROMISCUOUS	equ 1000b		    ; promiscuous mode
FILTER_HASHMULTICAST	equ 10000b		    ; multicast hast

RXEARLY_DISABLED	equ 8188		    ; RxEarly to disable

TXAVAIL_DISABLED	equ 8188		    ; TxAvailable to disable

TXSTART_DISABLED	equ 8188		    ; TxStart to disable
MAX_TXSTART		equ TXSTART_DISABLED
MAXTXSTARTVALUE 	equ 1FFCh
;
; Transmit Preamble
;
PREAMBLESIZE		equ 4			    ; transmit preamble size

PRE_INTONSUCCESS	equ 8000h		    ; interrupt on success
PRE_CRCAPPENDDISABLE	equ 2000h		    ; CRC included
;
; maximum packet that can be received normally
;
MAX_RXBYTES		equ 1792
;
; the size of a receive buffer should be the nearest higher multiple of 64,
; to preserve 64 byte alignment on receive buffers...
;
RX_BUFSIZE		equ (MAX_RXBYTES + 63) AND (NOT 63)
;
; Bits in various diagnostics registers
;
; MediaStatus
;
MEDIA_AUIDISABLE	equ 8000h		    ; on board transceiver selected
MEDIA_DCCONVERTERENABLED equ 4000h		    ; EnableDcConverter done
MEDIA_TXINPROG		equ 1000h		    ; transmit in progress
MEDIA_LBEAT		equ 0800h		    ; link beat ok (TP)
MEDIA_POLARITY		equ 0400h		    ; polarity (TP)
MEDIA_JABBER		equ 0200h		    ; jabber (TP)
MEDIA_LBEATENABLE	equ 0080h		    ; link beat enable (TP)
MEDIA_JABBERENABLE	equ 0040h		    ; jabber enable (TP)
MEDIA_CRS		equ 0020h		    ; carrier sense
MEDIA_COLLISION 	equ 0010h		    ; collision
MEDIA_SQEENABLE 	equ 0008h		    ; enable SQE statistics
MEDIA_CRCSTRIPDISABLE	equ 0004h		    ; disable Rx CRC stripping
MEDIA_DATARATE100	equ 0002h		    ; operating at 100Mbps

MEDIA_XCVRBITS		equ MEDIA_LBEATENABLE+MEDIA_JABBERENABLE+MEDIA_SQEENABLE
;
; NetDiagnostics
;
NETD_NOLOOPBACK_MASK	equ 0FFFh		    ; no loopbacks
NETD_EXTLOOPBACK	equ 8000h		    ; TP external loopback
NETD_ENDECLOOPBACK	equ 4000h		    ; ENDEC loopback
NETD_MACLOOPBACK	equ 2000h		    ; ethernet core loopback
NETD_FIFOLOOPBACK	equ 1000h		    ; FIFO loopback
NETD_TXENABLED		equ 0800h		    ; tx enabled
NETD_RXENABLED		equ 0400h		    ; rx enabled
NETD_TXTRANSMITTING	equ 0200h		    ; tx transmitting (maybe)
NETD_TXRESETREQD	equ 0100h		    ; tx reset required
NETD_STATSENABLED	equ 0080h		    ; statistics enabled
NETD_ASICREV		equ 003Eh		    ; ASIC revision
NETD_ASICREV_SHIFT	equ 1			    ; shr 1 to get revision
NETD_LOWVOLTAGE 	equ 0001h		    ; low voltage detect

FIFOD_RXRECEIVING	equ 8000h		    ; rx receiveing
FIFOD_RXUNDERRUN	equ 2000h		    ; rx underrun
FIFOD_RXOVERRUN 	equ 0800h		    ; rx overrun
FIFOD_TXOVERRUN 	equ 0400h		    ; tx overrun
;
; bits in Cyclone Reset Options
;
STANDARD_ADAPTER	equ 02h 		    ; all adv. features enabled
MOTHERBOARD		equ 00h 		    ; all enable except pkt scheduling
LOW_COST		equ 01h 		    ; adv. features disabled
SERVER_ADAPTER		equ 04h 		    ; same as standard.
;
; board identification codes
;
PCI_VENDORID		equ 010B7h		    ; PCI Vendor ID (3Com)
PCI_DEVICEID_MASK	equ 0FF00h		    ; mask off last digit/rev
PCI_DEVICEID		equ 09000h		    ; PCI Device ID (masked)
PCI_DEVICEID_CYC_TX	equ 09055h		    ; Cyclone TX
PCI_DEVICEID_CYC_T4	equ 09056h		    ; Cyclone T4
PCI_DEVICEID_KRA_TPO	equ 09004h		    ; Krakatau TPO
PCI_DEVICEID_KRA_COMBO	equ 09005h		    ; Krakatau Combo
PCI_DEVICEID_KRA_TPC	equ 09006h		    ; Krakatau TPC
PCI_DEVICEID_BOOM_T4	equ 09051h		    ; Boomerang T4
PCI_DEVICEID_BOOM_TX	equ 09050h		    ; Boomerang TX
PCI_DEVICEID_BOOM_TPO	equ 09000h		    ; Boomerang TPO
PCI_DEVICEID_BOOM_COMBO equ 09001h		    ; Boomerang Combo

;
; EEProm access
;
EE_BUSY 		equ 8000h		    ; EEProm busy bit in EECmd
READ_EEPROM		equ 080h

EE_TCOM_NODE_ADDR_WORD0     equ 00h
EE_TCOM_NODE_ADDR_WORD1     equ 01h
EE_TCOM_NODE_ADDR_WORD2     equ 02h
EE_DEVICE_ID		    equ 03h
EE_MANUFACTURING_DATE	    equ 04h
EE_MANUFACTURING_DIVISION   equ 05h
EE_MANUFACTURING_PRODCODE   equ 06h
EE_PCI_PARMS		    equ 08h
EE_ROM_INFO		    equ 09h
EE_OEM_NODE_ADDR_WORD0	    equ 0Ah
EE_OEM_NODE_ADDR_WORD1	    equ 0Bh
EE_OEM_NODE_ADDR_WORD2	    equ 0Ch
EE_SOFTWARE_INFO	    equ 0Dh
EE_CWORD		    equ 0Eh
EE_SOFTWARE_INFO_2	    equ 0Fh
EE_CAPABILITY_WORD	    equ 10h
EE_INTERNAL_CFG_WORD0	    equ 12h
EE_INTERNAL_CFG_WORD1	    equ 13h
EE_MII_SELECT		    equ 15h
EE_MEDIAOPTIONS		    equ	19h
EE_MII_SELECT_MASK	    equ 000Fh
;
; Software Configuration bits
;
SW_OPTIMIZE		equ 0030h
SW_MAXCLI		equ 3F00h
SW_LINKBEAT		equ 4000h
SW_FULLDUPLEX		equ 8000h
;
; Software Info 2 bits
;
DRIBBLE_10_FIX		equ 0001h
;
; Possibilities for SW_OPTIMIZE
;
OPTIMIZE_NORMAL 	equ 0010h
OPTIMIZE_NETWORK	equ 0020h
OPTIMIZE_CPU		equ 0030h
;
; Capabilities bits
;
SUPPORTS_FULLDUPLEX	equ 0002h
SUPPORTS_LARGEPACKETS	equ 0004h
SUPPORTS_FULLBUSMASTER	equ 0020h
SUPPORTS_FRAGBUSMASTER	equ 0040h
SUPPORTS_100MBPS	equ 1000h
;
; Bus Types
;
BUS_UNKNOWN		equ	0
BUS_ISA 		equ	1
BUS_EISA		equ	2
BUS_PCI 		equ	3
;
; PCI BIOS function code
;
PCI_FUNCTION_ID         equ     0b1h
PCI_BIOS_PRESENT        equ     001h
FIND_PCI_DEVICE         equ     002h
READ_CONFIG_BYTE        equ     008h
READ_CONFIG_WORD        equ     009h
READ_CONFIG_DWORD       equ     00ah
WRITE_CONFIG_BYTE	equ	0bh
WRITE_CONFIG_WORD	equ	0Ch
WRITE_CONFIG_DWORD	equ	0Dh
;
; PCI BIOS function return code
;
PCI_CALL_SUCCESSFUL     equ     00h
PCI_DEVICE_NOT_FOUND    equ     86h
PCI_BAD_VENDOR_ID       equ     83h
;
; offsets in PCI configuration space
;
PCIC_INTERRUPTLINE	equ	003Ch
PCIC_BIOSROMCONTROL	equ	0030h
PCIC_IOBASE		equ	0010h
PCIC_LATENCYTIMER	equ	000Dh
PCIC_STATUS		equ	0006h
PCIC_COMMAND		equ	0004h
PCIC_DEVICEID		equ	0002h
PCIC_VENDORID		equ	0000h
PCIC_MEDTESTMODEHI	equ	0054h

CFGREG_PCIC_COMMAND     equ     0004h
CFGREG_IOBASE           equ     010h
CFGREG_INTLINE          equ     03ch
CFGREG_INTERNALCFG      equ     040h
CFGREG_BIOSROMCONTROL   equ     030h
;
; bits in PciCommand
;
PCIC_IOENABLE		equ	00001h
PCIC_BMENABLE		equ	00004h
PCIC_PARITYENABLE	equ	00040h
;
; bits in LatencyTimer
;
LATE_MAX		equ	255
LATE_MASK		equ	(NOT 7)
;
; adapter codes
;
ACODE_PCI_10_TPO	equ	42
ACODE_PCI_10_COMBO	equ	43
ACODE_EISA_10_TPO	equ	44
ACODE_EISA_10_COMBO	equ	45
ACODE_PCI_100_TX	equ	46
ACODE_EISA_100_TX	equ	47
ACODE_BOOM_TPO		equ	60
ACODE_BOOM_COMBO	equ	61
ACODE_BOOM_TX		equ	62
ACODE_BOOM_T4		equ	63
;
; MII Transceiver type
;
GENERIC_MII		equ	0h
BASE100_T4		equ	1h
BASE10_T		equ	2h
BASE100_TX		equ	3h
AUTO_10BASET		equ	4h
AUTO_100BASETX		equ	5h

;
; special values used for RetryBits variable.  see DATA.ASM for details.
;
RETRY_YES		equ	CMD_ARGMASK
RETRY_NO		equ	0


;------ Structures ----------------------------------------------------------;
;
; Download and Upload Fragment descriptors:
;
MemFragment	struc
Frag_physaddr	dd	?		; 32 bit physical address
Frag_len	dd	?		; fragment length
MemFragment	ends

MemFragmentvirt struc
Frag_virtaddr_seg dw	?		; segment
Frag_virtaddr_off dw	?		; offset
Frag_numbytes	  dw	?		; number of bytes of data
MemFragmentvirt ends
;
;
; Download and Upload Packet Descriptors:
;
; The nextptr must be aligned on an 8 byte boundary.  Since we allocate
; space for several DPDs contiguously, the size must be held to a multiple
; of 8 bytes, so we make sure the software prefix bytes add up to a multiple
; of 8.
;
; Download Packet Descriptor
;
NUM_DPDS	  	equ	6
MAX_DOWNFRAGMENTS	equ	1	;16; gives us a 64 byte DPD
SMALL_PKT_BUFF_SIZE	equ	134

DPDStruc	struc
;DPD_header	db	 4 dup (?)	; queue header (next and prev)
;DPD_physaddr	dd	?		; physical address of this DPD
;DPD_pktaddr	dd	?		; physical address of small pkt buffer
;qtx_handle	dw	?		; save protocol handle
;qtx_protID	dw	?		; save protID
;DPD_VDS_used	db	0		; VDS used flag
;DPD_VDS_count	db	0		; count of fragments that were VDSed
;DPD_immed_bytes db	SMALL_PKT_BUFF_SIZE dup (0)	; space for small packet buffer
;DPD_virt_fragment db	(8*(size MemFragmentvirt)) dup (0) ; fragment virtual
DPD_DnNextPtr	dd	?		; physical address of next DPD
DPD_FrameStart	dw	?		; frame start header for packet
DPD_FSHindicate	dw	?		; high order bit requests an interrupt
DPD_Frag	db	(MAX_DOWNFRAGMENTS*(size MemFragment)) dup (?)
					; fragment descriptors
DPDStruc	ends

;
; Upload Packet Descriptor
;
NUM_RXBUFFERS	equ	6		; also the number of UPDs needed
MAX_UPFRAGMENTS equ	1	;3	; gives us a 40 byte UPD

UPDStruc	struc
;UPD_nextvirtoff dw	?		; virtual address offset to next UPD
;UPD_pktoff	dw	?		; offset of receive packet buffer
;UPD_pktseg	dw	?		; segment of receive packet buffer
;UPD_physaddr	dd	?		; physical address of this UPD's
;UPD_pad_bytes	db	6 dup (0)	; pad to 8-byte boundary
					; upnextptr (hardware structure start)
UPD_UpNextPtr	dd	?		; physical address of next UPD's
					; upnextptr (hardware structure start)
UPD_UpPktStatus	dw	?		; packet status
UPD_UpPktError	db	?		; error indications
UPD_UpStatspare	db	?		; unused
UPD_Frag	db	(MAX_UPFRAGMENTS*(size MemFragment)) dup (?)
					; fragment descriptors
UPDStruc	ends

;
; TxStart structure.  Padded to 16 bytes for easy indexing.
;
TxStartStruc	struc
txs_thresh	dw	?		; TxStart threshold (+CMD_SETTXSTART)
txs_value	dw	?		; value, no cmd, unscaled
txs_min 	dw	?		; minimum threshold, this bin
txs_count	dw	?		; packets since last underrun
txs_uN		dw	?		; number of entries in uSum
txs_uSum	dw	?		; sum of uN x packets between underruns
txs_pad 	dw	?		; pad to 16 bytes
txs_marker	dw	?		; pad to 16 bytes, marker for debug
TxStartStruc	ends

SIZE_TxStart	equ	SIZE TxStartStruc
TXBIN_COUNT	equ	1		; 1 bin

;
; MII register definitions.   The following are definitions of the standard
; MII registers, common to all implementations of the MII interface.
;
MII_PHY_CONTROL     equ    0	   ; control reg address
MII_PHY_STATUS	    equ    1	   ; status reg address
MII_PHY_OUI	    equ    2	   ; most of the OUI bits
MII_PHY_MODEL	    equ    3	   ; model/rev bits, and rest of OUI
MII_PHY_ANAR	    equ    4	   ; AutoNegotiation Adverisement Register
MII_PHY_ANLPAR	    equ    5	   ; AutoNegotiation Link Partner Ability Reg.
MII_PHY_ANER	    equ    6	   ; AutoNegotiation Expansion Reg.
MII_PHY_PAR	    equ    19h	   ; PHY Address Register
MII_EXT_REG0	    equ    10h	   ; Extended Reg. 0 (Broadcom)
MII_PHY_PCR	    equ    17h	   ; PCS Configuration Reg. (National)
;
; bit fields in the standard MII control register
;
MII_CTL_RESET	    equ    8000h   ; reset bit in control reg
MII_CTL_100MB	    equ    2000h   ; 100Mbit or 10 Mbit flag
MII_CTL_ENABLE_AUTO equ    1000h   ; autonegotiate enable
MII_CTL_ISOLATE     equ    0400h   ; islolate bit
MII_CTL_START_AUTO  equ    0200h   ; restart autonegotiate
MII_CTL_FULL_DUPLEX equ    0100h   ; full duplex
;
; bit fields in the standard MII status register
;
MII_STS_100MB_MASK  equ    0E000h  ; any of these indicate 100 Mbit
MII_STS_10MB_MASK   equ    1800h   ; either of these indicate 10 Mbit
MII_STS_100BASET4   equ    08000h  ; 100BaseT4
MII_STS_100BASEX_FD equ    04000h  ; 100BaseX Full Duplex
MII_STS_100BASEX_HD equ    02000h  ; 100BaseX Half Duplex
MII_STS_10BASET_FD  equ    01000h  ; 10BaseT Full Duplex
MII_STS_10BASET_HD  equ    0800h   ; 10BaseT Half Duplex
MII_STS_AUTO_DONE   equ    0020h   ; auto negotiation complete
MII_STS_AUTO	    equ    0008h   ; auto negotiation is available
MII_STS_LINK_UP     equ    0004h   ; link status bit
MII_STS_EXTENDED    equ    0001h   ; extended regs exist
;
; bit fields in the extended MII auto-negotiation link partner ability reg.
; bit 5-12 are technology ability bits in MII spec.
; national n-way uses bit 5-9 only.
;
MII_ANLPAR_100BASET4   equ    0200h  ; 100BaseT4
MII_ANLPAR_100BASEX_FD equ    0100h  ; 100BaseX Full Duplex
MII_ANLPAR_100BASEX_HD equ    0080h  ; 100BaseX Half Duplex
MII_ANLPAR_10BASET_FD  equ    0040h  ; 10BaseT Full Duplex
MII_ANLPAR_10BASET_HD  equ    0020h  ; 10BaseT Half Duplex
;
; bit fields in the ANER register
;
LP_AN_ABLE	     equ      0001h  ; Link Partner Auto-Negotiation able
MII_ANER_MLF	     equ      0010h  ; Multiple Link Fault
; bit field in the PAR reg.
;
SPEED_10	     equ      0040h  ; 1 = 10Mb, 0 = 100Mb
;
; Physical Management bits
;
MGMT_PHY_CLOCK	    equ    0001h
MGMT_PHY_DATA1	    equ    0002h
MGMT_PHY_WRITE	    equ    0004h
;
; bit field in the extended register 0 for broadcom
MII_EXT_SPEED	       equ    0002h  ; Speed Indication (1=100, 0=10)
;
; Phy addr
;
NWAY		    equ    18h
T4		    equ    01h
;
; Phy OUI
;
BROADCOM_OUI	    equ    3E0h 	; T4
NATIONAL_OUI	    equ    2000h	; 840A
;
; Phy Model
;
NATIONAL_MODEL	    equ    5C00h	; 840A
BROADCOM_MODEL	    equ    0000h	; T4

;
; for intercepting keyboard
;
BIOS_SEG		equ	40h
KEY_FLAG_OFF		equ	17h
KEY_WARMBOOT_BIT	equ	00001100b
KEY_ALT_BIT		equ	00001000b
KEY_CTRL_BIT		equ	00000100b

;------ Macros --------------------------------------------------------------;
;
; SelectWindow - select register window specified (must be a constant)
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;
SelectWindow macro  wno
	    mov     ax, CMD_SELECTWINDOW + wno
	    out     dx, ax
endm

;
; General purpose equates, structures and macros.
;
FALSE           equ     0
TRUE            equ     0ffh
;
; I/O ports for the PICs
;
MASTER_MASK_PORT equ    021h
SLAVE_MASK_PORT	 equ    0A1h
;
; DOUBLEWORD - Thirty-two bit double word layout for sixteen bit word access
;
doubleword      struc
loword          dw      0               ; low order word
hiword          dw      0               ; high order word
doubleword      ends

;
; FARPOINTER - Thirty-two bit 286-style far pointer layout for segment and
;              offset access
;
farpointer      struc
off             dw      0               ; offset
segm            dw      0               ; segment or selector
farpointer      ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\90xb.asm ===
subttl	3C90XB
	page	80,132

;===============================================================================
;  90XB.ASM - produces 3Com 3C90XB EtherLink PCI version of BootWare
;
;    (C) Lanworks Technologies Inc. 1992 - 1996 All rights reserved.
;
;  Revision History - version numbers refer to 90XB.ASM changes only
;
;  971210 1.00  RL - Initial Release
;*==============================================================================
CR		equ	0Dh
LF		equ	0Ah

ASReverseAttr	equ	070h		; Attribute for reverse video
ASNormalAttr	equ	07h		; attribute for normal video

MasterEOIPort 	equ	20h
SlaveEOIPort 	equ	0a0h

FALSE           equ     0
TRUE            equ     0ffh

;
; the number of times through a timed loop to stay off the bus while polling
; for bus master completion to avoid slowing the bus master transfers down
;
Delay3us	equ	8
Delay3ms	equ	01c20h
Delay25ms	equ	0ea60h

InitSTACKPTR	equ	07f00h		; stack pointer for AutoScan Code

T4_PHY_ADDR     equ     01h
NWAY_PHY_ADDR   equ     18h

;BOOTWARE_INTS equ      INT_LATCH + INT_ADAPTERFAIL + INT_RXCOMPLETE + INT_REQUESTED
BOOTWARE_INTS	equ	INT_LATCH+INT_ADAPTERFAIL+INT_UPCOMPLETE

;-------------------------------------
; Include all general companion files
;-------------------------------------

	.xlist
IFDEF	UNDI
	include	spdosegs.inc
	include	pxe_stru.inc
ELSE
	include \rom\sdk\include\drvseg.inc
	include \rom\genr\include\cui.ext
ENDIF
	include bwnad.inc
	include	boom.inc
	.list


IFNDEF	UNDI
public	RunROMTOP
public	InternalConfig
public	WaitEEBusy

;public	HookConfig
				; for CUI...
public	HookEditInput
public	HookHyphen
public	HookEditSpec
public	HookChkChar
public	HookChkInput
public	ErrConfSpace
public	MemBase
public	StoHex			; for 5X9CONF
public	ChkForCfg
public	ChkKey

public	NormalRxEarly
public	CurTxStart

public	eoi_value
public	int_mask_port

public	NADPCIConfig
public	LANOption
public	setchksum
ENDIF

public	IRQLevel
public	HWFilter
public	RxReset
public	TxReset
public	Int_Vector_Loc
public	OrgINTVector_Off
public	OrgINTVector_Seg

;-----------------------------------
; External Data/Variable References
;-----------------------------------

IFDEF	UNDI
	extrn	UNDI_DriverISR
ENDIF

	extrn	PCIBusDevFunc:word
	extrn	IOBase:word			; ROMTOP.ASM

IFNDEF	UNDI
	extrn	Start:near

	extrn	PrintErrMsg:near		; 5X9CONF.ASM
	extrn	ErrIRQ7:byte			; 5X9CONF.ASM
	extrn	NormalAttr:byte			; CUI.ASM
	extrn	ReverseAttr:byte		; CUI.ASM

	extrn	elnk3conf:near			; 5X9CONF.ASM
	extrn	Elnk3ConfSparse:byte		; 5X9CONF.ASM
	extrn	ROMCodeStart:word		; ROMTOP.ASM
	extrn	PrintAt:near
	extrn	NADIntFD:near
ENDIF

IFDEF	DEBUG
	extrn	StringAH:byte
	extrn	StringAL:byte
	extrn	StringPCI:byte
ENDIF

IFNDEF	UNDI
; the following structure is template for received lookahead data, it contains
; MAC header and the 1st 18 bytes of IPX Header.

LookAheadBuf_stru  struc
	;
DestAddr      db   6 dup (?)	       ; this part is
SrcAddr       db   6 dup (?)	       ;  MAC header of
LenType       dw   ?		       ;   received packet
;
IpxChkSum     dw   ?		       ; this portion
IpxPktLen     dw   ?		       ;  is the first
IpxTransContr db   ?		       ;   18 bytes
IpxPktType    db   ?		       ;    of IPX
IpxDestNet    db   4 dup (?)	       ;      header of
IpxDestNode   db   6 dup (?)	       ;	received
IpxDestSocket dw   ?		       ;	  packet.
;
LookAheadBuf_stru  ends

LxBufSize     equ  size LookAheadBuf_stru

LookAhead8022	struc
;
DestAddr8022	  db   6 dup (?)	   ; this part is
SrcAddr8022	  db   6 dup (?)	   ;  MAC header of
LenType8022	  dw   ?		   ;   received packet

; 802.2 LLC
DSAP	      db   0
SSAP	      db   0
Control       db   0
;
LookAhead8022	ends
ENDIF

MACHDRSIZE   		equ 	14
ETHADDRSIZE   		equ	6      		; address size

	.386

IFDEF	UNDI
_TEXT		Segment para public
	assume	cs:CGroup, ds:DGroup
ELSE
START_NAD
ENDIF

LanOption	db	'3Com 3C905B-TX EtherLink PCI v3.00 (971210)',0

NoNetMsg	db	'Ethernet card improperly installed or not connected.',CR,LF,0
TxMsg		db	'Transmit error                                      ',0

IFNDEF	UNDI
	include \rom\sdk\include\bwnadapi.asm

;----------------- Device Driver Data Definitions --------------------
ErrConfSpace	db	09h,011h,' '
NothingString	db	0

StrEndless	db	013h,0ah,'Reboot system for changes to take effect',0

CfgStr 		db	'Configuring Ethernet Adapter, press Ctrl-Alt-B to modify configuration', 0

;-----------------------------------------------------------------------------
;      V A R I A B L E S
;-----------------------------------------------------------------------------

		   ALIGN     4

LookAheadBufferPtr label     dword
		   dw	     offset LookAheadBuffer
		   dw	     ?

; error messages - note BootWare prefaces them with a CR,LF

StrPrompt	db	'Initializing 3C90X EtherLink PCI Adapter',0
BlankStr	db	'                                        ',0

Str8022U	db	06h,08h,'BootWare 3C90X supports NetWare, RPL & TCP/IP boot protocols:',0
		db	09h,0ah,'To configure & save protocol/frame type, type <ENTER>',0
		db	0bh,0bh,'Default boot protocol is NetWare Ethernet_802.2',0
		db	03h,0fh,'This message will appear until boot protocol information is saved.',0
		db	0ffh
StrNull 	db	0


MsgROM64K	db	'Only ROMSize of 64K is supported',0

ErrPressF1		db	'. Press <F1> to continue',0

StrWarnLevel	db	010h,0ah,'Newer BootWare version is available for this adapter.',0
StrFailLevel	db	0bh,0ah,'New EtherLink found. Need new BootWare version.',0

; Msg put here so it won't be on every page
MsgUpdateErr	db	06h,0ah,'Unable to update BootWare 3C90X. Configuration changes are not saved.',0

MsgVerifyBad	db	012h,0ah,'BootWare Update verification failed.',0
MsgUpdateOk	db	018h,0ah,'Update Successful ('
MsgUpdateCnt	db	'00)',0
ENDIF

MsgVulcanNotFound	db	'Could not find 3C90X', 0


IFNDEF	UNDI
;--------------------------------------------------------------------
RomTopExitJmp:
		jmp	RomTopExit	;already init. Never run in RAM.

RunROMTOP:
		pusha
		push	ds
		push	es

		push	cs
		push	cs
		pop	ds
		pop	es

		cld

IFDEF		TSR
		mov	ax, 040h
ENDIF
IFDEF		DEBUG
		int	3
ENDIF
		push	ax


IFDEF		DEBUG
		mov	di, offset CGroup:StringAL
 		call	StoHex

	 	xchg	al, ah
	 	mov	di, offset CGroup:StringAH
	 	call	StoHex

	 	mov	ax, cs
	 	mov	di, offset CGroup:StringCS
	 	call	ROMStoHex

		mov	bx, offset CGroup:StringPCI
		call	PrintMessage

		mov	bx, offset CGroup:ErrPressF1
		call	PrintMessage

ChkF1F2Lp:
		sti			; enable interrupt

		mov	ah, 0		; Read char. Char is removed from buffer
		int	016h		; Keyboard interrupt

		cmp	ah, 3Bh ; <F1> pressed?
		jz	TempCont

		cmp	ah, 3Ch ; <f2> pressed?
		jnz	ChkF1F2Lp

		pop	ax

ASExitEarly:
		pop	es
		pop	ds
		popa
		retf
TempCont:

ENDIF		; DEBUG

		call	GetBusType
		cmp	al, BUS_PCI
		jz	ASPCI

		cmp	al, BUS_EISA_PCI
		jz	ASPCI

		; Bus could be EISA or PCI_EISA
		mov	bx, offset CGroup:MsgVulcanNotFound
		pop	ax
		jmp	AutoScanErr

ASPCI:
IFNDEF		TSR

		pop	ax
		mov	PCIBusDevFunc, ax
		pop	ax
		push	ax			;ROMBase
		mov	ROMBase, ax

		; to save space, OldStackPtr is not used. Replaced by Old MsgIOConflict
		; use our own stack
		mov	word ptr [OldStackPtr], sp
		mov	word ptr [OldStackPtr+2], ss

		call	FindStack
		cli
		mov	ss, ax
		mov	sp, InitSTACKPTR
		sti

ENDIF		; TSR
		push	cs
		pop	ds

		mov	BusType, BUS_PCI
		call	Init_Adapter		; init vulcan hardware and
						;  variables
		cmp	ax, 0
		jz	Init_AdapterOk

		; Print Message. Can't use the one in CUI because it's not on
		; every page.
		mov	bx, offset CGroup:MsgVulcanNotFound

AutoScanErr:	call	PrintMessage
		mov	bx, offset CGroup:ErrPressF1
		call	PrintMessage

ChkF1Lp:
		sti			; enable interrupt

		mov	ah, 0		; Read char. Char is removed from buffer
		int	016h		; Keyboard interrupt

		cmp	ax, 3B00h	; <F1> pressed?
		jnz	ChkF1Lp

		; restore stack
		mov	ss, word ptr [OldStackPtr+2]
		mov	sp, word ptr [OldStackPtr]

		pop	es
		pop	ds
		popa
		retf

Init_AdapterOk:
		; Make sure ROMSize is set to 64K. Otherwise, print error
		; msg, wait and continue
		mov	bx, offset CGroup:MsgROM64K
		mov	ax, InternalConfig.loword
		and	ax, 0c0h		; consider only bit 6,7
		cmp	ax, 0c0h
		jnz	AutoScanErr

		; Setup PrintAttribute so that color will only be used
		; in Config Facility
;		mov	al, NormalAttr
;		mov	ah, ReverseAttr
;		mov	CUIAttr, ax
;		mov	NormalAttr, ASNormalAttr
;		mov	ReverseAttr, ASReverseAttr

;		call	ASConfig		; autoscan config
;		mov	NormalAttr, ASNormalAttr
;		mov	ReverseAttr, ASReverseAttr
;		jnc	AutoScanNoUpdate

		; Problem with Phoenix BIOS where SS is required to be
		; the same as CS
		; Assume that NOTHING is on the STACK!!!
;		cli
;		mov	ax, cs
;		mov	ss, ax
;		sti

;		call	UpdatePCI_PEROM

		; Problem updating ROM. Just dump error message and let
		; them proceed
;		xor	al, al		; Get user to press <ENTER> for acknowledge
;		call	PrintErrMsg
;		call	ClearScreen

AutoScanNoUpdate:

		push	cs
		pop	ds

IFNDEF		TSR
		; restore stack
		mov	ss, word ptr [OldStackPtr+2]
		mov	sp, word ptr [OldStackPtr]
ENDIF

RomTopExit:
 		pop	es
		pop	ds
		popa

		jmp	Start


;-----------------------------------------------------------------------------
; AutoConfig	Called by Autoscan routine
;
;		Exit:	ax = offset of checksum byte (whole ROM)
;-----------------------------------------------------------------------------
;AutoConfig	proc	near
;		ret
;AutoConfig	endp


;-----------------------------------------------------------------------------
; SetChkSum	Calculate checksum of a specified block of data and
;		write checksum to specified location
;
;		Entry:	ds:si = point to block of data to checksum
;			di = offset in block of data to write checksum
;			cx = length of data to checksum
;		Exit:	checksum ok block of data
;-----------------------------------------------------------------------------
SetChkSum	proc	near
		xor	ax, ax

SetChkSumLoop:
		lodsb
		add	ah, al
		loop	SetChkSumLoop

		neg	ah
		mov	ds:[di], ah		; write checksum

		ret
SetChkSum	endp


;------ GetBusType ----------------------------------------------------------;
;									     ;
;	Identify the type of system we are executing on.		     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	AL = EISA or PCI or EISA_PCI (also saved in BusType)			     ;
;									     ;
;	Destroys AH, BX, CX, DX, SI, DI.  All other registers are     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
		public	GetBusType
GetBusType	proc	near

		push	es
; point ES at Real Mode F000:0000
		mov	ax, 0F000h
		mov	es, ax

; to determine if this is an EISA system or not we look for the string "EISA"
; in the ROM at F000:FFD9 thru FFDC.

		mov	ax, 0			; clear BusFlag
		mov	di, 0FFD9h
		cmp	word ptr es:[di][0], 4945h	; "EI"?
		jne	gst_not_eisa
		cmp	word ptr es:[di][2], 4153h	; "SA"?
		jne	gst_not_eisa

		mov	al, BUS_EISA

; for the moment, if its not an EISA system, see if it's PCI

gst_not_eisa:
		push	ax

		; Is machine PCI?
		mov	ax, PCI_FUNCTION_ID shl 8 + PCI_BIOS_PRESENT
		int	1ah
		jc	GetBusRet

		or	ah, ah
		jne	GetBusRet

		cmp	dx, 4350h		; EDX = "PCI "
		jne	GetBusRet

		pop	ax
		add	al, BUS_PCI
		push	ax

GetBusRet:
		pop	ax
		pop	es
		ret
GetBusType	endp
ENDIF

IFDEF	UNDI
	include	nad90x.asm
ENDIF

public		WaitTime
;--------------------------------------------------------------------
; WaitTime - CX has 2*1.1932 the number of microseconds to wait.
;	If CX is small, add 1 to compensate for asynchronous nature
;	of clock.  For example, for 10us, call with CX = 25
;
;  On entry,
;	ints off (especially if CX is small, and accuracy needed)
;  On exit,
;
; 911223 0.0 GK
;--------------------------------------------------------------------
WaitTime	proc	near

		push	ax
		push	bx
		push	cx

		call	ReadTimer0		; get Timer0 value in AX
		mov	bx, ax			; save in BX

ReadTimer0Loop:
		call	ReadTimer0
		push	bx
		sub	bx, ax
		cmp	bx, cx
		pop	bx
		jc	ReadTimer0Loop

		pop	cx
		pop	bx
		pop	ax
		ret

WaitTime	endp


ReadTimer0	proc	near

		mov	al, 6
		out	43h, al 		; port 43h, 8253 wrt timr mode 3
		call	RT0

RT0:
		jmp	short $+2
		jmp	short $+2
		jmp	short $+2
		in	al, 40h 		; port 40h, 8253 timer 0 clock
		xchg	ah, al

		jmp	short $+2
		jmp	short $+2
		jmp	short $+2

		ret

ReadTimer0	endp


;------ ReadEEProm ----------------------------------------------------------;
;									     ;
;	This routine reads a word from the EEProm.  It can only be used      ;
;	once the board has been brought up at a particular IOBase.	     ;
;									     ;
;	Entry:								     ;
;	AL	= EEProm word to read					     ;
;	Window	= 0							     ;
;	DX 	= IOBase
;	cli								     ;
;									     ;
;	Exit:								     ;
;	AX	= that EEProm word					     ;
;	cli								     ;
;									     ;
;	Destroys BX, CX, DX, SI, DI and ES.  All other registers are	     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
	  	public  ReadEEProm
ReadEEProm	proc    near
		push	dx

; issue an EEProm read command
		add    al, READ_EEPROM
		out    dx, al

; spin until the EEProm busy bit goes off

		call   WaitEEBusy

; fetch the data from the EEProm data register

;960401		add    dx, PORT_EEData - PORT_EECmd
		mov	dx, PortEEData
		in     ax, dx

		pop	dx
		ret

ReadEEProm    endp


;-----------------------------------------------------------------------------
; WaitEEBusy	Poll until the EEPROM_BUSY bit in EECommand Register is cleared
;
; Input:	dx = IOBase+ PORT_EECmd
;		ax = 0 no problem, ax != 0 problem
;-----------------------------------------------------------------------------
WaitEEBusy	proc	near
		push	cx

		mov	cx, 0
WaitEELoop:
		in	ax, dx
		test	ax, EE_BUSY
		jz	WaitEEBusyExit
		loop	WaitEELoop
WaitEEBusyExit: 
		and	ax, EE_BUSY		; only consider bit 15 for Errcode
		pop	cx
		ret
WaitEEBusy	endp


;
; bits to enable in MediaStatus based on XCVR type
;
		public	MediaEnable
MediaEnable	label	word
;;		ASSERT	<XCVR_10TP EQ 0>
		dw	MEDIA_JABBERENABLE + MEDIA_LBEATENABLE
;;;		ASSERT	<XCVR_10AUI EQ 1>
		dw	MEDIA_SQEENABLE
		dw	0			; not used
;;;		ASSERT	<XCVR_10BNC EQ 3>
		dw	0
;;;		ASSERT	<XCVR_100TX EQ 4>
		dw	MEDIA_LBEATENABLE
;;;		ASSERT	<XCVR_100FX EQ 5>
		dw	MEDIA_LBEATENABLE
;;;		ASSERT	<XCVR_MII EQ 6>
		dw	0
		dw	0
		dw	MEDIA_LBEATENABLE

;-----------------------------------------------------------------------------
; FindV3PCI
;
; Return	dx = 0		not found
;		     IOBase	found
;		al = IRQLevel
;-----------------------------------------------------------------------------
FindV3PCI	proc	near

		call	PCISearch
		jc	no_pci

; Check whether bus mastering has been forced off.  If so, set MasterOK to NO
		
	       mov     ah, 0B1h		; PCI BIOS Function
	       mov     al, 009h		; PCI Read Config Word
	       mov     bx, PCIBusDevFunc
	       mov     di, PCIC_COMMAND	; read PCICommand
	       int     1Ah
       
	       test    cx, PCIC_BMENABLE       ; bus mastering enabled?
	       jnz     bm_set
       
	       or      cx, PCIC_BMENABLE       ; force it on
	       mov     ah, 0B1h		; PCI BIOS Function
	       mov     al, 00Ch		; PCI Write Config Word
	       mov     bx, PCIBusDevFunc
	       mov     di, PCIC_COMMAND	; write it back to PCICommand
	       int     1Ah
bm_set:

; PCI device has been found, read IO address from config space

		mov	bx, PCIBusDevFunc
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		mov	di, CFGREG_IOBASE
		int	1ah
		jc	no_pci

		and	cx, 0ffe0h			 ; drop last 5 bits
		mov	dx, cx

		mov    ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_BYTE
		mov    bx, PCIBusDevFunc
		mov    di, CFGREG_INTLINE
		int    1ah
		mov    al, cl

		ret

no_pci: 	xor	dx, dx
		ret
FindV3PCI	endp


;------ PCISearch -----------------------------------------------------------;
;									     ;
;	Attempt to find a match against a PCI adapter.	The caller can	     ;
;	specify the exact busno/slot to check or leave either unspecified    ;
;	in which case a search will be performed among the allowed	     ;
;	busno/slot combinations for a match.				     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Slot  = slot number to search, -1 if not specified		     ;
;	BusNo = bus number to search, -1 if not specified		     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	carry = set if no match 					     ;
;	      = clear if a match					     ;
;	BusNo = set for the matching adapter if carry clear		     ;
;	Slot  = set for the matching adapter if carry clear		     ;
;	PCIBusDevFunc = set for the matching adapter if carry clear	     ;
;									     ;
;	All registers are preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	PCISearch
PCISearch	proc	near

		pusha

;
; Read the PciCommand register to see if the adapter has been activated.  if
; not, pretend we didn't find it
;
		mov	ah, 0B1h		; PCI BIOS Function
		mov	al, 009h		; PCI Read Config Word
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_COMMAND
		int	1Ah
		jc	pcis_no

		test	ah, ah
		jnz	pcis_no


		test	cx, PCIC_IOENABLE	; I/O access enabled?
		jz	pcis_no

		clc
;
; exit with carry flag as set
;
pcis_exit:
		popa
		ret

;
; no PCI support or adapter not found or failure after found
;
		public	pcis_no
pcis_no:
		stc
		jmp	pcis_exit
PCISearch	endp


;*****************************************************************************
;
;   Init_Adapter: This routine initializes hardware of Fast EtherLink and
;		 variables required by this driver. The following are
;		 performed in this routine:
;
;		   1. activate adapter
;		   2. determine resource config and enable resources
;		   3. initialze and determine driver variables, tables
;		   4. enable vulcan hardware (txmitter, receiver, xcvr, etc.)
;
;   On Entry:
;
;      ds = es = CGroup
;      sti
;      cld
;
;   On Exit:
;
;      sti
;      ax     = 0, init successful
;	      = offset of an error message indicating type of error
;
;*****************************************************************************

nohardware:	sti
		mov	ax, offset CGroup:MsgVulcanNotFound
		ret

Init_Adapter	proc	  near

		call	FindV3PCI
		cmp	dx, 0
		jz	nohardware

		mov	DGroup:IOBase, dx
		mov	IRQLevel, al

		call	CalibrateDelay

		mov	cx, 1			; 1us
		call	ComputeDelay
		mov	Delayoneusec.loword, ax
		mov	Delayoneusec.hiword, dx


		mov	cx,0C350h
		call	ComputeDelay
		mov	DelaySomething.loword, ax
		mov	DelaySomething.hiword, dx

;;;
;
; initialize IO Port Variables
;
		mov	ax, IOBase
		mov	cx, NumOfPorts
		mov	di, offset DGroup:PortCmdStatus
InitPorts:
		add	[di], ax
		add	di, 2
		loop	InitPorts

		mov	dx, PortCmdStatus
		mov	ax, CMD_SELECTWINDOW+WNO_SETUP	   ;   unload/reload &
		out	dx, ax				   ;	boot PROMs

;PM		mov	ax, cs
		mov	ax, ds
		mov	es, ax
		mov	di, offset DGroup:BoardID

		mov	dx, PortEECmd
		mov	al, EE_OEM_NODE_ADDR_WORD0
		call	ReadEEProm		  ; read word 0 of node addr
		xchg	ah, al
		stosw

		mov	al, EE_OEM_NODE_ADDR_WORD1
		call	ReadEEProm		  ; read word 1 of node addr
		xchg	ah, al
		stosw

		mov	al, EE_OEM_NODE_ADDR_WORD2
		call	ReadEEProm		  ; read word 2 of node addr
		xchg	ah, al
		stosw
;
; check to make sure the board is visible (ie. no conflict with IOBase).  since
; the PCI adapter doesn't have the EISA manufacturer ID in Window 0 anymore, we
; now use the Window 5 to check this
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_READABLE

		mov	ax, CMD_SETTXSTART + 0
		out	dx, ax

		mov	dx, PortTxStart
		in	ax, dx
		test	ax, ax
		jnz	bind_ioconflict

		mov	dx, PortCmdStatus
		mov	ax, CMD_SETTXSTART + (TXSTART_DISABLED / 4)
		out	dx, ax

		mov	dx, PortTxStart
		in	ax, dx
		cmp	ax, TXSTART_DISABLED
		je	InitTxDisable

bind_ioconflict:
		jmp	nohardware

InitTxDisable:
; init DPD
		mov	dword ptr DPD.DPD_DnNextPtr, 0	;use single DPD
		mov	ax, ds
		mov	bx, offset DGroup:TxBuf
		mov	dx, ax
		shr	dx, 12
		shl	ax, 4
		add	ax, bx
		adc	dx, 0
		mov	si, offset DPD
		mov	word ptr [si].DPD_Frag.Frag_physaddr, ax
		mov	word ptr [si].DPD_Frag.Frag_physaddr+2, dx
		mov	word ptr [si].DPD_Frag.Frag_len, MAX_RXBYTES
		mov	word ptr [si].DPD_Frag.Frag_len+2, 8000h   ;last frag.

		mov	ax, ds
		mov	bx, offset DPD
		mov	dx, ax
		shr	dx, 12
		shl	ax, 4
		add	ax, bx
		adc	dx, 0
		mov	word ptr DPD_physaddr, ax
		mov	word ptr DPD_physaddr+2, dx
; init UPD
		mov	dword ptr UPD.UPD_UpNextPtr, 0	;use single UPD
		mov	ax, ds
		mov	bx, offset DGroup:RxBuf
		mov	dx, ax
		shr	dx, 12
		shl	ax, 4
		add	ax, bx
		adc	dx, 0	 
		mov	si, offset UPD
		mov	word ptr [si].UPD_Frag.Frag_physaddr, ax
		mov	word ptr [si].UPD_Frag.Frag_physaddr+2, dx
		mov	word ptr [si].UPD_Frag.Frag_len, MAX_RXBYTES
		mov	word ptr [si].UPD_Frag.Frag_len+2, 8000h   ;last frag.

		mov	ax, ds
		mov	bx, offset UPD
		mov	dx, ax
		shr	dx, 12
		shl	ax, 4
		add	ax, bx
		adc	dx, 0
		mov	word ptr UPD_physaddr, ax
		mov	word ptr UPD_physaddr+2, dx
   
;-------------------------------------------------------------------------------
; read a few things off the board
;
; note: because of the delays required for the EEProm accesses, we're going to
;	have interrupts disabled for a rather long time (hundreds of usec), but
;	since this is only init time, and our only other choice would be to
;	do this resident, we're going to do it anyway.
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

;		mov	dx, PortMediaOptions
;		in	ax, dx
;		mov	MediaOptions, ax

		mov	dx, PortInternalCfgH
		in	ax, dx
		mov	InternalConfig.hiword, ax

		mov	dx, PortInternalCfgL
		in	ax, dx
		mov	InternalConfig.loword, ax

		mov	dx, PortCmdStatus
		SelectWindow WNO_SETUP

		mov	al, EE_SOFTWARE_INFO
		mov	dx, PortEECmd
		call	ReadEEProm		  ; read software info
		mov	EESoftConfigInfo, ax

		mov	al, EE_SOFTWARE_INFO_2
		call	ReadEEProm		  ; read software info 2
		mov	EESoftConfigInfo2, ax

		mov	al, EE_CAPABILITY_WORD
		call	ReadEEProm
		mov	EECapabilities, ax

		mov	al, EE_INTERNAL_CFG_WORD0
		call	ReadEEProm
		mov	EEIntConfig0,ax

		mov	al, EE_INTERNAL_CFG_WORD1
		call	ReadEEProm
		mov	EEIntConfig1,ax

		mov	al, EE_CWORD
		call	ReadEEProm		  ; read Compatibility word
		mov	CWord, ax

		mov	al, EE_MII_SELECT
		call	ReadEEProm
		and	ax, EE_MII_SELECT_MASK
		mov	MiiSelect,ax
;; 980519
		mov	al, EE_MEDIAOPTIONS
		call	ReadEEProm
		mov	MediaOptions, ax
;;;;

; initialize IRQ on 8259 and remap vector to our interrupt service routine

		mov	al, IRQLevel
		call	SetInterruptVector

		mov    ax, 0

Init_Adapter_rtn:
		sti
		ret

Init_Adapter	endp


IFNDEF	UNDI
;--------------------------------------------------------------------------;
; ASConfig	autoscan Configuration Utility for 5X9. Will call Elnk3Conf
;
; Exit		cf	= clear No Change
;			= set	Changes are made
;
;--------------------------------------------------------------------------;
ASConfig	proc	near

  		; Check Fail/Warning Level to see if PROM should
		; dump any messages
		mov	dx, PortEECmd
		mov	al, EE_CWORD
		call	ReadEEPROM

		cmp	ah, LEVEL_FAIL		; is fail level ok?
		jbe	ChkWarnLevel

		call	ClearScreen
		mov	bx, offset CGroup:StrFailLevel
		xor	al, al
		call	PrintErrMsg
		call	ClearScreen

NoConfigJmp:	clc
		jmp	NoConfig

ChkWarnLevel:
		cmp	al, LEVEL_WARNING	; is warning level ok?
		jbe	ChkLevelDone

		call	ClearScreen
		mov	dx, word ptr CGroup:[StrWarnLevel]
		mov	ah, NormalAttr
		mov	bx, offset CGroup:StrWarnLevel+2
		call	PrintMsgLoc

		mov	si, 3			; 3 seconds
		call	ChkKey
		call	ClearScreen

ChkLevelDone:	; 940107 is CFG disabled by BW5X9.EXE ?
		mov	ax, BWTFeature
		test	ax, BWTFEA_CONF
		jnz	NoConfigJmp

; 930916 all 5X9Conf code will be here {
		call   ClearScreen
		call   ChkForCfg
		jnz    NoConfigJmp

		; setup ScreenAttributes
		mov	ax, CUIAttr
		mov	NormalAttr, al
		mov	ReverseAttr, ah

		mov	bx, InternalConfig.hiword
		mov	dx, EESoftConfigInfo

		mov	si, offset BoardID
		mov	di, IOBase
		mov	al, BusType

		call	ELNK3CONF
		jnc	NoConfig

		mov	EESoftConfigInfo, dx

		stc
NoConfig:
		pushf
		call   ClearScreen
		popf
		ret

ASConfig	endp


;--------------------------------------------------------------------------;
; UpdatePCI_PEROM	Update the BootWare Table of the PEROM for PCI V3
;
; Exit		bx  = 0, no problem
;		   != 0, pointer to error Message
;--------------------------------------------------------------------------;
UpdatePCI_PEROM proc	near

		mov	bx, 8
		call	FixRAMWidth

		; find a clean/free extend memory region
		call	FindExtendMemory
		cmp	UseExtendMem, 0
		jnz	ExtendMemFound

UpdateErr:
		mov	bx, offset CGroup:MsgUpdateErr
		jmp	UpdatePEROMExit

ExtendMemFound:
		; Use Word rather than DWord when READing/WRITing to config
		; space so that I can use Periscope to look at it
		; Fetch current Expansion +ROMBase Address so that we can
		; restore it later
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_BIOSROMCONTROL + 2
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		int	01ah
		mov	OldPCIROMAddr+2, cx

		; assume bx preserved
		mov	di, PCIC_BIOSROMCONTROL
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		int	01ah
		mov	OldPCIROMAddr, cx

		; map BootROM at UseExtendMem.
		mov	cx, UseExtendMem
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_BIOSROMCONTROL + 2
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		; assume bx preserved
		mov	cx, 01			; enable ROM
		mov	di, PCIC_BIOSROMCONTROL
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		; Update Physical BootROM with the appropriate information
		; Steps:
		; 1. Copy the first 256 bytes from BootROM to Elnk3ConfSparse
		; 2. Verify 1st 2 bytes are 55 AA
		; 3. Update appropriate data
		; 4. Copy data from AutoScanBuffer to BootROM
		; 5. Verify results and retry is necessary

		; First, Copy 256 bytes from BootROM to Elnk3ConfSparse
		; On entry	BX:DI is destination address
		;		DX:SI is source address
		;		CX    is byte count.

		mov	UpdateRetry, 3

UpdateMemRetry:
		cmp	UseExtendMem, 0ah
		jnz	CopyFromExtend

		; Segment A000 Update {
		push	ds
		mov	cx, 40h
		xor	esi, esi
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		xor	edi, edi
		mov	di, AutoScanBuffer
		mov	ax, 0a000h
		mov	ds, ax
;		rep	movsd
CopyA000Lp1:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp1
		pop	ds
		jmp	short UpdateChk55AA
		; Segment A000 Update }

CopyFromExtend:
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	bx, dx
		mov	di, ax
		add	di, AutoScanBuffer
		adc	bx, 0

		mov	dx, UseExtendMem
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		mov	cx, 100h
		call	CopyMemory

UpdateChk55AA:
		; Should at least make sure that AutoScanBuffer
		; contains the 55 AA signature
		mov	bx, offset CGroup:MsgUpdateErr
		mov	di, AutoScanBuffer
		cmp	word ptr [di], 0aa55h
		jnz	UpdateMemRemap

		; Update BWTLANOS, BWTFeature, BWTEthStd
;960529		mov	di, AutoScanBuffer

		mov	al, BWTLANOS
		mov	byte ptr [di+offset BWTLANOS], al

		mov	ax, BWTFeature
		mov	word ptr [di+offset BWTFeature], ax

;970219		mov	ax, BWTEthStd
;		mov	word ptr [di+offset BWTEthStd], ax

;		mov	al, BWTAddrRes
;		mov	byte ptr [di+offset BWTAddrRes], al


		; Calculate checksum of BootROM Table
		xor	cx, cx
		mov	cl, byte ptr cs:[8]
		dec	cl
		mov	si, AutoScanBuffer
		add	si, 8
		add	di, offset BWTChkSum		; di still points to AutoScanBuffer
		call	SetChkSum


		cmp	UseExtendMem, 0ah
		jnz	CopyToExtend

		; Segment A000 Update {
		push	es
		mov	ax, 0a000h
		mov	es, ax
		mov	cx, 20h
		xor	esi, esi
		xor	edi, edi
;960529		mov	di, AtmelOffset
		mov	di, ROMCODESTART
		mov	si, AutoScanBuffer
;		rep	movsd
CopyA000Lp2:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp2

		mov	cx, Delay25ms
		call	WaitTime

		mov	cx, 20h
CopyA000Lp3:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp3

		pop	es
		jmp	short UpdateVerify
		; Segment A000 Update }

CopyToExtend:
		; Extend Memory Update {
		; Copy First 256 bytes to Physical BootROM
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	si, ax
		add	si, AutoScanBuffer
		adc	dx, 0

		mov	bx, UseExtendMem
;960529		mov	di, AtmelOffset
		mov	di, ROMCODESTART
		mov	cx, 80h
		call	CopyMemory

		mov	cx, Delay25ms
		call	WaitTime

		mov	cx, 80h
		call	CopyMemory
		; Extend Memory Update }

UpdateVerify:
		mov	cx, Delay25ms
		call	WaitTime

		cmp	UseExtendMem, 0ah
		jnz	CopyToVerify

		; Segment A000 Update {
		jmp	$+2
		jmp	$+2
		jmp	$+2

		push	ds
		mov	cx, 40h
		xor	esi, esi
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		xor	edi, edi
		mov	di, AutoScanBuffer
		add	di, 100h
		mov	ax, 0a000h
		mov	ds, ax

CopyA000Lp4:
		lodsd
		jmp	$+2
		jmp	$+2
		jmp	$+2
		stosd
		loop	CopyA000Lp4

		pop	ds
		jmp	short UpdateCompare
		; Segment A000 Update }

CopyToVerify:
		; Verify PEROM content
		; es:di points to AutoScanBuffer
		; ds:si points to AutoScanBuffer+100h
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	bx, dx
		mov	di, ax
		add	di, AutoScanBuffer
		adc	bx, 0
		add	di, 100h
		adc	bx, 0

		mov	dx, UseExtendMem
;960529		mov	si, AtmelOffset
		mov	si, ROMCODESTART
		mov	cx, 100h
		call	CopyMemory

UpdateCompare:
		mov	bx, offset CGroup:MsgUpdateOk

		mov	di, AutoScanBuffer
		mov	si, di
		add	si, 100h
		mov	cx, 100h
		repz	cmpsb
		jz	UpdateMemRemap

		mov	bx, offset CGroup:MsgVerifyBad
		dec	UpdateRetry
		jz	UpdateMemRemap

		jmp	UpdateMemRetry

UpdateMemRemap:
		push	bx
		; Restore Expansion ROM Base Adress Register
		mov	bx, PCIBusDevFunc
		mov	cx, OldPCIROMAddr	; Disable ROM first
		mov	di, PCIC_BIOSROMCONTROL
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		; assume bx preserved
		mov	cx, OldPCIROMAddr + 2
		mov	di, PCIC_BIOSROMCONTROL + 2
		mov	ax, PCI_FUNCTION_ID shl 8 + WRITE_CONFIG_WORD
		int	01ah

		mov	bx, 0fff7h
		call	FixRAMWidth
		pop	bx

UpdatePEROMExit:
		ret
UpdatePCI_PEROM endp

; Extended memory global descriptor structure:

DESCRIPTOR	STRUC
Dummy		DW	0, 0, 0, 0
GDT_LOC 	DW	0, 0, 0, 0
SourceLimit	DW	0
SourceLoWord	DW	0
SourceHiByte	DB	0
SourceRights	DB	0
SourceInternal	db	0
SourceHiByteHi	db	0
TargetLimit	DW	0
TargetLoWord	DW	0
TargetHiByte	DB	0
TargetRights	DB	0
TargetInternal	db	0
TargetHiByteHi	db	0
Bios		DW	0, 0, 0, 0
Temp		DW	0, 0, 0, 0
DESCRIPTOR	ENDS

GDT		Descriptor <>

;--------------------------------------------------------------------
; FixRAMWidth()
;
;	- When we detect that InternalConfig.ramWidth is byte-wide,
;	  we need to fix an ASIC problem where we cannot
;	  write to the Atmel PEROM. All the odd location bytes are
;	  overwritten with zero
;	- toggle 3C590.InternalConfig.ramWidth between Byte-wide and
;	  Word-wide. Because InternalConfig.ramWidth toggles, we
;	  can't use ramWidth to determine if adapter need Fix
;
; Input 	bx = 8		to change ramWidth to WordWide
;		   = 0fff7h	to change ramWidth to ByteWide
;--------------------------------------------------------------------
FixRAMWidth	proc	near

		; is adapter 3C590, 3C592 or 3C597?
		cmp	BusType, BUS_EISA
		jz	FixRAMWidthNow

		; Goto ConfigSpace DeviceID (offset2) to distinguish
		; between 3C590 and 3C595. CANNOT use PCIStructure
		; in ROM because Award uses BootWare/3C595
		; rather than BootWare/3C590 for the 3C590 adapter.
		push	bx
		mov	bx, PCIBusDevFunc
		mov	di, PCIC_DEVICEID
		mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
		int	01ah
		pop	bx
		cmp	cx, PCI_DeviceID
		jnz	FixRAMWidthExit

FixRAMWidthNow:
		; Does version of ASIC contain bug?????????
		mov    dx, PortCmdStatus
		SelectWindow WNO_FIFO
;960401		port	InternalCfgL, CmdStatus
		mov	dx, PortInternalCfgL
		in	ax, dx

		test	bx, 8
		jnz	FixRAMWidthWord

		and	ax, bx
		jmp	short SetRAMWidth

FixRAMWidthWord:
		or	ax, bx

SetRAMWidth:
		out	dx, ax

		mov	dx, PortCmdStatus
		SelectWindow WNO_SETUP

FixRAMWidthExit:
		ret
FixRAMWidth	endp

;--------------------------------------------------------------------
; CopyMemory	Copy block of memory to/from extended memory
;
; On entry	BX:DI is destination address
;		DX:SI is source address
;		CX    is byte count.
;
;	Addresses is 32bit address
;	Assume CS=ES=DS
;--------------------------------------------------------------------
CopyMemory proc near

  	push	di
	push	cx
	mov	di, offset GDT
	mov	cx, (size DESCRIPTOR)/2
	xor	ax, ax
	rep	stosw
	pop	cx
	pop	di

	mov	ax, bx
	mov	bx, OffSet GDT	; address of GDT (es:si)
	mov	[bx].SourceLimit, cx	; set copy size
	mov	[bx].TargetLimit, cx	; set copy size
	mov	[bx].SourceRights, 93h	; set copy rights
	mov	[bx].TargetRights, 93h	; set rights

	mov	[bx].SourceLoWord, si	; set source address lo word
	mov	[bx].SourceHiByte, dl	; set source address LowByte of HighWord
	mov	[bx].SourceHiByteHi, dh ; set source address HighByte of HighWord

	mov	[bx].TargetLoWord, di	; set dest address low word
	mov	[bx].TargetHiByte, al	; set dest address lowbyte of High Word
	mov	[bx].TargetHiByteHi, ah ; set dest address highbyte of high word

	shr	cx, 1			; now cx is word count

	mov	si, bx			; es:si = GDT
	mov	ah, 87h
	int	15h			; move data to/from extended memory

	ret

CopyMemory EndP

;--------------------------------------------------------------------
; FindExtendMemory	- From Top of extended memory, find a region
;			  of extended memory we can use and return the
;			  Most Significant Word of the 32 bit address
;			- verify that the region we choose is unoccupied
;			  by examing the first 128 bytes of the 64K region
;			  and make sure the values are the same
;			- if region is occupied, goto next 64K region
;			  until we reach f000 0000
;
; Return:	ax =  Most Sign. Word of the 32Bit address that ROM code
;			can be copied to
;		   = error
;
;--------------------------------------------------------------------
FindExtendMemory	proc	near

		; Setup AutoScanBuffer
		; ** Elnk3ConfSparse is memory that we will throw away
		;    after AutoScan. Use it as a temporary buffer **
		; 950306 There are 1B0h bytes in Elnk3ConfSparse I can use
		mov	di, offset Elnk3ConfSparse
		inc	di
		and	di, 0fffeh		; make sure Buffer is Word Align
		mov	AutoScanBuffer, di


		; Before using Extended memory, check if A000:0 region is
		; available. Since A000:0 is below 1M, no need to use
		; CopyMemory to verify result
		push	ds
		mov	ax, 0a000h
		mov 	ds, ax
		xor	si, si
		mov	cx, 0ffffh

		lodsb
		mov	ah, al

FindA000Loop:
		lodsb
		cmp	ah, al
		jnz	FindA000

		loop	FindA000Loop

FindA000:	pop	ds

		cmp	cx, 0
		jnz	FindExtendMem

		mov	ax, 0ah
		mov	UseExtendMem, ax
		ret

FindExtendMem:
		mov	ah, 088h
		int	15h

		push	cx
		mov	cx, 040h
		div	cl		; divide by 40 to get starting 32bit
					; address
		xor	ah, ah		; ignore remainder
		add	ax, 020h	; add 1M for conventional RAM &
					; choose 1M above top of ExtendRAM
		mov	UseExtendMem, ax

		; Copy 128 bytes to AutoScanBuffer
		mov	cx, 010h
		mov	ax, cs
		mul	cx
		mov	bx, dx
		mov	di, ax
		add	di, AutoScanBuffer
		adc	bx, 0

		push	bx
		push	di

ExtendMemNextLp:
		pop	di
		pop	bx

		push	bx
		push	di

		mov	dx, UseExtendMem
		xor	si, si
		mov	cx, 080h
		call	CopyMemory

		; Make sure values in the AutoScanBuffer are identical
		;
		mov	cx, 07fh
		mov	si, AutoScanBuffer

		lodsb
		mov	ah, al

ExtendMemChkLoop:
		lodsb
		cmp	ah, al
		jnz	ExtendMemNext		; exit with zf cleared

		loop	ExtendMemChkLoop

FindExtendMemExit:
		mov	ax, UseExtendMem

		pop	di
		pop	bx

		pop	cx
		ret

ExtendMemNExt:
		inc	UseExtendMem		; goto next 64K region
		cmp	UseExtendMem, 0f000h
		jb	ExtendMemNextLp

		mov	UseExtendMem, 0
		jmp	short FindExtendMemExit

FindExtendMemory	endp

;--------------------------------------------------------------------
; FindStack	- From Top of conventional memory, find 1K of RAM
;		  we can use and return the Segment Value
;		- verify that the region we choose is unoccupied by
;		  examing the 1K region (make sure the values are identical)
;		- if region is occupied, goto next 1K region below
;		  until we reach 1000:0
;
; Entry
; Return:	ax = Segment Value of Stack
;
;--------------------------------------------------------------------
FindStack	proc	near
		push	ds
		push	bx
		push	cx
		int	12h
		sub	ax, 020h		; subtract 32K
		mov	cl, 6
		shl	ax, cl			; convert to segment form
		mov	ds, ax			; ES = Stack base

FindStackAgain:
		mov	cx, 07fh		; test 256 bytes
		mov	si, InitStackPtr
		lodsw
		mov	bx, ax

FindStackLoop:
		lodsw
		cmp	bx, ax
		jnz	FindStackNext

		loop	FindStackLoop

		; Carry would be cleared

		; ES is the stack segment!!
		mov	ax, ds
FindStackExit:
		pop	cx
		pop	bx
		pop	ds
		ret

FindStackNext:	mov	ax, ds
		sub	ax, 0800h
		mov	ds, ax

		cmp	ax, 01000h
		jae	FindStackAgain

		; No way. Can't find 1K free anywhere.
		; Just use ROMBase
		mov	ax, cs		; cs = ROMBase
		jmp	short FindStackExit

FindStack	endp
ENDIF

	include		nad90xb.inc
	include		bw90xb.inc


IFNDEF	UNDI
; ************************************************************************
; HOOKS for CUI.ASM
HookChkChar	proc	near
HookEditInput	proc	near
HookChkInput	proc	near
HookHyphen	proc	near
HookEditSpec	proc	near
		stc
		ret
HookEditSpec	endp
HookHyphen	endp
HookChkInput	endp
HookEditInput	endp
HookChkChar	endp

;----------------------------------------------------------------------
; StoHex - stuff binary AL as 2 hex digits at ES:DI
;
; On entry,
;	AL = binary digit to print as hex
;	ES:DI ptr to string buffer, CLD flag set
; On exit,
;	AX modified, ES:DI ptr to next location in buffer
;
; 920728 1.0 GK adapted from PutHex
;----------------------------------------------------------------------

StoHex	proc	near

	push	ax			; save for lower nibble
	shr	al,1
	shr	al,1
	shr	al,1
	shr	al,1
	call	h_digit
	pop	ax			; now do lower nibble

h_digit:
	and	al,00001111b
	add	al,90h
	daa
	adc	al,40h
	daa
	stosb				; stuff hex digit in buffer
	ret

StoHex	endp

;----------------------------------------------------------------------
; StoDec - stuff AX as CL decimal digits at ES:DI
;
; On entry,
;	AX = number to print as decimal
;	ES:DI ptr to leftmost position of field
;	CL has width of field, will zero-fill
; On exit,
;	AX, CX, DX modified, ES:DI ptr to beyond rightmost position
;
; 920728 1.0 GK adapted from PutHex
;----------------------------------------------------------------------

StoDec		proc	near

		push	ax		; save value
		mov	al, '0'
		mov	ch, 0
		rep	stosb		; fill with zeroes

		mov	cl, 0Ah 	; divide by 10
		pop	ax		; restore value
		push	di		; save ending DI value

StoDecNext:
		xor	dx, dx
		div	cx		; ax, dx rem=dx:ax/reg
		add	dl, 30h 	; '0'
		dec	di
		mov	es:[di], dl
		or	ax, ax
		jnz	StoDecNext

		pop	di		; return with DI pointing after field
		ret

StoDec		endp
ENDIF

;--------------------------------------------------------------------
;
;   SetInterruptVector: this routine determine the mask value for the selected
;			IRQ level and EOI values for both master and slave
;			8259s, remaps IRQ vector to our ISR and save current
;			IRQ vector in case DriverUnhook needs it.  We do not
;			mask on the selected IRQ in this routine, instead, it
;			will be turned on and off as init goes on.
;
;   On Entry:
;	      al = IRQ level
;	      sti
;   On Exit:
;	      sti
;
; 920717 0.0 GK modified, rewrote DOS get/setint calls
;--------------------------------------------------------------------

HookIntVector	proc	near
		push	es

; convert IRQ to interrupt vector number

		mov    al, IRQLevel		    ; al = IRQ level
		mov    ah, 8			    ; IRQ 0-7 => int vector # 08h-0fh
		cmp    al, 8
		jb     int_8tof
	
		mov    ah, (70h-8)		    ; IRQ 8-15 => int vector # 70h-77h
int_8tof:
		add    al, ah			    ; al = int vector number
		cli

; save old interrupt vector

		xor	bx, bx
		mov	es, bx			; ES = 0
		cbw
		mov	bx, ax
		shl	bx, 1
		shl	bx, 1
		les	bx, es:[bx]
		mov	OrgINTVector_Off, bx
		mov	OrgINTVector_Seg, es

; remap int vector to our DriverISR
IFDEF	UNDI
		mov    dx, offset CGroup:UNDI_DriverISR   ; ds:dx = ptr to DriverISR
ELSE
		mov    dx, offset CGroup:DriverISR   ; ds:dx = ptr to DriverISR
ENDIF
		xor	di, di
		mov	es, di			; ES = 0
		cbw
		mov	di, ax
		shl	di, 1
		shl	di, 1

		mov	cs:Int_Vector_Loc, di
	
		mov	ax, dx
		stosw
		mov	ax, cs		;971030
		stosw

; PCInit (GENR.ASM) will mask out IRQ9. Need to unmask again
		mov	al, IRQLevel		    ; al = IRQ level
		cmp	al, 7
		jbe	HookInt9

		in	al, 0A1h		; get slave PIC mask
		jmp	$+2
		and	al, 0fdh		; unmask int 9
		out	0A1h, al

HookInt9:
		; unmask Interrupt now
		mov    dx, int_mask_port
		in     al, dx

		and    al, IntMaskOnBit
		jmp    $+2

		out    dx, al

		cmp    dx, MASTER_MASK_PORT		  ; are we using IRQ from slave?
		je     HookIntVectorExit		 ; no

		in     al, MASTER_MASK_PORT		  ; yes, turn on cascaded input
		and    al, not 04			  ;  on master 8259
		out    21h, al

HookIntVectorExit:
		pop	es
		sti
		ret

HookIntVector	endp


;-----------------------------------------------------------------------------
;   Driver Unhook
;
;   assumes:
;	     DS is setup
;	     Interrupts are DISABLED
;
;   returns:
;	     interrupt disabled
;	     no registers need to be preserved.
;-----------------------------------------------------------------------------
DriverUnhook  proc near

		xor	ax, ax
		mov	es, ax
		mov	di,word ptr cs:Int_Vector_Loc

		mov	ax, OrgINTVector_Off
		or	ax, OrgINTVector_Seg
		jz	unhook_rtn			;nothing to unhook
		mov	ax, OrgINTVector_Off
		mov	es:[di].off, ax
		mov	ax, OrgINTVector_Seg
		mov	es:[di].segm, ax
unhook_rtn:
		ret

DriverUnhook  endp

IFNDEF	UNDI
;----------------------------------------------------------------------------;
;      E I S A	  S U P P O R T    R O U T I N E S
;----------------------------------------------------------------------------;
;------ WriteEEProm ---------------------------------------------------------;
;									     ;
;	This routine writes  a word to the EEProm.  It can only be used      ;
;	once the board has been brought up at a particular IOBase.	     ;
;									     ;
;	Entry:								     ;
;	BL	= EEProm word to write					     ;
;	CX	- Value to write
;	Window	= 0							     ;
;	RealIOBase  = valid						     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;									     ;
;	Destroys BX, CX, DX, SI, DI and ES.  All other registers are	     ;
;	preserved.							     ;
;									     ;
;----------------------------------------------------------------------------;
public		WriteEEProm
WriteEEProm	proc	near
	push	bx
	push	cx
	push	dx

	; To write a word to EEPROM, sequence of events are
	;	1. Issue Erase/Write Enable Cmd ( Port IOBase+A, Value 30h )
	;	2. Issue Erase Cmd ( Port IOBase+A, Value C0h or Address )
	;	3. Issue Erase/Write Enable Cmd again ( Port IOBase+A, Value 30h )
	;	4. Load data into EEPROM Data Reg ( Port IOBase+C, Value Data )
	;	5. Issue Write Cmd ( Port IOBase+A, Value 40 or Address )
	;
	; Always check if EEPROM Busy bit is cleared
;960401	mov	dx, IOBase
;960401	add	dx, PORT_EECmd
	mov	dx, PortEECmd
	call	WaitEEBusy

	mov	ax, 030h
	out	dx, ax				; issue Erase/Write Enable Cmd

	call	WaitEEBusy

	xor	ax, ax
	mov	al, bl
	add	al, 0c0h
	out	dx, ax				; issue Erase EEPROM Cmd

	call	WaitEEBusy

	mov	ax, 030h
	out	dx, ax				; issue Erase/Write Enable Cmd

	call	WaitEEBusy

	mov	ax, cx
;960401	add	dx, ( PORT_EEData - PORT_EECmd )
	mov	dx, PortEEData
	out	dx, ax				; load data

;960401	add	dx, ( PORT_EECmd - PORT_EEData )
	mov	dx, PortEECmd
	xor	ax, ax
	mov	al, bl
	add	al, 040h
	out	dx, ax

	call	WaitEEBusy

	pop	dx
	pop	cx
	pop	bx
	ret
WriteEEProm    endp


;----------------------------------------------------------------------------;
; NADChgReceiveMask - Called by NAD to change the receive mask of adapter.
;		       Change RxFilter to accept Multicast packets
;
; Input:	    bl	  command
;			  b0: set   = enable
;			      clear = disable
;			  b1: change broadcast mask
;			  b2: change multicast mask
;			  b3: change promiscuous mask (not supported yet)
;
;		    es:di pointer to multicast address (FOUND.Dest_Addr)
;
; no reg. changed
;----------------------------------------------------------------------------;
NADChangeReceiveMask	proc	far

		push	si
		push	dx
		push	ax

		mov	dx, PortCmdStatus

	; For the 3Com Chipset, enabling group address reception implies
	; broadcast reception. 
		test	bl, 2			; want to change Broadcast?
		jnz	NADChgBroad

		test	bl, 4			; want to change Multicast?
		jz	NADChgMaskEnd

NADChgMulti:
		test	bl, 1
		jz	NADChgMultiOff

NADChgMultiOn:
		mov	si, offset NIDGroupAddr
		mov	ax, es:[di]
		mov	ds:[si], ax

		add	si, 2
		add	di, 2
		mov	ax, es:[di]
		mov	ds:[si], ax

		add	si, 2
		add	di, 2
		mov	ax, es:[di]
		mov	ds:[si], ax

		mov	ax, HWFilter
		or	ax, FILTER_MULTICAST
		out	dx, ax
		jmp	short NADChgMaskEnd

NADChgMultiOff:
		mov	ax, HWFilter
		and	ax, NOT FILTER_MULTICAST
		out	dx, ax
		jmp	short NADChgMaskEnd

NADChgBroad:
		test	bl, 1
		jz	NADChgBroadOff

NADChgBroadOn:
		mov	ax, HWFilter
		or	ax, FILTER_BROADCAST
		out	dx, ax
		jmp	short NADChgMaskEnd

NADChgBroadOff:
		mov	ax, HWFilter
		and	ax, NOT FILTER_BROADCAST
		out	dx, ax

NADChgMaskEnd:
		mov	HWFilter, ax

		pop	ax
		pop	dx
		pop	si
		retf

NADChangeReceiveMask	endp


;--------------------------------------------------------------------
; ChkForCfg - prompt for config, wait up to 3s for Ctrl-Alt-B or Ctrl-Alt-Z
;
; On exit,
;	ZF set if user selected config option
;
; 911230 0.0 GK
;--------------------------------------------------------------------
ChkForCfg	proc	near
		push	es

		mov	ax, 0040h
		mov	es, ax			; ES = BIOS segment. For ChkKey

;		mov	al, BWTLANOS
;		and	al, BWTLANMASK
;		cmp	al, BWTLANTRI
;		jnz	NotFirst

		; dump "BootWare/3C5x9 supports NetWare..." string & wait for
		; user input
;		mov	ah, NormalAttr
;		mov	si, offset CGroup:Str8022U
;		call	PrintTemplate

;		mov	si, 8			; 8 seconds
;		call	ChkKey

		; check ah to see if <ENTER> is pressed
;		cmp	ah, 01ch	; ZF
;		jmp	short ChkForCfgExit

NotFirst:
		; dump "Press <CTRL><ALT><B>..." string & wait for user input
;		mov	bx, offset CGroup:StrPrompt
;		mov	dx, word ptr [bx]
;		mov	ah, NormalAttr
;		add	bx, 2
;		call	PrintMsgLoc
		mov	dx, 0
		mov	bx, offset cGroup:CfgStr
		call	PrintAt

		mov	si, 3			; 3 seconds
		call	ChkKey

ChkForCfgExit:
		pop	es
		ret			; ret ZF = 1 if config selected

ChkForCfg	endp

;--------------------------------------------------------------------
; ChkKey - prompt for config, wait up to 3s for Ctrl-Alt-B or Ctrl-Alt-Z
;
; On exit,
;	si  = # of seconds
;	ZF set if user selected config option
;
;	For 802.2U, ax = -1 if timeout
;		    ah = keyboard input (scan code)
;
; 911230 0.0 GK
;--------------------------------------------------------------------

ChkKey		proc	near

ChkKeyLoop1:
		mov	ax, 18		; 18 ticks = 1 second

		mov	cs:MaxTicks, ax
		mov	ah, 0
		int	1Ah			; get current tick value
		mov	cs:StartTick, dx	; save it


ChkKeyLoop:
	mov	ah, 1
	int	016h		; Keyboard interrupt - check keyboard status

	jz	ChkKeyTime	; No char available; Check time

; character available. check if char is Ctrl-Alt-B
; checking kybd status will not remove char from buffer

	mov	ah, 0		; Read char. Char is removed from buffer
	int	016h		; Keyboard interrupt

	cmp	ah, 030h	; "B"
	jz	ChkCtrlAlt	; are Ctrl & Alt keys pressed?

	cmp	ah, 02ch	; "Z"
	jnz	ChkKeyEnd

ChkCtrlAlt:
	mov	al, es:[17h]	; keyboard status flag 1
	and	al, 00001100b	; keep Ctrl and Alt bits
	cmp	al, 00001100b	; were they set?
;	 jz	 ChkKeyEnd	 ; yes, exit with ZF set
	jmp	short ChkKeyEnd ; exit with ZF

ChkKeyTime:
	mov	ah, 0
	int	1Ah			; get current tick
	sub	dx, cs:StartTick
	mov	cs:Curticks, dx
	cmp	dx, cs:MaxTicks
	cmc


	jnc	ChkKeyLoop	; Is 1 second yet ????

	mov	al, '.'
	call	PutChr
	dec	si
	jnz	ChkKeyLoop1

	mov	al, -1
	or	al, al		; ret ZF = 0, timeout

ChkKeyEnd:
		ret
ChkKey		endp

ENDIF

;--------------------------------------------------------------------
; Print
;
; Prints string given by DS:BX at current location.
;
; Parameters:
;	ds:bx - pointer to null terminated string
;
; Returns:
;	nothing
;--------------------------------------------------------------------
Print	proc	near

	push	ax			; save ax
	push	si			; save si

	mov	si, bx			; put string address into si

printLoop:
	lodsb				; get a character
	or	al, al			; check for end of line NULL
	je	printDone		; got end of line
	mov	ah, 0Eh
	int	010h			; write TTY
	jmp	short printLoop 	; next char

printDone:
	pop	si			; restore si
	pop	ax			; restore ax
	ret

Print	endp


Int_Vector_Loc		dw	?

IFDEF	UNDI
_TEXT		ends

_DATA		segment	para public
ENDIF
OrgINTVector_Off	dw	0	;save area for original INT vector
OrgINTVector_Seg	dw	0

	even
;------------------------------------------------------------------------------
;	Adapter configuration set by DriverInit during initialization
;------------------------------------------------------------------------------
EEIntConfig0	dw	?		;value of internal config reg
EEIntConfig1	dw	?		;value of internal config reg
EEMiiPhySelect	dw	-1

		even
;
; the various TxStart thresholds, set at INIT time.  must be contiguous and
; MasterTxStart must follow PioTxStart.
;
		even
		public	PioTxStart
PioTxStart	label	word
		rept 4
		TxStartStruc <?, 4, 0, 0, 0, 0>
		endm

		public	AfterTxStart
AfterTxStart	label	word			; marks the end of them

TxFreeMax	dw	?

IntMaskOnBit	db	?
IRQLevel	db	?

		   even

public		BoardID
BoardID 	db	6 dup (0)
LineSpeed	dw	10		;10/100 Mb determined at init

		even

MediaOptions	dw	?
InternalConfig	dd	?

	public	xcvr
xcvr		dw	?		; 10/20/94, cj

OldStackPtr	dw	0		; save Stack Pointer
		dw	0

		   even
PortCmdStatus		dw	0eh	; Win 0	; Command/Status Register

PortBadSsdCount    	label	word	; Win 4
PortTxFree		label	word	; Win 3 
PortEEData  		dw	0Ch	; Win 0 ; EEProm data register

PortMediaStatus		label	word	; Win 4 ; Media type/status
PortRxFree		label 	word	; Win 3	; Rx Free
;PortTimer		label	word	; Win 1 ; 
PortEECmd      		dw	0Ah	; Win 0 ; EEProm command register

PortMediaOptions  	label 	word	; Win 3 ; MediaOptions
PortPhyMgmt		label	word	; Win 4 ; MII Management 
;PortRxStatus		label	word	; Win 1
PortCfgResource 	dw	08h	; Win 0 ; resource configuration

PortNetDiag		label	word 	; Win 4 ; net diagnostic
PortMacControl		label	word	; Win 3 ; MacControl
PortCfgAddress  	dw	06h	; Win 0 ; address configuration

PortFIFODiag		label	word	; Win 4 ; FIFO Diagnostic
PortCfgControl  	dw	04h	; Win 0 ; configuration control

PortInternalCfgH   	label 	word    ; Win 3 ; InternalConfig High
PortProductID   	dw	02h	; Win 0 ; product id (EISA)

PortTxStart		label	word	; Win 5 ; tx start threshold
PortInternalCfgL   	label 	word	; Win 3 ; InternalConfig Low
PortSA0_1  		label	word	; win 2 ; station address bytes 0,1
;PortRxFIFO	   	label 	word	; Win 1 ; offset 00
;PortTxFIFO	   	label 	word	; Win 1 ; offset 00
PortManufacturer	dw	00h	; Win 0; Manufacturer code (EISA)

PortTxStatus		dw	1bh
;
PortPktStatus		dw	20h	; scatter/gather state bits
PortDnListPtr		dw	24h	; phys addr of current DPD
PortUpPktStatus		dw	30h	; upload packet status
PortUpListPtr		dw	38h	; phys addr of current UPD
; cyclone specific
PortDmaCtrl		dw	20h	; formerly Pktstatus
PortDnReq		dw	2Ch
PortDnPoll		dw	2Dh
PortUpReq		dw	3Ch
PortUpPoll		dw	3Dh

NumOfPorts	equ	( $ - PortCmdStatus )/ 2 

; PCI and Extended Memory Stuff
UseExtendMem	dw	0

OldPCIROMAddr	dw	0
		dw	0

AutoScanBuffer	dw	0

CUIAttr 	dw	0		; Store Screen Attribute for CUI
UpdateRetry	db	3		; times to retry before giving up

 		   ALIGN       4

NormalRxEarly	   dw	     ?		; set RxEarly cmd + threshold

CurTxStart	   dw	     CMD_SETTXSTART+TXSTART_DISABLED

PadBytes	   db	     ?

EESoftConfigInfo	dw	?	; EEPROM word 0d
EESoftConfigInfo2	dw	?
CWord			dw	?	; EEPROM word 0e
EECapabilities		dw	0	; EEPROM word 010h
BusType 		db	?	;

		ALIGN	4
eoi_value	dw	?		; ah = master, al = slave
int_mask_port	dw	?

		ALIGN	4
HwFilter	dw	?
IRQBit			db	?

StartTick	dw	0		; save area for tick value
RxPend		db	0		; b7 set if pending for Rx packet
					;  XXXXX NO XXX  else has rx status (0, 1)
IFNDEF	UNDI
MaxTicks	dw	0		; save area for max ticks
CurTicks	dw	0		; save area for current ticks

TxRetries	db	0		; transmission retry count
DestID		db	6 dup (?)	; save area for destination node ID

StatusMsgFlag	dw	0		; pointer to msg to be printed in DLCStatus

MemBase 		dw	0	; for TCP/IP Generic
					; also used to store OldBWTFeature

		ALIGN	4		; always dword-aligned
LookAheadBuffer    db	     LxBufSize+3 dup (?)   ; receive lookahead buffer

		ALIGN   4
TxEDPtr 	dd	?		; save area for transmit ED
RxEDPtr 	dd	?		; save area for receive ED

		ALIGN     4
public		CliBuffer
CliBufferSize	equ	128
CliBuffer	db	CliBufferSize dup (?)	; ** not needed, may be removed
						; along with other code in init
						; that computes copycli

		even
NIDGroupAddr	db	6 dup(0)	; GroupAddr
;ErrStruct	ErrorStruct < 0, 0, 0 >

;public		APITbl
;APITbl		dw	'WB'            ; start of BootWare API table
;		dw	30 dup (0)	; allocate 60 bytes ?
ENDIF

flag		dw	0

MiiSelect	dw	-1
MiiPhyUsed	dw	0
MiiPhyOui	dw	-1
MiiPhyModel	dw	-1
;MiiRegValue	dw	-1
MiiPhyAddr	db	0

phyANLPAR	dw	0
phyANAR 	dw	0

LinkDetected	db	0
forcemode	db	0
broadcom	db	0

Calibration	dd	0
Delayoneusec	dd	0
DelaySomething	dd	0

tempLoc     dw  0

;******************************************************************************
	align	8
DPD		DPDStruc <>
DPD_physaddr	dd	?

	align	8
UPD		UPDStruc <>
UPD_physaddr	dd	?



IFDEF	UNDI
_DATA		ends

_BSS	segment
 	even
	public	TxBuf
	public	RxBuf
TxBuf		db	MAX_RXBYTES dup(?)
RxBuf		db	MAX_RXBYTES dup(?)

_BSS	ends

ELSE
END_NAD
ENDIF

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\nad90x.asm ===
page	,132
;************************************************************************
;* NAD90X.ASM
;*	- Contains modules supporting the NetPC UNDI API for 3c90x
;*
;* Modules included :-
;*	NADInit
;*	NADReset
;*	NADShutDown
;*	NADOpen
;*	NADClose
;*	NADSetFilter
;*	NADGetStatistics
;*	NADRequestINT
;*	NADMCastChange
;*	DriverISR_Proc
;*
;* Latest Update: May 15, 1997
;************************************************************************

.xlist


public	NADInit
public	NADReset
public	NADShutDown
public	NADOpen
public	NADClose
public	NADSetFilter
public	NADGetStatistics
public	NADRequestINT
public	NADMCastChange
public	DriverISR_Proc

public  NADSetMACAddress       ; * NEW
public  NADInitiateDiags       ; * NEW

extrn	IRQNumber:byte
extrn	Net_Address:byte
extrn	Node_Address:byte
extrn	MultiCast_Addresses:word

.list
	.386
;================
NADSetMACAddress	proc	near		; NEW

		push	di
		mov	di, offset DGroup:Node_Address
		mov	eax, dword ptr [si]
		mov	dword ptr ds:[di], eax
		mov	ax, word ptr [si+4]
		mov	word ptr ds:[di+4], ax
		xor	ax, ax
		pop	di
		ret

NADSetMACAddress	endp

;
;================
NADInitiateDiags	proc	near		; New

		stc
		ret

NADInitiateDiags	endp


;=========================================================================
; NADInit
;=========
;	- Initializes the adapter but does not enable the Tx and Rx units
;	- Init variables such as IOBase, ROMBase, IRQNumber, Net_Address
;		NodeAddress for UNDI_NAD
;	- Hook receiving ISR
;
; Parameters:
;
; Return:	If CF = 0 then success,
;		else failure with  AX = 1 -> hardware failure
;			           AX = 2 -> media failure
;
; Remark:	Don't hook INT if this function fails
;=========================================================================
NADInit 	proc	near

;		push	ds
		push	es

;		mov	ax, cs
		mov	ax, ds
		mov	es, ax

		call	Init_Adapter		;init vulcan hardware and
						;  variables, IOBase, IRQLevel
		or	ax, ax
		jnz	NADInitErr

		mov	al, IRQLevel
		mov	DGroup:IRQNumber, al

		cld
;		mov	cx, 6
;		mov	di, offset DGroup:NodeAddress
;		mov	si, offset DGroup:BoardID
;	rep	movsb

		mov	cx, 6
		mov	di, offset DGroup:Net_Address
		mov	si, offset DGroup:BoardID
	rep	movsb

		call	Init_Adapter2

		cmp	LinkDetected, 0
		jz	no_media

		mov	dx, PortCmdStatus
		mov	ax, CMD_STATSENABLE
		out	dx, ax			;enable statistics counters

		call	HookIntVector

		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING		 ; switch to window 1

		clc
		jmp	NADInitx

no_media:
		mov	ax, 2
		jmp	initerr
NADInitErr:
		mov	ax, 1
initerr:
		stc
NADInitx:
		pop	es
;		pop	ds
		ret

NADInit 	endp


;=========================================================================
; NADReset
;==========
;	- Reset and Reinitialize the adapter
;	- Enables the Tx and Rx units
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADReset	proc	near

		call	Init_Adapter2

		mov	dx, PortCmdStatus
		mov	ax, CMD_STATSENABLE
		out	dx, ax			;enable statistics counters
		clc
		ret

NADReset	endp


;=========================================================================
; NADShutDown
;=============
;	- reset the adapter
;	- unhook our ISR
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADShutDown	proc	near

		mov	dx, PortCmdStatus
		xor	ax,ax			   ; global reset
		out	dx,ax
GResetWait:
		in      ax, dx
		test    ah, STH_BUSY
		jnz	GResetWait		   ; loop while busy
;;;
		call	DriverUnhook

		mov	ax, IOBase
		mov	cx, NumOfPorts
		mov	di, offset DGroup:PortCmdStatus
KillPorts:
		sub	ds:[di], ax
		add	di, 2
		loop	KillPorts

		clc
		ret

NADShutDown	endp


;=========================================================================
; NADOpen
;=========
;	- Enables the Tx and Rx units
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADOpen 	proc	near

		mov	dx, PortCmdStatus
		call	TxReset
		
		mov	ax, CMD_TXENABLE
		out	dx, ax			;enable Tx

		mov	ax, CMD_RXENABLE
		out	dx, ax			;enable Rx

		clc
		ret

NADOpen 	endp


;=========================================================================
; NADClose
;==========
;	- Disables the Tx and Rx units
;
; Parameters:
;
; Return:	carry set if failure
;=========================================================================
NADClose	proc	near

		mov	dx, PortCmdStatus
		mov	ah, CMDH_TXDISABLE
		out	dx, ax			;disable Tx
		mov	ah, CMDH_RXDISABLE
		out	dx, ax			;disable Rx

		clc
		ret

NADClose	endp


;=========================================================================
; DriverISR_Proc
;================
;	- ISR procedure to be called by UNDI_DriverISR
;
; Parameters:	DS = DataSeg
;
; Return:	CF = a if not our int
;=========================================================================
DriverISR_Proc	proc	near

		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING
;
; check whether our board caused the interrupt
;
		in	ax, dx			; AL=Interrupt Reasons
		test	al, INT_LATCH
		jnz	isr_ours
not_ours:
;;db 0f1h    
		stc
		ret

isr_ours:
		pushf
		push	cs
		call	DriverISR	;a near call with IRET
		clc
		ret

DriverISR_Proc	endp


;=========================================================================
; NADSetFilter
;==============
;	- Change the rx unit's filter to a new one
;	- Handle the promiscuous/broadcast/multicast mode for the
;		rx unit accordingly if necessary
;
; Parameters:	AX = filter value, 1 = directed/multicast
;				   2 = broadcast
;				   4 = promiscuous
; Return:	carry set if failure
;=========================================================================
NADSetFilter	proc	near

		push	ax
		mov	dx, PortCmdStatus
		mov	ah, CMDH_RXDISABLE	;disable Rx
		out	dx, ax
		pop	ax

		shl	al, 1
		test	al, 00000010b
		jz	go_set_filter
		or	al, 00000001b	;set bit 0 if bit 1 is set
go_set_filter:
		mov	ah, CMD_SETRXFILTER/256
		mov	HWFilter, ax
		out	dx, ax
;
; if the filter setting was non-zero, enable the receiver.  otherwise, disable
; the receiver.
;
		test	al, al			; zero filter?
		jz	SetFilterEnd
;
; handle multicast addresses here if necessary
;
		mov	ah, CMDH_RXENABLE	;enable Rx
		out	dx, ax			;set Rx unit
SetFilterEnd:
		clc
		ret

NADSetFilter	endp


;=========================================================================
; NADGetStatistics
;==================
;	- Read the adapter's statistics
;
; Parameters:	ds:si points to variables holding the result
;			TxGoodFrames	dd	0	;1
;			RxGoodFrames	dd	0	;2
;			RxCRCErrors	dd	0	;3
;			RxDiscarded	dd	0	;3
;		ax = 0 means get the result
;		   = 1 means clear the statistics
;
; Return:	Carry clear if data obtained successfully
;=========================================================================
NADGetStatistics	proc	 near

		push	dx
		push	ax

		mov	dx, PortCmdStatus
		SelectWindow WNO_STATISTICS

		pop	ax
		or	ax, ax
		jz	get_data
		
		xor	ax, ax
		add	dx, 6			;PORT_TXFRAMES
		out	dx, al

		mov	dx, PortCmdStatus
		add	dx, 7			;PORT_RXFRAMES
		out	dx, al

		mov	dx, PortCmdStatus
		add	dx, 5			;PORT_RXDISCARDED
		out	dx, al
		
		jmp	short GetStatRet

get_data:
		xor	eax, eax
		add	dx, 6			;PORT_TXFRAMES
		in	al, dx
		mov	dword ptr [si], eax
		add	si, 4

		mov	dx, PortCmdStatus
		add	dx, 7			;PORT_RXFRAMES
		in	al, dx
		mov	dword ptr [si], eax
		add	si, 4

		mov	dword ptr [si], 0
		add	si, 4

		mov	dx, PortCmdStatus
		add	dx, 5			;PORT_RXDISCARDED
		in	al, dx
		mov	dword ptr [si], eax

GetStatRet:
		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING
		pop	dx

		clc
		ret

NADGetStatistics	endp


;=========================================================================
; NADRequestINT
;================
;	- Generate an interrupt to the host
;
; Parameters:
;
; Return:
;=========================================================================
NADRequestINT	proc	near

		mov	dx, PortCmdStatus
		mov	ax, CMD_REQUESTINT
		out	dx, ax
		ret

NADRequestINT	endp


;==========================================================================
; NADMCastChange
;================
;	- Modify the multicast buffer to receive the multicast addresses
;	  listed in the multicast table.
;         Each entry in the multicast table is as follows:
;                 Bytes 0-5 = Multicast Address
;         All addresses are contiguous entries
;
; Parameters:	CX =  Number of multicast entries.
;               ES:SI -> Multicast Table.
;
; Return:	All registers may be destroyed.
;==========================================================================
NADMCastChange	proc	near

		push	ds

;		mov	dx, PortCmdStatus
;		mov	ax, CMD_RXDISABLE
;		out	dx, ax			;disable Rx

		push	ds
		push	es
		pop	ds		;ds:si -> mc table
		pop	es		;es = ds

		cmp	cx, MAXNUM_MCADDR
		jbe	MCsave
		mov	cx, MAXNUM_MCADDR
MCsave:
		lea	di, DGroup:MultiCast_Addresses
		mov	(Eth_MCastBuf ptr es:[di]).MCastAddrCount, cx
		jcxz	MC_SaveDone
;
; copy addresses from ds:si to es:di
;
		lea	di, (Eth_MCastBuf ptr es:[di]).MCastAddr
MC_SaveLoop:
		mov	eax, dword ptr [si]
		mov	dword ptr es:[di], eax
		mov	ax, word ptr [si+4]
		mov	word ptr es:[di+4], ax

		add	si, ADDR_LEN		; each unit is 16 bytes long
		add	di, ETH_ADDR_LEN
		loop	MC_SaveLoop
MC_SaveDone:
		pop	ds

;		mov	dx, PortCmdStatus
;		mov	ax, CMD_RXENABLE
;		out	dx, ax			;enable Rx

		lea	si, DGroup:MultiCast_Addresses
		mov	cx, (Eth_MCastBuf ptr [si]).MCastAddrCount
		lea	si, (Eth_MCastBuf ptr [si]).MCastAddr

		clc
		ret

NADMCastChange	endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\nad90xb.inc ===
;	NAD modules for 3C90XB PCI
;
; Modules included:
;  - NADChangeReceiveMask
;  - NADConfig
;  - NADDisengage
;  - NADGetBootInfo
;  - NADInitialize
;  - NADPCIConfig
;  - NADPoll
;  - NADRelocate
;  - NADReset
;  - NADStart
;  - NADTransmitPacket
;
;  - Interrupt Service Routines
;  - SoftRxReset
;  - TxReset
;  - RxReset
;  - RxDiscard
;
; 960618 GY    - Add support for Broadcast
; 960401 GY - Replace some MACROS with code
;        - standardize port access
;******************************************************************************

IFDEF	UNDI
extrn	GETED:near
extrn	MultiCast_Addresses:word
extrn	EDListHead:word
extrn	EDListCurrent:word
extrn	ApiEntry:word
ENDIF

NADRelocate proc far
	ret
NADRelocate endp

IFDEF	UNDI
NADGetBootInfo	proc	near
NADInitialize	proc	near
NADConfig	proc	near
NADStart	proc	near
		ret
NADStart	endp
NADConfig	endp
NADInitialize	endp
NADGetBootInfo	endp

ELSE
;--------------------------------------------------------------------
; NADGetBootInfo
;
; This function is called at the start of INT19 read the current
; configuration from the ROM.  The configuration is returned in ax.
;
; Values:
;	  1  local boot is default
;	  2  ROMShield enabled
;	  4  config menu enabled
;	 64  floppy drive disabled
;	128  hard drive disabled
;
; Parameters:
;	DS = RAM segment
;
; Returns:
;	ax - boot info
;--------------------------------------------------------------------

		xor	ax, ax
		test	BWTFeature, 1
		jz	no_local
		or	ax,1
no_local:
		test	BWTFeature, 2
		jz	no_rs  
		or	ax,2
no_rs:
		test	BWTFeature, 4
		jnz	no_menu
		or	ax,4
no_menu:
		test	BWTLanOS, 1
		jz	floppy
		or	ax,64
floppy:
		test	BWTLanOS, 2
		jz	hard
		or	ax,128
hard:
		ret

NADGetBootInfo	endp


;--------------------------------------------------------------------
; NADInitialize
;
; Initializes the network adapter and connects the adapter to the
; physical media.
;
; Parameters:
;	AX = PCIBusDevFunc #
;	DX = screen location to dislay initializing string
;	DS = RAM segment
;	ES = ROM Base
;
; Returns:
;	AX = 0 if no error else pointer to fatal error
;--------------------------------------------------------------------
NADInitialize	proc	near

		push	ds
		push	es

		mov	DGroup:PCIBusDevFunc, ax
		mov	ax,es
		mov	ROMBase, ax

		push	cs
		pop	ds
		mov	bx, offset CGroup:StrPrompt
		call	PrintAt

		push	cs
		pop	es

		; Update some init variables (BusType, IOBase, IRQ ...)
		mov	BusType, BUS_PCI

		call	Init_Vulcan		; init vulcan hardware and
						;  variables
		cld
		mov	cx, 6
		mov	di, offset NetAddress
		mov	si, offset BoardID
		rep	movsb

		call	Init_Vulcan2

		mov	LookAheadBufferPtr.segm, cs

		call	HookIntVector

		mov	dx, PortCmdStatus
		SelectWindow WNO_OPERATING		 ; switch to window 1

		xor	ax,ax
NADInitExit:
		pop	es
		pop	ds
		ret

NADInitialize	endp


;--------------------------------------------------------------------
; NADConfig
;
; Displays an optional configuration screen for the user to change
; ROM settings.
;
; Parameters:
;	dx = screen location for initialize string
;	ds = RAM segment
;
; Returns:
;	ax - pointer to configuration message
;--------------------------------------------------------------------
NADConfig	proc	near

		push	ds

		push	cs
		pop	ds
		mov	bx, offset CGroup:BlankStr
		call	PrintAt

		mov	ax, IOBase
		mov	NIC_IO, ax		; copy I/O base to NAD table

		mov	al, IRQLevel
		mov	NIC_IRQ, al		; copy IRQ to NAD table

;		cld
;		mov	cx, 6
;		mov	di, offset CGroup:NetAddress
;		mov	si, offset CGroup:BoardID
;		rep	movsb

;		call   ClearScreen
		xor	ax,ax

		pop	ds
		ret

NADConfig	endp


;--------------------------------------------------------------------
; NADStart
;
; Determine the protocol the ROM is configured, then jump to it.
;
; Parameters:
;	none
;--------------------------------------------------------------------
NADStart	proc near

		call	BuildNADAPI

		mov	al, BWTLANOS
		and	al, BWTLANMASK
		cmp	al, BWTLANRPL
		jnz	NotRPL
		jmp	CGroup:RPLStart

NotRPL:
	 	cmp	al, BWTLANIP
		jnz	NotIP
		jmp	CGroup:IPStart
NotIP:
		jmp	CGroup:NetWareStart

NADStart	endp


;--------------------------------------------------------------------
; NADPCIConfig
;
; Displays configuration screen for the user to change ROM settings.
;
; Parameters:
;	ds = RAM segment
;--------------------------------------------------------------------
NADPCIConfig	proc	near

		push	ds

		mov	al, NormalAttr
		mov	ah, ReverseAttr
		mov	CUIAttr, ax
		mov	NormalAttr, ASNormalAttr
		mov	ReverseAttr, ASReverseAttr

		call	ASConfig		; autoscan config
		mov	NormalAttr, ASNormalAttr
		mov	ReverseAttr, ASReverseAttr
		jnc	ConfigNoUpdate

	; Problem with Phoenix BIOS where SS is required to be
	; the same as CS
	; Assume that NOTHING is on the STACK!!!
;		cli
;		mov	ax, cs
;		mov	ss, ax
;		sti

		call	UpdatePCI_PEROM

	; Problem updating ROM. Just dump error message and let
	; them proceed
		xor	al, al		; Get user to press <ENTER> for acknowledge
		call	PrintErrMsg
		call	ClearScreen
ConfigNoUpdate:
		pop	ds
		ret

NADPCIConfig	endp
ENDIF

;----------------------------------------------------------------------
;  Routine Name:  NADTransmitPacket Routine
;
;  Description: The NADTransmitPacket Routine accepts all directed
;     send requests from the RIPL ROM NID code.  This
;     routine determines the validity of the request and
;     works with the adapter to carry it out.
;
;  Input:   ES:SI - pointer to ED
;     DS - Data Segment of RPL Module
;     ints disabled (spec says enabled)
;
;  Output:  ED Completion Code field updated
;     DS preserved
;     ints enabled (doesn't matter)
;
;  Calls:   TransmitPacket
;----------------------------------------------------------------------
public   NADTransmitPacket ; for DEBUGGING
NADTransmitPacket  PROC near		;FAR

		push	ds			; save caller ds

;PM		push	cs
;		pop	ds			; set ds = cs

		cld				; Clear direction
		cli				; ints off

 		push	si			; save ED offset
	 	mov	di, offset DGroup:TxBuf
		mov	cx, [es:si].ED_FragCount; get fragment count
		lea	bx, [si].ED_FragOff	; point to first fragment descriptor
Tx_Frag_Loop:
		push	cx			; save fragment count
		mov	cx, [es:bx].FragLen	; length of this fragment
		lds	si, [es:bx].DPointer	; location of this fragment
		push	es
		mov	ax, cs:ApiEntry.mlid_ds_sel
		mov	es, ax
	rep	movsb
		pop	es
Tx_Frag_End:
		pop	cx		; restore fragment count
		add	bx, size Frag	; next descriptor
		loop	Tx_Frag_Loop	; loop through all fragments

Start_Tx:
;PM		push	cs
;		pop	ds		; restore cs = ds
		mov	ax, cs:ApiEntry.mlid_ds_sel
		mov	ds, ax

		pop	si		; restore ED offset

		xor	eax, eax
		mov	ax, es:[si].ED_Length		; get total packet length
		mov	bx, offset DPD
		mov	[bx].DPD_FSHindicate, 0000h	; turn off dnIndicate
		mov	[bx].DPD_FrameStart, 8000h 	; txIndicate, dword roundup
		mov	[bx].DPD_Frag.Frag_len, eax	 ; # of bytes of data
		or	[bx].DPD_Frag.Frag_len, FRAGLAST ; set fraglast bit

		mov	dx, PortDnListPtr
		mov	eax, DPD_physaddr
		out	dx, eax 		; enable download
;
; wait for completion, and check for errors
;
		sti			; ints on again
;		mov	ah, 0		; get current system tick count
;		int	1Ah		; timer services
;		mov	StartTick, dx	; save timer value

		mov	cx, 250
WaitFornTx:
		push	cx
		mov	cx, 1000	; delay
WaitForEndTx:
		mov	dx, PortTxStatus
;		in	al, dx
		in	al, dx	
		test	al, TXS_COMPLETE  ; done yet?
		jnz	TxFinish	  ; jump if Tx complete

;		mov	ah, 0		; get current system tick count
;		int	1Ah		; timer services
;		sub	dx, StartTick	; subtract start time
;		cmp	dx, 5		; 5 ticks time-out
;		jb	WaitForEndTx	; loop until time-out

		call	Delay500ns
		call	Delay500ns
		loop	WaitforEndTx
		pop	cx
		loop	WaitfornTx

BadConnection:
		mov	dx, PortCmdStatus
		call	TxReset		; make sure FIFO is flushed

		mov	ah, CMDH_TXENABLE
		out     dx, ax		; enable the transmitter

		mov	es:[si].ED_ErrMsg, offset CGroup:NoNetMsg
		mov	es:[si].ED_ErrCode, TRANSMIT_ERROR

		jmp	short NetSendRet

; copy done, return

TxFinish:
		pop	cx
		out	dx, al		; pop Tx status
		test	al, TXS_ERRTYPE	; any error bits set?
		jnz	NetSendError

		mov	es:[si].ED_ErrCode, SUCCESSFUL
NetSendRet:
		pop	ds		; restore callers ds
		ret

NetSendError:
;		push	ax
		mov	es:[si].ED_ErrMsg, offset CGroup:TxMsg
		mov	es:[si].ED_ErrCode, TRANSMIT_ERROR
;		pop	ax

		test	al, TXS_UNDERRUN or TXS_JABBERERROR
		jz	NotTxUnderOrJabber

		mov	dx, PortCmdStatus
		call	TxReset			; reset transmitter

		mov     ah, CMDH_TXENABLE
		out     dx, ax			; enable the transmitter

		jmp	short NetSendRet

NotTxUnderOrJabber:
		mov	dx, PortCmdStatus
		mov     ah, CMDH_TXENABLE
		out     dx, ax			; enable the transmitter
		jmp	short NetSendRet

NADTransmitPacket	ENDP


;--------------------------------------------------------------------
; TxReset - reset the transmitter
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;--------------------------------------------------------------------
TxReset		proc	near

		mov	ax, CMD_TXRESET		;+ TXRXRESET_ALLBUTBM
		out	dx, ax
?txrloop:
		in	ax, dx
		test	ah, STH_BUSY
		jnz	?txrloop                ;; loop while busy
		ret

TxReset		endp


;--------------------------------------------------------------------
; RxReset - reset the receiver
;
; entry:
;   dx = cmd/status port
;
; destroys:
;   ax
;--------------------------------------------------------------------
RxReset		proc	near

		mov	ax, CMD_RXRESET
		out	dx, ax
?rxrloop:
		in	ax, dx
		test	ah, STH_BUSY
		jnz	?rxrloop                    ;; loop while busy
		ret

RxReset		endp


;--------------------------------------------------------------------
; RxDiscard - discard top packet in RxFIFO
;
; entry:
;   ds = DGROUP
;   dx = cmd/status port
;   cli
;
; exit:
;   cli
;
; destroys:
;   ax
;--------------------------------------------------------------------
;RxDiscard	proc  near

;		mov	dx, PortUpListPtr
;		mov	eax, UPD_physaddr
;		out	dx, eax 			; write UpListPtr
;		ret

;RxDiscard	endp


;------ SoftRxReset -------------------------------------------------
;
;  This routine does an RxReset to clear out the RxFIFO and its
;  associated logic.  After the RxReset, it reenables and restores
;  the current RxFilter and RxEarly thresholds.
;
;  Entry:
;  DS = DGROUP
;  DX = port CmdStatus
;  cli
;
;  Exit:
;  cli
;  Destroys AX.  All other registers preserved.
;
;--------------------------------------------------------------------
		 public SoftRxReset
SoftRxReset   proc   near

		call	RxReset

		mov	dx, PortCmdStatus
		mov	ax, HWFilter      ; has CMD_SETFILTER in it
		out	dx, ax

		; enable the receiver
		mov     ah, CMDH_RXENABLE
		out     dx, ax

		mov   ax, NormalRxEarly ; has CMD_SETRXEARLY in it
		out   dx, ax

		ret
SoftRxReset endp


IFNDEF	UNDI
;----------------------------------------------------------------------
;  Routine Name:  NADPoll Routine
;
;  Description: The NADPoll routine is used by the RIPL ROM NID
;     portion of the RIPL ROM to poll the driver portion so
;     that the driver portion can do timeout work.
;
;  Input:   DS - Data Segment of RPL Module
;     ints enabled
;
;  Output:  DS preserved
;     ints enabled
;
;  Calls:   none
;----------------------------------------------------------------------
NADPoll  proc  far
	retf				; nothing to do...
NADPoll  endp

;----------------------------------------------------------------------
;  Routine Name:  NADDisengage Routine

;  Description: The NADDisengage routine is used by the RIPL ROM NID
;     portion of the RIPL ROM to signal the Network Driver
;     to release its IRQ, DMA, and memory resources.
;
;  Input:   DS - Data Segment of RPL Module
;     ints enabled
;
;  Output:  DS preserved
;     ints enabled
;     ax = offset to error string or 0 if successful
;
;  Calls:   none
;
; July 10,91   implement NIDDisengage version 0.8
;----------------------------------------------------------------------
NADDisengage   PROC  FAR
	push  ds
	push  es

	cli

	; is it RPL ?
	test  cs:BWTLANOS, BWTLANRPL
	jz DisengageRPL

	; change IntFD to point to NADIntFD in ROMTOP.ASM. Depending on
	; the ROMSize, RPLBOOT.SYS might call the IntFD that is not
	; even mapped on the system and hang the machine
	xor   ax, ax
	mov   es, ax
	mov   di, 0FDh*4
	mov   ax, offset CGroup:NADIntFD
	stosw
	mov   ax, cs:ROMBase    ; 940118
	stosw

	; make sure that it works on every page. Int13 should point to NADIntFD
	; also.
	mov   di, 013h*4
	mov   ax, offset CGroup:NADIntFD
	stosw
	mov   ax, cs:ROMBase
	stosw

	push  cs
	pop   es

DisengageRPL:

		; 3Com 5X9 NDIS driver place ISR at IRQ 2 rather than IRQ 9 ( compatability
		; with IBM 3270 program ). Thus, this routine needs to restore the old
		; BIOS IRQ9 handler to invoke IRQ2. Also, this routine should NOT
		; mask IRQ9.

		mov    dx, Int_mask_port
		in     al, dx
	
		or     al, cs:IRQBit
		jmp    $+2

		out    dx, al

		; restore handler
		call  DriverUnhook

		; unmask IRQ 9 again so that interrupt will pass to IRQ2 ISR
		cmp   cs:IRQLevel, 9
		jnz   DisengageExit

		mov   dx, 0a1h
		in al, dx
		and   al, 0fdh
		out   dx, al

DisengageExit:
		pop   es
		pop   ds

		sti
		xor   ax, ax
		retf        ; Return to caller

NADDisengage   endp
ENDIF


;------------------------------------------------------------------------------
; packet completed, but RxStatus.Err indicates the packet experienced an error
; during receiving.

ip_bad:
;		call	RxDiscard
; A packet may be marked as a runt but it may be a good packet
; This happens after a real bonafide runt.   The packet after it
; could also be marked as a runt but is really a good packet.

		mov	al, UPD.UPD_UpPktError
		cmp	al, RXE_RUNT		; the only error is a runt
		jnz	ipbad
		cmp	cx, 60			; yes, check the length to verify it is ok
		jl	ipbad
		jmp	isr_accept
ipbad:
		jmp	int_next

;------------------------------------------------------------------------------
; various errors: No ECB, pkt too small, pkt too big, pkt with bad size
ip_discard_pkt:
;		call	RxDiscard 
		jmp	int_next    ; dx = port CmdStatus

;--------------------------------------------------------------------
;
;  Upload Complete interrupt.
;
;--------------------------------------------------------------------
; entry:
;   interrupt is disabled at adapter level. (through SetIntMask cmd).
;   EOIs have been issued to PICs.
;   we've not done sti
;
;   dx = port CmdStatus
;   cli
;   cld
;
;--------------------------------------------------------------------
isr_UpPkt:
; acknowledge upComplete int
;		mov	dx, PortCmdStatus
		mov	ax, CMD_ACKNOWLEDGE + INT_UPCOMPLETE	
		out     dx, ax

		mov	ax, UPD.UPD_UpPktStatus
		mov	cx, ax
		and	cx, RXS_LENGTH		;packet length

		test	ah, RXSH_ERROR		; error reported?
		jnz	ip_bad
isr_accept:
;
; get Packet Length from UpPktStatus register
;
		mov	ax, cx
IFDEF UNDI
		call	GetED
ELSE
		call	[AIGetEDJmp]		; get an ED (ES:SI)
ENDIF
		jz	ip_discard_pkt		; we didn't get an ED

		mov	bx, si			; move ED offset to bx
		mov	es:[si].ED_Length, ax	; save length in ED
		mov	cx, es:[si].ED_FragCount; get number of fragments
		lea	bx, [si].ED_FragOff	; point to 1st descriptor

		mov	dx, ax			; move packet size to dx
DRxNxtF:
		push	cx
		push	es
		mov	cx, es:[bx].Dlen	; get fragment length
;PM		les	di, es:[bx].Dpointer	; get fragment pointer
		mov	ax, ds
		mov	es, ax
		mov	di, word ptr es:[bx].Dpointer	; get fragment pointer
ChkMovSize:
		cmp	dx, cx
		ja	MoveFrag		; more data after this frag

		mov	cx, dx			; no more data after this frag
MoveFrag:
		sub	dx, cx			; subtract size of this frag
		jcxz	DrxDoNxt 		; zero count -- skip data read

		push	si
		mov	si, offset DGroup:RxBuf
	rep	movsb
		pop	si

DrxDoNxt:
		pop	es
		pop	cx
		add	bx, 6			; point to next fragment desc
		loop	DRxNxtF			; do next frag, if any

; -- DX has # of bytes that couldn't fit in receive descriptors

NoRxFrag:
;PM		push	cs
;		pop	ds			; restore DS = CS
;		mov	ax, cs:ApiEntry.mlid_ds_sel
;		mov	ds, ax

		mov	es:[si].ED_ErrCode, 0	; Set good completion

IFDEF	UNDI
		lea	bx, [si].ED_FragOff	; point to 1st descriptor
;		les	di, es:[bx].Dpointer	; get fragment pointer
		mov	ax, ds
		mov	es, ax
		mov	di, word ptr es:[bx].Dpointer	; get fragment pointer

		cmp	byte ptr es:[di], 01h
		jnz	NoMCastCheck		; not a MC address
		mov	si, offset DGroup:MultiCast_Addresses
		mov	cx, (Eth_MCastBuf ptr [si]).MCastAddrCount
		jcxz	NoMCastCheck		; no MC address

		lea	si, (Eth_MCastBuf ptr [si]).MCastAddr
CheckMC:
		push	cx
		mov	cx, 6		;length of address in byte
	repz	cmpsb
		jcxz	MCastFound	;this is our MC address

		add	si, 6
		pop	cx
		loop	CheckMC
;
; not our MC address, kill the recently saved ED
;
		mov	si, DGroup:[EDListCurrent]	; get current ED
		mov	word ptr [si].ED_Length, 0	;kill the data
		mov	DGroup:[EDListHead], si	; move the head backward
		jmp	DiscardRxData

MCastFound:
		pop	cx
NOMCastCheck:
ELSE
		call	[AIPostEDJmp]		; post the received packet
ENDIF

; we've copied all packet data out of RxFIFO, now discard postamble and any
; pad bytes inserted by hardware.

DiscardRxData:
;		call  RxDiscard         ; discard padding & postamble

; copy is done, now tell foreground that a packet is available

		jmp   int_next

;------------------------------------------------------------------
;
; DriverISR:  Interrupt Service Routine for Vulcan
;
;------------------------------------------------------------------

	 public DriverISR

		 ALIGN  4
		 db     'ISR'

DriverISR	proc   near

		pusha
		push	ds
		push	es
;PM		mov	ax, cs
		mov	ax, cs:ApiEntry.mlid_ds_sel
		mov	ds, ax

		cld

; mask off all interrupts at adapter level. and release the system interrupt
		mov	dx, PortCmdStatus
		mov	ax, CMD_SETINTMASK + MASK_ALL
		out	dx, ax			; disable all interrupts

; acknowledge interrupt
		mov	ax, CMD_ACKNOWLEDGE + INT_LATCH
		out     dx, ax

		mov	ax, eoi_value		; ah = EOI for master PIC
						; if int < 8, eoi_value = 6040h
						;   else eoi_value = 6220h
		cmp	al, 40h			; Int level < 8 ? (i.e. NOP)
		jz	EOIMaster		; No, need EOI to Slave PIC

		out	SlaveEOIPort, al	; al = EOI for slave PIC

		jmp	$+2
		jmp	$+2
		jmp	$+2
		jmp	$+2
		jmp	$+2
		jmp	$+2
EOIMaster:
		mov	al, ah			; send EOI to Master 8259 PIC
		out	MasterEOIPort, al

;----------------------------------------------------------------------------
; read the reason for the interrupt and dispatch control to the appropriate
; routine through jump table.  When that reason has been handled the routine
; will jump  to int_next.  if there is no reason for the interrupt
; we will simply end up at isr_return. the following types of interrupt
; are handled:
;
;      a. Adapter Failure
;      b. Upload Complete
;      c. Interrupt Request (not supported, ack and return)

isr_1st_pass:
;		mov	dx, PortCmdStatus
		in	ax, dx
		jmp	IntDispatch

; there is another interrupt reason.  since we might be close to our disable
; time limit, enable before we handle it.

isr_again:				; AL has CmdStatus contents
		 sti
		 nop
		 cli
		 jmp    IntDispatch

; once the code entered through IntDispatch has completed its task, it jumps
; to this label. check for any remaining reasons.

int_next:
		mov	dx, PortUpListPtr
		mov	eax, UPD_physaddr
		out	dx, eax 		;re-enable upload engine

		xor	ax, ax
		mov	UPD.UPD_UpPktStatus, ax

		mov	dx, PortCmdStatus
		mov	ax, CMD_STALLCTL OR UP_UNSTALL
		out	dx, ax
xrloop:
		in	ax, dx
		test	ah, STH_BUSY
		jnz	xrloop                ;; loop while busy

;PM		mov	ax, cs
;		mov	ds, ax			; DS = CS
;		mov	dx, PortCmdStatus
;		in	ax, dx			; read status reg see if any
;		and	ax, 0412h
;		test	ax, ax			; more interrupts to be
;		jnz	isr_again		; serviced?

;-----------------------------------------------------------------------------
; nothing left showing in status.
isr_return:

;----------------------------------------------------------------------------
; reenable interrupts from the adapter.
;
; note: if indications are disabled, they are masked off through the
; ReadZeroMask so reenabling interrupts will have no effect on those bits.

isr_enable:
		cli

		mov	dx, PortCmdStatus
		mov	ax, CMD_SETINTMASK + BOOTWARE_INTS
		out	dx, ax			;re-enable INT

		pop	es
		pop	ds
		popa

		iret

DriverISR	endp


IntDispatch:
		test	ax, INT_ADAPTERFAIL
		jz	IntNotFail
		jmp	isr_AdapterFailure

IntNotFail:
		test	ax, INT_RXCOMPLETE
		jz	IntNotRxComplete
		mov	cx, 10
wait_upcomplete:
		mov	ax, UPD.UPD_UpPktStatus
		test	ax, UPPKTCOMPLETE
		jnz	isr_UpPkt
		call	Delay500ns
		loop	wait_upcomplete
		jmp	int_next

IntNotRxComplete:
		test	ax, INT_UPCOMPLETE
		jz	IntNotUpComplete
		jmp	isr_UpPkt

IntNotUpComplete:
;		test	ax, INT_TXCOMPLETE   ; shouldn't happen, only if cable not connected
;		jz	IntNotTxComplete

;		mov	dx, PortTxStatus
;		in	al, dx
;		cmp	al, 0C0h
;		jne	xx
;		mov	cGroup:flag, 1
;xx:
;		out	dx, al         ; pop tx status to turn the bit off
;		mov	dx, PortCmdStatus
;		mov	ax, CMD_ACKNOWLEDGE + 4
;		out	dx, ax
;		jmp	int_next

IntNotTxComplete:
		test	al, INT_REQUESTED
		jz	isr_return

;	mov	al, 85h
;	call	puthex

isr_IntRequest:
; acknowledge interrupt
		mov	ax, CMD_ACKNOWLEDGE + INT_REQUESTED
		out     dx, ax
		jmp	isr_return     ; Solve mysterious problem with V2

isr_AdapterFailure:
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS        ; switch to window 4

		mov	dx, PortFIFODiag
		in	ax, dx

		mov	dx, PortCmdStatus
		test	ax, FIFOD_RXUNDERRUN
		jz	chk_tx_overrun

; RxUnderrun.  ASIC (rev 1) adapter failure int. due to a false RxUnderrun.
; we just call SoftRxReset to reset the receiver and return to int_next as
; a software workaround to a hardware problem.

		 public AdapterFailure_Rxunderrun

AdapterFailure_Rxunderrun:
		SelectWindow WNO_OPERATING

		mov   dx, PortCmdStatus
		call   SoftRxReset

		jmp    int_next

chk_tx_overrun:
		test   ax, FIFOD_TXOVERRUN
		jz     ia_shutdown

; TxOverrun.  Probably a software error, but since its probably on the back end
; of the TxFIFO and the error shuts down the transmitter, we won't have sent
; any bad packets yet (with rev 1 silicon).  Reset the transmitter and start
; things up again.

		public AdapterFailure_TxOverrun

AdapterFailure_TxOverrun:
		call  TxReset

		mov    ax, CurTxStart
		out    dx, ax

		; enable the transmitter
		mov     ah, CMDH_TXENABLE
		out     dx, ax


;		SelectWindow WNO_OPERATING

; shut off the transmitter and receiver
		public ia_shutdown

ia_shutdown:
IFNDEF	UNDI
		SelectWindow WNO_OPERATING

		; Tx Disable
		mov     ah, CMDH_TXDISABLE
		out     dx, ax

				; Disable the receiver
		mov     ah, CMDH_RXDISABLE
		out     dx, ax

; disable additional interrupts from the adapter

		mov    ax, CMD_SETRZMASK + MASK_ALL
		out    dx, ax
ENDIF
		jmp    int_next


IFDEF	DEBUG
Puthex	proc	near

		push	es
		push	ax		; save for lower nibble
		shr	al, 1
		shr	al, 1
		shr	al, 1
		shr	al, 1
		add	al, 90h
		daa
		adc	al, 40h
		daa
;		call	h_digit
		push	ax
		mov	ax, 0b800h
		mov	es, ax
		xor	di, di
		pop	ax
		stosb
		pop	ax		; now do lower nibble

h_digit:
		push	ax
		and	al, 00001111b
		add	al, 90h
		daa
		adc	al, 40h
		daa
;		call	putchr
		mov	di, 2
		stosb
		pop	ax
		pop	es
		ret
		
Puthex		endp

Putchr		proc	near

		push	bx
		mov	ah,0eh
		mov	bx, 0007h		; page 0, normal
		int	10h
		pop	bx
		ret

Putchr		endp
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\undi_equ.inc ===
;
;--- Miscellaneous Equates
;
NULL            equ     0
CR		equ	0Dh           ;- Carriage Return
LF		equ	0Ah           ;- Line Feed
FALSE		equ	0
TRUE		equ	1
;
;--- Ethernet Frame Sizes
;
ETHERNET_ADDRESS_LENGTH		equ	6
ETHERNET_HEADER_SIZE		equ	14
MINIMUM_ETHERNET_PACKET_SIZE	equ	60
;MAXIMUM_ETHERNET_PACKET_SIZE	equ	1514
MAXIMUM_ETHERNET_PACKET_SIZE	equ	1500 ;; just data, not media header

MAX_PACKET         Equ       1514      ; Maximum allowable packet size.
MIN_PACKET         Equ       60        ; Minimum allowable packet size.
; 
;--- Packet filter bit definitions
; 
FLTR_DIRECTED                Equ       01H
FLTR_MLTCST                  Equ       01H
FLTR_BRDCST                  Equ       02H
FLTR_PRMSCS                  Equ       04H
FLTR_SRC_RTG                 Equ       08H
;
;--- Processor Type Equates
;
EIGHT_BIT          equ       0001H
SIXTEEN_BIT        equ       0002H
PROC_TYPE_MASK     equ       0030H

PROC_8086          equ       0000H OR EIGHT_BIT
PROC_80286         equ       0010H OR SIXTEEN_BIT
PROC_80386         equ       0020H
PROC_80486         equ       0040H
;
;--- Result codes returned in AX by a PXE API service.
;
PXENV_EXIT_SUCCESS		equ	0
PXENV_EXIT_FAILURE		equ	1
PXENV_EXIT_CHAIN		equ	0FFFFh	; used internally
;
;--- Status codes returned in the status word of PXE API parameter structures.
;
PXENV_STATUS_SUCCESS		equ	0
PXENV_STATUS_FAILURE		equ	1	;general failure
PXENV_STATUS_BAD_FUNC		equ	2	;invalid function number
PXENV_STATUS_UNSUPPORTED	equ	3	;not yet supported
PXENV_STATUS_1A_HOOKED		equ	4	;Int 1AH cannot be unhooked

; Driver errors (60 to 0x6F)
; These errors are for UNDI compatible NIC drivers.
PXENV_STATUS_UNDI_MEDIATEST_FAILED 		equ	61h
PXENV_STATUS_UNDI_CANNOT_INIT_NIC_FOR_MCAST	equ	62h
;
;
EISA_ADAPTER             equ    1
PCI_ADAPTER              equ    2
PnP_ADAPTER              equ    3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\pci.inc ===
;
; Modifications:   $Header: /Client Boot/NICS/3Com/3C90xB/UNDI/PCI.INC 2     22/07/98 8:30p John Lobraico $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

ifndef _PCI_INC
_PCI_INC = 1

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Structures and records
;


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Equates
;

PCI_IRQ_LINE	equ	3Ch


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Macros
;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; PCI_READ_BYTE
;	Read one byte from PCI configuration space.
;
; passed:
;	BH := PCI bus number
;	BL := PCI device (bits 7-3) & function (bits 2-0) numbers
;	DI := Offset into PCI configuration space (00h to FFh)
;
; returns:
;	SUCCESS
;		CY := 0
;		AH := 0
;		CL := Byte read from PCI configuration space
;
;	FAILURE
;		CY := 1
;		AH := 81h (Unsupported function)
;		AH := 87h (Bad PCI register number)
;
PCI_READ_BYTE macro
	mov	ax, 0B108h
	int	1Ah
	endm

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; PCI_READ_WORD
;	Read one word from PCI configuration space.
;
; passed:
;	BH := PCI bus number
;	BL := PCI device (bits 7-3) & function (bits 2-0) numbers
;	DI := Offset into PCI configuration space (00h to FEh)
;
; returns:
;	SUCCESS
;		CY := 0
;		AH := 0
;		CX := Word read from PCI configuration space
;
;	FAILURE
;		CY := 1
;		AH := 81h (Unsupported function)
;		AH := 87h (Bad PCI register number)
;
PCI_READ_WORD macro
	mov	ax, 0B109h
	int	1Ah
	endm

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; PCI_READ_DWORD
;	Read one dword from PCI configuration space.
;
; passed:
;	BH := PCI bus number
;	BL := PCI device (bits 7-3) & function (bits 2-0) numbers
;	DI := Offset into PCI configuration space (00h to FCh)
;
; returns:
;	SUCCESS
;		CY := 0
;		AH := 0
;		ECX := Dword read from PCI configuration space
;
;	FAILURE
;		CY := 1
;		AH := 81h (Unsupported function)
;		AH := 87h (Bad PCI register number)
;
PCI_READ_DWORD macro
	mov	ax, 0B10Ah
	int	1Ah
	endm


endif ;_PCI_INC

; EOF - $Workfile: PCI.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\pxe_stru.inc ===
;
NUM_MCADDRS    	Equ	8		; max number of multicast addresses.
MAX_DATABLK    	Equ	8		; max number of data blocks supported 
					;	in a descriptor.
MAX_IMMED_LEN	Equ	64		; max immediate data buffer length
MAX_TX_DATABLK	Equ	MAX_DATABLK	; max number of data blocks supported 
					;	in a Tx descriptor.
MAX_TD_DATABLK	Equ	MAX_DATABLK	; max number of TransferData blocks
		
APIMaxFunc	EQU	0011h

ADDR_LEN	EQU	16
ETH_ADDR_LEN	EQU	6
MAXNUM_MCADDR	EQU	8

;
; protocol values in transmit buffer
;
P_UNKNOWN	EQU	0		;; no media header
P_IP	 	EQU	1		;; IP type
P_ARP		EQU	2		;; ARP type
P_RARP		EQU	3		;; RARP type

TYPE_IP	 	EQU	0800h		;; IP type
TYPE_ARP	EQU	0806h		;; ARP type
TYPE_RARP	EQU	8035h		;; RARP type
;
; xmitflag values in transmit buffer
;
PKT_DESTADDR	EQU 0	;; destination address given 
PKT_BROADCAST	EQU 1h	;; use broadcast address 
PKT_MULTICAST	EQU 2h	;; multicast addr given

;; Hardware type values
ETHER_TYPE 		EQU 1
EXP_ETHER_TYPE	EQU 2
IEEE_TYPE  	EQU 6
ARCNET_TYPE   	EQU 7


Eth_MCastBuf	Struc
MCastAddrCount	DW	?
MCastAddr	DB MAXNUM_MCADDR * ETH_ADDR_LEN dup (0)
Eth_MCastBuf	Ends

MC_MCastBuf		Struc
MC_MCastAddrCount	DW	?
MC_MCastAddr  		DB MAXNUM_MCADDR * ADDR_LEN dup (0)
MC_MCastBuf		Ends

NIC_StartUp	Struc
S_Status	DW	?
S_BusType	DB	?
S_AddrType	DB	?
S_DataSeg	DW	?
S_DataSegAddr	DD	?
S_DataSegSize	DW	?
S_CodeSegSize	DW	?
S_BusDevFunc	DW	?	;; PCI Dev_ID
S_PCI_ds_off	dw	?	;; Far pointer to PCI data structure
S_PCI_ds_seg	dw	?
S_PnP_csn	dw	?	; Card select number.-1 for non-PnP BBS device
S_PnP_eh_off	dw	?	; Far pointer to PnP expansion header
S_PnP_eh_seg	dw	?
NIC_StartUp	Ends

NIC_CleanUp	Struc
CL_Status	DW	?
NIC_CleanUp	Ends

NIC_Initialize	Struc
I_Status	DW	?
I_Prot_ini	DD	?
I_RcvInt	DD	?
I_GenInt	DD	?
NIC_Initialize  Ends

NIC_Reset	Struc
R_Status	DW	?
R_MCBuf		MC_MCastBuf <>
NIC_Reset	Ends

NIC_ShutDown	Struc
SD_Status	DW	?
NIC_ShutDown	Ends

NIC_Open	Struc
O_Status	DW	?
O_OpenFlg	DW	?
O_PktFilter	DW	?
O_MCBuf		MC_MCastBuf <>
NIC_Open	Ends

NIC_Close	Struc
C_Status	DW	?
NIC_Close	Ends

X_DataBlock	Struc
X_TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
X_TxRsvdByte	DB	?	; Reservered, must be zero.
X_TxDataLen	DW	?	; Data block length in bytes.
X_TxDataPtr	DD	?	; Far pointer to data block.
X_DataBlock Ends

NIC_TBD		Struc
X_Length	DW	?
X_BufOff	DW	?
X_BufSeg	DW	?
X_DataBlkCount	DW	?		; will always be zero for base code
X_DataBlk	DB	MAX_DATABLK * SIZE X_DataBlock dup (0)	
NIC_TBD		Ends

NIC_Transmit		Struc
T_Status		DW	?
T_Protocol		DB	?
T_XmitFlag		DB	?
T_DestAddrOffset 	DW	?	; 16-bit segment & offset of the
T_DestAddrSegment 	DW	?	; destination media address 
T_TBDOffset		DW	?	; 16-bit segment & offset 
T_TBDSegment		DW	?	; transmit buffer descriptor 
T_Reserved		DD	2 dup(0)	; for future use	
NIC_Transmit Ends

NIC_SetMCastAddr	Struc
SM_Status		DW	?
SM_MCBuf		MC_MCastBuf <>
NIC_SetMCastAddr	Ends

NIC_SetStationAddr	Struc
SS_Status		DW	?
SS_StationAddr		DB	ADDR_LEN dup (0)
NIC_SetStationAddr	Ends

NIC_SetPacketFilter	Struc
SP_Status		DW	?
;;SP_NewFilter		DW  ?
SP_NewFilter		DB  ?
;;SP_MCBuf		MC_MCastBuf <>
NIC_SetPacketFilter	Ends

NIC_GetInfo	Struc
GI_Status		DW	?
GI_BaseIo		DW	?
GI_IntNumber		DW	?
GI_MTU			DW	?
GI_HwType		DW	?
GI_HwAddrLen		DW	?
GI_CurrentNodeAddress	DB ADDR_LEN dup (0)
GI_PermNodeAddress	DB ADDR_LEN dup (0)
GI_ROMAddress		DW 	?
GI_RxBufCt		DW	?
GI_TxBufCt		DW	?
NIC_GetInfo	Ends

NIC_GetNICType_pci 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
Vendor_ID	DW	?	; /* OUT:  */
Dev_ID		DW	?	;  /* OUT:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */ 
Rev		DB	?	;  /* OUT: Revision number */ 
BusDevFunc	DW	?	; /* OUT: Bus, Device & Function numbers */
SubSystemId     dd      ?       ; /*OUT: SubsytemId & SubsystemVendorId
NIC_GetNICType_pci 	Ends

NIC_GetNICType_pnp 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
EISA_Dev_ID	DD	?	; /* Out:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */
CardSelNum	DW	?	; /* OUT: Card Selector Number */
Res		DB	0	;
NIC_GetNICType_pnp 	Ends

NIC_GetStatistics	Struc
GS_Status		DW	?
GS_XmtGoodFrames	dd    ?
GS_RcvGoodFrames	dd    ?
GS_RcvCRCErrors		dd    ?
GS_RcvResourceErrors	dd    ?
NIC_GetStatistics	Ends

NIC_ClearStatistics	Struc
CS_Status		DW	?
NIC_ClearStatistics	Ends

NIC_InitDiags	Struc
ID_Status	DW	?
NIC_InitDiags   Ends

NIC_ForceInterrupt	Struc
FI_Status		DW	?
NIC_ForceInterrupt	Ends

NIC_GetMCastAddr	Struc
GM_Status		DW	?
GM_InetAddr		DD	?
GM_HwAddr		DB	ADDR_LEN dup (0)
NIC_GetMCastAddr	Ends

;NIC_API_Entry	Struc
;Signature 	DB	'PXENV+'	;; not null terminated
;Version		DW	0100h		;; 1.0
;StrucLength	DB	0		;; length of this structure
;CheckSum	DB	0		;; fill in later
;rm_entry_off	DW	0		;; real mode driver entry offset
;rm_entry_seg	DW	0		;; real mode driver entry segment
;pm_entry_off	DW	0		;; protected mode driver entry offset
;pm_entry_seg	DW	0		;; protected mode driver entry segment
;NIC_API_Entry	Ends

s_PXENV_ENTRY	Struc
signature	db	6 dup(?)	; 'PXENV+'
ver             dw      ?               ; MSB=major, LSB=minor
bytes		db	?		; sizeof s_pxenv_entry
checksum	db	?		; 8-bit checksum of structure,
					; including this byte shoube be zero.
rm_entry_off	dw	?		; 16-bit real-mode segment & offset.
rm_entry_seg	dw	?
pm_entry_off	dw	?		; 16-bit protected mode 32-bit physical
pm_entry_base	dd	?		; address and 16-bit offset.
stack_sel	dw	?		; PROM stack segment.  Will be set
stack_size	dw	?		; to 0 when removed from memory.
base_cs_sel	dw	?		; Base code segment.  Will be set
base_cs_size	dw	?		; to 0 when removed from memory.
base_ds_sel	dw	?		; Base data segment.  Will be set
base_ds_size	dw	?		; to 0 when removed from memory.
mlid_ds_sel	dw	?		; MLID data segment.
mlid_ds_size	dw	?
mlid_cs_sel	dw	?		; MLID code segment.
mlid_cs_size	dw	?
s_PXENV_ENTRY	Ends

;; Ethernet II protocol header
EtherHeader	Struc
E_DestAddr	DB 6 dup (0)	;; destination ethernet addr
E_SrcAddr	DB 6 dup (0)	;; destination ethernet addr
E_Type		DW  ?	;; protocol type
EtherHeader	Ends

ETHER_HEADER_LEN	Equ	SIZE EtherHeader

; 
; * Data structures for TransmitChain (Tx), TransferData (TD)
; 
TxDataBlock	Struc
TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TxRsvdByte	DB	?	; Reservered, must be zero.
TxDataLen	DW	?	; Data block length in bytes.
TxDataPtr	DD	?	; Far pointer to data block.
TxDataBlock	Ends

; 
; * TransmitChain descriptor structure definition
; 
TxBufDesc	Struc
TxImmedLen	DW	?	; Byte count of immediate data, max=64
TxImmedPtr	DD	?	; Virtual address of Immediate data
TxDataCount	DW	?	; Number of Data Blocks (max = 8)
TxDataBlk	DB	size TxDataBlock * MAX_TX_DATABLK dup(0)
TxBufDesc	Ends

TxBufDescrSize	Equ	Size TxImmedLen + Size TxImmedPtr + Size TxDataCount

; 
; * TransferData data block description
; 
TDDataBlock	Struc
TDPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TDRsvdByte	DB	?	; Reservered, must be zero.
TDDataLen	DW	?	; Data block length in bytes.
TDDataPtr	DD	?	; Far pointer to data block.
TDDataBlock	Ends

; 
; * TransferData descriptor structure
; 
TDBufDesc	Struc
TDDataCount	DW	?	; No of Data Blocks (max 8 for V1.01).
TDDataBlk	DB	size TDDataBlock*MAX_TD_DATABLK dup(0)
TDBufDesc	Ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\version.inc ===
;
; Modifications:   $Header:   H:/Archives/Client/Include/version.inv   1.22.1.1   31 Jan 1998 23:08:08   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

ifndef _VERSION_INC
_VERSION_INC=1


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Equates
;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Version number of current LSA build.
;
LSA_MAJOR	equ	0
LSA_MINOR	equ	99
LSA_EDIT	equ	'd'

LSA_EISA_ID	equ   ((('L'-'@') shl 26)+(('S'-'@') shl 21)+(('A'-'@') shl 16))

LSA_PMM_HANDLE	equ	((LSA_EISA_ID)+2000h+((LSA_MAJOR) shl 8)+(LSA_MINOR))


; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Product & manufacturer ID strings.
;
MFG_STR		textequ	<'Intel'>
PROD_STR	textequ	<'LANDesk (R) Service Agent II'>
COPYRIGHT_STR	textequ	<'Copyright (C) 1997  Intel Corporation.  All rights reserved.'>


endif ;_VERSION_INC

; EOF - $Workfile:   version.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\buildcfg.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/BUILDCFG.INV   1.2   19 Sep 1997 21:39:16   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: Compilation Switches used to build NDIS DOS, OS/2 driver
;

;
;   Description      :    Compilation Switches used to build the NDIS DOS
;                         and OS2 drivers.   Controls version numbers,
;                         default values for parameters, debug inclusion.
;
;                         This file will be included in all of the NDIS
;                         driver source files. Any changes to this file must
;                         (through makefile) force a complete remake of the
;                         entire driver.

.386

TRUE        Equ  1
FALSE       Equ  0


Ifndef DOS
DOSNDIS         Equ     FALSE
OS2NDIS         Equ     TRUE
Else
DOSNDIS         Equ     TRUE
OS2NDIS         Equ     FALSE
Endif

OS2             Equ     OS2NDIS
DOS             Equ     DOSNDIS

;- Switch to enable debug breakpoints (int 3)
DEBUG_BP             equ         FALSE

;- Switch to enable Early Receive Code
EARLY_RCV            equ         FALSE

;- Switch to enable Code Profiling
CODE_PROFILE         equ         FALSE

StratStack           equ         TRUE

;- when transmitter hangs, when should we reset?
TRANSMIT_TIMEOUT Equ     2

;- Interval (in seconds) between successive reads of SCB statistics
UPDATE_STATS_INTERVAL    equ     4

MAX_PACKET         Equ       1514      ; Maximum allowable packet size.
MIN_PACKET         Equ       60        ; Minimum allowable packet size.

;- Number Of Multicast Addresses Supported By This Driver
MAX_MULTICAST_ADDRESSES  equ     20

;- Optional data area in TCB for Flexible mode
TXCB_BUFFER_SIZE         equ     60

;- Transmit buffer size is max Eth Size (not incl. CRC) plus slop to 1536
TCB_SLOP                 equ     22
TCB_BUFFER_SIZE          equ     MAX_PACKET+TCB_SLOP

;- Receive buffer size is max Eth size plus CRC plus slop to 1536
RCB_SLOP                 equ     22
RCB_BUFFER_SIZE          equ     MAX_PACKET+RCB_SLOP

;- minimum number of Tx buffers and/or Rx buffers allowed to run driver.
MIN_TXRX_BUF_CTS         equ     2

;- Interframe Spacing 96 Tx Clocks
IFS_SPACING              equ     60h

;- Slot Time 512 Tx Clocks
SLOT_TIME                equ     200h

;- Default CUSTOM parameter values
DEFAULT_TXFIFO           equ     8
DEFAULT_RXFIFO           equ     8
DEFAULT_LINE_SPEED       equ     100
DEFAULT_ADAPTIVE_IFS     equ     0
DEFAULT_TXTHRESHOLD      equ     32
DEFAULT_FORCEFDX         equ     0
DEFAULT_IOMAPMODE        equ     0
DEFAULT_TXDMACOUNT       equ     0
DEFAULT_RXDMACOUNT       equ     0
DEFAULT_PHYADDRESS       equ     0FFh
DEFAULT_FRAME_GAP equ 6
FRAME_GAP_MIN equ  6
FRAME_GAP_MAX equ  15

IF DOS
DEFAULT_TXBUF_COUNT      equ     4
DEFAULT_RXBUF_COUNT      equ     8               ; v40
ENDIF

DEFAULT_CONGENB          equ     0               ; v0.49

USE_DEFAULT_VALUE        equ     (-1)

DEFAULT_MCWA_EventCount  equ     6               ; v44

;- used by timer tick interrupt routine to count out one second
TICKS_PER_SECOND         equ     18



;- this indicates the offset to add to get to the '$' in the driver name
;  '0123456789'
;  'E100B$'
DOLLAR_OFFSET            equ     5               ; v0.38

; TRANSMIT_CHECK equ 1


; EOF - $Workfile:   buildcfg.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\bwstruct.inc ===
;====================================================================
; BWSTRUCT.INC
;
; Include for for BootWare, defines common structures.
;
; 970116 PC - first version
;====================================================================

;--------------------------------------------------------------------
; Common equates
;---------------------------------------------------------------------
FEATURE_LOCAL	equ	1
FEATURE_VIRUS	equ	2
FEATURE_MENU	equ	4
FEATURE_KEYWAIT	equ	8
FEATURE_FLOPPY	equ	64
FEATURE_HDRIVE	equ	128

;--------------------------------------------------------------------
; Event Descriptor (ED) Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc	ED
	Ptr		dw	?	; pointer to next ED
	Unused		dw	?	; spare word
	DestAddr	dw	?, ?, ?	; destination Address
	ErrCode		dw	?	; error code
	ErrMsg		dw	?	; pointer to error msg
	Length		dw	?	; total packet length
	FragCount	dw	?	; number of fragments
	FragOff		dw	?	; 1st fragment offset
	FragSeg		dw	?	; 1st fragment segment
	FragLen 	dw	?	; length of fragment
ends
ELSE
ED_Struct      STRUC
	ED_Ptr		dw	?	; pointer to next ED
	ED_Unused	dw	?	; spare word
	ED_DestAddr	dw	?, ?, ?	; destination address
	ED_ErrCode	dw	?       ; error code
	ED_ErrMsg	dw	?       ; Pointer to error msg
	ED_Length	dw	?	; total packet length
	ED_FragCount	dw	?	; Number of descriptors/fragments
	ED_FragOff	dw	?	; Descriptor Pointer
	ED_FragSeg	dw	?	; Descriptor Pointer
	ED_FragLen 	dw	?	; Length of packet descriptor
ED_Struct      ENDS
ENDIF

;--------------------------------------------------------------------
; Descricptor Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc Frag
	Off		dw	?	; offset of fragment
	Seg		dw	?	; segment of fragment
	Len		dw	?	; length of fragment
ends
ELSE
Frag Struc
	FragOff		dw	?	; offset of fragment
	FragSeg		dw	?	; segment of fragment
	FragLen		dw	?	; length of fragment
Frag ends
Descript_Struct STRUC
	DPointer	dd	?	; Descriptor Pointer
	DLen		dw	?	; Length of packet descriptor
Descript_Struct ends
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\pcinic.inc ===
;
; Modifications:   $Header: /Client Boot/NICS/3Com/3C90xB/UNDI/PCINIC.INC 2     22/07/98 8:30p John Lobraico $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: PCI Configuration Space Definitions
;

IFDEF            PCI_INC
ELSE
PCI_INC          equ    1
include pci.inc

;--------------------------------------------------------------------------
; Configuration Space Header
;--------------------------------------------------------------------------
PCI_CONFIG_STRUC       struc
    PciVendorId        dw    ?                ;- PCI Vendor ID
    PciDeviceId        dw    ?                ;- PCI Device ID
    PciCommand         dw    ?
    PciStatus          dw    ?
    PciRevisionId      db    ?
    PciClassCode       db    3  dup (?)
    PciCacheLineSize   db    ?
    PciLatencyTimer    db    ?
    PciHeaderType      db    ?
    PciBIST            db    ?
    PciBaseReg0        dd    ?
    PciBaseReg1        dd    ?
    PciBaseReg2        dd    ?
    PciBaseReg3        dd    ?
    PciBaseReg4        dd    ?
    PciBaseReg5        dd    ?
    PciReserved0       dd    0
    PciReserved1       dd    0
    PciExpROMAddress   dd    ?
    PciReserved2       dd    0
    PciReserved3       dd    0
    PciInterruptLine   db    ?
    PciInterruptPin    db    ?
    PciMinGnt          db    ?
    PciMaxLat          db    ?
PCI_CONFIG_STRUC       ends

;--------------------------------------------------------------------------
; Config Space Register Offsets
; Refer To The PCI Specification For Detailed Explanations
;--------------------------------------------------------------------------
VENDOR_ID_REGISTER       equ     00h          ;- PCI Vendor ID Register
DEVICE_ID_REGISTER       equ     02h          ;- PCI Device ID Register
COMMAND_REGISTER         equ     04h          ;- PCI Command Register
STATUS_REGISTER          equ     06h          ;- PCI Status Register
REV_ID_REGISTER          equ     08h          ;- PCI Revision ID Register
CLASS_CODE_REGISTER      equ     09h          ;- PCI Class Code Register
CACHE_LINE_REGISTER      equ     0Ch          ;- PCI Cache Line Register
LATENCY_TIMER            equ     0Dh          ;- PCI Latency Timer Register
HEADER_TYPE              equ     0Eh          ;- PCI Header Type Register
BIST_REGISTER            equ     0Fh          ;- PCI Built-In SelfTest Register
BAR_0_REGISTER           equ     10h          ;- PCI Base Address Register 0
BAR_1_REGISTER           equ     14h          ;- PCI Base Address Register 1
BAR_2_REGISTER           equ     18h          ;- PCI Base Address Register 2
BAR_3_REGISTER           equ     1Ch          ;- PCI Base Address Register 3
BAR_4_REGISTER           equ     20h          ;- PCI Base Address Register 4
BAR_5_REGISTER           equ     24h          ;- PCI Base Address Register 5
SUB_VENDOR_ID_REGISTER           equ     2Ch          ;- PCI Base Address Register 5
SUB_DEVICE_ID_REGISTER           equ     2Eh          ;- PCI Base Address Register 5
EXPANSION_ROM            equ     30h          ;- PCI Expansion ROM Base Register
INTERRUPT_LINE           equ     3Ch          ;- PCI Interrupt Line Register
INTERRUPT_PIN            equ     3Dh          ;- PCI Interrupt Pin Register
MIN_GNT_REGISTER         equ     3Eh          ;- PCI Min-Gnt Register
MAX_LAT_REGISTER         equ     3Fh          ;- PCI Max_Lat Register

;--------------------------------------------------------------------------
; Configuration space DWORD register offsets
;--------------------------------------------------------------------------
CONFIG_SPACE_REG0        equ     0
CONFIG_SPACE_REG1        equ     1
CONFIG_SPACE_REG2        equ     2
CONFIG_SPACE_REG3        equ     3
CONFIG_SPACE_REG4        equ     4
CONFIG_SPACE_REG5        equ     5
CONFIG_SPACE_REG6        equ     6
CONFIG_SPACE_REG7        equ     7
CONFIG_SPACE_REG8        equ     8
CONFIG_SPACE_REG9        equ     9
CONFIG_SPACE_REGA        equ     0Ah
CONFIG_SPACE_REGB        equ     0Bh
CONFIG_SPACE_REGC        equ     0Ch
CONFIG_SPACE_REGD        equ     0Dh
CONFIG_SPACE_REGE        equ     0Eh
CONFIG_SPACE_REGF        equ     0Fh

;--------------------------------------------------------------------------
; Byte/Word Offsets In A Config DWORD
; These offsets can be used to move a Byte or Word into the lower half of
; a register.
;--------------------------------------------------------------------------
CONFIG_BYTE_0            equ     0
CONFIG_BYTE_1            equ     8
CONFIG_BYTE_2            equ     16
CONFIG_BYTE_8            equ     24
CONFIG_WORD_0            equ     0
CONFIG_WORD_1            equ     16

;--------------------------------------------------------------------------
; Configuration Mechanism Registers
;--------------------------------------------------------------------------
CF1_CONFIG_ADDR_REGISTER   equ   0CF8h        ;- Config Space Address Register
CF1_CONFIG_DATA_REGISTER   equ   0CFCh        ;- Config Space Data Register
CF2_SPACE_ENABLE_REGISTER  equ   0CF8h        ;- CSE Register
CF2_FORWARD_REGISTER       equ   0CFAh        ;- Forward Register
CF2_BASE_ADDRESS           equ   0C000h       ;- Configuration #2 Base

;--------------------------------------------------------------------------
; PCI Class Code Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
PCI_BASE_CLASS           equ     02h          ;- Base Class - Network Controller
PCI_SUB_CLASS            equ     00h          ;- Sub Class - Ethernet Controller
PCI_PROG_INTERFACE       equ     00h          ;- Prog I/F - Ethernet COntroller

;--------------------------------------------------------------------------
; PCI Command Register Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
CMD_IO_SPACE             equ     BIT_0
CMD_MEMORY_SPACE         equ     BIT_1
CMD_BUS_MASTER           equ     BIT_2
CMD_SPECIAL_CYCLES       equ     BIT_3
CMD_MEM_WRT_INVALIDATE   equ     BIT_4
CMD_VGA_PALLETTE_SNOOP   equ     BIT_5
CMD_PARITY_RESPONSE      equ     BIT_6
CMD_WAIT_CYCLE_CONTROL   equ     BIT_7
CMD_SERR_ENABLE          equ     BIT_8
CMD_BACK_TO_BACK         equ     BIT_9

;--------------------------------------------------------------------------
; PCI Status Register Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
STAT_BACK_TO_BACK        equ     BIT_7
STAT_DATA_PARITY         equ     BIT_8
STAT_DEVSEL_TIMING       equ     BIT_9 OR BIT_10
STAT_SIGNAL_TARGET_ABORT equ     BIT_11
STAT_RCV_TARGET_ABORT    equ     BIT_12
STAT_RCV_MASTER_ABORT    equ     BIT_13
STAT_SIGNAL_MASTER_ABORT equ     BIT_14
STAT_DETECT_PARITY_ERROR equ     BIT_15

;--------------------------------------------------------------------------
; PCI Base Address Register For Memory (BARM) Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
BARM_LOCATE_BELOW_1_MEG  equ     BIT_1
BARM_LOCATE_IN_64_SPACE  equ     BIT_2
BARM_PREFETCHABLE        equ     BIT_3

;--------------------------------------------------------------------------
; PCI Base Address Register For I/O (BARIO) Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
BARIO_SPACE_INDICATOR    equ     BIT_0

;--------------------------------------------------------------------------
; PCI BIOS Definitions
; Refer To The PCI BIOS Specification
;--------------------------------------------------------------------------
;- Function Code List

;IFE  NWSERVER
;;- Server can use the defines in ODI.INC
;PCI_FUNCTION_ID          equ     0B1h         ;- AH Register
;PCI_BIOS_PRESENT         equ     01h          ;- AL Register
;FIND_PCI_DEVICE          equ     02h          ;- AL Register
;FIND_PCI_CLASS_CODE      equ     03h          ;- AL Register
;GENERATE_SPECIAL_CYCLE   equ     06h          ;- AL Register
;READ_CONFIG_BYTE         equ     08h          ;- AL Register
;READ_CONFIG_WORD         equ     09h          ;- AL Register
;READ_CONFIG_DWORD        equ     0Ah          ;- AL Register
;WRITE_CONFIG_BYTE        equ     0Bh          ;- AL Register
;WRITE_CONFIG_WORD        equ     0Ch          ;- AL Register
;WRITE_CONFIG_DWORD       equ     0Dh          ;- AL Register
;ENDIF

; Function Return Code List
SUCCESSFUL               equ     00h
FUNC_NOT_SUPPORTED       equ     81h
BAD_VENDOR_ID            equ     83h
DEVICE_NOT_FOUND         equ     86h
BAD_REGISTER_NUMBER      equ     87h

;- PCI BIOS Calls
PCI_BIOS_INTERRUPT       equ     01Ah         ;- PCI BIOS Int 1Ah Function Call
PCI_PRESENT_CODE         equ     20494350h    ;- Hex Equivalent Of 'PCI '
                                              ;- ASCII Codes for ' ICP'
PCI_PRESENT_CODE_WORD    equ     4350h        ;- Hex Equivalent Of 'CP'
PCI_SERVICE_IDENTIFIER   equ     49435024h    ;- ASCII Codes for 'ICP$'

;- PCI Device and Vendor IDs
;; JL - Removed nic specifics!
;;SPEEDO_DEVICE_ID         equ     1227h
;;SPLASH1_DEVICE_ID        equ     1226h
;;D100_DEVICE_ID           equ     1229h
;;D100_VENDOR_ID           equ     8086h

;- Maximum bus slots supported under Configuration mechanisms 1 and 2
CONFIG1_MAX_PCI_SLOTS    equ     32
CONFIG2_MAX_PCI_SLOTS    equ     16

;- Maximum buses supported
MAX_PCI_BUSES            equ     255

ENDIF


; EOF - $Workfile: PCINIC.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\spdosegs.inc ===
; Modifications:   $Header: /Client Boot/NICS/3Com/3C90xB/UNDI/SPDOSEGS.INC 2     22/07/98 8:30p John Lobraico $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;
;   Description: segment declaration and ordering for NDIS driver
;-----------------------------------------------------------------------
; Functional Description
;
;   This file defines the segments used by a MAC driver and the order
;   in which they are loaded. The groups DGROUP (for data) and CGROUP
;   (for code) are also defined, as are macros to open and close
;   segments (which also set up the default segment assumptions).
;-----------------------------------------------------------------------
; DOS segment definitions and ordering.
;==========================================================================
Ifdef DRV
DevHeaderSeg   segment para public USE16 'CODE'
DevHeaderSeg   ends
Endif	
;--------------------------------------------------------------------------
; Resident Code segment - code that is used after init time
; (unfortunately, this includes code to bind another driver, and
; initializations that take place at bind time) should be placed in this
; segment.
;--------------------------------------------------------------------------
_TEXT       segment para public USE16 'CODE'
_TEXT       ends

Ifdef DRV
ICODE       segment para public USE16 'INIT'
ICODE       ends
ENDIF	
;--------------------------------------------------------------------------
; Resident Data segment - things put here will remain in memory after
; init time. At the present time, this is in low memory, so data that is
; not used after init time should NOT be put in this segment.
;--------------------------------------------------------------------------
_DATA       segment para public USE16 'DATA'
_DATA       ends

Ifdef DRV
_BSS       segment para public USE16 'DATA'
_BSS       ends
IDATA       segment para public USE16 'DATA'
IDATA       ends
Else
_BSS       segment para public USE16 'BSS'
_BSS       ends
ENDIF
;--------------------------------------------------------------------------
; Make sure the segment order defined in this file is respected.
;--------------------------------------------------------------------------
.SEQ               
;--------------------------------------------------------------------------
; DOS Group is all one 64K segment, CS=SS=DS, use equate for DGROUP.
;--------------------------------------------------------------------------
Ifdef DRV
    CGROUP      group   DevHeaderSeg, _TEXT, ICODE
    DGROUP      group   _DATA, _BSS, IDATA
ELSE
    CGROUP      group   _TEXT
    DGROUP      group   _DATA, _BSS
ENDIF	
;--------------------------------------------------------------------------
; Group is 64K data, 64K code, CS!=SS=DS, actual group for Code.
;--------------------------------------------------------------------------
; Assume statement here takes care of for any source, same for OS2 and DOS.
;--------------------------------------------------------------------------
    Assume   CS:CGROUP, DS:DGROUP, ES:NOTHING, SS:NOTHING

START_CODE	macro
_TEXT		segment Public 'Code'
		assume ds:DGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_CODE	macro
_TEXT		ends
		endm

START_DATA	macro
_Data		segment Public 'Data'
		assume ds:DGroup,cs:CGroup,es:nothing,ss:nothing
		endm

END_DATA	macro
_Data		ends
		endm

; 2 macros by John to let you easily insert data fragments into code
;
; This macro assumes that Code is open, closes it, and opens data.
OPEN_DATA       macro
    END_CODE
    START_DATA
                endm

; This macro closes the open data and re-opens the Code segment.
CLOSE_DATA      macro
    END_DATA
    START_CODE
                endm


; EOF - $Workfile: SPDOSEGS.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\genmacro.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/GENMACRO.INV   1.2   19 Sep 1997 21:39:10   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: Generic macros used by all Speedo3 ASM driver
;

IFDEF            GENMACRO_INC
ELSE
GENMACRO_INC     equ       1

;--------------------------------------------------------------------------
; Small/quick way to set a register to NULL, all F's (avoid 32-bit constants).
;--------------------------------------------------------------------------
@NULLPTR macro reg
    xor     reg, reg
    dec     reg
    ENDM

;--------------------------------------------------------------------------
; Port I/O macros
;--------------------------------------------------------------------------
;- 32-bit Output
@OUTPD     MACRO    portid, low, high
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    push   high
    push   low
    pop    eax
    out    dx, eax
.SALL
    ENDM

;- 16-bit Output
@OUTPW     MACRO    portid, value
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
IFNB       <value>
    mov    ax, value
ENDIF
    out    dx, ax
.SALL
    ENDM

;- 8-bit Output
@OUTPB     MACRO    portid, value
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
IFNB       <value>
    mov    al, value
ENDIF
    out    dx, al
.SALL
    ENDM

;- 32-bit Input
@INPD      MACRO    portid
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    in     eax, dx
.SALL
    ENDM

;- 16-bit Input
@INPW      MACRO    portid
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    in     ax, dx
.SALL
    ENDM

;- 8-bit Input
@INPB      MACRO    portid
.XALL
IFNB       <portid>
    mov    dx, portid
ENDIF
    in     al, dx
.SALL
    ENDM

;--------------------------------------------------------------------------
; Macro @POPF (DESTROYS AX!!!)                   v1.6
;--------------------------------------------------------------------------
@POPF MACRO                                      
    pop     ax      
    test    ax, 200H
    jz      @F      
    sti                
@@:
    ENDM

;--------------------------------------------------------------------------
; FASTCOPY
; Macro to perform fast DWORD memory copy
; Handles data transfers that are not multiples of 4
;--------------------------------------------------------------------------
@FASTCOPY  MACRO
.XALL
    push   cx
    shr    cx, 2
    rep    movsd
    pop    cx
    and    cx, 3
    rep    movsb
.SALL
    ENDM

;--------------------------------------------------------------------------
; REALLY_FASTCOPY
; Macro to perform fast DWORD memory copy, optimized by processor type.
; Handles data transfers that are not multiples of 4, or not dword-aligned.
;
; Each time REALLY_FASTCOPY is invoked, make sure that:
;  - pass macro value returned by "GetCpuType" (=PENTIUM_CPU does special move)
;  - CX has length
;  - ES:EDI points to destination (must clear upper 16 bits under DOS, OS/2)
;  - DS:ESI points to source      (must clear upper 16 bits under DOS, OS/2)
;--------------------------------------------------------------------------
@REALLY_FASTCOPY  MACRO CpuTypeValue
    local   CopyDword, RepCopy, CopyRemainder, CopyByte, Exit
    push    ax                                             ; v1.04
    push    dx                                             ; v1.04

    mov     dx, cx
    cmp     dx, 4
    jb      CopyRemainder

;--------------------------------------------------
;  Align destination to dword boundary
;--------------------------------------------------
    movsd
    sub     dx, 4

    mov     ax, di
    and     ax, 00003h
    sub     di, ax
    sub     si, ax
    add     dx, ax

    cmp     CpuTypeValue, PENTIUM_CPU                      ; v1.04
    jb      RepCopy

;-------------------------------------------------
; Do Pentium Optimized Block Copy
;-------------------------------------------------
    mov     ax, dx
    shr     ax, 2
    jz      CopyRemainder

CopyDword:
    movsd
    dec     ax
    jnz     CopyDword
    jmp     CopyRemainder

;-------------------------------------------------
; Do i386 and i486 Optimized Block Copy
;-------------------------------------------------
RepCopy:
    mov     cx, dx
    shr     cx, 2
    rep     movsd

;------------------------------------------------
; Copy any remaining bytes
;------------------------------------------------
CopyRemainder:
    mov     ax, dx
    and     ax, 00003h
    jz      Exit

CopyByte:
    movsb
    dec     ax
    jnz     CopyByte

Exit:
    pop     dx                                             ; v1.04
    pop     ax                                             ; v1.04
    ENDM

;--------------------------------------------------------------------------
; SLOW
; Macro to delay execution
; Processor speed independent. Executes an I/O to the keyboard port.  We
; use port 61h and not port 60h, because polling 60h can cause the
; "crazy mouse" problem under windows.
;--------------------------------------------------------------------------
@SLOW      MACRO
.XALL
    push   ax
    in     al,61h
    pop    ax
.SALL
    ENDM

;--------------------------------------------------------------------------
; READ_TICK_COUNTER
; This macro reads the 16-bit Timer Tick Count register 
; (8254 System Board Timer 0).
; The count register decrements by 2 (even numbers) every 838ns.
;
; Entry:    Interrupts disabled
;
; Exit:     AX with the current count
;           Interrupts disabled
;--------------------------------------------------------------------------
@READ_TICK_COUNTER     MACRO
;- Setup 8254 To Latch T0's Current Count
    xor     al, al
    out     43h, al
;- Read The Latched Counter Value, LSB First and MSB Next
    in      al, 40h
    mov     ah, al
    in      al, 40h
;- Swap The Counter Bytes To Correct Format
    xchg    al, ah
    ENDM


;--------------------------------------------------------------------------
; DELAY 
; This macro inserts a delay of specified milliseconds. 
;
; Entry:    Interrupts disabled
;
; Exit:     AX , CX destroyed
;           Interrupts disabled
;--------------------------------------------------------------------------
@DELAY MACRO MSEC
    local   Delay_Loop

    @READ_TICK_COUNTER
    mov     cx, ax
Delay_Loop:
    @READ_TICK_COUNTER
    neg     ax
    add     ax, cx
    cmp     ax, MSEC
    jb      Delay_Loop
    ENDM

;--------------------------------------------------------------------------
; INC32  
; This macro increments a 32 bit counter. 
;
; Entry:    Interrupts disabled
;
; Exit:     AX , CX destroyed
;           Interrupts disabled
;--------------------------------------------------------------------------
@INC32      MACRO     num32
    add     word ptr num32[0], 1
    adc     word ptr num32[2], 0
    ENDM

;--------------------------------------------------------------------------
; @FATAL
;
; Description : Macro to Halt execution (TRAP) in case of Fatal error
;
; Entry       : none
;
; Exit        : none
;--------------------------------------------------------------------------
@FATAL     MACRO 
    int 3
    ENDM

;--------------------------------------------------------------------------
; @INT3BP
;
; Description : inserts an INT 3 in way that is easy to find with an editor.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@INT3BP macro
    Int    3
endm


;--------------------------------------------------------------------------
; @BP_IFDEBUG
; Description : inserts an INT 3 instruction if debug switch has been set.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@BP_IFDEBUG macro
IF  DEBUG_BP
    @INT3BP
ENDIF    
endm

ENDIF


; EOF - $Workfile:   genmacro.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\eep15.inc ===
;************************************************************************;
;*									*;
;*			EEP15.INC					*;
;*									*;
;*  EEPROM configuration routines for the ATI AT-1500 Adapters.		*;
;*									*;
;*  Copyright (c) 1992, 1993, Allied Telesis, Inc.  All Rights Reserved.*;
;*									*;
;************************************************************************;

; Bit definitions for the PCNetISA "Vendor Specific Word", which on the
; AT-1500 controls the on-board serial EEPROM (National Semiconductor NMC95C12).
DATA_IN		equ	001h	; EEPROM serial data in (DI) - write/only
CLOCK		equ	002h	; EEPROM serial clock (SK) - write/only
DATA_OUT	equ	004h	; EEPROM serial data out - read/only
CHIP_SEL	equ	008h	; EEPROM Chip Select - write/only
JUMPER_STATE	equ	008h	; Alternate Address Jumper state - read/only

; EEPROM command codes.
READ		equ	80h	; Read EEPROM memory at specified address
WEN		equ	30h	; Write Enable
WRITE		equ	40h	; Write EEPROM memory at specified address
WRALL		equ	10h	; Write to all EEPROM locations
WDS		equ	00h	; Write Disable

SB		equ	01h	; "Start Bit" (command follows)
ADDR_MASK	equ	3Fh	; EEPROM memory address mask

; EEPROM locations used for AT-1500 configuration data (all are word addresses):
BOARD_TYPE_LOC		equ	0	; ASCII product name:  12 bytes
BOARD_REV_LOC		equ	6	; board rev. level:  low-order byte
BOARD_SUBTYPE_LOC	equ	6	; board subtype code:  high-order byte
FLAG_WORD_LOC		equ	32	; Flag bits - see below
Off_33_1500		equ	33	; Bit 13,14,15 reserved for Lanworks
SCR_SAVE_ADDR		equ	61	; SCR (below) power-up value save loc.
SCR_ADDR		equ	62	; "Switch Configuration Register"
SRR_ADDR		equ	63	; "Switch Readback Register"

; Configuration values for the SCR and the SCR_SAVE (word locations 61 & 62):
IRQ_MASK	equ	0003h		; bits  0-3  (switch 1): IRQ: see below
DMA_MASK	equ	0030h		; bits  4-7  (switch 2): DMA: see below
IO_BASE_MASK	equ	0300h		; bits  8-11 (switch 3): IO: see below
BOOT_EN_MASK	equ	1000h		; bits 12-15 (switch 4): BOOT: see below
MAU_SEL_MASK	equ	2000h		; bits 12-15 (switch 4): PORT: see below

; SCR Bits 0-3:  IRQ configuration:
IRQ_CHOICE_A	equ	0000h
IRQ_CHOICE_B	equ	0001h
IRQ_CHOICE_C	equ	0002h
IRQ_CHOICE_D	equ	0003h
IRQ_3		equ	IRQ_CHOICE_A
IRQ_4		equ	IRQ_CHOICE_B
IRQ_5		equ	IRQ_CHOICE_C
IRQ_9		equ	IRQ_CHOICE_D
IRQ_10		equ	IRQ_CHOICE_A		; AT-1500xx-20 only
IRQ_11		equ	IRQ_CHOICE_B		; AT-1500xx-00/01/20 only
IRQ_12		equ	IRQ_CHOICE_C		; AT-1500xx-30 only
IRQ_14		equ	IRQ_CHOICE_C		; AT-1500xx-20 only
IRQ_15		equ	IRQ_CHOICE_D		; AT-1500xx-00/01/20 only

; SCR Bits 4-7:  DMA configuration:
DMA_3		equ	0000h
DMA_5		equ	0010h
DMA_6		equ	0020h
DMA_7		equ	0030h

; SCR Bits 8-11:  IO BASE configuration:
BASE_IO_300	equ	0000h
BASE_IO_320	equ	0100h
BASE_IO_340	equ	0200h
BASE_IO_360	equ	0300h

; SCR Bits 12-15:  BOOT PROM and PORT SELECTION configuration:
BOOT_ENA	equ	1000h		; bit 12 = 1:  Enable boot PROM
BOOT_DIS	equ	0000h		; bit 12 = 0:  Disable boot PROM
UTP_PORT	equ	2000h		; bit 13 = 1:  Select UTP Port
OTHER_PORT	equ	0000h		; bit 13 = 0:  Select "Other" Port

; Flag Word (location 32):
AUTO_SENSE_BIT	equ	0001h
BOOT_PROTOCOL	equ	0006h		; type of boot prom protocol:
;951030	BOOT_NCP	equ	0002h	; use Novell Netware NCP (IPX)
;951030	BOOT_RPL	equ	0004h	; use IBM/Microsoft Remote Program Load
;951030	BOOT_BOOTP	equ	0006h	; use TCP/IP BOOTP and TFTP
;951030	BOOT_OTHER	equ	0000h	; use some other protocol
;951124	BOOT_NW_8023	equ	0000h	; use NetWare with IEEE 802.3
;951124	BOOT_NW_8022	equ	0002h	; use NetWare with IEEE 802.2
;951124	BOOT_NW_8137	equ	0004h	; use NetWare with Ethernet II
;951124	BOOT_RPL	equ	0006h	; use IBM/Microsoft Remote Program Load


; Off_33_1500 (location 33 Bit 13,14,15)
BOOT1500_PROT	equ	0e000h		; type of BootProtocol (bit 11,12,13)
        BOOT1500_NW_8023        equ     0000h   ; use NetWare with IEEE 802.3
        BOOT1500_NW_8022        equ     02000h  ; use NetWare with IEEE 802.2
        BOOT1500_NW_8137        equ     04000h  ; use NetWare with Ethernet II
        BOOT1500_RPL            equ     06000h  ; use RPL
        BOOT1500_BOOTP          equ     08000h  ; BOOTP
        BOOT1500_BOOTP_ARP      equ     0a000h  ; BOOTP/ARP


; Board "Subtypes" (location 6):
SUBTYPE_00	equ	1
SUBTYPE_10	equ	2
SUBTYPE_20	equ	3
SUBTYPE_01	equ	4
SUBTYPE_30	equ	5

; PCNetISA I/O Ports:
ADDR_PROM_OFFSET	equ	0	; MAC (datalink) Address PROM
RDP_OFFSET		equ	16	; Register Data Port
RAP_OFFSET		equ	18	; Register Address Port
ISACR_OFFSET		equ	22	; ISA-Bus Control Register
VSW_OFFSET		equ	24	; Vendor Specific Word

ISACR2		equ	2		; ISACR2 (out RAP register == ISACR2)
MC_UTP_OTHER	equ	001h		; value to select UTP or "Other" port
MC_AUTO_SEL	equ	002h		; value to select "Auto Select" function

; Possible AT-1500 IRQ choices (varies depending on board "subtype"):
IRQ_RANGE	MACRO	range_name, irq_a, irq_b, irq_c, irq_d
range_name	equ	(irq_a SHL 12) + (irq_b SHL 8) + (irq_c SHL 4) + irq_d
		ENDM
	IRQ_RANGE  LOW_IRQ_RANGE,     3,  4,  5,  9	; all except Subtype 30
	IRQ_RANGE  HIGH_IRQ_RANGE,   10, 11, 14, 15	; all except Subtype 30
	IRQ_RANGE  MIXED_IRQ_RANGE,   3, 11,  5, 15	; all except Subtype 30
	IRQ_RANGE  LOWER_IRQ_RANGE,   3,  4,  5,  9	; Subtype 30, BOOT_ENA=0
	IRQ_RANGE  UPPER_IRQ_RANGE,  10, 11, 12, 15	; Subtype 30, BOOT_ENA=1


Delay_750	proc	near
	push	cx
	mov	cx, 8

DELAY_750_Lp:
	loop	DELAY_750_Lp

	pop	cx
	ret
Delay_750	endp

DELAY_250 MACRO
	; times 2 = at least 400ns on a 40Mhz 386
	; times 4 = at least 400ns on an 80Mhz 386 (!!)
	jmp short $+2
	jmp short $+2
	jmp short $+2
	jmp short $+2
	ENDM


DEBUG_DISPLAY MACRO	display_char
	push	AX
	push	DX
	mov	AH, 02h
	mov	DL, '<'
	int	21h
	mov	DL, display_char
	int	21h
	mov	DL, '>'
	int	21h
	pop	DX
	pop	AX
	ENDM

;************************************************************************;
;*									*;
;*  VerifyBoard 							*;
;*	Function: Read the configuration of the AT-1500 board.		*;
;*	Input:	DI = base I/O address of the AT-1500 board.		*;
;*	Output: stc (carry set) if not an AT-1500 or config error;	*;
;*		clc (carry clear) if successful, and:			*;
;*			BH = configured DMA channel.			*;
;*			BL = configured IRQ.				*;
;*			CX = value to be output to the ISACR2 register. *;
;*		Other registers used are preserved.			*;
;*									*;
;************************************************************************;

VerifyBoard proc	near

	push	AX			; save caller's registers
	push	DX

	; Verify that this really is an AT-1500 board.
	mov	DX, DI			; DX = address prom I/O address
	in	AX, DX			; read the first 2 bytes of MAC address
	cmp	AX, 0			; it better be 0000
	je	VB_go_on
	 jmp	scr_error
VB_go_on:
	add	DX, 2
	in	AX, DX			; read the next 2 bytes of MAC address
	cmp	AL, 0F4h		; the third byte better be F4
	je	VB_its_ours
	 jmp	scr_error
VB_its_ours:
	;  Read the SCR to get the state of the configuration "switches".
	mov	BX, SCR_ADDR
	call	rd_oper 		; read the Switch Configuration Register
	mov	DX, AX			; save SCR value for later
	mov	CX, AX			; save SCR value for later

	;  Read this board's rev level and "subtype" codes.
	mov	BX, BOARD_REV_LOC	; read "board rev code" at EEPROM loc 6
	call	rd_oper 		; AL=rev level code, AH=Subtype code

	;  Determine the configured IRQ and return this value in BL.
	cmp	AH, SUBTYPE_30		; is this a Subtype 30 (8 IRQ) board ?
	 jne	VB_not_st30		;   no

	cmp	AL, 00h 		; is this an early-rev board ?
	 je	VB_jumper_normal	;    yes - ignore jumper
	cmp	AL, 0FFh		; is this an early-rev board ?
	 je	VB_jumper_normal	;    yes - ignore jumper
	mov	DX, DI
	add	DX, VSW_OFFSET
	in	AL, DX			; read the VSW to get the jumper state

    mov DX, CX		    ; Restore register value
	test	AL, JUMPER_STATE	; are both jumpers J1/J2 "in" (NORMAL) ?
	 jnz	VB_jumper_normal	;   yes
	; Alternate Address Mode is jumpered - adjust things.
	mov	BL, 9			; yes, assume 320/9
	cmp	DI, 320h
	 je	got_irq
	mov	BL, 5			; ... or 340/5
	cmp	DI, 340h
	 je	got_irq
	mov	BL, 10			; ... or 360/10
	jmp	got_irq
  VB_jumper_normal:
	mov	BX, UPPER_IRQ_RANGE	; jumper normal:  assume upper IRQs

	test	DX, BOOT_ENA		; is it using the upper range of IRQs?
	 jnz	got_irq_range		;   yes
	mov	BX, LOWER_IRQ_RANGE	; no, uses lower range of IRQs
	jmp	got_irq_range

  VB_not_st30:
	mov	BX, HIGH_IRQ_RANGE	; (assume this is a Subtype 20 board)
	cmp	AH, SUBTYPE_20		; is this a Subtype 20 board ?
	 je	got_irq_range		;   yes, uses High range of IRQ choices
	mov	BX, MIXED_IRQ_RANGE
	cmp	AH, SUBTYPE_00		; is this a Subtype 00 board ?
	 je	got_irq_range		;   yes, uses Mixed range of IRQ choices
	cmp	AH, SUBTYPE_01		; is this a Subtype 01 board ?
	 je	got_irq_range		;   yes, uses Mixed range of IRQ choices
	mov	BX, LOW_IRQ_RANGE	; must be Subtype 10: uses Low IRQ range
  got_irq_range:
	mov	AX, DX			; get the SCR value again
	and	AX, IRQ_MASK		; isolate IRQ configuration bits
	mov	CL, 12
	cmp	AX, IRQ_CHOICE_A	; switch based upon on of 4 IRQ choices
	 je	got_irq_choice
	mov	CL, 8
	cmp	AX, IRQ_CHOICE_B
	 je	got_irq_choice
	mov	CL, 4
	cmp	AX, IRQ_CHOICE_C
	 je	got_irq_choice
	xor	CL, CL
	cmp	AX, IRQ_CHOICE_D
	 je	got_irq_choice
	jmp	scr_error
  got_irq_choice:
	shr	BX, CL			; compute actual IRQ value
	and	BL, 0Fh 		;   and return in register BL
got_irq:

	;  Determine the configured DMA channel and return this value in BH.
	mov	AX, DX			; get the SCR value again
	and	AX, DMA_MASK		; isolate DMA channel configuration bits
	mov	BH, 3
	cmp	AX, DMA_3		; is it DMA channel 3 ?
	 je	got_dma 		;    yes
	mov	BH, 5
	cmp	AX, DMA_5		; is it DMA channel 5 ?
	 je	got_dma 		;    yes
	mov	BH, 6
	cmp	AX, DMA_6		; is it DMA channel 6 ?
	 je	got_dma 		;    yes
	mov	BH, 7
	cmp	AX, DMA_7		; is it DMA channel 7 ?
	 je	got_dma 		;    yes
	jmp	scr_error
got_dma:

	;  Determine the proper value to be used for ISACR2 and return it in CX.
	mov	CX, 0001h		; assume ISACR2 = XMAUSEL (ext. hdw)
	test	DX, UTP_PORT		; check SCR value: is "UTP" selected ?
	 jz	got_mau 		;   no, "Other" port (BNC/FOIRL/AUI)
	push	bx
	mov	BX, Off_33_1500	; not the "other" port, but ...
	call	rd_oper 		; read the flag word from the EEPROM
	pop	bx
	test	AX, AUTO_SENSE_BIT	; is "Auto Select" configured ?
	 jz	got_mau 		;   no, must be the UTP port
	mov	CX, 0002h		; yes, ISACR2 = ASEL (Auto Select)
got_mau:

	clc				; set CF=0 == "success"
	pop	dx			; restore caller's registers
	pop	ax
	ret				; return to caller

scr_error:
	stc				; set CF=1 == "error"
	pop	dx			; restore caller's registers
	pop	ax
	ret				; return to caller

VerifyBoard endp


;************************************************************************;
;*									*;
;*  rd_oper								*;
;*	Function: do a complete word READ operation.			*;
;*	Input:	BX = EEPROM address to be read.				*;
;*		DI = base I/O address of the AT-1500 board		*;
;*	Output: AX = data read from EEPROM.				*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	rd_oper
rd_oper proc	near

	push	bx		; save caller's registers
	push	cx
	push	dx
	mov	cx, bx

	call	pulse_cs	; pulse CS to terminate any previous command
	call	prep_load	; prepare the EEPROM for a new command
	mov	dx, SB
	call	wr_bit		; write a Start Bit
	mov	dl, READ
	and	cl, ADDR_MASK
	or	dl, cl
	call	wr_byte		; write a READ command code with the address

	xor	bx, bx		; bx = data read
	mov	cx, 16		; reading 16 bits
rd_next_bit1:
	shl	bx, 1
	call	rd_bit		; read a bit
	or	bx, ax		; merge it with accumulated bits so far
	loop	rd_next_bit1

	call	pulse_cs	; pulse CHIP SELECT to terminate the command
	mov	ax, bx		; return EEPROM value in AX
	pop	dx		; restore caller's registers
	pop	cx
	pop	bx
	ret			; return to caller

rd_oper endp

;************************************************************************;
;*									*;
;*  rd_bit								*;
;*	Function: Read 1 bit from the eeprom DO pin.			*;
;*	Input:	AX = the least significant bit (bit 0) is the data bit	*;
;*			read.						*;
;*		DI = base I/O address of the AT-1500 board		*;
;*	Output: nothing							*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	rd_bit
rd_bit	proc	near

	push	dx
	xor	ax, ax
	mov	al, CHIP_SEL
	or	al, CLOCK
	mov	dx, DI
	add	dx, VSW_OFFSET
	out	dx, al		; make CLOCK go high

	in	al, dx		; read D0
	and	al, DATA_OUT
	call 	DELAY_750	; chip requires about 750ns hold time here

	push	ax
	mov	al, CHIP_SEL
	out	dx, al		; make CLOCK go low again
	pop	ax

	shr	ax, 1
	shr	ax, 1		; return DO in LSB (bit 0) of AX
	pop	dx
	ret

rd_bit	endp


;************************************************************************;
;*									*;
;*  wr_byte								*;
;*	Function: Write a byte to the eeprom.				*;
;*	Input:	DL = data byte to be written.				*;
;*		DI = base I/O address of the AT-1500 board.		*;
;*	Output:	nothing							*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	wr_byte
wr_byte proc	near

	push	ax			; save caller's registers
	push	cx

	mov	al, dl
	mov	cx, 8
next_bit:
	rol	al, 1
	mov	dl, al
	and	dl, 01h			; DL bit 0 = bit to write
	call	wr_bit			; write one bit of the byte
	loop	next_bit		; loop to write all bits

	pop	cx			; restore caller's registers
	pop	ax
	ret				; return to caller

wr_byte endp

;************************************************************************;
;*									*;
;*  wr_bit								*;
;*	Function: Write a bit to the EEPROM Data In pin.		*;
;*	Input:	DL = the least significant bit (bit 0) is the data bit	*;
;*			to be written.					*;
;*		DI = base I/O address of the AT-1500 board.		*;
;*	Output: nothing							*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	wr_bit
wr_bit	proc	near

	push	ax		; save caller's registers
	push	bx
	push	dx
	mov	bl, dl
	mov	al, CHIP_SEL
	and	bl, 01h
	or	al, bl
	mov	dx, DI
	add	dx, VSW_OFFSET
	out	dx, al		; write CS and DI out
	or	al, CLOCK
	out	dx, al		; present data bit with CLOCK high
	call	DELAY_750		; chip requires about 750ns hold time here
	mov	al, CHIP_SEL
	out	dx, al		; make the CLOCK go low again

	pop	dx		; restore registers
	pop	bx
	pop	ax
	ret			; return to caller

wr_bit	endp

;************************************************************************;
;*									*;
;*  cs_low								*;
;*	Function: to make the Chip Select pin in the EEPROM go low.	*;
;*	Input:	DI = base I/O address of the AT-1500 board		*;
;*	Output: nothing							*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	cs_low
cs_low	proc	near

	push	ax		; save caller's registers
	push	dx
	mov	dx, DI
	add	dx, VSW_OFFSET
	xor	ax, ax
	out	dx, al		; turn off CHIP SELECT
	DELAY_250		; chip requires about 250ns between instructions
	pop	dx		; restore caller's registers
	pop	ax
	ret			; return to caller

cs_low	endp

;************************************************************************;
;*									*;
;*  cs_high								*;
;*	Function: to make the Chip Select pin in the EEPROM go high.	*;
;*	Input:	DI = base I/O address of the AT-1500 board		*;
;*	Output: nothing							*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	cs_high
cs_high	proc	near

	push	ax		; save caller's registers
	push	dx
	mov	dx, DI
	add	dx, VSW_OFFSET
	mov	al, CHIP_SEL
	out	dx, al		; turn on CHIP SELECT
	pop	dx		; restore caller's registers
	pop	ax
	ret			; return to caller

cs_high	endp

; Code is moved from  AT1500.ASM. EEPROM code specific to AT-1500

;************************************************************************;
;*									*;
;*  prep_load								*;
;*	Function: Generate one clock cycle as required before sending	*;
;*			a new command code to the EEPROM.		*;
;*	Input:	DI = base I/O address of the AT-1500 board		*;
;*	Output: nothing 						*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	prep_load
prep_load	proc	near

		mov	al, CHIP_SEL + CLOCK
		call	OutVSW
		and	al, NOT CLOCK
		call	OutVSW

		ret				; return to caller

prep_load	endp

;************************************************************************;
;*									*;
;*  pulse_cs								*;
;*	function: to make CS pin in the eeprom go low for a short time, *;
;*		  then go high again (required between commands).	*;
;*	input:	DI = base I/O address of the AT-1500 board		*;
;*	output: nothing 						*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	pulse_cs
pulse_cs	proc	near

	pushf			; save interrupt state
	cli			; disable interrupts
	xor	ax, ax
	call	OutVSW
	mov	al, CHIP_SEL
	call	OutVSW
	popf			; re-enable interrupts (if they were enabled)
	ret			; return to caller

pulse_cs	endp


;************************************************************************;
; OutVSW	output a byte to VSW. Save space.
; Input:	DI = base I/O address of the AT-1500
;		AL = byte to output
;************************************************************************;
public	OutVSW
OutVSW	proc	near

	push	dx
	mov	dx, DI
	add	dx, VSW_OFFSET
	out	dx, al		; turn on CHIP SELECT
	call	Delay_750
	pop	dx		; restore caller's registers
	ret			; return to caller

	ret
OutVSW	endp

; Copied from Config15.ASM from Allied Telesis DDK
;************************************************************************;
;*									*;
;*  wr_oper								*;
;*	Function: do a complete word WRITE operation.			*;
;*	Input:	DX = data word to be written.				*;
;*		BX = address of the word to be written. 		*;
;*		DI = base I/O address of the AT-1500 board.		*;
;*	Output: nothing 						*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	wr_oper
wr_oper proc	near

	push	bx		; save caller's registers
	push	dx

	call	pulse_cs	; 930928 pulse CS to terminate any previous command
	call	prep_load	; prepare the EEPROM for a new command
	mov	dx, SB
	call	wr_bit		; write a Start Bit
	mov	dl, WRITE
	and	bl, ADDR_MASK
	or	dl, bl
	call	wr_byte 	; write a WRITE command code with the address
	pop	dx		; pop caller's data word to be written
	push	dx		; (save it again)
	call	wr_word 	; write the caller's data word

	pop	dx		; restore caller's registers
	pop	bx
	cmp	bx, SCR_ADDR	; did we just write to the SCR ?
	 je	wo1		;   yes, not a real EEPROM location - don't wait
	call	wait_for_write	; no, wait for EEPROM write cycle to complete
	call	pulse_cs	; pulse CHIP SELECT to terminate the command
wo1:
	ret			; return to caller

wr_oper endp

;************************************************************************;
;*									*;
;*  wr_word								*;
;*	Function: Write a word to the eeprom.				*;
;*	Input:	DX = data word to be written.				*;
;*		DI = base I/O address of the AT-1500 board		*;
;*	Output: nothing 						*;
;*		registers used are preserved.				*;
;*									*;
;************************************************************************;
public		wr_word
wr_word proc	near

	xchg	dl, dh
	call	wr_byte 		; write the high-order byte first
	xchg	dl, dh
	call	wr_byte 		; write the low-order byte next
	ret				; return to caller

wr_word endp

;************************************************************************;
;*									*;
;*  wait_for_write							*;
;*	Function: to wait and check for write operation to complete.	*;
;*	Input:	DI = base I/O address of the AT-1500 board		*;
;*	Output: nothing 						*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public	wait_for_write
wait_for_write	proc	near

	push	ax
	push	dx
	mov	dx, DI
	add	dx, VSW_OFFSET
	pushf			; save interrupt state
	cli			; disable interrupts - timing below important
	xor	ax, ax
	out	dx, al		; drop CHIP SELECT
	jmp	$+2
	jmp	$+2		; dally a bit
	jmp	$+2
	mov	al, CHIP_SEL
	out	dx, al		; turn on CHIP SELECT again
	popf			; re-enable interrupts (if they were enabled)
	call	DELAY_750	; chip requires min. 500ns before status valid
wait_til_write_completes:
	in	al, dx
	test	ax, DATA_OUT	; is the write complete yet ?
	 jz	wait_til_write_completes  ; no - wait
    write_has_completed:

	pop	dx
	pop	ax
	ret

wait_for_write	endp

;************************************************************************;
;*									*;
;*  wr_enable								*;
;*	function: to do WREN operation (Write Enable).			*;
;*	input:	DI = base I/O address of the AT-1500 board		*;
;*	output: nothing 						*;
;*		registers used are preserved				*;
;*									*;
;************************************************************************;
public		wr_enable
wr_enable	proc	near

	push	dx
	call	prep_load	;wait for 1 clock cycle
	mov	dx, SB		;write Start Bit
	call	wr_bit
	mov	dx, WEN
	call	wr_byte
	call	pulse_cs
	pop	dx
	ret

wr_enable	endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\drvseg.inc ===
;----------------------------------------------------------------------
; DRVSEG.INC
;
; Segment definitions for all BootWare ROMs.
;
; 961226 PC - added Code_NID and Code_NAD, changed alignments to para
;	    - added IDEAL mode support
; 960105 PC - added INIT segment
; 951030 PC
;----------------------------------------------------------------------
IFDEF _IDEAL_
Group	cGroup _Text
DGROUP equ <Cgroup>
	assume	cs:cGroup, ds:cGroup, es:nothing,ss:nothing

; Define segment macros for ideal mode

Macro	START_INIT
Segment	Code Public "Code"
	assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
endm

Macro	END_INIT
ends
endm

Macro	START_NAD
Segment	Code Public "Code"
	assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
endm

Macro	END_NAD
ends
endm

Macro	START_CODE
;Segment	Code Public "Code"
Segment _TEXT  para public "CODE"
	assume ds:dGroup,cs:cGroup,es:nothing,ss:nothing
endm

Macro	END_CODE
ends
endm

Macro	START_NID
;Segment	Code Public "Code"
Segment _TEXT  para public "CODE"
	assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
endm

Macro	END_NID
ends
endm

Macro	START_SPARSE
Segment _TEXT  para public "CODE"
;Segment	Sparse Public "Code"
endm

Macro	END_SPARSE
ends
endm

Macro   START_TEXT

Segment _TEXT  para public "CODE"
endm

Macro	END_TEXT
ends
endm





ELSE
; Define segment macros for MASM mode
;====================================================================
cGroup		group	_TEXT
		assume	cs:cGroup, ds:cGroup, es:nothing,ss:nothing

START_INIT	macro
Code		segment Public 'Code'
		assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_INIT	macro
Code		ends
		endm

START_NAD	macro
Code		segment Public 'Code'
		assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_NAD		macro
Code		ends
		endm

START_CODE	macro
;Code		segment Public 'Code'
_TEXT       segment para public 'CODE'
		assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_CODE	macro
;Code		ends
_TEXT       ends
		endm

START_NID	macro
;Code		segment Public 'Code'
_TEXT       segment para public 'CODE'
		assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_NID		macro
_TEXT       ends
;Code		ends
		endm

START_SPARSE	macro
;Sparse		segment Public 'Code'
_TEXT       segment para public 'CODE'
		assume ds:cGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_SPARSE	macro
;Sparse		ends
_TEXT       ends
		endm
ENDIF

;====================================================================
; Use all the marcos to set the order of the segments.
;====================================================================

;START_INIT
;END_INIT

;START_NAD
;END_NAD

START_CODE
END_CODE

;START_NID
;END_NID

START_SPARSE
END_SPARSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\pci.inc ===
VENDOR_ID	equ 1022h	     ;4 ; Vendor Identification

DEVICE_ID	equ 2000h 	     ;6 ; Device Identification (AT2450)

DEVICE_ID1   equ     0AE34h     ; 32


;PCI BIOS call constants definition
;----------------------------------
PCI_BIOS_INT             equ     1Ah
PCI_FUNCTION_ID          equ    0B1h
PCI_BIOS_PRESENT         equ     01h
FIND_PCI_DEVICE          equ     02h
FIND_PCI_CLASS_CODE      equ     03h
GENERATE_SPECIAL_CYCLE   equ     06h
READ_CONFIG_BYTE         equ     08h
READ_CONFIG_WORD         equ     09h
READ_CONFIG_DWORD        equ     0Ah
WRITE_CONFIG_BYTE        equ     0Bh
WRITE_CONFIG_WORD        equ     0Ch
WRITE_CONFIG_DWORD       equ     0Dh

;PCI BIOS returned values constants definition
;---------------------------------------------
PCI_SUCCESSFUL           equ     00h
PCI_FUNC_NOT_SUPPORTED   equ     81h
PCI_BAD_VENDOR_ID        equ     83h
PCI_DEVICE_NOT_FOUND     equ     86h
PCI_BAD_REGISTER_NUMBER  equ     87h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\eep24.inc ===
;************************************************************************
;*
;*			    EEP24.INC
;*
;*  EEPROM configuration routines for the ATI AT-2450 Adapters.
;*
;*  Copyright (c) 1994-5 Allied Telesyn Int.  All Rights Reserved.
;*
;
;    Rev 1.0   14 Nov 1994 11:30:24   SSCHELL
;************************************************************************

; EEPROM Opcode
READ_OP 	equ	2	; Read from EEPROM
EWEN_OP 	equ	0	; Erase Write Enable	0b00
EWEN_ADR	equ	030h	;			0b110000
ERASE_OP	equ	3	; Erase 		0b11
ERAL_OP 	equ	0	; Erase all		0b00
WRITE_OP	equ	1	; Write to EEPROM	0b01
WRAL_OP 	equ	0	; Write all reg 	0b00
EWDS_OP 	equ	0	; Erase Write Enable	0b00
EWDS_ADR	equ	0	;			0b000000

; EEPROM Map word offset
PROM_PADR1	equ	0
PROM_PADR2	equ	1
PROM_PADR3	equ	2
PROM_HWID	equ	4
PROM_USER1	equ	5
PROM_CHKSUM1	equ	6
PROM_ASCIIW	equ	7
PROM_IOLOW	equ	8
PROM_IOUP	equ	9
PROM_BCR18	equ	0ah
PROM_BCR2	equ	0bh
PROM_BCR21	equ	0ch
PROM_BCR9	equ	0eh
PROM_CHKSUM2	equ	0fh
PROM_USER2	equ	011h

; User1 Word (location 5):
BOOT2450_PROT	equ	03800h		; type of BootProtocol (bit 11,12,13)
	BOOT2450_NW_8023	equ	0000h	; use NetWare with IEEE 802.3
	BOOT2450_NW_8022	equ	0800h	; use NetWare with IEEE 802.2
	BOOT2450_NW_8137	equ	01000h	; use NetWare with Ethernet II
	BOOT2450_RPL		equ	01800h	; use RPL
	BOOT2450_BOOTP		equ	02000h	; BOOTP
	BOOT2450_BOOTP_ARP	equ	02800h	; BOOTP/ARP


; uwire control bit definitions
BCR19_UWIRE_ON	equ	10h	; sets EEN
BCR19_START	equ	15h	; "Start Bit" (command follows)
BCR19_STOP	equ	0	; Stop bit
BCR19		equ	19	; EEPROM control and status register
BCR19_ESK_HIGH	equ	2	; EEPROM serial clock
BCR19_ECS	equ	0014H	; EEPROM chip select

; PCNetPCI I/O Ports:
RAP_OFFSET	equ	12h	; Register Address Port
BDP_OFFSET	equ	16h	; Bus Data Port

; Configuration values for BCR2
MAU_SEL_MASK_2450	equ	0003h	; Bits 0-1 (BCR2): media selection

Delay_2450	proc	near
	push	cx
	mov	cx, 50

DELAY_2450_Lp:
	loop	DELAY_2450_Lp

	pop	cx
	ret
Delay_2450	endp


;************************************************************************;
;*									*;
;*  VerifyPCIBoard							*;
;*   Function: Read the configuration of the AT-2450 board.		*;
;*	       All we need is the media selection from the EEPROM.	*;
;*   Input:  DI = base I/O address of the AT-2450 board.		*;
;*   Output: stc (carry set) if not an AT-2450 or config error; 	*;
;*	clc (carry clear) if successful, and:				*;
;*	   CH = autoselect flag from BCR2 register			*;
;*	   CL = twisted pair flag from BCR2 register			*;
;*	Other registers used are preserved.				*;
;*									*;
;************************************************************************;
public	VerifyPCIBoard
VerifyPCIBoard proc   near

	push	ax			; Save caller's registers
	push	bx
	push	dx

	; Verify that this really is an AT-2450 board.
	mov	dx, di			; DX = address prom I/O address
	in	ax, dx			; Read the first 2 bytes of MAC address
	cmp	ax, 0			; It better be 0000
	je	VB_go_on_2450
	jmp	not_our_card

VB_go_on_2450:
	add	dx, 2
	in	ax, DX			; Read the next 2 bytes of MAC address
	cmp	al, 0F4h		; The third byte better be F4
	je	VB_its_ours_2450
	jmp	not_our_card

VB_its_ours_2450:
	mov	bx, PROM_BCR2		; Read BCR2 in the EEPROM
	call	EE_Read 		; to get the media selection

	and	bx, MAU_SEL_MASK_2450	; Look at only the 2 media sel bits
	mov	cx, bx			; We'll return it in cx
	and	cx, 01			; cl is the twisted pair flag
	shr	bx, 1			; Now look at autoselect
	mov	ch, bl			; Autoselect flag in ch

	clc				; Set CF=0 == "success"
	pop	dx			; Restore caller's registers
	pop	bx
	pop	ax
	ret				; Return to caller

not_our_card:
	stc				; Set CF=1 == "error"
	pop	dx			; Restore caller's registers
	pop	bx
	pop	ax
	ret				; Return to caller

VerifyPCIBoard endp


;****************************************************************************
;   This function reads a 16-bit word from the serial eeprom and returns the
;   result as an unsigned short integer in BX.	The eeprom location to be read
;   is passed to this function as the register BX. Note: It is assumed that
;   the EEPROM is configured for word (16 bit) mode.
;
;	Input:
;		bx = EEPROM location to read
;		di = IOBase
;
;	Output:
;		bx = value read
;****************************************************************************
public	EE_Read
EE_Read PROC NEAR

	push	si			; Save registers used
	push	cx
	push	dx
	push	ax

	mov	si, BCR19_START
	call	uwire_out		; Give START condition to EEPROM.

	mov	al, READ_OP
	call	ee_opcode		; Write the read opcode to EEPROM.

	call	ee_address		; Write desired address (BX) to EEPROM.

	xor	si, si			; Clear registers
	xor	bx, bx

	; Read 16 bits from EEPROM.
serial_in:
	call	eedo_in 		; Read a bit - returned in ax
	mov	cl, 000fH		; 15 bits
	mov	dx, si
	sub	cl, dl			; CL = 15 - loop counter
	shl	ax, cl			; Position the bit to add to the word
	or	bx, ax			; Add in the bit we just read
	inc	si
	cmp	si, 000fH		; Do we have a word yet?
	jle	serial_in		; No - read another bit

	; The word is read
	mov	si, BCR19_STOP		; BCR19_STOP = 0
	call	uwire_out		; Clear EEN and ECS.
					; bx = the EEPROM word just read

	pop	ax			; Restore saved registers
	pop	dx
	pop	cx
	pop	si

	ret

EE_Read ENDP

;****************************************************************************
;   EE_EWEN	Enable EEPROM  erase/write
;
;   Input:	bx = EEPROM location to write to
;		ax = value to write to EEPROM
;****************************************************************************
public		EE_Ewen
EE_Ewen 	proc	near
		push	dx
		push	ax

		mov	di, IOBase
		mov	si, BCR19_START
		call	uwire_out	; Give START condition to EEPROM.

		mov	al, EWEN_OP
		call	ee_opcode	; Write the write opcode to EEPROM.

		mov	bx, EWEN_ADR
		call	ee_address	; Write desired address (BX) to EEPROM.

		mov	si, BCR19_STOP		; BCR19_STOP = 0
		call	uwire_out		; Clear EEN and ECS.

	pop	ax
		pop	dx
		ret
EE_Ewen 	endp

;****************************************************************************
;   EE_EWDS	Disable EEPROM	erase/write
;
;   Input:	bx = EEPROM location to write to
;		ax = value to write to EEPROM
;****************************************************************************
public		EE_Ewds
EE_Ewds 	proc	near
		push	dx
		push	ax

		mov	di, IOBase
		mov	si, BCR19_START
		call	uwire_out	; Give START condition to EEPROM.

		mov	al, EWDS_OP
		call	ee_opcode	; Write the write opcode to EEPROM.

		mov	bx, EWDS_ADR
		call	ee_address	; Write desired address (BX) to EEPROM.

		mov	si, BCR19_STOP		; BCR19_STOP = 0
		call	uwire_out		; Clear EEN and ECS.

		pop	ax
		pop	dx
		ret
EE_Ewds 	endp



;****************************************************************************
;   EE_Write	This function writes a 16-bit word to the serial eeprom.
;
;   Input:	bx = EEPROM location to write to
;		ax = value to write to EEPROM
;		di = IOBase
;****************************************************************************
public		EE_Write
EE_Write	PROC NEAR

	push	si			; Save registers used
	push	cx
	push	dx
	push	ax

	push	ax
	mov	si, BCR19_START
	call	uwire_out		; Give START condition to EEPROM.

	mov	al, WRITE_OP
	call	ee_opcode		; Write the write opcode to EEPROM.

	call	ee_address		; Write desired address (BX) to EEPROM.

	xor	si, si			; Clear registers
	xor	bx, bx

	pop	ax			; Value to write to EEPROM

	; Write 16 bits to EEPROM.
	mov	cx, 16
serial_out:
	rol	ax, 1
	mov	si, ax
	and	si, 1
	or	si, BCR19_ECS
	call	uwire_out		; Write a bit

	loop	serial_out		; No - read another bit

	mov	ax, 19
	mov	bx, BCR19_UWIRE_ON
	call	reg_write		; clears ESC to start programming

	call	Delay_2450

	mov	ax, 19
	mov	bx, BCR19_ECS
	call	reg_write		; EEPROM DO now the busy indicator

	; Wait for program cycle to complete
EE_Write_chk:
	mov	ax, 19
	call	reg_read
	test	ax, 1
	jz	EE_Write_chk


	mov	si, BCR19_STOP		; BCR19_STOP = 0
	call	uwire_out		; Clear EEN and ECS.
					; bx = the EEPROM word just read

	pop	ax			; Restore saved registers
	pop	dx
	pop	cx
	pop	si

	ret

EE_Write	ENDP

;****************************************************************************
;   SetChkSum1	This function update Checksum 1 of EEPROM if necessary
;
;   Input:	di = IOBase
;****************************************************************************
public		SetChkSum1
SetChkSum1	proc	near

		xor	ax, ax
		mov	di, IOBase
		mov	bx, PROM_PADR1

SetChkSumB:	push	bx
		call	EE_Read
		add	al, bl
		adc	ah, 0
		add	al, bh
		adc	ah, 0
		pop	bx

		inc	bx
		cmp	bx, 6
		jnz	SetChkSumB

		mov	bx, PROM_ASCIIW
		call	EE_Read
		add	al, bl
		adc	ah, 0
		add	al, bh
		adc	ah, 0

		mov	bx,  PROM_CHKSUM1
		call	EE_Read
		cmp	ax, bx
		jz	SetChkSum1Exit

		call	Delay_2450

		; Need to update PROM_CHKSUM1
		mov	bx,  PROM_CHKSUM1
		call	EE_Write

		call	Delay_2450

SetChkSum1Exit:
		ret
SetChkSum1	endp

;****************************************************************************
;   SetChkSum2	This function update Checksum 2 of EEPROM if necessary
;
;   Input:	di = IOBase
;****************************************************************************
public		SetChkSum2
SetChkSum2	proc	near

		xor	ax, ax
		mov	di, IOBase
		mov	bx, PROM_PADR1

ReadChkSum2:	push	bx
		call	EE_Read
		add	ah, bl
		add	ah, bh
		pop	bx

		inc	bx
		cmp	bx, 012h
		jnz	ReadChkSum2

		; is checksum okay?
		sub	ah, 0ffh
		jz	SetChkSum2Exit

		; Need to readjust checksum
		neg	ah

		mov	bx,  PROM_CHKSUM2
		call	EE_Read
		add	ah, bh

		call	Delay_2450

		mov	bx,  PROM_CHKSUM2
		call	EE_Write

		call	Delay_2450


SetChkSum2Exit:
		ret
SetChkSum2	endp


;****************************************************************************
;   This function writes bit 1, followed by bit 0 of the argument 'opcode'
;   in AL onto the uwire interface.  The opcode of a desired eeprom operation
;   should be placed in the least significant two bits of the argument
;   'opcode', to write an opcode to the eeprom.
;
;	ax = OpCode
;****************************************************************************
public		ee_opcode
ee_opcode	PROC NEAR

	push	si			; Save used registers

	; Write out MSB of opcode
	push	ax			; Save for future use
	and	al, 2			; Look at bit 1 only
	shr	al, 1			; Put it in bit 0
	or	al, BCR19_ECS		; EEPROM chip select
	sub	ah, ah			; Clear high byte
	mov	si, ax			; SI is argument to uwire_out
	call	uwire_out		; Write the bit to the EEPROM

	; Write out LSB of opcode
	pop	ax			; Retrieve passed-in argument
	and	al, 1			; Look at bit 0 only
	or	al, BCR19_ECS		; EEPROM chip select
	sub	ah, ah			; Clear high byte
	mov	si, ax			; SI is argument to uwire_out
	call	uwire_out		; Write the bit to the EEPROM

	pop	si			; Restore used registers
	ret

ee_opcode	ENDP

;****************************************************************************
;   This function writes the 6 least significant bits of the argument
;   'address' onto the uwire interface (order:bit 5 to bit 0).  The desired
;   eeprom address should be placed in the 6 least significant bits of the
;   argument 'address' to write an address to the eeprom.
;
;   BX = address to write
;****************************************************************************
public		ee_address
ee_address	PROC NEAR

	push	si			; Save used registers
	push	dx
	push	ax
	push	cx

	xor	dx, dx			; Initialize bit counter

	; Write out MSB to LSB of address
write_address_bit:
	mov	cl, 5			; 5 bits
	mov	ax, dx
	sub	cl, al			; CL = 5 - loop counter
	mov	al, bl			; Passed in address is in BX
	shr	al, cl			; Position the bit to add to the word
	and	al, 1			; Look at just a single bit
	or	al, BCR19_ECS		; EEPROM chip select
	sub	ah, ah			; Clear high bit
	mov	si, ax			; SI is argument to uwire_out
	call	uwire_out		; Write the address bit to the EEPROM

	inc	dx			; Next bit
	cmp	dx, 5			; Did we do 5 bits yet?
	jbe	write_address_bit	; No - read another bit

	pop	cx			; Restore used registers
	pop	ax
	pop	dx
	pop	si
	ret

ee_address	ENDP

;****************************************************************************
;   This function takes a 16-bit unsigned integer argument, in SI, and
;   writes the lower 5 bits to BCR19, affecting the uwire interface.  A
;   clock edge on the EESK output is generated to clock the uwire interface,
;   causing a single bit write to the EEPROM.
;   SI = value to write
;****************************************************************************
public		uwire_out
uwire_out	PROC NEAR

	push	ax			; Save used registers
	push	bx
	mov	ax, si			; AX = value to write

	; Isolate uwire signals and clear the ESK bit to allow clocking.
	and	ax, 001dH

	; Writes data to uwire interface (ESK low).
	mov	bx, ax			; Data to be written
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	Delay_2450		; Guarantees fSK, tSKL, and tDIS EE

	or	bx, BCR19_ESK_HIGH	; Make EEPROM serial clock high
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	Delay_2450		; Guarantees fSK, tSKL, and tDIS EE

	pop	bx			; Restore used registers
	pop	ax

	ret

uwire_out	ENDP

;****************************************************************************
;   eedo_in - Perform single bit read from EEPROM using uwire interface.
;
;   The bit is returned in AX.
;****************************************************************************
public		eedo_in
eedo_in PROC NEAR

	push	bx			; Save used registers

	; Bring EESK (clock pin) low.
	mov	bx, BCR19_ECS		; EEPROM serial clock
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	Delay_2450		; Guarantees fSK and tSKL eeprom

	; Clock out EEPROM bit to EEDO pin.
	mov	bx, BCR19_ECS		; EEPROM serial clock
	or	bx, BCR19_ESK_HIGH	; Make EEPROM serial clock high
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	Delay_2450		; Guarantees fSK and tSKL eeprom
	call	Delay_2450

	mov	ax, BCR19		; Read from EEPROM control register
	call	reg_read		; Read the bit
	and	ax, 1			; Look at just a single bit

	pop	bx			; Restore used registers

	ret

eedo_in ENDP

;****************************************************************************
;   reg_write - Write a 16-bit value to the specified CSR or BCR register.
;
;   Use a 16-bit I/O instruction.  A BCR write is performed.
;
;
;	DI = IOBase
;	AX = number of the specific register to access
;	BX = data
;****************************************************************************
public		reg_write
reg_write	PROC NEAR

	push	dx			; Save used registers
	push	ax

	mov	dx, di			; Base IO address
	add	dx, RAP_OFFSET		; Write to Register Address Port
	out	dx, ax			; Write register to be accessed

	mov	ax, bx			; Data to be written

	mov	dx, di			; Base IO address
	add	dx, BDP_OFFSET		; Write to Bus Data Port
	out	dx, ax			; Write data to register

	pop	ax			; Restore used registers
	pop	dx

	ret

reg_write	ENDP

;****************************************************************************
;   reg_read - Read a 16-bit value from the specified CSR or BCR register.
;
;   Use a 16-bit I/O instruction.  A BCR read is performed.
;
;   IOAddress1 is expected to contain the correct I/O address.
;   AX contains the register to read on entry.	On exit, AX contains
;   the value just read.
;
;	DI = IOBase
;	AX = number of the specific register to access
;
;****************************************************************************
public		reg_read
reg_read	PROC NEAR

	push	dx			; Save used registers

	mov	dx, di			; Base IO address
	add	dx, RAP_OFFSET		; Write to Register Address Port
	out	dx, ax			; Write register to be accessed

	mov	dx, di			; Base IO address
	add	dx, BDP_OFFSET		; Write to Bus Data Port
	in	ax, dx			; Read data from register

	pop	dx			; Restore used registers

	ret

reg_read	ENDP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\3c90xb\bw90xb.inc ===
; Routines in BW90XB.INC
;
; Modules included:
;	- Init_Vulcan2
; 	- SetInterruptVector
;	- init_vulcan_hw
;	- AutoSelect
;	- TryLinkBeat 
;	- TryLoopback
;	- SetupConnector 
;


;******************************************************************************
; Init_Adapter2
;******************************************************************************
Init_Adapter2	proc	near
;
; set up initial TxStart thresholds.
;
;		mov	si, offset DGroup:PioTxStart
init_txs_loop:
;		mov	[si].txs_min, 0 	; Disable MinTxStart
;;960408		max	ax, 16, dx

;960408 {
;		; Replace "max	ax, 16, dx"
;		cmp	ax, 16
;		ja	init_txs_max
;
;		mov	ax, 16
;init_txs_max:	
;		mov	[si].txs_value, ax
;		add	ax, 2			; round
;		shr	ax, 2			; then scale
;		add	ax, CMD_SETTXSTART	; add command
;		mov	[si].txs_thresh, ax	; for direct use
;		mov	[si].txs_marker, 0D1CEh ; debug flag
;		add	si, SIZE_TxStart	; next TxStart threshold
;		cmp	si, offset DGroup:AfterTxStart
;		jb	init_txs_loop		; around again
;
; initialize Vulcan hardware, driver variables & tables
;
		call   init_adapter_hw		; initialize Vulcan hardware

;------------------------------------------------------------------------------
; enable int at 8259, turn on Ethernet Core Transciever and Receiver
;
mask_on_IRQ:

; setup initial TxStart & RxEarly Thresholds
; disable Tx and Rx Early Thresholds

		mov	dx, PortCmdStatus
		mov	ax, CMD_SETRXEARLY+RXEARLY_DISABLED
		mov	NormalRxEarly, ax	; will be adjusted later
		out	dx, ax

		mov	ax, CurTxStart
		out	dx, ax

; set rx filter
		mov	ax, CMD_SETRXFILTER+FILTER_INDIVIDUAL
		mov	HWFilter, ax		; save for SoftRxReset
		out	dx, ax

		mov	ax, CMD_SETINTMASK + BOOTWARE_INTS
		out	dx, ax

IFNDEF	UNDI
		; enable the transmitter
		mov     ah, CMDH_TXENABLE
		out     dx, ax

		; enable the receiver
		mov     ah, CMDH_RXENABLE
		out     dx, ax
ENDIF
; enable upload engine
		mov	eax, UPD_physaddr
		mov	dx, PortUpListPtr
		out	dx, eax

		mov	dx, PortCmdStatus
		mov	ax, CMD_STALLCTL + UP_UNSTALL
		out	dx, ax

		mov	ax, 0
		ret

Init_Adapter2	endp

;******************************************************************************
;
;   SetInterruptVector: this routine determine the mask value for the selected
;			IRQ level and EOI values for both master and slave
;			8259s. We do not mask on the selected IRQ in this
;			routine, instead, it will be turned on and off as
;			initialization goes on.
;
;   On Entry:
;	      al = IRQ level
;	      cli
;
;   On Exit:
;
;******************************************************************************
SetInterruptVector proc near

;
;------------------------------------------------------------------------------
; determine the mask value for the selected IRQ level
;

       mov    cl, al				 ; al = IRQ level
       and    cl, 0f7h				 ; strip out IRQ on slave
       mov    ch, 1
       shl    ch, cl
       mov    IRQBit, ch			 ; IRQ bit postion (1), maskoff)
       not    ch				 ; all bits 1 except channel
       mov    IntMaskOnBit, ch			 ; Mask on bit position (0)

       mov    word ptr int_mask_port, MASTER_MASK_PORT
       cmp    al, 7
       jbe    SetIRQMaster
       mov    word ptr int_mask_port, SLAVE_MASK_PORT

SetIRQMaster:
;------------------------------------------------------------------------------
; determine EOI values for both master and slave 8259
;
       mov    al, IRQLevel
       cmp    al, 8				 ; IRQ on slave?
       jae    SetEOI				 ; yes

       mov    ah, al				 ;
       or     ah, 60h				 ; specific EOI to master 8259
       mov    al, 40h				 ; nop to slave to 8259
       jmp    short save_eoi

SetEOI:
       mov    ax, 6220h 			 ; non-specific EOI to slave
						 ; specific EOI to master 8259
save_eoi:
       mov    eoi_value, ax			 ; ah = EOI for master
						 ; al = EOI for slave
       ret

SetInterruptVector endp


;******************************************************************************
;   init_adapter_hw:  this routine initializes most of vulcan hardware required
;		     to operate the adapter.  TxEnable and RxEnable will not
;		     be done in this routine
;
;   On Entry:
;	      adapter has been activated and window 0 is active.
;	      the following variables are valid and available:
;
;			1. IOBase
;			2. IRQLevel
;			5. NetAddress - ethernet addr of the adapter
;
;   On Exit:
;	      window 1 is active
;	      dx = port CmdStatus
;
;*****************************************************************************
init_adapter_hw	   proc      near

; for EISA board, cannot reset board.
		cmp	BusType, BUS_EISA
		jz	Init_SkipReset

		mov	dx, PortCmdStatus
		xor	ax,ax			   ; global reset
		out	dx,ax

GlobalResetWait:
		in      ax, dx
		test    ah, STH_BUSY
		jnz	GlobalResetWait		   ; loop while busy

Init_SkipReset:
;
;------------------------------------------------------------------------------
; Setup Station Address.  the adapter's Ethernet Address has been read out of
; EEPROM, we need to program it into window 2, so Ethernet Core Receiver can
; receive packets properly.  the active window is 0, switch to window 2 first.
;

		mov	dx, PortCmdStatus
		SelectWindow	WNO_STATIONADDRESS

IFDEF	UNDI
		lea	si, DGroup:BoardID	;971030
ELSE
		lea	si, NetAddress
ENDIF
		mov	dx, PortSA0_1
		lodsw
		out	dx, ax

		add	dx, 2			; dx = port addr 3, 2
		lodsw
		out	dx, ax

		add	dx, 2			; dx = port addr 1, 0 = IO base
		lodsw
		out	dx, ax
;
; Initialize the mask registers to 0's, so we get only messages meant for us
;
		xor    ax,ax
		add    dx,2			; dx = station mask lo
		out    dx,ax
		add    dx,2			; dx = station mask mid
		out    dx,ax
		add    dx,2			; dx = station mask hi
		out    dx,ax
;
;----------------------------------------------------------------------------
; determine the connector to use.
;
; we set the default to EEProm InternalConfiguration.  Then we check
;	for auto-selection
;

;;int 03    

;  Autoselect and ComputeSpeeds expect CLI.  force it.

		cli

		mov	ax, EEIntConfig1
		and	ax, ICH_XCVR_MASK
		shr	ax, ICH_XCVR_SHIFT
		mov	Xcvr, ax

		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

		mov	dx, PortInternalCfgH
		in	ax, dx
		test	ax, ICH_AUTOSELECT
		jz	not_auto_select

		mov	MiiSelect, -1
		call	AutoSelect		;if autoselect failed, Xcvr is
						;back to default
		jnc	autoselected

		mov	ax, HARDWARE_FAILURE	; don't do anything more
		ret

autoselected:
		cmp	Xcvr, XCVR_AUTO
		je	check_mii_speed

		cmp     Xcvr, XCVR_MII
		je      check_mii_speed

not_mii_connector:
;
;;980429, check link for single connector's adapter
;
		mov	LinkDetected, 0
		cmp     Xcvr, XCVR_100TX
		jz	test_100link
		cmp     Xcvr, XCVR_100FX
		jnz	not_100FX
test_100link:
		call	TryLinkbeat
		jc      fast_connector
		mov	LinkDetected, 1
		jmp     fast_connector

not_100FX:
		cmp	Xcvr, XCVR_10TP
		jnz	not_10TP
		call	TryLinkbeat
		jmp	short connector10

not_10TP:
;;; 980519
		cmp	Xcvr, XCVR_10AUI
		jnz	not_10AUI

		test	MediaOptions, RO_BASEFL		;10BaseFL ?
		jz	x10AUI
;
; since 10FL's link can't be detected, so always set it to true
;
		mov	LinkDetected, 1
		jmp	short slow_connector

not_10AUI:
x10AUI:
;;;
		call	TryLoopback		;  either 10AUI or 10BNC
connector10:
		jc	slow_connector
		mov	LinkDetected, 1
		jmp	short slow_connector
;;
not_auto_select:
		cmp	Xcvr, XCVR_AUTO 	; Cyclone AutoNegotiation
		jne	not_cyc_auto

		call	ForceMII
		jc      chk_mii_speed
		mov	LinkDetected, 0
		jz	check_mii_speed 	; not ok, but recoverable

		mov	ax, HARDWARE_FAILURE	; can't do anything more
		ret

not_cyc_auto:
		cmp     Xcvr, XCVR_MII
		jne     not_mii_connector

		call    ForceMII
		jc      chk_mii_speed
		mov	LinkDetected, 0
		jz	check_mii_speed 	; not ok, but recoverable

		mov	ax, HARDWARE_FAILURE	; can't do anything more
		ret

chk_mii_speed:
		mov	LinkDetected, 1
check_mii_speed:
		cmp     LineSpeed, 100
		je      fast_connector
		jmp     slow_connector

;
; determine link speed from connector.	also set BytesPerTick to 4 for 10Mbps
; operation (3.2us ticks=4 x 800ns) and 40 for 100Mbps operation (40 x 80ns).
;
fast_connector:
		mov	LineSpeed, 100		; Mbps
		jmp	xcvr_done

slow_connector:
		mov	LineSpeed, 10		; Mbps
xcvr_done:
;
;  first make sure the internal DC DC converter is disabled
;
		mov	dx, PortCmdStatus
		mov     ah, CMDH_STOPINTXCVR
		out     dx, ax		       ; issue command
;
; now give the transceiver 3ms to stabilize before we enable transmit or
; receive traffic thru it.
;
		mov	cx, Delay3ms
		call	WaitTime
;
; workaround for a hardware bug fix in Cyclone regarding PCI command MWI
;
		mov	ax, EESoftConfigInfo2
		test	ax, 0020h		;test bit 5
		jnz	bugfixed

		mov	dx, PortDMACtrl
		in	eax, dx
		or	eax, 100000h		;set defeatMWI to 1
		out	dx, eax
bugfixed:
;
; set up the connector (possibly for the second time)
;
		call    SetupConnector

		mov	dx, PortCmdStatus
		SelectWindow	WNO_OPERATING		 ;

		mov	ax, CMD_SETRZMASK+MASK_NONE	 ; enable all interrupts for Rev. 1
		out	dx, ax

		ret

init_adapter_hw	endp


;------ AutoSelect ----------------------------------------------------------;
;									     ;
;	This routine attempts to auto-select the connector.  It should be    ;
;	called only if the autoselect bit is set.  If it fails, it will      ;
;	leave the current connector in InternalConfig set.		     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Station Address has been set up on adapter.			     ;
;	Xcvr set to the connector to use if AutoSelect fails (this should    ;
;	    be read from the EEProm, NOT from InternalConfig)		     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	Delay25ms set up for a 50ms delay.				     ;
;	MediaEnable table defined.					     ;
;	Specific.mc_caddr set up with the station address.		     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	MediaStatus, MacControl, InternalConfig set up for connector chosen. ;
;	DC-DC converter stopped/started as required.			     ;
;	TxFIFO/RxFIFO reset and disabled.				     ;
;	RZMask/IntMask disabled (0).					     ;
;	NetDiag modified for no loopback.				     ;
;	No interrupts pending.						     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;
AutoSelect	proc	near

		pusha
;
; set the IntMask and RZMask not to allow any interrupts through
;
		mov	dx, PortCmdStatus
		mov	ax, CMD_SETINTMASK + 0
		out	dx, ax
		mov	ax, CMD_SETRZMASK + 0
		out	dx, ax
;
; save the default connector
;
		mov	bp, Xcvr		; save original Xcvr value
;
; determine what connectors are available
;
;980519		mov	dx, PortCmdStatus
;		SelectWindow WNO_FIFO

;		mov	dx, PortMediaOptions	;PortResetOptions
;		in	ax, dx
;		mov	bx, ax			; BX=ResetOptions

		mov	bx, MediaOptions
;
; if 100TX connector is available, try that.  we do 100Mbps first to avoid
; generating any 10Mbps traffic on a hub that might be autosensing and might
; switch to 10Mbps to match us.  For Cyclone, 100TX is used to indicate on
; board auto-negotiation.
;
; note: sending 100Mbps stuff on a 10TP connection will generally partition
;	us.  we'll need to clear this up before we're done.
;
		public	auto_try_100tx
auto_try_100TX:
		test	bx, RO_BASETX
		jz	auto_try_MII

		mov	Xcvr, XCVR_AUTO

;;int    03h

		call	TryMII
		jc	auto_exit
		jz	auto_try_mii
		mov	LinkDetected, 0
		jmp	auto_exit_hw_fail
;
; if MII is available, try that
;
		public	auto_try_MII
auto_try_MII:
		test    bx, RO_MII
		jnz	try_MII

;
; if 100BASE-T4 PHY is available through MII
;
		test    bx, RO_BASET4
		jz      auto_try_10TP

try_MII:
		mov	Xcvr, XCVR_MII

;;int    03h

		call	TryMII
		jc	auto_exit
		jz	auto_try_10TP
		mov	LinkDetected, 0
		jmp	auto_exit_hw_fail
;
; if 10TP connector is available, try that.  This is for the Boomerang case.
; For Cyclone, it could be a 10Mbps only card that uses the auto negotiation.
;
		public	auto_try_10TP
auto_try_10TP:
		test	bx, RO_TP
		jz	auto_try_aui

		mov	Xcvr, XCVR_AUTO

;;int    03h

		call	TryMII
		jc	auto_exit
		jz	boom_10tp		; could be TPO
		mov	LinkDetected, 0
		jmp	auto_exit_hw_fail

boom_10tp:
		mov	Xcvr, XCVR_10TP
		call	TryLinkbeat
		jnc	auto_exit
;
; if 10AUI connector is available, try that
;
		public	auto_try_aui
auto_try_aui:
		test	bx, RO_AUI
		jz	auto_try_bnc

		mov	Xcvr, XCVR_10AUI
		call	TryLoopback
		jnc	auto_exit
		mov	LinkDetected, 0
;
; if 10BNC connector is available, try that
;
		public	auto_try_bnc
auto_try_bnc:
		test	bx, RO_COAX
		jz	auto_try_100FX
;		jz	auto_fail

		mov	Xcvr, XCVR_10BNC
		call	TryLoopback
		jnc	auto_exit
		mov	LinkDetected, 0
;;; 980519
; if 100FX connector is available, try that
;
auto_try_100FX:
		test	bx, RO_BASEFX
		jz	auto_try_10FL

		mov	Xcvr, XCVR_100FX
		call	TryLinkbeat
		jnc	auto_exit
		mov	LinkDetected, 0
;
; if 10FL connector is available, always assume the link is available since it
;	can't be detected
;
auto_try_10FL:
		test	bx, RO_BASEFL
		jz	auto_fail
		mov	Xcvr, XCVR_10AUI
		jmp	short auto_exit
;;;
;
; nothing worked.  just switch back to the default connector
;
		public	auto_fail
auto_fail:
		mov	Xcvr, bp
		call	SetupConnector
		jmp	autox
;
; done.  leave.
;
		public	auto_exit
auto_exit:
		mov	LinkDetected, 1
autox:
		clc
		popa
		ret

auto_exit_hw_fail:
		stc					; hardware failure
		popa
		ret

AutoSelect	endp


;------ TryLinkBeat ---------------------------------------------------------;
;									     ;
;	This routine sets up the adapter to use one of the linkbeat-capable  ;
;	connectors: 10TP or 100TX.  Since the port might be partitioned by   ;
;	the hub (a previous attempt at an incorrect speed might cause this   ;
;	for example), we send a packet first to clear this up.	Then we      ;
;	look for linkbeat.						     ;
;									     ;
;	This routine is part of the auto-select logic and is called by	     ;
;	AutoSelect to do its work.					     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Xcvr set to the connector to set up.				     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	Delay25ms set up for a 50ms delay.				     ;
;	MediaEnable table defined.					     ;
;	Specific.mc_caddr set up with the station address.		     ;
;	no interrupts pending.						     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	clc if we get linkbeat, the connector seems fine.  stc if not.	     ;
;	DC-DC converted started/stopped.				     ;
;	MediaStatus set up.						     ;
;	MacControl set up.						     ;
;	InternalConfig set up.						     ;
;	Rx/TxFIFO's reset and disabled.                                      ;
;	NetDiag modified for no loopback.				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;
		public	TryLinkbeat
TryLinkbeat	proc	near

		pusha
		push	es
;
; go quiet for 1.5 seconds to get any N-Way hub into a receptive state to
; sense the new speed.  we go quiet by switching to the 10BaseT connector
; with no linkbeat
;
		call    QuietConnector

		mov     cx, 30		  ; 30 x 1/20th = 1.5 sec
tlb_qloop:
		push	cx
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime		; assume cx preserved
		pop	cx
		loop    tlb_qloop

;
; set up the connector
;
		call	SetupConnector
;
; give settling time. Run WaitTime twice to get enough delay
;
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime		; assume cx preserved
;
; we might be partitioned.  some hubs won't clear the partition until we
; send a packet.  so send one.	the good news is that if we are partitioned
; then there is no receive traffic incoming so we don't have to wait that
; long for backoffs or retries.
;
; load the UplistPtr
;
		mov	dx, PortUpListPtr
		mov	eax, UPD_physaddr
		out	dx, eax

		mov	dx, PortCmdStatus
		mov	ax, CMD_STALLCTL + UP_UNSTALL
		out	dx, ax
;
; set up a 14-byte packet to send.  ourselves as the destination.
;
		push	ds
		pop	es
		mov	di, offset DGroup:TxBuf
		mov	dword ptr [di], 16
		add	di, 4			; adjust ptr 4 bytes
IFDEF	UNDI
		lea	si, DGroup:BoardID
ELSE
		lea	si, NetAddress
ENDIF
		mov	cx, 6
	rep	movsb			;rep outsb	; destination address
		mov	cx, 6
		sub	si, 6
	rep	movsb			;rep outsb	; source address

		mov	word ptr es:[di], 0h		; pad to 16 bytes

		mov	si, offset DPD
		mov	[si].DPD_FSHindicate, 0000h	;turn off dnIndicate
		mov	[si].DPD_FrameStart, 8000h 	;turn on txIndicate 
		mov	[si].DPD_Frag.Frag_len, 20	 ; # of bytes of data
		or	[si].DPD_Frag.Frag_len, FRAGLAST ; set fraglast bit

		mov	dx, PortDnListPtr
		mov	eax, DPD_physaddr
		out	dx, eax 			; write DnListPtr
;
; enable transmission.
;
		mov	dx, PortCmdStatus
		mov     ah, CMDH_TXENABLE
		out     dx, ax			; enable the Tx
;
; wait 1.25 seconds (>1 sec required by N-Way) for the linkbeat detect
; logic/N-Way auto-select to settle.
;
		mov	cx, 25			; 25 x 1/20th = 1.25 sec
tlb_loop:
		push	cx
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime
		pop	cx
		loop	tlb_loop
;
; check for linkbeat
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS

		mov	dx, PortMediaStatus
		in	ax, dx			; AX=MediaStatus
		test	ax, MEDIA_LBEAT 	; got linkbeat?
		jnz     tlb_gotlink
;
; no linkbeat.	connector probably not connected to a network.
;
		public	tlb_bad
tlb_bad:
		stc
		jmp	short tlb_exit
;
; got linkbeat.  if we're testing 10BaseT, that's good enough.
;
		public  tlb_gotlink
tlb_gotlink:
		cmp     Xcvr, XCVR_10TP
		je      tlb_good_10
;
; with 100BaseTX the problem is that 10Mbps traffic makes the 100Mbps link beat
; indication go on.  so we need to do some sanity checking of the result.  we
; want to loop around for a while looking for linkbeat to go off (there was
; a long enough gap in the 10Mbps traffic) or a packet to be received (if good,
; then its a real 100Mbps network).  we also sample carrier during this loop.
; if we see carrier enough of the time during the loop, then we should have
; received a packet.  if not, its just 10Mbps traffic giving us a false linkbeat.
; this is acceptable only because this loop runs for a very long time relative
; to the wire.  on current PCI systems with a single I/O taking around 600ns,
; this loop run run around 1/16th of a second.  this is long enough for 150
; max size 4500 byte packets plus 333 additional slot times for backoff.  this
; seems a reasonable period to require a packet to show up if we have carrier.
; the only exposure here is if some future system has massively faster single
; I/O cycles, which doesn't seem too worrisome.
;
		mov	dx, PortCmdStatus
		mov     ax, CMD_SETRXFILTER + FILTER_PROMISCUOUS
		out     dx, ax
		mov     ah, CMDH_RXENABLE
		out     dx, ax			; enable the receiver

		xor     bx, bx			; BX=# CRS's seen=0
		mov	cx, 0FFFFh		; CX=# loops to do
tlb_outer:
		test	UPD.UPD_UpPktStatus, UPPKTCOMPLETE
		jz	nopkg			; ...nope

;		AcknowledgeInt INT_UPCOMPLETE
		mov	eax, dword ptr UPD.UPD_UpPktStatus
		test	ah, RXSH_ERROR		; any errors?
		jz	tlb_good		; ...no errors, must be 100Mbps

		mov	dword ptr UPD.UPD_UpPktStatus, 0 ; clear the uppktstatus
nopkg:
		mov	dx, PortMediaStatus
		in      ax, dx

		test    ax, MEDIA_LBEAT		; still got linkbeat?
		jz      tlb_bad			; nope--bad link

		test    ax, MEDIA_CRS		; count CRS's seen
		jz      crss
		inc     bx			; ++BX = # of CRS's seen
crss:
		loop    tlb_outer
;
; fell out of loop.  linkbeat the whole time.  no good packets received.  if
; carrier sense was on a lot of the time, then we should have got a packet.
; if not, its a false reading.
;
		cmp     bx, 4000h		; CRS on 1/4 of the time?
		jae     tlb_bad			; if so, false reading
;
; connector good.  return carry clear.
;
tlb_good:
tlb_good_10:
		clc
;
; return current carry flag setting after disabling.
;
		public	tlb_exit
tlb_exit:
		mov	ax, 0			; used mov's to preserve CF
		mov	UPD.UPD_UpPktStatus, ax	; clear UPD status
		pushf

		mov	dx, PortCmdStatus
		call	TxReset
		call	RxReset

		popf
		pop	es
		popa
		ret

TryLinkbeat	endp



;------ QuietConnector ------------------------------------------------------;
;
;       This routine shuts down all output from the adapter.  It does this
;       by selecting the 10BaseT connector and disabling linkbeat.
;
;       Entry:
;       cli
;       DelayXcvr set for 3ms delay.
;
;       Exit:
;       cli
;       DC-DC stopped.
;       InternalConfig set to use 10BaseT.
;       MediaStatus set to linkbeat disabled.
;       Rx/TxFIFO's reset and disabled.
;
;       All registers preserved.
;
;----------------------------------------------------------------------------;
QuietConnector  proc    near

		pusha
;
; set up the InternalConfig for 10BaseT
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

		mov	dx, PortInternalCfgH
		in      ax, dx
		and     ax, NOT ICH_XCVR_MASK
		or      ax, XCVR_10TP SHL ICH_XCVR_SHIFT
		out     dx, ax
;
; in MediaStatus, disable linkbeat generation
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS

		mov	dx, PortMediaStatus
		in      ax, dx		  ; AX=media status
		and     ax, NOT (MEDIA_LBEATENABLE)
		out     dx, ax		  ; write it back
;
; reset the Tx/RxFIFO's
;
		mov	dx, PortCmdStatus
		call	TxReset
		call	RxReset

		popa
		ret

QuietConnector  endp


;------ TryLoopback ---------------------------------------------------------;
;									     ;
;	This routine sets up the adapter to use one of the		     ;
;	non-linkbeat-capable connectors: 10BNC or 10AUI.  For these	     ;
;	connectors we enable external loopback and transmit a packet to      ;
;	ourselves.  If we receive it (or any other packet without errors)    ;
;	the connector works.						     ;
;									     ;
;	This routine is part of the auto-select logic and is called by	     ;
;	AutoSelect to do its work.					     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Xcvr set to the connector to set up.				     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	Delay25ms set up for a 50ms delay.				     ;
;	MediaEnable table defined.					     ;
;	Specific.mc_caddr set up with the station address.		     ;
;	no interrupts pending.						     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	clc if we get linkbeat, the connector seems fine.  stc if not.	     ;
;	DC-DC converted started/stopped.				     ;
;	MediaStatus set up.						     ;
;	MacControl set up.						     ;
;	InternalConfig set up.						     ;
;	Rx/TxFIFO's reset and disabled.                                      ;
;	NetDiag modified for no loopback.				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	TryLoopback
TryLoopback	proc	near
		pusha
;
; set up the connector
;
		call	SetupConnector
;
; enable external loopback so that we can see our own packets
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS
		mov	dx, PortNetDiag
		in	ax, dx
		and	ax, NETD_NOLOOPBACK_MASK
		or	ax, NETD_EXTLOOPBACK
		out	dx, ax
;
; up to three times (we might get collisions) try to loop a packet thru
;
		mov	bp, 3			; outer loop count

		public	tlp_loop
tlp_loop:
;
; reset both transmitter and receiver, enable both and set up our packet
; filter to receive anything
;
		mov	dx, PortCmdStatus
		call	TxReset
		mov     ah, CMDH_TXENABLE
		out     dx, ax

		call	RxReset
		mov     ah, CMDH_RXENABLE
		out     dx, ax

		mov	ax, CMD_SETRXFILTER + FILTER_PROMISCUOUS
		out	dx, ax
;
; load the UplistPtr
;
		mov	dx, PortUpListPtr
		mov	eax, UPD_physaddr
		out	dx, eax

		mov	dx, PortCmdStatus
		mov	ax, CMD_STALLCTL + UP_UNSTALL
		out	dx, ax
;
; send a 14-byte packet to ourselves.
;
		push	ds
		pop	es
		mov	di, offset DGroup:TxBuf
		mov	dword ptr [di], 16
		add	di, 4			; adjust ptr 4 bytes
IFDEF	UNDI
		lea	si, DGroup:BoardID
ELSE
		lea	si, NetAddress
ENDIF
		mov	cx, 6
	rep	movsb			;rep outsb	; destination address
		mov	cx, 6
		sub	si, 6
	rep	movsb			;rep outsb	; source address

		mov	word ptr es:[di], 0h		; pad to 16 bytes

		mov	si, offset DPD
		mov	[si].DPD_FSHindicate, 0000h	; turn off dnIndicate
		mov	[si].DPD_FrameStart, 8000h 	;turn on txIndicate 
		mov	[si].DPD_Frag.Frag_len, 20	 ; # of bytes of data
		or	[si].DPD_Frag.Frag_len, FRAGLAST ; set fraglast bit

		mov	dx, PortDnListPtr
		mov	eax, DPD_physaddr
		out	dx, eax 			; write DnListPtr

		mov	dx, PortDMACtrl
;
; wait for the packet to show up in RxStatus.  give it up to 1/4 second.
;
		mov	cx, 5			; 5 x 1/20th = 1/4 second
tlp_rxloop:
		in	eax, dx 		; read pktstatus
		test	ax, UPCOMPLETE
		jnz	tlp_rxcomplete

		push	cx			; 950511
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime
		pop	cx			; 950511
		loop	tlp_rxloop

		xor	ax, ax
		mov	UPD.UPD_UpPktStatus, ax	; clear it anyway
;
; no complete packets received.  try again.
;
		public	tlp_rxfail
tlp_rxfail:
		dec	bp
		jnz	tlp_loop
		jmp	tlp_bad
;
; a complete RxStatus.	check for any errors.
;
		public	tlp_rxcomplete
tlp_rxcomplete:
		mov	dx, PortCmdStatus
		mov	ax, CMD_ACKNOWLEDGE + INT_UPCOMPLETE	
		out     dx, ax

		mov	eax, DWORD PTR UPD.UPD_UpPktStatus
		test	ah, RXSH_ERROR
		jnz	tlp_rxfail
;
; got a good receive packet.  connector seems good.
;
		public	tlp_good
tlp_good:
		xor	ax, ax
		mov	UPD.UPD_UpPktStatus, ax ; clear it
		clc
		jmp	short tlp_exit
;
; no packets received.	connector probably not connected to a network.
;
		public	tlp_bad
tlp_bad:
		stc
;
; return current carry flag setting after disabling/resetting.
;
		public	tlp_exit
tlp_exit:
		pushf

		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS
		mov	dx, PortNetDiag
		in	ax, dx
		and	ax, NETD_NOLOOPBACK_MASK
		out	dx, ax			; disable any loopback modes

		mov	dx, PortCmdStatus
		call	TxReset
		call	RxReset

		popf
		popa
		ret

TryLoopback	endp


;------ SetupConnector ------------------------------------------------------;
;									     ;
;	This routine sets up the adapter to use the specified connector.     ;
;	It sets up the connector in InternalConfig, sets bits in MacControl  ;
;	and MediaStatus as appropriate, and starts/stops the DC-DC converter ;
;	as required.							     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Xcvr set to the connector to set up.				     ;
;	SWConfig has the software configuration word from the EEProm.	     ;
;	Delay3ms set for 3ms delay.					    ;
;	MediaEnable table defined.					     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	DC-DC converted started/stopped.				     ;
;	MediaStatus set up.						     ;
;	MacControl set up.						     ;
;	InternalConfig set up.						     ;
;	Rx/TxFIFO's reset and disabled.                                      ;
;	NetDiag modified for no loopback.				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	SetupConnector
SetupConnector	proc	near
		pusha
;
; disable any loopback modes in effect
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS

		mov	dx, PortNetDiag
		in	ax, dx
		and	ax, NETD_NOLOOPBACK_MASK
		out	dx, ax
;
; set up the connector in InternalConfig
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

		mov	dx, PortInternalCfgH
		in	ax, dx
		and	ax, NOT ICH_XCVR_MASK
		mov	cx, Xcvr
		shl	cx, ICH_XCVR_SHIFT
		or	ax, cx
		out	dx, ax
;
; if full-duplex operation is specified, go enable it.	disable all the weird
; stuff for now.
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_FIFO

		mov	dx, PortMacControl
		in	ax, dx
		and	ax, NOT MACC_FULLDUPLEX ; not full duplex
		and	ax, NOT MACC_ALLOWLARGE ; no large packets
		and	ax, NOT MACC_DEFEREXTEND ; normal 802.3 deferrence

; check to see if we auto negotiated.  If we did, then program full duplex
; based on what was negotiated.

;		mov	full_on, 0		; init a full duplex flag
;		test	Xcvr, XCVR_MII + XCVR_AUTO
;		jz	check_EEPROM

;		test	auto_negotiated, 1
;		jz	check_EEPROM

;		test	full_duplex, 1		; full duplex was set
;		jz	@F

;		or	ax, MACC_FULLDUPLEX
;		mov	full_on, 1
;		jmp	@F

;check_EEPROM:
;		test	SWConfig, SW_FULLDUPLEX
;		jz	@F

;		or	ax, MACC_FULLDUPLEX
;		mov	full_on, 1		; full duplex was set
;@@:
		out	dx, ax
;
; setup various bits in MediaStatus (jabber, linkbeat, sqe) as appropriate
; for the connector.  the user can force linkbeat off if desired at 10Mbps.
;
		mov	dx, PortCmdStatus
		SelectWindow WNO_DIAGNOSTICS

		mov	dx, PortMediaStatus
		in	ax, dx			; AX=media status
		and	ax, NOT MEDIA_XCVRBITS	; mask bits off first
		mov	bx, Xcvr		; transceiver type
		shl	bx, 1			; use as index into table
		or	ax, MediaEnable[bx]	; on bits appropriate to xcvr

		test	EESoftConfigInfo, SW_LINKBEAT	; if set, don't enable linkbeat
		jz	ConnectLinkBeat
		cmp	Xcvr, XCVR_10TP 	; but only for 10TP
		jne	ConnectLinkBeat
		and	ax, NOT (MEDIA_LBEATENABLE)
ConnectLinkBeat:
		out	dx, ax			; write it back
;
; if configured for 10Base2 we must start the internal transceiver.  if not
; we stop it (just in case the configuration has changed and we haven't cold
; booted).
;
		mov	dx, PortCmdStatus
		mov	ah, CMDH_STARTINTXCVR	; if BNC, start
		cmp	Xcvr, XCVR_10BNC
		je	ConnectXcvr
		mov	ah, CMDH_STOPINTXCVR	; else, stop
ConnectXcvr:
		out	dx, ax			; issue command
;
; now give the transceiver 3ms to stabilize before we enable transmit or
; receive traffic thru it.
;
		mov	cx, Delay3ms
		call	WaitTime
;
; reset the Tx/RxFIFO's
;
		mov	dx, PortCmdStatus
		call	TxReset
		call	RxReset

		mov	cx, 40*3
waitrdy:
		push	cx
		mov	cx, Delay25ms
		call	WaitTime
		pop	cx
		loop	waitrdy

		popa
		ret

SetupConnector	endp


;------ ForceMII --------------------------------------------------------------;
;	
;       Exit:
;       Carry bit set: found MII
;       Carry bit clear: MII test failed
;----------------------------------------------------------------------------;
		public  ForceMII
ForceMII	proc    near

		pusha

		cmp	Xcvr, XCVR_MII
		je	fmii_external_port
;
; Since it is not an external MII, it must be the Cyclone on-board in which
; case we know the PHY addr is 18h and we can go ahead and read the OUI.
;
		mov	MIIPhyAddr, NWAY
		mov	dx, MII_PHY_OUI
		call	ReadMIIPhy
		mov	miiphyoui, ax		; save OUI
		jc	freset_phy
		jmp	fm_fail_hw

fmii_external_port:
;
; Check to see if the MII is there.  No use going any further if it doesn't
; exist.  We only do this for the external MII.
;
		call	FindMIIPhy
		jnz	FoundMii
		jmp	fm_fail_hw

FoundMii:
		mov	cx, 31			; 31 possible combinations
floop_for_phy:
		mov	MIIPhyAddr, cl
		mov	dx, MII_PHY_OUI
		call	ReadMIIPhy
		jc	ffind_mii_phy
		loop	floop_for_phy
		jmp	fm_fail_hw

ffind_mii_phy:
		mov	miiphyoui, ax		; save the OUI
		mov	dx, MII_PHY_MODEL
		call	ReadMIIPhy
		jc	freset_phy
		jmp	fm_fail_hw

freset_phy:
		mov	miiphymodel, ax 	; save the model
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	ff1
		jmp	fm_fail_hw
ff1:
		or	ax, MII_CTL_RESET	; reset the MII
		call	WriteMiiPhy
;
; Wait up to 2 seconds for reset to finish.
;
		mov	ecx, 10
fm_loop1:
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	ff2
		jmp	fm_fail_hw

ff2:
		test	ax, MII_CTL_RESET	; reset done?
		jz	mii_freset_done

		call	Delay200ms

		loop	fm_loop1
		jmp	fm_fail_hw

mii_freset_done:
		cmp	miiphyoui, NATIONAL_OUI ; National's OUI
		jne	force_nway

		cmp	miiphymodel, NATIONAL_MODEL ;
		jne	force_nway

; do the National 840A fix for the switch
		mov	dx, MII_PHY_PCR
		call	ReadMIIPhy
		jc	ff3
		jmp	fm_fail_hw

ff3:
		or	ax, 0020h		; set bit 5 = 1, force
						; disconnect to bypass
		call	WriteMIIPhy
force_nway:
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	ff4
		jmp	fm_fail_hw

ff4:
		mov	cx, ax			; save Control reg. value
		mov	LineSpeed, 10
		and	ax, NOT MII_CTL_100MB	; 10 Mbps
		cmp	miiselect, BASE10_T
		je	force_speed_done

		cmp	miiselect, AUTO_10BASET ; 10 Mbps - Auto_nego
		je	force_speed_done

		mov	LineSpeed, 100
		or	ax, MII_CTL_100MB	; 100 Mbps
		cmp	miiselect, BASE100_TX
		je	force_speed_done

		cmp	miiselect, AUTO_100BASETX   ; 100 Mbps - Auto nego
		je	force_speed_done

		and	ax, not MII_CTL_ENABLE_AUTO ; disable auto negotiation
		and	ax, not MII_CTL_FULL_DUPLEX ; half duplex
		cmp	miiselect, BASE100_T4	; 100 Mbps - T4
		je	fmii_2
		jmp	fm_fail_hw

force_speed_done:
		and	ax, not MII_CTL_ENABLE_AUTO ; disable auto negotiation
		and	ax, not MII_CTL_FULL_DUPLEX ; half duplex
;		test	SWConfig, SW_FULLDUPLEX     ; check SoftwareInfo for
;		jz	fmii_2			    ; duplex info
;
;		or	ax, MII_CTL_FULL_DUPLEX ; full duplex
fmii_2:
		mov	dx, MII_PHY_CONTROL
		call	WriteMiiPhy
;
; workaround for Broadcom T4 bug - need to reset if going from 10 to 100 Mbps
;
		cmp	miiphyoui, BROADCOM_OUI ; check for Broadcom
		jne	ff5

		cmp	miiphymodel, BROADCOM_MODEL ; model = 0
		jne	ff5

		test	cx, 2000h		; if previous speed=100
		jnz	ff5			; don't reset

		cmp	LineSpeed, 100		; prev. speed = 10, check current speed
		jne	ff5

		mov	dx, MII_CTL_RESET	; current speed = 100,
		call	WriteMiiPhy		; need to reset
ff5:
;;; 980209
; check link status

		mov	cx, 25
chk_link_status:
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	chk_lnk2
		jmp	fm_fail_hw

chk_lnk2:
		test	ax, MII_STS_LINK_UP
		jnz	ff6

		call	Delay200ms

		loop	chk_link_status
		jmp	fm_fail_hw
ff6:
;;;
		stc
		jmp	short fm_exit

fm_fail_hw:
		or	ax, 1			; zf = 0
		clc				; cf = 0
		jmp	short fm_exit

fm_fail:
		xor	ax, ax			; zf = 1
		clc				; cf = 0
fm_exit:
		popa
		ret

ForceMII	endp


;------ TryMII --------------------------------------------------------------;
;	
;       Exit:
;       Carry bit set: found MII
;       Carry bit clear: MII test failed
;----------------------------------------------------------------------------;
		public  TryMII
TryMII		proc	near

;;int 03h

		pusha
;		mov	auto_negotiated, 0	    ; clear auto negotiated flag
;		mov	forcemode, 0
		cmp	Xcvr, XCVR_MII
		je	mii_external_port

cyc_auto_con:
		mov	miiphyaddr, NWAY
		mov	dx, MII_PHY_OUI
		call	ReadMIIPhy
		mov	miiphyoui, ax
		jc	reset_phy
		jmp	tm_fail_hw

mii_external_port:
		call	FindMIIPhy
		jnz	tm01
		jmp	tm_fail_hw
;
; Search for the PHY address
;
tm01:
		mov	cx, 31
loop_for_phy:
		mov	miiphyaddr, cl
		mov	dx, MII_PHY_OUI
		call	ReadMIIPhy
		jc	find_mii_phy
		loop	loop_for_phy
		jmp	tm_fail_hw

find_mii_phy:
		mov	miiphyoui, ax
		mov	dx, MII_PHY_MODEL
		call	ReadMIIPhy
		mov	miiphymodel, ax 	; save the model
		jc	reset_phy
		jmp	tm_fail_hw
;
; The MII Phy exists. Reset it.
; DX has the offset of control reg. AX return the value of control reg.
;
reset_phy:
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	tm02
		jmp	tm_fail_hw

tm02:
		or	ax, MII_CTL_RESET
		call	WriteMIIPhy

		mov	cx, 10			; total timeout about 2 sec.
tm_loop1:
		push	cx
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		pop	cx
		jc	tm03
		jmp	tm_fail_hw

tm03:
		test	ax, MII_CTL_RESET	; reset done?
		jz	mii_reset_done		; yes

		call	Delay200ms		; no, delay 200 ms
		loop	tm_loop1
		jmp	tm_fail_hw

mii_reset_done:


			mov	cx,0Fh
  			push	ax
  			push	bx
  			push	cx
  			push	dx
			mov	cx,4

locloop_1167:							;  xref 8A38:F210
				mov	ax,DGroup:DelaySomething.loword				; (8A38:2892=0)
           		mov	dx,DGroup:DelaySomething.hiword				; (8A38:2894=0)
loc_1168:							;  xref 8A38:F20E
				sub	ax,1
				sbb	dx,0

      			mov	bx,ax
      			or	bx,dx
      			jnz	loc_1168				; Jump if not zero
      			loop	locloop_1167				; Loop if cx > 0

      			pop	dx
      			pop	cx
      			pop	bx
      			pop	ax

;;		mov	dx, MII_PHY_CONTROL
;;		call	ReadMIIPhy
;;		jc	tm04
;;		jmp	tm_fail_hw

;;tm04:
;;		mov	cx, ax			; cx <= control reg.


locloop_1169:							;  xref 8A38:F249
    		mov	dx, MII_PHY_STATUS
    		call	ReadMIIPhy					; (659E)
    		jc	short loc_1170				; Jump if carry Set
    		jmp	tm_fail_hw				; (F38B)
loc_1170:							;  xref 8A38:F21C
    		test	ax,20h
    		jnz	short loc_1173				; Jump if not zero
    		push	ax
    		push	bx
    		push	cx
    		push	dx
    		mov	cx,4

locloop_1171:							;  xref 8A38:F243

			mov	ax,DGroup:DelaySomething.loword				; (8A38:2892=0)
       		mov	dx,DGroup:DelaySomething.hiword				; (8A38:2894=0)

loc_1172:							;  xref 8A38:F241

    		sub	ax,1
    		sbb	dx,0
    		mov	bx,ax
    		or	bx,dx
    		jnz	loc_1172				; Jump if not zero
    		loop	locloop_1171				; Loop if cx > 0

    		pop	dx
    		pop	cx
    		pop	bx
    		pop	ax
    		loop	locloop_1169				; Loop if cx > 0

loc_1173:							;  xref 8A38:F227


		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	tm04
		jmp	tm_fail_hw

tm04:
		mov	cx, ax			; cx <= control reg.


;
; now we can read the status and try to figure out what's out there.
;
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm05
		jmp	tm_fail_hw

tm05:
;
; bit 15 = 100BaseT4,
; bit 14 = 100BaseTX (full duplex),
; bit 13 = 100BaseTX (half duplex),
; bit 12 = 10BaseT (full duplex),
; bit 11 = 10BaseT (half duplex)
;
		test	ax, MII_STS_100MB_MASK+MII_STS_10MB_MASK
		jnz	handle_both
		jmp	tm_fail_hw		; sanity check

handle_both:
;
; if MII does not have extended registers, we have no way to tell
; what the link speed is after the completion of auto negotiation.
; (no ANLPAR register, no PAR regiater)
;
		test	ax, MII_STS_EXTENDED
		jnz	tm06
		jmp	no_auto_nego

tm06:
;
; see if it is capable of auto negotiation
;
		test	ax, MII_STS_AUTO	; auto negotiation capable
		jnz	tm07			; yes
		jmp	no_auto_nego

tm07:
;
; it is capable of auto negotiation, see if it has been done already.
; if not, re-initialize autoselect/autonego. otherwise, accept the results.
;
; special hack for National part.  We know we are NWAY capable
; and we are not the Broadcom T4 part which is not NWAY capable
;
		cmp	miiphyoui, NATIONAL_OUI
		jne	enable_auto

		cmp	miiphymodel, NATIONAL_MODEL
		jne	enable_auto

		push	cx
		push	ax
		mov	dx, MII_PHY_PCR
		call	ReadMIIPhy
		jc	force_link_disc
		pop	cx
		pop	ax
		jmp	tm_fail_hw

force_link_disc:
		or	ax, 0020h		; set bit 5 = 1, force
						; disconnect to bypass
		mov	dx, MII_PHY_PCR
		call	WriteMIIPhy
		pop	ax
		pop	cx

enable_auto:
		mov	si, 3			; retry count for 840A fix
		test	cx, MII_CTL_ENABLE_AUTO ; auto nego enabled?
		jz	auto_not_enabled

		test	ax, MII_STS_AUTO_DONE	; auto nego done?
		jz	auto_not_enabled
		jmp	auto_nego_done

auto_not_enabled:
		mov	ax, cx			; AX <= control reg.
		or	ax, MII_CTL_START_AUTO	; restart auto nego
		or	ax, MII_CTL_ENABLE_AUTO ; enable it
		mov	dx, MII_PHY_CONTROL
		call	WriteMIIPhy

		mov	cx, 10			; 2 sec. timeout
tm_loop2:
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm08
		jmp	tm_fail_hw

tm08:
		test	ax, MII_STS_AUTO_DONE	; done?
		jnz	auto_nego_done		; yes

		call	Delay200ms		; no, delay 200 ms
		loop	tm_loop2
;
; pending: if MII_STS_AUTO_DONE never set in status reg. Check to see if it is
; a National 840A in which case do 840A fix else fail out as a recoverable.
;
		cmp	miiphyoui, NATIONAL_OUI
		jne	tm_fail

		cmp	miiphymodel, NATIONAL_MODEL
		jne	tm_fail
;
; 840A workaround
;
		mov	dx, MII_PHY_ANER
		call	ReadMIIPhy
		jc	tm09
		jmp	tm_fail_hw

tm09:
		mov	dx, MII_PHY_ANER
		call	ReadMIIPhy
		jc	tm10
		jmp	tm_fail_hw

tm10:
		test	ax, MII_ANER_MLF
		jz	auto_nego_retry

		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		jc	tm11
		jmp	tm_fail_hw

;
; force to 100Mbps half duplex
;
tm11:
		and	ax, NOT MII_CTL_FULL_DUPLEX
		and	ax, NOT MII_CTL_ENABLE_AUTO
		or	ax, MII_CTL_100MB
		mov	dx, MII_PHY_CONTROL
		call	WriteMIIPhy

		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		jc	tm12
		jmp	tm_fail_hw
tm12:
		mov	cx, 20			; wait up to 4 sec.
tm_mlp:
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm13
		jmp	tm_fail_hw

tm13:
		test	ax, MII_STS_LINK_UP
		jnz	mlp_link_up

		call	Delay200ms
		loop	tm_mlp
		jmp	tm_fail_hw

mlp_link_up:
;		mov	full_duplex, 0		; forced to half duplex
		mov	LineSpeed, 100		; forced to 100 Mbps
;		mov	auto_negotiated, 1	; fake the auto negotiation
		stc
		jmp	tm_exit

;
; retry the auto negotiation here for a certain number of times
;
auto_nego_retry:
		dec	si
		jz	tm_fail

		mov	ax, MII_CTL_RESET
		mov	dx, MII_PHY_CONTROL
		call	WriteMIIPhy

		mov	cx, 10			; wait up to 2 sec for reset
reset_wait:
		push	cx
		mov	dx, MII_PHY_CONTROL
		call	ReadMIIPhy
		pop	cx
		jc	tm14
		jmp	tm_fail_hw

tm14:
		test	ax, MII_CTL_RESET
		jz	mlp_reset_done

		call	Delay200ms		; delay 200 ms
		loop	reset_wait
		jmp	tm_fail_hw		; can't reset, something wrong

mlp_reset_done:
		mov	cx, ax
		jmp	auto_not_enabled
; end 840A workaround
;
; check link status.  Since it is a latch function, read status register again.
;
auto_nego_done:
;		mov	auto_negotiated, 1
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		jc	tm15
		jmp	tm_fail_hw

tm15:
		test	ax, MII_STS_LINK_UP	; do I have link?
		jnz	tm16			; yes
		jmp	tm_fail 		; no, just get out (maybe not plugged in)
;
; read the advertised abilities of link partner as received during auto
; negotiation.
;
tm16:
		mov	dx, MII_PHY_ANLPAR
		call	ReadMIIPhy
		jnc	tm_fail_hw

		mov	phyANLPAR, ax
;
; read the advertised abilities of myself as transmitted to link partner
; during auto negotiation.
;
		mov	dx, MII_PHY_ANAR
		call	ReadMIIPhy
		jnc	tm_fail_hw

		mov	phyANAR, ax
		mov	bx, phyANLPAR		; link partner's abilities
		mov	ax, phyANAR		; my abilities
		test	ax, MII_ANLPAR_100BASET4 ; Can I do 100 T4?
		jz	nws_1			; no

		test	bx, MII_ANLPAR_100BASET4 ; yes, now can my partner?
		jz	nws_1			; no

;		mov	full_duplex, 0		; yes, set to half duplex
		jmp	must_be_100mb

nws_1:
		test	ax, MII_ANLPAR_100BASEX_FD ; Can I do 100 Full duplex?
		jz	nws_2			; no

		test	bx, MII_ANLPAR_100BASEX_FD ; yes, now can my partner?
		jz	nws_2			; no

;		mov	full_duplex, 1		; yes, set to full duplex
		jmp	must_be_100mb

nws_2:
		test	ax, MII_ANLPAR_100BASEX_HD ; Can I do 100 Half duplex?
		jz	nws_3			; no

		test	bx, MII_ANLPAR_100BASEX_HD ; yes, now can my partner?
		jz	nws_3			; no

;		mov	full_duplex, 0		; yes, set to half duplex
		jmp	must_be_100mb

nws_3:
		test	ax, MII_ANLPAR_10BASET_FD ; Can I do 10 Full duplex?
		jz	nws_4			; no

		test	bx, MII_ANLPAR_10BASET_FD ; yes, now can my partner
		jz	nws_4			; no

;		mov	full_duplex, 1		; yes, set to full duplex
		jmp	must_be_10mb

nws_4:
		test	ax, MII_ANLPAR_10BASET_HD ; Can I do 10 Half duplex?
		jz	tm_fail_hw		; no, fail out

		test	bx, MII_ANLPAR_10BASET_HD ; yes, now can my partner?
		jz	nws_5			; no

;		mov	full_duplex, 0		; yes, set to half duplex
		jmp	must_be_10mb
;
; We came here because the link partner didn't advertise anything.  Maybe
; it is a bug.	Check if it is a National 840A.  If it is, then do the fix
; else fail out.
;
nws_5:
		cmp	miiphyoui, NATIONAL_OUI
		jne	tm_fail_hw		; since not National part, fail

		cmp	miiphymodel, NATIONAL_MODEL
		je	nway_patch		; go to NWAY patch for National part
		jmp	tm_fail_hw		; fail, not the correct model
;
; PATCH for National 840A nway chip problem.
; Should read the ANLPAR reg. and ANAR reg. to determine the link used.
; See P010.C, a workaround solution is to read PAR reg. instead.
;
nway_patch:
;		mov	full_duplex, 0		; since link partner not NWAY default to half duplex
		mov	dx, MII_PHY_PAR 	; special National register
		call	ReadMIIPhy
		jc	tm17
		jmp	tm_fail

tm17:
		test	ax, 0040h		; SPEED_10 = bit 6
		jnz	must_be_10mb
;
; *** end of PATCH
;
must_be_100mb:
		mov	LineSpeed, 100
		stc				; return success
		jmp	tm_exit

must_be_10mb:
		mov	LineSpeed, 10
		stc				; return success
		jmp	tm_exit

;
; auto negotiation didn't work.  It might be able to auto-select
;
no_auto_nego:
;		mov	auto_negotiated, 0	; didn't auto negotiate
;
; It might be a Broadcom part that only supports T4
;
		cmp	MIIPhyOui, 03e0h
		je	tm18
		jmp	tm_fail_hw		; just get out

tm18:
		cmp	MIIPhyModel, 0
		je	tm19
		jmp	tm_fail_hw		; just get out and fail h/w

tm19:
;
; we now know we are Broadcom T4, so initialize some variables for the the
; T4 fix here.	It is a good a place as any.
;
		push	ax
		push	cx
		test	cx, MII_CTL_ENABLE_AUTO ; here it is auto-selection
						; not auto-negotiation
		jz	bcm_auto_not_enabled

		test	ax, MII_STS_AUTO_DONE
		jz	bcm_auto_not_enabled
		jmp	bcm_auto_done

bcm_auto_not_enabled:
		mov	ax, cx
		or	ax, MII_CTL_ENABLE_AUTO ; enable auto selection
		and	ax, NOT MII_CTL_FULL_DUPLEX
;		test	SWConfig, SW_FULLDUPLEX
;		jz	tm20

;		or	ax, MII_CTL_FULL_DUPLEX
tm20:
		mov	dx, MII_PHY_CONTROL
		call	WriteMIIPhy

bcm_auto_done:
		pop	cx
		pop	ax

; check link status.  Since it is a latch function, read status register again.

		mov	cx, 25
link_status_loop:
		push	cx
		mov	dx, MII_PHY_STATUS
		call	ReadMIIPhy
		pop	cx
		jc	tm21
		jmp	tm_fail_hw

tm21:
		test	ax, MII_STS_LINK_UP
		jnz	read_ext_reg

		call	Delay200ms

		loop	link_status_loop
		jmp	tm_fail
;
; read address reg. 10h
;
read_ext_reg:
		mov	dx, MII_EXT_REG0
		call	ReadMIIPhy		; read extended reg. 0 to get speed
		jc	tm22
		jmp	tm_fail_hw

tm22:
		test	ax, MII_EXT_SPEED	; speed is (1=100, 0=10)
		jnz	tm23
		jmp	must_be_10mb
tm23:
		jmp	must_be_100mb

tm_fail_hw:
		or	ax, 1				; zf = 0
		clc					; cf = 0
		jmp	short tm_exit

tm_fail:
		xor	ax, ax				; zf = 1
		clc					; cf = 0
tm_exit:
		popa
		ret

TryMII		endp


;------ FindMIIPhy ----------------------------------------------------------;
;        
;       Exit:
;       ZF set: not found
;       ZF clear: found
;----------------------------------------------------------------------------;

                public  FindMIIPhy
FindMIIPhy      proc    near

                pusha
		mov	dx, PortCmdStatus
                SelectWindow    WNO_DIAGNOSTICS
		mov	dx, PortPhyMgmt
;
; drop everything, so we are not driving the data, and run the clock
; through 32 cycles in case the PHY is trying to tell us something. Then
; read the data line, since the PHY's pull-up will read as a 1 if it's
; present.
;
                xor     ax, ax
                out     dx, ax

                mov     cx, 32
fmp_loop:
                call	Delay500ns
                mov     ax, MGMT_PHY_CLOCK
                out     dx, ax
                call	Delay500ns
                xor     ax, ax
                out     dx, ax
                loop    fmp_loop

                in      ax, dx
                test    ax, MGMT_PHY_DATA1

                ;SelectWindow   WNO_OPERATING
                popa
                ret
FindMIIPhy      endp


;------ SendOneBitToMII --------------------------------------------------------;
;        
; send one bit out on MDIO.
;
; On Entry: bit 0 in AX - the bit to be sent.
;----------------------------------------------------------------------------;
                public  SendOneBitToMII
SendOneBitToMII proc    near

;;Sub_59 proc    near


		or	ax,4
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

        call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;		mov	dx,data_578				; (8A38:2898=0)
;;loc_415:							;  xref 8A38:690D
;;		sub	ax,1
;;		sbb	dx,0
;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_415					; Jump if not zero
;;		popa						; Restore all regs

		or	ax,1
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

        call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_416:							;  xref 8A38:6926
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_416					; Jump if not zero
;;		popa						; Restore all regs

		and	ax,0FFFEh
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

        call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_417:							;  xref 8A38:693F
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_417					; Jump if not zero
;;		popa						; Restore all regs


                ret

;;Sub_59 endp

SendOneBitToMII endp


;------ WriteMIIPhy ---------------------------------------------------------;
;
;       Entry:
;       DX = the register offset
;       AX = the data to be written to the register of xcvr
;
;       Exit:
;       All registers are preserved.
;        
;----------------------------------------------------------------------------;
                public  WriteMIIPhy
WriteMIIPhy     proc    near

		pusha						; Save all regs
		push	ax
		push	dx

		mov	dx, PortCmdStatus
        SelectWindow    WNO_DIAGNOSTICS
		mov	dx, PortPhyMgmt

		mov	cx,20h

locloop_353:							;  xref 8A38:6503
		mov	ax,2
		call	SendOneBitToMII					; (68F7)
		loop	locloop_353				; Loop if cx > 0

		xor	ax,ax					; Zero register

		call	SendOneBitToMII					; (68F7)
		mov	ax,2
		call	SendOneBitToMII					; (68F7)
		xor	ax,ax					; Zero register
		call	SendOneBitToMII					; (68F7)
		mov	ax,2
		call	SendOneBitToMII					; (68F7)

        xor bh, bh
    	mov	bl, miiphyaddr				; (8A38:64E0=0)
		mov	cx,5

locloop_354:							;  xref 8A38:6532
		xor	ax,ax					; Zero register
		test	bx,10h
		jz	short loc_355				; Jump if zero
		mov	ax,2

loc_355:							;  xref 8A38:6528
		call	SendOneBitToMII					; (68F7)
		shl	bx,1					; Shift w/zeros fill
		loop	locloop_354				; Loop if cx > 0

		pop	bx
		mov	cx,5

locloop_356:							;  xref 8A38:6548
		xor	ax,ax					; Zero register
		test	bx,10h
		jz	short loc_357				; Jump if zero
		mov	ax,2
loc_357:							;  xref 8A38:653E
		call	SendOneBitToMII					; (68F7)
		shl	bx,1					; Shift w/zeros fill
		loop	locloop_356				; Loop if cx > 0

		mov	ax,2
		call	SendOneBitToMII					; (68F7)
		xor	ax,ax					; Zero register
		call	SendOneBitToMII					; (68F7)
		pop	bx
		mov	cx,10h

locloop_358:							;  xref 8A38:6569
		xor	ax,ax					; Zero register
		test	bx,8000h
		jz	short loc_359				; Jump if zero
		mov	ax,2
loc_359:							;  xref 8A38:655F
		call	SendOneBitToMII					; (68F7)
		shl	bx,1					; Shift w/zeros fill
		loop	locloop_358				; Loop if cx > 0

		mov	ax,1
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

        call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_360:							;  xref 8A38:6581
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_360					; Jump if not zero
;;		popa						; Restore all regs

		xor	ax,ax					; Zero register
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

        call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_361:							;  xref 8A38:6599
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_361					; Jump if not zero
;;		popa						; Restore all regs

		popa						; Restore all regs
		retn



WriteMIIPhy	endp


; *******************************************************************
; *******************************************************************


;------ ReadMIIPhy ----------------------------------------------------------;
;        
;       Entry:
;       DX = the register offset
;
;       Exit:
;       Carry bit set: success
;       Carry bit clear: failed
;	AX = the value of the register in xcvr
;
;----------------------------------------------------------------------------;
                public  ReadMIIPhy
ReadMIIPhy      proc    near

		pusha						; Save all regs
		push	dx

		mov	dx, PortCmdStatus
        SelectWindow    WNO_DIAGNOSTICS
		mov	dx, PortPhyMgmt

		mov	cx,20h

locloop_362:							;  xref 8A38:65B4
		mov	ax,2
		call	sendonebittomii					; (68F7)
		loop	locloop_362				; Loop if cx > 0

		xor	ax,ax					; Zero register
		call	sendonebittomii					; (68F7)
		mov	ax,2
		call	sendonebittomii					; (68F7)
		mov	ax,2
		call	sendonebittomii					; (68F7)
		xor	ax,ax					; Zero register
		call	sendonebittomii					; (68F7)
        xor bh, bh
    	mov	bl, miiphyaddr				; (8A38:64E0=0)
		mov	cx,5

locloop_363:							;  xref 8A38:65E3
		xor	ax,ax					; Zero register
		test	bx,10h
		jz	short loc_364				; Jump if zero
		mov	ax,2
loc_364:							;  xref 8A38:65D9
		call	sendonebittomii					; (68F7)
		shl	bx,1					; Shift w/zeros fill
		loop	locloop_363				; Loop if cx > 0

		pop	bx
		mov	cx,5

locloop_365:							;  xref 8A38:65F9
		xor	ax,ax					; Zero register
		test	bx,10h
		jz	short loc_366				; Jump if zero
		mov	ax,2
loc_366:							;  xref 8A38:65EF
		call	sendonebittomii					; (68F7)
		shl	bx,1					; Shift w/zeros fill
		loop	locloop_365				; Loop if cx > 0

		xor	ax,ax					; Zero register
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;		mov	dx,data_578				; (8A38:2898=0)
;;loc_367:							;  xref 8A38:6610
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_367					; Jump if not zero
;;		popa						; Restore all regs
        
		mov	ax,1
		out	dx,ax					; port 0FFFAh ??I/O Non-standard
    
		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_368:							;  xref 8A38:6629
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_368					; Jump if not zero
;;		popa						; Restore all regs

		xor	ax,ax					; Zero register
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;		mov	dx,data_578				; (8A38:2898=0)
;;loc_369:							;  xref 8A38:6641

;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_369					; Jump if not zero
;;		popa						; Restore all regs

		in	ax,dx					; port 0FFFAh ??I/O Non-standard
		test	ax,2
		jz	short loc_370				; Jump if zero
		clc						; Clear carry flag
		jmp	loc_379					; (66F8)
loc_370:							;  xref 8A38:6648
		mov	ax,1
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_371:							;  xref 8A38:6664
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_371					; Jump if not zero
;;		popa						; Restore all regs

		xor	ax,ax					; Zero register
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_372:							;  xref 8A38:667C
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_372					; Jump if not zero
;;		popa						; Restore all regs
  
    	xor	bx,bx					; Zero register
		mov	cx,10h

locloop_373:							;  xref 8A38:66C0
		shl	bx,1					; Shift w/zeros fill
		in	ax,dx					; port 0FFFAh ??I/O Non-standard
		test	ax,2
		jz	short loc_374				; Jump if zero
		or	bx,1
loc_374:							;  xref 8A38:668A
		mov	ax,1
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_375:							;  xref 8A38:66A5
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_375					; Jump if not zero
;;		popa						; Restore all regs

		xor	ax,ax					; Zero register
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_376:							;  xref 8A38:66BD
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_376					; Jump if not zero
;;		popa						; Restore all regs

		loop	locloop_373				; Loop if cx > 0

		mov	ax,1
		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_377:							;  xref 8A38:66D8
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_377					; Jump if not zero
;;		popa						; Restore all regs

		xor	ax,ax					; Zero register

		out	dx,ax					; port 0FFFAh ??I/O Non-standard

		call	Delay500ns

;;		pusha						; Save all regs
;;		mov	ax,data_577				; (8A38:2896=0)
;;				mov	dx,data_578				; (8A38:2898=0)
;;loc_378:							;  xref 8A38:66F0
;;		sub	ax,1
;;		sbb	dx,0
;;		mov	bx,ax
;;		or	bx,dx
;;		jnz	loc_378					; Jump if not zero
;;		popa						; Restore all regs

		mov	DGroup:tempLoc,bx				; (8A38:64E8=0FFFFh)
		stc						; Set carry flag
loc_379:							;  xref 8A38:664B
		popa						; Restore all regs
        mov ax, DGroup:tempLoc
		retn

ReadMIIPhy	endp


;------ TestMIILink ---------------------------------------------------------;
;        
; Read the "link is up" bit, (this will reset it in case it was latched
; low due to a failure) and then read it again to see if the link is up.
;
;       Exit:
;       Carry set: success
;       Carry clear: failed
;----------------------------------------------------------------------------;

                public  TestMIILink
TestMIILink     proc    near

                pusha

                mov     dx, MII_PHY_STATUS
                call    ReadMIIPhy
                jnc     tml_exit
                
                call    ReadMIIPhy
                jnc     tml_exit
                test    ax, MII_STS_LINK_UP
                jz      tml_exit
                stc
tml_exit:
                popa
                ret

TestMIILink     endp


;------ CalibrateDelay ------------------------------------------------------;
;									     ;
;	This routine computes the number of loop iterations for 5 timer      ;
;	ticks.	From this ComputeDelay can then compute the number of loop   ;
;	iterations to delay a specified number of microseconds.  Note that   ;
;	the delay loop and the compute loop must use the same instructions.  ;
;									     ;
;	Note: since interrupts must be enabled during this operation in      ;
;	order to accumulate timer ticks, we minimize the possible overhead   ;
;	by masking off all other interrupts through the PIC temporarily.     ;
;									     ;
;	Entry:								     ;
;	DS	= DGROUP						     ;
;	cli								     ;
;									     ;
;	Exit:								     ;
;	cli (enables during processing) 				     ;
;									     ;
;	All registers preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

		public	CalibrateDelay
CalibrateDelay	proc	near

		pusha
		push	es
;
; mask off all but the timer interrupt through the PIC
;
		in	al, MASTER_MASK_PORT
		push	ax			; save original mask on stack
		jmp	$+2
		mov	al, NOT 1		; mask off all but timer
		out	MASTER_MASK_PORT, al
;
; enable interrupts... we need to take timer ticks in here
;
		sti
;
; set DI to the current count
;
; to limit our error watch the timer tick and wait until we see it change.
;
; under DOS we use the tick count in the BIOS data area.  under OS/2 we have
; access to a msec counter in the GlobalInfoSeg.
;
		mov	ax, 0
		mov	es, ax

		mov	di, es:[46ch]		;bios_ticks.loword
B1:		cmp	di, es:[46ch]		;bios_ticks.loword
		je	B1
		mov	di, es:[46ch]		;bios_ticks.loword
;
; set CX to zero.  this will be our outer loop count, the number of times we
; have run thru the calibration loop.
;
		xor	cx, cx
;
; now do 10000 iterations of our calibration loop.  we want a large enough count
; that the overhead of fetching the system time cause a significant error in
; our calculations.  on a 486DX2/66 this loop takes about 1ms so its unlikely
; to take too long on even the slowest computer we run on.
;
		public	cal_loop
cal_loop:
		inc	cx			; increment our outer loop count

		mov	ax, 10000		; DX:AX is our loop count
		xor	dx, dx

		align	16
B2:		sub	ax, 1
		sbb	dx, 0
		mov	bx, ax
		or	bx, dx
		jnz	B2
;
; if we wait for at least 5 ticks to go by our measurement error will be below
; 20% which is probably good enough
;
; check the system time to see if at least 5 ticks or 1/4 second have gone by.
; if not, run through the calibration loop again.
;
		mov	ax, es:[46ch]		;bios_ticks.loword
		sub	ax, di
		cmp	ax, 5
		jb	cal_loop
;
; compute iterations per 50ms.
;
; under DOS, 5 ticks at 18.20651 MHz = approx 275,000us. or 275ms.  so ticks
; per 50ms is:
;
;   cx * 10,000     cx * 10,000     cx * 20,000
;   -----------  =  -----------  =  -----------
;     275/50		5.5		11
;
; the result will likely exceed a single word in size, so we do long division.
; say the numerator is H:L, both letters being digits base 64k
;
;	Dh :  Dl
;    ------------
; 11 )	H  :  L
;	Rh :  L
;
		mov	ax, 20000
		mul	cx			; DX:AX = H:L

		mov	cx, 11

		mov	bx, ax			; save L

		mov	ax, dx
		xor	dx, dx			; 0:H

		div	cx			; 0:H / 11
		mov	Calibration.hiword, ax

		mov	ax, bx			; Rh:L

		div	cx			; Rh:L / 11
		mov	Calibration.loword, ax
;
; disable interrupts again
;
		cli
;
; enable interrupts through the PIC again
;
		pop	ax			; original PIC mask
		out	MASTER_MASK_PORT, al	; restore it

		pop	es
		popa
		ret

CalibrateDelay	endp


;------ ComputeDelay --------------------------------------------------------;
;									     ;
;	This routine computes a value to delay a specified number of	     ;
;	microseconds on this machine.  This count can then be passed to      ;
;	the DelayN routine to delay for that amount of time.		     ;
;									     ;
;	CalibateDelay has already been used to compute the number of	     ;
;	iterations of our delay loop in 50ms, so the calculations here are   ;
;	straight-forward.  See CalibrateDelay for details.		     ;
;									     ;
;	Entry:								     ;
;	CX	= number of microseconds to compute for 		     ;
;									     ;
;	Exit:								     ;
;	DX:AX	= loop count						     ;
;									     ;
;	Destroys BX, CX, SI, DI.  All other registers are preserved.	     ;
;									     ;
;----------------------------------------------------------------------------;

		public	ComputeDelay
ComputeDelay	proc	near
;
; Calibration contains the number of loop iterations for 50ms.	So the number
; of iterations for cx usec is:
;
;   Calibration * cx
;   ----------------
;	 50,000
;
; again the result may be three words in size after the multiply, so we do
; the multiplication and division long form as above.
;
		mov	ax, Calibration.loword
		mul	cx
		mov	si, ax			; SI=L
		mov	di, dx			; DI=M

		mov	ax, Calibration.hiword
		mul	cx
		add	ax, di			; AX=M
		adc	dx, 0			; DX=H, finished multiply

		mov	di, ax			; DI=M

		mov	ax, dx
		xor	dx, dx			; 0:H

		mov	bx, 50000		; 50ms=50000us
		div	bx			; assume Dh=0, ignore it

		mov	ax, di			; Rh:M

		div	bx			; Rh:M / usec
		mov	di, ax			; DI=Dm

		mov	ax, si			; Rm:L

		div	bx			; Rm:L / usec
		mov	dx, di			; DX:AX = Dm:Dl
;
; make sure its at least one
;
		mov	bx, ax
		or	bx, dx
		jnz	F1
		inc	ax
F1:
		ret
ComputeDelay	endp

public	Delay500ns
Delay500ns	proc	 near

		push	ax
		push	bx
		push	dx
		mov	ax, DelayOneUsec.loword
		mov	dx, DelayOneUsec.hiword
		shr	ax, 1			; divide 1 Usec in half
		shr	dx, 1
		jnc	F2
		or	ax, 8000h		; move low order bit of dx into ax
F2:
		or	ax, dx			;980429
		jnz	F3			;safety check in case of 0
		mov	ax, 1
F3:
		sub	ax, 1
		sbb	dx, 0
		mov	bx, ax
		or	bx, dx
		jnz	F3
		pop	dx
		pop	bx
		pop	ax
		ret

Delay500ns	endp


Delay200ms	proc	near

		push	cx
		mov	cx, Delay25ms
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		call	WaitTime
		pop	cx
		ret

Delay200ms	endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\pxe_stru.inc ===
;
NUM_MCADDRS    	Equ	8		; max number of multicast addresses.
MAX_DATABLK    	Equ	8		; max number of data blocks supported 
					;	in a descriptor.
MAX_IMMED_LEN	Equ	64		; max immediate data buffer length
MAX_TX_DATABLK	Equ	MAX_DATABLK	; max number of data blocks supported 
					;	in a Tx descriptor.
MAX_TD_DATABLK	Equ	MAX_DATABLK	; max number of TransferData blocks
		
APIMaxFunc	EQU	0011h

ADDR_LEN	EQU	16
ETH_ADDR_LEN	EQU	6
MAXNUM_MCADDR	EQU	8

;
; protocol values in transmit buffer
;
P_UNKNOWN	EQU	0		;; no media header
P_IP	 	EQU	1		;; IP type
P_ARP		EQU	2		;; ARP type
P_RARP		EQU	3		;; RARP type

TYPE_IP	 	EQU	0800h		;; IP type
TYPE_ARP	EQU	0806h		;; ARP type
TYPE_RARP	EQU	8035h		;; RARP type
;
; xmitflag values in transmit buffer
;
PKT_DESTADDR	EQU 0	;; destination address given 
PKT_BROADCAST	EQU 1h	;; use broadcast address 
PKT_MULTICAST	EQU 2h	;; multicast addr given

;; Hardware type values
ETHER_TYPE 		EQU 1
EXP_ETHER_TYPE	EQU 2
IEEE_TYPE  	EQU 6
ARCNET_TYPE   	EQU 7


Eth_MCastBuf	Struc
MCastAddrCount	DW	?
MCastAddr	DB MAXNUM_MCADDR * ETH_ADDR_LEN dup (0)
Eth_MCastBuf	Ends

MC_MCastBuf		Struc
MC_MCastAddrCount	DW	?
MC_MCastAddr  		DB MAXNUM_MCADDR * ADDR_LEN dup (0)
MC_MCastBuf		Ends

NIC_StartUp	Struc
S_Status	DW	?
S_BusType	DB	?
S_AddrType	DB	?
S_DataSeg	DW	?
S_DataSegAddr	DD	?
S_DataSegSize	DW	?
S_CodeSegSize	DW	?
S_BusDevFunc	DW	?	;; PCI Dev_ID
S_PCI_ds_off	dw	?	;; Far pointer to PCI data structure
S_PCI_ds_seg	dw	?
S_PnP_csn	dw	?	; Card select number.-1 for non-PnP BBS device
S_PnP_eh_off	dw	?	; Far pointer to PnP expansion header
S_PnP_eh_seg	dw	?
NIC_StartUp	Ends

NIC_CleanUp	Struc
CL_Status	DW	?
NIC_CleanUp	Ends

NIC_Initialize	Struc
I_Status	DW	?
I_Prot_ini	DD	?
I_RcvInt	DD	?
I_GenInt	DD	?
NIC_Initialize  Ends

NIC_Reset	Struc
R_Status	DW	?
R_MCBuf		MC_MCastBuf <>
NIC_Reset	Ends

NIC_ShutDown	Struc
SD_Status	DW	?
NIC_ShutDown	Ends

NIC_Open	Struc
O_Status	DW	?
O_OpenFlg	DW	?
O_PktFilter	DW	?
O_MCBuf		MC_MCastBuf <>
NIC_Open	Ends

NIC_Close	Struc
C_Status	DW	?
NIC_Close	Ends

X_DataBlock	Struc
X_TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
X_TxRsvdByte	DB	?	; Reservered, must be zero.
X_TxDataLen	DW	?	; Data block length in bytes.
X_TxDataPtr	DD	?	; Far pointer to data block.
X_DataBlock Ends

NIC_TBD		Struc
X_Length	DW	?
X_BufOff	DW	?
X_BufSeg	DW	?
X_DataBlkCount	DW	?		; will always be zero for base code
X_DataBlk	DB	MAX_DATABLK * SIZE X_DataBlock dup (0)	
NIC_TBD		Ends

NIC_Transmit		Struc
T_Status		DW	?
T_Protocol		DB	?
T_XmitFlag		DB	?
T_DestAddrOffset 	DW	?	; 16-bit segment & offset of the
T_DestAddrSegment 	DW	?	; destination media address 
T_TBDOffset		DW	?	; 16-bit segment & offset 
T_TBDSegment		DW	?	; transmit buffer descriptor 
T_Reserved		DD	2 dup(0)	; for future use	
NIC_Transmit Ends

NIC_SetMCastAddr	Struc
SM_Status		DW	?
SM_MCBuf		MC_MCastBuf <>
NIC_SetMCastAddr	Ends

NIC_SetStationAddr	Struc
SS_Status		DW	?
SS_StationAddr		DB	ADDR_LEN dup (0)
NIC_SetStationAddr	Ends

NIC_SetPacketFilter	Struc
SP_Status		DW	?
;;SP_NewFilter		DW  ?
SP_NewFilter		DB  ?
;;SP_MCBuf		MC_MCastBuf <>
NIC_SetPacketFilter	Ends

NIC_GetInfo	Struc
GI_Status		DW	?
GI_BaseIo		DW	?
GI_IntNumber		DW	?
GI_MTU			DW	?
GI_HwType		DW	?
GI_HwAddrLen		DW	?
GI_CurrentNodeAddress	DB ADDR_LEN dup (0)
GI_PermNodeAddress	DB ADDR_LEN dup (0)
GI_ROMAddress		DW 	?
GI_RxBufCt		DW	?
GI_TxBufCt		DW	?
NIC_GetInfo	Ends

NIC_GetNICType_pci 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
Vendor_ID	DW	?	; /* OUT:  */
Dev_ID		DW	?	;  /* OUT:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */ 
Rev		DB	?	;  /* OUT: Revision number */ 
BusDevFunc	DW	?	; /* OUT: Bus, Device & Function numbers */
NIC_GetNICType_pci 	Ends

NIC_GetNICType_pnp 	Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
EISA_Dev_ID	DD	?	; /* Out:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */
CardSelNum	DW	?	; /* OUT: Card Selector Number */
Res		DB	0	;
NIC_GetNICType_pnp 	Ends

NIC_GetStatistics	Struc
GS_Status		DW	?
GS_XmtGoodFrames	dd    ?
GS_RcvGoodFrames	dd    ?
GS_RcvCRCErrors		dd    ?
GS_RcvResourceErrors	dd    ?
NIC_GetStatistics	Ends

NIC_ClearStatistics	Struc
CS_Status		DW	?
NIC_ClearStatistics	Ends

NIC_InitDiags	Struc
ID_Status	DW	?
NIC_InitDiags   Ends

NIC_ForceInterrupt	Struc
FI_Status		DW	?
NIC_ForceInterrupt	Ends

NIC_GetMCastAddr	Struc
GM_Status		DW	?
GM_InetAddr		DD	?
GM_HwAddr		DB	ADDR_LEN dup (0)
NIC_GetMCastAddr	Ends

;NIC_API_Entry	Struc
;Signature 	DB	'PXENV+'	;; not null terminated
;Version		DW	0100h		;; 1.0
;StrucLength	DB	0		;; length of this structure
;CheckSum	DB	0		;; fill in later
;rm_entry_off	DW	0		;; real mode driver entry offset
;rm_entry_seg	DW	0		;; real mode driver entry segment
;pm_entry_off	DW	0		;; protected mode driver entry offset
;pm_entry_seg	DW	0		;; protected mode driver entry segment
;NIC_API_Entry	Ends

s_PXENV_ENTRY	Struc
signature	db	6 dup(?)	; 'PXENV+'
ver             dw      ?               ; MSB=major, LSB=minor
bytes		db	?		; sizeof s_pxenv_entry
checksum	db	?		; 8-bit checksum of structure,
					; including this byte shoube be zero.
rm_entry_off	dw	?		; 16-bit real-mode segment & offset.
rm_entry_seg	dw	?
pm_entry_off	dw	?		; 16-bit protected mode 32-bit physical
pm_entry_base	dd	?		; address and 16-bit offset.
stack_sel	dw	?		; PROM stack segment.  Will be set
stack_size	dw	?		; to 0 when removed from memory.
base_cs_sel	dw	?		; Base code segment.  Will be set
base_cs_size	dw	?		; to 0 when removed from memory.
base_ds_sel	dw	?		; Base data segment.  Will be set
base_ds_size	dw	?		; to 0 when removed from memory.
mlid_ds_sel	dw	?		; MLID data segment.
mlid_ds_size	dw	?
mlid_cs_sel	dw	?		; MLID code segment.
mlid_cs_size	dw	?
s_PXENV_ENTRY	Ends

;; Ethernet II protocol header
EtherHeader	Struc
E_DestAddr	DB 6 dup (0)	;; destination ethernet addr
E_SrcAddr	DB 6 dup (0)	;; destination ethernet addr
E_Type		DW  ?	;; protocol type
EtherHeader	Ends

ETHER_HEADER_LEN	Equ	SIZE EtherHeader

; 
; * Data structures for TransmitChain (Tx), TransferData (TD)
; 
TxDataBlock	Struc
TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TxRsvdByte	DB	?	; Reservered, must be zero.
TxDataLen	DW	?	; Data block length in bytes.
TxDataPtr	DD	?	; Far pointer to data block.
TxDataBlock	Ends

; 
; * TransmitChain descriptor structure definition
; 
TxBufDesc	Struc
TxImmedLen	DW	?	; Byte count of immediate data, max=64
TxImmedPtr	DD	?	; Virtual address of Immediate data
TxDataCount	DW	?	; Number of Data Blocks (max = 8)
TxDataBlk	DB	size TxDataBlock * MAX_TX_DATABLK dup(0)
TxBufDesc	Ends

TxBufDescrSize	Equ	Size TxImmedLen + Size TxImmedPtr + Size TxDataCount

; 
; * TransferData data block description
; 
TDDataBlock	Struc
TDPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TDRsvdByte	DB	?	; Reservered, must be zero.
TDDataLen	DW	?	; Data block length in bytes.
TDDataPtr	DD	?	; Far pointer to data block.
TDDataBlock	Ends

; 
; * TransferData descriptor structure
; 
TDBufDesc	Struc
TDDataCount	DW	?	; No of Data Blocks (max 8 for V1.01).
TDDataBlk	DB	size TDDataBlock*MAX_TD_DATABLK dup(0)
TDBufDesc	Ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\spdosegs.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/SPDOSEGS.INV   1.5   19 Sep 1997 21:39:18   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: segment declaration and ordering for NDIS driver
;


;-----------------------------------------------------------------------
;
; Functional Description
;
;   This file defines the segments used by a MAC driver and the order
;   in which they are loaded. The groups DGROUP (for data) and CGROUP
;   (for code) are also defined, as are macros to open and close
;   segments (which also set up the default segment assumptions).
;
;-----------------------------------------------------------------------

;=======================================================================
;** Segment Definitions - order counts!
;
; DOS Order:
;      CGROUP, DGROUP
;         DevHeaderSeg
;         _TEXT
;         _DATA 
;         CONST
;         _BSS
;   ; Code and data will be cut off here.	;; AVL - not any more
;         ICODE
;         IDATA
;
; AVL - NEW Order:
;   CGROUP
;         DevHeaderSeg
;         _TEXT
;		  ICODE		;; DOS driver specific init routines, not needed for ROM
;	 DGROUP
;         _DATA 
;         CONST
;         _BSS
;         IDATA		;; just to mark the upper boundary.
;
;========================================================================


;==========================================================================
; DOS segment definitions and ordering.
;==========================================================================
Ifdef DRV
DevHeaderSeg   segment para public USE16 'CODE'
DevHeaderSeg   ends
Endif	;; DRV
;--------------------------------------------------------------------------
; Resident Code segment - code that is used after init time
; (unfortunately, this includes code to bind another driver, and
; initializations that take place at bind time) should be placed in this
; segment.
;--------------------------------------------------------------------------
_TEXT       segment para public USE16 'CODE'
_TEXT       ends

Ifdef DRV
ICODE       segment para public USE16 'INIT'
ICODE       ends
Endif	;; DRV
;--------------------------------------------------------------------------
; Resident Data segment - things put here will remain in memory after
; init time. At the present time, this is in low memory, so data that is
; not used after init time should NOT be put in this segment.
;--------------------------------------------------------------------------
_DATA       segment para public USE16 'DATA'
_DATA       ends

Ifdef DRV
_BSS       segment para public USE16 'DATA'
_BSS       ends
IDATA       segment para public USE16 'DATA'
IDATA       ends
Else
_BSS       segment para public USE16 'BSS'
_BSS       ends
Endif	;; DRV
;--------------------------------------------------------------------------
; Make sure the segment order defined in this file is respected.
;--------------------------------------------------------------------------
.SEQ               


;--------------------------------------------------------------------------
; DOS Group is all one 64K segment, CS=SS=DS, use equate for DGROUP.
;--------------------------------------------------------------------------

;DGROUP      equ     CGROUP
;CGROUP      group   DevHeaderSeg, _TEXT, _DATA, CONST, _BSS, ICODE, IDATA

Ifdef DRV
CGROUP      group   DevHeaderSeg, _TEXT, ICODE
DGROUP      group   _DATA, _BSS, IDATA
ELSE
CGROUP      group   _TEXT
DGROUP      group   _DATA, _BSS
Endif	;; DRV
;--------------------------------------------------------------------------
; Group is 64K data, 64K code, CS!=SS=DS, actual group for Code.
;--------------------------------------------------------------------------

;--------------------------------------------------------------------------
; Assume statement here takes care of for any source, same for OS2 and DOS.
;--------------------------------------------------------------------------
    Assume   CS:CGROUP, DS:DGROUP, ES:NOTHING, SS:NOTHING


; EOF - $Workfile:   spdosegs.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\undi_equ.inc ===
;
;--- Miscellaneous Equates
;
CR		equ	0Dh           ;- Carriage Return
LF		equ	0Ah           ;- Line Feed
FALSE		equ	0
TRUE		equ	1
;
;--- Ethernet Frame Sizes
;
ETHERNET_ADDRESS_LENGTH		equ	6
ETHERNET_HEADER_SIZE		equ	14
MINIMUM_ETHERNET_PACKET_SIZE	equ	60
;MAXIMUM_ETHERNET_PACKET_SIZE	equ	1514
MAXIMUM_ETHERNET_PACKET_SIZE	equ	1500 ;; just data, not media header

MAX_PACKET         Equ       1514      ; Maximum allowable packet size.
MIN_PACKET         Equ       60        ; Minimum allowable packet size.
; 
;--- Packet filter bit definitions
; 
FLTR_DIRECTED                Equ       01H
FLTR_MLTCST                  Equ       01H
FLTR_BRDCST                  Equ       02H
FLTR_PRMSCS                  Equ       04H
FLTR_SRC_RTG                 Equ       08H
;
;--- Processor Type Equates
;
EIGHT_BIT          equ       0001H
SIXTEEN_BIT        equ       0002H
PROC_TYPE_MASK     equ       0030H

PROC_8086          equ       0000H OR EIGHT_BIT
PROC_80286         equ       0010H OR SIXTEEN_BIT
PROC_80386         equ       0020H
PROC_80486         equ       0040H
;
;--- Result codes returned in AX by a PXE API service.
;
PXENV_EXIT_SUCCESS		equ	0
PXENV_EXIT_FAILURE		equ	1
PXENV_EXIT_CHAIN		equ	0FFFFh	; used internally
;
;--- Status codes returned in the status word of PXE API parameter structures.
;
PXENV_STATUS_SUCCESS		equ	0
PXENV_STATUS_FAILURE		equ	1	;general failure
PXENV_STATUS_BAD_FUNC		equ	2	;invalid function number
PXENV_STATUS_UNSUPPORTED	equ	3	;not yet supported
PXENV_STATUS_1A_HOOKED		equ	4	;Int 1AH cannot be unhooked

; Driver errors (60 to 0x6F)
; These errors are for UNDI compatible NIC drivers.
PXENV_STATUS_UNDI_MEDIATEST_FAILED 		equ	61h
PXENV_STATUS_UNDI_CANNOT_INIT_NIC_FOR_MCAST	equ	62h
;
;
EISA_ADAPTER             equ    1
PCI_ADAPTER              equ    2
PnP_ADAPTER              equ    3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\moreseg.inc ===
;----------------------------------------------------------------------
;
; File Name:	   DRVSEG.INC
;
; Function:	   This module contains all the segment definitions
;		   to be used throughout the source code.
;
; History:
;
; 910201 0.0 GK	adapted from MSRPL Kit
;----------------------------------------------------------------------
include		drvseg.inc

CGroup		group	_TEXT, PacketBufferSeg
DGroup		equ	<CGroup>

		assume	cs:CGroup,ds:DGroup,es:DGroup,SS:DGroup


;----------------------------------------------------------------------
;			 segment ORDER DECLARATIONS
;
; Description: This section declares all the segments in their proper
;	       order.  After these declarations, all code and data
;	       segments may use the generic segment macros defined in
;	       the next section to delimit themselves.
;
;	       The segment order will be different based on whether
;	       this is a DOS driver or not.  If it is, then the dis-
;	       cardable segments go last.  If it isn't, then we will
;	       split up the code and data parts.
;
;	       The segments that are defined for this driver are:
;	     - DATA:	 contains all the permanent data.
;	     - CODE:	 contains all the permanent code.
;----------------------------------------------------------------------

;Code		segment word public 'CODE'
;Code		ends

PacketBufferSeg    segment para public 'BUF'
PacketBufferSeg    ends

;start_code	macro
;Code		segment
;		assume cs:CGroup,DS:DGroup,es:DGroup,ss:DGroup
;		endm
;
;end_code	macro
;Code		ends
;		endm

start_buffer	macro
PacketBufferSeg segment align
		endm

end_buffer	macro
PacketBufferSeg ends
		endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\eeprom.asm ===
;-----------------------------------------------------------------------------
; EEPROM Interface Equates

;EE_SK           equ     00000001B       ;EEPROM shift clock (1 = high, 0 = low)
;EE_CS           equ     00000010B       ;EEPROM chip select (1 = high, 0 = low)
EE_CS           equ     00000001B       ;EEPROM chip select (1 = high, 0 = low)
EE_SK           equ     00000010B       ;EEPROM shift clock (1 = high, 0 = low)
EE_DI           equ     00000100B       ;EEPROM data in
					; (set to 1 for writing data to EEPROM)
EE_DO           equ     00001000B       ;EEPROM data out
EE_tick         equ     64

EEPROM_read_opcode      equ     110B
EEPROM_write_opcode     equ     101B
EEPROM_erase_opcode     equ     111B
EEPROM_EWEN_opcode      equ     10011B          ;Erase/write enable
EEPROM_EWDS_opcode      equ     10000B          ;Erase/write disable

i8254Cmd                Equ     43h
i8254Ch0                Equ     40h

public read_eeprom
public write_eeprom

Code		segment para public USE16 'CODE'
;-----------------------------------------------------------------------------
;
;  Reads the contents of the specified EEPROM register from the specified
;  base I/O address.
;
;  Entry   - AX  EEPROM location
;	     DX  eeprom control reg in PLX chip
;
;  Returns - AX  EEPROM location contents
;
;  NOTE: Must preserve DI!
;-----------------------------------------------------------------------------
read_eeprom	proc	near

	push	di
	push	bx
	push	cx

	mov	bx, ax

	;---------------------------------------------------------------------
	; Select the EEPROM.  Mask off the ASIC and 586 reset bits and set
	; the ee_cs bit in the EEPROM control register.
	;---------------------------------------------------------------------
	in	al, dx
	and	al, 11110010b
	or	al, EE_CS
	out	dx, al

	;---------------------------------------------------------------------
	; Write out read opcode and EEPROM location.
	;---------------------------------------------------------------------
	mov	ax, EEPROM_read_opcode		;Set AX to READ opcode and
	mov	cx, 3				;Send it to the EEPROM circuit
	call	shift_bits_out

	mov	ax, bx				;Tell EEPROM which register is
	mov	cx, 6				; to be read.  6 bit address.
	call	shift_bits_out

	call	shift_bits_in			;AX gets EEPROM register
						;contents

	call	eeprom_clean_up			;Leave EEPROM in known state.

	pop	cx
	pop	bx
	pop	di
	ret

read_eeprom	endp

;-----------------------------------------------------------------------------
;  Writes the specified value to the specified EEPROM register at the
;  specified base I/O address.
;
;  Entry  - AX  EEPROM location to write.
;           BX  Value to write
;	    DX  eeprom control reg in PLX chip
;
;  Return - AX = 0 if no error
;           AX = Pointer to Error message
;
;-----------------------------------------------------------------------------
write_eeprom    proc	near

        push    bx
        mov     bx, ax

        in      al, dx                          ;Select EEPROM
        and     al, 11110010b
        or      al, EE_CS
        out     dx, al

        ;---------------------------------------------------------------------
        ; Send Erase/write enable opcode to the EEPROM.
        ;---------------------------------------------------------------------
        mov     ax, EEPROM_EWEN_opcode          ;Send erase/write enable
        mov     cx, 5                           ; command to the EEPROM.
        call    shift_bits_out

        mov     cx, 4                           ;Send 4 don't cares as
        call    shift_bits_out                  ; required by the eeprom

        call    stand_by

        ;---------------------------------------------------------------------
        ; Send the erase opcode to the EEPROM and wait for the command to
        ; complete.
        ;---------------------------------------------------------------------
        mov     ax, EEPROM_erase_opcode         ;Send Erase command to the
        mov     cx, 3                           ; EEPROM.
        call    shift_bits_out

        mov     ax, bx                          ;Send EEPROM location the the
        mov     cx, 6                           ; EEPROM.  6 bit address.
        call    shift_bits_out

        call    wait_eeprom_cmd_done            ;wait for end-of-operation
        or      ah, ah                          ; Error?
        jnz     write_Fault_pop                 ; Yes

        call    stand_by

        ;---------------------------------------------------------------------
        ; send the write opcode, location to write, and data to write to the
        ; eeprom.  wait for the write to complete.
        ;---------------------------------------------------------------------
        mov     ax, EEPROM_write_opcode         ;Send write command to the
        mov     cx, 3                           ; EEPROM.
        call    shift_bits_out

        mov     ax, bx                          ;Send the EEPROM location to
        mov     cx, 6                           ; the EEPROM.  5 bit address.
        call    shift_bits_out

        pop     ax                              ;Send data to write to the
        mov     cx, 16                          ; EEPROM.  16 bits.
        call    shift_bits_out

        call    wait_eeprom_cmd_done            ;Await end-of-command
        or      ah,ah                           ;Error?
        jnz     write_Fault                     ;Yes

        call    stand_by

        ;---------------------------------------------------------------------
        ; Send the erase write disable command to the EEPROM.
        ;---------------------------------------------------------------------
        mov     ax, EEPROM_EWDS_opcode          ;Disable the Erase/write
        mov     cx, 5                           ; command previously sent to
        call    shift_bits_out                  ; EEPROM.

        mov     cx, 4                           ;Send 4 don't cares as
        call    shift_bits_out                  ; required by the eeprom

        call    eeprom_clean_up

        mov     ax, 1

write_eeprom_exit:

        ret

write_Fault_pop:

        add     sp, 2                           ;Get rid of data on stack

write_Fault:

        mov     ax, 0
        jmp     write_eeprom_exit

write_eeprom    endp


;-----------------------------------------------------------------------------
;  wait_eeprom_cmd_done
;
;       Wait for ee_do to go high, indicating end-of-write or end-of-erase
;       operation.
;
;       Input:
;               none
;
;       Output:
;               AX  = 0 : No Error
;               AX != 0 : Time out error
;
; The EEPROM spec calls for a 10 millisecond max time for DO to go high
; indicating an end of operation.  This loop uses a 54.7 millisecond timeout.
;-----------------------------------------------------------------------------
wait_eeprom_cmd_done    proc    near

        push    bx
        push    cx

        call    stand_by

        call    ReadTickCounter
        mov     di, ax

ee_do_wait_loop:
        call    ReadTickCounter
        neg     ax
        add     ax, di

        cmp     ax, 7000h                       ; wait 10ms before we even
        jb      ee_do_wait_loop                 ;  start testing

        push    ax                              ; save counter difference
        in      al, dx                          ;Get EEPROM control register
        test    al, EE_DO                       ;ee_do high?
        pop     ax                              ; restore counter difference.

        jnz     ee_do_found                     ; If EE_DO high, we're done here!

        cmp     ax, 0ff00h                      ; 54.7 Millisecond time out

        jb      ee_do_wait_loop                 ; if B then no timeout yet.

        mov     ah, -1                          ; indicate timout.
        jmp     short wait_eeprom_cmd_done_exit

ee_do_found:

        xor     ah, ah                          ;"clean" status (no timeout)

wait_eeprom_cmd_done_exit:

        pop     cx
        pop     bx
        ret

wait_eeprom_cmd_done    endp


;-----------------------------------------------------------------------------
;  shift_bits_out
;
;	This subroutine shift_bits bits out to the Hyundai EEPROM.
;
;	Input:
;		AX = data to be shifted
;		CX = # of bits to be shifted
;
;	Output:
;		none
;
;-----------------------------------------------------------------------------
shift_bits_out	proc	near

	push	bx

	;---------------------------------------------------------------------
	; Data bits are right justified in the AX register.  Move the data
	; into BX and left justify it.  This will cause addresses to to
	; be sent to the EEPROM high order bit first.
	;---------------------------------------------------------------------
	mov	bx, ax
	mov	ch, 16
	sub	ch, cl
	xchg	cl, ch
	shl	bx, cl
	xchg	cl, ch
	xor	ch, ch

	;---------------------------------------------------------------------
	; Get the EEPROM control register into AL.  Mask of the ASIC asn 586
	; reset bits.
	;---------------------------------------------------------------------
	in	al, dx
	AND	AL, 11110011B

	;---------------------------------------------------------------------
	; Set or clear DI bit in EEPROM control register based on value of
	; data in BX.
	;---------------------------------------------------------------------
out_shift_loop:

	and	al, not EE_DI			;Assume data bit will be zero

	rcl	bx, 1				;Is the data bit a one?
	jnc	out_with_it			;No

	or	al, EE_DI      			;Yes

out_with_it:

	out	dx, al				;Output a 0 or 1 on data pin

	;---------------------------------------------------------------------
	; Set up time for data is .4 Microseconds.  So to be safe (incase of
	; this software is run on a cray), call delay.
	;---------------------------------------------------------------------
	mov	di, 1
	call	eeprom_delay

	;---------------------------------------------------------------------
	; clock the data into the EEPROM.
	;---------------------------------------------------------------------
	call	raise_eeprom_clock
	call	lower_eeprom_clock
	loop	out_shift_loop			;Send next bit

	AND	AL, NOT EE_DI			;Force DI = 0
	OUT	DX, AL				;Output DI

	pop	bx

	ret

shift_bits_out	endp

;-----------------------------------------------------------------------------
;
;  shift_bits_in
;
;	This subroutine shift_bits bits in from the Hyundai EEPROM.
;
;	Input:
;		none
;
;	Output:
;		AX = register contents
;
;-----------------------------------------------------------------------------
shift_bits_in	proc	near

	push	bx
	push	cx

	;---------------------------------------------------------------------
	; BX will receive the 16 bits read from the EEPROM.  Data is valid in
	; data out bit (DO) when clock is high.  There for, this procedure
	; raises clock and waits a minimum amount of time.  DO is read, and
	; clock is lowered.
	;---------------------------------------------------------------------
	in	al, dx				;Init AL to eeprom control
	AND	AL, 11110011B			; register.

	xor	bx, bx				;Init holding register
	mov	cx, 16				;We'll shift in 16 bits

in_shift_loop:

	shl	bx, 1				;Adjust holding register for
						; next bit

	call	raise_eeprom_clock

	in	al, dx
	AND	AL, 11111011B

	test	al, EE_DO			;Was the data bit a one?
	jz	in_eeprom_delay			;No

	or	bx, 1				;Yes, reflect data bit state
						; in holding register.

in_eeprom_delay:

	call	lower_eeprom_clock
	loop	in_shift_loop			;CONTINUE

	mov	ax, bx				;AX = data

	pop	cx
	pop	bx
	ret

shift_bits_in	endp

;-----------------------------------------------------------------------------
raise_eeprom_clock	proc	near

	or	al, EE_SK    			;clock the bit out by raising
	jmp	short eeprom_clock_common

raise_eeprom_clock	endp

;-----------------------------------------------------------------------------
lower_eeprom_clock	proc	near

	and	al, not EE_SK			;lower ee_sk

eeprom_clock_common:

	out	dx, al
	mov	di, EE_tick
	call	eeprom_delay			;waste time

	ret

lower_eeprom_clock	endp

;-----------------------------------------------------------------------------
;
; lower EEPROM chip select and di.
; clock EEPROM twice and leave clock low.
;
eeprom_clean_up	proc	near

	push	ax

	in	al, dx
	AND	AL, 11111111B
	and	al, not (EE_CS or EE_DI)
	out	dx, al

	call	raise_eeprom_clock
	call	lower_eeprom_clock

	pop	ax
	ret

eeprom_clean_up	endp

;-----------------------------------------------------------------------------
;
; DI has number of 838 Nanoseconds clock counts
;
;-----------------------------------------------------------------------------
eeprom_delay	proc	near

	push	ax
	push	bx
	push	dx

	call	ReadTickCounter
	mov	bx, ax

eeprom_delay_loop:

	call	ReadTickCounter
	neg	ax
	add	ax, bx
	cmp	ax, di
	jb	eeprom_delay_loop

	pop	dx
	pop	bx
	pop	ax
	ret

eeprom_delay	endp


;-----------------------------------------------------------------------------
; Stand-by is lowering chip select for 1 microsecond.
;-----------------------------------------------------------------------------
stand_by        proc    near

        in      al, dx                          ;de-select eeprom
        and     al, (11111110b) and (not EE_CS)
        out     dx, al

        mov     di, 2
        call    eeprom_delay

        or      al, EE_CS
        out     dx, al
        ret

stand_by        endp

;-----------------------------------------------------------------------------
;
;       ReadTickCounter
;
;       Read the 16 bit timer tick count register (system board timer 0).
;       The count register decrements by 2 (even numbers) every 838ns.
;
;       Assumes:        Interrupts disabled
;
;       Returns:        ax with the current count
;                       dx destroyed
;                       Interrupts disabled
;
ReadTickCounter proc    near
	push    dx
	mov     dx, i8254Cmd                    ; Command 8254 timer to latch
	xor     al, al                          ; T0's current count
	out     dx, al

	mov     dx, i8254Ch0                    ; read the latched count
	in      al, dx                          ; LSB first
	mov     ah, al
	in      al, dx                          ; MSB next
	xchg    al, ah                          ; put count in proper order
	pop     dx
	ret
ReadTickCounter endp

Code	ends
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\eep24x.inc ===
;************************************************************************
;*
;*                          EEP24.INC
;*
;*  EEPROM configuration routines for the ATI AT-2450 Adapters.
;*
;*  Copyright (c) 1994-5 Allied Telesyn Int.  All Rights Reserved.
;*
; 
;    Rev 1.0   14 Nov 1994 11:30:24   SSCHELL
;************************************************************************

; EEPROM Opcode
READ_OP		equ	2	; Read from EEPROM
EWEN_OP		equ	0	; Erase Write Enable	0b00
EWEN_ADR	equ	030h	; 			0b110000
ERASE_OP	equ	3	; Erase			0b11
ERAL_OP		equ	0	; Erase all		0b00
WRITE_OP	equ	1	; Write to EEPROM	0b01
WRAL_OP		equ	0	; Write all reg		0b00
EWDS_OP		equ	0	; Erase Write Enable	0b00
EWDS_ADR	equ	0	; 			0b000000

; EEPROM Map word offset
PROM_PADR1	equ	0
PROM_PADR2	equ	1
PROM_PADR3	equ	2
PROM_HWID	equ	4
PROM_USER1	equ	5
PROM_CHKSUM1	equ	6
PROM_ASCIIW	equ	7
PROM_IOLOW	equ	8
PROM_IOUP	equ	9
PROM_BCR18	equ	0ah
PROM_BCR2	equ	0bh
PROM_BCR21	equ	0ch
PROM_BCR9	equ	0eh
PROM_CHKSUM2	equ	1fh
PROM_USER2	equ	011h

; User1 Word (location 5):
BOOT2450_PROT	equ	03800h		; type of BootProtocol (bit 11,12,13)
	BOOT2450_NW_8023	equ	0000h	; use NetWare with IEEE 802.3
	BOOT2450_NW_8022	equ	0800h	; use NetWare with IEEE 802.2
	BOOT2450_NW_8137	equ	01000h	; use NetWare with Ethernet II
	BOOT2450_RPL		equ	01800h	; use RPL
	BOOT2450_BOOTP		equ	02000h	; BOOTP
	BOOT2450_BOOTP_ARP	equ	02800h	; BOOTP/ARP


; uwire control bit definitions
BCR19_UWIRE_ON	equ	10h	; sets EEN
BCR19_START	equ	15h	; "Start Bit" (command follows)
BCR19_STOP	equ	0	; Stop bit
BCR19		equ	19	; EEPROM control and status register
BCR19_ESK_HIGH	equ	2	; EEPROM serial clock
BCR19_ECS	equ	0014H	; EEPROM chip select

; PCNetPCI I/O Ports:
RAP_OFFSET	equ	12h	; Register Address Port
BDP_OFFSET	equ	16h	; Bus Data Port

; Configuration values for BCR2
MAU_SEL_MASK_2450	equ	0003h	; Bits 0-1 (BCR2): media selection

public  Delay_2450

Delay_2450	proc	near
	push	cx
	mov	cx, 50

DELAY_2450_Lp:
	loop	DELAY_2450_Lp

	pop	cx
	ret
Delay_2450	endp


;************************************************************************;
;*                                                                      *;
;*  VerifyPCIBoard                                                      *;
;*   Function: Read the configuration of the AT-2450 board.             *;
;*             All we need is the media selection from the EEPROM.      *;
;*   Input:  DI = base I/O address of the AT-2450 board.                *;
;*   Output: stc (carry set) if not an AT-2450 or config error;         *;
;*      clc (carry clear) if successful, and:                           *;
;*         CH = autoselect flag from BCR2 register                      *;
;*         CL = twisted pair flag from BCR2 register                    *;
;*      Other registers used are preserved.                             *;
;*                                                                      *;
;************************************************************************;
public	VerifyPCIBoard
VerifyPCIBoard proc   near

	push	ax			; Save caller's registers
	push	bx
	push	dx

	; Verify that this really is an AT-2450 board.
	mov	dx, di			; DX = address prom I/O address
	in	ax, dx			; Read the first 2 bytes of MAC address
	cmp	ax, 0			; It better be 0000
	je	VB_go_on_2450
	jmp	not_our_card

VB_go_on_2450:
	add	dx, 2
	in	ax, DX			; Read the next 2 bytes of MAC address
	cmp	al, 0F4h		; The third byte better be F4
	je	VB_its_ours_2450
	jmp	not_our_card

VB_its_ours_2450:
	mov	bx, PROM_BCR2		; Read BCR2 in the EEPROM
	call	ee_read			; to get the media selection

	and	bx, MAU_SEL_MASK_2450	; Look at only the 2 media sel bits
	mov	cx, bx			; We'll return it in cx
	and	cx, 01			; cl is the twisted pair flag
	shr	bx, 1			; Now look at autoselect
	mov	ch, bl			; Autoselect flag in ch

	clc				; Set CF=0 == "success"
	pop	dx			; Restore caller's registers
	pop	bx
	pop	ax
	ret				; Return to caller
   
not_our_card:
	stc				; Set CF=1 == "error"
	pop	dx			; Restore caller's registers
	pop	bx
	pop	ax
	ret				; Return to caller
      
VerifyPCIBoard endp


;****************************************************************************
;   This function reads a 16-bit word from the serial eeprom and returns the
;   result as an unsigned short integer in BX.  The eeprom location to be read
;   is passed to this function as the register BX. Note: It is assumed that
;   the EEPROM is configured for word (16 bit) mode.
;
;	Input:
;		bx = EEPROM location to read
;		di = IOBase
;
;	Output:
;		bx = value read
;****************************************************************************
public	ee_read
ee_read	PROC NEAR

	push	si			; Save registers used
	push	cx
	push	dx
	push	ax

	mov	si, BCR19_START
	call	uwire_out		; Give START condition to EEPROM.

	mov	al, READ_OP
	call	ee_opcode		; Write the read opcode to EEPROM.

	call	ee_address		; Write desired address (BX) to EEPROM.

	xor	si, si			; Clear registers
	xor	bx, bx
	
	; Read 16 bits from EEPROM.
serial_in:
	call	eedo_in			; Read a bit - returned in ax
	mov	cl, 000fH		; 15 bits
	mov	dx, si
	sub	cl, dl			; CL = 15 - loop counter
	shl	ax, cl			; Position the bit to add to the word
	or	bx, ax			; Add in the bit we just read
	inc	si
	cmp	si, 000fH		; Do we have a word yet?
	jle	serial_in		; No - read another bit

	; The word is read
	mov	si, BCR19_STOP		; BCR19_STOP = 0
	call	uwire_out		; Clear EEN and ECS.
					; bx = the EEPROM word just read

	pop	ax			; Restore saved registers
	pop	dx
	pop	cx
	pop	si

	ret	

ee_read	ENDP

;****************************************************************************
;   EE_EWEN	Enable EEPROM  erase/write
;
;   Input:	bx = EEPROM location to write to
;		ax = value to write to EEPROM
;****************************************************************************
public		EE_EWEN
ee_ewen		proc	near
		push	dx
		push	ax

		mov	di, NIC_IO
		mov	si, BCR19_START
		call	uwire_out	; Give START condition to EEPROM.
	
		mov	al, EWEN_OP
		call	ee_opcode	; Write the write opcode to EEPROM.

		mov	bx, EWEN_ADR
		call	ee_address	; Write desired address (BX) to EEPROM.

		mov	si, BCR19_STOP		; BCR19_STOP = 0
		call	uwire_out		; Clear EEN and ECS.

		pop	ax
		pop	dx
		ret
ee_ewen		endp

;****************************************************************************
;   EE_EWDS	Disable EEPROM  erase/write
;
;   Input:	bx = EEPROM location to write to
;		ax = value to write to EEPROM
;****************************************************************************
public		EE_EWDS
ee_ewds		proc	near
		push	dx
		push	ax

		mov	di, NIC_IO
		mov	si, BCR19_START
		call	uwire_out	; Give START condition to EEPROM.
	
		mov	al, EWDS_OP
		call	ee_opcode	; Write the write opcode to EEPROM.

		mov	bx, EWDS_ADR
		call	ee_address	; Write desired address (BX) to EEPROM.

		mov	si, BCR19_STOP		; BCR19_STOP = 0
		call	uwire_out		; Clear EEN and ECS.

		pop	ax
		pop	dx
		ret
ee_ewds		endp



;****************************************************************************
;   EE_WRITE	This function writes a 16-bit word to the serial eeprom.
;
;   Input:	bx = EEPROM location to write to
;		ax = value to write to EEPROM
;		di = IOBase
;****************************************************************************
public		ee_write
ee_write	PROC NEAR

	push	si			; Save registers used
	push	cx
	push	dx
	push	ax

	push	ax
	mov	si, BCR19_START
	call	uwire_out		; Give START condition to EEPROM.

	mov	al, WRITE_OP
	call	ee_opcode		; Write the write opcode to EEPROM.

	call	ee_address		; Write desired address (BX) to EEPROM.

	xor	si, si			; Clear registers
	xor	bx, bx

	pop	ax			; Value to write to EEPROM
	
	; Write 16 bits to EEPROM.
	mov	cx, 16
serial_out:
	rol	ax, 1
	mov	si, ax
	and	si, 1
	or	si, BCR19_ECS
	call	uwire_out		; Write a bit

	loop	serial_out		; No - read another bit

	mov	ax, 19
	mov	bx, BCR19_UWIRE_ON
	call	reg_write		; clears ESC to start programming

	call	Delay_2450

	mov	ax, 19
	mov	bx, BCR19_ECS
	call	reg_write		; EEPROM DO now the busy indicator

	; Wait for program cycle to complete
ee_write_chk:
	mov	ax, 19
	call	reg_read
	test	ax, 1
	jz	ee_write_chk


	mov	si, BCR19_STOP		; BCR19_STOP = 0
	call	uwire_out		; Clear EEN and ECS.
					; bx = the EEPROM word just read

	pop	ax			; Restore saved registers
	pop	dx
	pop	cx
	pop	si

	ret	

ee_write	ENDP

;****************************************************************************
;   SetChkSum1	This function update Checksum 1 of EEPROM if necessary
;
;   Input:	di = IOBase
;****************************************************************************
public		SetChkSum1
SetChkSum1	proc	near
		
		xor	ax, ax
		mov	di, NIC_IO
		mov	bx, PROM_PADR1

SetChkSumB:	push	bx
		call	ee_read
		add	al, bl
		adc	ah, 0
		add	al, bh
		adc	ah, 0
		pop	bx

		inc	bx
		cmp	bx, 6
		jnz	SetChkSumB
	   
		mov	bx, PROM_ASCIIW
		call	ee_read				
		add	al, bl
		adc	ah, 0
		add	al, bh
		adc	ah, 0

		mov	bx,  PROM_CHKSUM1
		call	ee_read
		cmp	ax, bx
		jz	SetChkSum1Exit

		call	Delay_2450

		; Need to update PROM_CHKSUM1
		mov	bx,  PROM_CHKSUM1
		call	ee_write

		call	Delay_2450

SetChkSum1Exit:
		ret
SetChkSum1	endp

;****************************************************************************
;   SetChkSum2	This function update Checksum 2 of EEPROM if necessary
;
;   Input:	di = IOBase
;****************************************************************************
public		SetChkSum2
SetChkSum2	proc	near
		
		xor	ax, ax
		mov	di, NIC_IO
		mov	bx, PROM_PADR1

ReadChkSum2:	push	bx
		call	ee_read
		add	ah, bl
		add	ah, bh
		pop	bx

		inc	bx
		cmp	bx, 01Fh
		jnz	ReadChkSum2

		call	ee_read
		add	ah, bh

		; is checksum okay?
		sub	ah, 0ffh
		jz	SetChkSum2Exit

		; Need to readjust checksum
		neg	ah

		mov	bx,  PROM_CHKSUM2
		call	ee_read	
		add	ah, bh

		call	Delay_2450

		mov	bx,  PROM_CHKSUM2
		call	ee_write

		call	Delay_2450


SetChkSum2Exit:
		ret
SetChkSum2	endp


;****************************************************************************
;   This function writes bit 1, followed by bit 0 of the argument 'opcode'
;   in AL onto the uwire interface.  The opcode of a desired eeprom operation
;   should be placed in the least significant two bits of the argument
;   'opcode', to write an opcode to the eeprom.
;
;	ax = OpCode
;****************************************************************************
public		ee_opcode
ee_opcode	PROC NEAR

	push	si			; Save used registers

	; Write out MSB of opcode
	push	ax			; Save for future use
	and	al, 2			; Look at bit 1 only
	shr	al, 1			; Put it in bit 0
	or	al, BCR19_ECS		; EEPROM chip select
	sub	ah, ah			; Clear high byte
	mov	si, ax			; SI is argument to uwire_out
	call	uwire_out		; Write the bit to the EEPROM

	; Write out LSB of opcode
	pop	ax			; Retrieve passed-in argument
	and	al, 1			; Look at bit 0 only
	or	al, BCR19_ECS		; EEPROM chip select
	sub	ah, ah			; Clear high byte
	mov	si, ax			; SI is argument to uwire_out
	call	uwire_out		; Write the bit to the EEPROM

	pop	si			; Restore used registers
	ret	

ee_opcode	ENDP

;****************************************************************************
;   This function writes the 6 least significant bits of the argument
;   'address' onto the uwire interface (order:bit 5 to bit 0).  The desired
;   eeprom address should be placed in the 6 least significant bits of the
;   argument 'address' to write an address to the eeprom.
;
;   BX = address to write
;****************************************************************************
public		ee_address
ee_address	PROC NEAR

	push	si			; Save used registers
	push	dx
	push	ax
	push	cx

	xor	dx, dx			; Initialize bit counter

	; Write out MSB to LSB of address
write_address_bit:
	mov	cl, 5			; 5 bits
	mov	ax, dx
	sub	cl, al			; CL = 5 - loop counter
	mov	al, bl			; Passed in address is in BX
	shr	al, cl			; Position the bit to add to the word
	and	al, 1			; Look at just a single bit
	or	al, BCR19_ECS		; EEPROM chip select
	sub	ah, ah			; Clear high bit
	mov	si, ax			; SI is argument to uwire_out
	call	uwire_out		; Write the address bit to the EEPROM

	inc	dx			; Next bit
	cmp	dx, 5			; Did we do 5 bits yet?
	jbe	write_address_bit	; No - read another bit

	pop	cx			; Restore used registers
	pop	ax
	pop	dx
	pop	si
	ret	

ee_address	ENDP

;****************************************************************************
;   This function takes a 16-bit unsigned integer argument, in SI, and
;   writes the lower 5 bits to BCR19, affecting the uwire interface.  A
;   clock edge on the EESK output is generated to clock the uwire interface,
;   causing a single bit write to the EEPROM.
;   SI = value to write
;****************************************************************************
public		uwire_out
uwire_out	PROC NEAR

	push	ax			; Save used registers
	push	bx
	mov	ax, si			; AX = value to write

	; Isolate uwire signals and clear the ESK bit to allow clocking.
	and	ax, 001dH

	; Writes data to uwire interface (ESK low).
	mov	bx, ax			; Data to be written
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	DELAY_2450		; Guarantees fSK, tSKL, and tDIS EE

	or	bx, BCR19_ESK_HIGH	; Make EEPROM serial clock high
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	DELAY_2450		; Guarantees fSK, tSKL, and tDIS EE

	pop	bx			; Restore used registers
	pop	ax

	ret	

uwire_out	ENDP

;****************************************************************************
;   eedo_in - Perform single bit read from EEPROM using uwire interface.
;
;   The bit is returned in AX.
;****************************************************************************
public		eedo_in
eedo_in	PROC NEAR

	push	bx			; Save used registers
	
	; Bring EESK (clock pin) low.
	mov	bx, BCR19_ECS		; EEPROM serial clock
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	DELAY_2450		; Guarantees fSK and tSKL eeprom

	; Clock out EEPROM bit to EEDO pin.
	mov	bx, BCR19_ECS		; EEPROM serial clock
	or	bx, BCR19_ESK_HIGH	; Make EEPROM serial clock high
	mov	ax, BCR19		; Write to EEPROM control register
	call	reg_write

	call	DELAY_2450		; Guarantees fSK and tSKL eeprom
	call	DELAY_2450

	mov	ax, BCR19		; Read from EEPROM control register
	call	reg_read		; Read the bit
	and	ax, 1			; Look at just a single bit

	pop	bx			; Restore used registers

	ret	

eedo_in	ENDP

;****************************************************************************
;   reg_write - Write a 16-bit value to the specified CSR or BCR register.
;
;   Use a 16-bit I/O instruction.  A BCR write is performed.
;   
;
;	DI = IOBase
;	AX = number of the specific register to access
;	BX = data
;****************************************************************************
public		reg_write
reg_write	PROC NEAR

	push	dx			; Save used registers
	push	ax
	
	mov	dx, di			; Base IO address
	add	dx, RAP_OFFSET		; Write to Register Address Port
	out	dx, ax			; Write register to be accessed

	mov	ax, bx			; Data to be written

	mov	dx, di			; Base IO address
	add	dx, BDP_OFFSET		; Write to Bus Data Port
	out	dx, ax			; Write data to register

	pop	ax			; Restore used registers
	pop	dx

	ret	

reg_write	ENDP

;****************************************************************************
;   reg_read - Read a 16-bit value from the specified CSR or BCR register.
;
;   Use a 16-bit I/O instruction.  A BCR read is performed.
;   
;   IOAddress1 is expected to contain the correct I/O address.
;   AX contains the register to read on entry.  On exit, AX contains
;   the value just read.
;
;	DI = IOBase
;	AX = number of the specific register to access
;
;****************************************************************************
public		reg_read
reg_read	PROC NEAR

	push	dx			; Save used registers

	mov	dx, di			; Base IO address
	add	dx, RAP_OFFSET		; Write to Register Address Port
	out	dx, ax			; Write register to be accessed

	mov	dx, di			; Base IO address
	add	dx, BDP_OFFSET		; Write to Bus Data Port
	in	ax, dx			; Read data from register

	pop	dx			; Restore used registers

	ret	

reg_read	ENDP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\bwstruct.inc ===
;====================================================================
; BWSTRUCT.INC
;
; Include for for BootWare, defines common structures.
;
; 970116 PC - first version
;====================================================================

;--------------------------------------------------------------------
; Common equates
;---------------------------------------------------------------------
FEATURE_LOCAL	equ	1
FEATURE_VIRUS	equ	2
FEATURE_MENU	equ	4
FEATURE_KEYWAIT	equ	8
FEATURE_FLOPPY	equ	64
FEATURE_HDRIVE	equ	128

;--------------------------------------------------------------------
; Event Descriptor (ED) Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc	ED
	Ptr		dw	?	; pointer to next ED
	Unused		dw	?	; spare word
	DestAddr	dw	?, ?, ?	; destination Address
	ErrCode		dw	?	; error code
	ErrMsg		dw	?	; pointer to error msg
	Length		dw	?	; total packet length
	FragCount	dw	?	; number of fragments
	FragOff		dw	?	; 1st fragment offset
	FragSeg		dw	?	; 1st fragment segment
	FragLen 	dw	?	; length of fragment
ends
ELSE
ED_Struct      STRUC
	ED_Ptr		dw	?	; pointer to next ED
	ED_Unused	dw	?	; spare word
	ED_DestAddr	dw	?, ?, ?	; destination address
	ED_ErrCode	dw	?       ; error code
	ED_ErrMsg	dw	?       ; Pointer to error msg
	ED_Length	dw	?	; total packet length
	ED_FragCount	dw	?	; Number of descriptors/fragments
	ED_FragOff	dw	?	; Descriptor Pointer
	ED_FragSeg	dw	?	; Descriptor Pointer
	ED_FragLen 	dw	?	; Length of packet descriptor
ED_Struct      ENDS
ENDIF

;--------------------------------------------------------------------
; Descricptor Structure
;---------------------------------------------------------------------
IFDEF _IDEAL_
Struc Frag
	Off		dw	?	; offset of fragment
	Seg		dw	?	; segment of fragment
	Len		dw	?	; length of fragment
ends
ELSE
Frag Struc
	FragOff		dw	?	; offset of fragment
	FragSeg		dw	?	; segment of fragment
	FragLen		dw	?	; length of fragment
Frag ends
Descript_Struct STRUC
	DPointer	dd	?	; Descriptor Pointer
	DLen		dw	?	; Length of packet descriptor
Descript_Struct ends
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\nadamd.asm ===
page	,132
;************************************************************************
;* NADAMD.ASM
;*	- Contains modules supporting the NetPC UNDI API for Am79C970A
;*							PCnet-PCI II
;*
;* Modules included:-
;*	NADInit
;*	NADReset
;*	NADShutDown
;*	NADOpen
;*	NADClose
;*	NADSetFilter
;*	NADGetStatistics
;*	NADRequestINT
;*	NADMCastChange
;*	DriverISR_Proc
;*
;* Latest Update: 970514
;************************************************************************
.386


include 	undi_equ.inc
include 	pxe_stru.inc
include 	bwstruct.inc
include 	spdosegs.inc


_TEXT	Segment para public

	assume	cs:CGroup, ds:DGroup


public	NADInit
public	NADReset
public	NADShutDown
public	NADOpen
public	NADClose
public	NADSetFilter
public	NADGetStatistics
public  NADInitiateDiags
public  NADSetMACAddress

ifdef HARD_INT
    public	NADRequestINT
endif

public	NADMCastChange
public	DriverISR_Proc

public   OrgIntVector_OFF
public   OrgIntVector_SEG


extrn	GetED:near
extrn	PostED:near
extrn	Net_Address:byte
extrn	Node_Address:byte
extrn	UNDI_DriverISR:far
extrn	IOBase:word
extrn	IRQNumber:byte
;extern GenIntCallBack:dword
;extern RxCallback:dword
extrn EDListHead:word
extrn EDListTail:word




;extern IntReqPending:byte

;;extrn Puts:near


;public  RxEDs

;NAD return codes from BWEQU.INC

SUCCESSFUL		EQU	0000h
REQUEST_QUEUED		EQU	0002h
OUT_OF_RESOURCE 	EQU	0006h
INVALID_PARAMETER	EQU	0007h
INVALID_FUNCTION	EQU	0008h
NOT_SUPPORTED		EQU	0009h
HARDWARE_ERROR		EQU	000ah
TRANSMIT_ERROR		EQU	000bh
NO_SUCH_DESTINATION	EQU	000ch
HARDWARE_NOT_FOUND	EQU	0023h
HARDWARE_FAILURE	EQU	0024h
CONFIGURATION_FAILURE	EQU	0025h
INTERRUPT_CONFLICT	EQU	0026h
INITIALIZATION_FAILED	EQU	0028h
RECEIVE_TIMEOUT 	EQU	0080h		; Rx2 in NetWare
GENERAL_FAILURE 	EQU	00ffh


;
; offsets in PCI configuration space
;
PCIC_INTERRUPTLINE	equ	003Ch
PCIC_BIOSROMCONTROL	equ	0030h
PCIC_IOBASE		    equ	0010h
PCIC_LATENCYTIMER	equ	000Dh
PCIC_STATUS		    equ	0006h
PCIC_COMMAND		equ	0004h
PCIC_DEVICEID		equ	0002h
PCIC_VENDORID		equ	0000h
;
; bits in PciCommand
;
PCIC_IOENABLE		equ	00001h
PCIC_BMENABLE		equ	00004h

; PCI BIOS function code

PCI_FUNCTION_ID 	equ	0b1h
PCI_BIOS_PRESENT	equ	001h
FIND_PCI_DEVICE 	equ	002h
READ_CONFIG_BYTE	equ	008h
READ_CONFIG_WORD	equ	009h
READ_CONFIG_DWORD	equ	00ah
WRITE_CONFIG_BYTE	equ	0bh
WRITE_CONFIG_WORD	equ	0Ch
WRITE_CONFIG_DWORD	equ	0Dh

; PCI BIOS function return code

PCI_CALL_SUCCESSFUL	    equ	00h
PCI_DEVICE_NOT_FOUND	equ	86h
PCI_BAD_VENDOR_ID	    equ	83h

VENDOR_IDx	equ 1022h	     ;4 ; Vendor ID for AMD
DEVICE_ID	equ 2000h	     ;6 ; Device ID for PCnet-PCI II

include AT1500.EQU			; AMD-specific equates

; Time constants used in delays and timeouts
TIME50MS	equ	1		; 1 clock tick is 50ms
TIME100MS	equ	2		; 2 clock tick is 100ms
TIME900MS	equ	50		; 2 clock tick is 100ms

EOI		equ	20h

LF	equ	0Ah
CR	equ	0Dh


MTU	    	equ	1514	;max size for a completed Ethernet packet
NUM_ED		equ	5	;number of EDs





;=========================================================================
; NADInit
;=========
;	- Initializes the adapter but does not enable the Tx and Rx units
;	- Hook receiving ISR
;
; Parameters:	DS = CGroup
;
; Returns:	If CF = 0 then success, else fail
;=========================================================================

NADInit 	proc	near

;;db  0f1h        

		cld
		push	ds
		push	es

        mov     ax, ds
        mov     es, ax
;        push    ds
;        pop     es


;int 03        

		call	FindAT2450	; returns DX = IOBase, AL = irq
		or	    dx, dx
		jz	    NADInitErr	; adapter not found

		mov	    DGroup:[IOBase], dx	; UNDI_NAD variable
		mov	    DGroup:[IntNum], al
		mov	    DGroup:[IRQNumber], al ; UNDI_NAD variable

		call	InitHardware



;;   	mov	ax, DGroup:CSR15Broad

;;	    and	ax, 0bfffh		; clear bit 14
;;  	mov	DGroup:CSR15Broad, ax



;**** Dmitry ***

        mov     bl, 58      ; set software style - 16 bit
        mov     ax, 0
        call    csrOut

;*****

		mov	    si, offset DGroup:Net_Address
		mov	    di, offset DGroup:Node_Address
		movsw
		movsw
		movsw

;;    	lea	bp, DGroup:LanOption
;;    	call	puts

        mov     ax, ds
        mov     DGroup:StoreDS, ax

        call    NADCheckCable

        jnc     NADInitExit
        call    NADDisengage
        mov     ax, 2

;		clc
;		jmp	short NADInitExit

NADInitErr:
		stc
NADInitExit:

;db  0f1h
		pop	es
		pop	ds
		ret

NADInit 	endp

;-----------------------------------------------------------------------------
; FindAT2450
;
; Return	dx = 0		not found
;		     IOBase	found
;		al = IRQLevel
;-----------------------------------------------------------------------------

FindAT2450	proc	near

	call	PCISearch
	jc	no_pci

;   Set Bus Master Enable ( some BIOSes disable that ):

	mov	bx, DGroup:[PCIBusDevFunc]
	mov	ah, PCI_FUNCTION_ID	; 0B1h
	mov	al, READ_CONFIG_WORD	; read word from config space (04h)
	mov	di, 04h 		; offset in config space for COMMAND
	INT	1AH
	jc	no_pci			; Brif PCI error.

; *** Dmitry ***

	mov	bx, DGroup:[PCIBusDevFunc]
	or	cx, 04h 		; set Bus Master Enable
	mov	ah, PCI_FUNCTION_ID	; 0B1h
	mov	al, WRITE_CONFIG_WORD	; write word back to config space (04h)
	mov	di, 04h 		; offset in config space for COMMAND
	INT	1AH
	jc	no_pci	      ; Brif PCI error.

; ***

; PCI device has been found, read IO address from config space

	mov	bx, DGroup:[PCIBusDevFunc]
	mov	ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_WORD
	mov	di, PCIC_IOBASE
	int	1ah
	jc	no_pci

	and	cx, 0FFE0h			 ; drop last 5 bits
	mov	dx, cx

	mov    ax, PCI_FUNCTION_ID shl 8 + READ_CONFIG_BYTE
	mov    bx, DGroup:[PCIBusDevFunc]
	mov    di, PCIC_INTERRUPTLINE
	int    1ah
	mov    al, cl
	ret

no_pci:
	xor	dx, dx
	ret

FindAT2450	endp

;------ PCISearch -----------------------------------------------------------;
;									     ;
;	Attempt to find a match against a PCI adapter.	The caller can	     ;
;	specify the exact busno/slot to check or leave either unspecified    ;
;	in which case a search will be performed among the allowed	     ;
;	busno/slot combinations for a match.				     ;
;									     ;
;	Entry:								     ;
;	cli								     ;
;	Slot  = slot number to search, -1 if not specified		     ;
;	BusNo = bus number to search, -1 if not specified		     ;
;									     ;
;	Exit:								     ;
;	cli								     ;
;	carry = set if no match 					     ;
;	      = clear if a match					     ;
;	BusNo = set for the matching adapter if carry clear		     ;
;	Slot  = set for the matching adapter if carry clear		     ;
;	PCIBusDevFunc = set for the matching adapter if carry clear	     ;
;									     ;
;	All registers are preserved.					     ;
;									     ;
;----------------------------------------------------------------------------;

	public	PCISearch

PCISearch	proc	near

	push	ax
	push	bx
	push	cx
	push	di

	mov	cx, DEVICE_ID
	mov	dx, VENDOR_IDx
	mov	si, 0			; PCI device number (0 for first)
	mov	ah, PCI_FUNCTION_ID	; 0B1h
	mov	al, FIND_PCI_DEVICE	; 02h
	INT	1AH
	jc	PCIS_No        ; Brif PCI error.

	;Device was found - Return Handler in BX.
	;---------------------------------
	mov	word ptr DGroup:[PCIBusDevFunc], bx

;
; Read the PciCommand register to see if the adapter has been activated.  if
; not, pretend we didn't find it
;
	mov	ah, 0B1h		; PCI BIOS Function
	mov	al, 009h		; PCI Read Config Word
	mov	bx, DGroup:[PCIBusDevFunc]
	mov	di, PCIC_COMMAND
	int	1Ah
	jc	PCIS_No

	test	ah, ah
	jnz	PCIS_No


	test	cx, PCIC_IOENABLE	; I/O access enabled?
	jz	PCIS_No

	clc
;
; exit with carry flag as set
;
	public	pcis_exit
pcis_exit:
;	popa

	pop	di
	pop	cx
	pop	bx
	pop	ax

	ret

;
; no PCI support or adapter not found or failure after found
;
	public	PCIS_No
PCIS_No:
	stc
	jmp	pcis_exit

PCISearch	endp

public StopAdapter

StopAdapter    proc    near

	mov	dx, DGroup:[IOBase]
	add	dx, REGRAP
	mov	ax, CSR0
	cli				; 970515 - to ensure no interrupts
	out	dx, ax			; Specify CSR0
	jmp	$+2
	in	ax, dx

	sub	dx, 2			; -2 to get RegRDP

	; 940315 Before issuing CSR0_STOP, issue CSR0_STRT to
	; get adapter out of STOP mode ( happens sometimes ).

; ** Dmitry **

;;	mov	ax, CSR0_STRT
;;	out	dx, ax

;;	jmp	$+2
;;	jmp	$+2

; **
	; 940315 }

	mov	ax, CSR0_STOP		; Reset card
	out	dx,ax
	jmp	$+2
	in	ax,dx
	sti				; 970515 - allow interrupts again

	mov	ax, TIME100MS
	call	StartTime

GetMemReset:
	in	ax,dx
	cmp	ax, CSR0_STOP
	jz	GetMemResetOK	; Jump if reset is Okay (CY clear)

	call	CheckTime
	jnc	GetMemReset	; check status again if not timeout

GetMemErr:
	stc			; CY set to indicate reset timeout

GetMemResetOK:
	ret

StopAdapter	endp



InitHardware	proc	near

; Stop card before doing anything

;    int 03
    push    ds
	call	StopAdapter

; Enable  receiver:

    mov     bl, 15
    call    CSRIn
    and     ax, not 1h
    mov     bl, 15
    call    CSROut

; Enable transmit poll:

    mov     bl, CSR4
    call    CSRIn
    and     ax, not 1000h
    mov     bl, CSR4
    call    CSROut



	cld			; clear direction flag
	mov	    DGroup:[InterruptFlag],0 ; initialize variable

	; Save the original PIC interrupt vector
	call	SetupInt	; Setup interrupt variables

;db  0f1h
    in  ax, 60h         ;

;*** do we need this????
;	; Set the DMA interrupt controller into cascade mode
;	call	EnableDMACascade

	; Fetch the network address
	call	SetCardAddr
	xor ax, ax

	pop	ds
	ret				; return to caller

InitHardware	endp

;=========================================================================
; NADReset
;==========
;	- Reset and Reinitialize the adapter
;	- Enables the Tx and Rx units
;
; Parameters:	DS = DataSeg
;
; Returns:
;=========================================================================
NADReset	proc	near

;int 03        
;db  0f1h

	push	es
	push	di		; save ES:DI since UNDI_NAD doesn't!!!
	call	StopAdapter
    clc
	pop	di
	pop	es
	ret

NADReset	endp

;=========================================================================
; NADShutDown
;=============
;	- reset the adapter and enables
;	- unhook our ISR
;
; Parameters:
;
; Returns:
;=========================================================================

NADShutDown	proc	near

;;db  0f1h
;int 03
;	push	cs		; NADDisengage does a retf

	call	NADDisengage	; stop adapter, unhook ISR

IFDEF Gateway

; Disable receiver:

;db  0f1h

    mov     bl, 15
    call    CSRIn
    or      ax, 1h
    mov     bl, 15
    call    CSROut

; Disable transmit poll:

    mov     bl, CSR4
    call    CSRIn
    or      ax, 1000h
    mov     bl, CSR4
    call    CSROut

	mov	    ax,( CSR0_STRT )
	mov	    bl, CSR0
	call	CSROut

ENDIF

;;	mov	dx, [IOBase]
;;	add	dx, REGRESET
;;	in	ax, dx		; start an S_RESET (takes 1us).

;db  0f1h
    clc

	ret

NADShutDown	endp


;=========================================================================
; NADOpen
;=========
;	- Enables the Tx and Rx units
;
; Parameters:	DS = CGroup
;
; Returns:
;=========================================================================
NADOpen 	proc	near

;db  0f1h

;int 03        

; not sure whether we have to do anything here, since NADTransmit does a
; reset of the adapter and re-inits everytime.

        clc
    	ret

NADOpen 	endp


;=========================================================================
; NADClose
;==========
;	- Disables the Tx and Rx units
;
; Parameters:	DS = CGroup
;
; Returns:
;=========================================================================
NADClose	proc	near

;int 03        

	push	es
	push	di		; save ES:DI since UNDI_NAD doesn't!!!
	call	StopAdapter
    clc
	pop	di
	pop	es
	ret

NADClose	endp



NADInitiateDiags    proc    near
    stc
    ret
NADInitiateDiags    endp



NADSetMACAddress    proc    near
;;    stc
    clc
    ret
NADSetMACAddress    endp




;=========================================================================
; DriverISR_Proc
;================
;	- ISR procedure to be called by UNDI_DriverISR
;
; Parameters:	DS = CGroup
;
; Returns:	CF = a if not our int
;=========================================================================
DriverISR_Proc	proc	near

;
; check whether our board caused the interrupt
;
;int 03        


		mov	bl, CSR0
		call	CSRIn		; AX.b7 = INTR, int flag
		test	al, CSR0_INTR	; Interrupt Flag set?
		jnz	isr_ours

		stc
		ret

isr_ours:
		pushf
		call	BootISR 	; (BWAMD.INC)

; ********************************
        cli
        sub     DGroup:ReceiveError, 1  ; detect CY flag
        cmc                             ; toggle it
        mov     DGroup:ReceiveError, 0
        sti
; ********************************
;;;;            clc

;;;        jnc     @F
;;;db  0f1h
;;		clc
;;;@@:
		ret

DriverISR_Proc	endp

;=========================================================================
; NADSetFilter
;==============
;	- Change the rx unit's filter to a new one
;
; Parameters:	AX = filter value, 1 = directed/multicast
;				   2 = broadcast
;				   4 = promiscuous
;		DS = CGroup
;
; Returns:
;=========================================================================
NADSetFilter	proc	near

; use NADChangeReceiveMask to do all of the dirty work -- 1 bit at a time,
; since NADChangeReceiveMask does not accept OR'd mask settings

;int 03
	push	ax			; save for later
	mov	bl, 00000100b		; multicast setting - assume off
	test	al, 1			; directed/multicast?
	jz	SetFilterMulticast

	or	bl, 1			; multicast on

SetFilterMulticast:
	call	NADChangeReceiveMask

	pop	ax
	push	ax
	mov	bl, 00000010b		; broadcast setting - assume off
	test	al, 2			; broadcast?
	jz	SetFilterBroadcast

	or	bl, 1			; broadcast on

SetFilterBroadcast:
	call	NADChangeReceiveMask

	pop	ax
	mov	bl, 00010000b		; promiscuous setting - assume off
	test	al, 4			; promiscuous?
	jz	SetFilterPromiscuous

	or	bl, 1			; promiscuous on

SetFilterPromiscuous:
	call	NADChangeReceiveMask
    clc
	ret

NADSetFilter	endp


;=========================================================================
; NADGetStatistics
;==================
;	- Read the adapter's statistics
;
; Parameters:	ds:si points to variables to hold the result
;			TxGoodFrames	dd	0	;1
;			RxGoodFrames	dd	0	;2
;			RxCRCErrors	dd	0	;3
;			RxDiscarded	dd	0	;3
;
; Returns:
;=========================================================================
NADGetStatistics	proc	 near

;int 03        

		push	dx
; more code here

		pop	dx
;;        stc
        clc
		ret

NADGetStatistics	endp


ifdef HARD_INT


;=========================================================================
; NADRequestINT
;================
;	- Generate an interrupt to the host
;
; Parameters:
;
; Returns:
;=========================================================================
NADRequestINT	proc	near


;	 int 03

;;		mov	bl, CSR3
;;	xor ax,ax
;;		call	CSROut
;;	sti
;;		ret

;	 sti
;	 int 03


;;	db  0F1h


        mov bl, CSR0
        call    CSRIn
        or  ax, 40h
;        mov ax, 44h
        call    CSROUT
		mov	    bl, CSR4
		call	CSRIn		; read CSR4
		and	    ax, 4D15h   ; set b7, UINTCMD to generate user int
		or      ax, 4080h
		sti
		call	CSROut
;		sti
		ret



NADRequestINT	endp


endif


;==========================================================================
; NADMCastChange
;================
;	- Modify the multicast buffer to receive the multicast addresses
;	  listed in the multicast table.
;	  Each entry in the multicast table is as follows:
;		  Bytes 0-5 = Multicast Address
;	  All addresses are contiguous entries
;
; Parameters:	CX =  Number of multicast entries.
;		ES:SI -> Multicast Table.
;		AX = 1 means save the list
;		AX = 0 means use the saved list
;
; Return:	All registers may be destroyed.
;==========================================================================

NADMcastChange	proc	near

;;	call	StopReceiveUnit
	push	es			; save ES

;; add code here to deal with AX=0 case (used saved list)

;- clear the existing multicast table (and LADRF??)

	push	ds
	pop	es			; ES = DS
	mov	di, offset DGroup:MCastTable
	xor	ax, ax
	stosw
	stosw
	stosw

	mov	di, offset DGroup:LADRF
	stosw
	stosw
	stosw
	stosw

	pop	es			; restore ES
	mov	di, si			; ES:DI now points to mcast addrlist
	cmp	cx, MAXNUM_MCADDR
	jbe	MCsave

	mov	cx, MAXNUM_MCADDR

MCsave:
	jcxz	Set_MCastDone		; could be zero -- just exit

Set_McastTable_Loop:
	push	cx			; save mcastaddr count
	call	Set_Multicast_List	; return ES:DI ptr to next address
	pop	cx
	add	bx, offset DGroup:LADRF
	or	byte ptr [bx], al
	loop	Set_MCastTable_Loop




; Fill the LADRF AMD registers (CSR8-CSR11 ):

;int	03
;    push    cx

;    mov cx, 4
;    mov bl, 8
;    mov si, offset LADRF
;setLADRF:
;    lodsw
;    call CSROUT
;    inc  bl
;    loop setLADRF

;    pop cx

Set_MCastDone:
;;  call    StartReceiveUnit
	ret

NADMcastChange	endp

; ***** routines pasted directly from AT1500.ASM
;
;
;	void CSROut(reg, val) - put value to CSR register.
;
; Input 	bl	CSR reg number ( CSR0, CSR1 ... )
;		ax	Value to write to
;
; Output	ax	Value read from port after data is written
;
; Outputs value val to lance CSR reg (0-3 for AM7790, 0-127 for AM79c960)
; given by reg.
;
CSROut	proc	near
	push	dx

	push	ax
	mov	dx, DGroup:[IOBase]
	add	dx, REGRAP	;offset to RAP register
	mov	al, bl		;load CSR number (ie CSR0, CSR1...)
	xor	ah, ah		;clear upper byte of word to put
	out	dx, ax		;selec CSR reg

	add	dx, -2		;point to RDP
	pop	ax		;get value to stuff
	out	dx, ax		;send to selected CSR reg.

	call	Delay_750

	in	ax, dx
	pop	dx
	ret
CSROut	endp

;
;
;	CSRIn(reg) - read value from CSR register
;
; Input 	bl	CSR reg number
;
; Output	AX	value of CSR register
;
; Outputs value val to lance CSR reg (0-3 for AM7790, 0-127 for AM79c960)
; given by reg.
;
;
CSRIn	 proc	 near
	push	dx

	mov	dx, DGroup:[IOBase]
	add	dx, REGRAP	;point to RAP register
	mov	al, bl		;get isacr reg to address
	xor	ah, ah		;clear high byte
	out	dx, ax		;select CSR reg

	add	dx, -2		;point to RDP
	in	ax, dx		;read value to return

	pop	dx
	ret
CSRIn	 endp



BCROut	proc	near
	push	dx

	push	ax
	mov	dx, DGroup:IOBase
	add	dx, RegRAP	;offset to RAP register
	mov	al, bl		;load BCR number (ie BCR0, BCR1...)
	xor	ah, ah		;clear upper byte of word to put
	out	dx, ax		;select BCR reg

	add	dx, 4		;point to BDP
	pop	ax		    ;get value to stuff
	out	dx, ax		;send to selected BCR reg.

	call	Delay_750

	in	ax, dx
	pop	dx
	ret
BCROut	endp

;
;
;	BCRIn(reg) - read value from BCR register
;
; Input 	bl	BCR reg number
;
; Output	AX	value of BCR register
;
; Outputs value val to lance BCR reg (0-3 for AM7790, 0-127 for AM79c960)
; given by reg.
;
;

BCRIn	 proc	 near
	push	dx

	mov	dx, DGroup:IOBase
	add	dx, RegRAP	;point to RAP register
	mov	al, bl		;get isacr reg to address
	xor	ah, ah		;clear high byte
	out	dx, ax		;select BCR reg

	add	dx, 4		;point to BDP
	in	ax, dx		;read value to return

	pop	dx
	ret
BCRIn	 endp



;public  NADCheckCable 


NADCheckCable   proc    near

; first check Internal PHY :
        mov     bl, 4
        call    BCRIn
        and     ax, 7fffh
        push    ax
        mov     ax, 40h
        call    BCROut
        call    BCRIn
        mov     cx, ax
        pop     ax
        call    BCROut
        test    cx, 8000h
        jnz     Media_ok

; then externalPhy:

        mov     bl, 32
        call    BCRIn
        test    ax, 4000h
        jnz     extPhy
        inc     bl
        mov     ax, 2h
        call    BCROut
        inc     bl
        call    BCRIn
        or      ax, ax
        jz      media_fail
        cmp     ax, 0ffffh
        je      media_fail
extPhy:
        inc     bl
        mov     ax, 21h
        call    BCROut
        inc     bl
        call    BCRIn
        test    ax, 4
        jnz     Media_ok

media_fail:
		stc
		ret

Media_ok:
		clc
		ret

NADCheckCable   endp


;------------------------------------------------------------------------------
;	SendInitBlock
;	Function : Assemble and send the initialization block to the adapter
;		   The initialization block contains operating parameters
;		   necessary for operations
;		   It will also wait for the adapter to acknowledge the
;		   initialization and check for errors
;	in	:  di pointer to receive ring pointer
;		   si pointer to transmit ring pointer
;		   BusInterface contains value to be stored in CSR3
;		   CSR0Cmd contains command to be sent to CSR0
;		   InitBlock.Mode is set to reflect desired operating parameters
;	 Out	:  zf=1 no error	zf=0 error
;
;	Assumption :	The mode register is set already
;------------------------------------------------------------------------------
public		SendInitBlock
SendInitBlock	proc	near
		pusha

		push	si
		push	di
		; Place the node address into PADR ( physical address )
;;        push    ds
;;        pop     es
        mov     ax, ds
        mov     es, ax
		mov	di, offset DGroup:InitialBlock.InitNodeAdd
		mov	si, offset DGroup:Net_Address
		mov	cx,6
		rep	movsb

		; The logical address filter will just be zeros
		; Try to use filter to filter out broadcast

    	mov si, offset DGroup:LADRF
;	    mov si, LADRFPtr
;	    mov al, 0ffh
		mov	di, offset DGroup:InitialBlock.InitAddrFilter
		mov	cx,8
;		rep stosb
		rep	movsb

		; Setup the receive descriptor ring pointer
		mov	ax,NumRxBuf
		pop	di
		mov	dx,di
		call	SetupRing
		mov	di, offset DGroup:InitialBlock.InitRdrp

		mov	ds:[di],dx
		add	di,2
		mov	ds:[di],ax

		; Setup the transmit descriptor ring pointer
		mov	ax, NumTxBuf
		pop	si
		mov	dx,si
		call	SetupRing
		mov	di, offset DGroup:InitialBlock.InitTdrp

		mov	ds:[di],dx
		add	di,2
		mov	ds:[di],ax

		; Finish setting up the initialization block
		; Start setting up the CSR blocks
		mov	ax, DGroup:[BusInterface]
		mov	bl, CSR3
		call	CSROut



IFDEF		GILBUG
		; Check if the STOP bit is set (it will disable all activities)
		; Print Tx3 if bit is set
		; Only in GILBUG mode (the bit is checked again later )
		push	ax
		push	dx

		mov	ax, CSR0
		mov	dx, DGroup:[IOBase]
		add	dx, REGRAP
		out	dx,ax		; Specify CSR0

		mov	dx, DGroup:[IOBase]
		add	dx, REGRDP
		in	ax, dx
		cmp	ax, CSR0_STOP
		pop	dx
		pop	ax
		jz	NetSendTest1

		mov	ax, 0e0dh	 ;
		int	010h
		mov	ax, 0e0ah
		int	010h		; skip one line
		mov	ax,0e4ch	; print "L"
		int	010h

		mov	al,3		; Print Tx3 to indicate mysterious reset
		add	al,'0'

NetSendTest1:

ENDIF
		; Place address of initialization block in CSR1 and CSR2
		mov	dx, offset DGroup:InitialBlock

		xor	ax,ax		;
		call	SetupRing

		mov	bl, CSR2
		call	CSROut

		mov	ax, dx
		and	ax, 0FFFEh		; bit 0 has to be zero
		mov	bl, CSR1
		call	CSROut

		; Check if the STOP bit is set (it will disable all activities)
		; Print Tx3 if bit is set
		mov	bl, CSR0
		call	CSRIn

		cmp	ax,CSR0_STOP
		jz	SendInitStop

;		mov	di, offset CGroup:ErrReset
;		mov	cs:StatusMsgFlag, di

		mov	ax,1
		or	ax,ax		; clear zf to indicate error
		jmp	SentInitEnd

SendInitStop:
		mov	ax, DGroup:[CSR0Cmd]
		mov	bl, CSR0
		call	CSROut

		mov	ax, 18	; 1 second
		call	StartTime

SendInitPoll:	mov	ax, DGroup:[InterruptFlag]
		test	ax, INTINITERR
		jnz	SendInitErr

		test	ax, INTINIT
		jnz	SendInitOK

		call	CheckTime	; timeout is 100ms
		jnc	SendInitPoll

		jmp	SendInitErr

SendInitOK:

IFDEF		DEBUG
		int	3
ENDIF


SendInit2450:
		mov	bx, DGroup:[ValISACR2]

		mov	di, DGroup:[IOBase]
		mov	ax, 2
		call	reg_read

		; if bit 1 (ASEL) is already set, just exit
		test	ax, 2
		jnz	SentInitISACR

		and	ax, 0FFFEh		; always clear XMAUSEL

		or	ax, 2			; set ASEL for AutoSelect

;951109 Just force the board to use AutoSelect. Ignore setting (951109)

;951109 	cmp	bh, 0			; Test for autoselect
;951109 	jne	SendInitWrite
;951109
;951109 	and	ax, 0fffdh
;951109SendInitWrite:

		mov	bx, ax
		mov	ax, 2
		call	reg_write

		; Delay for AutoSelect to stablize???
		mov	ax, 5
		call	StartTime

SentInitDelay:
		call	CheckTime
		jnc	SentInitDelay


SentInitISACR:
		xor	ax,ax		; set zero flag to indicate no error

SentInitEnd:	popa
		ret

SendInitErr:
;		mov	di, offset CGroup:ErrInit
;		mov	cs:StatusMsgFlag, di

		mov	ax,1
		or	ax,ax		; clear zf to indicate error
		jmp	SentInitEnd

SendInitBlock	endp

; ***** routines pasted directly from EEP15.INC

Delay_750	proc	near
	push	cx
	mov	cx, 8

DELAY_750_Lp:
	loop	DELAY_750_Lp

	pop	cx
	ret
Delay_750	endp

include EEP24.INC

UNDI	equ	1			; needed to conditionalize BWAMD.INC


include BWAMD.INC


_TEXT	ends




_DATA	segment	para public

; Data variables

LanOption   db  'LAN option: AMD PCnet - PCI II/PCnet - FAST Ethernet Adapter', CR, LF, 0

PCIBusDevFunc	dw	?
IntNum		db	?
ISRErrFlag	db	FALSE		; flag indicating if error condition is
TxRetryCnt	dw	1		; Number of times to retry transmit
StoreDS     dw  0

_DATA	ends





	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\bwamd.inc ===
;====================================================================
; BWAMD.INC - Generic Transmit, receive code for NE2100 and AT1500.
;		Based on AMD Ethernet Chipset
;
;;	 CONDITIONALS
;;	 /dGILBUG to generate debug version which prints all error cond
;;	 /dTSR	  for TSR version
;;
;;   (C) Lanworks Technologies Inc. 1992-1995 All rights reserved.
;;
;---------------------------------------------------------------------
; BWAMD.INC
;
; Date	 Ver	Dev	Comments
;
; 9701XX 1.XX GY    - fix problem when more than 800h packets are received
; 961022 1.XX GY    - support for Multicast/Broadcast reception in
;		      NADChgReceiveMask. Newer controller allows disable
;		      broadcast reception in CSR15
; 960206 1.60 GY    - packet size between 60 and 64 bytes are not transmitted
;			properly
; 950928 1.40 GY    - Split up AT1500 and NE2100. Both will share BWAMD.INC
;		      as the include file. Take out all Non AT1500 code
;
;---------------------------------------------------------------------

; used to Acknowledge the Interrupt from the controller,
; but disable further controller Interrupts until we service
; the current interrupt.
; writing a "1" to RINT, TINT and IDON should clear up the interrupt
ACKNOWLEDGEINT	equ (CSR0_INEA or CSR0_TDMD or CSR0_STOP or CSR0_STRT or CSR0_INIT)

; Stored in InterruptFlag to indicate type of interrupt serviced
INTRXANY	equ	0ffh		; Any receive interrupt
INTINIT 	equ	0100h		; Initialization done interrupt
INTTX		equ	0200h		; Transmit interrupt
INTINITERR	equ	0400h		; Initialization error
INTTXERR	equ	0800h		; Transmit Error
INTRXERR	equ	02000h		; Receive error
INTNO		equ	04000h		; No interrupt source
INTRXOVF	equ	08000h		; Rx buffers all used up
INTERR		equ	0fc00h		; any error



;include	 \rom\genr\include\nadcode.inc
;------------------------------------------------------------------------------
; StartTime - save maxtick count, get current tick value
;	Timeout is ticks, each tick is 55 ms.
;	Note: this routine can only be called once the PC timer
;	and its interrupt are setup (INT19 and beyond are OK)
;
; On entry,
;	AX = max ticks to wait
;	ints enabled
;
; On exit,
;	all preserved
;
; 881030 1.0 GK
;------------------------------------------------------------------------------

StartTime	proc	near

		push	ax
		push	cx
		push	dx
        push    di  
        push    es

		mov	DGroup:MaxTicks, ax
;;		mov	ah, 0
;;db  0f1h
;;		int	1Ah				; get current tick value
        mov     ax, 40h
        mov     es, ax
        mov     di, 6Ch
        mov     dx, es:[di]
        mov     cx, es:[di+2]
		mov	DGroup:StartTick, dx		; save it

        pop es
        pop di
		pop	dx
		pop	cx
		pop	ax
		ret

StartTime	endp

;------------------------------------------------------------------------------
; CheckTime - gets current tick value, compares with maxticks
;	Timeout is ticks, each tick is 55 ms.
;	Note: this routine can only be called once the PC timer
;	and its interrupt are setup (INT19 and beyond are OK)
;
; On entry,
;	maxticks set by StartTime
;	ints enabled
;
; On exit,
;	CY set if timeout
;	all registers preserved
;
; 881030 1.0 GK
;------------------------------------------------------------------------------

CheckTime	proc	near

		push	ax
		push	cx
		push	dx
        push    di  
        push    es

;;		mov	ah, 0
;;		int	1Ah			; get current tick

        mov     ax, 40h
        mov     es, ax
        mov     di, 6Ch
        mov     dx, es:[di]
        mov     cx, es:[di+2]

		sub	dx, DGroup:StartTick
		cmp	dx, DGroup:MaxTicks
		cmc

        pop es
        pop di
		pop	dx
		pop	cx
		pop	ax

		ret				; return with CY set if timeout

CheckTime	endp



;------------------------------------------------------------------------------
;	SetCardAddr
;	Function: Fetch the station address stored in the adapter's PROM. Called
;		  during initialization
;	Modify: NIDNetAddress - the station address is stored in the last
;				   six bytes of this variale
;	Remarks: There is no need to set the card address. The card will
;		automatically use the PROM's Ethernet address to
;		configure the board
;
;------------------------------------------------------------------------------

		assume	cs:CGROUP, ds:DGROUP

SetCardAddr	proc	near
		push	ax
		push	cx
		push	dx
		push	di

		mov	cx,6		; A total of 6 bytes are transferred
		mov	dx, DGroup:IOBase
		add	dx, REGADDR1
		push	ds
		pop	es
		mov	di, offset DGroup:Net_Address
SetCardLoop:	
        in	al,dx		; Fetch address from I/O port
		stosb			; Store address bytes
		inc	dx		; Next I/O port
		loop	SetCardLoop

		pop	di
		pop	dx
		pop	cx
		pop	ax
		ret
SetCardAddr	endp




;----------------------------------------------------------------------
;  Routine Name:  NADPoll Routine
;
;  Description: The NADPoll routine is used by the RIPL ROM NID
;		portion of the RIPL ROM to poll the driver portion so
;		that the driver portion can do timeout work.
;
;  Input:	DS - Data Segment of RPL Module
;		ints enabled
;
;  Output:	DS preserved
;		ints enabled
;
;  Calls:	none
;----------------------------------------------------------------------
NADPoll 	proc	far

		retf

NADPoll 	endp

;----------------------------------------------------------------------
;  Routine Name:  NADDisengage Routine
;
;  Description: The NADDisengage routine is used by the RIPL ROM NID
;		portion of the RIPL ROM to signal the Network Driver
;		to release its IRQ, DMA, and memory resources.
;
;  Input:	DS - Data Segment of RPL Module
;		ints enabled
;
;  Output:	DS preserved
;		ints enabled
;		ax = offset to error string or 0 if successful
;
;  Calls:	none
;
; July 10,91	implement NIDDisengage version 0.8
;----------------------------------------------------------------------

NADDisengage	PROC	FAR
		push	ds

		; reset card first
		mov	ax, CSR0_STOP
		mov	bl, CSR0
		call	CSROut

		cmp	ax,CSR0_STOP	; All the bits in CSR0 are cleared
					; except the stop bit
		jnz	NADDisErr	; Error if STOP bit not set

        cli
		; Mask interrupt level
		mov	dx, DGroup:MaskReg
;;		in	al, dx
        mov al, byte ptr DGroup:OldMaskReg
;;		or	al, DGroup:IRQLine
		out	dx, al

		; Problem with AT1500.DOS ver 1.32 when IRQ2 is used.
		; v1.32 driver install Interrupt Handler @ int ah rather
		; than int 71. Deinstall Handler and restore old vector will
		; solve the problem
		push	es
;;		mov	bx, DGroup:OldIntVector[2]	 ; segment
;;		mov	dx, DGroup:OldIntVector[0]   ; offset

		mov	    bx, DGroup:OrgIntVector_SEG	 ; segment
		mov	    dx, DGroup:OrgIntVector_OFF   ; offset

		xor	ax,ax
		mov	es,ax		; segment for vector address is 0
		mov	ax, DGroup:IntVect

;db  0f1h
		mov	di, ax
		mov	es:[di], dx
		add	di,2
		mov	es:[di], bx
		pop	es

        sti

;;        mov bx, 5
;;        call    csrIn
;;        mov     bx, ax
;;    	mov	dx, [IOBase]
;;    	add	dx, REGRESET
;;    	in	ax, dx		; start an S_RESET (takes 1us).

;;        test    bx, 2
;;        jz      @F
;;        call    AMD_enable_magic_packet

@@:
		xor	ax,ax		; indicate no error
		pop	ds
		retf			; Return to caller

NADDisErr:
		mov	ax, -1
		pop	ds

		retf

NADDisengage	ENDP


;------------------------------------------------------------------------------
;	SetupRing
;
;	Purpose : 1. Convert # of buffers to power of twos
;		  2. Convert dx from segment:offset to a 24 bit address
;	In :	ax = # of buffers
;		dx = pointer to buffer
;	Out:	ax = first byte of transmit descriptor ring pointer
;			Bit 15:13 Transmit ring length
;			Bit 7:0   high order byte of pointer to buffer
;		dx = second byte of transmit descriptor ring pointer
;			Bit 15:0  Lower word pointer to buffer
;	Remarks: follow sample in Diag_Sub.c (form_phy_address)
;		 follow sample in Diag_Sub.c (cal_num_rings)
;		 Used for setting up 1. CSR1 and CSR2
;				     2. Receive Descriptor ring pointer
;				     3. Transmit descriptor ring pointer
;	Assume : ax = 1,2,4,8,16,32,64 or 128 ( power of 2)
;
;------------------------------------------------------------------------------
SetupRing	proc	near
		push	bx
		push	cx
        push    di
;        push    ds

        
        mov ebx,    CR0
        test    bx, 1
        je      real_mode

; We are in protected mode:

;db  0f1h
        
;        xor     ebx,    ebx
;        mov     bx, ds
;        test    bx, 4h
;        je      gtxx
;        sldt    DGroup:LDT1
;        jmp short    @F
;gtxx:    
;        sgdt    DGroup:GDT
;@@:     
        mov     di, DGroup:StoreDS
        jmp short   @F
        
real_mode:

        mov     di, ds            
@@:
		cmp	ax,0
		jz	SetupRingZero	; No need to check if # of buffers = 0

		mov	bx,1
		mov	cx,7

SetupRingLoop:	test	bx,ax
		jnz	SetupRingMatch	; jump if match is found

		shl	bx,1		; move the bit left
		loop	SetupRingLoop

SetupRingMatch: not	cx

		sub	cx,not (7h)	; means 8 - cx
					; not(7h) = 2's complement of 8

		shl	cx, 13

; Detect what mode we are now :

;db  0f1h

;db  0f1h
		mov	ax, cx
;        mov bx, ds
;        push    ds
;        pop     cx
;        mov di, ds    
@@:
;		mov	ax, cx

SetupRingZero:	
        
        mov	bx, di		; move segment
		shr	bx, 12

		or	ax,bx


		mov	bx, di

		shl	bx, 4

		add	dx,bx		; add the offset and segment/16
		jnc	SetupRingEnd

		inc	ax		; overflow means increment segment

SetupRingEnd:	

;        pop ds
        pop di
        pop	cx
		pop	bx
		ret
SetupRing	endp

; --------------------------- ISR Routines  -------------------------------

;------------------------------------------------------------------------------
;	bootISR
;	Function : This ISR will service all interrupt. It services the host
;		   interrupt (EOI). It determines the type of interrupt and
;		   jump to the appropriate ISR. All errors in CSR0 will be
;		   stored in variable ISRErr
;
 ;	 Remarks :  Follow sample in INT_HAND.ASM (AT1500_isr)
;------------------------------------------------------------------------------
BootISR 	proc	far

;IFDEF	 DEBUG
;	push	ax
;	mov	al, '.'
;	call	PutChr
;	pop	ax
;
;ENDIF

;;db	 0F1h

		pusha
		pushf
		push	es
		push	ds

;		push	cs
;		pop	ds

		push	ds
		pop	es		; es=ds

		mov	bl, CSR0
		call	CSRIn


		; if nothing is set, don't do anything
;931019;ignore CSR0_CERR for AUI port		     test    ax, ( CSR0_INTR or CSR0_CERR )
		test	ax,  CSR0_INTR
		jz	BootISREnd

		; Acknowledge interrupt from controller
		; Clear INEA to disable interrupt until current interrupt is
		; serviced
		; Flags cleared include receive interrupt, transmitter interrupt
		; initialization done, babble flag, collision error, miss packet
		; memory error

		mov	bx,ax		; have 2 copies of CSR0
		and	ax,not ACKNOWLEDGEINT
		mov	dx, DGroup:IOBase
		add	dx, REGRDP
		out	dx,ax		; still CSR0
		in	ax,dx		; follow all write with read

		mov	ax,bx		; restore CSR0 to ax


		test	bx,CSR0_MERR
		jz	BootChkTx	; Jump if no error

		mov	ax,DGroup:InterruptFlag
		or	ax, INTERR	 ; all error bits are set
		mov	DGroup:InterruptFlag,ax

		mov	DGroup:ISRErr,bx
		mov	DGroup:ISRErrFlag,TRUE
		jmp	BootEnableInt

BootChkTx:	; determine what type of interrupt it is and call appropriate
		; ISR
;931019;ignore CSR0_CERR for AUI port		     test    bx,(CSR0_TINT or CSR0_BABL or CSR0_CERR )
		test	bx,(CSR0_TINT or CSR0_BABL )

		jz	BootChkRecv	; Is it a transmit interrupt

		call	TxISR

BootChkRecv:	test	bx,(CSR0_RINT or CSR0_MISS) ; Is it a receive interrupt
		jz	BootChkInit

		call	RecvISR
        jnc     @F
        mov     DGroup:ReceiveError, 1
;	 int 03
@@:
BootChkInit:	test	bx,CSR0_IDON
;970527 	jz	BootEnableInt
		jz	BootChkUInt

		mov	ax,bx		; ax now has CSR0
		test	ax,CSR0_ERR
		jz	BootInitOK

		mov	ax, DGroup:InterruptFlag
		or	ax, INTINITERR
		mov	DGroup:InterruptFlag,ax
		jmp	BootEnableInt

;970527
BootChkUInt:				; see if it's a user-interrupt
		mov	bl, CSR4
		call	CSRIn		; b6, UINT will be set if so
		test	ax, 0040h
		jz	BootEnableInt	; not a user interrupt

; clear the user interrupt by writing a 1 back to b6 of CSR4

;    	db  0F1h
		call	CSROut
;		jmp	short BootEnableInt
;		jmp	short ReallyOk
;970527

BootInitOK:
;		mov	    bl, CSR4
;		call	CSRIn
;	test	ax, CSR4_UINT
;	jz	ReallyOk
;	jz	BootEnableInt
;	int	03

;ReallyOk:
		mov	ax,DGroup:InterruptFlag
		or	ax, INTINIT
		mov	DGroup:InterruptFlag,ax
					; There is no need to do any processing
					; for initialization done interrupt


BootEnableInt:
		mov	al,EOI
		out	20h,al		; Master Controller
		mov	dx,DGroup:MaskReg	; Get (0cw0) mask register address
		cmp	dx,021h
		jz	MasterCnt
					; al still contains EOI
		out	0a0h,al 	; Slave controller

MasterCnt:
; For some reason, interrupt is masked 961216 {
		mov	ah,DGroup:IRQLine
		not	ah

		mov	dx,DGroup:MaskReg	; Address of mask register
		in	al,dx		; Get old mask byte
		and	al,ah		; unmask the correct bits
		out	dx,al		; Enable the interrupt
; For some reason, interrupt is masked 961216 }


		; Need to enable interrupt again
		mov	bl, CSR0
		mov	ax, CSR0_INEA
		call	CSROut

BootISREnd:
		pop	ds
		pop	es
		popf
		popa
		iret
BootISR 	endp

;------------------------------------------------------------------------------
;	TxISR
;	Purpose : Interrupt service routine for transmit
;	On entry,	bx = CSR0 status
;------------------------------------------------------------------------------
TxISR		proc	near

;;db	 0F1h

;	 int	 03
		push	bx
;931019;ignore CSR0_CERR for AUI port		     mov     ax,bx
;931019;ignore CSR0_CERR for AUI port		     test    ax,CSR0_ERR
;931019;ignore CSR0_CERR for AUI port		     jnz     TxISRErr	     ; CSR0 indicates error

		mov	ax,DGroup:TxMsgBlock[0].TxTmd1
		test	ax,Tmd1Own
		jnz	TxISRErr	; Did card give up ownership

		test	ax,Tmd1Err	; check for error
		jnz	TxISRErr	 ; Error indicated in Tmd1??

		; Pass all the error testing
		mov	ax,DGroup:InterruptFlag
		or	ax, INTTX
		mov	DGroup:InterruptFlag,ax; Check for other interrupts rather
					; than jumping to exit routine
IFDEF		GILBUG
		push	ax
		mov	ax,0e20h	; print " "
		int	010h
		mov	ax,0e54h	; print "T"
		int	010h
		mov	ax,0e54h	; print "T"
		int	010h
		mov	ax,0e20h	; print " "
		int	010h
		pop	ax

ENDIF
		jmp	TxISREnd

TxISRErr:	mov	ax,DGroup:InterruptFlag; set transmit error flag
		or	ax, INTTXERR
		mov	DGroup:InterruptFlag,ax

TxISREnd:	pop	bx
		ret
TxISR		endp

;------------------------------------------------------------------------------
;	RecvISR
;	Purpose : Interrupt service routine for receive
;		  check if packet received is a broadcast. If so, reject packet
;	On entry,	bx = CSR0 status
;	Exit	       ; z flag set	 means broadcast or error
;		       ; z flag cleared  means not broadcast
;------------------------------------------------------------------------------
RecvISR 	proc	near


;	 int	 03
		push	bx
		push	ax
		push	cx
		push	dx


;IFDEF	 DEBUG
;	push	ax
;	mov	al, '~'
;	call	PutChr
;	pop	ax
;
;ENDIF

		; if AM7990 MISS a packet, just quit without getting and
		; returning an ED
		test	bx, CSR0_MISS
        jz  @F
;;;db  0f1h
		jmp short	RxISRErrJmp
;;		jnz	RxISRErrJmp

@@:
NextBuffer:
		; the offset for Rmd1 is determined by the InterruptFlag not
		; RecvRingOffset
		push	di
		push	cx
		xor	cx,cx
		push	bx

		mov	bx, NumRxBuf	; used to check if RecvIntCount is
					; multiple of 8
		xor	dx, dx
		mov	ax, DGroup:RecvIntCount

		div	bx
		mov	ax, dx		; move reminder to AL
		or	ax, ax		; is RecvIntCount multiple of NumRxBuf?
		pop	bx
		jz	RecvISRFoundOff

RecvISRSub:	add	cx, RINGSIZE
		dec	al
		jz	RecvISRFoundOff

		jmp	RecvISRSub

RxISRErrJmp:	jmp	RxISRErr	; Jump


RecvISRFoundOff:
		mov	di, offset DGROUP:RxMsgBlock[0].RxRmd1

		add	di,cx
		pop	cx
		mov	ax,ds:[di]
		pop	di

		test	ax, Rmd1Own
        jz  @F
        
;;;db  0f1h
		jmp short	RxISRErrJmp
;;		jnz	RxISRErrJmp	; Did card give up ownership

@@:
		test	ax,  Rmd1Fram or Rmd1Crc or Rmd1BufErr
;		mov	ax,1		; indicate not a broadcast
        jz  @F

;;db  0f1h
;;		jmp short	RxISRErrJmp
;;		jnz	RxISRErrJmp
        mov     DGroup:ReceiveError, 1

@@:
		; 970225 NCR sees problem where RMD1.ENP is not set
		; even though all my buffers are MTU and error bits
		; should be set
ChkEndofPacket:
		test	ax, Rmd1End
		jnz	Rmd1EndOk

		inc	DGroup:RecvIntCount
		jmp	NextBuffer

Rmd1EndOk:
		; Check if this is the first packet received
		mov	ax, DGroup:RecvIntCount
		or	ax, ax
		jnz	RecvNotFirst

		mov	ax, DGroup:InterruptFlag
		or	dx, INTRXANY
		mov	DGroup:InterruptFlag, ax
		jmp	ProcessRecv


RecvNotFirst:	; confusing part. The buffer offset RecvBufOffset,
		; RecvRingOffset, UpdateBufOff and UpdateRingOff are manipulated
		; so that the PROM will have access to a "continuous" supply
		; of receive buffers.
		; See notes on January 6,92
		; Packet #0-5	increment RecvBufOffset, RecvRingOffset
		; Packet #6,7,9 increment RecvBufOffset, RecvRingOffset
		;		increment UpdateBufOffset, UpdateRingOffset
		; Packet #8	set to 0  RecvBufOffset, RecvRingOffset
		;		increment UpdateBufOffset, UpdateRingOffset
		; Packet #14	increment RecvBufOffset, RecvRingOffset
		;		set to 0  UpdateBufOffset, UpdateRingOffset
		;
		mov	cx, NumRxBuf	; should be 8
		xor	dx, dx
		mov	ax, DGroup:RecvIntCount
		cmp	ax, 6
		jb	RecvPktB6	; jump if less than 6 packets received

		div	cx
		or	dx, dx		; is remainder 0 ?
		jz	RecvPkt8	; need to reset receive buffer pointers

		xor	dx, dx
		mov	ax, DGroup:RecvIntCount
		sub	ax, 6
		div	cx
		or	dx, dx		; is remainder 0 ?
		jz	RecvPkt14	; need to reset update buffer pointers

		; For any other packets, we update buffers for both RecvBuf
		; & UpdateBufOff
		add	DGroup:RecvBufOffset, PACKETSIZE
		add	DGroup:RecvRingOffset, RINGSIZE
		add	DGroup:UpdateBufOff, PACKETSIZE
		add	DGroup:UpdateRingOff, RINGSIZE
		call	ReleaseBuffer
		jmp	short ProcessRecv

RecvPkt14:	; packet # - 6 is a multiple of 8
		add	DGroup:RecvBufOffset, PACKETSIZE
		add	DGroup:RecvRingOffset, RINGSIZE
		mov	DGroup:UpdateBufOff, 0
		mov	DGroup:UpdateRingOff, 0
		call	ReleaseBuffer
		jmp	short ProcessRecv

RecvPkt8:	; Packet # is a multiple of 8
		mov	DGroup:RecvBufOffset, 0
		mov	DGroup:RecvRingOffset, 0
		add	DGroup:UpdateBufOff, PACKETSIZE
		add	DGroup:UpdateRingOff, RINGSIZE
		call	ReleaseBuffer
		jmp	short ProcessRecv

RecvPktB6:	; below packet # 6
		add	DGroup:RecvBufOffset, PACKETSIZE
		add	DGroup:RecvRingOffset, RINGSIZE

ProcessRecv:	; fetch an ED for the received packet


        cmp DGroup:ReceiveError, 1
        jne @F 

		pushf
		inc	DGroup:RecvIntCount
		popf
        jmp short RxISRErr
        
@@:

		push	bx
		xor	ax, ax
    	call	GetED

		pop	bx
		mov	word ptr DGroup:RxEDPtr, si
		mov	word ptr DGroup:RxEDPtr+2, es
;        clc
;;        jnz   @F
;;db  0f1h
		jz    RxISRErr
;@@:
;	 int	 03

		call	PacketReceived
		pushf
		inc	DGroup:RecvIntCount
		popf
		jnc	RecvISREnd

;;ReturnED:

;;db  0f1h    

;;		les	si, ds:RxEDPtr
;;		push	bx
;;    	call	ReturnED
;;		pop	bx
;;        jz	RxISRErr
RxISRErr:

;;db  0f1h    

        stc

IFDEF		GILBUG

		mov	ax,InterruptFlag; set receive error flag
		or	ax,IntRxErr
		mov	InterruptFlag,ax
		jmp	RecvISREnd
ENDIF

RecvISREnd:  ;;;	 or	 ax,ax		 ; set zero flag
		pop	dx
		pop	cx
		pop	ax
		pop	bx
		ret
RecvISR 	endp

;------------------------------------------------------------------------
;
; SYNOPSIS:	call PacketReceived
;
; ON ENTRY:	bx - address of RBD containing packet
;		es = CGROUP
;
; DESCRIPTION:	This routine is called by the interrupt handler to
;		hand the packet off to the next higher level.
;
;
; REGISTERS:	bx, ds saved; others destroyed
;
; RETURNS:	carry set = error , return ED unchanged
;		carry clear = no error
;
; CALLED BY:	ProcessFRInt
;
; 881101 1.0 George Kostiuk
;------------------------------------------------------------------------
public		PacketReceived
PacketReceived	proc	near

;int 03

		; set up segment registers so that
		; es = segment of ED
		; ds = segment where ROM Code is
		; cs = segment where ROM Code is
;		push	cs
;		pop	ds
		assume	ds:DGROUP

		; Make sure packet is not a broadcast (check dest address)
		; temporarily set ES=CS
        cld
ChkAddress:
		push	ds      ;  !!!!!!!!!!!!!!! cs
		pop	es
		mov	si, offset DGroup:RxPacket[0].DestAddr[0]

		add	si, DGroup:RecvBufOffset
		mov	bx, si			; save pointer to packet in bx also
		jmp	short OkAddress

ReturnRxEDJmp:
		jmp	ReturnRxED


OkAddress:

; Cannot use MAC header length for Eth II PROMs ( bootP & NW_EthII )
; Use the Rmd3	 instead
		mov	si, offset DGroup:RxMsgBlock.RxRmd3
		add	si, DGroup:RecvRingOffset
		lodsw
		and	ax, 0fffh

		mov	dx,ax			; MAC Length

		mov	DGroup:PacketLen, ax

		les	bp, DGroup:RxEDPtr		; ES:BX point to ED


		mov	es:[bp].ED_Length, dx	 ; Set good completion
		mov	cx, es:[bp].ED_FragCount
		jcxz	NoRxFrag		; there are no fragments

; setup source ptr (points to data in packet past the header)
		lea	si, [bx]
		lea	bp, [bp].ED_FragOff	; point to 1st descriptor
		push	bx

DRxNxtF:
    	push	cx
		push	es
		mov	cx, es:[bp].DLen	; CX has frag len

        
        mov di, WORD PTR es:[bp].DPointer
;		les	di, es:[bp].DPointer	; ES:DI ptr to frag



ChkMovSize:	
        cmp	dx, cx
		ja	MoveFrag	; more data after this frag

		mov	cx, dx		; no more data after this frag

MoveFrag:	sub	dx, cx		; subtract size of this frag
		jcxz	DrxDoNxt	; zero count -- skip data read

		rep	movsb		; move data from card to ED

DrxDoNxt:	pop	es
		pop	cx
		add	bp, 6		; point to next fragment desc
		loop	DRxNxtF 	; do next frag, if any

		pop	bx

; -- DX has # of bytes that couldn't fit in receive descriptors

NoRxFrag:	
;        push	cs
;		pop	ds			; DS = CS
		assume	ds:DGROUP
IFDEF		DEBUG
		int	3
ENDIF

		push	ds
		les	si, DGroup:RxEDPtr
		mov	es:[si].ED_ErrCode, 0	; Set good completion
		; Generic routines need ds=code segment
;		push	cs
;		pop	ds
		push	bx


;	 int	 03
;	call	PostED

		pop	bx
		pop	ds

		clc			; indicate no problem

IFDEF		GILBUG
		push	ax
		mov	ax,0e20h	; print " "
		int	010h
		mov	ax,0e52h	; print "R"
		int	010h
		mov	ax,0e52h	; print "R"
		int	010h
		mov	ax,0e20h	; print " "
		int	010h
		pop	ax
ENDIF

		ret

ReturnRxED:	stc			; indicate error
		ret

PacketReceived	endp

;----------------------------------------------------------------------
; Routine Name: ReleaseBuffer
;
; Description: Release the buffer pointed by UpdateBufOff and UpdateRingOff
;	       by setting the Ownership bit in RMD1. This allows the
;	       AMD access to a continuous streams of buffers for packets
;----------------------------------------------------------------------
ReleaseBuffer	proc	near
		push	ax
		push	di
		mov	di, offset DGroup:RxMsgBlock[0].RxRmd1
		add	di, DGroup:UpdateRingOff
		mov	ax, ds:[di]
		or	ax, DGroup:RxMsgMode	; set ownership bit
		mov	ds:[di], ax
		pop	di
		pop	ax
		ret
ReleaseBuffer	endp

; --- Transmit Routines -----------------------------------

;----------------------------------------------------------------------
;  Routine Name:  NADTransmitPacket Routine
;
;  Description: The NADTransmitPacket Routine accepts all directed
;		send requests from the RIPL ROM NID code.  This
;		routine determines the validity of the request and
;		works with the adapter to carry it out.
;
;  Input:	ES:SI - pointer to ED
;		DS - Data Segment of RPL Module
;		ints disabled (spec says enabled)
;
;  Output:	ED Completion Code field updated
;		DS preserved
;		ints enabled (doesn't matter)
;
;  Calls:	TransmitPacket
;----------------------------------------------------------------------

		PUBLIC	NADTransmitPacket
NADTransmitPacket	 PROC	near

;int 03        

;931021SkipDefer:
;db  0f1h
		push	ds
		pushf
		sti			; interrupt should be enabled

;	 int  03

		mov	word ptr DGroup:TxEDPtr, si	; save Tx ED ptr
		mov	word ptr DGroup:TxEDPtr+2, es

		mov	ax, TIME100MS
		call	StartTime

		; Reset card before doing anything
		mov	ax, CSR0_STOP
		mov	bl, CSR0
		call	CSROut

		mov	dx, DGroup:IOBase
		add	dx, REGRDP

		mov	ax, TIME100MS
		call	StartTime

NetSendReset:	;mov	 dx,IORDP	 ; read register back
		in	ax,dx
		cmp	ax,(CSR0_STOP)
		jz	TxResetOK	; Jump if reset is Okay

		call	CheckTime
		jnc	NetSendReset	; check status again if not timeout

TxResetOK:
		; clear StatusMsgFlag
		mov	DGroup:[StatusMsgFlag],0
		mov	DGroup:InterruptFlag,0
		mov	DGroup:RecvBufOffset,0
		mov	DGroup:RecvRingOffset,0
		mov	DGroup:ISRErrFlag,FALSE; Clear flag
		mov	DGroup:RecvIntCount,0	; indicate which RxPacket buffer is used

		; set up segment registers so that
		; ds = segment of ED
		; es = segment where ROM Code is
		; cs = segment where ROM Code is
;		push	es
;		pop	ds
		push	ds  ; !!!!!!!!!!!!!! es !!!!!!!!!!!!!!!
		pop	es
		assume	es:DGROUP

;  Now, get the ED pointer to the transmit data buffer descriptor and
;  verify the fields contained in it.

		mov	ax, INVALID_PARAMETER	; Set error code
		mov	cx, ds:[si].ED_FragCount   ; Get data count
		jcxz	SetEDCCodeJmp		; err if total # of ptrs = 0

		jmp	short GetDataLen ; temp

SetEDCCodeJmp:	; when there is an error, post ED now with return code
		; set appropriately
		lds	si, DGroup:TxEDPtr
		mov	ds:[si].ED_ErrCode, ax	; Set return code
		push	ds			; es = ED segment
		pop	es
;		push	cs			; Set DS = CS
;		pop	ds			;
		jmp	TransmitEnd

GetDataLen:	;  Get total data size in AX by adding up frame descriptors
		xor	ax, ax
		lea	bx, [si].ED_FragOff	; point to first framedesc

SumDataLen:
		add	ax, ds:[bx].DLen
		add	bx, size Descript_Struct ; next descriptor
		loop	SumDataLen

		mov	DGroup:PacketLen,ax
		push	ax			; save packet size for later use
		cld					; Clear direction
		mov	di, offset DGroup:TxPacket


; Ethernet packets must contain at least 46 bytes of data or they will
; be rejected as runt packets.	If the packet to be transmitted is less
; than 46 bytes, it will be padded to 46, but the length field will
; still indicate the number of valid bytes.


		pop	ax			; get packet size back

		lds	bx, DGroup:TxEDPtr
		mov	cx, ds:[bx].ED_FragCount   ; Get fragment count
		lea	bx, [bx].ED_FragOff	; point to first framedesc

Tx_Frag_Loop:
		push	cx			; save fragment count
		push	ds			; save fragment descriptor list segment
		mov	cx, ds:[bx].DLen	; length of this fragment

;        mov si, WORD PTR ds:[bx].DPointer

		lds	si, ds:[bx].DPointer	; location of this fragment
		rep	movsb

Tx_Frag_End:	pop	ds			; restore frag descriptor list segment
		pop	cx			; restore fragment count
		add	bx, size Descript_Struct ; next descriptor
		loop	Tx_Frag_Loop		; loop through all fragments

		call	RealTransmit

TransmitEnd:
		popf
		pop	ds
        clc
        or  ax, ax
        jz  @F
        stc
@@:
		sti			; enable interrupt before exit
;;db	 0F1h
		ret			; Return to caller

NADTransmitPacket	 ENDP

;------------------------------------------------------------------------------
;	RealTransmit
;	Purpose : Set ownership of Tx buffers and force transmission to happen
;
;	Exit	zf set = error recorded in CSR0
;		zf cleared = no error recorded by CSR0
;------------------------------------------------------------------------------
RealTransmit	proc	near

IFDEF		GILBUG
	mov	al, '~'
	push	bx
	mov	ah, 0Eh
	mov	bx, 0007h		; page 0, normal
	int	10h			; Write TTY

	mov	al, '~'
	mov	bx, 0007h		; page 0, normal
	int	10h			; Write TTY
	pop	bx
ENDIF

;db  0F1h
;int 03

;db  0f1h


		mov	DGroup:TxRetryCnt, 1


Do_Tx:		; DS doesn't have to point to ED anymore
;		push	cs
;		pop	ds

		; One buffer is enough for transmit (always)
		mov	DGroup:TxMsgMode,(Tmd1Start or Tmd1End)
		mov	ax,0
		mov	dx, offset DGroup:TxPacket
;int 03
		call	SetupRing
		mov	DGroup:TxMsgBlock[0].TxTmd0,dx
		or	ax,DGroup:TxMsgMode
		mov	DGroup:TxMsgBlock[0].TxTmd1,ax
		mov	ax, DGroup:PacketLen	 ; Get data count

		cmp	ax, 60
		jae	NetSendLenOK

		; documentation is wrong (minimum size should be 60 )
		; 64 bytes include checksum also
		mov	ax, 60

NetSendLenOK:	neg	ax		; put 2's comp. of size in Tmd2
		or	ax,0f000h	; make sure first nibble is all ones
		mov	DGroup:TxMsgBlock[0].TxTmd2,ax
		; clear bits in Tmd3
		xor	ax,ax
		mov	DGroup:TxMsgBlock[0].TxTmd3,ax


		; setup receive buffer before initializing card
		; need to initialize 8 buffers
		mov	cx, NumRxBuf
		mov	DGroup:RecvBufOffset,0 ; Clear flags
		mov	DGroup:RecvRingOffset,0;

;db	 0F1h

NetSendRBuf:	push	cx
		mov	DGroup:RxMsgMode,Rmd1Own ; setup mode register
		mov	ax,0
		mov	dx, offset DGROUP:RxPacket[0]
		add	dx,DGroup:RecvBufOffset ; for multiple buffer
		call	SetupRing

		push	di
		mov	di, offset DGROUP:RxMsgBlock[0].RxRmd0
		add	di,DGroup:RecvRingOffset
		mov	ds:[di],dx
		pop	di

		push	di
		lea	di,DGroup:RxMsgBlock[0].RxRmd1
		add	di,DGroup:RecvRingOffset
		mov	ds:[di],ax
		pop	di
		mov	ax,PACKETSIZE	; adequate for any packet
		neg	ax			; put 2's comp. of size in Tmd2
		or	ax,0f000h	; make sure first nibble is all ones

		push	di
		lea	di,DGroup:RxMsgBlock[0].RxRmd2
		add	di,DGroup:RecvRingOffset
		mov	ds:[di],ax
		pop	di

		push	ax
		push	di
		xor	ax,ax
		lea	di,DGroup:RxMsgBlock[0].RxRmd3
		add	di,DGroup:RecvRingOffset
		mov	ds:[di],ax
		pop	di
		pop	ax
		add	DGroup:RecvBufOffset,PACKETSIZE
		add	DGroup:RecvRingOffset,RINGSIZE
		pop	cx
		loop	NetSendRBuf

;db	 0F1h

		mov	DGroup:RecvBufOffset,0 ; initialize offset back to zero
		mov	DGroup:RecvRingOffset,0; initialize offset back to zero

		; Send initialization block
;961028 	mov	InitialBlock.InitMode,0 ; Enable receive & transmit
		mov	ax, CSR15Broad
		mov	DGroup:InitialBlock.InitMode, ax ; Enable receive & transmit
		mov	DGroup:BusInterface,0
		mov	DGroup:CSR0Cmd,(CSR0_INEA or CSR0_INIT)
		mov	di, offset DGROUP:RxMsgBlock[0]
		mov	si, offset DGROUP:TxMsgBlock[0]
;int 03
;;db	 0F1h
		call	SendInitBlock
;;db	 0F1h
		jz	NetSendTxmit	;transmit packet if initialize successful

		dec	DGroup:TxRetryCnt
		jz	TxmitBadCodeJmp

		jmp	Do_Tx		; ReTry if initialization fails

TxmitBadCodeJmp: jmp	 TxmitBadCode

NetSendTxmit:
		mov	ax,DGroup:TxMsgBlock[0].TxTmd1 ; give ownership of buffer to
		or	ax,Tmd1Own		; adapter
		mov	DGroup:TxMsgBlock[0].TxTmd1,ax

		; in multiple buffer mode, need to give control of all buffers
		; to card

		mov	DGroup:RecvRingOffset,0	; make sure offset is zero
		mov	cx, NumRxBuf
TxmitRxBuf:	push	di
		lea	di,DGroup:RxMsgBlock[0].RxRmd1
		add	di,DGroup:RecvRingOffset
		mov	ax,ds:[di]
		or	ax,DGroup:RxMsgMode
		mov	ds:[di],ax
		pop	di

		add	DGroup:RecvRingOffset,RINGSIZE
		loop	TxmitRxBuf

		mov	DGroup:RecvRingOffset,0

;;db  0f1h

		mov	ax,(CSR0_INEA or CSR0_STRT )
		mov	bl, CSR0
		call	CSROut

		sti			; enable interrupt

		mov	ax, TIME100MS
		call	StartTime

TxmitPacLoop:	mov	ax,InterruptFlag

;db  0f1h

		test	ax, INTTXERR
		jnz	TxmitPacErr

		test	ax, INTTX
		jnz	TxmitPacOK

		cmp	DGroup:ISRErrFlag, TRUE
		jz	TxmitMERR

		call	CheckTime
		jnc	TxmitPacLoop

		jmp	short TxmitPacErr

TxmitPacOK:
		les	si, DGroup:TxEDPtr
;		push	cs
;		pop	ds
		; Set return code to successful
		mov	es:[si].ED_ErrCode, SUCCESSFUL
		xor	ax,ax		; indicate no error

TxmitPacEnd:	or	ax,ax
		ret

TxmitPacErr:	; ask user to check cable connection

;;db  0f1h
		les	si, DGroup:TxEDPtr
;		mov	di, offset CGROUP:ErrTx
;		mov	DGroup:StatusMsgFlag, di		; used for RPL
		mov	es:[si].ED_ErrCode, TRANSMIT_ERROR
;		mov	es:[si].ED_ErrMsg, offset CGROUP:ErrTx

		les	si, TxEDPtr
;		push	cs			; Set DS = CS = ES
;		pop	ds			;
		; Set return code to indicate error
		mov	es:[si].ED_ErrCode, TRANSMIT_ERROR

		mov	ax,1		; indicate error
		jmp	TxmitPacEnd

TxmitBadCode:	

;;;db  0f1h

        les	si, TxEDPtr
;		push	cs			; Set DS = CS = ES
;		pop	ds			;
		; Set return code to indicate error
		mov	es:[si].ED_ErrCode, TRANSMIT_ERROR
;		mov	es:[si].ED_ErrMsg, offset DGROUP:ErrTx1

		mov	ax,1		; indicate error
		jmp	TxmitPacEnd

TxmitMERR:	les	si, DGroup:TxEDPtr
;		push	cs			; Set DS = CS = ES
;		pop	ds			;
		; Set return code to indicate error
		mov	es:[si].ED_ErrCode, GENERAL_FAILURE
;		mov	es:[si].ED_ErrMsg, offset DGROUP:ErrTx2

		mov	ax,1		; indicate error
		jmp	TxmitPacEnd

RealTransmit	endp

FlushRxBuffer	proc	near
ClearRecvBit	proc	near
		ret
ClearRecvBit	endp
FlushRxBuffer	endp


; ----------------- Initialize routines -------------------------------

;------------------------------------------------------------------------------
;	SetupInt
;
;	Purpose : Setup variables related to interrupt lines and mask registers
;		  The old interrupt vector is saved and the interrupt level is
;		  in IntNum. A new interrupt vector is given to the system.
;		  The interrupt is also enabled (unmasked )
;	Remarks : follow sample in DIAG_SUB.C (SetupIntVar)
;		  follow sample in INT_Hand.asm (save_int_vec)
;		  follow sample in INT_HAND.ASM (enable_int_vec)
;
;------------------------------------------------------------------------------
public		SetupInt
SetupInt	proc	near
		pusha
		xor	cx, cx
		mov	DGroup:MaskReg, 021h	; assume Master PIC first
		mov	DGroup:IntVect, 020h	; base vector address for Master PIC
		mov	al,DGroup:IntNum
		mov	cl,DGroup:IntNum

		cmp	al, 8
		jb	MaskRegOk

		sub	cl, 8
		mov	DGroup:MaskReg, 0a1h

;;		in	al, 0A1h		; get slave PIC mask
;;		jmp	$+2
;;		and	al, 0fdh		; unmask int 9
;;		out	0A1h, al

		mov	DGroup:IntVect, 01C0h	; base vector address for slave PIC

MaskRegOk:	; Setup  IRQLine
		mov	bl, 1
		shl	bl, cl
		mov	DGroup:IRQLine, bl
		shl	cl, 1
		shl	cl, 1		; multiply bl by 4
		add	DGroup:IntVect, cx	; get correct vector address

SetupIntSave:
	       ; Store old pointer and place new pointer in int. vector
		cli			; disable interrupt

		push	es
		push	si
		xor	ax,ax
		mov	es,ax		; segment for vector address is 0
		mov	ax,DGroup:IntVect

		mov	si,ax
		mov	bx,es:[si]
		add	si,2
		mov	ax,es:[si]
		mov	es,ax

		mov	DGroup:OrgIntVector_OFF,bx ; old interrupt pointer is stored in
		mov	DGroup:OrgIntVector_SEG,es ; this variable

;;		mov	DGroup:OldIntVector,bx ; old interrupt pointer is stored in
;;		mov	DGroup:OldIntVector[2],es ; this variable

		xor	ax,ax
		mov	es,ax

		sub	si,2

;;db  0f1h

IFDEF	UNDI
		mov	dx, offset CGroup:UNDI_DriverISR
ELSE
		mov	dx, offset CGROUP:BootISR
ENDIF
		mov	es:[si],dx
		add	si,2
		mov	es:[si],cs

		pop	si
		pop	es

		mov	ah, DGroup:IRQLine
		not	ah

;;		in	al, 0A1h		; get slave PIC mask
;;		jmp	$+2
;;		and	al, 0fdh		; unmask int 9
;;		out	0A1h, al


		mov	dx, DGroup:MaskReg   ; Address of mask register
		in	al, dx		; Get old mask byte
        mov byte ptr DGroup:OldMaskReg, al
		and	al, ah		; unmask the correct bits
        cmp dx, 0A1h
        jne @F
        and al, 0FDh
@@:
		out	dx,al		; Enable the interrupt

		cmp    dx, 21h		  ; are we using IRQ from slave?
		je     HookIntVectorExit		 ; no

		in     al, 21h		  ; yes, turn on cascaded input
		and    al, not 04			  ;  on master 8259
		out    21h, al

HookIntVectorExit:

		sti			; enable interrupt
		xor	al,al		; set zero flag to indicate no error

SetupIntEnd:
		popa
		ret
SetupInt	endp

IFNDEF	UNDI
;------------------------------------------------------------------------------
;	EnableDmaCascade
;	Purpose : Puts the DMA controller into cascade mode (16 bit)
;
;	Remarks : follow sample in DMA_Util.c
;------------------------------------------------------------------------------

EnableDmaCascade       proc    near

		cmp	DGroup:DmaNum, 4
		jae	Set16BitDma

		mov	bx, 0Ah 	; 8-bit mask reg
		mov	cx, 0Bh 	; 8-bit mode reg
		jmp	short DoDmaInit

Set16BitDma:
		mov	bx, 0D4h	; 16-bit mask reg
		mov	cx, 0D6h	; 16-bit mode reg

DoDmaInit:
		mov	ah, DGroup:DmaNum
		and	ah, 00000011b	; keep only b1 b0
		mov	al, ah
		or	al, 00000100b	; set the mask bit
		mov	dx, bx
		out	dx, al
		mov	al, ah		;  DmaNum AND 03
		or	al, 11010000b	; set cascade mode
		mov	dx, cx
		out	dx, al
		mov	al, ah		; DmaNum AND 03
		mov	dx, bx
		out	dx, al		; clear the mask bit
		ret
EnableDmaCascade	endp
ENDIF	; IFNDEF UNDI

;----------------------------------------------------------------------------;
; NADChangeReceiveMask - Called by NAD to change the receive mask of adapter.
;
; Input:	bl	  command
;		b0: set   = enable
;		    clear = disable
;		b1: enable/disable broadcast reception on the NIC based on b0
;		b2: enable/disable multicast reception on the NIC based on b0
;		    ES:DI is ignored.
;		b3: Change Multicast Address Table
;			if b0 is set, ES:DI will point to the multicast address to add
;			if b0 is cleared, ES:DI will point to multicast address to delete.
;			if b0 is cleared and ES:DI = 0:0, clear whole Multicast Table
;		b4: enable/disable promiscuous reception on the NIC based on b0
;
;		es:di pointer to multicast address
;
; no reg. changed
;----------------------------------------------------------------------------;
NADChangeReceiveMask	proc	far

;    int 03

	; ** This routine DOESN'T support Deleting a particular  **
	; ** Multicast Address **

	test	bl, 2			; want to change Broadcast?
	jnz	NADChgBroad

	test	bl, 4			; want to change Multicast?
	jnz	NADChgMulti

	test	bl, 8			; want to change Multicast Table?
	jz	NADChgMaskEnd

NADMTable:
	test	bl, 1
	jnz	NADMTableAdd

NADMTableClear:
	; Only support clearing whole table
	mov	ax, es
	cmp	ax, 0
	jnz	NADChgMaskEnd

	cmp	di, 0
	jnz	NADChgMaskEnd

	push	ds
	pop	es

	; clear both MCastTable and LADRF
	mov	di, offset DGroup:MCastTable
	xor	ax, ax
	stosw
	stosw
	stosw

	mov	di, offset DGroup:LADRF
	stosw
	stosw
	stosw
	stosw
	jmp	short NADChgMaskEnd

NADMTableAdd:

	call	Set_Multicast_List
	add	bx, offset DGroup:LADRF
	or	byte ptr [bx], al
	jmp	short NADChgMaskEnd

NADChgMulti:
	mov	LADRFPtr, offset DGroup:LADRF

	test	bl, 1
	jnz	NADChgMaskEnd

NADChgMultiOff:
	mov	LADRFPtr, offset DGroup:LADRFDisable
	jmp	short NADChgMaskEnd

NADChgBroad:
	mov	ax, DGroup:CSR15Broad
	test	bl, 1
	jz	NADChgBroadOff

NADChgBroadOn:

	and	ax, 0bfffh		; clear bit 14
;	or	ax, 04000h		; set bit 14
	mov	DGroup:CSR15Broad, ax
	jmp	short NADChgMaskEnd

NADChgBroadOff:
	or	ax, 04000h		; set bit 14
;	and	ax, 0bfffh		; clear bit 14
	mov	DGroup:CSR15Broad, ax

NADChgMaskEnd:
    clc
	retf

NADChangeReceiveMask	   endp


;----------------------------------------
; Set_Multicast_List
;
; enter with ES:DI ->multicast address
; returns:	bx	offset from LADRF (# of bytes)
;		ah	bit in LADRF to set/clear
;----------------------------------------
;
POLYL	equ	1DB6h			; CRC polynomial coefficients
POLYH	equ	04C1h			;

Set_Multicast_List	proc	near

	mov	ax, 0FFFFh		; AX, DX = CRC accumulator
	mov	dx, ax			;
	mov	ch, 3			; CH = word counter

CRCwordloop:
	mov	bp, es:[di]			; get a word of address
	add	di, 2			; point to next address
	mov	cl, 16			; CL = bit counter

CRCbitloop:
	mov	bx,dx			; get high word of CRC
	rol	bx,1			; put CRC bit 31 to LSB
	xor	bx,bp			; combine CRC31 with word
	sal	ax,1			; left shift CRC accumulator
	rcl	dx,1			;
	and	bx,0001h		; BX = control bit
	jz	short DontXORwithPOLY	;

	xor	ax,POLYL		; XOR if control bit = 1
	xor	dx,POLYH		;

DontXORwithPOLY:
	or	ax,bx			; put control bit in CRC0
	ror	bp,1			; rotate address word
	dec	cl			;
	jnz	short CRCbitloop	;

	dec	ch			; decrement word counter
	jnz	short CRCwordloop	;

	; formation of CRC complete, AL contains the reversed Hash code
	mov	cx,10			;
Reversehashbits:
	sal	al,1			; reverse the order of AL bits
	rcr	ah,1			;
	loop	Reversehashbits 	;

	; AL contains the 6 - bit Hash code
	mov	bl,ah			; BL = Hash code, BH = 0
	mov	cl,3			;
	shr	bl,cl			; divide Hash code by 8
	mov	al,1			; preset filetr bit
	and	ah,0111B		; extract bit count
	mov	cl,ah			;
	shl	al,cl			; shift bit to correct positions
	clc				; return clear carry flag
	ret

Set_Multicast_List	endp

; Routine used to build string
;----------------------------------------------------------------------
; StoHex - stuff binary AL as 2 hex digits at ES:DI
;
; On entry,
;	AL = binary digit to print as hex
;	ES:DI ptr to string buffer, CLD flag set
; On exit,
;	AX modified, ES:DI ptr to next location in buffer
;
; 920728 1.0 GK adapted from PutHex
;----------------------------------------------------------------------

StoHex	proc	near

	push	ax			; save for lower nibble
	shr	al, 4
	call	h_digit
	pop	ax			; now do lower nibble

h_digit:
	and	al,00001111b
	add	al,90h
	daa
	adc	al,40h
	daa
	stosb				; stuff hex digit in buffer
	ret

StoHex	endp

;----------------------------------------------------------------------
; StoDec - stuff AX as CL decimal digits at ES:DI
;
; On entry,
;	AX = number to print as decimal
;	ES:DI ptr to leftmost position of field
;	CL has width of field, will zero-fill
; On exit,
;	AX, CX, DX modified, ES:DI ptr to beyond rightmost position
;
; 920728 1.0 GK adapted from PutHex
;----------------------------------------------------------------------

StoDec		proc	near

		push	ax		; save value
		mov	al, '0'
		mov	ch, 0
		rep	stosb		; fill with zeroes

		mov	cl, 0Ah 	; divide by 10
		pop	ax		; restore value
		push	di		; save ending DI value

StoDecNext:
		xor	dx, dx
		div	cx		; ax, dx rem=dx:ax/reg
		add	dl, 30h 	; '0'
		dec	di
		mov	es:[di], dl
		or	ax, ax
		jnz	StoDecNext

		pop	di		; return with DI pointing after field
		ret

StoDec		endp



public		WaitTime
;--------------------------------------------------------------------
; WaitTime - CX has 2*1.1932 the number of microseconds to wait.
;	If CX is small, add 1 to compensate for asynchronous nature
;	of clock.  For example, for 10us, call with CX = 25
;
;  On entry,
;	ints off (especially if CX is small, and accuracy needed)
;  On exit,
;	CX modified
;
; 911223 0.0 GK
;--------------------------------------------------------------------
WaitTime	proc	near

		push	ax
		push	bx
		call	ReadTimer0		; get Timer0 value in AX
		mov	bx, ax			; save in BX

ReadTimer0Loop:
		call	ReadTimer0
		push	bx
		sub	bx, ax
		cmp	bx, cx
		pop	bx
		jc	ReadTimer0Loop

		pop	bx
		pop	ax
		ret

WaitTime	endp


ReadTimer0	proc	near

		mov	al, 6
		out	43h, al 		; port 43h, 8253 wrt timr mode 3
		call	RT0

RT0:
		jmp	short $+2
		jmp	short $+2
		jmp	short $+2
		in	al, 40h 		; port 40h, 8253 timer 0 clock
		xchg	ah, al

		jmp	short $+2
		jmp	short $+2
		jmp	short $+2

		ret

ReadTimer0	endp



IFNDEF	UNDI
END_CODE
START_BUFFER
ENDIF	; IFNDEF UNDI


_TEXT	ends


_DATA	segment	para public

        align 2


;;LDT1    dw  3 dup(0)
;;GDT     db  6 dup(0)

ReceiveError    dw  0


CSR15Broad	dw	  04000h	     ; CSR15 value. * Only change Bit14 *
							; Other bits must be zero !!
MCastTable	db	6 dup (0)	; Multicast table
			db	6 dup (0)

public		LADRFPtr
LADRFPtr	dw	offset LADRFDisable
;LADRFPtr	dw	offset LADRF
LADRF		db	8 dup (0)	; Value to put in Logical Address Filter
LADRFDisable	db	8 dup (0)	; Disable Logical Address Filter

public CardType

		db	"Start"
CardType	db	0		; indicate what card it is : AT1500
					; NE2100/1500 or ANSEL NS2100/NH2100
					; or HP
MemBase 	db	0		; for BPPatch (TCP/IP)
IRQLine 	db	0		; interrupt request line
StartTick	dw	0		; save area for tick value
MaxTicks	dw	0		; save area for max ticks
CurTicks	dw	0

MaskReg 	dw	0		; mask register
IntVect 	dw	0		; interrupt vector
OldMaskReg 	dw	0		; mask register

OrgIntVector_OFF    dw  0
OrgIntVector_SEG    dw  0

;OldIntVector	dw	2 dup (0)	; Store the old pointer to interrupt
					; vector

;IRQLine	 db	 0		 ; interrupt request line
;ISRErrFlag	 db	 FALSE		 ; flag indicating if error condition is
;					 ; encountered during int acknowledgement
ISRErr		dw	0		; contains CSR0 if ISRErrFlag is TRUE
InterruptFlag	dw	0		; indicate what type of interrupt is
					; serviced

TxMsgMode	dw	0		; Tmd1 in the descriptor ring
RxMsgMode	dw	0		; Rmd1 in the descriptor ring
BusInterface	dw	0		; CSR3 value (allow redefinition of bus
					; interface)
CSR0Cmd 	dw	0		; Command to be sent to CSR0

RecvBufOffset	dw	0		; Indicate offset to rx buffer used
RecvRingOffset	dw	0		; Indicate offset to Rx Ring desc used
UpdateBufOff	dw	0		; Indicate offset to Rx update buffer
UpdateRingOff	dw	0		; indicate offset to Rx update ring desc.

RecvIntCount	dw	0		; Buffer # being tested
TxEDPtr 	dd	?		; save area for transmit ED
RxEDPtr 	dd	?		; save area for receive ED
StatusMsgFlag	dw	0		; pointer to msg to be printed in NIDStatus
PacketLen	dw	0		; length of packet data

ValISACR2	dw	02		 ; value to be output to ISACR2 Register

_DATA	ends


;ErrStruct	 ErrorStruct < 0, 0, 0 >

;db 0, 0, 0

_BSS	segment

        align 8

db  'BWSPARSE'

        align 2



		align 8
InitialBlock	InitBlock <,,,,>	; Structure for initialization block




    	align 8
TxPacket	Packet NumTxBuf dup(<,,,,>)	 ; Store transmit ethernet packet

;db 0, 0

	ALIGN 8
RxPacket	Packet	NumRxBuf dup(<,,,,>)	 ; Store receive ethernet packet
	ALIGN 8
TxMsgBlock	TxMsgDesc NumTxBuf dup(<,,,>)	; Transmit message descriptor entry
		ALIGN 8
RxMsgBlock	RecvMsgDesc NumRxBuf+8 dup(<,,,>) ; Receiver message descriptor entry

;_DATA	ends

_BSS	ends

_TEXT	Segment para public


IFNDEF	UNDI
END_BUFFER
ENDIF		; note in UNDI case, this file is included within _TEXT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\eeprom2.inc ===
;****************************************************************************
;
;       The information contained in this file is confidential and 
;       proprietary to Standard Microsystems Corporation.  No part
;       of this file may be reproduced or distributed, in any form
;       or by any means for any purpose, without the express written
;       permission of Standard Microsystems Corporation.
;
;	(c) COPYRIGHT 1995 Standard Microsystems Corporation,
;	ALL RIGHTS RESERVED.
;
; File:         EEPROM2.INC
;
; Description:  Defines the data format for the EEPROM of EPIC and
;               later adapters.
;
;
;*******************
; Revision History *
;*******************
;
; $Log: /Client Boot/NICS/SMC/9432/UNDI/EEPROM2.INC $
;
;   Rev 1.1   07 Jan 1997 18:19:46   cosand
;Added a value definition for the QSI 6612 PHY.
;
;   Rev 1.0   03 Oct 1995 11:25:50   ANDERSON
;Initial revision.
;
; Change: removed "bank" references from comments.
;
; Change: Added Configured Media Type and Configured Line Speed fields.
;
; Change: Replaced Interface Chip byte with an eight byte Chip Type array.
;         Added four physical layer chips.
;
; Change: Removed Integrated BIC/NIC flag.
;
; Change: Added 1.5 MBps (T1) ATM line speed, but not 100 MBps (TAXI)
;	  or 45 MBps (DS3).
;
; Initial Version taken from Mike Steiger's NEW BOARD ID FORMAT proposal.
;
;
; +!/? ***********************************************************************
;
;
; NEW BOARD ID FORMAT
;
; Starting with the EPIC-based adapters, SWENG is adopting a new board ID
; standard. The current board ID standard is outdated and does not adequately
; describe new technologies and options.
;
; ADAPTER ID STRING
;
; The adapter ID string that is displayed when the driver loads will be stored
; directly in EEPROM. This will require 12 bytes of EEPROM to be allocated.
; Storing the string on the adapter alleviates the requirement of the software
; to correlate adapter options with adapter names. With the string stored in
; EEPROM, the driver will always report the correct adapter name.
;
; OPTION DEFINITIONS
;
; The proposed EEPROM data format is described below:
;
;****************************************************************************
; EEPROM format version.
;
;        7       6       5       4       3       2       1       0
;      MAJ3    MAJ2    MAJ1    MAJ0    MIN3    MIN2    MIN1    MIN0
;
;        Data structure revision. Indicates the format of the data in the
;        structure.
;        MAJ3-0          Major version. Indicates a change in the data format.
;        MIN3-0          Minor version. Indicates that the structure has been
;                        appended.
;

; Offset
EPM_FMT		equ	000h

; Current EEPROM Format version
EPM_FMT_VER	equ	000h	; Version 0.0

; Bit definition
EPM_FMT_MAJ3	equ	080h
EPM_FMT_MAJ2	equ	040h
EPM_FMT_MAJ1	equ	020h
EPM_FMT_MAJ0	equ	010h
EPM_FMT_MIN3	equ	008h
EPM_FMT_MIN2	equ	004h
EPM_FMT_MIN1	equ	002h
EPM_FMT_MIN0	equ	001h

;****************************************************************************
; Adapter RAM size.
;
;        7       6       5       4       3       2       1       0
;       RS7     RS6     RS5     RS4     RS3     RS2     RS1     RS0
;
;        RS7-0   Size of adapter RAM in 8KB (2000h) units.
;
;

; Offset
EPM_RAM_SIZE	equ	001h

; Some common values
EPM_RAM_SIZE_128KB	equ	010h
EPM_RAM_SIZE_64KB	equ	008h
EPM_RAM_SIZE_32KB	equ	004h
EPM_RAM_SIZE_16KB	equ	002h
EPM_RAM_SIZE_8KB	equ	001h

;****************************************************************************
; Adapter RAM Window Minimum Size
;
;        7       6       5       4       3       2       1       0
;       WS7     WS6     WS5     WS4     WS3     WS2     WS1     WS0
;
;        WS7-0   Minimum size of adapter RAM window in KB.
;        
;
;
; Offset
EPM_RAM_WIN_SIZE	equ	002h

; Some common values
EPM_RAM_WIN_SIZE_16KB	equ	010h
EPM_RAM_WIN_SIZE_8KB	equ	008h

;****************************************************************************
; Adapter Bus Type
;

; Offset
EPM_BUS	equ	003h

; Value definitions
EPM_BUS_PCI_32b_33M	equ	000h	; PCI 32 bit 33 MHz
EPM_BUS_PCI_32b_66M	equ	001h	; PCI 32 bit 66 MHz
EPM_BUS_PCI_64b_66M	equ	002h	; PCI 64 bit 66 MHz
EPM_BUS_CARDBUS		equ	003h	; CardBus
EPM_BUS_PCCARD		equ	004h	; PC Card 16 Bit
;   		                5-255      available

;****************************************************************************
; Card Type
;
;        7       6       5       4       3       2       1       0
;       ETH     TKR     ATM     MOD     WIR    ISDN     ---     ---
;
;        ETH     Ethernet
;        TKR     Token Ring
;        ATM     ATM
;        MOD     Modem
;        WIR     Wireless
;        ISDN    ISDN Interface
;
; Note: bit mask.  Multiple bits may be defined; e.g. Modem and ISDN.

; Offset
EPM_TYPE	equ	004h

; Bit definition
EPM_TYPE_ETH	equ	080h		; Ethernet
EPM_TYPE_TKN	equ	040h		; Token Ring
EPM_TYPE_ATM	equ	020h		; ATM
EPM_TYPE_MOD	equ	010h		; Modem
EPM_TYPE_WIR	equ	008h		; Wireless
EPM_TYPE_ISDN	equ	004h		; ISDN Interface
EPM_TYPE_RV1	equ	002h		; available
EPM_TYPE_RV0	equ	001h		; available

;****************************************************************************
; 100 Mbps Ethernet Supported Media I
;
;        7       6       5       4       3       2       1       0
;       FXHD    FXFD     T4     TXHD    TXFD    MII     STP     UTP
;
;        FXHD    Fiber Half-Duplex
;        FXFD    Fiber Full-Duplex ?
;        T4      T4
;        TXHD    TX Half-Duplex
;        TXFD    TX Full-Duplex
;        MII     Media-Independent Interface
;        STP     Shielded Twisted Pair
;        UTP     Unshielded Twisted Pair
;

; Offset
EPM_E100MED1	equ	005h

; Bit definition
EPM_E100MED1_FXHD	equ	080h		; 100Base-Fx Half Duplex
EPM_E100MED1_FXFD	equ	040h		; 100Base-Fx Full Duplex
EPM_E100MED1_T4 	equ	020h		; 100Base-T4
EPM_E100MED1_TXHD	equ	010h		; 100Base-Tx Half Duplex
EPM_E100MED1_TXFD	equ	008h		; 100Base-Tx Full Duplex
EPM_E100MED1_MII	equ	004h		; Media-Independent Interface
EPM_E100MED1_STP	equ	002h		; Shielded Twisted Pair
EPM_E100MED1_UTP	equ	001h		; Unshielded Twisted Pair

;****************************************************************************
; 100 Mbps Ethernet Supported Media II
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     ---     ---     ---     ---       
;
; All bits available for future expansion.

; Offset
EPM_E100MED2	equ	006h

; Bit definition
EPM_E100MED2_RV7	equ	080h
EPM_E100MED2_RV6	equ	040h
EPM_E100MED2_RV5	equ	020h
EPM_E100MED2_RV4	equ	010h
EPM_E100MED2_RV3	equ	008h
EPM_E100MED2_RV2	equ	004h
EPM_E100MED2_RV1	equ	002h
EPM_E100MED2_RV0	equ	001h

;****************************************************************************
; 10 Mbps Ethernet Supported Media
;
;        7       6       5       4       3       2       1       0
;       ---     ---     FD      S10     BNC     AUI     STP     UTP
;
;        FD      Full Duplex
;        S10     Starlan-10
;        BNC     Thinnet Coax
;        AUI     Attachment Unit Interface
;        STP     Shielded Twisted Pair
;        UTP     Unshielded Twisted Pair
;

; Offset
EPM_E10MED	equ	007h

; Bit definition
EPM_E10MED_RV7	equ	080h		; available
EPM_E10MED_RV6	equ	040h		; available
EPM_E10MED_FD	equ	020h		; Full Duplex
EPM_E10MED_S10	equ	010h		; Starlan-10
EPM_E10MED_BNC	equ	008h		; Thinnet Coax
EPM_E10MED_AUI	equ	004h		; Attachment Unit Interface
EPM_E10MED_STP	equ	002h		; Shielded Twisted Pair
EPM_E10MED_UTP	equ	001h		; Unshielded Twisted Pair

;****************************************************************************
; Token Ring Supported Media
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     ---     STP     UTP     DTR
;
;        STP     Shielded Twisted Pair
;        UTP     Unshielded Twisted Pair
;        DTR     Dedicated Token Ring
;

; Offset
EPM_TKNMED	equ	008h

; Bit definition
EPM_TKNMED_RV7	equ	080h		; available
EPM_TKNMED_RV6	equ	040h		; available
EPM_TKNMED_RV5	equ	020h		; available
EPM_TKNMED_RV4	equ	010h		; available
EPM_TKNMED_RV3	equ	008h		; available
EPM_TKNMED_STP	equ	004h		; Shielded Twisted Pair
EPM_TKNMED_UTP	equ	002h		; Unshielded Twisted Pair
EPM_TKNMED_DTR	equ	001h		; Dedicated Token Ring

;****************************************************************************
; ATM Supported Media
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     ---     ---     UTP     FIB
;
;        UTP     Unshielded Twisted Pair
;        FIB     Fiber
;
;

; Offset
EPM_ATMMED	equ	009h

; Bit definition
EPM_ATMMED_RV7	equ	080h		; available
EPM_ATMMED_RV6	equ	040h		; available
EPM_ATMMED_RV5	equ	020h		; available
EPM_ATMMED_RV4	equ	010h		; available
EPM_ATMMED_RV3	equ	008h		; available
EPM_ATMMED_RV2	equ	004h		; available
EPM_ATMMED_UTP	equ	002h		; Unshielded Twisted Pair
EPM_ATMMED_FIB	equ	001h		; Fiber

;****************************************************************************
; Modem Supported Rates I
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     V42     V34     V32     FAX
;
;        V42     V.42BIS
;        V34     V.34 (28.8K)
;        V32     V.32 (14.4K)
;        FAX     Fax Support
;

; Offset
EPM_MODSPD1	equ	00Ah

; Bit definition
EPM_MODSPD1_RV7	equ	080h		; available
EPM_MODSPD1_RV6	equ	040h		; available
EPM_MODSPD1_RV5	equ	020h		; available
EPM_MODSPD1_RV4	equ	010h		; available
EPM_MODSPD1_RV3	equ	008h		; available
EPM_MODSPD1_RV2	equ	004h		; available
EPM_MODSPD1_RV1	equ	002h		; available
EPM_MODSPD1_RV0	equ	001h		; available

;****************************************************************************
; Modem Supported Rates II
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     ---     ---     ---     ---    
;
;

; Offset
EPM_MODSPD2	equ	00Bh

; Bit definition
EPM_MODSPD2_RV7	equ	080h		; available
EPM_MODSPD2_RV6	equ	040h		; available
EPM_MODSPD2_RV5	equ	020h		; available
EPM_MODSPD2_RV4	equ	010h		; available
EPM_MODSPD2_RV3	equ	008h		; available
EPM_MODSPD2_RV2	equ	004h		; available
EPM_MODSPD2_RV1	equ	002h		; available
EPM_MODSPD2_RV0	equ	001h		; available

;****************************************************************************
; Ethernet Supported Rates
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     ---     ---    BPS100   BPS10
;
;        BPS100  100 Mbps
;        BPS10   10 Mbps
;

; Offset
EPM_ETHSPD	equ	00Ch

; Bit definition
EPM_ETHSPD_RV7	equ	080h		; available
EPM_ETHSPD_RV6	equ	040h		; available
EPM_ETHSPD_RV5	equ	020h		; available
EPM_ETHSPD_RV4	equ	010h		; available
EPM_ETHSPD_RV3	equ	008h		; available
EPM_ETHSPD_RV2	equ	004h		; available
EPM_ETHSPD_100	equ	002h		; 100 MBps
EPM_ETHSPD_10	equ	001h		; 10 MBps

;****************************************************************************
; Token Ring Supported Rates
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     ---     ---    BPS16    BPS4
;
;        BPS16   16 Mbps
;        BPS4     4 Mbps
;

; Offset
EPM_TKNSPD	equ	00Dh

; Bit definition
EPM_TKNSPD_RV7	equ	080h		; available
EPM_TKNSPD_RV6	equ	040h		; available
EPM_TKNSPD_RV5	equ	020h		; available
EPM_TKNSPD_RV4	equ	010h		; available
EPM_TKNSPD_RV3	equ	008h		; available
EPM_TKNSPD_RV2	equ	004h		; available
EPM_TKNSPD_16	equ	002h		; 16 MBps
EPM_TKNSPD_4	equ	001h		; 4 MBps

;****************************************************************************
; ATM Supported Rates
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---    BPS622  BPS155  BPS51   BPS25   BPS2
;

; Offset
EPM_ATMSPD	equ	00Eh

; Bit definition
EPM_ATMSPD_RV7	equ	080h		; available
EPM_ATMSPD_RV6	equ	040h		; available
EPM_ATMSPD_RV5	equ	020h		; available
EPM_ATMSPD_622	equ	010h		; 622 MBps
EPM_ATMSPD_155	equ	008h		; 155 MBps (STS-3c)
EPM_ATMSPD_51	equ	004h		; 51.84 MBps
EPM_ATMSPD_25	equ	002h		; 25.6 MBps
EPM_ATMSPD_2	equ	001h		; 1.5/2 MBps (T-1/E-1)

;****************************************************************************
; Adapter Architecture
;
;        7       6       5       4       3       2       1       0
;       ---     ---     ---     ---     ---     INT     MCH     MPT 
;
;        INT     Intelligent Card
;        MCH     Multi-Channel Card
;        MPT     Multi-Port Card
;

; Offset
EPM_ARCH	equ	00Fh

; Bit definition
EPM_ARCH_RV7	equ	080h
EPM_ARCH_RV6	equ	040h
EPM_ARCH_RV5	equ	020h
EPM_ARCH_RV4	equ	010h
EPM_ARCH_RV3	equ	008h
EPM_ARCH_INT	equ	004h		; Intelligent Card
EPM_ARCH_MCH	equ	002h		; Multi-Channel Card
EPM_ARCH_MPT	equ	001h		; Multi-Port Card

;****************************************************************************
; Chip Type Array
;
; each byte defines one chip installed on the adapter.
; eight chips may be defined for each adapter.
;

; Offset
EPM_CHIP7	equ	017h
EPM_CHIP6	equ	016h
EPM_CHIP5	equ	015h
EPM_CHIP4	equ	014h
EPM_CHIP3	equ	013h
EPM_CHIP2	equ	012h
EPM_CHIP1	equ	011h
EPM_CHIP0	equ	010h

; Value definition
EPM_CHIP_NONE	equ	000h	; empty array entry
EPM_CHIP_EPIC	equ	001h	; SMC 100Base-TX NIC & integrated PCI BIC
EPM_CHIP_EPIC_C	equ	002h	; SMC 100Base-T4 NIC & integrated PCI BIC
EPM_CHIP_N83840	equ	003h	; National 100Base-TX Physical Layer
EPM_CHIP_CY971	equ	004h	; Cypress 100Base-T4 Physical Layer
EPM_CHIP_SMC111	equ	005h	; SMC 100Base-TX Physical Layer
EPM_CHIP_SMC140	equ	006h	; SMC 100Base-T4 Physical Layer
EPM_CHIP_QS6612 equ     007h    ; QSI 100Base-TX Physical Layer
EPM_CHIP_RSV	equ	0FFh	; reserved for future expansion

;****************************************************************************
; Adapter name string.
;
;        12 byte adapter name string.
;        pad with spaces.
;        no NULL termination.
;
;        for example:
;        	EPM_NAME[0] = 'S'
;        	EPM_NAME[1] = 'M'
;        	EPM_NAME[2] = 'C'
;        	EPM_NAME[3] = '9
;        	EPM_NAME[4] = '4'
;        	EPM_NAME[5] = '3'
;        	EPM_NAME[6] = '2'
;        	EPM_NAME[7] = 'D'
;        	EPM_NAME[8] = 'M'
;        	EPM_NAME[9] = 'T'
;        	EPM_NAME[A] = ' '
;        	EPM_NAME[B] = ' '
;

; Offset
EPM_NAME	equ	018h	; adapter name offset 18 - 23

;****************************************************************************
; Reserved for Lanworks I.
;

; Offset
EPM_LANWORKS1	equ	024h

;****************************************************************************
; Reserved for Lanworks II.
;

; Offset
EPM_LANWORKS2	equ	025h

;****************************************************************************
; Wireless Info.
;

; Offset
EPM_WIR		equ	026h

;****************************************************************************
; ISDN Info.
;

; Offset
EPM_ISDN	equ	027h

;****************************************************************************
; Media Type2 -- configured default media word 
;

; Offset
EPM_MEDIA_TYPE2	equ	028h	; offsets 28 - 29

;****************************************************************************
; Line Speed -- configured default line speed word 
;

; Offset
EPM_LINE_SPEED	equ	02Ah	; offsets 2A - 2B
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\epic100.inc ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       EPIC100.INC    (C) Copyright 1995 Standard Microsystems Corp.
;                       All rights reserved.
;
;       Definitions for the EPIC/100 chip
;
;       Author: najay
;
; Revision Log:
; $Log: /Client Boot/NICS/SMC/9432/UNDI/EPIC100.INC $
;  
;     Rev 1.16   24 Nov 1997 16:50:18   cosand
;  Moved the definition for the PCI Subsystem ID for 9432BTX to lmstruct.inc.
;  
;     Rev 1.15   04 Nov 1997 16:39:44   cosand
;  Defined EPC_SSID_9432BTX, the PCI Subsystem ID for 9432BTX.
;  Defined the bit PHY_LINK_DOWN_INT for the register PHY_INT_SOURCE_REG.
;  
;     Rev 1.14   11 Sep 1997 13:36:06   cosand
;  Defined EPC_ID_EPIC_C for the EPC_DEVICE_ID register.
;  Defined the organizationally unique identifiers (OUI)
;  for National, TDK, and QSI.
;  
;     Rev 1.13   05 Aug 1997 12:20:10   cosand
;  Changed the length of the bit definitions for the Non-Volatile Control
;  register to 32 bits.
;  
;     Rev 1.12   26 Mar 1997 15:04:34   ANDERS
;  For the EPC_GEN_CONTROL register defined GC_RD_MULT = 00000400h &
;  GC_RD_LINE = 00000800h.
;  
;     Rev 1.11   26 Feb 1997 17:27:40   cosand
;  Added a definition for the PBLCNT register.
;  
;     Rev 1.10   07 Jan 1997 17:36:52   cosand
;  Added the compact definition GP2 for INT_PHY_EVENT.
;  Added Mercury PHY register and bit definitions.
;  
;     Rev 1.9   18 Dec 1996 08:50:34   ANDERS
;  redefined I/O port BCh to EPC_PREEMP_RX_INT
;  
;     Rev 1.8.1.0   16 Oct 1996 09:50:54   ANDERS
;  DEBUG release: add definitions for Preemptive Int & Interpacket Gap
;  processing
;  
;     Rev 1.8   21 Aug 1996 13:50:42   STEIGER
;  Eliminated the "XE" definition requirement. This release and all
;  future releases will support Epic XE & later only.
;  
;     Rev 1.7   21 Aug 1996 11:10:18   STEIGER
;  Added changes for EPIC XE. "XE" must be defined to enable XE register
;  and bit definitions.
;  
;     Rev 1.6   03 Oct 1995 16:22:40   ANDERSON
;  
;     Rev 1.5   03 Oct 1995 16:13:32   ANDERSON
; Change: added EPC_EEPROM_SW_OFFSET.
;  
;     Rev 1.4   13 Sep 1995 14:52:46   ANDERSON
;
; Change: add bit definitions for TRANSMIT_CONTROL mode bits:
;       TC_NORMAL_MODE         half duplex operation, no loopback
;       TC_INTERNAL_LOOPBACK   do not send data to PHY chips
;       TC_EXTERNAL_LOOPBACK   must put PHY chip in loopback mode
;       TC_FULL_DUPLEX         full duplex operation, no loopback
; 
;     Rev 1.3   29 Aug 1995 17:51:24   CHAN_M
;  Added additional PHY layer register & bit definitions.
;  
;     Rev 1.2   17 Jul 1995 20:20:14   CHAN_M
;  Added some physical layer register & bit definitions.
;  
;     Rev 1.1   19 Jun 1995 17:43:20   CHAN_M
;  added more compact bit definitions for the interrupt status bits.
;  
;     Rev 1.0   11 May 1995 14:20:32   NAJARIAN
;  Initial revision.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Mapping for EPIC/100 configuration registers

EPC_VENDOR_ID           equ     0h
EPC_ID_SMC              equ     000010b8h

EPC_DEVICE_ID           equ     2h
EPC_ID_EPIC_100         equ     0005h
EPC_ID_EPIC_C           equ     0006h

EPC_PCI_COMMAND         equ     4h
PCIC_FAST_BTOB_ENABLE   equ     0200h
PCIC_SERR_ENABLE        equ     0100h
PCIC_WAIT_CYCLE         equ     0080h
PCIC_PARITY_ENABLE      equ     0040h
PCIC_VGA_SNOOP          equ     0020h
PCIC_MEM_WRITE_INV      equ     0010h
PCIC_SPECIAL_CYCLES     equ     0008h
PCIC_BUSMASTER_ENABLE   equ     0004h
PCIC_MEM_SPACE_ENABLE   equ     0002h
PCIC_IO_SPACE_ENABLE    equ     0001h

EPC_PCI_STATUS          equ     6h
PCIS_PARITY_ERR         equ     8000h
PCIS_SYSTEM_ERR         equ     4000h
PCIS_MASTER_ABORT       equ     2000h
PCIS_TARGET_ABORT       equ     1000h 
PCIS_SIG_TARGET_ABORT   equ     0800h
PCIS_DEVSEL_TIMING      equ     0600h 
PCIS_DATA_PARITY        equ     0100h
PCIS_FAST_BTOB          equ     0080h
PCIS_UDF_SUPPORT        equ     0040h
PCIS_66MHZ_SUPPORT      equ     0020h


EPC_REV_ID              equ     8h
EPC_CLASS_CODE          equ     08h
CC_BASE_CLASS           equ     0ff000000h
CC_SUB_CLASS            equ     00ff0000h
CC_PROG_INTERFACE       equ     0000ff00h
CC_REV_ID               equ     000000ffh

EPC_LAT_TIMER           equ     0dh

EPC_HDR_TYPE            equ     0eh
HT_MULTI_FUNC           equ     80h
HT_TYPE                 equ     7fh

EPC_IO_ADDR             equ     10h
IO_BASE_ADDR            equ     0fffffff0h
IO_SPACE_IND            equ     00000001h

EPC_MEM_ADDR            equ     14h
MEM_BASE_ADDR           equ     0fffff000h
MEM_PREFETCHABLE        equ     000000008h
MEM_TYPE                equ     000000006h
MEM_SPACE_IND           equ     000000001h

EPC_CIS_PTR             equ     28h
CIS_ADDR_SPACE          equ     70000000h
CIS_ROM_IMAGE           equ     0f000000h
CIS_OFFSET              equ     00ffffffh

EPC_SUBSYSTEM_VENDOR    equ     2ch

EPC_SYSTEM_ID           equ     2eh

EPC_ROM_ADDR            equ     30h
ROM_BASE_ADDR           equ     0ffff0000h
ROM_ADDR_DECODE_ENABLE  equ     000000001h

EPC_INT_LINE            equ     3ch
EPC_INT_PIN             equ     3dh
EPC_MIN_GNT             equ     3eh
EPC_MAX_LAT             equ     3fh

EPC_EEPROM_SW_OFFSET    equ     40h   ; start of software-defined eeprom data

;
; EPIC/100 Register descriptions
;

EPC_COMMAND             equ     00h
CMD_RXQUEUED_ALT        equ     0800h
CMD_TXQUEUED_ALT        equ     0400h
CMD_TXUGO               equ     0080h
CMD_STOP_RDMA           equ     0040h
CMD_STOP_TDMA           equ     0020h
CMD_NEXTFRAME           equ     0010h
CMD_RXQUEUED            equ     0008h
CMD_TXQUEUED            equ     0004h
CMD_START_RX            equ     0002h
CMD_STOP_RX             equ     0001h        

EPC_INT_STATUS          equ     04h
EPC_INT_MASK            equ     08h

; the following interrupts are status only

INT_RCV_COPY_THRESH_STATUS equ  00400000h
INT_RCV_BUFF_EMPTY      equ     00200000h
INT_XMIT_COPY_ACTIVE    equ     00100000h
INT_RCV_COPY_ACTIVE     equ     00080000h
INT_XMIT_IDLE           equ     00040000h
INT_RCV_IDLE            equ     00020000h
INT_ACTIVE              equ     00010000h

;ifdef   XE      ; EPIC Rev XE changes

 INT_RCV_STATUS_VALID    equ     00800000h

 ; The following 4 statii are OR'd together and generate an
 ; interrupt on INT_FATAL below...

 INT_PCI_TARGET_ABORT    equ     08000000h
 INT_PCI_MASTER_ABORT    equ     04000000h
 INT_PCI_ADDR_PARITY_ERR equ     02000000h
 INT_PCI_DATA_PARITY_ERR equ     01000000h

; the following interrupts will generate an interrupt
; (and are valid as interrupt masks)

 INT_PHY_EVENT           equ     00008000h
 INT_FATAL               equ     00001000h
 INT_RCV_COPY_THRESH     equ     00000800h
 INT_RCV_PREEMPT         equ     00000400h

;else
;
; INT_RCV_STATUS_VALID    equ     00008000h
; INT_PCI_TARGET_ABORT    equ     00004000h
; INT_PCI_MASTER_ABORT    equ     00002000h
; INT_PCI_ADDR_PARITY_ERR equ     00001000h
; INT_PCI_DATA_PARITY_ERR equ     00000800h
; INT_RCV_COPY_THRESH     equ     00000400h
;
;endif

INT_CNTR_OVERFLOW       equ     00000200h
INT_XMIT_UNDERRUN       equ     00000100h
INT_XMIT_QUEUE_EMPTY    equ     00000080h
INT_XMIT_CHAIN_DONE     equ     00000040h
INT_XMIT_DONE           equ     00000020h
INT_RCV_ERR             equ     00000010h
INT_RCV_BUFF_OVERFLOW   equ     00000008h
INT_RCV_QUEUE_EMPTY     equ     00000004h
INT_HEADER_COPY_DONE    equ     00000002h
INT_RCV_COPY_DONE       equ     00000001h

; more compact definitions

PTA     equ     INT_PCI_MASTER_ABORT
PMA     equ     INT_PCI_MASTER_ABORT
APE     equ     INT_PCI_ADDR_PARITY_ERR     
DPE     equ     INT_PCI_DATA_PARITY_ERR
GP2     equ     INT_PHY_EVENT
RCT     equ     INT_RCV_COPY_THRESH
RXP     equ     INT_RCV_PREEMPT
CNT     equ     INT_CNTR_OVERFLOW
TXU     equ     INT_XMIT_UNDERRUN
TQE     equ     INT_XMIT_QUEUE_EMPTY
TCC     equ     INT_XMIT_CHAIN_DONE
TXC     equ     INT_XMIT_DONE
RXE     equ     INT_RCV_ERR
OVR     equ     INT_RCV_BUFF_OVERFLOW
RQE     equ     INT_RCV_QUEUE_EMPTY
HCC     equ     INT_HEADER_COPY_DONE
RCC     equ     INT_RCV_COPY_DONE

EPC_GEN_CONTROL         equ     0ch
GC_HARD_RESET           equ     00004000h
GC_SOFT_BITS            equ     00003000h
GC_RD_MULT              equ     00000400h
GC_RD_LINE              equ     00000800h
GC_RCV_FIFO_THRESH      equ     00000300h
GC_RCV_FIFO_LOW         equ     00000000h
GC_RCV_FIFO_MID         equ     00000100h
GC_RCV_FIFO_HIGH        equ     00000200h
GC_XMIT_DMA_PRIORITY    equ     00000080h
GC_RECV_DMA_PRIORITY    equ     00000040h
GC_BIG_ENDIAN           equ     00000020h
GC_ONECOPY              equ     00000010h
GC_POWERDOWN            equ     00000008h
GC_SW_INT               equ     00000004h
GC_INT_ENABLE           equ     00000002h
GC_SOFT_RESET           equ     00000001h

EPC_NV_CONTROL          equ     10h

NVC_IPG_DELAY_SHCNT     equ     7        ; Bit position of LSB, use to shift value
					 ; into position. (XE ONLY)
NVC_IPG_DELAY_MASK      equ     00000780h
NVC_CB_MODE             equ     00000040h ; When set, Epic is in a Cardbus slot. (XE ONLY)
NVC_GPIO2               equ     00000020h
NVC_GPIO1               equ     00000010h
NVC_GPOE2               equ     00000008h
NVC_GPOE1               equ     00000004h
NVC_CLOCK_RUN           equ     00000002h
NVC_MAP_CONTROL         equ     00000001h

EPC_EEPROM_CONTROL      equ     14h
EEC_SIZE                equ     00000040h
EEC_READY               equ     00000020h
EEC_DATAOUT             equ     00000010h
EEC_DATAIN              equ     00000008h
EEC_CLOCK               equ     00000004h
EEC_CHIP_SELECT         equ     00000002h
EEC_ENABLE              equ     00000001h

EPC_PBLCNT              equ     18h

EPC_TEST                equ     1ch
TEST_BYPASS_ADDR        equ     00000080h
TEST_FORCE_DATALEN      equ     00000040h
TEST_COUNTERS           equ     00000020h
TEST_FIFO_LEVELS        equ     00000010h
TEST_CLOCK              equ     00000008h
TEST_PARITY_IN          equ     00000004h
TEST_PARITY_OUT         equ     00000002h
TEST_REGISTER           equ     00000001h

EPC_CRC_ERR_CNT         equ     20h

EPC_FA_ERR_CNT          equ     24h

EPC_MISSED_PKT_CNT      equ     28h

EPC_RECEIVE_FIFO        equ     2ch

EPC_MII_CONTROL         equ     30h
MII_PHYS_ADDR           equ     0003e00h
MII_REG_ADDR            equ     00001f0h
MII_RESPONDER           equ     0000008h
MII_WRITE               equ     0000002h
MII_READ                equ     0000001h

EPC_MII_DATA            equ     34h
PHY_BMC_REG             equ     0       ;Basic Mode Control Register

PHY_AN_ENABLE           equ     1000h
PHY_RESTART_AN          equ     200h
PHY_SPEED_SELECT_100    equ     2000h
PHY_FULL_DUPLEX         equ     100h
PHY_ISOLATE             equ     400h
PHY_LOOPBACK            equ     4000h

PHY_BMS_REG             equ     1       ;Basic Mode Status Register

PHY_AN_COMPLETE         equ     20h
PHY_LINK_STATUS         equ     4

PHY_ID_REG1             equ     2       ;Identifier register 1

PHY_ID_REG2             equ     3       ;Identifier register 2

PHY_NATIONAL_OUI        equ     080017h     ;Organizationally unique identifier
PHY_TDK_OUI             equ     00c039h     ;Organizationally unique identifier
PHY_QSI_OUI             equ     006051h     ;Organizationally unique identifier

PHY_ANLPA_REG           equ     5       ;Auto-Negotiation Link Partner Ability Reg.

PHY_100_BASE_T4         equ     200h
PHY_100_BASE_TX_FD      equ     100h
PHY_100_BASE_TX_HD      equ     80h
PHY_10_BASE_T_FD        equ     40h
PHY_10_BASE_T_HD        equ     20h

PHY_ANE_REG             equ     6       ;Auto-Negotiation Expansion Reg.

PHY_LP_AN_ABLE          equ     1

PHY_INT_SOURCE_REG      equ     29      ;Interrupt Source Register

PHY_LINK_DOWN_INT       equ     10h
PHY_AN_COMPLETE_INT     equ     40h

PHY_INT_MASK_REG        equ     30      ;Interrupt Mask Register

PHY_INT_MODE            equ     8000h

EPC_MII_CONFIG          equ     38h
MII_ALT_DIR             equ     0000080h
MII_ALT_DATA            equ     0000040h
MII_ALT_CLOCK           equ     0000020h
MII_ENABLE_SMI          equ     0000010h
MII_PHY_PRESENT         equ     0000008h
MII_694_LINK_STATUS     equ     0000004h
MII_ENABLE_694          equ     0000002h
MII_SERIAL_MODE_ENABLE  equ     0000001h

EPC_INTERPACKET_GAP     equ     3ch
IPG_INTERFRAME_SPACING  equ     0007f00h
IPG_GAP_TIME            equ     00000ffh        

EPC_LANADDR1            equ     40h
EPC_LANADDR2            equ     44h
EPC_LANADDR3            equ     48h

EPC_BOARD_ID            equ     4ch

EPC_MC_HASH_TABLE1      equ     50h
EPC_MC_HASH_TABLE2      equ     54h
EPC_MC_HASH_TABLE3      equ     58h
EPC_MC_HASH_TABLE4      equ     5ch

EPC_RECEIVE_CONTROL     equ     60h
RC_BUFFER_SIZE          equ     0000300h
RC_EARLY_RECEIVE_ENABLE equ     0000080h
RC_MONITOR_MODE         equ     0000040h
RC_PROMISCUOUS_MODE     equ     0000020h
RC_RCV_INVERSE          equ     0000010h
RC_RCV_MULTICAST        equ     0000008h
RC_RCV_BROADCAST        equ     0000004h
RC_RCV_RUNT             equ     0000002h
RC_RCV_ERRORED          equ     0000001h

EPC_RECEIVE_STATUS      equ     64h
RS_RECEIVER_DISABLED    equ     0000040h
RS_BROADCAST_ADDR       equ     0000020h
RS_MULTICAST_ADDR       equ     0000010h
RS_MISSED_PKT           equ     0000008h
RS_CRC_ERR              equ     0000004h
RS_FA_ERR               equ     0000002h
RS_RCV_OK               equ     0000001h

EPC_RECEIVE_BYTE_CNT    equ     68h

EPC_RECEIVE_TEST        equ     6ch
RT_RECEIVE_FIFO_LEVEL   equ     0007c00h
RT_RUNT_STATUS          equ     0000080h
RT_TEST_RDMA2           equ     0000040h
RT_TEST_RDMA1           equ     0000020h
RT_INT_BUFF_DISABLE     equ     0000010h
RT_TEST_COUNTERS        equ     0000008h
RT_SPLIT_COUNTERS       equ     0000004h
RT_TEST_RECEIVE_FIFOS   equ     0000003h

EPC_TRANSMIT_CONTROL    equ     70h
TC_SLOT_TIME            equ     00000f8h
TC_LOOPBACK_MODE        equ     0000006h        ; mode mask
TC_NORMAL_MODE          equ     0000000h        ; half duplex operation, no loopback
TC_INTERNAL_LOOPBACK    equ     0000002h        ; do not send data to PHY chips
TC_EXTERNAL_LOOPBACK    equ     0000004h        ; must put PHY chip in loopback mode
TC_FULL_DUPLEX          equ     0000006h        ; full duplex operation, no loopback
TC_EARLY_XMIT_ENABLE    equ     0000001h

EPC_TRANSMIT_STATUS     equ     74h
TS_COLLISION_CNT        equ     0001f00h
TS_DEFERRING            equ     0000080h
TS_OUT_OF_WINDOW_COLL   equ     0000040h
TS_COLLISION_DETECT_HB  equ     0000020h
TS_UNDERRUN             equ     0000010h
TS_CARRIER_SENSE_LOST   equ     0000008h
TS_XMIT_WITH_COLL       equ     0000004h
TS_NON_DEFERRED_XMIT    equ     0000002h
TS_XMIT_OK              equ     0000001h

EPC_TRANSMIT_PKT_ADDR   equ     78h

EPC_TRANSMIT_TEST       equ     7ch
TT_MUXED_INT_MODES      equ     0000f00h
TT_FORCE_COLLISION      equ     0000080h
TT_MUX_BACKTIMER        equ     0000040h
TT_RANDOMIZE_BACKOFF    equ     0000020h
TT_SET_BACKTIME         equ     0000010h
TT_SLOT_TIMER_TEST      equ     0000008h
TT_DELAY_TIMER_TEST     equ     0000004h
TT_BACKOFF_TIMER_TEST   equ     0000002h
TT_XMIT_SCAN_ENABLE     equ     0000001h

EPC_RCV_FIRST_DESC_ADDR equ     80h

EPC_RCV_CURR_DESC_ADDR  equ     84h

EPC_RCV_HOST_DATA_ADDR  equ     88h

EPC_RCV_FRAGLIST_ADDR   equ     8ch

EPC_RCV_DMA_DATALEN     equ     90h
RDMA_OWNER              equ     0080000h
RDMA_HEADER             equ     0040000h
RDMA_LFFORM             equ     0020000h
RDMA_FRAGLIST           equ     0010000h

EPC_RCV_FRAG_CNT        equ     94h

EPC_RCV_RAM_CURR_ADDR   equ     98h

EPC_RCV_RAM_PKT_ADDR    equ     9ch

EPC_RCV_EOF_ADDR        equ     0a0h

EPC_RCV_DMA_STATUS      equ     0a4h
RDMA_FRAME_LEN          equ     0ffff0000h
RDMA_OWNER_STATUS       equ     0008000h
RDMA_HEADER_COPIED      equ     0004000h
RDMA_FRAG_LIST_ERR      equ     0002000h
RDMA_NW_STATUS_VALID    equ     0001000h
RDMA_RECEIVER_DISABLED  equ     0000040h
RDMA_BROADCAST_ADDR     equ     0000020h
RDMA_MULTICAST_ADDR     equ     0000010h
RDMA_MISSED_PKT         equ     0000008h
RDMA_CRC_ERR            equ     0000004h
RDMA_FA_ERR             equ     0000002h
RDMA_RCV_OK             equ     0000001h

EPC_RCV_RAM_BUFFER      equ     0a8h

EPC_RCV_MTU_CURR_ADDR   equ     0ach

EPC_RCV_COPY_THRESH     equ     0b0h

;EPC_RCV_DMA_TEST        equ     0bch
EPC_PREEMP_RX_INT       equ     0bch

EPC_XMIT_FIRST_DESC_ADDR equ    0c0h

EPC_XMIT_CURR_DESC_ADDR equ     0c4h

EPC_XMIT_HOST_DATA_ADDR equ     0c8h

EPC_XMIT_FRAGLIST_ADDR  equ     0cch

EPC_XMIT_DMA_DATALEN    equ     0d0h
XDMA_OWNER              equ     0200000h
XDMA_LASTDESC           equ     0100000h
XDMA_NOCRC              equ     0080000h
XDMA_IAF                equ     0040000h
XDMA_LFFORM             equ     0020000h
XDMA_FRAGLIST           equ     0010000h

EPC_XMIT_FRAG_CNT       equ     0d4h

EPC_XMIT_RAM_CURR_ADDR  equ     0d8h

EPC_XMIT_COPY_THRESH    equ     0dch

EPC_XMIT_EARLY_CNT      equ     0e0h

EPC_XMIT_DMA_STATUS     equ     0e4h
XDMA_XMIT_LEN           equ     0ffff0000h
XDMA_OWNER_STATUS       equ     0008000h
XDMA_EXCESSIVE_COLL     equ     0001000h
XDMA_COLLISION_CNT      equ     0001f00h
XDMA_DEFERRING          equ     0000080h
XDMA_OUT_OF_WINDOW_COLL equ     0000040h
XDMA_COLLISION_DETECT_HB equ    0000020h
XDMA_UNDERRUN           equ     0000010h
XDMA_CARRIER_SENSE_LOST equ     0000008h
XDMA_XMIT_WITH_COLL     equ     0000004h
XDMA_NON_DEFERRED_XMIT  equ     0000002h
XDMA_XMIT_OK            equ     0000001h

EPC_XMIT_RAM_BUFFER     equ     0e8h

EPC_XMIT_FIRST_DESC_ADDR2 equ    0ech

;ifdef   XE
 ;; Epic XE rev Cardbus register defs...
 EPC_FEVTR               equ     0F0h
 EPC_FETVR_MASK          equ     0F4h
 EPC_FPRSTR              equ     0F8h
 EPC_FFRCEVTR            equ     0FCh
;else
;EPC_XMIT_DMA_TEST       equ     0fch
;endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\portable.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/portable.INV   1.2   19 Sep 1997 21:39:10   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: MACROS which drive the way portable code is built
;

IFDEF              PORTABLE_INC
ELSE
PORTABLE_INC       equ    1

;--------------------------------------------------------------------------
; This file requires the inclusion of "equates.inc" before it is included.
;--------------------------------------------------------------------------
; This file must follow the definition (via inclusion or in-line) of one of
; the following configuration assemble-time switches.  The following IFNDEF
; statements take care of two situations:
;   1) the user of this file only needs to define the model it using as TRUE,
;      all other models will not be defined and will therefore be set FALSE,
;      which means all references to the model will use IF (not IFDEF or IFE).
;   2) a user who does not define any model will find that nothing is defined,
;      since all of the IFNDEF's will assemble.  A model must be selected.
;--------------------------------------------------------------------------

IFDEF DOSNDIS
ELSE
DOSNDIS              equ         FALSE
ENDIF

IFDEF OS2NDIS
ELSE
OS2NDIS              equ         FALSE
ENDIF

IFDEF NWSERVER
ELSE
NWSERVER             equ         FALSE
ENDIF

IFDEF DOSODI
ELSE
DOSODI               equ         FALSE
ENDIF

IFDEF OS2ODI
ELSE
OS2ODI               equ         FALSE
ENDIF

;--------------------------------------------------------------------------
; @CPUSH
;
; Description : Each driver inserts code that pushes the registers that must 
;               not be changed by a function called from C.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@CPUSH macro  name
IF DOSODI
 IFDEF XMIT_NO_COPY_DMA
    push    ebp            
    push    ebx
    push    esi
    push    edi
 ELSE
    push    bp
    push    bx
    push    di
    push    si
 ENDIF
ENDIF
IF OS2ODI
    push    ebp            
    push    ebx
    push    edi
    push    esi
ENDIF
IF DOSNDIS
    push    bp
    push    bx
    push    di
    push    si
ENDIF
IF OS2NDIS
    push    ebp
    push    ebx
    push    edi
    push    esi
ENDIF
IF NWSERVER
    CPush
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @CPOP
;
; Description : Each driver inserts code that pops the registers that must 
;               not be changed by a function called from C.  
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@CPOP macro  name
IF DOSODI
 IFDEF XMIT_NO_COPY_DMA
    pop     edi            
    pop     esi
    pop     ebx
    pop     ebp
 ELSE
    pop     si
    pop     di
    pop     bx
    pop     bp
 ENDIF
ENDIF
IF OS2ODI
    pop     esi
    pop     edi            
    pop     ebx
    pop     ebp
ENDIF
IF DOSNDIS
    pop     si
    pop     di
    pop     bx
    pop     bp
ENDIF
IF OS2NDIS
    pop     esi
    pop     edi            
    pop     ebx
    pop     ebp
ENDIF
IF NWSERVER
    CPop
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @PUSH_MUSTSAVE
;
; Description : Each driver inserts code that pushes the registers that must 
;               NEVER be changed by a function, others may be saved at times.
;               PUSH_MUSTSAVE contents must correlate to POP_MUSTSAVE.
;               PUSH_MUSTSAVE can't be written to allow POP_SAVE to save flags.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@PUSH_MUSTSAVE macro  name
IF DOSODI
    push    bx
ENDIF
IF OS2ODI
    push    ebx
ENDIF
IF DOSNDIS
ENDIF
IF OS2NDIS
ENDIF
IF NWSERVER
    push    ebp
    push    ebx
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @POP_MUSTSAVE
;
; Description : Each driver inserts code that pops the registers that must 
;               NEVER be changed by a function, others may be saved at times.
;               POP_MUSTSAVE contents must correlate to PUSH_MUSTSAVE.
;               POP_MUSTSAVE cannot save contents of Flags Register.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@POP_MUSTSAVE macro  name
IF DOSODI
    pop     bx
ENDIF
IF OS2ODI
    pop     ebx
ENDIF
IF DOSNDIS
ENDIF
IF OS2NDIS
ENDIF
IF NWSERVER
    pop     ebx
    pop     ebp
ENDIF
    ENDM

;--------------------------------------------------------------------------
; @PROC_BEGIN
;
; Description : Each driver inserts code that defines a procedure header.
;
; Entry       : The "name" is required as it precedes the "proc" directive,
;               the "distance" is optional, and will default to the size 
;               as specified by SEGMENT directives if it is not provided.
;
; Exit        : none
;
;--------------------------------------------------------------------------
@PROC_BEGIN macro  name, distance
IF DOSODI
            align 4
    public  name
name        proc   distance
ENDIF
IF OS2ODI
            align 4
    public  name
name        proc   distance
ENDIF
IF DOSNDIS
;            align 16
    public  name
name        proc   distance
ENDIF
IF OS2NDIS
            align 16
    public  name
name        proc   distance
ENDIF
IF NWSERVER
            align 16
    public  name
name        proc   distance
ENDIF
            ENDM

;--------------------------------------------------------------------------
; @PROC_END
;
; Description : Each driver inserts code that concludes a procedure, WITHOUT
;               the Return statement (avoids forcing jump-to-end to return).
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
@PROC_END   macro  name
IF DOSODI
name        endp
ENDIF
IF OS2ODI
name        endp
ENDIF
IF DOSNDIS
name        endp
ENDIF
IF OS2NDIS
name        endp
ENDIF
IF NWSERVER
name        endp
ENDIF
            ENDM


;--------------------------------------------------------------------------
; BREG
;
; Description : Each driver defines an equate which will be used by portable
;               code when referring to variables in the data segment.
;               The value of the EQU must evaluate to a valid value when
;               used, the EQU is always used within [] brackets.
;
; Entry       : none
;
; Exit        : none
;
;--------------------------------------------------------------------------
IF DOSODI
BREG    equ    0
ENDIF

IF OS2ODI
BREG    equ    bx
ENDIF

IF DOSNDIS
BREG    equ    0
ENDIF

IF OS2NDIS
BREG    equ    0
ENDIF

IF NWSERVER
BREG    equ    ebp
ENDIF

;--------------------------------------------------------------------------
; Macro for virtual to physical address conversion, only necessary for users 
; of LINEAR mode as opposed to SEGMENTED mode.  If using LINEAR mode, base
; register is 0, all virtual addresses must be converted to true physical 
;   (therefore this mode requires that the macro convert "source").
;
; If using SEGMENTED mode AND not running under a memory maanager, then DS
; is the true paragraph number to be assigned to the CURU base register, and
; any offset with the data segment is valid value to give CU/RU as an address 
;   (therefore this mode requires that the macro leave "source" as-is).
;
; If using SEGMENTED mode AND loaded under a memory manager, the DS value is
; not necessarily the TRUE paragraph number, but OFFSETs will be correct.
; At initialization time DS must converted if needed under memory manager. 
; In this situation, whether DS is same as TRUE paragraph or not, BUILD_PHYSICAL
; will leave "source" alone since is offsets are correct within TRUE paragraph.
;
; NOTE that can't use SEGMENTED mode and point to memory outside base Segment,
; because the SCB MACROs and structures always force the high-16 bits to zero.
;--------------------------------------------------------------------------
;- Build A Physical Address From A Logical Address
@BUILD_PHYS_OFFSET  MACRO    Source
    ENDM

;- Build A Physical Address From A Logical Address
@BUILD_PHYS_ADDRESS MACRO    Source
IF NWSERVER
    xchg    eax, Source
    call    MSMGetPhysical
    xchg    Source, eax
ENDIF
IF OS2ODI
    ;- call    DevHlp:VirtToPhys          ; NOTE macro can be used ANYTIME!
    mov     esi, Source
    call    ConvertToPhysicalAddress
    mov     Source, eax
ENDIF
IF (DOSNDIS OR OS2NDIS)
    mov     ax, ds
    mov     es, ax
    mov     esi, Source
    call    ConvertToPhysicalAddress
    mov     Source, eax
ENDIF
    ENDM


;--------------------------------------------------------------------------
; Macro to Output a string under Various and Random Netware Requirements.
;--------------------------------------------------------------------------
@PrintWarning  macro Msg
IF NWSERVER
    push    esi
    mov     esi, OFFSET Msg
    call    MSMPrintStringWarning
    pop     esi
ENDIF

IF (OS2ODI OR DOSODI)
    push    dx
IF  OS2ODI
    mov     dx, Msg
ENDIF    
IF  DOSODI
    mov     dx, OFFSET CGROUP:Msg
ENDIF    
    push    ax
    push    bx
    call    MSMPrintStringZero 
    pop     bx
    pop     ax
    pop     dx
ENDIF
    ENDM

;--------------------------------------------------------------------------
; Macro Used by routines which load a pointer to a string in AX to indicate
; that the routine encountered an error (therefore NDIS must return non-zero).
;--------------------------------------------------------------------------
@LOAD_MSGPTR macro msg
IF NWSERVER
    lea     eax, msg 
ENDIF
IF DOSODI
    lea     ax, msg 
ENDIF
IF OS2ODI
    mov     eax, msg 
ENDIF
IF (OS2NDIS OR DOSNDIS)
    xor     eax, eax
    dec     eax
ENDIF
    ENDM

;--------------------------------------------------------------------------
; Generic Register names used in portable code:
;
; Assumption here is that the NWSERVER code is using Flat 32-bit model, all
; pointers must be 32-bit pointers (relative to DS, whatever that is).  All
; other drivers using this code are assumed to be 16-bit Segment Model code.
;--------------------------------------------------------------------------

IF NWSERVER

RDI equ     edi
RSI equ     esi
RDX equ     edx
RCX equ     ecx
RBX equ     ebx
RAX equ     eax
RBP equ     ebp

ELSE

RDI equ     di
RSI equ     si
RDX equ     dx
RCX equ     cx
RBX equ     bx
RAX equ     ax
RBP equ     bp

ENDIF

ENDIF


; EOF - $Workfile:   portable.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\amd\sstrucs.inc ===
;
; Modifications:   $Header:   J:/archives/preboot/lsa2/inc/SSTRUCS.INV   1.4   19 Sep 1997 21:39:20   MJOHNSOX  $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description      :    NDIS structures and bit definitions for fields
;                         within those structures, name of driver, etc.
;                         THIS FILE HAS BEEN MODIFIED FROM NDIS NDK VERSION.
;

;
; File: sStrucs.inc    - Support Structures include NDIS specific.
;
;

;-----------------------------------------------------------------------------
;
;    The following equates are the primary configuration for the driver.
;
; * maximum number of multicast addresses.
;
NUM_MCADDRS        Equ       8
;
; * Maximum number of data blocks supported in a descriptor.
;
MAX_DATABLK        Equ    8
;

;-----------------------------------------------------------------------------
;
;    The following equates and structures should only be changed when
;    upgrading to a newer NDIS specification.
;

; * define the length of names and addresses in the Common Characteristics
; * and Specific Characteristics table.
;
NAME_LEN    Equ    16
ADDR_LEN    Equ    16
ADDR_SIZE   Equ    6

;
MIN_LOOKAHEAD_DEFAULT        Equ       MIN_PACKET+4
MAX_LOOKAHEAD                Equ       256

DELAY_COPY					 Equ	   -1
SUCCESS                      Equ       0000H
WAIT_FOR_RELEASE             Equ       0001H
REQUEST_QUEUED               Equ       0002H
FRAME_NOT_RECOGNIZED         Equ       0003H
FRAME_REJECTED               Equ       0004H
FORWARD_FRAME                Equ       0005H
OUT_OF_RESOURCE              Equ       0006H
INVALID_PARAMETER            Equ       0007H
INVALID_FUNCTION             Equ       0008H
NOT_SUPPORTED                Equ       0009H
HARDWARE_ERROR               Equ       000AH
TRANSMIT_ERROR               Equ       000BH
NO_SUCH_DESTINATION          Equ       000CH
ALREADY_STARTED              Equ       0020H
INCOMPLETE_BINDING           Equ       0021H
DRIVER_NOT_INITIALIZED       Equ       0022H
HARDWARE_NOT_FOUND           Equ       0023H
HARDWARE_FAILURE             Equ       0024H
CONFIGURATION_FAILURE        Equ       0025H
INTERRUPT_CONFLICT           Equ       0026H
INCOMPATIBLE_MAC             Equ       0027H
INITIALIZATION_FAILED        Equ       0028H
GENERAL_FAILURE              Equ       00FFH

; 
; * Packet filter bit definitions.
; 
FLTR_DIRECTED                Equ       01H
FLTR_MLTCST                  Equ       01H
FLTR_BRDCST                  Equ       02H
FLTR_PRMSCS                  Equ       04H
FLTR_SRC_RTG                 Equ       08H

; 
; * MAC status bits in the MAC Specific Characteristics table.
; * Bits 0-2 are coded to reflect the hardware status.
; 
HW_MISSING                   Equ       0000H
HW_BUD_ERR                   Equ       0001H
HW_CFG_ERR                   Equ       0002H
HW_FAULT                     Equ       0003H
HW_SOFT_ERR                  Equ       0004H
HW_OK                        Equ       0007H
MS_HW_MASK                   Equ       HW_OK

MS_BOUND                     Equ       0008H
MS_OPEN                      Equ       0010H
MS_DIAGS_ON                  Equ       0020H

;
;    Definintions for the MAC Service Supported Flags.
;    Bits 0-15.
;
BroadcastSupport             Equ       TRUE
MulticastSupport             Equ       TRUE
FunctionalGroupSupport       Equ       FALSE
PromiscuousSupport           Equ       TRUE
SetStationAddrSupport        Equ       TRUE
StatusAlwaysCurrent          Equ       FALSE
DiagnosticsSupport           Equ       FALSE
LoopBackSupport              Equ       FALSE
ReceiveChainPrimary          Equ       FALSE
IBMSourceRouting             Equ       FALSE
ResetMACSupport              Equ       TRUE
OpenAdapterSupport           Equ       TRUE
InterruptRequestSupp         Equ       TRUE
SourceRoutingBridge          Equ       FALSE
GDTAddressesSupported        Equ       TRUE
MultipleXferDatas            Equ       TRUE      ; Also set MaxXferDatas
RcvLkFrameSizeZero           Equ       FALSE

;
; * Definintions for the MAC Service Supported Flags.
; * Bits 0-14.
;
ServiceFlags    =  00000000H
ServiceFlags    =  ServiceFlags Or BroadcastSupport
ServiceFlags    =  ServiceFlags Or (MulticastSupport Shl 1)
ServiceFlags    =  ServiceFlags Or (FunctionalGroupSupport Shl 2)
ServiceFlags    =  ServiceFlags Or (PromiscuousSupport Shl 3)
ServiceFlags    =  ServiceFlags Or (SetStationAddrSupport Shl 4)
ServiceFlags    =  ServiceFlags Or (StatusAlwaysCurrent Shl 5)
ServiceFlags    =  ServiceFlags Or (DiagnosticsSupport Shl 6)
ServiceFlags    =  ServiceFlags Or (LoopBackSupport Shl 7)
ServiceFlags    =  ServiceFlags Or (ReceiveChainPrimary Shl 8)
ServiceFlags    =  ServiceFlags Or (IBMSourceRouting Shl 9)
ServiceFlags    =  ServiceFlags Or (ResetMACSupport Shl 10)
ServiceFlags    =  ServiceFlags Or (OpenAdapterSupport Shl 11)
ServiceFlags    =  ServiceFlags Or (InterruptRequestSupp Shl 12)
ServiceFlags    =  ServiceFlags Or (SourceRoutingBridge Shl 13)
ServiceFlags    =  ServiceFlags Or (GDTAddressesSupported Shl 14)
ServiceFlags    =  ServiceFlags Or (MultipleXferDatas Shl 15)
ServiceFlags    =  ServiceFlags Or (RcvLkFrameSizeZero Shl 16)

MAC_Type    Equ    <'DIX+802.3'>       ; Specific Characteristic Type.
;
; Protocol Manager opcodes used by the generic model
;
GetPMInfo                    Equ       1
RegisterModule               Equ       2
BindAndStart                 Equ       3
GetPMLinkage                 Equ       4

Ifdef AVL
;-----------------------------------------------------------------------------
; 
; * multicast address structure is ADDR_LEN bytes long
; 
MCastAddr   Struc
mAddr       DB     ADDR_LEN dup(0)
MCastAddr   Ends

; 
; * the multicast address buffer manages NUM_MCADDRS multicast address
; * structures.
; 
MCastBuf    Struc
McbMax      DW     ?    ;  max # of multicast addresses
McbCnt      DW     ?    ;  curr# "        "

McbAddrs    DB     size MCastAddr*NUM_MCADDRS dup(0)
MCastBuf    Ends
Endif	;; AVL 

;-----------------------------------------------------------------------------
;
;    Structures defined by the NDIS specification and used by the generic
;    model.
;
;-----------------------------------------------------------------------------
; * immediate data buffer length cannot exceed 64 bytes.
; 
MAX_IMMED_LEN      Equ       64
; 
; * Maximum number of data blocks supported in a Tx descriptor.
; 
MAX_TX_DATABLK     Equ       MAX_DATABLK
; 
; * Max number of TransferData blocks
; 
MAX_TD_DATABLK     Equ       MAX_DATABLK
; 
; * MAx number of ReceiveChain data blocks
; 
MAX_RX_DATABLK     Equ       MAX_DATABLK

; 
; * Data structures for TransmitChain (Tx), TransferData (TD), and
; * ReceiveChain (Rx).
; 
TxDataBlock Struc
TxPtrType   DB     ?        ; 0 => Phys pointer, 1 => GDT pointer
TxRsvdByte  DB     ?        ; Reservered, must be zero.
TxDataLen   DW     ?        ; Data block length in bytes.
TxDataPtr   DD     ?        ; Far pointer to data block.
TxDataBlock Ends

; 
; * TransmitChain descriptor structure definition
; 
TxBufDesc   Struc
TxImmedLen  DW     ?        ; Byte count of immediate data, max=64
TxImmedPtr  DD     ?        ; Virtual address of Immediate data
TxDataCount DW     ?        ; Number of Data Blocks (max = 8)
TxDataBlk   DB     size TxDataBlock * MAX_TX_DATABLK dup(0)
TxBufDesc   Ends

TxBufDescrSize    Equ    Size TxImmedLen + Size TxImmedPtr + Size TxDataCount

; 
; * TransferData data block description
; 
TDDataBlock Struc
TDPtrType   DB     ?        ; 0 => Phys pointer, 1 => GDT pointer
TDRsvdByte  DB     ?        ; Reservered, must be zero.
TDDataLen   DW     ?        ; Data block length in bytes.
TDDataPtr   DD     ?        ; Far pointer to data block.
TDDataBlock Ends

; 
; * TransferData descriptor structure
; 
TDBufDesc   Struc
TDDataCount DW    ?        ; No of Data Blocks (max 8 for V1.01).
TDDataBlk   DB    size TDDataBlock*MAX_TD_DATABLK dup(0)
TDBufDesc   Ends

; 
; * ReceiveChain data block structure definition
; 
RxDataBlock Struc
RxDataLen   DW    ?        ; Length of the Data Block
RxDataPtr   DD    ?        ; Far Pointer to Data Block
RxDataBlock Ends

; 
; * ReceiveChain descriptor structure definition
; 
RxBufDesc   Struc
RxDataCount DW    ?        ; No of Data Blocks. (max 8 for V1.01).

RxDataBlk   DB    size RxDataBlock*MAX_RX_DATABLK dup(0)
RxBufDesc   Ends


;-----------------------------------------------------------------------------
; 
;    Structures used in Protocol.Ini parsing.
;
;  
; * Data structures for the "Module Configuration" structure parsed from
; * the PROTOCOL.INI file. see NDIS spec for details.
; 
Param       Struc
ParamType   DW    ?    ; 0 => 31 bit signed integer, 1 => string
ParamLen    DW    ?    ; String length (including null) or 4.
ParmStart   DB    ?    ; Start of actual parameter.
Param       Ends

KeywordEntry       Struc
NextKeywordEntry   DD        ?                   ;  Forward pointer
PrevKeywordEntry   DD        ?                   ;  Back Pointer
KeyWord            DB        NAME_LEN Dup(?)     ;  Keyword on left side of "="
NumParams          DW        ?                   ;  Number of parameters on r. side of "="
Params             DB        Size Param dup(?)   ;  Actual size depends on NumParams
KeywordEntry       Ends


ModCfg      Struc
NextModCfg  DD     ?                   ;  Module config images are in a
PrevModCfg  DD     ?                   ;  double-linked list.
ModName     DB     NAME_LEN Dup(?)     ;  Bracketed Module Name.
KE          DB     Size KeywordEntry Dup(?) ;  Head of Keyword list
ModCfg      Ends

ProIni      Struc
MC          DB     Size ModCfg*1 dup(?)  ; Head of Module config list.
ProIni      Ends

PI_Record   Struc
Srchkeyword        DB        '                ' ; keyword.
SrchParmType       DW        ?         ; 0 - numeric, 1 - string. see below.
ParamField         DD        ?         ; If numeric, will contain value, 
                                       ; If string, will contain the pointer to string.
RequiredField      DB        ?         ; Set to 1 if parameter is required.
SetFCN             DW        ?         ; Offset to Parser function.
PI_Record   Ends


;
; Processor Type Equates.
;
EIGHT_BIT          equ       0001H
SIXTEEN_BIT        equ       0002H
PROC_TYPE_MASK     equ       0030H

PROC_8086          equ       0000H OR EIGHT_BIT
PROC_80286         equ       0010H OR SIXTEEN_BIT
PROC_80386         equ       0020H
PROC_80486         equ       0040H


; EOF - $Workfile:   sstrucs.inc  $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\pci.inc ===
;
; Modifications:   $Header: /Client Boot/NICS/3Com/3C90xB/UNDI/PCI.INC 2     22/07/98 8:30p John Lobraico $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

ifndef _PCI_INC
_PCI_INC = 1

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Structures and records
;


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Equates
;

PCI_IRQ_LINE	equ	3Ch


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; Macros
;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; PCI_READ_BYTE
;	Read one byte from PCI configuration space.
;
; passed:
;	BH := PCI bus number
;	BL := PCI device (bits 7-3) & function (bits 2-0) numbers
;	DI := Offset into PCI configuration space (00h to FFh)
;
; returns:
;	SUCCESS
;		CY := 0
;		AH := 0
;		CL := Byte read from PCI configuration space
;
;	FAILURE
;		CY := 1
;		AH := 81h (Unsupported function)
;		AH := 87h (Bad PCI register number)
;
PCI_READ_BYTE macro
	mov	ax, 0B108h
	int	1Ah
	endm

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; PCI_READ_WORD
;	Read one word from PCI configuration space.
;
; passed:
;	BH := PCI bus number
;	BL := PCI device (bits 7-3) & function (bits 2-0) numbers
;	DI := Offset into PCI configuration space (00h to FEh)
;
; returns:
;	SUCCESS
;		CY := 0
;		AH := 0
;		CX := Word read from PCI configuration space
;
;	FAILURE
;		CY := 1
;		AH := 81h (Unsupported function)
;		AH := 87h (Bad PCI register number)
;
PCI_READ_WORD macro
	mov	ax, 0B109h
	int	1Ah
	endm

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; PCI_READ_DWORD
;	Read one dword from PCI configuration space.
;
; passed:
;	BH := PCI bus number
;	BL := PCI device (bits 7-3) & function (bits 2-0) numbers
;	DI := Offset into PCI configuration space (00h to FCh)
;
; returns:
;	SUCCESS
;		CY := 0
;		AH := 0
;		ECX := Dword read from PCI configuration space
;
;	FAILURE
;		CY := 1
;		AH := 81h (Unsupported function)
;		AH := 87h (Bad PCI register number)
;
PCI_READ_DWORD macro
	mov	ax, 0B10Ah
	int	1Ah
	endm


endif ;_PCI_INC

; EOF - $Workfile: PCI.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\9432umac.asm ===
;----------------------------------------------------------------------------
; 9432UMAC.ASM
;
;   (C) Lanworks Technologies Inc. 1995. All rights reserved.
;
;$History: 9432UMAC.ASM $
; 
; *****************  Version 1  *****************
; User: Paul Cowan   Date: 26/08/98   Time: 9:40a
; Created in $/Client Boot/NICS/SMC/9432/UNDI
;
; 10-Sep-97 1.10 PC - uses new TCP/IP NID and AI
; 29-Apr-97 1.00 PC - first release
;----------------------------------------------------------------------------
UMAC_MAIN	equ	1

ETHERNET	equ	9432
EPIC		equ	1
EPIC100		equ	1
PCI		equ	1

PCI_VENDOR_ID	equ	000010b8h
PCI_DEVICE_ID	equ	5

MAXPACKETDATASIZE  =	1514		; max packet data size
STATUS_PENDING	= 1

;;locals
	.xlist
;;	include \rom\sdk\include\drvseg.inc
;;	include \rom\sdk\include\bwnad.inc
;;	include \rom\sdk\include\bwequ.inc
    include 	undi_equ.inc
    include 	pxe_stru.inc
    include 	bwstruct.inc
    include 	spdosegs.inc
	include epic100.inc
	include lmstruct.inc
	.list

;;.386

INT_CTRL1	EQU	020h		; 8259A Int Controller #1
INT_CTRL1_MR	EQU	021h		; 8259A Int Controller #1
INT_CTRL1_ELR	EQU	4d0h		; 8259A Int Controller #1
INT_CTRL2	EQU	0a0h		; 8259A Int Controller #2
INT_CTRL2_MR	EQU	0a1h		; 8259A Int Controller #2
INT_CTRL2_ELR	EQU	4d1h		; 8259A Int Controller #2

EOI_SPECIFIC	EQU	060h		; Specific interrupt EOI


TRANSMIT_ERROR  EQU 0bh

;;extrn	PrintAt:near
;;extrn 	Print:near
;;extrn	PrintChar:near

;;extrn	ReadConfig:near
;;extrn	DoConfig:near


extrn	GetED:near
extrn	PostED:near
extrn	UNDI_DriverISR:far

extrn	Net_Address:byte
extrn	Node_Address:byte


extrn	LM_GetCnfg:near
extrn	LM_Send:near
extrn	LM_Initialize_Adapter:near
extrn	LM_Enable_Adapter:near
extrn	LM_Disable_Adapter:near
extrn	LM_Open_Adapter:near
extrn	LM_Service_Events:near
extrn	LM_Change_Receive_Mask:near
extrn	LM_Add_Multi_Address:near
extrn	LM_Delete_Multi_Address:near
extrn	LM_Receive_Copy:near
extrn	LM_Close_Adapter:near

;;extrn   Puts:near


extrn	IOBase:word
extrn	IRQNumber:byte


.386P

public	AS

public	UM_Send_Complete
public	UM_Receive_Copy_Complete
public	UM_Status_Change
public	UM_Interrupt
public	UM_Card_Services
public	UM_Receive_Packet


public	NADInit
public	NADReset
public	NADShutDown
public	NADOpen
public	NADClose
public	NADSetFilter
public	NADGetStatistics
public  NADMCastChange
public  NADTransmitPacket
public  DriverISR_Proc
public  NADInitiateDiags
public  NADSetMACAddress


public   OrgIntVector_OFF
public   OrgIntVector_SEG


Assume  CS:CGroup, DS:DGroup

;--------------------------------------------------------------------
;;START_CODE
_TEXT	Segment para public



;;	include \rom\sdk\include\bwnadapi.asm


;--------------------------------------------------------------------
; NADInitialize
;
;--------------------------------------------------------------------
NADInit proc near

;;	mov	bx, offset DGroup:StrPrompt
;;	call	PrintAt			; print initializing message

;;db  0f1h


;;;   	lea	bp, DGroup:LanOption
;;;   	call	puts


	call	FindAdapter		; find and reset LAN adapter
	or	dx, dx			; did we find the adapter?
	jne	xx_found
;	mov	ax, offset DGroup:NicNotFound	; return error message
	stc
	ret

xx_found:
;;	call	ReadConfig		; read configuration from adapter

	call	InitializeAdapter
	or	ax, ax			; was there an error?
	je	initOK2			; no error
    stc
	ret				; return (with error message in ax)

initOK2:
    mov ax, ds
    mov DGroup:StoreDS, ax
    clc
	xor	ax, ax			; return no error
	ret

NADInit endp



;------------------------------------------------------------------------------
; StartTime - save maxtick count, get current tick value
;	Timeout is ticks, each tick is 55 ms.
;	Note: this routine can only be called once the PC timer
;	and its interrupt are setup (INT19 and beyond are OK)
;
; On entry,
;	AX = max ticks to wait
;	ints enabled
;
; On exit,
;	all preserved
;
; 881030 1.0 GK
;------------------------------------------------------------------------------

StartTime	proc	near

		push	ax
		push	cx
		push	dx
        push    di  
        push    es

		mov	DGroup:MaxTicks, ax
;;		mov	ah, 0
;;db  0f1h
;;		int	1Ah				; get current tick value
        mov     ax, 40h
        mov     es, ax
        mov     di, 6Ch
        mov     dx, es:[di]
        mov     cx, es:[di+2]
		mov	DGroup:StartTick, dx		; save it

        pop es
        pop di
		pop	dx
		pop	cx
		pop	ax
		ret

StartTime	endp


;------------------------------------------------------------------------------
; CheckTime - gets current tick value, compares with maxticks
;	Timeout is ticks, each tick is 55 ms.
;	Note: this routine can only be called once the PC timer
;	and its interrupt are setup (INT19 and beyond are OK)
;
; On entry,
;	maxticks set by StartTime
;	ints enabled
;
; On exit,
;	CY set if timeout
;	all registers preserved
;
; 881030 1.0 GK
;------------------------------------------------------------------------------

CheckTime	proc	near

		push	ax
		push	cx
		push	dx
        push    di  
        push    es

;;		mov	ah, 0
;;		int	1Ah			; get current tick

        mov     ax, 40h
        mov     es, ax
        mov     di, 6Ch
        mov     dx, es:[di]
        mov     cx, es:[di+2]

		sub	dx, DGroup:StartTick
		cmp	dx, DGroup:MaxTicks
		cmc

        pop es
        pop di
		pop	dx
		pop	cx
		pop	ax

		ret				; return with CY set if timeout

CheckTime	endp




;--------------------------------------------------------------------
; FindAdapter
;
; Parameters:
;	none
;
; Returns:
;	dx = I/O address
;--------------------------------------------------------------------
FindAdapter proc near

	mov	ax, 0b101h
	int	1ah			; check for PCI BIOS
	jc	notFound		; device not found

	cmp	edx, ' ICP'		; check for PCI signature
	jne	notFound		; return "not found" error

	mov	dx, PCI_VENDOR_ID	; PCI vendor ID
	mov	cx, PCI_DEVICE_ID	; PCI device ID
	mov	si, 0			; index
	mov	ax, 0b102h
	int	1ah			; find PCI device
	jc	notFound		; device not found

	mov	di, 10h			; register number (I/O address)
	mov	ax, 0b109h
	int	1ah			; read PCI config word
	jc	notFound		; device not found

	and	cl, 80h
	push	cx			; save address on stack

	mov	dx, cx
	add	dx, EPC_GEN_CONTROL
	mov	ax, GC_SOFT_RESET
	out	dx, ax			; reset the NIC

; delay for > 1 us (15 pci clocks)
	mov	cx, 100h
reset_delay:
	mov	al, DGroup:StatusFlag
	loop	reset_delay

	pop	dx			; return address in dx
	ret

notFound:
	xor	dx, dx			; return 0 - adapter not found
	ret

FindAdapter endp

;---------------------------------------------------------------------
;  Routine Name:  NetInitialize Routine
;
;  Description: The NetInitialize routine is responsible for initial-
;		izing the adapter.  This routine is called from the
;		NETINT code when it is ready to use the adapter to
;		send the first request out to the network.
;  On entry,
;		DS = DGroup
;		ints enabled
;
;  On exit,
;		AX - return code (0 = good completion)
;
;  Calls:
;
;---------------------------------------------------------------------
InitializeAdapter proc near

;	push	cs
;	pop	ds			; ds = cs

	mov	DGroup:[AS.pc_bus], PCI_BUS
	mov	DGroup:[AS.slot_num], 16

	mov	bp, offset DGroup:AS

    push    es
    push    ds
    pop     es

;db  0f1h
	call	LM_GetCnfg		; try and find the SMC adapter

    pop     es

	cmp	ax, ADAPTER_AND_CONFIG
	je	getCnfgOK

	mov	ax, offset DGroup:InitError
	ret				; return error code

getCnfgOK:
	mov	ax, offset DGroup:HostRAM
	mov	dx, ds
	mov	word ptr DGroup:[AS.host_ram_virt_addr], ax
	mov	word ptr DGroup:[AS.host_ram_virt_addr+2], dx
	mov	word ptr DGroup:AS.setup_ptr.virtual_addr, ax
	mov	word ptr DGroup:AS.setup_ptr.virtual_addr+2, dx

	and     edx, 0ffffh
	shl     edx, 4
	and     eax, 0ffffh
	add     edx, eax
	mov     DGroup:AS.host_ram_phy_addr, edx
	mov	    DGroup:AS.setup_ptr.phy_addr, edx

foundAdapter:

;	First, the maximum packet size and number of transmit buffers,
;	the memory address used by the host (seg:off in this code),
;	and the pointers to error counters are set before calling
;	LM_Initialize_Adapter.	Since Token Ring and Ethernet use
;	different errors, an IFDEF is used to initialize the correct
;	pointers.  Interrupts are disabled before installing new
;	interrupt vector, and are not enabled until after
;	LM_Initialize_Adapter is called in order to prevent the
;	mishandling of spurious interrupts.  STATUS_PENDING is used to
;	determine when the call is completed.  Since UM_Status_Change
;	may be called inside of LM_Initialize_Adapter, STATUS_PENDING
;	is set before the call.  If the adapter initialize
;	successfully, we set the multicast addresses (different for
;	Token ring and Ethernet) and open the adapter.	We return after
;	opening the adapter.

;  set up the values needed by LM_Initialize_Adapter
;  (num_of_tx_bufs defaults to 1)

	mov	DGroup:[AS.rx_lookahead_size], 4
	mov	DGroup:[AS.max_packet_size], MAXPACKETDATASIZE
;	mov	[AS.media_type], MEDIA_UNKNOWN
	or	DGroup:[AS.adapter_flags], ENABLE_TX_PENDING

	push	ds
	pop	es			; ES = DS
	lea	di, DGroup:AS.ptr_rx_CRC_errors
	mov	si, offset DGroup:eth_rx_CRC_errors
	mov	cx, 15			; 15 error counters are defined

defineEthErrPtrs:
	mov	ax, si
	stosw
	add	si, 4			; next dword error variable
	mov	ax, ds
	stosw
	loop	defineEthErrPtrs

	cli				; ints off

	mov	ax, offset CGroup:UNDI_DriverISR



	mov	bl, byte ptr DGroup:AS.irq_value
	xor	bh, bh
	call	HookIntVector
	or	DGroup:statusFlag, STATUS_PENDING

	mov	DGroup:AS.receive_mask,  0 ; ACCEPT_PHYSICAL

	push	ds
	pop	es			; es = ds

;db  0f1h
	call	LM_Initialize_Adapter
	sti				; enable ints again

;db  0f1h
	or	ax, ax			; was there an error?
	jz	AdapterInitOk		; no error

	push	ax			; save retcode
	call	UnhookIntVector 	; restore int vector and mask PIC
	pop	ax

	mov	ax, offset DGroup:msg_initerror

;GetLMErrStr:
;	test	word ptr [bx], -1	; reached end of errcode table?
;	jz	FoundLMErrStr		; yes, return default message

;	cmp	ax, [bx]
;	jz	FoundLMErrStr		; [bx+2] has err msg offset

;	add	bx, 4
;	jmp	short GetLMErrStr

;FoundLMErrStr:
;	mov	ax, [bx+2]		; AX has errmsg offset
	jmp	init_exit		; return with error msg

AdapterInitOk:
; -- wait up to 10s for adapter to initialize. The call to UM_Status_Change
;    from the LMAC will cause the STATUS_PENDING bit to be reset.

;db  0f1h
	mov	ax, 0182		; wait up to 10s
	call	StartTime

InitPendLoop:
	test	DGroup:statusFlag, STATUS_PENDING
	jz	InitCompleted

	call	CheckTime
	jnc	InitPendLoop

	call	UnhookIntVector 	; clean up interrupt stuff
	mov	ax, offset DGroup:msg_initerror ; "Error initializing adapter"
	jmp	short init_exit		; return AX errmsg offset

InitCompleted:
; Now open the adapter onto the network.

	or	DGroup:statusFlag, STATUS_PENDING
;;	call	LM_Open_Adapter
    jmp     OpenCompleted1    

OpenCompleted1:

	mov	si, offset DGroup:AS.Xnode_address
	mov	di, offset DGroup:Node_Address
	mov	cx, 6
	rep	movsb			; copy node address

	mov	si, offset DGroup:AS.Xnode_address
	mov	di, offset DGroup:Net_Address
	mov	cx, 6
	rep	movsb			; copy node address

    mov	    ax, DGroup:AS.io_base
	mov	    DGroup:[IOBase], ax	; UNDI_NAD variable
	mov	    al, byte ptr DGroup:AS.irq_value
	mov	    DGroup:[IRQNumber], al ; UNDI_NAD variable


    in  ax, 60h         ;

	xor	ax, ax			; no errors

init_exit:
	ret				; Return to caller

InitializeAdapter endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
NADReset proc near

;db  0f1h
    call    NADClose
	ret

NADReset endp

;--------------------------------------------------------------------
; NADDisengage
;
;--------------------------------------------------------------------
NADDisengage proc far

	push	ds			; save callers' DS
	mov	bp, offset DGroup:AS

   	or	DGroup:statusFlag, STATUS_PENDING
;db  0f1h
	call	LM_Close_Adapter
   	or	ax, ax
   	jnz	NADCloseFailed

   	mov	ax, 637 		; wait up to 35s for open
   	call	StartTime

NADClosePendLoop:
   	test	DGroup:statusFlag, STATUS_PENDING
   	jz	NADCloseCompleted

   	call	CheckTime
   	jnc	NADClosePendLoop


NADCloseFailed:
	pop	ds			; restore callers' DS
    stc
    ret

;  Status changed -- see if adapter is open; if so, set good retcode

NADCloseCompleted:
    cmp	DGroup:AS.adapter_status, CLOSED
    jnz	NADCloseFailed

	call	LM_Disable_Adapter
	call	UnhookIntVector 	; restore int vector and mask PIC

	pop	ds			; restore callers' DS
    clc
	ret				; Return to caller

NADDisengage endp

;---------------------------------------------------------------------
;  Routine Name:  Adapter Interrupt Handler Routine
;
;  Description: The Adapter Interrupt Handler Routine is what is called
;		when an interrupt is asserted from the adapter.
;		This routine first calls LM_Disable_Adapter, then
;		LM_Service_Events. LM_Service_Events will then make
;		calls back to us  to complete interrupt processing.
;		After returning to us, we must issue an LM_Enable_Adapter
;		to enable further adapter interrupts.
;
; 920902 - 0.0 GK
;---------------------------------------------------------------------
OurInterruptHandler proc far


	cld
	cli

	pusha				; save all registers
	push	ds			; save ds
	push	es			; save es



	mov	bp, offset DGroup:AS	; get pointer to adapter structure

	;  call LM_Disable_Adapter to prevent further interrupts from adapter
	call	LM_Disable_Adapter
	call	IssueEOI		; EOI the int controller
	sti				; allow other interrupts to occur

;db  0f1h
	call	LM_Service_Events
	cli
	; reenable the adapter
	call	LM_Enable_Adapter

	pop	es			; restore es
	pop	ds			; restore ds
	popa				; restore all registers

	iret				; Return from interrupt

OurInterruptHandler endp

;--------------------------------------------------------------------
;  IssueEOI
;
;  Description: The IssueEOI routine issues a EOI to the interrupt
;		controller.  This is done differently (maybe) depend-
;		on whether we're under DOS or OS/2.
;
;  Input:	DS:BX - adapter ACB
;
;  Output:	none
;
;  Calls:	none
;---------------------------------------------------------------------
IssueEOI proc near

	mov	al, byte ptr DGroup:AS.irq_value
					; Get the int level
	cmp	al, 7			; Is it on secondary ctrlr ?
	jbe	int_prim		;   No, its on controller #1

	sub	al, 8			; Adjust int level
	or	al, EOI_SPECIFIC	; Make it specific EOI
	out	INT_CTRL2, al		; EOI controller #1
	mov	al, 2			; Set int level 2

int_prim:
	or	al, EOI_SPECIFIC	; Make it specific EOI
	out	INT_CTRL1, al		; EOI controller #1

	ret				; Return to caller

IssueEOI endp

;--------------------------------------------------------------------
; HookIntVector  - hook int vector given by adapterStruc.irq_value
;
; On entry,
;	ax - handler function offset
;	bx - interrupt number
;	ints disabled
;
; On exit,
;	???
;
; 931223 2.7 GK doesn't convert INT9 back to INT2 when installing vector
; 920910 0.0 GK
;--------------------------------------------------------------------

HookIntVector proc near

	pusha				; save all registers
	mov	si, ax			; save function offset in si
	cli				; disable interrupts

;	test	byte ptr cs:ATFlag, -1
;	jz	int_adj_skip		; not running on AT, keep at int 2

	cmp	bl, 2			; Is interrupt level = 2 ?
	jne	int_adj_skip		;   No, skip this

	mov	bl, 9			; Set interrupt level 9

int_adj_skip:
	mov	dx, INT_CTRL1_MR	; Set int controller #1
	mov	cx, bx			; Save int level in cx
	cmp	cl, 7			; We on right controller ?
	jbe	ctrler_ok		;   Yep, continue

	mov	dx, INT_CTRL2_MR	; Set int controller #2
	sub	cl, 8			; Adjust int level offset

ctrler_ok:
	mov	ah, 11111110b		; Make IRQ mask
	rol	ah, cl			; Put enable bit in right

	mov	dGroup:irq_mask, ah	; Save interrupt enable mask

	push	ax			; Save enable mask
	push	dx			; Save int controller port

	mov	al, bl			; Get IRQ number
	cmp	al, 9			; Is it level 9 ?
	jne	int_lvl_ok		;   No, skip this

;931223 mov	al, 2			; Make it level 2

int_lvl_ok:
	add	al, 08h 		; Point to correct INT
	cmp	al, 10h 		; Is it below INT 10h ?
	jb	int_set 		;   Yes, go set it up

	add	al, 60h 		; Point to correct INT

int_set:
	push	ax			; Save INT number

	xor	bx, bx			; Clear target register
	mov	es, bx			; es = 0
	mov	bl, al			; Copy INT vector
	shl	bx, 1			; Point to vector in memory
	shl	bx, 1			; Point to vector in memory
	mov	dGroup:IvtOffset, bx	; save IVT offset

;;	mov	ax, es:[bx]		; get old vector
;;	mov	word ptr dGroup:OldIntVector, ax
;;	mov	ax, es:[bx+2]
;;	mov	word ptr dGroup:OldIntVector+2, ax


	mov	ax, es:[bx]		; get old vector
	mov	word ptr dGroup:OrgIntVector_OFF, ax
	mov	ax, es:[bx+2]
	mov	word ptr dGroup:OrgIntVector_SEG, ax


	pop	ax			; Restore INT number

; * Dmitry *
;;;;;db  0f1h

	mov	es:[bx], si		; set new interrupt vector offset
	mov	es:[bx+2], cs		; set new interrupt vector segment

	pop	dx			; Restore int controller
	pop	ax			; Restore int enable mask
	in	al, dx			; Get current IRQs
	jmp	$+2			; slow
	and	al, ah			; Add in our's
	out	dx, al			; Put it back into 8259

	popa				; restore registers
	sti				; enable interrupts
	ret

HookIntVector endp

;--------------------------------------------------------------------
; UnhookIntVector - remove our int handler from the IVT chain
;
; On entry,
;	HookIntVector has been called
;	DS = CS
;
; On exit,
;	AX, BX, DX, ES modified
;
; 931223 2.7 - GK leaves INT9 interrupt enabled
; 920910 0.0 - George Kostiuk
;--------------------------------------------------------------------
UnhookIntVector proc near

; --- first disable adapter-specific int

	mov	bx, dGroup:IvtOffset	; get IVT offset
	cmp	bx, 0
	je	unhookExit

	xor	ax, ax			; Point to int vector memory
	mov	es, ax
;931223 for POST
	cmp	bx, 1C4h		; slave INT 9??
	jz	UnhookIVT		; yes, keep the int enabled
;931223 for POST

	mov	dx, INT_CTRL1_MR	; assume master PIC
	or	bh, bh			; slave PIC?
	jz	MaskIntOff

	mov	dx, INT_CTRL2_MR	; slave PIC

maskIntOff:
	mov	ah, DGroup:irq_mask		; AH has enable mask
	not	ah			; invert it to get disable mask
	in	al, dx
	jmp	$+2
	or	al, ah			; mask the interrupt
	out	dx, al

unhookIVT:
	cli

;;	mov	ax, word ptr DGroup:OldIntVector
;;	mov	es:[bx], ax		; restore old vector
;;	mov	ax, word ptr DGroup:OldIntVector+2
;;	mov	es:[bx+2], ax

	mov	ax, word ptr DGroup:OrgIntVector_OFF
	mov	es:[bx], ax		; restore old vector
	mov	ax, word ptr DGroup:OrgIntVector_SEG
	mov	es:[bx+2], ax

	sti

unhookExit:
	ret

UnhookIntVector endp

;----------------------------------------------------------------------
;  Routine Name:  NADTransmitPacket Routine
;
;  Description:
;	Called to send a frame out onto the network.
;
; The ED is set up with the frame data descriptors pointing to
; the packet data to be transmitted.  The packet is to be
; transmitted in RAW mode where the entire packet, including
; the MAC header is included in the fragment buffers.
;
;  Input:	ES:SI - pointer to ED (ES != DS)
;		DS = RAM Base
;
;  Output:	ED.retcode field updated
;
;----------------------------------------------------------------------
;TxEDPtr dd 0
NADTransmitPacket proc near

;db  0f1h

	push	ds			; Save data segment


	pushf				; Save flags

;;cli

; ********* DMitry *************

;db  0f1h
        push    si
        push    es
        push    ds

        push    ds
        push    es
        pop     ds
        pop     es

		cld					; Clear direction
		mov	di, offset DGroup:TxPacket

        mov bx, si

		mov	cx, ds:[bx].ED_FragCount   ; Get fragment count
		lea	bx, [bx].ED_FragOff	; point to first framedesc
        xor dx, dx

Tx_Frag_Loop:
		push	cx			; save fragment count
		push	ds			; save fragment descriptor list segment
		mov	cx, ds:[bx].DLen	; length of this fragment
        add dx, cx

		lds	si, ds:[bx].DPointer	; location of this fragment
		rep	movsb

Tx_Frag_End:	
        
        pop	ds			; restore frag descriptor list segment
		pop	cx			; restore fragment count
		add	bx, size Descript_Struct ; next descriptor
		loop	Tx_Frag_Loop		; loop through all fragments

        pop ds
        pop es
        pop si

	cli				; Disable interrupts

	; We must convert the fragment list to physical addresses.
	mov	cx, 1 ; get fragment count
	mov	DGroup:FragCount, cx
    mov cx, dx

	mov	di, offset DGroup:Frag1

;copyTxFrags:


    mov ebx,    CR0
    test    bx, 1
    je      real_mode
    mov ax, Dgroup:StoreDS
    jmp short   p_mode

real_mode:
	mov	ax, ds

p_mode:
    and eax, 0ffffh
	shl	eax, 4
	mov	dx, offset DGroup:TxPacket
    and edx, 0ffffh 
	add	eax, edx
	mov	[di], eax
    mov	ax, cx
	or	ax, PHYSICAL_ADDR
	mov	[di+4], ax


	mov	cx, es:[si].ED_Length	; CX has packet_size

	cmp	cx, 60
	jae	EthTxSizeOk

	mov	cx, 60

EthTxSizeOk:
	mov	byte ptr DGroup:TxDoneFlag, 0	; clear Tx Done

	push	si			; save ED pointer
	push	es			; save es

	push	ds
	pop	es			; set es = ds

	mov	si, offset DGroup:FragCount
	mov	bp, offset DGroup:AS
	sti				; Enable interrupts

;db  0f1h
	call	LM_Send
;	sti				; Enable interrupts

	pop	es			; restore es

	mov	ax, 5			; wait up to 5 ticks for Tx complete
	call	StartTime
	xor	ax, ax			; prepare errCode = 0

	pop	si			; restore ED pointer

TxPendLoop:
	cmp	byte ptr DGroup:TxDoneFlag, al
	jnz	SetEDCCode

	call	CheckTime
	jnc	TxPendLoop

	mov	ax, -1	                    ; fatal
	mov	bx, offset DGroup:NoNetMsg	; not installed or not connected

;  post the ED completion code and return

SetEDCCode:

;	les	si, TxEDPtr
	mov	es:[si].ED_ErrCode, ax	; Set return code
	or	ax, ax
	jz	noTxError

	mov	es:[si].ED_ErrMsg, bx	; BX has errmsg offset
    popf
    stc
    pop ds
    ret

noTxError:
	popf				; Restore interrupts
    clc
	pop	ds			; Restore data segment
	ret				; Return to caller

NADTransmitPacket endp

;======================= RECEIVE SECTION =============================

;--------------------------------------------------------------------
; NADChangeReceiveMask
;
;	Change the receive mask of the controller. Can force the adapter
;	to enable/disable broadcast, multicast or promiscuous receptions
;
;	Parameters:
;		BL - new receive bit mask:
;			bit 0:	set   = enable
;				clear = disable
;			bit 1:	change broadcast mask based on bit 0 flag
;			bit 2:	change multicast mask based on bit 0 flag
;			bit 3:	change Multicast Address Table:
;				if bit 0 is set, ES:DI will point to the
;					multicast address to add
;				if bit 0 is cleared, ES:DI will point to
;					multicast address to delete.
;				if bit 0 is cleared and DI = 0,
;					clear whole Multicast Table
;
;		ES:DI pointer to multicast address
;
;	Returns:
;		BX - TRUE/FALSE status if change was made
;		DS - preserved
;
; 970303 1.80/320 - GK
;--------------------------------------------------------------------
NADChangeReceiveMask proc far

	push	ds			; save callers' DS
  
    mov	bp, offset DGroup:AS

	mov	ax, ACCEPT_BROADCAST
	test	bx, 10b			; change broadcast mask?
	jnz	changeMaskTest

	mov	ax, ACCEPT_MULTICAST
	test	bx, 100b		; change multicast mask?
	jnz	changeMaskTest

	test	bx, 1000b		; change multicast table?
	jz	changeMaskExit

;    set AS.receive_mask to ACCEPT_MULTICAST and call LM_Change_Receive_Mask

; -- copy ES:DI to AS.multi_address and call LM_Add_Multi_Address or
;    LM_Delete_Multi_Address

	or	di, di			; clear whole table?
	jz	ChangeMaskErr		; not supported!

	mov	ax, es:[di]
	mov	word ptr DGroup:AS.multi_address, ax
	mov	ax, es:[di+2]
	mov	word ptr DGroup:AS.multi_address+2, ax
	mov	ax, es:[di+4]
	mov	word ptr DGroup:AS.multi_address+4, ax

				; ds:bp ptr to AS with multi_address field set

	test	bx, 1			; set or clear?
	jnz	AddMulti

cli
	call	LM_Delete_Multi_Address
sti
	jmp	changeMaskExit

addMulti:
cli
	call	LM_Add_Multi_Address
sti
	jmp	changeMaskExit

changeMaskTest:
	test	bx, 1			; set if enable, clear if disable
	jnz	setMask

	not	ax
	and	DGroup:AS.receive_mask, ax
	jmp	changeMask

setMask:
	or	DGroup:AS.receive_mask, ax

changeMask:
cli
	call	LM_Change_Receive_Mask
sti

changeMaskExit:
	mov	bx, 1			; return TRUE
	pop	ds			; restore callers' DS
	ret

changeMaskErr:
	xor	bx, bx			; return FALSE
	pop	ds
	ret

NADChangeReceiveMask    endp



;=========================================================================
; NADSetFilter
;==============
;	- Change the rx unit's filter to a new one
;
; Parameters:	AX = filter value, 1 = directed/multicast
;				   2 = broadcast
;				   4 = promiscuous
;		DS = DGroup
;
; Returns:
;=========================================================================
NADSetFilter	proc	near

; use NADChangeReceiveMask to do all of the dirty work -- 1 bit at a time,
; since NADChangeReceiveMask does not accept OR'd mask settings

;int 03

;;db  0f1h

	push	ax			; save for later
	mov	bl, 00000100b		; multicast setting - assume off
	test	al, 1			; directed/multicast?
	jz	SetFilterMulticast

	or	bl, 1			; multicast on

SetFilterMulticast:
	call	NADChangeReceiveMask

	pop	ax
	push	ax
	mov	bl, 00000010b		; broadcast setting - assume off
	test	al, 2			; broadcast?
	jz	SetFilterBroadcast

	or	bl, 1			; broadcast on

SetFilterBroadcast:
	call	NADChangeReceiveMask

	pop	ax
	mov	bl, 00010000b		; promiscuous setting - assume off
	test	al, 4			; promiscuous?
	jz	SetFilterPromiscuous

	or	bl, 1			; promiscuous on

SetFilterPromiscuous:
	call	NADChangeReceiveMask
    clc
	ret

NADSetFilter	endp



;==========================================================================
; NADMCastChange
;================
;	- Modify the multicast buffer to receive the multicast addresses
;	  listed in the multicast table.
;	  Each entry in the multicast table is as follows:
;		  Bytes 0-5 = Multicast Address
;	  All addresses are contiguous entries
;
; Parameters:	CX =  Number of multicast entries.
;		ES:SI -> Multicast Table.
;		AX = 1 means save the list
;		AX = 0 means use the saved list
;
; Return:	All registers may be destroyed.
;==========================================================================

NADMcastChange	proc	near

;;db  0f1h

	mov	di, si			; ES:DI now points to mcast addrlist
	cmp	cx, MAXNUM_MCADDR
	jbe	MCsave

	mov	cx, MAXNUM_MCADDR

MCsave:
	jcxz	Set_MCastDone		; could be zero -- just exit

Set_McastTable_Loop:


	push	cx			; save mcastaddr count
;		BL - new receive bit mask:
;			bit 0:	set   = enable
;				clear = disable
;			bit 1:	change broadcast mask based on bit 0 flag
;			bit 2:	change multicast mask based on bit 0 flag
;			bit 3:	change Multicast Address Table:
;				if bit 0 is set, ES:DI will point to the
;					multicast address to add
    mov     bx, 9
    call    NadChangeReceiveMask
    add     di, 6
	pop	cx
	loop	Set_MCastTable_Loop

Set_MCastDone:
	ret

NADMcastChange	endp




;--------------------------------------------------------------------
; UM_Receive_Packet
;
; On entry,
;	CX = size of received data
;	DS:BP ptr to AS
;	ES:SI ptr to lookahead data (if AS.adapter_flags has
;	      RX_VALID_LOOKAHEAD set)
;
; On exit,
;	AX = SUCCESS or EVENTS_DISABLED
;	all other regs preserved *******IMPORTANT****!!!!
;
;--------------------------------------------------------------------
UM_Receive_Packet proc near

;db  0f1h

    or  cx, cx
    jz  just_ret1

    or  bl, bl
    jnz  just_ret1


;    cli
    

;    test    bl, 6
;    jz  shhh


;shhh:

	pusha				; save registers
	push	es
	cld

	mov	DGroup:RxSize, cx		; save total rx packet size

	mov	ax, DGroup:RxSize
	cmp	ax, MAXPACKETDATASIZE	; check what max size is
	ja	rcv_no_filter


	mov	cx, 1; get fragment count
	mov	DGroup:RxFragCount, cx
;	lea	bx, es:[si].ED_FragOff

	mov	di, offset DGroup:RxFrag1

;copyRxFrags:

    mov ebx,    CR0
    test    bx, 1
    je      real_mode2
    mov ax, Dgroup:StoreDS
    jmp short   p_mode1
real_mode2:
    mov	ax, ds
p_mode1:

;    mov     ax, ds
    and     eax, 0ffffh
;	movzx	eax, ds
	shl	eax, 4
	mov 	dx, offset Dgroup:RxPacket
    and     edx, 0ffffh
	add	eax, edx
	mov	[di], eax
	mov	ax, 1800
	or	ax, PHYSICAL_ADDR
	mov	[di+4], ax

	mov	si, offset DGroup:RxFragCount
	mov	bp, offset DGroup:AS
	mov	cx, DGroup:RxSize

	xor	ax, ax			; offset = 0
	push	cx			; save receive count

	push	es			; save es
	push	ds
	pop	es			; es = ds

	mov	bx, 1			; set to indicate final copy, poll status
	call	LM_Receive_Copy

;    sti

	pop	es			; restore es
	pop	cx
	or	ax, ax
	jnz	RxWasTooBig

;	mov	BytesReceived, cx	; set received byte count


	call	GetED
	mov	word ptr DGroup:RxEDPtr, si	; save ED pointer
	mov	word ptr DGroup:RxEDPtr+2, es
	jz	rcv_no_filter


    mov     si, offset DGroup:RxPacket

    mov     cx,    DGroup:RxSize

	les	bx, DGroup:RxEDPtr		; ES:BX point to ED

	lea	di, es:[bx].ED_FragOff	; ES:SI ptr to fragment descriptor list

    mov di, WORD PTR es:[di].FragOff
;;	les	di, dword ptr es:[di].FragOff

    rep movsb    

OkPac:

	les	si, DGroup:RxEDPtr

    mov     cx,    DGroup:RxSize
	mov	es:[si].ED_Length, cx	; save length in ED

	mov	es:[si].ED_ErrCode, 0	; Set good completion


rcv_no_filter:				; this packet can be thrown away now
	pop	es			; restore registers
	popa

Just_ret:
	xor	ax, ax			; indicate SUCCESS
	ret

Just_ret1:
;db  0f1h
	xor	ax, ax			; indicate SUCCESS
	ret



RxWasTooBig:
;	mov	BytesReceived, 0	; indicate no bytes received

;;db  0f1h

	jmp	rcv_no_filter

UM_Receive_Packet   endp

;--------------------------------------------------------------------
;--------------------------------------------------------------------
UM_Receive_Copy_Complete proc near
	xor	ax, ax			; indicate SUCCESS
	ret
UM_Receive_Copy_Complete endp

UM_SEND_COMPLETE proc
;db  0f1h
	mov	DGroup:TxDoneFlag, -1	; for now, should check AX =send_status
	xor	ax, ax			; return SUCCESS
	ret
UM_SEND_COMPLETE    endp

UM_STATUS_CHANGE proc
;db  0f1h
	mov	DGroup:StatusFlag, 0		; clear status pending
	xor	ax, ax			; return success
	ret
UM_STATUS_CHANGE    endp

UM_Interrupt proc near
	xor	ax, ax			; indicate SUCCESS
	ret
UM_Interrupt endp

UM_Card_Services proc
	int	1ah
	ret

UM_Card_Services    endp


;=========================================================================
; DriverISR_Proc
;================
;	- ISR procedure to be called by UNDI_DriverISR
;
; Parameters:	DS = CGroup
;
; Returns:	CF = a if not our int
;=========================================================================
DriverISR_Proc	proc	near

;db  0f1h
		pushf
        call    OurInterruptHandler
		clc
		ret

DriverISR_Proc	endp


;=========================================================================
; NADGetStatistics
;==================
;	- Read the adapter's statistics
;
; Parameters:	ds:si points to variables to hold the result
;			TxGoodFrames	dd	0	;1
;			RxGoodFrames	dd	0	;2
;			RxCRCErrors	dd	0	;3
;			RxDiscarded	dd	0	;3
;
; Returns:
;=========================================================================
NADGetStatistics	proc	 near

		push	dx
; more code here

;;        stc
        clc
		pop	dx
		ret

NADGetStatistics	endp

;=========================================================================
; NADOpen
;=========
;	- Enables the Tx and Rx units
;
; Parameters:	DS = CGroup
;
; Returns:
;=========================================================================
NADOpen 	proc	near

;db  0f1h

; not sure whether we have to do anything here, since NADTransmit does a
; reset of the adapter and re-inits everytime.
    
    	mov	bp, offset DGroup:AS

        mov ebx,    CR0
        test    bx, 1
        je      real_mode1     ; je

; reinitialize this if we are in protected mode :

    	mov	ax, offset DGroup:HostRAM
    	mov	dx, ds
    	mov	word ptr DGroup:[AS.host_ram_virt_addr], ax
    	mov	word ptr DGroup:[AS.host_ram_virt_addr+2], dx
    	mov	word ptr DGroup:AS.setup_ptr.virtual_addr, ax
    	mov	word ptr DGroup:AS.setup_ptr.virtual_addr+2, dx

    	mov	dx, DGroup:StoreDS
    	and     edx, 0ffffh
    	shl     edx, 4
    	and     eax, 0ffffh
    	add     edx, eax
    	mov     DGroup:AS.host_ram_phy_addr, edx
    	mov	    DGroup:AS.setup_ptr.phy_addr, edx


    	mov	DGroup:[AS.rx_lookahead_size], 4
    	mov	DGroup:[AS.max_packet_size], MAXPACKETDATASIZE
    	or	DGroup:[AS.adapter_flags], ENABLE_TX_PENDING ; 0

        push    di
        push    es

    	push	ds
    	pop	es			; ES = DS

    	mov	dx, ds  

    	lea	di, DGroup:AS.ptr_rx_CRC_errors
    	mov	si, offset DGroup:eth_rx_CRC_errors
    	mov	cx, 15			; 15 error counters are defined

defineEthErrPtrs1:
    	mov	ax, si
    	stosw
    	add	si, 4			; next dword error variable
    	mov	ax, dx
    	stosw
    	loop	defineEthErrPtrs1

    	or	DGroup:statusFlag, STATUS_PENDING

    	sti				; enable ints again
    	call	LM_Initialize_Adapter

        pop     es
        pop     di

    	or	ax, ax			    ; was there an error?
    	jnz	NADOpenFailed		; error

;db  0f1h        

AdapterInitOk1:
; -- wait up to 10s for adapter to initialize. The call to UM_Status_Change
;    from the LMAC will cause the STATUS_PENDING bit to be reset.

;db  0f1h
    	mov	ax, 0182		; wait up to 10s

    	call	StartTime

InitPendLoop1:
    	test	DGroup:statusFlag, STATUS_PENDING
    	jz	    InitCompleted1


    	call	CheckTime
    	jnc	InitPendLoop1

        jmp short NADOpenFailed
;db  0f1h    


;;		call	init_tx_queues
;;		call	init_rx_queues

InitCompleted1:

real_mode1:

    	or	DGroup:statusFlag, STATUS_PENDING
;db  0f1h
    	call	LM_Open_Adapter
    	or	ax, ax
    	jnz	NADOpenFailed

    	mov	ax, 637 		; wait up to 35s for open
    	call	StartTime

NADOpenPendLoop:
    	test	DGroup:statusFlag, STATUS_PENDING
    	jz	NADOpenCompleted

    	call	CheckTime
    	jnc	NADOpenPendLoop

;  The open adapter request failed:  UnhookIntVector, set errmsg and return.

NADOpenFailed:
    stc
    ret

;  Status changed -- see if adapter is open; if so, set good retcode

NADOpenCompleted:
     cmp	DGroup:AS.adapter_status, OPEN
     jnz	NADOpenFailed

     clc
  	 ret

NADOpen 	endp



;=========================================================================
; NADShutDown
;=============
;	- reset the adapter and enables
;	- unhook our ISR
;
; Parameters:
;
; Returns:
;=========================================================================

NADShutDown	proc	near

;int 03
;	push	cs		; NADDisengage does a retf
;db  0f1h
	call	NADDisengage	; stop adapter, unhook ISR

	ret

NADShutDown	endp


;=========================================================================
; NADClose
;==========
;	- Disables the Tx and Rx units
;
; Parameters:	DS = CGroup
;
; Returns:
;=========================================================================
NADClose	proc	near

;db  0f1h
    push    ax
	push	ds			; save callers' DS
	mov	bp, offset DGroup:AS

   	or	DGroup:statusFlag, STATUS_PENDING
;db  0f1h
	call	LM_Close_Adapter
   	or	ax, ax
   	jnz	NADCloseFailed1

   	mov	ax, 637 		; wait up to 35s for open
   	call	StartTime

NADClosePendLoop1:
   	test	DGroup:statusFlag, STATUS_PENDING
   	jz	NADCloseCompleted1

   	call	CheckTime
   	jnc	NADClosePendLoop1


NADCloseFailed1:

	pop	ds			; restore callers' DS
    pop ax
    stc
    ret

;  Status changed -- see if adapter is open; if so, set good retcode

NADCloseCompleted1:
    cmp	DGroup:AS.adapter_status, CLOSED
    jnz	NADCloseFailed1




;;	call	LM_Disable_Adapter
;;	call	UnhookIntVector 	; restore int vector and mask PIC

	pop	ds			; restore callers' DS
    pop ax
    clc
	ret				; Return to caller

NADClose	endp


NADInitiateDiags    proc    near
    stc
    ret
NADInitiateDiags    endp



NADSetMACAddress    proc    near
;;    stc
    clc
    ret
NADSetMACAddress    endp



_TEXT	ends
;END_CODE

;====================================================================
; SPARSE data
;====================================================================
;START_SPARSE


_DATA	segment	para public

; Data variables


StoreDS dw  0

;;public  LanOption

;;LanOption   db  'LAN option: SMC EPIC adapter', CR, LF, 0

;;StrPrompt	db	'Initializing SMC EtherPower II Adapter', 0

;;Speed10		db "Media: 10Base-T", 0
;;Speed100	db "Media: 100Base-T", 0

even

AS		AdapterStructure <?>

StatusFlag	db	0

InitError	db	"Error: Unable to read configuration from adapter.", 0
msg_initerror	db	"Error initializing adapter", 0
NoNetMsg	db	'Adapter is improperly installed or not connected to the network.', 13, 10, 0

even

IFDEF	ETHERNET
eth_rx_CRC_errors	dd	0
eth_rx_too_big		dd	0
eth_rx_lost_pkts	dd	0
eth_rx_align_errors	dd	0
eth_rx_overruns 	dd	0
eth_tx_deferred 	dd	0
eth_tx_total_collisions dd	0
eth_tx_max_collisions	dd	0
eth_tx_one_collision	dd	0
eth_tx_mult_collisions	dd	0
eth_tx_ow_collision	dd	0
eth_tx_CD_heartbeat	dd	0
eth_tx_carrier_lost	dd	0
eth_tx_underruns	dd	0
eth_ring_OVW		dd	0
ENDIF

ErrorPtr	dw	0
;NicNotFound  	db	"Could not find SMC EtherPower II adapter.", 0


MaxTicks	dw	0
CurTicks	dw	0
StartTick	dw	0		; used by StartTime and CheckTime


IvtOffset	dw	0
;;OldIntVector	dd	0		; Old interrupt vector
OrgIntVector_OFF    dw  0
OrgIntVector_SEG    dw  0
irq_mask	db	0		; int enable mask

TxDoneFlag db 0


RxEDPtr dd	0
RxSize	dw	0

even

;public FragCount
FragCount	dw	?
Frag1		FragmentStructure <?>
;Frag2		FragmentStructure <?>
;Frag3		FragmentStructure <?>
;Frag4		FragmentStructure <?>
;Frag5		FragmentStructure <?>


RxFragCount	dw	?
RxFrag1		FragmentStructure <?>
RxFrag2		FragmentStructure <?>
RxFrag3		FragmentStructure <?>
RxFrag4		FragmentStructure <?>
RxFrag5		FragmentStructure <?>


public HostRAM


public MemEnd
MemEnd		db	?
;END_SPARSE
_DATA	ends

_BSS	segment

align   16
HostRAM 	db	HOST_RAM_SIZE+100 dup (?)

even

TxPacket    db  1800 dup (0)    
RxPacket    db  1800 dup (0)    

_BSS ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\lm9432.inc ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       ETH_PCI.INC    (C) Copyright 1995 Standard Microsystems Corp.
;                       All rights reserved.
;
;       LMI lower routine include file for 
;       Ethernet 9432 PCI adapter.
;
;       Author: najay
;
; Revision Log:
; $Log: /Client Boot/NICS/SMC/9432/UNDI/LM9432.INC $
;  
;     Rev 1.3   21 Feb 1996 12:05:08   RHODES
;  Added NDIS3X def to support ML assembly for use with C UMAC
;  
;     Rev 1.2   25 Sep 1995 16:34:32   NAJARIAN
;  fixed pass dependent defines for tasm builds
;  
;     Rev 1.1   17 May 1995 15:20:20   NAJARIAN
;  added 386 support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
; PCI Defines (pulled from PCI bios spec v2.1 (26Aug94)
;

; function list

PCI_FUNCTION_ID         equ     0b1h
PCI_BIOS_PRESENT        equ     01h
FIND_PCI_DEVICE         equ     02h
FIND_PCI_CLASS_CODE     equ     03h
GENERATE_SPECIAL_CYCLE  equ     06h
PCI_READ_CONFIG_BYTE    equ     08h
PCI_READ_CONFIG_WORD    equ     09h
PCI_READ_CONFIG_DWORD   equ     0ah
PCI_WRITE_CONFIG_BYTE   equ     0bh
PCI_WRITE_CONFIG_WORD   equ     0ch
PCI_WRITE_CONFIG_DWORD  equ     0dh
GET_IRQ_ROUTING_OPTIONS equ     0eh
SET_PCI_IRQ             equ     0fh


PCI_SUCCESSFUL          equ     00h
PCI_FUNC_NOT_SUPPORTED  equ     81h
PCI_BAD_VENDOR_ID       equ     83h
PCI_DEVICE_NOT_FOUND    equ     86h
PCI_BAD_REGISTER_NUMBER equ     87h
PCI_SET_FAILED          equ     88h
PCI_BUFFER_TOO_SMALL    equ     89h

; lm9432 macros

ifdef	CODE_386
ifndef NDIS3X
; ifndef	pAS
  pAS	equ    <[ebp]>		; Pointer to adapter structure
  epAS	equ    <[ebp]>
; endif

 pASi	equ    <[ebp+esi]>	; Pointer to adapter structure + index

; ifndef	pDS
  pDS	equ    <[esi]>		; Pointer to data buffer structure
; endif

 pDST	equ    <[edi]>
 pSRC	equ    <[esi]>

 RWORD	equ	dword

 rax	equ    <EAX>
 rbx	equ    <EBX>
 rcx	equ    <ECX>
 rdx	equ    <EDX>
 rdi	equ    <EDI>
 rsi	equ    <ESI>
 rbp	equ    <EBP>
 rsp	equ    <ESP>

else

; ifndef	pAS
  pAS	equ    [ebp]		; Pointer to adapter structure
  epAS	equ    [ebp]
; endif

 pASi	equ    [ebp+esi]	; Pointer to adapter structure + index

; ifndef	pDS
  pDS	equ    [esi]		; Pointer to data buffer structure
; endif

 pDST	equ    [edi]
 pSRC	equ    [esi]

 RWORD	equ	dword

 rax	equ    EAX
 rbx	equ    EBX
 rcx	equ    ECX
 rdx	equ    EDX
 rdi	equ    EDI
 rsi	equ    ESI
 rbp	equ    EBP
 rsp	equ    ESP
endif

else

; ifndef	pAS
  pAS	equ	ds:[bp]		; Pointer to adapter structure
  epAS	equ	es:[bp]
; endif

 pASi	equ	ds:[bp+si]	; Pointer to adapter structure + index

; ifndef	pDS
  pDS	equ	es:[si]		; Pointer to data buffer structure
; endif

 pDST	equ	es:[di]
 pSRC	equ	ds:[si]

 RWORD	equ	word
 
 rax	equ	AX
 rbx	equ	BX
 rcx	equ	CX
 rdx	equ	DX
 rdi	equ	DI
 rsi	equ	SI
 rbp	equ	BP
 rsp	equ	SP

endif



ifdef   COUNTER16
errptr  equ     <word ptr>
errAX   equ     <ax>
else
errptr  equ     <dword ptr>
errAX   equ     <eax>
endif

; PUSH_ES, POP_ES,
; PUSH_DS POP_DS
; PUSH_CS
; do nothing for CODE_386, pushes/pops es & ds otherwise.

PUSH_ES	MACRO
 ifndef	CODE_386
	push	es
 endif
ENDM

PUSH_DS	MACRO
 ifndef	CODE_386
	push	ds
 endif
ENDM

PUSH_CS	MACRO
 ifndef	CODE_386
	push	cs
 endif
ENDM

POP_DS	MACRO
 ifndef	CODE_386
	pop	ds
 endif
ENDM

POP_ES	MACRO
 ifndef	CODE_386
	pop	es
 endif
ENDM

;-----------------
; MACRO - PUSHALL
;-----------------

PUSHALL	MACRO

        push ds
        push es
        push si
        push di
        push dx
        push cx
        push bx
        ENDM

;----------------
; MACRO - POPALL
;----------------

POPALL 	MACRO

        pop bx
        pop cx
        pop dx
        pop di
        pop si
        pop es
        pop ds
        ENDM

;--------------------------------
; ASM Procedure Start Definition
;--------------------------------
		
ASM_PCI_PROC	MACRO	X

IFDEF  EZSTART

	IFDEF	CODE_386
		EVEN
		PUBLIC	PCI_&X
	PROC	NEAR
	ELSE
	IFDEF	LARGE
		EVEN
		PUBLIC	PCI_&X
PCI_&X	PROC	FAR
	ELSE
		EVEN
		PUBLIC	PCI_&X
PCI_&X	PROC	NEAR
	
	ENDIF
	ENDIF
ELSE
	IFDEF   CODE_386
		EVEN
		PUBLIC  X
X		PROC    NEAR
	ELSE
	IFDEF   LARGE
		EVEN
		PUBLIC  X
X               PROC    FAR
	ELSE
		EVEN
		PUBLIC  X
X               PROC    NEAR
	
	ENDIF
	ENDIF
ENDIF
		ENDM


;--------------------------------
; ASM Procedure Start Definition
;--------------------------------
		
ASM_PROC	MACRO	ProcNameStub

	IFDEF	CODE_386
		EVEN
		PUBLIC	ProcNameStub
ProcNameStub	PROC	NEAR
	ELSE
	IFDEF	LARGE
		EVEN
		PUBLIC	ProcNameStub
ProcNameStub	PROC	FAR
	ELSE
		EVEN
		PUBLIC	ProcNameStub
ProcNameStub	PROC	NEAR
	
	ENDIF
	ENDIF
		ENDM

;------------------------------
; ASM Procedure End Definition
;------------------------------

ASM_PCI_PROC_END	MACRO	X


IFDEF  EZSTART
PCI_&X          ENDP
ELSE
X               ENDP
ENDIF

		ENDM

;------------------------------
; ASM Procedure End Definition
;------------------------------

ASM_PROC_END	MACRO	ProcNameStub

ProcNameStub		ENDP

		ENDM

;------------------------------
; ASM Procedure call Definition
;------------------------------
ASM_PCI_CALL	MACRO	X

IFDEF   EZSTART
	IFDEF	CODE_386
	call	PCI_&X
	ELSE
	IFDEF	LARGE
	call	far ptr	PCI_&X
	ELSE
		EVEN
	call	near ptr PCI_&X
	ENDIF
	ENDIF
ELSE
	IFDEF	CODE_386
	call	X
	ELSE
	IFDEF	LARGE
	call	far ptr	X
	ELSE
		EVEN
	call	near ptr X
	ENDIF
	ENDIF
ENDIF
		ENDM

;------------------------------
; ASM Procedure call Definition
;------------------------------
ASM_CALL	MACRO	ProcCallStub

	IFDEF	CODE_386
	call	ProcCallStub
	ELSE
	IFDEF	LARGE
	call	far ptr	ProcCallStub
	ELSE
		EVEN
	call	near ptr ProcCallStub
	ENDIF
	ENDIF
		ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\spdosegs.inc ===
; Modifications:   $Header: /Client Boot/NICS/Generic/UNDI_NAD/SPDOSEGS.INC 1     16/07/98 5:33p Dmitry Klimenko $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;
;   Description: segment declaration and ordering for NDIS driver
;-----------------------------------------------------------------------
; Functional Description
;
;   This file defines the segments used by a MAC driver and the order
;   in which they are loaded. The groups DGROUP (for data) and CGROUP
;   (for code) are also defined, as are macros to open and close
;   segments (which also set up the default segment assumptions).
;-----------------------------------------------------------------------
; DOS segment definitions and ordering.
;==========================================================================
Ifdef DRV
DevHeaderSeg   segment para public USE16 'CODE'
DevHeaderSeg   ends
Endif	
;--------------------------------------------------------------------------
; Resident Code segment - code that is used after init time
; (unfortunately, this includes code to bind another driver, and
; initializations that take place at bind time) should be placed in this
; segment.
;--------------------------------------------------------------------------
_TEXT       segment para public USE16 'CODE'
_TEXT       ends

Ifdef DRV
ICODE       segment para public USE16 'INIT'
ICODE       ends
ENDIF	
;--------------------------------------------------------------------------
; Resident Data segment - things put here will remain in memory after
; init time. At the present time, this is in low memory, so data that is
; not used after init time should NOT be put in this segment.
;--------------------------------------------------------------------------
_DATA       segment para public USE16 'DATA'
_DATA       ends

Ifdef DRV
_BSS       segment para public USE16 'DATA'
_BSS       ends
IDATA       segment para public USE16 'DATA'
IDATA       ends
Else
_BSS       segment para public USE16 'BSS'
_BSS       ends
ENDIF
;--------------------------------------------------------------------------
; Make sure the segment order defined in this file is respected.
;--------------------------------------------------------------------------
.SEQ               
;--------------------------------------------------------------------------
; DOS Group is all one 64K segment, CS=SS=DS, use equate for DGROUP.
;--------------------------------------------------------------------------
Ifdef DRV
    CGROUP      group   DevHeaderSeg, _TEXT, ICODE
    DGROUP      group   _DATA, _BSS, IDATA
ELSE
    CGROUP      group   _TEXT
    DGROUP      group   _DATA, _BSS
ENDIF	
;--------------------------------------------------------------------------
; Group is 64K data, 64K code, CS!=SS=DS, actual group for Code.
;--------------------------------------------------------------------------
; Assume statement here takes care of for any source, same for OS2 and DOS.
;--------------------------------------------------------------------------
    Assume   CS:CGROUP, DS:DGROUP, ES:NOTHING, SS:NOTHING

START_CODE	macro
_TEXT		segment Public 'Code'
		assume ds:DGroup,cs:cGroup,es:nothing,ss:nothing
		endm

END_CODE	macro
_TEXT		ends
		endm

START_DATA	macro
_Data		segment Public 'Data'
		assume ds:DGroup,cs:CGroup,es:nothing,ss:nothing
		endm

END_DATA	macro
_Data		ends
		endm

; 2 macros by John to let you easily insert data fragments into code
;
; This macro assumes that Code is open, closes it, and opens data.
OPEN_DATA       macro
    END_CODE
    START_DATA
                endm

; This macro closes the open data and re-opens the Code segment.
CLOSE_DATA      macro
    END_DATA
    START_CODE
                endm


; EOF - $Workfile: SPDOSEGS.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\pcinic.inc ===
;
; Modifications:   $Header: /Client Boot/NICS/3Com/3C90xB/UNDI/PCINIC.INC 2     22/07/98 8:30p John Lobraico $
;
; Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
;

;
;   Description: PCI Configuration Space Definitions
;

IFDEF            PCI_INC
ELSE
PCI_INC          equ    1
include pci.inc

;--------------------------------------------------------------------------
; Configuration Space Header
;--------------------------------------------------------------------------
PCI_CONFIG_STRUC       struc
    PciVendorId        dw    ?                ;- PCI Vendor ID
    PciDeviceId        dw    ?                ;- PCI Device ID
    PciCommand         dw    ?
    PciStatus          dw    ?
    PciRevisionId      db    ?
    PciClassCode       db    3  dup (?)
    PciCacheLineSize   db    ?
    PciLatencyTimer    db    ?
    PciHeaderType      db    ?
    PciBIST            db    ?
    PciBaseReg0        dd    ?
    PciBaseReg1        dd    ?
    PciBaseReg2        dd    ?
    PciBaseReg3        dd    ?
    PciBaseReg4        dd    ?
    PciBaseReg5        dd    ?
    PciReserved0       dd    0
    PciReserved1       dd    0
    PciExpROMAddress   dd    ?
    PciReserved2       dd    0
    PciReserved3       dd    0
    PciInterruptLine   db    ?
    PciInterruptPin    db    ?
    PciMinGnt          db    ?
    PciMaxLat          db    ?
PCI_CONFIG_STRUC       ends

;--------------------------------------------------------------------------
; Config Space Register Offsets
; Refer To The PCI Specification For Detailed Explanations
;--------------------------------------------------------------------------
VENDOR_ID_REGISTER       equ     00h          ;- PCI Vendor ID Register
DEVICE_ID_REGISTER       equ     02h          ;- PCI Device ID Register
COMMAND_REGISTER         equ     04h          ;- PCI Command Register
STATUS_REGISTER          equ     06h          ;- PCI Status Register
REV_ID_REGISTER          equ     08h          ;- PCI Revision ID Register
CLASS_CODE_REGISTER      equ     09h          ;- PCI Class Code Register
CACHE_LINE_REGISTER      equ     0Ch          ;- PCI Cache Line Register
LATENCY_TIMER            equ     0Dh          ;- PCI Latency Timer Register
HEADER_TYPE              equ     0Eh          ;- PCI Header Type Register
BIST_REGISTER            equ     0Fh          ;- PCI Built-In SelfTest Register
BAR_0_REGISTER           equ     10h          ;- PCI Base Address Register 0
BAR_1_REGISTER           equ     14h          ;- PCI Base Address Register 1
BAR_2_REGISTER           equ     18h          ;- PCI Base Address Register 2
BAR_3_REGISTER           equ     1Ch          ;- PCI Base Address Register 3
BAR_4_REGISTER           equ     20h          ;- PCI Base Address Register 4
BAR_5_REGISTER           equ     24h          ;- PCI Base Address Register 5
SUB_VENDOR_ID_REGISTER           equ     2Ch          ;- PCI Base Address Register 5
SUB_DEVICE_ID_REGISTER           equ     2Eh          ;- PCI Base Address Register 5
EXPANSION_ROM            equ     30h          ;- PCI Expansion ROM Base Register
INTERRUPT_LINE           equ     3Ch          ;- PCI Interrupt Line Register
INTERRUPT_PIN            equ     3Dh          ;- PCI Interrupt Pin Register
MIN_GNT_REGISTER         equ     3Eh          ;- PCI Min-Gnt Register
MAX_LAT_REGISTER         equ     3Fh          ;- PCI Max_Lat Register

;--------------------------------------------------------------------------
; Configuration space DWORD register offsets
;--------------------------------------------------------------------------
CONFIG_SPACE_REG0        equ     0
CONFIG_SPACE_REG1        equ     1
CONFIG_SPACE_REG2        equ     2
CONFIG_SPACE_REG3        equ     3
CONFIG_SPACE_REG4        equ     4
CONFIG_SPACE_REG5        equ     5
CONFIG_SPACE_REG6        equ     6
CONFIG_SPACE_REG7        equ     7
CONFIG_SPACE_REG8        equ     8
CONFIG_SPACE_REG9        equ     9
CONFIG_SPACE_REGA        equ     0Ah
CONFIG_SPACE_REGB        equ     0Bh
CONFIG_SPACE_REGC        equ     0Ch
CONFIG_SPACE_REGD        equ     0Dh
CONFIG_SPACE_REGE        equ     0Eh
CONFIG_SPACE_REGF        equ     0Fh

;--------------------------------------------------------------------------
; Byte/Word Offsets In A Config DWORD
; These offsets can be used to move a Byte or Word into the lower half of
; a register.
;--------------------------------------------------------------------------
CONFIG_BYTE_0            equ     0
CONFIG_BYTE_1            equ     8
CONFIG_BYTE_2            equ     16
CONFIG_BYTE_8            equ     24
CONFIG_WORD_0            equ     0
CONFIG_WORD_1            equ     16

;--------------------------------------------------------------------------
; Configuration Mechanism Registers
;--------------------------------------------------------------------------
CF1_CONFIG_ADDR_REGISTER   equ   0CF8h        ;- Config Space Address Register
CF1_CONFIG_DATA_REGISTER   equ   0CFCh        ;- Config Space Data Register
CF2_SPACE_ENABLE_REGISTER  equ   0CF8h        ;- CSE Register
CF2_FORWARD_REGISTER       equ   0CFAh        ;- Forward Register
CF2_BASE_ADDRESS           equ   0C000h       ;- Configuration #2 Base

;--------------------------------------------------------------------------
; PCI Class Code Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
PCI_BASE_CLASS           equ     02h          ;- Base Class - Network Controller
PCI_SUB_CLASS            equ     00h          ;- Sub Class - Ethernet Controller
PCI_PROG_INTERFACE       equ     00h          ;- Prog I/F - Ethernet COntroller

;--------------------------------------------------------------------------
; PCI Command Register Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
CMD_IO_SPACE             equ     BIT_0
CMD_MEMORY_SPACE         equ     BIT_1
CMD_BUS_MASTER           equ     BIT_2
CMD_SPECIAL_CYCLES       equ     BIT_3
CMD_MEM_WRT_INVALIDATE   equ     BIT_4
CMD_VGA_PALLETTE_SNOOP   equ     BIT_5
CMD_PARITY_RESPONSE      equ     BIT_6
CMD_WAIT_CYCLE_CONTROL   equ     BIT_7
CMD_SERR_ENABLE          equ     BIT_8
CMD_BACK_TO_BACK         equ     BIT_9

;--------------------------------------------------------------------------
; PCI Status Register Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
STAT_BACK_TO_BACK        equ     BIT_7
STAT_DATA_PARITY         equ     BIT_8
STAT_DEVSEL_TIMING       equ     BIT_9 OR BIT_10
STAT_SIGNAL_TARGET_ABORT equ     BIT_11
STAT_RCV_TARGET_ABORT    equ     BIT_12
STAT_RCV_MASTER_ABORT    equ     BIT_13
STAT_SIGNAL_MASTER_ABORT equ     BIT_14
STAT_DETECT_PARITY_ERROR equ     BIT_15

;--------------------------------------------------------------------------
; PCI Base Address Register For Memory (BARM) Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
BARM_LOCATE_BELOW_1_MEG  equ     BIT_1
BARM_LOCATE_IN_64_SPACE  equ     BIT_2
BARM_PREFETCHABLE        equ     BIT_3

;--------------------------------------------------------------------------
; PCI Base Address Register For I/O (BARIO) Bit Definitions
; Configuration Space Header
;--------------------------------------------------------------------------
BARIO_SPACE_INDICATOR    equ     BIT_0

;--------------------------------------------------------------------------
; PCI BIOS Definitions
; Refer To The PCI BIOS Specification
;--------------------------------------------------------------------------
;- Function Code List

;IFE  NWSERVER
;;- Server can use the defines in ODI.INC
;PCI_FUNCTION_ID          equ     0B1h         ;- AH Register
;PCI_BIOS_PRESENT         equ     01h          ;- AL Register
;FIND_PCI_DEVICE          equ     02h          ;- AL Register
;FIND_PCI_CLASS_CODE      equ     03h          ;- AL Register
;GENERATE_SPECIAL_CYCLE   equ     06h          ;- AL Register
;READ_CONFIG_BYTE         equ     08h          ;- AL Register
;READ_CONFIG_WORD         equ     09h          ;- AL Register
;READ_CONFIG_DWORD        equ     0Ah          ;- AL Register
;WRITE_CONFIG_BYTE        equ     0Bh          ;- AL Register
;WRITE_CONFIG_WORD        equ     0Ch          ;- AL Register
;WRITE_CONFIG_DWORD       equ     0Dh          ;- AL Register
;ENDIF

; Function Return Code List
SUCCESSFUL               equ     00h
FUNC_NOT_SUPPORTED       equ     81h
BAD_VENDOR_ID            equ     83h
DEVICE_NOT_FOUND         equ     86h
BAD_REGISTER_NUMBER      equ     87h

;- PCI BIOS Calls
PCI_BIOS_INTERRUPT       equ     01Ah         ;- PCI BIOS Int 1Ah Function Call
PCI_PRESENT_CODE         equ     20494350h    ;- Hex Equivalent Of 'PCI '
                                              ;- ASCII Codes for ' ICP'
PCI_PRESENT_CODE_WORD    equ     4350h        ;- Hex Equivalent Of 'CP'
PCI_SERVICE_IDENTIFIER   equ     49435024h    ;- ASCII Codes for 'ICP$'

;- PCI Device and Vendor IDs
;; JL - Removed nic specifics!
;;SPEEDO_DEVICE_ID         equ     1227h
;;SPLASH1_DEVICE_ID        equ     1226h
;;D100_DEVICE_ID           equ     1229h
;;D100_VENDOR_ID           equ     8086h

;- Maximum bus slots supported under Configuration mechanisms 1 and 2
CONFIG1_MAX_PCI_SLOTS    equ     32
CONFIG2_MAX_PCI_SLOTS    equ     16

;- Maximum buses supported
MAX_PCI_BUSES            equ     255

ENDIF


; EOF - $Workfile: PCINIC.INC $
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\pxe_stru.inc ===
;
NUM_MCADDRS    	Equ	8		; max number of multicast addresses.
MAX_DATABLK    	Equ	8		; max number of data blocks supported 
					;	in a descriptor.
MAX_IMMED_LEN	Equ	64		; max immediate data buffer length
MAX_TX_DATABLK	Equ	MAX_DATABLK	; max number of data blocks supported 
					;	in a Tx descriptor.
MAX_TD_DATABLK	Equ	MAX_DATABLK	; max number of TransferData blocks
		
APIMaxFunc	EQU	0011h

ADDR_LEN	EQU	16
ETH_ADDR_LEN	EQU	6
MAXNUM_MCADDR	EQU	8

;
; protocol values in transmit buffer
;
P_UNKNOWN	EQU	0		;; no media header
P_IP	 	EQU	1		;; IP type
P_ARP		EQU	2		;; ARP type
P_RARP		EQU	3		;; RARP type

TYPE_IP	 	EQU	0800h		;; IP type
TYPE_ARP	EQU	0806h		;; ARP type
TYPE_RARP	EQU	8035h		;; RARP type
;
; xmitflag values in transmit buffer
;
PKT_DESTADDR	EQU 0	;; destination address given 
PKT_BROADCAST	EQU 1h	;; use broadcast address 
PKT_MULTICAST	EQU 2h	;; multicast addr given

;; Hardware type values
ETHER_TYPE 		EQU 1
EXP_ETHER_TYPE	EQU 2
IEEE_TYPE  	EQU 6
ARCNET_TYPE   	EQU 7


Eth_MCastBuf    Struc
MCastAddrCount	DW	?
MCastAddr	DB MAXNUM_MCADDR * ETH_ADDR_LEN dup (0)
Eth_MCastBuf	Ends

MC_MCastBuf    Struc
MC_MCastAddrCount	DW	?
MC_MCastAddr  		DB MAXNUM_MCADDR * ADDR_LEN dup (0)

MC_MCastBuf Ends

NIC_StartUp    Struc
S_Status	DW	?
S_BusType	DB	?
S_AddrType	DB	?
S_DataSeg	DW	?
S_DataSegAddr	DD	?
S_DataSegSize	DW	?
S_CodeSegSize	DW	?
S_BusDevFunc	DW	?	;; PCI Dev_ID
S_PCI_ds_off	dw	?	;; Far pointer to PCI data structure
S_PCI_ds_seg	dw	?
S_PnP_csn	dw	?	; Card select number.-1 for non-PnP BBS device
S_PnP_eh_off	dw	?	; Far pointer to PnP expansion header
S_PnP_eh_seg	dw	?
NIC_StartUp Ends

NIC_CleanUp    Struc
CL_Status	DW	?
NIC_CleanUp Ends

NIC_Initialize    Struc
I_Status	DW	?
I_Prot_ini	DD	?
I_RcvInt	DD	?
I_GenInt	DD	?
NIC_Initialize  Ends

NIC_Reset    Struc
R_Status	DW	?
R_MCBuf		MC_MCastBuf <>
NIC_Reset   Ends

NIC_ShutDown    Struc
SD_Status	DW	?
NIC_ShutDown    Ends

NIC_Open    Struc
O_Status	DW	?
O_OpenFlg	DW	?
O_PktFilter	DW	?
O_MCBuf		MC_MCastBuf <>
NIC_Open    Ends

NIC_Close    Struc
C_Status	DW	?
NIC_Close   Ends

X_DataBlock    Struc
X_TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
X_TxRsvdByte	DB	?	; Reservered, must be zero.
X_TxDataLen	DW	?	; Data block length in bytes.
X_TxDataPtr	DD	?	; Far pointer to data block.
X_DataBlock Ends

NIC_TBD    Struc
X_Length	DW	?
X_BufOff	DW	?
X_BufSeg	DW	?
X_DataBlkCount	DW	?		; will always be zero for base code
X_DataBlk	DB	MAX_DATABLK * SIZE X_DataBlock dup (0)	
NIC_TBD Ends

NIC_Transmit    Struc
T_Status		DW	?
T_Protocol		DB	?
T_XmitFlag		DB	?
T_DestAddrOffset 	DW	?	; 16-bit segment & offset of the
T_DestAddrSegment 	DW	?	; destination media address 
T_TBDOffset		DW	?	; 16-bit segment & offset 
T_TBDSegment		DW	?	; transmit buffer descriptor 
T_Reserved		DD	2 dup(0)	; for future use	
NIC_Transmit    Ends

NIC_SetMCastAddr    Struc
SM_Status		DW	?
SM_MCBuf		MC_MCastBuf <>
NIC_SetMCastAddr    Ends

NIC_SetStationAddr    Struc
SS_Status		DW	?
SS_StationAddr		DB	ADDR_LEN dup (0)
NIC_SetStationAddr  Ends

NIC_SetPacketFilter    Struc
SP_Status		DW	?
;;SP_NewFilter		DW  ?
SP_NewFilter		DB  ?
;;SP_MCBuf		MC_MCastBuf <>
NIC_SetPacketFilter Ends

NIC_GetInfo    Struc
GI_Status		DW	?
GI_BaseIo		DW	?
GI_IntNumber		DW	?
GI_MTU			DW	?
GI_HwType		DW	?
GI_HwAddrLen		DW	?
GI_CurrentNodeAddress	DB ADDR_LEN dup (0)
GI_PermNodeAddress	DB ADDR_LEN dup (0)
GI_ROMAddress		DW 	?
GI_RxBufCt		DW	?
GI_TxBufCt		DW	?
NIC_GetInfo Ends

NIC_GetNICType_pci    Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
Vendor_ID	DW	?	; /* OUT:  */
Dev_ID		DW	?	;  /* OUT:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */ 
Rev		DB	?	;  /* OUT: Revision number */ 
BusDevFunc	DW	?	; /* OUT: Bus, Device & Function numbers */
SubSystemId     dd      ?       ; /*OUT: SubsytemId & SubsystemVendorId
NIC_GetNICType_pci  Ends

NIC_GetNICType_pnp    Struc
Status 		DW	?	; OUT: See PXENV_STATUS_xxx constants */ 
NicType 	DB	?	;  /* OUT: 2=PCI, 3=PnP */
EISA_Dev_ID	DD	?	; /* Out:  */
Base_Class	DB	?	; /* OUT: */
Sub_Class	DB	?	;  /* OUT: */
Prog_Intf	DB	?	;  /* OUT: program interface */
CardSelNum	DW	?	; /* OUT: Card Selector Number */
Res		DB	0	;
NIC_GetNICType_pnp  Ends

NIC_GetStatistics    Struc
GS_Status		DW	?
GS_XmtGoodFrames	dd    ?
GS_RcvGoodFrames	dd    ?
GS_RcvCRCErrors		dd    ?
GS_RcvResourceErrors	dd    ?
NIC_GetStatistics   Ends

NIC_ClearStatistics    Struc
CS_Status		DW	?
NIC_ClearStatistics Ends

NIC_InitDiags    Struc
ID_Status	DW	?
NIC_InitDiags   Ends

NIC_ForceInterrupt    Struc
FI_Status		DW	?
NIC_ForceInterrupt  Ends

NIC_GetMCastAddr    Struc
GM_Status		DW	?
GM_InetAddr		DD	?
GM_HwAddr		DB	ADDR_LEN dup (0)
NIC_GetMCastAddr    Ends

;NIC_API_Entry	Struc
;Signature 	DB	'PXENV+'	;; not null terminated
;Version		DW	0100h		;; 1.0
;StrucLength	DB	0		;; length of this structure
;CheckSum	DB	0		;; fill in later
;rm_entry_off	DW	0		;; real mode driver entry offset
;rm_entry_seg	DW	0		;; real mode driver entry segment
;pm_entry_off	DW	0		;; protected mode driver entry offset
;pm_entry_seg	DW	0		;; protected mode driver entry segment
;_EndStruct     NIC_API_Entry

s_PXENV_ENTRY    Struc
signature	db	6 dup(?)	; 'PXENV+'
ver             dw      ?               ; MSB=major, LSB=minor
bytes		db	?		; sizeof s_pxenv_entry
checksum	db	?		; 8-bit checksum of structure,
					; including this byte shoube be zero.
rm_entry_off	dw	?		; 16-bit real-mode segment & offset.
rm_entry_seg	dw	?
pm_entry_off	dw	?		; 16-bit protected mode 32-bit physical
pm_entry_base	dd	?		; address and 16-bit offset.
stack_sel	dw	?		; PROM stack segment.  Will be set
stack_size	dw	?		; to 0 when removed from memory.
base_cs_sel	dw	?		; Base code segment.  Will be set
base_cs_size	dw	?		; to 0 when removed from memory.
base_ds_sel	dw	?		; Base data segment.  Will be set
base_ds_size	dw	?		; to 0 when removed from memory.
mlid_ds_sel	dw	?		; MLID data segment.
mlid_ds_size	dw	?
mlid_cs_sel	dw	?		; MLID code segment.
mlid_cs_size	dw	?
s_PXENV_ENTRY   Ends

;; Ethernet II protocol header
EtherHeader    Struc
E_DestAddr	DB 6 dup (0)	;; destination ethernet addr
E_SrcAddr	DB 6 dup (0)	;; destination ethernet addr
E_Type		DW  ?	;; protocol type
EtherHeader Ends

ETHER_HEADER_LEN	Equ	SIZE EtherHeader

; 
; * Data structures for TransmitChain (Tx), TransferData (TD)
; 
TxDataBlock    Struc
TxPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TxRsvdByte	DB	?	; Reservered, must be zero.
TxDataLen	DW	?	; Data block length in bytes.
TxDataPtr	DD	?	; Far pointer to data block.
TxDataBlock Ends

; 
; * TransmitChain descriptor structure definition
; 
TxBufDesc    Struc
TxImmedLen	DW	?	; Byte count of immediate data, max=64
TxImmedPtr	DD	?	; Virtual address of Immediate data
TxDataCount	DW	?	; Number of Data Blocks (max = 8)
TxDataBlk	DB	size TxDataBlock * MAX_TX_DATABLK dup(0)
TxBufDesc   Ends

TxBufDescrSize	Equ	Size TxImmedLen + Size TxImmedPtr + Size TxDataCount

; 
; * TransferData data block description
; 
TDDataBlock    Struc
TDPtrType	DB	?	; 0 => Phys pointer, 1 => GDT pointer
TDRsvdByte	DB	?	; Reservered, must be zero.
TDDataLen	DW	?	; Data block length in bytes.
TDDataPtr	DD	?	; Far pointer to data block.
TDDataBlock Ends

; 
; * TransferData descriptor structure
; 
TDBufDesc    Struc
TDDataCount	DW	?	; No of Data Blocks (max 8 for V1.01).
TDDataBlk	DB	size TDDataBlock*MAX_TD_DATABLK dup(0)
TDBufDesc   Ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\lmac.asm ===
;----------------------------------------------------------------------------
; LMAC.ASM
;
; Main file for SMC 9432 LMAC.
;
;$History: LMAC.ASM $
; 
; *****************  Version 1  *****************
; User: Paul Cowan   Date: 26/08/98   Time: 9:40a
; Created in $/Client Boot/NICS/SMC/9432/UNDI
;
;----------------------------------------------------------------------------

include 	spdosegs.inc

_TEXT	Segment para public

.386

EPIC		equ 1
ETHERNET	equ	1

assume ds:DGroup,cs:cGroup,es:nothing,ss:nothing

include epic100.inc
include lmstruct.inc
include eeprom2.inc
include lm9432.inc
include lm9432cf.asm
include lm9432.asm

extrn	UM_SEND_COMPLETE:near
extrn	UM_Receive_Copy_Complete:near
extrn	UM_STATUS_CHANGE:near
extrn	UM_Interrupt:near
extrn	UM_Card_Services:near
extrn	UM_RECEIVE_PACKET:near

_TEXT	ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\undi_equ.inc ===
;
;--- Miscellaneous Equates
;
NULL            equ     0
CR		equ	0Dh           ;- Carriage Return
LF		equ	0Ah           ;- Line Feed
FALSE		equ	0
TRUE		equ	1
;
;--- Ethernet Frame Sizes
;
ETHERNET_ADDRESS_LENGTH		equ	6
ETHERNET_HEADER_SIZE		equ	14
MINIMUM_ETHERNET_PACKET_SIZE	equ	60
;MAXIMUM_ETHERNET_PACKET_SIZE	equ	1514
MAXIMUM_ETHERNET_PACKET_SIZE	equ	1500 ;; just data, not media header

MAX_PACKET         Equ       1514      ; Maximum allowable packet size.
MIN_PACKET         Equ       60        ; Minimum allowable packet size.
; 
;--- Packet filter bit definitions
; 
FLTR_DIRECTED                Equ       01H
FLTR_MLTCST                  Equ       01H
FLTR_BRDCST                  Equ       02H
FLTR_PRMSCS                  Equ       04H
FLTR_SRC_RTG                 Equ       08H
;
;--- Processor Type Equates
;
EIGHT_BIT          equ       0001H
SIXTEEN_BIT        equ       0002H
PROC_TYPE_MASK     equ       0030H

PROC_8086          equ       0000H OR EIGHT_BIT
PROC_80286         equ       0010H OR SIXTEEN_BIT
PROC_80386         equ       0020H
PROC_80486         equ       0040H
;
;--- Result codes returned in AX by a PXE API service.
;
PXENV_EXIT_SUCCESS		equ	0
PXENV_EXIT_FAILURE		equ	1
PXENV_EXIT_CHAIN		equ	0FFFFh	; used internally
;
;--- Status codes returned in the status word of PXE API parameter structures.
;
PXENV_STATUS_SUCCESS		equ	0
PXENV_STATUS_FAILURE		equ	1	;general failure
PXENV_STATUS_BAD_FUNC		equ	2	;invalid function number
PXENV_STATUS_UNSUPPORTED	equ	3	;not yet supported
PXENV_STATUS_1A_HOOKED		equ	4	;Int 1AH cannot be unhooked

; Driver errors (60 to 0x6F)
; These errors are for UNDI compatible NIC drivers.
PXENV_STATUS_UNDI_MEDIATEST_FAILED 		equ	61h
PXENV_STATUS_UNDI_CANNOT_INIT_NIC_FOR_MCAST	equ	62h
;
;
EISA_ADAPTER             equ    1
PCI_ADAPTER              equ    2
PnP_ADAPTER              equ    3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\lmstruct.inc ===
;****************************************************************************
;
;       The information contained in this file is confidential and 
;       proprietary to Standard Microsystems Corporation.  No part
;       of this file may be reproduced or distributed, in any form
;       or by any means for any purpose, without the express written
;       permission of Standard Microsystems Corporation.
;
; File:         lmstruct.inc
;
; Description:  Definitions for the various data structures and the
;               equates supporting these structures.
;
;
;********************
;* Revision History *
;********************
;
; $Log: /Client Boot/NICS/SMC/9432/UNDI/LMSTRUCT.INC $
; 
;    Rev 1.191   24 Nov 1997 17:22:54   cosand
; Added definitions for the AdapterStructure variable card_SSID (PCI
; Subsystem ID), added the variable power_mode inside IFDEF EPIC.
; Added the variables TxUnderrunCnt, NoETX, PciMRead, BurstLen, and
; ScrambleOn to AdapterStructure inside IFDEF EZSTART in order to make
; the assembly AdapterStructure match the C AdapterStructure for EZSTART.
; 
;    Rev 1.190   04 Nov 1997 16:05:22   cosand
; Added the variable card_SSID to AdapterStructure.  It is used to store
; the PCI Subsystem ID.
; 
;    Rev 1.189   11 Sep 1997 13:29:12   cosand
; Added the variable phy_id to AdapterStructure.  It is
; used by the Epic lmac to store the Phy's organizationally
; unique identifier.
; 
;    Rev 1.188   05 Aug 1997 12:26:34   cosand
; Changed the size of gen_cntl from a word to a dword, since the General
; Control register in Epic XF uses more than 16 bits.
; 
;    Rev 1.187   27 Mar 1997 07:42:18   ANDERS
; Added 2 new bit definitions to AdapterStructure variable "adapter_flags1".
; "SCRAMBLE equ 0001h" & "READ_MULT equ 8000h".
; In AdapterStructure struc definition used IFDEF EPIC to define 3 new
; variables - "burstlen db 0", "ipg_delay db 0" & "preemp_count dw 0".
;
;   Rev 1.0   26 Mar 1997 15:01:14   ANDERS
;Initial revision.
; 
;    Rev 1.186   20 Feb 1997 10:36:36   ANDERS
; changed gen_cntl variable in Adapter Structure to 0010 (FREEBUFF defined)
; or 0110 (FREEBUFF not defined).  This turns off PCI "read multiple" for 9432.
; 
;    Rev 1.185   20 Feb 1997 10:29:20   DONOHOE
; Added Enabler support
; 
;    Rev 1.184   14 Feb 1997 18:44:06   cosand
; Changed the default value of gen_cntl outside the FREEBUFF conditional
; to 0500h (was 0100h) to set the PCI transmit DMA "memory read multiple"
; command bit in the Epic General Control Register.
; 
;    Rev 1.183   07 Feb 1997 17:38:58   DONOHOE
; Change for 8020TM with 2.1 tuples
; 
;    Rev 1.182   05 Feb 1997 12:06:32   ANDERS
; changed default value of "gen_cntl" under FREEBUFF conditional to
; 0410h (was 0010h) to set transmit DMA PCI "read memory multiple"
; command
; 
;    Rev 1.181   04 Oct 1996 14:23:46   cosand
; Added NEEDS_SERVICE to adapter_flags1 to indicate that BroadcomBugFix needs
; to be called for the 9332BVT.
; 
;    Rev 1.180   06 Sep 1996 10:53:18   COSAND_J
; Added a MEDIA_TYPE_AUTO_SENSE bit to media_type2 to specify auto
; speed detection for the 9332bvt.
; 
;    Rev 1.179   23 Aug 1996 09:42:58   ANDERS
; under conditional assembly "IFDEF EPIC" change definition of "int_mask"
; from dw to dd for XE chip reg defintions
; 
;    Rev 1.178   16 Jul 1996 13:30:30   STEIGER
; Removed C-language comment delimiter around "LINE_SPEED_T4" and replaced it
; with an assembly language comment delimiter (semicolon). After all, it is
; an INC file!
; 
;    Rev 1.177   16 Jul 1996 11:19:14   STEIGER
; Changed "IFDEF SPIKE" to "IFDEF TURBO".
; 
;    Rev 1.176   14 May 1996 13:42:36   COOKE_J
; Added defines for 100BaseT4 LINE_SPEED_T4 as LINE_SPEED_100
; 
;    Rev 1.175   11 Mar 1996 08:50:00   TRAN_D
; Defined callback_handler_addr in AdapterStructure for 8016 (PCMCIA).
; 
;    Rev 1.174   29 Feb 1996 14:51:32   COOKE_J
; Added support for 9332BDT
; 
;    Rev 1.173   13 Feb 1996 09:51:44   DONOHOE
; Added lm_gc_corruption_check and ADAPTER_FOUND_LAN_CORRUPT return to
; LM_GetCnfg so it can still try to find the card if some of the LAN
; regs were corrupted.
; 
;    Rev 1.172   12 Jan 1996 11:13:36   CHAN_M
; Changed EPIC's rx fifo threshold to 1/4 full for Free Buffer Pool mode.
; 
;    Rev 1.171   08 Jan 1996 15:14:44   WATANABE
; 1.  Update LMAC to conform to spec v3.01.
;         - eliminate media_used.
; 
; 2.  Add dual function support - PC Card 5.0 spec compliant. 
; 
; 
;    Rev 1.170   22 Dec 1995 14:19:50   NAJARIAN
; changes rx_lastfrag from dd to dw when not in CODE_386
; 
; 
;    Rev 1.169   19 Dec 1995 19:09:34   WATANABE
; 1.  Add defines for multi-function PC Card per v5.0 standard.
; 2.  Add 91C94 and 8020 Xilinx part support.
; 
;    Rev 1.168   19 Dec 1995 11:05:06   NAJARIAN
; added defines for lm9432
; 
;    Rev 1.167   26 Sep 1995 15:56:48   MALIK_D
; Cooke_J changed ifdef lm9432 to EPIC.
; 
;    Rev 1.166   07 Sep 1995 13:46:54   NAJARIAN
; uncommented out the commented out ERX_DISABLED, since the ethernet lower
; uses the cable to track the state of the early receive hardware on the 790.
; 
;    Rev 1.165   29 Aug 1995 18:04:20   CHAN_M
; Added fields media_type2 and line_speed in adapter structure for EPIC100.
; 
;    Rev 1.164   19 Jul 1995 11:32:38   ANDERSON
;
; Change: commented out ERX_DISABLED.  This bit was redundant.
;         Instead, use EARLY_RX_ENABLE in receive_mask.
; 
;    Rev 1.163   18 Jul 1995 14:50:28   CHAN_M
; EPIC100 changes to support Free Buffer Pool receive mechanism.
; 
;    Rev 1.162   12 Jul 1995 11:10:50   NAJARIAN
; removed references to needs_physical_addr and uses_physical_addr.
; Added TX_PHY, RX_PHY, TX_VIRT, and RX_VIRT.
; removed reference to TX_PHY_RX_VIRT (redundant)
; added ADAPTER_REMOVABLE to facilitate code to support hot swappable
; adapters.
; 
;    Rev 1.161   11 Jul 1995 15:03:08   COOKE_J
; Added flags and definitions for SATURN chipset in PCI machines.
; 
;    Rev 1.160   19 Jun 1995 18:15:16   CHAN_M
; minor modifications for EPIC100
; 
;    Rev 1.159   06 Jun 1995 16:21:32   CHAN_M
; EPIC100 changes
; 
;    Rev 1.159   06 Jun 1995 15:39:04   CHAN_M
; changes for EPIC100
; 
;    Rev 1.158   30 May 1995 17:10:36   WATANABE
; 1.  Reverse order for Rev and Early Rcv registers in 91Cxx chip.
; 
;    Rev 1.157   30 May 1995 11:35:24   ANDERSON
;
; Change: added PNP_ENABLE and PNP_BOOT_BIT to adapter_flags1
; 
;    Rev 1.156   23 May 1995 11:13:22   STEIGER
; Removed _DWORD definition -- MASM didn't like it. Changed
; Ethernet error counter variable widths explicitly. This may
; cause some assembly warnings.
; 
;    Rev 1.155   23 May 1995 10:45:26   STEIGER
; Changed Ethernet error counter pointers from "dd 0" to
; "_DWORD"
; Added definition of _DWORD. If CODE_386 is defined, _DWORD is equivalent
; to "dd 0", else it is equivalent to "dw 2 dup (0)"
; 
;    Rev 1.154   25 Apr 1995 10:54:36   WATANABE
; Added MEDIA_UTP100 for media_type.
; Added MEDIA_INVALID for error codes under CONFIG_ERROR.
; 
;    Rev 1.154   24 Apr 1995 19:02:36   WATANABE
; Added MEDIA_UTP100 for media_type.
; 
;    Rev 1.153   14 Apr 1995 09:41:52   HUI_S
; Change: move mc_count into ifdef ETHERNET (Token ring has its own)
; 
;    Rev 1.152   20 Mar 1995 11:45:26   HUI_S
; move mc_count field from DEC_PCI definition to public 
;    in Adapter Structure
; 
;    Rev 1.151   16 Mar 1995 17:27:26   MARCUS_C
; WORD aligned Token Ring Adapter Structure variables following monitor_state.
; 
;    Rev 1.150   08 Mar 1995 16:00:50   WATANABE
; 1.  Added eerom_rev, pci_bus_number and pci_vslot_num for EZStart.
; 
;    Rev 1.149   13 Feb 1995 15:03:30   ANDERSON
;
; Change: Add EARLY_RX_DONE flag to adapter_flags1.
; 
;    Rev 1.148   08 Feb 1995 18:24:38   CHAN_M
; Changed early rx & tx values for high performance 8416 driver
; 
;    Rev 1.147   02 Feb 1995 15:12:22   WATANABE
; 1.  Added NOT_INIT_BY_BRIDGE return code.  LM_GetCnfg will return this
;     code when a PCI-PCI_bridge is present but BIOS does not initialize
;     the NIC properly.
; 
; 
; 
;    Rev 1.146   11 Jan 1995 14:47:52   WATANABE
; 1.  Added test_flag(BYTE) to adapter structure for EZStart 
;     interrupt test.
; 
; 
; 
; 
;    Rev 1.145   02 Dec 1994 19:30:56   WATANABE
; 1. Added members to adapter structure for LM9232 support with conditional compile 
;    switch "LM9232".
; 2. Added new equates :
;         EISA_SLAVE_DMA_CUTOFF - DMA threshold
;         BIC_574_CHIP - EFI bic
;         NIC_C100_CHIP - FEAST 
;         
; 
;    Rev 1.143   09 Nov 1994 11:12:38   CHAN_M
; Changed the following bus_type definitions to conform to Novell's spec.
;     PCI_BUS  equ  3
;     PCMCIA_BUS equ 4
; 
;    Rev 1.142   10 Oct 1994 18:59:04   WATANABE
; For supporting 8432BTA, 8432BA, & 8432TA boards
; 
; 1.  Changed define labels for media_type :
;         MEDIA_UTP_FULL_DUPLEX    to   MEDIA_UTPFD
;         MEDIA_UTP_NO_LINK_TEST   to   MEDIA_UTPNL
; 
; 2.  Added new define lables for media_type :
; 
;         MEDIA_AUI_BNC
;         MEDIA_AUI_BNC_UTP
; 
;    Rev 1.141   15 Sep 1994 11:46:20   MARCUS_C
; Added ptr_bcn_type and ptr_local_ring_num variables to adapter structure.
; These variables are mandatory for the Novell 386 file server driver.
; 
;    Rev 1.140   26 Aug 1994 11:03:10   MARCUS_C
; 1. Evenize adapter_structure.
; 
;    Rev 1.139   26 Aug 1994 10:46:32   MARCUS_C
; 1. Made changes to support LM_8115_s2.2_v2.00a.
; 
;    Rev 1.138   16 Aug 1994 13:31:02   PAUL_A
; Add support for 8316 Token Ring AT Bus Master adapter and 587 i-face chip.
; 
; Change:       add extra dma area for queueing sends.
; Change:       add bus_master_control to set dma priority.
; Change:       add  ETX_DISABLE to adapter_flags to disable early transmit.
; Change:       Add virt_erx_buffer and ptr_erx_fraglist to support
;               Early Receive for 8316.
; Change:       Add dma_channel.
; Change:       Add num_tx_fcbs_queued for 8316 for pending support.
; Change:       Add BIC_587_CHIP.
;
;    Rev 1.137   12 Aug 1994 11:07:28   teresa
; Added board_id2, extra_info2, and media_menu to adapter_structure
;    for EZSTART interface with future products.
; Added media_used to DEC_PCI specific section in adapter structure.
; 
; 
;    Rev 1.136   02 Aug 1994 17:29:36   teresa
; 1.  Add tx_buff_tbl and tx_buff_idx to adapter structure to support
;     double copy in tx routine.
; 2.  Move rev_number field to the end to align each field on word boundary.
; 3.  Change defines for host RAM size to include TX buffer.
; 
; 
;    Rev 1.131   18 May 1994 16:16:04   WOOD_R
; Fixed banner, finally
;  
;     Rev 1.130   03 May 1994 16:05:20   STEIGER
;  More banner problems.
;  
;     Rev 1.129   03 May 1994 16:01:00   STEIGER
;  Added structure members media_opts and media_set. Used by LM_GetCnfg
;  to indicate available and configured media on Ethernet and Token Ring
;  adapters.
;  
;     Rev 1.128   21 Apr 1994 16:02:40   wood_r
;  Banner problems
;  
;     Rev 1.127   21 Apr 1994 15:13:34   wood_r
;  LM_8416_s2.1_v2.00a
;
; Changes:      This revision of the file will be the start of the next
;               generation of the Ethernet LMACs.  The version level will
;               be bumped from 1.xxx to 2.xxx.
;
;               The Ring Empty feature on the 795 was added to the code
;               base.  To implement the feature, a flag bit is used in the
;               adapter structure variable "lmac_flags".  The equate
;               USE_RE_BIT was defined to support the feature.
;
;               The Ehternet LMAC driver now supports "Dual Mode" operation.
;               This is implemented by using a flag bit, "IO_MAPPED", in the
;               adapter structure variable "adapter_flags".
;
;+!?/ ***********************************************************************

MC_TABLE_ENTRIES        equ     16

;IFNDEF MAXFRAGMENTS
MAXFRAGMENTS            equ     32
;ENDIF

MAX_TX_QS               equ     8
NUM_TX_QS_USED          equ     3

MAX_RX_QS               equ     2
NUM_RX_QS_USED          equ     2

LAPAD                   equ     20
IFDEF   LAF                     ; Look Ahead Full
LOOK_AHEAD_BUFFER_LEN   equ     512
;LOOK_AHEAD_BUFFER_LEN  equ     1518
ELSE
LOOK_AHEAD_BUFFER_LEN   equ     64
ENDIF

ifdef CODE_386
PHYSICAL_ADDR           equ     80000000h
else
PHYSICAL_ADDR           equ     8000h
endif

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       Structure Template to simplify handling of far pointers . . .

FarPointer      struc

	ofst            dw      ?
	sgmt            dw      ?

FarPointer      ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       Structure Template for received Ethernet packets (690)

EthernetPacket  struc

	EthRStat                db      ?
	EthNxtPkt               db      ?
	EthPhysSize             dw      ?
	EthDestAdd              db      6 dup (?)
	EthSrcAdd               db      6 dup (?)
	Eth8023Size             dw      ?

EthernetPacket  ends

;***************************
; Multicast Table Structure
;***************************

McTable                 struc

	address                 db      6 dup (?)
	instance_count          db      0

McTable                 ends

SIZE_OF_MC_TABLE        equ     MC_TABLE_ENTRIES * (size McTable)

;*******************************
; Fragment Descriptor Structure
;*******************************

FragmentStructure       struc
	fragment_ptr            dd      0
ifdef   CODE_386
	fragment_length         dd      0
else
	fragment_length         dw      0
endif
FragmentStructure       ends

;**********************************
; Data Buffer Structure Definition
;**********************************

DataBuffStructure       struc

ifdef   CODE_386
	fragment_count          dd      0
else
	fragment_count          dw      0
endif
	fragment_list           db      (MAXFRAGMENTS * (size FragmentStructure)) dup (0)

DataBuffStructure       ends
ifdef   PCMCIA
;**********************************
; PCMCIA Data Structure defs
;**********************************

InfoStruct      struc

	InfoInfoLen             dw      0
	InfoSignature           dw      0
	InfoCount               dw      0
	InfoRevision            dw      0
	InfoCSLevel             dw      0
	InfoVStrOff             dw      0
	InfoVStrLen             dw      0
	InfoVendorString        db      128 dup (0)

InfoStruct      ends
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

RegisterClientStruct    struc

	RegCliAttributes        dw      0
	RegCliEventMask         dw      0
	RegCliClientData        db      8       dup (0)
	RegCliCSVersion         dw      0

RegisterClientStruct    ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; The following struct is a template to go along with TupleData struct.
; 
TupleStruct     struc

	TpStSocket              dw      ?
	TpStAttributes          dw      ?
	TpStDesiredTuple        db      ?
	TpStTupleOffset         db      ?
	TpStFlags               dw      ?
	TpStLinkOffset          dd      ?
	TpStCISOffset           dd      ?
	TpStTupleCode           db      ?
	TpStTupleLink           db      ?

TupleStruct     ends
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TupleData       struc

	TpDtSocket              dw      0
	TpDtAttributes          dw      0
	TpDtDesiredTuple        db      0
	TpDtTupleOffset         db      0
	TpDtFlags               dw      0
	TpDtLinkOffset          dd      0
	TpDtCISOffset           dd      0
	TpDtTupleDataMax        dw      0       
	TpDtTupleDataLen        dw      0       
	TpDtTupleData           db      128     dup (0)

TupleData       ends
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ReqIOStruct     struc

	ReqIOSocket             dw      0
	ReqIOBasePort1          dw      0
	ReqIONumPorts1          db      0
	ReqIOAttributes1        db      0
	ReqIOBasePort2          dw      0
	ReqIONumPorts2          db      0
	ReqIOAttributes2        db      0
	ReqIOIOAddrLines        db      0

ReqIOStruct     ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ReqIrqStruct    struc

	ReqIrqSocket            dw      0
	ReqIrqAttributes        dw      0
	ReqIrqAssignedIrq       db      0
	ReqIrqIRQInfo1          db      0
	ReqIrqIRQInfo2          dw      0

ReqIrqStruct    ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ReqMemStruct    struc

	ReqMemSocket            dw      0
	ReqMemAttributes        dw      0
	ReqMemBase              dd      0
	ReqMemSize              dd      0
	ReqMemAccessSpeed       db      0

ReqMemStruct    ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MapMemPageStruct        struc

	MapMemCardOffset        dd      0
	MapMemPageNum           db      0

MapMemPageStruct        ends
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ReqCfgStruct    struc

	ReqCfgSocket            dw      0
	ReqCfgAttributes        dw      0
	ReqCfgVcc               db      0
	ReqCfgVpp1              db      0
	ReqCfgVpp2              db      0
	ReqCfgIntType           db      0
	ReqCfgConfigBase        dd      0
	ReqCfgStatus            db      0
	ReqCfgPin               db      0
	ReqCfgCopy              db      0
	ReqCfgConfigIndex       db      0
	ReqCfgPresent           db      0

ReqCfgStruct    ends
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GetCfgInfoStruct        struc

	GCISocket               dw      0
	GCIAttribute            dw      0
	GCIVcc                  db      0
	GCIVpp1                 db      0
	GCIVpp2                 db      0
	GCIIntType              db      0
       GCIConfigBase            dd      0
	GCIStatus               db      0
	GCIPin                  db      0
	GCICopy                 db      0
	GCIConfigIndex          db      0
	GCIPresent              db      0
	GCIFirstDevType         db      0
	GCIFuncCode             db      0
	GCISysInitMask          db      0
	GCIManufCode            dw      0
	GCIManufInfo            dw      0
	GCICardValues           db      0
	GCIAssignedIRQ          db      0
	GCIIRQAttributes        dw      0
	GCIBasePort1            dw      0
	GCINumPorts1            db      0
	GCIAttributes1          db      0
	GCIBasePort2            dw      0
	GCINumPorts2            db      0
	GCIAttributes2          db      0
	GCIIOAddrLines          db      0

GetCfgInfoStruct        ends


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;; The following are structure templates for Tuple Data . . .

MfgIDTuple      struc

;       MfgTplCode              db      ?
;       MfgTplLink              db      ?
	MfgTplId                dw      ?
	MfgTplInfo              dw      ?

MfgIDTuple      ends
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FuncIdTuple        struc

	FuncIdTplCode           db      ?
	FuncIdTplSysinit        db      ?

FuncIdTuple        ends


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LanTuple        struc

	LTpType                 db      ?
	LTpLanTech              db      ?

LanTuple        ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LanNid          struc

	LanNidType              db      ?
	LTpLanIdSz              db      ?
	LTpLanId                db      6 dup (?)

LanNid          ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ConfigTuple    struc
       
       CTpSize                 db      ?
       CTpLast                 db      ?
       CTpRADR                 dw      ?
       CTpRMSK                 db      ?
       CTpRSVD                 db      ?

ConfigTuple    ends


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

AdjResInfoStructMem     struc

	ARIActionM              db      ?
	ARIResourceM            db      ?
	ARIAttributesM          dw      ?
	ARIBase                 dd      ?
	ARISize                 dd      ?

AdjResInfoStructMem     ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

AdjResInfoStructIO1     struc

	ARIActionIO1            db      ?
	ARIResourceIO1          db      ?
       ARIBasePortIO1          dw      ?
       ARINumPortIO1           db      ?
	ARIAttributesIO1        db      ?
       ARIAdrLineIO1           db      ?

AdjResInfoStructIO1     ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

AdjResInfoStructIO2     struc

	ARIActionIO2            db      ?
	ARIResourceIO2          db      ?
       ARIBasePortIO2          dd      ?
       ARINumPortIO2           dd      ?
	ARIAttributesIO2        db      ?
       ARIAdrLineIO2           db      ?

AdjResInfoStructIO2     ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

AdjResInfoStructIrq     struc

	ARIActionI              db      ?
	ARIResourceI            db      ?
	ARIAttributesI          db      ?
	ARIIrq                  db      ?

AdjResInfoStructIrq     ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

endif ; (PCMCIA)



;**********************************
; DEC PCI Data Structures & defs
;**********************************

ifdef  DEC_PCI

       MAX_TX_FRAMES_8432      equ     3
       MAX_TX_DESC_8432        equ     ((MAX_TX_FRAMES_8432 * MAXFRAGMENTS) + 1)
       MAX_RX_DESC_8432        equ     4
       MAX_BUFFER_SIZE         equ     1520
       SETUP_BUFFER_SIZE       equ     192
       HOST_RAM_ALIGNMENT      equ     32    

       HOST_RAM_SIZE           equ   ( (32 * MAX_TX_DESC_8432) \
				     + (32 * MAX_RX_DESC_8432 )   \
				     + SETUP_BUFFER_SIZE          \
				     + (MAX_RX_DESC_8432 * MAX_BUFFER_SIZE) \
				    + (MAX_TX_FRAMES_8432 * MAX_BUFFER_SIZE) \
				     + HOST_RAM_ALIGNMENT )

ADDR_TBL       struc
       virtual_addr    dd      0
       phy_addr        dd      0
ADDR_TBL       ends


TxDescriptorStructure  struc 

       tx_status       dd      0
       tx_control      dd      0
       tbuffer_1       dd      0
       tbuffer_2       dd      0
       tdesc_pad       dd      4 dup (0)

TxDescriptorStructure  ends


RxDescriptorStructure  struc

       rx_status       dd      0
       rx_control      dd      0
       rbuffer_1       dd      0
       rbuffer_2       dd      0
       vbuffer_1       dd      0
       rdesc_pad       dd      3 dup (0)

RxDescriptorStructure  ends


endif ; (DEC_PCI)

ifdef EPIC

DMA_FRAG        struc
dma_status      dw      0
dma_len         dw      0
dma_buf_addr    dd      0
dma_buf_len     dw      0
dma_control     dw      0
dma_next_phys   dd      0
dma_handle      dd      0
IFDEF CODE_386
dma_next_off    dd      0
dma_buff_off    dd      0
ELSE
dma_next_off    dw      0
dma_buff_off    dw      0
ENDIF
DMA_FRAG        ends

DMA_FRAG_SIZE   equ     4 + (8 * MAXFRAGMENTS)

DEFAULT_TX_DESC_9432        equ     3
DEFAULT_RX_DESC_9432        equ     3

; Default host ram size for UMACs that don't call LM_Get_Host_Ram_Size

HOST_RAM_TX_SIZE        equ     (size DMA_FRAG + DMA_FRAG_SIZE) * DEFAULT_TX_DESC_9432
HOST_RAM_RX_SIZE        equ     (size DMA_FRAG + DMA_FRAG_SIZE) * DEFAULT_RX_DESC_9432
HOST_RAM_SIZE   equ     HOST_RAM_TX_SIZE + HOST_RAM_RX_SIZE + 256

ADDR_TBL       struc
       virtual_addr    dd      0
       phy_addr        dd      0
ADDR_TBL       ends

endif

;******************************
; Adapter Structure Definition
;******************************

AdapterStructure        struc

	adapter_num             db      0       ;logical adapter no.  
	pc_bus                  db      0       ;Bus type
	io_base                 dw      0       ;I/O base address
	adapter_name            db      12 dup (0)
	irq_value               dw      0       ;IRQ line used by hardware
	rom_size                dw      0       ;num of 1024 byte blocks
	rom_base                dd      0       ;physical address of ROM
	rom_access              dd      0       ;seg:off value to access ROM
	ram_size                dw      0       ;num of 1024 byte blocks
	ram_base                dd      0       ;physical address of RAM
	ram_access              dd      0       ;seg:off value to access RAM
	ram_usable              dw      0       ;num of 1024 byte blocks (window size)
	io_base_new             dw      0       ;new base I/O Addr (for PutCnfg)
	xnode_address           db      6 dup (0)       ;network address 
	max_packet_size         dw      0       ;max pkt size hardware supports
IFDEF EPIC
	num_of_tx_buffs         dw      DEFAULT_TX_DESC_9432
ELSE
	num_of_tx_buffs         dw      1       ;TX buffs available in hardware
ENDIF
	receive_mask            dw      0
	adapter_status          dw      0
	media_type              dw      0       ;BNC, AUI, UTP_4, etc.
	media_type2             dw      0       ;added to support EPIC100
	line_speed              dw      0       ;added to support EPIC100
	adapter_bus             dw      0
	pos_id                  dw      0       ;Adapter POS ID (MCA only)
	adapter_flags           dw      0       ;
	adapter_flags1          dw      0       ;
	slot_num                db      0       ;Micro Channel slot number
	rx_lookahead_size       db      0       ; Size of UMAC's max lookahead in 16 byte chunks.
	media_opts              dw      0       ; Media options supported by the adapter ...
	media_set               dw      0       ; Media type(s) being used by the adapter ...
ifdef   LM8316
	dma_channel             dw      0       ; Direct Memory Access channel
else
ifdef  LM9232
       dma_channel             dw      0
endif
endif
IFDEF EPIC
IFDEF FREEBUFF
	num_of_rx_buffs         dw      10      ; num. of rx fragment lists
						; to preallocate
ELSE
	num_of_rx_buffs         dw      DEFAULT_RX_DESC_9432
ENDIF
IFDEF EZSTART
; These 5 variables were added to make lmstruct.inc match lmstruct.h for EZSTART.
; None of these variables are being used by the assembly lmac 11/24/97.
    TxUnderrunCnt           dw      0
    NoETX                   dw      0
    PciMRead                dw      0
    BurstLen                dw      0
    ScrambleOn              dw      0
ENDIF ;EZSTART
IFDEF FREEBUFF
	num_rx_free_buffs       dw      0       ; num. of rx fragment lists
						; owned by the LMAC
ENDIF
ENDIF ;EPIC

	;-----------------------...Local vars for each adapter...----------------------

	bic_type                dw      0
	nic_type                dw      0
	phy_id                  dd      0       ;Phy organizationally unique identifer
	board_id                dw      0       ;WDM defined Board ID
	board_id2               dw      0
	extra_info              dw      0       ;WDM defined Extra Board Info
	extra_info2             dw      0
	mode_bits               dw      0       ;mode bits for adapter
	status_bits             dw      0       ;
	xmit_buf_size           dw      600h    ;
	xmit_flag_offset        dw      0
	config_mode             dw      0       ; 1=store config in EEROM
	page_offset_mask        dw      0
	media_menu              dw      0
	easp                    dd      0
    card_SSID               dw      0       ;PCI Subsystem ID

ifdef TOKEN_RING
	ptr_rx_fcb_overruns     dd      0
	ptr_rx_bdb_overruns     dd      0
	ptr_rx_fifo_overruns    dd      0
	ptr_tx_fifo_underruns   dd      0
	ptr_internal_errors     dd      0
	ptr_line_errors         dd      0
	ptr_ac_errors           dd      0
	ptr_burst_errors        dd      0
	ptr_ad_trans_errors     dd      0
	ptr_rcv_congest_errors  dd      0
	ptr_lost_frame_errors   dd      0
	ptr_freq_errors         dd      0
	ptr_fr_copied_errors    dd      0
	ptr_token_errors        dd      0
	ptr_una                 dd      0
	ptr_bcn_type            dd      0
	ptr_local_ring_num      dd      0

	ring_status_flags       db      0
	join_state              db      0
	monitor_state           db      0
	filler                  db      0       ; evenize structure

	ring_status             dw      0
	authorized_function_clases      dw      0
	authorized_access_priority      dw      0
	microcode_version       dw      0
	group_address_0         dw      0
	group_address           dw      2 dup (0)
	functional_address_0    dw      0
	functional_address      dw      2 dup (0)
	bitwise_group_address   dw      2 dup (0)
	source_ring_number      dw      0
	target_ring_number      dw      0
	ptr_ucode               dd      0

;/*
;   The following values are for lower mac use only!
;   They are not used by the upper mac
;*/

ifdef   LM8316
	tx_dma_area_ptr         dd      0       ;ptr to tx fraglist space
	rx_dma_area_ptr         dd      0       ;ptr to rx fraglist space
	extra_dma_area_ptr      dd      0       ;ptr to extra fraglist space
	tx_dma_fcb              dd      0       ;transmit fcb being transferred
	virt_erx_buffer         dd      0       ;virt ptr to UMAC erx buffer
	ptr_erx_fraglist        dd      0       ;virt ptr to phys fraglist
	bus_master_control      dw      0       ;set dma request priority
endif
	sh_mem_used             dd      0

	config_word0            dw      0       
	config_word1            dw      0       

	iscpb_ptr               dd      0       ;ptr to init sys cfg ptr block
	scgb_ptr                dd      0       ;ptr to sys config block
	sclb_ptr                dd      0       ;ptr to sys control block
	isb_ptr                 dd      0       ;ptr to interrupt status block
	current_isb_index       dw      0       ;interrupt status block index
	misc_command_data       dd      0

	acb_head                dd      0       ;ptr to action command block
	acb_curr                dd      0
	acb_next                dd      0

	num_acbs                dw      0
	num_acbs_used           dw      0
	acb_pending             dw      0

	tx_fcb_head             dd      NUM_TX_QS_USED dup (0)
	tx_fcb_curr             dd      NUM_TX_QS_USED dup (0)
	tx_fcb_tail             dd      NUM_TX_QS_USED dup (0)  ; points to the most recent transmitted frame

	tx_bdb_head             dd      NUM_TX_QS_USED dup (0)

	tx_buff_head            dd      NUM_TX_QS_USED dup (0)
	tx_buff_end             dd      NUM_TX_QS_USED dup (0)
	tx_buff_curr            dd      NUM_TX_QS_USED dup (0)
	tx_buff_size            dw      NUM_TX_QS_USED dup (0)

	num_tx_fcbs             dw      NUM_TX_QS_USED dup (0)
	num_tx_bdbs             dw      NUM_TX_QS_USED dup (0)
	num_tx_fcbs_used        dw      NUM_TX_QS_USED dup (0)

ifdef   LM8316
	num_tx_fcbs_queued      dw      NUM_TX_QS_USED dup (0)
endif
	tx_buff_used            dw      NUM_TX_QS_USED dup (0)
	tx_queue_status         dw      NUM_TX_QS_USED dup (0)

	rx_fcb_head             dd      NUM_RX_QS_USED dup (0)
	rx_fcb_curr             dd      NUM_RX_QS_USED dup (0)

	rx_bdb_head             dd      NUM_RX_QS_USED dup (0)
	rx_bdb_end              dd      NUM_RX_QS_USED dup (0)
	rx_bdb_curr             dd      NUM_RX_QS_USED dup (0)

	rx_buff_head            dd      NUM_RX_QS_USED dup (0)
	rx_buff_end             dd      NUM_RX_QS_USED dup (0)

	num_rx_fcbs             dw      NUM_RX_QS_USED dup (0)
	num_rx_bdbs             dw      NUM_RX_QS_USED dup (0)
	receive_queue_number    dw      0

	rx_buff_blk_size        dw      NUM_RX_QS_USED dup (0)
	rx_shift_factor         db      NUM_RX_QS_USED dup (0)  ; mul. factor to get # of BDBs from frame length        

	trc_mask                db      0
	rx_fifo_overrun_count   db      0

	lobe_media_test_flag    db      0
	DMA_test_state          db      0
						  
;/* end of lower mac specific variables */

endif

ifdef   ETHERNET
;-------------------------...Error Counter Pointers...-------------------------

ifdef   CODE_386
	ptr_rx_CRC_errors       dd      0
	ptr_rx_too_big          dd      0
	ptr_rx_lost_pkts        dd      0
	ptr_rx_align_errors     dd      0
	ptr_rx_overruns         dd      0
	ptr_tx_deferred         dd      0
	ptr_tx_total_collisions dd      0
	ptr_tx_max_collisions   dd      0
	ptr_tx_one_collision    dd      0
	ptr_tx_mult_collisions  dd      0
	ptr_tx_ow_collision     dd      0
	ptr_tx_CD_heartbeat     dd      0
	ptr_tx_carrier_lost     dd      0
	ptr_tx_underruns        dd      0
	ptr_ring_OVW            dd      0
else
	ptr_rx_CRC_errors       dw      2 dup (0)
	ptr_rx_too_big          dw      2 dup (0)
	ptr_rx_lost_pkts        dw      2 dup (0)
	ptr_rx_align_errors     dw      2 dup (0)
	ptr_rx_overruns         dw      2 dup (0)
	ptr_tx_deferred         dw      2 dup (0)
	ptr_tx_total_collisions dw      2 dup (0)
	ptr_tx_max_collisions   dw      2 dup (0)
	ptr_tx_one_collision    dw      2 dup (0)
	ptr_tx_mult_collisions  dw      2 dup (0)
	ptr_tx_ow_collision     dw      2 dup (0)
	ptr_tx_CD_heartbeat     dw      2 dup (0)
	ptr_tx_carrier_lost     dw      2 dup (0)
	ptr_tx_underruns        dw      2 dup (0)
	ptr_ring_OVW            dw      2 dup (0)
endif
	multi_address           db      6 dup (0)       ;network group address

;/*
;   The following values are for lower mac use only!
;   They are not used by the upper mac
;  
;*/
ifdef   CODE_386
	early_xmit_flags        dw      0
	split_word              dw      0
	leftover_count          dd      0
endif

IFDEF EPIC
	burstlen                db      0
	ipg_delay               db      0
	preemp_count            dw      0
ELSE
; for 8232
	max_page_num            db      0
	curr_page_num           db      0
	early_tx_pend           db      0
	rx_pend                 db      0
ENDIF
	early_tx_threshold      dw      0

	rx_frag                 dd      0
	erx_offset              dw      0
	erx_size                dw      0
	dummy_vector            dd      0

ifdef   CODE_386
	xmit_threshold          dd      0
else
	xmit_threshold          dw      0
endif
	tx_pend                 dw      0
;;;     early_tx_slope          db      0
	tx_retry                db      0
	early_rx_slope          dw      0
endif

ifdef   ETHERNET
	imr_hold                db      0
	rcr_hold                db      0
	pstart_hold             db      0
	pstop_hold              db      0
	local_nxtpkt_ptr        db      0
	int_bit                 db      0
	hdw_int                 db      0
	ovw_tx_pending          db      0
ifdef   CODE_386
	pstop_32                dd      0
	wr_frag_cnt             dd      0
	byte_cnt                dd      0
	packet_offset           dd      0
else    
	wr_frag_cnt             dw      0
	byte_cnt                dw      0
	packet_offset           dw      0
endif
endif

ifdef   ETHERNET
	packet_ptr              dw      0
	int_port                dw      0
	pkt_len                 dw      0
	ring_ovw                db      0
	laar_enter              db      0
	data_buff_seg           dw      0
	leftover_data           dw      0
	tx_buffer               dd      3 dup (0)
ifdef   LNKLST
	tx_head                 dw      0
	tx_tail                 dw      0
else
	tx_head                 db      0
	tx_tail                 db      0
endif
	tx_count                db      0
	tx_pstop                db      0
	servicing_ints          dw      0

;;      lpbk_frag_count         dw      0
;;      lpbk_frag_struct        db      size FragmentStructure dup (0)

ifdef   LNKLST
	rec_buf_size            dw      0
	tstart                  dw      0
	tstop                   dw      0
	rstart                  dw      0
	rstop                   dw      0
	tbegin                  db      0
	tend                    db      0
	rbegin                  db      0
	rend                    db      0
	num_rdt_entries         dw      0
	next_rdt_entry          dw      0
	rdt_size                db      0
	xmt_size                db      0
	rec_size                db      0
endif
	laar_exit               db      0
	erx_frame_size          dw      0
	lmac_flags              dw      0
	erx_addr_type           db      0
;if ETHERNET EQ 3000
ifdef E3000
	tx_mask                 db      0
	rx_mask                 db      0
	rx_status               db      0

	pkt_byte_offset         dw      0
	total_bytes_to_move     dw      0
	xmit_pkt_size           dw      0
	driver_state            dw      0
	pkt_bytes_looked        dw      0
	etherstar_byte_count    dw      0
	bytes_from_LA           dw      0

	ptr_shrtpkt_errors      dd      0
	ptr_busread_errors      dd      0
	ptr_buswrite_errors     dd      0

ifdef LA_BUFF
	look_ahead_buf          db      LA_BUFF dup (0)
else
	look_ahead_buf          db      256 dup (0)
endif
endif

;------------------------...Multicast Address Table...-------------------------
	bc_add                  db      6 dup   (0ffh)  ; Broadcast address.
				db      1               ; Instance count for
							; broadcast address.
	mc_table                db      SIZE_OF_MC_TABLE dup (0)
	temp_addr               db      6 dup   (0)

ifdef   PCMCIA
	callback_handler_addr   dd      0
	callback_handler_status dw      0
	pcm_socket              dw      0
	pcm_card_flags          dw      0
	pcm_client_handle       dw      0
	pcm_ram_win_handle      dw      0
	pcm_reg_win_handle      dw      0
       pcm_isr_handler         dd      0
       pcm_cs_ver              dw      0
       pcm_max_num_skt         dw      0
       pcm_cfg_reg_addr        dw      0 
       req_irq_struct           db      size ReqIrqStruct               dup (0)
	req_mem_struct          db      size ReqMemStruct               dup (0)
	req_io_struct           db      size ReqIOStruct                dup (0)
	tuple_data              db      size TupleData                  dup (0)
	register_client_struct  db      size RegisterClientStruct       dup (0)
	info_struct             db      size InfoStruct                 dup (0)
	req_cfg_struct          db      size ReqCfgStruct               dup (0)
	get_cfg_info_struct     db      size GetCfgInfoStruct           dup (0)
	map_mem_page_struct     db      size MapMemPageStruct           dup (0)
	adj_res_info_struct     db      size AdjResInfoStructMem        dup (0)
ifndef PCCARD5
	pcm_modem_irq           dw      0
	pcm_modem_iobase        dw      0
	pcm_modem_isr           dd      0
	pcm_modem_handle        dw      0  ;swap generic enabler handle and ours
endif
       
endif ; (PCMCIA)

;/* end of lower mac specific variables */
endif ; (Ethernet)

; 
; PCI configuration
;
ifdef  DEC_PCI

; host ram physical and virtual address
       host_ram_phy_addr       dd      0
       host_ram_virt_addr      dd      0

	device_id               dw      0
	cbio                    dd      0

; Registers

	op_mode                 dd      0
	int_mask                dd      0
	sia_mode0               dd      0
	sia_mode1               dd      0
	sia_mode2               dd      0
       def_bus_mode            dd      0

; TX descriptor ring  - 16 bytes/descriptor - quadword aligned 

	tx_ring                 db      (size ADDR_TBL) dup (0)
       tx_buff_tbl             db      (MAX_TX_FRAMES_8432 * (size ADDR_TBL)) dup (0)
       tx_buff_idx             dw      0
	tx_enqueue              dd      0
	tx_dequeue              dd      0
	free_tx_desc            dd      0

;
; Rx descriptor ring - 16 bytes/descriptor - quadword aligned
; Rx buffer - 1.6k/buffer - longword aligned
;

	rx_ring                 db      (size ADDR_TBL) dup (0)
	rx_dequeue              dd      0
	current_rx_buffer       dd      0
       media_used              dw      0

;
; CAM setup buffer -192 bytes - longword aligned
;

	setup_ptr               db      (size ADDR_TBL) dup (0)

       multicast_check         db      0

	rev_number              db      0
       test_flag               db      0

;
; for EZSTART 
;
       eerom_rev               db      0
       pci_bus_num             db      0
       pci_vslot_num           db      0

endif         ; DEC_PCI

IFDEF EPIC
; host ram physical and virtual address
host_ram_phy_addr       dd      0
host_ram_phy_base       dd      0
host_ram_virt_addr      dd      0


IFDEF CODE_386
rx_curr_lookahead       dd      0
rx_curr_fraglist        dd      0
IFDEF FREEBUFF
rx_last_fraglist        dd      0
ENDIF
tx_first_off            dd      0
tx_curr_off             dd      0
ELSE
rx_curr_lookahead       dw      0
rx_curr_fraglist        dw      0
IFDEF FREEBUFF
rx_last_fraglist        dw      0
ENDIF
tx_first_off            dw      0
tx_curr_off             dw      0
ENDIF
tx_free_desc_count      dw      0
tx_scratch              dd      0

early_tx_thresh         dw      64
ipg_timer               dw      03c60h

vslotnumber             db      0
busnumber               db      0


int_mask                dd      0
slot_timer              dw      0fh
IFDEF FREEBUFF 
gen_cntl                dd      00000010h       ; ONECOPY, "memory read", 32 byte rx thresh
ELSE
gen_cntl                dd      00000100h       ; 64 byte rx thresh, "memory read"
ENDIF
test_reg                dd      0h

;
; CAM setup buffer -192 bytes - longword aligned
;

	setup_ptr               db      (size ADDR_TBL) dup (0)

       multicast_check         db      0

endif

IFDEF LM9232
       look_ahead_buf          db      256 dup (0)

MCAddress               db      6 dup (0)       ;Used for multicast
MCWorkArea              db      8 dup (0)
SCECTxQueueSize         db       3              ;default max tx free count
TxPacketsInsideSCEC     db      0               ; 1 -> 2048 bytes for 91C90
CurrentTxPcktSize       db      0               ; but 256 bytes for 91C92
SCECShrForPageSize      db      ?
MIRShlTo256ByteUnits    db      0               ;0 for 91C90/92, 1 for FEAST

InDriverInitFlag        db      0
OddAddressFlag          db      0
AllocationRequestedFlag db      0

Is386                   db      0               ;Default to 286

;RxErrorBits             dw      ?
SCECPageSize            dw      ?
SCECMaxMemForTx         db      ?               ;In percentage
SCECMaxPagesForTx       dw      ?
SCEC1518InSCECPages     dw      ?
SCECNumberOfPages       dw      ?

HardwareFrameLength     dw      ?               ;Used to set SCEC's Control 
						; byte.

;/**************************************************************************\
;*                                                                          *
;*      I/O Port Variables                                                  *
;*                                                                          *
;\**************************************************************************/

;storage for IO address locations
;Bank 1

TCR                     dw      0     
StatusRegister          dw      0             
RCRRegister             dw      0     
Counter                 dw      0             
MIR                     dw      0     
MCR                     dw      0     
NotUsed1                dw      0
BankSelect              dw      0
     
;Bank 2
Configuration           dw      0             
BaseAddress             dw      0     
IA0_1                   dw      0             
IA2_3                   dw      0             
IA4_5                   dw      0             
General                 dw      0             
Control                 dw      0     
NotUsed2                dw      0

;Bank 3
MMUCommand              dw      0     
PNR_ARR                 dw      0             
FifoPorts               dw      0     
Pointer                 dw      0             
Data0_1                 dw      0             
Data2_3                 dw      0             
Interrupt               dw      0     
NotUsed3                dw      0

;Bank 4
MT0_1                   dw      0             
MT2_3                   dw      0             
MT4_5                   dw      0             
MT6_7                   dw      0             
NotUsed4                dw      0
Revision                dw      0
ERCV                    dw      0

SCECRAMSize             dw      ?               ;In 256 byte units

; ----- debug counters -----
IFDEF  DEBUG
SQETCount               dw      2 dup (0)
ExcessiveDeferralCount  dw      2 dup (0)
TXDeferredCount         dw      2 dup (0)
TXMulticastCount        dw      2 dup (0)
TXBroadcastCount        dw      2 dup (0)
RxBroadcastCount        dw      2 dup (0)
RxMulticastCount        dw      2 dup (0)
SCECRxTooShortCount     dw      2 dup (0)
MMUTimeoutCount         dw      2 dup (0)
SpuriousEntryToISR      dw      2 dup (0)
ENDIF

MaxPercentageOnTx       dw      2 dup (0)

FoundSCECMaxMemForTx    db      0

InScecDriverInitFlag    db      0
;IntLine1                db      2              ;Override test pattern


;DMA look up tables for IO base registers

base_addr_dat           db      8 dup (0)
base_addr_dat_L         db      8 dup (0)
byte_count_dat          db      8 dup (0)

DMA_base_addr_dat       db      0
DMA_base_addr_dat_L     db      0
DMA_byte_count_dat      db      0


; Temporary FIX for FEAST Rev. B lockup problem with multiple stations
;
KickStartFlag          db      0

endif ; end FEAST

ifdef ETHERNET
       mc_count                dd      0
endif

IFDEF EPIC
       power_mode       dw      0            
ENDIF

AdapterStructure        ends

;************************************
; SNMP-ON-BOARD Agent Link Structure
;************************************

AgentLink       struc
  LnkSigStr     db 12 dup(0)    ;signature string containing "SmcLinkTable"
  LnkDrvTyp     db 0    ;1=Redbox ODI, 2=ODI DOS, 3=ODI OS/2, 4=NDIS DOS,
  LnkFlg        db 0    ;0 if no agent linked in, 1 if agent linked in
  LnkNfo        dd 0    ;pointer to routine which returns pointer to NIC info
  LnkAgtRcv     dd 0    ;pointer to agent receive trap entry
  LnkAgtXmt     dd 0    ;pointer to agent transmit trap entry
  LnkGet        dd 0    ;pointer to NIC receive data copy routine
  LnkSnd        dd 0    ;pointer to NIC send routine
  LnkRst        dd 0    ;pointer to NIC driver reset routine
  LnkMib        dd 0    ;pointer to MIB data base
  LnkMibAct     dd 0    ;pointer to MIB action routine list
  LnkCntOffset  dw 0    ;offset to error counters
  LnkCntNum     dw 0    ;number of error counters
  LnkCntSize    dw 0    ;size of error counters i.e. 32 = 32 bits
  LnkISR        dd 0    ;pointer to interrupt vector
  LnkFrmTyp     db 0    ; 1=Ethernet, 2=Token Ring
  LnkDrvVer1    db 0    ; driver major version
  LnkDrvVer2    db 0    ; driver minor version
AgentLink       ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Defs for pcm_card_flags(bit-mapped)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
REG_COMPLETE    equ     00001h
INSERTED        equ     00002h
PCC_INSERTED  equ    00004h          ; 1=currently inserted, 0=currently removed
ENABLER       equ    00008h

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Ram Test Patterns
;
RAM_PATTERN_1   equ     055AAh
RAM_PATTERN_2   equ     09249h
RAM_PATTERN_3   equ     0DB6Dh

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Equates for RAM test
;
ROM_SIGNATURE   equ     0AA55h
MIN_ROM_SIZE    equ     02000h
;
;
;**************
; Return Codes
;**************

SUCCESS                 equ     0000h   ; this code is defined by NDIS spec
ADAPTER_AND_CONFIG      equ     0001h
ADAPTER_NO_CONFIG       equ     0002h
NOT_MY_INTERRUPT        equ     0003h
FRAME_REJECTED          equ     0004h   ; this code is defined by NDIS spec
EVENTS_DISABLED         equ     0005h
OUT_OF_RESOURCES        equ     0006h   ; this code is defined by NDIS spec
INVALID_PARAMETER       equ     0007h   ; this code is defined by NDIS spec
INVALID_FUNCTION        equ     0008h   ; this code is defined by NDIS spec
INITIALIZE_FAILED       equ     0009h
CLOSE_FAILED            equ     000Ah
MAX_COLLISIONS          equ     000Bh
NO_SUCH_DESTINATION     equ     000Ch
BUFFER_TOO_SMALL_ERROR  equ     000Dh
ADAPTER_CLOSED          equ     000Eh
UCODE_NOT_PRESENT       equ     000Fh
FIFO_UNDERRUN           equ     0010h
DEST_OUT_OF_RESOURCES   equ     0011h
ADAPTER_NOT_INITIALIZED equ     0012h
PENDING                 equ     0013h
UCODE_PRESENT           equ     0014h
NOT_INIT_BY_BRIDGE     equ     0015h

OPEN_FAILED             equ     0080h
HARDWARE_FAILED         equ     0081h
SELF_TEST_FAILED        equ     0082h
RAM_TEST_FAILED         equ     0083h
RAM_CONFLICT            equ     0084h
ROM_CONFLICT            equ     0085h
UNKNOWN_ADAPTER         equ     0086h
CONFIG_ERROR            equ     0087h
CONFIG_WARNING          equ     0088h
NO_FIXED_CNFG           equ     0089h
EEROM_CKSUM_ERROR       equ     008Ah
ROM_SIGNATURE_ERROR     equ     008Bh
ROM_CHECKSUM_ERROR      equ     008Ch
ROM_SIZE_ERROR          equ     008Dh
UNSUPPORTED_NIC_CHIP    equ     008Eh
NIC_REG_ERROR           equ     008Fh
BIC_REG_ERROR           equ     0090h
MICROCODE_TEST_ERROR    equ     0091h
LOBE_MEDIA_TEST_FAILED  equ     0092h
CS_UNSUPPORTED_REV      equ     0093h
CS_NOT_PRESENT          equ     0094h
TUPLE_ERROR             equ     0095h
REG_CLIENT_ERR          equ     0096h
NOT_OUR_CARD            equ     0097h
UNSUPPORTED_CARD        equ     0098h
PCM_CONFIG_ERR          equ     0099h
CARD_CONFIGURED         equ     009Ah

ADAPTER_FOUND_LAN_CORRUPT       equ     009Bh
MODEM_NOT_CONFIGURED        equ    009Ch
UNSUPPORTED_PCMCIA          equ    009Dh
ENABLER_NO_CONFIG           equ    009Eh

ADAPTER_NOT_FOUND       equ     0ffffh
ILLEGAL_FUNCTION        equ     INVALID_FUNCTION

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Bit-Mapped codes returned in DX if return code from LM_GET_CONFIG is
; CONFIG_ERROR or CONFIG_WARNING:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;; Errors:
IO_BASE_INVALID         equ     0001h
IO_BASE_RANGE           equ     0002h
IRQ_INVALID             equ     0004h
IRQ_RANGE               equ     0008h
RAM_BASE_INVALID        equ     0010h
RAM_BASE_RANGE          equ     0020h
RAM_SIZE_RANGE          equ     0040h
MEDIA_INVALID          equ     0800h

;;;; Warnings:
IRQ_MISMATCH            equ     0080h
RAM_BASE_MISMATCH       equ     0100h
RAM_SIZE_MISMATCH       equ     0200h
BUS_MODE_MISMATCH       equ     0400h

;************************************************************
;* Definitions for status bits when calling UM_Receive_Packet
;************************************************************

RX_CRC_ERROR            equ     01h
RX_ALIGNMENT_ERROR      equ     02h
RX_HW_FAILED            equ     80h

;**********************************************
;* Definitions for the field RING_STATUS_FLAGS
;**********************************************

RING_STATUS_CHANGED                     equ     01h
MONITOR_STATE_CHANGED                   equ     02h
JOIN_STATE_CHANGED                      equ     04h

;***************************************
;* Definitions for the field JOIN_STATE
;***************************************

JS_BYPASS_STATE                         equ     00h
JS_LOBE_TEST_STATE                      equ     01h
JS_DETECT_MONITOR_PRESENT_STATE         equ     02h
JS_AWAIT_NEW_MONITOR_STATE              equ     03h
JS_DUPLICATE_ADDRESS_TEST_STATE         equ     04h
JS_NEIGHBOR_NOTIFICATION_STATE          equ     05h
JS_REQUEST_INITIALIZATION_STATE         equ     06h
JS_JOIN_COMPLETE_STATE                  equ     07h
JS_BYPASS_WAIT_STATE                    equ     08h

;******************************************
;* Definitions for the field MONITOR_STATE
;******************************************

MS_MONITOR_FSM_INACTIVE                 equ     00h
MS_REPEAT_BEACON_STATE                  equ     01h
MS_REPEAT_CLAIM_TOKEN_STATE             equ     02h
MS_TRANSMIT_CLAIM_TOKEN_STATE           equ     03h
MS_STANDBY_MONITOR_STATE                equ     04h
MS_TRANSMIT_BEACON_STATE                equ     05h
MS_ACTIVE_MONITOR_STATE                 equ     06h
MS_TRANSMIT_RING_PURGE_STATE            equ     07h
MS_BEACON_TEST_STATE                    equ     09h

;********************************************
;* Definitions for the bit-field RING_STATUS
;********************************************

SIGNAL_LOSS                             equ     08000h
HARD_ERROR                              equ     04000h
SOFT_ERROR                              equ     02000h
TRANSMIT_BEACON                         equ     01000h
LOBE_WIRE_FAULT                         equ     00800h
AUTO_REMOVAL_ERROR                      equ     00400h
REMOVE_RECEIVED                         equ     00100h
COUNTER_OVERFLOW                        equ     00080h
SINGLE_STATION                          equ     00040h
RING_RECOVERY                           equ     00020h

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Definitions for the field BUS_TYPE

AT_BUS                  equ     00h
MCA_BUS         equ     01h
EISA_BUS                equ     02h
PCI_BUS                 equ     03h
PCMCIA_BUS              equ     04h


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;**********************
; Defs for adapter_flags
;**********************

RX_VALID_LOOKAHEAD      equ     0001h
FORCED_16BIT_MODE       equ     0002h
ADAPTER_DISABLED        equ     0004h
TRANSMIT_CHAIN_INT      equ     0008h
EARLY_RX_FRAME          equ     0010h
EARLY_TX                equ     0020h
EARLY_RX_COPY           equ     0040h
;;;USES_PHYSICAL_ADDR   equ     0080h   ;;;#### Reserved - Do not uncomment
;;;NEEDS_PHYSICAL_ADDR  equ     0100h   ;;;#### Reserved - Do not uncomment
RX_STATUS_PENDING       equ     0200h
ERX_DISABLED            equ     0400h   ;;; Used by Ethernet 790 ERX logic
ENABLE_TX_PENDING       equ     0800h
ENABLE_RX_PENDING       equ     1000h
PERM_CLOSE              equ     2000h   ; For PCMCIA LM_Close_Adapter
IO_MAPPED               equ     4000h   ; IO mapped bus interface (795)
ETX_DISABLED            equ     8000h


;************************
; Defs for adapter_flags1
;************************
;;;TX_PHY_RX_VIRT       equ     0001h   ;;;#### No Longer used - Reserved
					; See TX_PHY... below
SCRAMBLE                equ     0001h   ;set scramble in EPIC Phy for Baystack problem
NEEDS_HOST_RAM         equ     0002h
NEEDS_MEDIA_TYPE       equ     0004h
EARLY_RX_DONE          equ     0008h
PNP_BOOT_BIT           equ     0010h    ; activates PnP & config on power-up
					; clear => regular PnP operation
PNP_ENABLE             equ     0020h    ; regular PnP operation
					; clear=>no PnP, overrides PNP_BOOT_BIT
SATURN_ENABLE          equ     0040h

ADAPTER_REMOVABLE      equ     0080h    ; adapter is hot swappable

TX_PHY                 equ     0100h    ; Uses physical address for tx bufs
RX_PHY                 equ     0200h    ; Uses physical address for rx bufs
TX_VIRT                equ     0400h    ; Uses virtual address for tx bufs
RX_VIRT                equ     0800h    ; Uses virtual address for rx bufs
NEEDS_SERVICE          equ     1000h    ; Request that LM_Service_Events call
					; BroadcomBugFix for the 9332BVT.
PCMCIA_LAN_IRQ         equ     2000h    ; BTM, set if LAN func generated INT
PCMCIA_MODEM_IRQ       equ     4000h    ; BTM, set if Modem func generated INT */
READ_MULT               equ     8000h   ; set to tell LMAC to enable Mem Read Multiple

;**********************
; ADAPTER STATUS CODES
;**********************

OPEN                    equ     0001h
INITIALIZED             equ     0002h
CLOSED                  equ     0003h
FAILED                  equ     0005h
NOT_INITIALIZED         equ     0006h
IO_CONFLICT             equ     0007h
CARD_REMOVED            equ     0008h
CARD_INSERTED           equ     0009h

;**********************
; MODE BIT DEFINITIONS
;**********************

INTERRUPT_STATUS_BIT    equ     8000h   ; PC Interrupt Line: 0 = Not Enabled
BOOT_STATUS_MASK        equ     6000h   ; Mask to isolate BOOT_STATUS
BOOT_INHIBIT            equ     0000h   ; BOOT_STATUS is 'inhibited'
BOOT_TYPE_1             equ     2000h   ; Unused BOOT_STATUS value
BOOT_TYPE_2             equ     4000h   ; Unused BOOT_STATUS value
BOOT_TYPE_3             equ     6000h   ; Unused BOOT_STATUS value
ZERO_WAIT_STATE_MASK    equ     1800h   ; Mask to isolate Wait State flags
ZERO_WAIT_STATE_8_BIT   equ     1000h   ; 0 = Disabled (Inserts Wait States)
ZERO_WAIT_STATE_16_BIT  equ     0800h   ; 0 = Disabled (Inserts Wait States)
LOOPING_MODE_MASK       equ     0007h
LOOPBACK_MODE_0         equ     0000h
LOOPBACK_MODE_1         equ     0001h
LOOPBACK_MODE_2         equ     0002h
LOOPBACK_MODE_3         equ     0003h
LOOPBACK_MODE_4         equ     0004h
LOOPBACK_MODE_5         equ     0005h
LOOPBACK_MODE_6         equ     0006h
LOOPBACK_MODE_7         equ     0007h
AUTO_MEDIA_DETECT       equ     0008h   ; Auto detect the media connection
MANUAL_CRC              equ     0010h
EARLY_TOKEN_REL         equ     0020h   ; Early Token Release for Token Ring
NDIS_UMAC               equ     0040h   ; Indicates to LMAC that UMAC is NDIS.
UTP2_PORT               equ     0080h   ; For 8216T2, 0=port A, 1=Port B.
BNC_10BT_INTERFACE      equ     0600h   ; BNC and UTP current media set
UTP_INTERFACE           equ     0500h   ; Ethernet UTP Only.
BNC_INTERFACE           equ     0400h   ; net defs for adv. feature adapters
AUI_INTERFACE           equ     0300h   
AUI_10BT_INTERFACE      equ     0200h   
STARLAN_10_INTERFACE    equ     0100h   
INTERFACE_TYPE_MASK     equ     0700h   ; Mask value for interface type

;****************************************************************************
; Definitions for the field:
; media_type
; TP = Twisted Pair
; STP = Shielded twisted pair
; UTP = Unshielded twisted pair

CNFG_MEDIA_TYPE_MASK    equ     03h     ; bits 0-1

MEDIA_S10               equ     00000h  ; Ethernet adapter, TP.
MEDIA_AUI_UTP           equ     00001h  ; Ethernet adapter, AUI/UTP media.
MEDIA_BNC               equ     00002h  ; Ethernet adapter, BNC media.
MEDIA_AUI               equ     00003h  ; Ethernet adapter, AUI media.
MEDIA_STP_16            equ     00004h  ; TokenRing adap, 16Mbit STP.
MEDIA_STP_4             equ     00005h  ; TokenRing adap, 4Mbit STP.
MEDIA_UTP_16            equ     00006h  ; TokenRing adap, 16Mbit UTP.
MEDIA_UTP_4             equ     00007h  ; TokenRing adap, 4Mbit UTP.
MEDIA_UTP               equ     00008h  ; Ethernet adapter, UTP media (no AUI).
MEDIA_BNC_UTP          equ     00010h  ; Ethernet adapter, BNC/UTP media 
MEDIA_UTPFD            equ     00011h  ; Ethernet adapter, TP and full duplex.
MEDIA_UTPNL            equ     00012h  ; Ethernet adapter, TP w/o link integrity test.
MEDIA_AUI_BNC          equ     00013h  ; Ethernet adapter, AUI/BNC .
MEDIA_AUI_BNC_UTP      equ     00014h  ; Ethernet adapter, AUI/BNC/UTP.
MEDIA_UTPA             equ     00015h  ; Ethernet UTP-10Mbps Ports A
MEDIA_UTPB             equ     00016h  ; Ethernet UTP-10Mbps Ports B
MEDIA_STP_16_UTP_16    equ     00017h  ; Token Ring STP-16Mbps/UTP-16Mbps
MEDIA_STP_4_UTP_4      equ     00018h  ; Token Ring STP-4Mbps/UTP-4Mbps                

MEDIA_STP100_UTP100    equ     00020h  ; Ethernet STP-100Mbps/UTP-100Mbps
MEDIA_UTP100FD         equ     00021h  ; Ethernet UTP-100Mbps, full duplex */
MEDIA_UTP100           equ     00022h  ; Ethernet UTP-100Mbps */
	
MEDIA_UNKNOWN           equ     0FFFFh  ; Unknown adapter/media type

;****************************************************************************
; Definitions for the field:
; media_type2
MEDIA_TYPE_MII                  equ     1
MEDIA_TYPE_UTP                  equ     2
MEDIA_TYPE_BNC                  equ    0004h
MEDIA_TYPE_AUI                  equ    0008h
MEDIA_TYPE_S10                  equ    0010h
MEDIA_TYPE_AUTO_SENSE           equ     1000h
MEDIA_TYPE_AUTO_NEGOTIATE       equ     8000h
MEDIA_TYPE_AUTO_DETECT          equ     4000h

;****************************************************************************
; Definitions for the field:
; line_speed
LINE_SPEED_UNKNOWN              equ     0
LINE_SPEED_4                    equ     1
LINE_SPEED_10                   equ     2
LINE_SPEED_16                   equ     4
LINE_SPEED_100                  equ     8
LINE_SPEED_T4                   equ     8  ; 100BaseT4 aliased for 9332BVT
LINE_SPEED_FULL_DUPLEX          equ     8000h

;****************************************************************************
; Definitions for the field:
; bic_type (Bus interface chip type)
;
BIC_NO_CHIP             equ     00000h  ; Bus interface chip not implemented
BIC_583_CHIP            equ     00001h  ; 83C583 bus interface chip
BIC_584_CHIP            equ     00002h  ; 83C584 bus interface chip
BIC_585_CHIP            equ     00003h  ; 83C585 bus interface chip
BIC_593_CHIP            equ     00004h  ; 83C593 bus interface chip
BIC_594_CHIP            equ     00005h  ; 83C594 bus interface chip
BIC_564_CHIP            equ     00006h  ; PCMCIA bus interface chip
BIC_790_CHIP            equ     00007h  ; 83C790 bus i-face/Ethernet NIC chip
BIC_571_CHIP            equ     00008h  ; 83C571 EISA bus master i-face
BIC_587_CHIP            equ     00009h  ; Token Ring AT Bus Master i-face chip
BIC_574_CHIP           equ     00010h  ; FEAST bus interface chip
BIC_8432_CHIP          equ     00011h  ; 8432 bus i-face/Ethernet NIC chip(DEC PCI)
BIC_9332_CHIP          equ     00012h  ; 9332 bus i-face/100 Mbps Ethernet NIC chip(DEC PCI)
BIC_8432E_CHIP         equ     00013h  ; 8432 Enhanced bus iface/Ethernet NIC(DEC)
BIC_EPIC100_CHIP        equ     00014h  ; EPIC/100 10/100 Mbps Ethernet BIC/NIC
BIC_C94_CHIP           equ     00015h  ; 91C94 bus i-face in PCMCIA mode
BIC_X8020_CHIP         equ     00016h  ; Xilinx PCMCIA multi-func i-face


;****************************************************************************
; Definitions for the field:
; nic_type (Bus interface chip type)
;
NIC_UNK_CHIP            equ     00000h  ; Unknown NIC chip
NIC_8390_CHIP           equ     00001h  ; DP8390 Ethernet NIC
NIC_690_CHIP            equ     00002h  ; 83C690 Ethernet NIC
NIC_825_CHIP            equ     00003h  ; 83C825 Token Ring NIC
;NIC_???_CHIP           equ     00004h  ; Not used
;NIC_???_CHIP           equ     00005h  ; Not used
;NIC_???_CHIP           equ     00006h  ; Not used
NIC_790_CHIP            equ     00007h  ; 83C790 bus i-face/Ethernet NIC chip
NIC_C100_CHIP          equ     00010h  ; FEAST 100Mbps Ethernet NIC
NIC_8432_CHIP          equ     00011h  ; 8432 bus i-face/Ethernet NIC(DEC PCI)
NIC_9332_CHIP          equ     00012h  ; 9332 bus i-face/100 Mbps Ethernet NIC(DEC PCI)
NIC_8432E_CHIP         equ     00013h  ; 8432 enhanced bus iface/Ethernet NIC(DEC) 
NIC_EPIC100_CHIP        equ     00014h  ; EPIC/100 10/100 Mbps Ethernet BIC/NIC
NIC_C94_CHIP           equ     00015h  ; 91C94 PC Card with multi func

;****************************************************************************
; Definitions for the field:
; adapter_type  The adapter_type field describes the adapter/bus
;               configuration.
;
BUS_UNK_TYPE            equ     00000h  ; 
BUS_ISA16_TYPE          equ     00001h  ; 16 bit adap in 16 bit (E)ISA slot
BUS_ISA8_TYPE           equ     00002h  ; 8/16b adap in 8 bit XT/(E)ISA slot
BUS_MCA_TYPE            equ     00003h  ; Micro Channel adapter
BUS_EISA32M_TYPE        equ     00004h  ; EISA 32 bit bus master adapter
BUS_EISA32S_TYPE        equ     00005h  ; EISA 32 bit bus slave adapter
BUS_PCMCIA_TYPE         equ     00006h  ; PCMCIA Bus
BUS_PCI_TYPE           equ     00007h  ; PCI bus

;***************************
; Receive Mask Definitions
;***************************

ACCEPT_MULTICAST                equ     0001h
ACCEPT_BROADCAST                equ     0002h
PROMISCUOUS_MODE                equ     0004h
ACCEPT_SOURCE_ROUTING           equ     0008h
ACCEPT_ERR_PACKETS              equ     0010h
ACCEPT_ATT_MAC_FRAMES           equ     0020h
ACCEPT_MULTI_PROM               equ     0040h   
TRANSMIT_ONLY                   equ     0080h
ACCEPT_EXT_MAC_FRAMES           equ     0100h
EARLY_RX_ENABLE                 equ     0200h
PKT_SIZE_NOT_NEEDED             equ     0400h
ACCEPT_SOURCE_ROUTING_SPANNING  equ     0808h
ACCEPT_ALL_MAC_FRAMES           equ     0120h
				   
;*******************************************
; config_mode defs
;*******************************************

STORE_EEROM             equ     00001h          ; Store config in EEROM.
STORE_REGS              equ     00002h          ; Store config in register set.

;****************************************************************************
; Definitions for the field:
; card_SSID (PCI Subsystem ID)
;****************************************************************************

SSID9332BDT     equ     02001h                  ; National PHY
SSID9332BVT     equ     02002h
SSID9334BDT     equ     02003h
;;SSID9332BDT     equ     02004h                ; Microlinear PHY
SSID8032DT      equ     02005h
SSSID8432BT     equ     02007h
SSID8432BTA     equ     02008h
SSID8432T       equ     02009h
SID1208T        equ     02011h                  ; Accton 10 Mbps
;;SSID9332BDT     equ     02401h                ; QSI 6611 PHY
SSID9432DMT     equ     0A010h
SSID9432TX      equ     0A011h
SSID9032TXM     equ     0A012h                  ; Eval Mercury Cardbus + Modem
SSID9032TX      equ     0A013h                  ; TDK PHY
SSID9432TXPWR   equ     0A014h                  ; 9432TX with power management
SSID9432BTX     equ     0A015h

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; equates for lmac_flags in adapter structure (Ethernet)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MEM_DISABLE     equ     0001h
RX_STATUS_POLL  equ     0002h
USE_RE_BIT      equ     0004h
;RESERVED       equ     0008h
;RESERVED       equ     0010h   
;RESERVED       equ     0020h
;RESERVED       equ     0040h
;RESERVED       equ     0080h
;RESERVED       equ     0100h
;RESERVED       equ     0200h
;RESERVED       equ     0400h
;RESERVED       equ     0800h
;RESERVED       equ     1000h
;RESERVED       equ     2000h
;RESERVED       equ     4000h
;RESERVED       equ     8000h


; media_opts & media_set Fields bit defs for Ethernet ...
MED_OPT_BNC     equ     01h
MED_OPT_UTP     equ     02h
MED_OPT_AUI     equ     04h
MED_OPT_10MB    equ     08h
MED_OPT_100MB   equ     10h
MED_OPT_S10     equ     20h

; unique media_opts & media_set Fields bit defs for Token Ring ...
MED_OPT_4MB     equ     08h
MED_OPT_16MB    equ     10h
MED_OPT_STP     equ     40h

;*******************************************
; PCMCIA definitions
;*******************************************

CS_SIG                          equ     05343h  ; ASCII 'CS' 
SMC_PCMCIA_ID                   equ     0108h   ; SMC ID Byte value.
IO_PORT_RANGE                   equ     0020h   ; Number of IO Ports.   
ENABLE_IRQ_STEER                equ     0002h   ; For ReqCfgStruct.ReqCfgAttributes
FIVE_VOLTS                      equ     50      ; For ReqCfgStruct.ReqCfgVcc, .Vpp1, .Vpp2
TWELVE_VOLTS                    equ     120     ; For ReqCfgStruct.ReqCfgVcc, .Vpp1, .Vpp2
MEM_AND_IO                      equ     0002h   ; For ReqCfgStruct.ReqCfgIntType
ATTRIBUTE_REG_OFFSET            equ     0001h   ; Hi word of offset of attribute registers
REG_COR_VALUE                   equ     0041h   ; Value for Config Option Register
REGS_PRESENT_VALUE              equ     000Fh   ; Value for ReqCfgStruct.ReqCfgPresent
LEVEL_IRQ                       equ     0020h   ; For ReqIrqStruct.IRQInfo1
IRQ_INFO2_VALID                 equ     0010h   ; For ReqIrqStruct.IRQInfo1
VALID_IRQS                      equ     8EBCh   ; For ReqIrqStruct.IRQInfo2
OFFSET_SHMEM_HI                 equ     0002h   ; Hi word of shared ram offset
OFFSET_SHMEM_LO                 equ     00000h  ; Lo word of shared ram offset
OFFSET_REGISTER_MEM             equ     0003h   ; Hi word of register memory offset (not used)
AMD_ID                          equ     0A701h  ; Mfg/Product ID for AMD flash ROM
ATMEL_ID                        equ     0D51Fh  ; Mfg/Product ID for ATMEL flash ROM
SHMEM_SIZE                      equ     4000h   ; Size of shared memory device.
SHMEM_NIC_OFFSET                equ     0100h   ; Offset of start of shared memory space for NIC.
REG_OFFSET                      equ     0000h   ; Offset of PCM card's mem-mapped register set.

MAX_8023_SIZE                   equ     1500    ; Max 802.3 size of frame.
IFDEF TURBO
DEFAULT_ERX_VALUE               equ     01h     ; Number of 16-byte blocks for 790B early Rx.
DEFAULT_ETX_VALUE               equ     4       ; Number of bytes for 790B early Tx.
ELSE
DEFAULT_ERX_VALUE               equ     04h     ; Number of 16-byte blocks for 790B early Rx.
DEFAULT_ETX_VALUE               equ     32      ; Number of bytes for 790B early Tx.
ENDIF
DEFAULT_TX_RETRIES              equ     3       ; Number of transmit retries
LPBK_FRAME_SIZE                 equ     1024    ; Default loopback frame for Rx calibration test.
MAX_LOOKAHEAD_SIZE              equ     252     ; Max lookahead size for ethernet.

;*******************************************
; FEAST EISA 
;*******************************************
EISA_SLAVE_DMA_CUTOFF          equ     128    ; DMA threshold


IFDEF DEC_PCI
SATURN_BIT_MASK                 equ     00FDh
SATURN_CDC_CFID_VAL             equ     0483h
SATURN_PCMC_CFID_VAL            equ     04A3h
INTEL_VAL                       equ     8086h
SATURN_CPU_PCI_ENTRY            equ     0053h
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\stdio.asm ===
;--------------------------------------------------------------------
DisplayByte Proc near
; AL has byte to output to tty
;           
                    push    ax
                    mov     ah,0eh  ; write tty
                    int     10h     ; video - write tty            
                    pop     ax
DisplayByteExit:    ret
DisplayByte endp
;--------------------------------------------------------------------
Print   Proc near
;
; Prints a null terminated string to the console
;
; PARMAMETERS: ds:si - pointer to string
;     RETURNS: nothing
;    DESTROYS: nothing
;     ASSUMES: nothing
;
                push	ax
                push    si
printLoop:      mov     al,[si]
                inc     si
                and     al,al                   ; check for zero
        	je	printEnd
                call    DisplayByte
        	jmp	printLoop
printEnd:       pop     si
                pop	ax
	        ret
Print   endp
;--------------------------------------------------------------------
PrintDecimal Proc   near
;
; Prints a number to the console in decimal
;
; PARMAMETERS: AX - has the number (in binary) to print
;     RETURNS: nothing
;    DESTROYS: nothing
;     ASSUMES: nothing
;
	        pusha
        	xor	cx, cx          ; cx = 0
        	mov	dx, cx          ; dx = 0
        	mov	bx, 10          ; bx = 10
__loop1:        div	bx              ; ax/10
        	push	dx      	; save digit on stack
        	inc	cx		; inc digit counter
        	xor	dx, dx		; clear remainder
        	or	ax, ax		; check for more digits
        	jne	__loop1
__loop2:        pop	ax              ; get 1st item off stack
        	add	al, '0'         ; make ASCII
                call    DisplayByte
        	loop	__loop2         ; do for each digit on stack
        	popa
	        ret
PrintDecimal    endp
;--------------------------------------------------------------------
PrintHexDword   Proc    near
                push    eax
                shr     eax,16      ; print high word 1st
                call    PrintHexWord
                pop     eax
                call    PrintHexWord
                ret
PrintHexDword   endp
;--------------------------------------------------------------------
PrintHexWord    Proc near
;
; Prints a number to the console in hex
;
; PARMAMETERS: AX - has the number (in binary) to print
;     RETURNS: nothing
;    DESTROYS: nothing
;     ASSUMES: nothing
;
                push    ax
                push    bx
        	mov	bx, ax
        	mov	al, bh
        	call	PrintHexByte
	        mov	al, bl
        	call	PrintHexByte
                pop     bx
                pop     ax
	        ret
PrintHexWord    endp
;--------------------------------------------------------------------
PrintHexByte   Proc    near
;	AL - number to print
; PARMAMETERS: AL has the number (in binary) to print
;     RETURNS: nothing
;    DESTROYS: nothing
;     ASSUMES: nothing
;
        	push	ax			; save word
        	rol	al, 4
	        call	HexDigit
        	pop	ax
hexDigit:      	push	ax
        	and	al, 00001111b
	        add	al, 90h
        	daa
        	adc	al, 40h
        	daa
                call    DisplayByte
        	pop	ax
        	ret
PrintHexByte    endp
;--------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\clearacl\clearacl.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>


int _cdecl
main(int argc, char * argv[])
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    WCHAR unicodeName[MAX_PATH];
    UCHAR SecurityDescriptorBuffer[512];
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    ULONG lengthNeeded;
    HANDLE fileHandle;

    if (argc < 2) {
        printf("usage: %s file\n", argv[0]);
        return -1;
    }

    mbstowcs(unicodeName, argv[1], strlen(argv[1]) + 1);

    RtlDosPathNameToNtPathName_U(
        unicodeName,
        &nameString,
        NULL,
        NULL);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = NtOpenFile(
                 &fileHandle,
                 READ_CONTROL | WRITE_DAC,
                 &objectAttributes,
                 &ioStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 0);

    if (!NT_SUCCESS(status) || !NT_SUCCESS(ioStatusBlock.Status)) {
        printf("%s: NtOpenFile on %wZ failed %lx %lx\n", argv[0], &nameString, status, ioStatusBlock.Status);
        return -1;
    }

    //
    // Now read the DACL from the server file.
    //

    status = NtQuerySecurityObject(
                 fileHandle,
                 DACL_SECURITY_INFORMATION,
                 (PSECURITY_DESCRIPTOR)SecurityDescriptorBuffer,
                 sizeof(SecurityDescriptorBuffer),
                 &lengthNeeded);

    if (!NT_SUCCESS(status)) {
        printf("%s: NtQuerySecurityObject on %wZ failed %lx %lx\n", argv[0], &nameString, status, lengthNeeded);
        return -1;
    }

#if 0
    status = RtlSetDaclSecurityDescriptor(
                 (PSECURITY_DESCRIPTOR)SecurityDescriptorBuffer,
                 FALSE,
                 NULL,
                 FALSE);

    if (!NT_SUCCESS(status)) {
        printf("%s: RtlSetDaclSecurityDescriptor on %wZ failed %lx\n", argv[0], &nameString, status);
        return -1;
    }
#else
    ((PISECURITY_DESCRIPTOR)SecurityDescriptorBuffer)->Control &= ~SE_DACL_PRESENT;
#endif

    status = NtSetSecurityObject(
                 fileHandle,
                 DACL_SECURITY_INFORMATION,
                 (PSECURITY_DESCRIPTOR)SecurityDescriptorBuffer);

    if (!NT_SUCCESS(status)) {
        printf("%s: NtSetSecurityObject on %wZ failed %lx %lx\n", argv[0], &nameString, status);
        return -1;
    }

    printf("%s: DACL successfully cleared on %wZ\n", argv[0], &nameString);

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\lm9432cf.asm ===
;----------------------------------------------------------------------------
;
;$History: LM9432CF.ASM $
; 
; *****************  Version 1  *****************
; User: Paul Cowan   Date: 26/08/98   Time: 9:31a
; Created in $/Client Boot/NICS/SMC/9432/UNDI
;
;
;$NoKeywords: $
;
;----------------------------------------------------------------------------

;****************************************************************************
;****************************************************************************
;*                                                                          *
;*          LM9432CF.ASM -  Get Config for LM 9432 driver  *
;*                                                                          *
;*          Copyright (C) 1995 Standard MicroSystems Corporation            *
;*                        All Rights Reserved.                              *
;*                                                                          *
;*                Contains confidential information and                     *
;*                     trade secrets proprietary to:                        *
;*                                                                          *
;*                  Standard MicroSystems Corporation                       *
;*                            6 Hughes	  
;*                           Irvine, CA                                     *
;*                                                                          *
;*                                                                          *
;****************************************************************************
;*                                                                          
;* History Log:                                                             
;*
;* Standard Microsystem LMAC Get Config module.
;*
;* Written by:     najay
;* Date:           2/14/95
;*
;* By         Date     Ver.   Modification Description
;* ------------------- -----  --------------------------------------
;*                                       
;****************************************************************************

;****************************************************************************
;
; Function:     LM_GetCnfg
;
; Synopis:      Find an adapter 
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************


ASM_PCI_PROC    LM_GetCnfg
	push	edx
	push	ecx
	push	ebx
	push	di
	push	si

; make sure the upper thinks we are pci
	cmp	pAS.pc_bus, PCI_BUS
	jne	pci_cnfg_fail

; check for a pci bios 
	mov	ah, PCI_FUNCTION_ID
	mov	al, PCI_BIOS_PRESENT

	call	UM_Card_Services
	jc	pci_cnfg_fail

IFDEF CODE_386
	cmp	dx, 'CP'
ELSE
	cmp	edx, ' ICP'		; 'PCI ' backwards
ENDIF
	jne	pci_cnfg_fail

; find the adapter 
	mov	ah, PCI_FUNCTION_ID
	mov	al, FIND_PCI_DEVICE
	mov	cx, EPC_ID_EPIC_100
	mov	dx, EPC_ID_SMC
	movzx	si, pAS.slot_num
	sub	si, 16			; follow dec's convention for
	call	UM_Card_Services	; PCI slot numbering
        jnc     pci_adapter_found

; check for 9032
	mov	ah, PCI_FUNCTION_ID
	mov	al, FIND_PCI_DEVICE
        mov     cx, EPC_ID_EPIC_C
	call	UM_Card_Services	
	jc	pci_cnfg_fail
pci_adapter_found:
	
; save card specific info 
	mov	pAS.busnumber, bh
	mov	pAS.vslotnumber, bl
	
; get irq value 
	mov	ah, PCI_FUNCTION_ID
	mov	al, PCI_READ_CONFIG_BYTE
	mov	di, EPC_INT_LINE 
	call	UM_Card_Services
	jc	pci_cnfg_fail

	mov 	byte ptr  pAS.irq_value, cl	

; enable memory mapped config registers 
	mov	ah, PCI_FUNCTION_ID
	mov	al, PCI_WRITE_CONFIG_WORD
	mov	di, EPC_PCI_COMMAND
	mov	cx, PCIC_MEM_SPACE_ENABLE + PCIC_BUSMASTER_ENABLE + PCIC_IO_SPACE_ENABLE
	call	UM_Card_Services
	jc	pci_cnfg_fail

; get address of pci registers
	mov	ah, PCI_FUNCTION_ID
	mov	al, PCI_READ_CONFIG_DWORD
	mov	di, EPC_MEM_ADDR
	call	UM_Card_Services
	jc	pci_cnfg_fail

	mov	pAS.ram_base, ecx

; get iobase of pci registers
	mov	ah, PCI_FUNCTION_ID
	mov	al, PCI_READ_CONFIG_DWORD
	mov	di, EPC_IO_ADDR
	call	UM_Card_Services
	jc	pci_cnfg_fail

	and	ecx, IO_BASE_ADDR
	mov	pAS.io_base, cx

; get subsystem ID
	mov	ah, PCI_FUNCTION_ID
	mov	al, PCI_READ_CONFIG_WORD
	mov	di, EPC_SYSTEM_ID
	call	UM_Card_Services
	jc	pci_cnfg_fail

	mov	pAS.card_SSID, cx

; copy name into adapter area
	lea	rdi, pAS.adapter_name
	mov	dx, (EPC_EEPROM_SW_OFFSET + EPM_NAME) SHR 1 ; address of adapter name
	mov	cx, 6				; number of words in name

pci_cnfg_an_loop:
	call	eeprom_read
	xchg	al, ah
	mov	pDST, ax
	add	rdi, 2
	inc	dx
	loop	pci_cnfg_an_loop	
	dec	rdi
	mov	byte ptr pDST, 0

; set adapter_flags
	or	pAS.adapter_flags, RX_VALID_LOOKAHEAD
	or	pAS.adapter_flags1, NEEDS_MEDIA_TYPE + TX_PHY +	RX_PHY + NEEDS_HOST_RAM

; set media type
	mov	dx, (EPC_EEPROM_SW_OFFSET + EPM_MEDIA_TYPE2) SHR 1 ; address of media_type2
        call    eeprom_read
        mov     pAS.media_type2, ax
        inc     dx
        call    eeprom_read
        mov     pAS.line_speed, ax

; autodetect stuff moved to LM_Initialize_Adapter in init_mii_registers
; autodetect stuff would go here
;	mov	pAS.media_type, MEDIA_STP100_UTP100

pci_media_type_set:

; set adapter bus
	mov	pAS.bic_type, BIC_EPIC100_CHIP
	mov	pAS.nic_type, NIC_EPIC100_CHIP
	mov	pAS.adapter_bus, BUS_PCI_TYPE
	mov     rax, ADAPTER_AND_CONFIG

pci_cnfg_done:
	pop	si
	pop	di
	pop	ebx
	pop	ecx
	pop	edx
	ret

pci_cnfg_fail:
	mov	rax, ADAPTER_NOT_FOUND	
	jmp	short pci_cnfg_done

ASM_PCI_PROC_END LM_GetCnfg

;****************************************************************************
;
; Function:     eeprom_read
;
; Synopis:      fetches a word from the eeprom
;
; Input:        ds:bp (ebp)	AdapterStructure
; 		dx		address
;
; Output:       ax 		word fetched
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    eeprom_read

; set chip select
	mov	al, EEC_ENABLE or EEC_CHIP_SELECT
	call	eeprom_register_write

; send read command and address
	call	eeprom_register_read
	test	al, EEC_SIZE
	mov	ax, dx
	jz	eepr_128k
	and	ax, 03fh
	or	ax, 180h
	jmp	eepr_write

eepr_128k:
	and	ax, 0ffh
	or	ax, 600h

eepr_write:
	call	eeprom_output_word

; read data
	call	eeprom_input_word
	xchg	al, ah

; clear chip select
	push	ax
	mov	al, EEC_ENABLE
	call	eeprom_register_write
	pop	ax

	ret

ASM_PCI_PROC_END eeprom_read


;****************************************************************************
;
; Function:     eeprom_input_word
;
; Synopis:      fetches a word from the eeprom
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax 		word fetched
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    eeprom_input_word
	push	cx
	push	bx

	mov	cx, 16
	mov	bx, 0

eep_iw_loop:
	mov	al, EEC_ENABLE or EEC_CHIP_SELECT
	call	eeprom_clock

	shl	bx, 1
	test	al, EEC_DATAOUT
	jz	eep_iw_data0
	inc	bx

eep_iw_data0:
	loop	eep_iw_loop

	mov	ax, bx
	pop	bx
	pop	cx
	ret

ASM_PCI_PROC_END eeprom_input_word

;****************************************************************************
;
; Function:     eeprom_output_word
;
; Synopis:      fetches a word from the eeprom
;
; Input:        ds:bp (ebp)	AdapterStructure
; 		ax		address
;
; Output:       ax 		word fetched
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    eeprom_output_word
	push	cx
	push	bx

	mov	cx, 16
	mov	bx, ax

eep_ow_loop:
	rol	bx, 1
	mov	al, EEC_ENABLE or EEC_CHIP_SELECT
	jnc	eep_ow_data0
	or	al, EEC_DATAIN

eep_ow_data0:
	call	eeprom_clock
	loop	eep_ow_loop

	mov	ax, bx
	pop	bx
	pop	cx
	ret

ASM_PCI_PROC_END eeprom_output_word

;****************************************************************************
;
; Function:     eeprom_clock
;
; Synopis:      fetches a word from the eeprom
;
; Input:        ds:bp (ebp)	AdapterStructure
; 		ax		address
;
; Output:       ax 		word fetched
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    eeprom_clock

; write register with clock low
	call	eeprom_register_write

; write register with clock high
	push	ax
	or	al, EEC_CLOCK
	call	eeprom_register_write
	pop	ax

; write register with clock low
	call	eeprom_register_write

	call	eeprom_register_read
	ret

ASM_PCI_PROC_END eeprom_clock

;****************************************************************************
;
; Function:     eeprom_register_write
;
; Synopis:      outputs a bte to EEPROM and waits for data valid
;
; Input:        ds:bp (ebp)	AdapterStructure
; 		al		byte to write
;
; Output:       None
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    eeprom_register_write
	push	dx
	push	cx
	push	ax

	mov	dx, pAS.io_base
	add	dx, EPC_EEPROM_CONTROL
	out	dx, al

; wait for eeprom ready
	mov	cx, 0fffh

eep_rw_loop:
	in	al, dx
	and	al, EEC_READY
	loopz	eep_rw_loop

	pop	ax
	pop	cx
	pop	dx
	ret

ASM_PCI_PROC_END eeprom_register_write

;****************************************************************************
;
; Function:     eeprom_register_read
;
; Synopis:      inputs a byte from the eeprom
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       al 		byte fetched
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    eeprom_register_read
	push	dx

	mov	dx, pAS.io_base
	add	dx, EPC_EEPROM_CONTROL
	in	al, dx

	pop	dx
	ret

ASM_PCI_PROC_END eeprom_register_read
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\cleanri\cleanri.c ===
/*
   This is cleanri
 */
#include <windows.h>
#include <winldap.h>
#include <dsgetdc.h>
#define SECURITY_WIN32
#include <security.h>
#include "resource.h"

HINSTANCE g_hInstance = NULL;

#ifdef DBG
#define DebugOut OutputDebugString
#else
#define DebugOut 1 ? (void)0 : (void) 
#endif

#define ARRAYSIZE( array ) sizeof( array ) / sizeof(( array )[ 0 ] )

//
// Ldap_InitializeConnection( )
//
DWORD
Ldap_InitializeConnection(
    PLDAP  * LdapHandle )
{
    PLDAPMessage OperationalAttributeLdapMessage;
    PLDAPMessage CurrentEntry;

    DWORD LdapError = LDAP_SUCCESS;

    if ( !( *LdapHandle ) ) {
        ULONG temp = DS_DIRECTORY_SERVICE_REQUIRED |
                     DS_IP_REQUIRED |
                     DS_GC_SERVER_REQUIRED;

        DebugOut( L"Initializing LDAP connection.\n" );

        *LdapHandle = ldap_init( NULL, LDAP_PORT);

        if ( !*LdapHandle ) 
        {
            DebugOut( L"ldap_init() failed.\n" );
            LdapError = LDAP_UNAVAILABLE;
            goto e0;
        }

        ldap_set_option( *LdapHandle, LDAP_OPT_GETDSNAME_FLAGS, &temp );

        temp = LDAP_VERSION3;
        ldap_set_option( *LdapHandle, LDAP_OPT_VERSION, &temp );

        LdapError = ldap_connect( *LdapHandle, 0 );
        if ( LdapError != LDAP_SUCCESS )
        {
            DebugOut( L"ldap_connect() failed.\n" );
            goto e1;
        }

        LdapError = ldap_bind_s( *LdapHandle, NULL, NULL, LDAP_AUTH_SSPI );
        if ( LdapError != LDAP_SUCCESS ) 
        {
            DebugOut( L"ldap_bind_s() failed.\n" );
            goto e1;
        }
    }

    DebugOut( L"LDAP initialization succeeded.\n" );

e0:
    return LdapError;

e1:
    ldap_unbind( *LdapHandle );
    *LdapHandle = NULL;
    goto e0;
}

void
ErrorMessage( 
    ULONG LdapError )
{
    WCHAR szTmp[ 512 ];
    WCHAR szText[ 512 ];
    WCHAR szTitle[ 64 ];

    LoadString( g_hInstance, IDS_UNABLE_TITLE, szTitle, ARRAYSIZE(szTitle) );
    LoadString( g_hInstance, IDS_UNABLE_TEXT, szTmp, ARRAYSIZE(szTmp) );

    wsprintf( szText, szTmp, LdapError );

    MessageBox( NULL, szText, szTitle, MB_OK );
}

//
// WinMain()
//
int APIENTRY
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    LPWSTR pszDN = NULL;
    LPWSTR *ppszDN = NULL;
    PLDAP  LdapHandle = NULL;
    PLDAPMessage LdapMessage = NULL;
    int iErr = -1;

    ULONG  nSize;
    ULONG  LdapError;
    LPWSTR pszAttributes[ 2 ];
    DWORD  dwCount;
    PLDAPMessage LdapCurrent;

    g_hInstance = hInstance;

    if ( !GetComputerObjectName( NameFullyQualifiedDN, NULL, &nSize ) )
    {
        DebugOut( L"GetComputerObjectName() failed.\n" );
        iErr = -2;
        goto Cleanup;
    }
    DebugOut( L"Got GetComputerObjectName() nSize.\n" );

    pszDN = (LPWSTR) LocalAlloc( LMEM_FIXED, nSize * sizeof(WCHAR) );
    if ( !pszDN )
    {
        DebugOut( L"Out of memory.\n" );
        iErr = -3;
        goto Cleanup;
    }
    DebugOut( L"Allocated memory.\n" );

    if ( !GetComputerObjectName( NameFullyQualifiedDN, pszDN, &nSize ) )
    {
        DebugOut( L"GetComputerObjectName() failed.\n" );
        iErr = -4;
        goto Cleanup;
    }
    DebugOut( L"Got GetComputerObjectName().\n" );
    DebugOut( L"Computer DN: " );
    DebugOut( pszDN );
    DebugOut( L"\n" );

    if ( Ldap_InitializeConnection( &LdapHandle ) )
    {
        DebugOut( L"Ldap failed to initialize.\n" );
        iErr = -5;
        goto Cleanup;
    }
    DebugOut( L"Ldap initialized.\n" );

    pszAttributes[0] = L"netbootSCPBL";
    pszAttributes[1] = NULL;

TrySearchAgain:
    LdapError = ldap_search_ext_s( LdapHandle,
                                   pszDN,
                                   LDAP_SCOPE_BASE,
                                   L"objectClass=Computer",
                                   pszAttributes,
                                   FALSE,
                                   NULL,
                                   NULL,
                                   NULL,
                                   0,
                                   &LdapMessage );
    switch( LdapError )
    {
    case LDAP_SUCCESS:
        break;

    case LDAP_BUSY:
    case LDAP_TIMEOUT:
        DebugOut( L"ldap_search_ext_s() failed. Trying again.\n" );
        goto TrySearchAgain;

    default:
        DebugOut( L"ldap_search_ext_s() failed. Displaying pop-up.\n" );
        ErrorMessage( LdapError );
        iErr = -6;
        goto Cleanup;
    }
    DebugOut( L"ldap_search_ext_s() succeeded.\n" );

    dwCount = ldap_count_entries( LdapHandle, LdapMessage );
    if ( dwCount == 0 )
    {
        DebugOut( L"ldap_search_ext_s() returned a count of zero. Nothing to do.\n" );
        iErr = -7;
        goto Cleanup; // NOP
    }
    DebugOut( L"ldap_search_ext_s() found an SCP.\n" );

    LdapCurrent = ldap_first_entry( LdapHandle, LdapMessage );
    if ( !LdapCurrent )
    {
        DebugOut( L"Couldn't retrieve the first entry. Aborting...\n" );
        iErr = -8;
        goto Cleanup;
    }

    ppszDN = ldap_get_values( LdapHandle, LdapCurrent, L"netbootSCPBL");
    if ( !ppszDN )
    {
        DebugOut( L"No DN to SCP. How did we did we get here then?\n" );
        iErr = -9;
        goto Cleanup;
    }
    DebugOut( L"SCP DN: " );
    DebugOut( *ppszDN );
    DebugOut( L"\n" );

TryDeleteAgain:
    LdapError = ldap_delete_s( LdapHandle, *ppszDN );
    switch ( LdapError )
    {
    case LDAP_SUCCESS:
        break;

    case LDAP_BUSY:
    case LDAP_TIMEOUT:
        DebugOut( L"ldap_delete_s() failed. Trying again.\n" );
        goto TryDeleteAgain;

    default:
        {
            LPWSTR pszExtendedError;
            DebugOut( L"ldap_delete_s() failed. Displaying pop-up.\n" );

            ldap_get_option(LdapHandle, LDAP_OPT_SERVER_ERROR, (void *) &pszExtendedError);
            DebugOut( L"Extended Error: " );
            DebugOut( pszExtendedError );
            DebugOut( L"\n" );

            ErrorMessage( LdapError );
            iErr = -9;
            goto Cleanup;
        }
    }

    DebugOut( L"SCP deletion succeeded.\n" );
    iErr = ERROR_SUCCESS;

Cleanup:
    DebugOut( L"Cleaning up...\n" );
    if ( ppszDN )
        ldap_value_free( ppszDN );

    if ( LdapMessage )
        ldap_msgfree( LdapMessage );

    if ( LdapHandle )
        ldap_unbind( LdapHandle );

    if ( pszDN )
        LocalFree( pszDN );

    return iErr;
}

// stolen from the CRT, used to shrink our working set
int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPSTR pszCmdLine = GetCommandLineA();


    if ( *pszCmdLine == '\"' )
    {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else
    {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' '))
    {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never come here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\cleanri\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cleanri.rc
//
#define IDS_UNABLE_TITLE                1
#define IDS_UNABLE_TEXT                 2

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\makefile.inc ===
_TAR=obj\$(TARGET_DIRECTORY)
_SRC=..



make_data:$(_TAR)\ristndrd.sif \
          $(_TAR)\rinorprt.sif
          

!IFDEF BINPLACE_CMD
MYBINPLACE_CMD=$(BINPLACE_CMD)
!ENDIF

!IFDEF PERSONALFILES
!IFDEF BINPLACE_CMD
MYBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b perinf)
!ENDIF
!ENDIF

!IFDEF SERVERFILES
!IFDEF BINPLACE_CMD
MYBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b srvinf)
!ENDIF
!ENDIF

!IFDEF ENTERPRISEFILES
!IFDEF BINPLACE_CMD
MYBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b entinf)
!ENDIF
!ENDIF

!IFDEF DATACENTERFILES
!IFDEF BINPLACE_CMD
MYBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b dtcinf)
!ENDIF
!ENDIF


$(_TAR)\ristndrd.sif: $(_SRC)\ristndrd.sif
        prodfilt $(_SRC)\ristndrd.sif $@ +$(PRODSWITCH)
        $(MYBINPLACE_CMD)

$(_TAR)\rinorprt.sif: $(_SRC)\rinorprt.sif
        prodfilt $(_SRC)\rinorprt.sif $@ +$(PRODSWITCH)
        $(MYBINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\undi_nad.asm ===
page	,132
;************************************************************************
;*  UNDI_NAD.ASM :-							*
;*  Universal NIC Driver Interface (UNDI) for Bootware's NAD            *
;*									*
;*  (C) Lanworks Technologies Inc. 1997.  All rights reserved.		*
;*									*
;*  Revision history:-							*
;*  970624  0.10  RL	- Init version for NetPC Spec v1.0b		*
;*  970508  0.00  RL	- Init version for NetPC Spec v0.9		*
;*  980504        JL    - Revised for making our UNDI's for Goliath     *
;************************************************************************
;------------------------------------------------------------------------------
;                       DEBUG       CONSTANTS
;------------------------------------------------------------------------------
_NOP        EQU     090h        ; define a NOP to put in BREAK definition
DEBUG_BREAK EQU     0CCh        ; int 3 for TurboDebug and Debug
ARIUM_BREAK EQU     0F1h        ; 0F1h for Arium breakpoint
;
;BREAK EQU   db ARIUM_BREAK     ; change this for your breakpoint opcodes
;BREAK EQU DB DEBUG_BREAK
BREAK EQU DB _NOP

;_DEBUG      equ 1       ; makes linked in code start at 1000H
;_VERBOSE    equ 1       ; makes progress messages show up
;------------------------------------------------------------------------------

LSA_MAJOR	equ	0           ; Version #'s
LSA_MINOR	equ	99

.xlist

MTU		equ	1514	;max size for a completed Ethernet packet
NUM_ED		equ	5	;number of EDs

TYPE_UCAST	equ	0
TYPE_BCAST	equ	1
TYPE_MCAST	equ	2

include 	undi_equ.inc
include 	pxe_stru.inc
include 	bwstruct.inc
include 	pci.inc
include 	pcinic.inc
include 	spdosegs.inc

extern	NADInit:near
extern	NADReset:near
extern	NADShutDown:near
extern	NADOpen:near
extern	NADClose:near
extern	NADTransmitPacket:near
extern	NADSetFilter:near
extern	NADGetStatistics:near
extern	NADMCastChange:near
extern	DriverISR_Proc:near
extern  NADSetMACAddress:near       ; * NEW
extern  NADInitiateDiags:near       ; * NEW

extern  OrgIntVector_Off:WORD
extern  OrgIntVector_Seg:WORD

public	IOBase              ; NIC's I/O base address (WORD)
public	ROMBase
public	PCIBusDevFunc
public  VendorId            ; filled in at runtime by this code
public  DeviceId            ; filled in at runtime by this code
public  SimulateInterrupts  ; lower level code will set this if hardware
                            ; ints are NOT used
public  NicIntsEnabled      ; lower level code should set & clr this to reflect
                            ; when hardware ints on the nic are enabled
public  Print               ; prints string pointed to by DS:SI
public  DisplayByte         ; prints byte in AL
public  PrintDecimal        ; prints value in AX as decimal
public  PrintHexWord        ; prints value in AX as hexadecimal
public  PrintHexByte        ; prints value in AL as hexadecimal

public	GetED
public	PostED
public	Net_Address         ; the changeable NIC address for this card
public	Node_Address        ; the permanent NIC address for this card
public	BusType
public	IRQNumber
public	RecFilter
public	UNDI_DriverISR
public	MultiCast_Addresses
public	EDListHead
public	EDListTail
public	EDListCurrent

.list
;******************************************************************************
_TEXT		Segment para public
	assume	cs:CGroup, ds:DGroup
;==========================================================================
; PXENV_UNDI_API:
;=================
;
; Entry:	BX contains function number
;		ES:DI contains parameter block
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error,
;		all other registers are preserved.
;==========================================================================
	public	PXENV_UNDI_API			; must always be at offset 0
.386
PXENV_UNDI_API	proc	far
                nop
                BREAK           ; defined at top of file
		push	ebp
		push	ebx
		push	ecx
		push	edx
		push	edi
		push	esi
		push	ds
		push	es
		push	fs
;
		cmp	bx, 1
		jb	API_Bad
		je	call_function

		cmp	bx, UNDI_APIMaxFunc
		ja	API_Bad

;  assumed startup is over and dataseg is valid
        	mov 	ax, cs:ApiEntry.mlid_ds_sel
	        mov 	ds, ax
call_function:
;
; TIP - code to print function # that is being called in UNDI
;       Put this code (and the code right after the call) back in if you
;       want to see when the UNDI code is entered and exited while you're
;       in the debugging stages.
;
;;  push    si
;;  push    ax
;;  mov     ax,bx
;;  call    PrintHexWord            ; print UNDI function # called
;;  pop     ax
;;  mov     si,offset msg_Entry     ; print "Entering UNDI"
;;  call    Print
;;  mov     si,offset msg_CRLF
;;  call    Print
;;  pop     si

		DEC	BX
	JZ	SKIPAHEAD	; skip if force interrupt
		NOP             ; Dimitry -> set BP here for other functions

SkipAhead:	shl	bx, 1                       ; * 2 for word table
		call	cs:NIC_Export_Table[bx]     ; near call
;
;              pushf                               ; save error status
;              push    si
 ;             mov     si,offset msg_Exit
;              call    Print                       ; print "Exiting UNDI"
;;              pop     si
;;              popf                                ; restore error status
;
		jc	API_err_ret
		xor	ax, ax
		jmp	API_Done
;
API_err_ret:	mov	ax, -1
		jmp	API_Err
API_Bad:	mov	ax, PXENV_STATUS_BAD_FUNC
API_Err:	stc
API_Done:	pop	fs
		pop	es
		pop	ds
		pop	esi
		pop	edi
		pop	edx
		pop	ecx
		pop	ebx
		pop	ebp
		ret
;
PXENV_UNDI_API	Endp
;------------------------------------------------------------------------------
Old_1A		dd	0	;address of previous int 1A ISR

	align	4
	public	NIC_Export_Table

NIC_Export_Table	label	word
		dw	OFFSET CGROUP:UNDI_StartUp
		dw	OFFSET CGROUP:UNDI_CleanUp
		dw	OFFSET CGROUP:UNDI_Initialize
		dw	OFFSET CGROUP:UNDI_ResetAdapter
		dw	OFFSET CGROUP:UNDI_ShutDown
		dw	OFFSET CGROUP:UNDI_OpenAdapter
		dw	OFFSET CGROUP:UNDI_CloseAdapter
		dw	OFFSET CGROUP:UNDI_Transmit
		dw	OFFSET CGROUP:UNDI_SetMCastAddr
		dw	OFFSET CGROUP:UNDI_SetStationAddress
		dw	OFFSET CGROUP:UNDI_SetPacketFilter
		dw	OFFSET CGROUP:UNDI_GetNICInfo
		dw	OFFSET CGROUP:UNDI_GetStatistics
		dw	OFFSET CGROUP:UNDI_ClearStatistics
		dw	OFFSET CGROUP:UNDI_InitDiags
		dw	OFFSET CGROUP:UNDI_ForceInterrupt
		dw	OFFSET CGROUP:UNDI_GetMCastAddr
		dw	OFFSET CGROUP:UNDI_GetNICType

UNDI_APIMaxFunc equ	($ - NIC_Export_Table)/2

;==========================================================================
; UNDI_StartUp
;==============
; Description:	Hooks INT 1AH and saves DataSeg, Dev_ID values
;
; Entry:	called from PXENV_UNDI_API for boot-rom.
;		ES:DI contains NIC_StartUp Pointer
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_StartUp	proc	 near
;
; set the physical address of the API entry structure
		xor	eax, eax
		mov	ax, cs
		shl	eax, 4
		add	eax, offset CGroup:ApiEntry
		mov	cs:ApiEntryPhyAddr, eax

	;; set local ds from es:di...
		mov	ds, (NIC_StartUp ptr es:[di]).S_DataSeg

; save the data segment selector and size in API Entry structure
		lea	bx, CGroup:ApiEntry

		mov	ax, (NIC_StartUp ptr es:[di]).S_DataSegSize
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).mlid_ds_size, ax
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).mlid_ds_sel, ds

		mov	ax, (NIC_StartUp ptr es:[di]).S_CodeSegSize
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).mlid_cs_size, ax
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).mlid_cs_sel, cs

		mov 	(s_PXENV_ENTRY ptr cs:[bx]).rm_entry_seg, cs
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).rm_entry_off, offset cs:PXENV_UNDI_API

		mov 	(s_PXENV_ENTRY ptr cs:[bx]).pm_entry_off, 0
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).pm_entry_base, 0

		mov 	(s_PXENV_ENTRY ptr cs:[bx]).stack_sel, 0
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).stack_size, 0

		mov 	(s_PXENV_ENTRY ptr cs:[bx]).base_cs_sel, 0
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).base_cs_size, 0

		mov 	(s_PXENV_ENTRY ptr cs:[bx]).base_ds_sel, 0
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).base_ds_size, 0

		mov	dword ptr (s_PXENV_ENTRY ptr cs:[bx]).signature, 4e455850h ; PXENV+
		mov	word ptr (s_PXENV_ENTRY ptr cs:[bx]).signature+4, 2b56h	   ; PXENV+

		mov 	(s_PXENV_ENTRY ptr cs:[bx]).ver, (LSA_MAJOR shl 8) or LSA_MINOR
		mov 	(s_PXENV_ENTRY ptr cs:[bx]).bytes, SIZE s_PXENV_ENTRY

		xor	al, al
		mov	(s_PXENV_ENTRY ptr cs:[bx]).checksum, al

		push	bx
		mov	cx, sizeof s_PXENV_ENTRY
@@:		add	al, cs:[bx]
		inc	bx
		loop	@B
		pop	bx

		sub	(s_PXENV_ENTRY ptr cs:[bx]).checksum, al

		mov	ax, word ptr (NIC_StartUp ptr es:[di]).S_BusDevFunc
		mov	DGroup:PCIBusDevFunc, ax

		mov	al, byte ptr (NIC_StartUp ptr es:[di]).S_BusType
		mov	BusType, al

; chain int 1Ah
		push	es
		push	bx

		xor	ax, ax
		mov	es, ax
		mov	bx, 1Ah * 4		; 1Ah * 4
		mov	eax, es:[bx]		; old ISR
		mov	dword ptr cs:Old_1A, eax
		mov	ax, cs
		shl	eax, 16
		lea	ax, cs:Int1A_ISR
		pushf
			cli
			mov	dword ptr es:[bx], eax
		popf
		POP	bx 	; JL patch
		pop	es
;
; take PCIBusDevFunc # and get DeviceID and VendorID values
;
; code to find out the DeviceId & VendorID from the BusDevFunc value
;
		push	di	; JRL
                mov     ax,0B101h   ; test PCI BIOS present
                int     1Ah
                jc      StartUpError    ; error for carry
                and     ah,ah
                jnz     StartUpError    ; error for AH != 0
                cmp     edx,020494350h  ;
                jne     StartUpError    ; error for bad PCI signature
;
                mov     ax,0B109h   ; read config word
                mov     bx,PCIBusDevFunc
                sub     di,di       ; read config reg 0000 - VendorID
                int     1Ah         ; do it
                jc      StartUpError ; error out
                and     ah,ah
                jnz     StartUpError    ; error for AH != 0

                mov     VendorID,cx ; put it in
;
                mov     ax,0B109h   ; read config word
                mov     bx,PCIBusDevFunc
                mov     di,2        ; read config reg 0002 - DeviceID
                int     1Ah         ; do it
                jc      StartUpError ; error out
                and     ah,ah
                jnz     StartUpError    ; error for AH != 0

                mov     DeviceID,cx ; put it in
;
                mov     ax,0B10Ah        ; read config dword
                mov     bx,PCIBusDevFunc
                mov     di,02Ch         ; Subsystem Id & Subsystem VendorId
                int     1Ah             ; do it
                jc      StartUpError
                and     ah,ah
                jnz     StartUpError    ; error for AH != 0
                mov     SubSystem_Id,ecx
;
		pop	di	; JL
		mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS
		clc
		ret
STARTUPERROR:   pop	di
		MOV	WORD PTR ES:[DI], PXENV_STATUS_FAILURE
          	mov	ax, PXENV_EXIT_FAILURE
		stc
		ret
UNDI_StartUp	endp
;------------------------------------------------------------------------------
Int1A_ISR	proc	far
;
		cmp	ax, 5650h		; VP, signature check
		jne	old_isr1A
		lea	bx, cs:ApiEntry
		push	cs
		pop	es                      ; ES = CS

; es:bx has s_PXENV_ENTRY structure

		mov	ax, 564eh	        ;; VN
		mov	edx, cs:ApiEntryPhyAddr	;; physical address of the entry structure
		push	bp
		mov	bp, sp
		and	word ptr [bp+6], not 1      ; clr carry on stack
		pop	bp
		iret
;
old_isr1A:	push	word ptr cs:Old_1A+2
		push	word ptr cs:Old_1A
		retf			; far jump to the previous ISR
;
Int1A_ISR	endp
;==========================================================================
; UNDI_CleanUp
;==============
; Entry:	called from PXENV_UNDI_API for boot-rom.
;		ES:DI contains ParamBlock Pointer
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_CleanUp	proc	near
;
; unhook the int1A
;
		cli
		push	es

		xor	ax, ax
		mov	es, ax                  ; ES = 0000 (I.V.T)
		mov	bx, 1Ah * 4             ; int 1A offset
		mov	eax, es:[bx]		; current ISR
		cmp	ax, cs:Int1A_ISR	; is this ours?
		jne	Cant_unhook
		shr	eax, 16
		mov	cx, cs
		cmp	ax, cx
		jne	Cant_unhook
		mov	eax, dword ptr cs:Old_1A
		mov	dword ptr es:[bx], eax
Cant_unhook:    pop     es
		mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS
		clc
		jmp short CleanUp_Exit
;
;Cant_unhook:    pop     es
;                mov     ax, PXENV_EXIT_FAILURE
;                mov     word ptr es:[di], PXENV_STATUS_1A_HOOKED
;                stc
CleanUp_Exit:	sti                             ; re-allow interrupts
                ret
;
UNDI_CleanUp	endp
;==========================================================================
; UNDI_Initialize
;=================
; Description:	Resets the adapter with default parameters but does not
;		enable the Tx and Rx units.
;
; Entry:	ES:DI contains NIC_Initialize pointer
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_Initialize proc	near
BREAK
	push	es
		push	di

		mov	eax, (NIC_Initialize ptr es:[di]).I_RcvInt
		mov	RxCallback, eax         ; save ptr to Applications callback routine
		mov	eax, (NIC_Initialize ptr es:[di]).I_GenInt
		mov	GenIntCallback, eax     ; callback for ints other than receive

; We don't care to save prot_INI pointer as we don't use it.
;
                mov     bx,PCIBusDevFunc       ; by JON
		cmp	IsInitialized,0			; is it already init'ed?
                jne     PPI_Err2                                ; yes, skip
IFDEF _VERBOSE
                push    si
                mov     si,offset msg_callNADInit
                call    Print
                pop     si
ENDIF
		call	NADInit			;Don't hook INT in NADInit
        					; if it fails
IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADInitOK ; set ok msg
                jnc     NADInitRetOK            ; branch if really ok
                mov     si,offset msg_NADInitErr ; set error msg
NADInitRetOK:   call    Print
                pop     si
                popf
ENDIF
		jc	PPI_Err
PPI_Err2:       mov             IsInitialized,1                 ; set state variable
; JL - copy 6 byte address from Net_Address to Node_Address so driver code
;      doesn't have to worry about it

                mov     ax,ds
                mov     es,ax           ; let ES = DS
                cld
                mov     si,offset DGroup:Net_Address
                mov     di,offset DGroup:Node_Address
                mov     cx,3            ; 6 bytes = 3 words
           rep  movsw
; end JL code
		call	InitEDMemory

		mov	ForcedINT, FALSE        ; set default value
		mov	NeedIndComplete, FALSE

		pop	di
		pop	es
		mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS
		clc
		ret

PPI_Err: 	pop	di
	 	pop	es
	 	cmp	ax, 2
	 	jz	MediaFail
	 	mov	word ptr es:[di], PXENV_STATUS_FAILURE
	 	jmp	init_err
MediaFail:      mov	word ptr es:[di], PXENV_STATUS_UNDI_MEDIATEST_FAILED
init_err: 	mov	ax, PXENV_EXIT_FAILURE
	  	stc
	  	ret
;
UNDI_Initialize endp
;==========================================================================
; UNDI_ResetAdapter
;===================
; Description:	Resets and reinitializes the adapter with the same set
;		of parameters supplied to Initialize routine, and
;		opens the adapter, i.e. connects logically to network.
;
; Entry:	ES:DI contains NIC_Reset pointer
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_ResetAdapter	proc	near

		cmp	IsInitialized,0		; if not init'd error out of here
		jne	Ok2Reset
		jmp	short ResetOkExit
;;		mov	ax, PXENV_EXIT_FAILURE
;;		mov	word ptr es:[di], PXENV_STATUS_FAILURE
;;		stc
;;		ret
Ok2Reset:	push	es
		push	di
      		call	UNDI_CloseAdapter
;
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADReset
                call    Print
                pop     si
ENDIF
		call	NADReset
IFDEF _VERBOSE                      ; print success or fail msg for NADReset
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADResetOK    ; set ok msg
                jnc     NADResetRetOK               ; branch if really ok
                mov     si,offset msg_NADResetErr   ; set error msg
NADResetRetOK:  call    Print
                pop     si
                popf
ENDIF
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADOpen
                call    Print
                pop     si
ENDIF
		call	NADOpen

IFDEF _VERBOSE  ; print success or fail msg for NADOpen
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADOpenOK ; set ok msg
                jnc     NADOpenRetOK            ; branch if really ok
                mov     si,offset msg_NADOpenErr ; set error msg
NADOpenRetOK:   call    Print
                pop     si
                popf
ENDIF
                jnc      @F
		pop	di
		pop	es
		mov	ax, PXENV_EXIT_FAILURE
		mov	word ptr es:[di], PXENV_STATUS_FAILURE
		stc
		ret
;
@@:		mov	DGroup:IsOpen,1
		mov	ax, RecFilter

IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADSetFilter
                call    Print
                pop     si
ENDIF
		call	NADSetFilter
IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADSetFilterOK ; set ok msg
                jnc     NADSetFilterOK            ; branch if really ok
                mov     si,offset msg_NADSetFilterErr ; set error msg
NADSetFilterOK: call    Print
                pop     si
                popf
ENDIF
;
;- Set ES:SI = Multicast list, Set CX to # of MC entries.
;
		mov	cx, (NIC_Reset ptr es:[di]).R_MCBuf.MC_MCastAddrCount
		lea	si, (NIC_Reset ptr es:[di]).R_MCBuf.MC_MCastAddr
		mov	ax, 1			; save mcast address list
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADMCast
                call    Print
                pop     si
ENDIF
		call	NADMCastChange
IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADMCastChangeOK  ; set ok msg
                jnc     NADMCastRetOK2                  ; branch if really ok
                mov     si,offset msg_NADMCastChangeErr ; set error msg
NADMCastRetOK2:   call    Print
                pop     si
                popf
ENDIF
		pop	di
		pop	es
ResetOkExit:    mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS
		clc
		ret
;
UNDI_ResetAdapter	endp
;==========================================================================
; UNDI_ShutDown
;===============
; Description:	Resets the adapter and leaves it in a safe state for
;		another driver to program it.
;
; Entry:	ES:DI contains NIC_ShutDown Pointer
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_ShutDown	proc	near

		push	es
		push	di
		cmp     IsOpen,0        ; if = 0 means closed
		je	ok2ShutDown
      		call	UNDI_CloseAdapter       ; close it for them
ok2ShutDown:	cmp	IsInitialized,0		; has UNDI_Initialize been called?
		je	ShutdownErr			; no, so skip this
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADShutDown
                call    Print
                pop     si
ENDIF
				call	NADShutDown
				jc      ShutdownFailed
				mov		IsInitialized,0		; set to uninitialized state
ShutdownFailed:
IFDEF _VERBOSE  ; print success or fail msg for NADShutDown
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADShutDownOK  ; set ok msg
                jnc     NADShutDownOK                ; branch if really ok
                mov     si,offset msg_NADShutDownErr ; set error msg
NADShutDownOK:  call    Print
                pop     si
                popf
ENDIF
                jnc      @F
ShutdownErr:
;;              pop             di
;;              pop             es
;;              stc
;;              mov         ax,PXENV_EXIT_FAILURE
;;              mov             word ptr es:[di],PXENV_STATUS_FAILURE
;;              jmp short ShutdownExit                  ; carry set to indicate error
;
@@:     		pop	di
				pop	es
				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
ShutdownExit:	ret
;
UNDI_ShutDown	endp
;==========================================================================
; UNDI_OpenAdapter
;==================
; Description:	Activates the adapter's network connection and sets the
;		adapter ready to accept packets for transmit and receive.
;
; Entry:	ES:DI points to NIC_Open Structure
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;
; JL - We'll handle the "OPEN" state as a variable "IsOpen" which will be
;      set to non-zero when the adapter is "OPEN". If the higher level calls
;      us to do a Transmit we will check for IsOpen and fail the call if it
;      isn't.
;
;==========================================================================
UNDI_OpenAdapter proc	near

		push	es
		push	di
        	cmp     DGroup:IsOpen,0         ; 0 means NOT open
	        jne     skipNADOpen             ; skip if 'open'
       		cmp	DGroup:IsInitialized,0	; has UNDI_Initialize been called?
		je	skipNADOpen
;;      	je	OpenErr			; no, so skip this
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADOpen
                call    Print
                pop     si
ENDIF
		call	NADOpen

IFDEF _VERBOSE  ; print success or fail msg for NADOpen
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADOpenOK ; set ok msg
                jnc     NADOpenRetOK2           ; branch if really ok
                mov     si,offset msg_NADOpenErr ; set error msg
NADOpenRetOK2:  call    Print
                pop     si
                popf
ENDIF
                jnc      @F
		pop	di
		pop	es
		ret                     ; carry set to indicate error
;
@@:             mov     DGroup:IsOpen,1     ; JL - indicate Open state
		mov	ax, (NIC_Open ptr es:[di]).O_PktFilter
		mov	RecFilter, ax
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADSetFilter
                call    Print
                pop     si
ENDIF
		call	NADSetFilter
IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADSetFilterOK ; set ok msg
                jnc     NADSetFilterOK2           ; branch if really ok
                mov     si,offset msg_NADSetFilterErr ; set error msg
NADSetFilterOK2: call    Print
                pop     si
                popf
ENDIF
;
;- Set ES:SI = Multicast list, Set CX to # of MC entries.
;
		pop	di
		pop	es
		push	es
		push	di

		mov	cx, (NIC_Open ptr es:[di]).O_MCBuf.MC_MCastAddrCount
		lea	si, (NIC_Open ptr es:[di]).O_MCBuf.MC_MCastAddr
		mov	ax, 1			; save mcast address list
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADMCast
                call    Print
                pop     si
ENDIF
		call	NADMCastChange
IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADMCastChangeOK  ; set ok msg
                jnc     NADMCastRetOK3                  ; branch if really ok
                mov     si,offset msg_NADMCastChangeErr ; set error msg
NADMCastRetOK3:   call    Print
                pop     si
                popf
ENDIF
skipNADOpen:    pop     di
		pop	es
		mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS
		clc
		ret
OpenErr:	pop	di
		pop	es
		stc
		mov	ax,PXENV_EXIT_FAILURE
		mov	word ptr es:[di],PXENV_STATUS_FAILURE
            	ret
;
UNDI_OpenAdapter endp
;==========================================================================
; UNDI_CloseAdapter
;===================
; Description:	Disconnects the adapter from network.
;		Packets cannot be Tx or Rx.
;
; Entry:	ES:DI points to NIC_Close Struc
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_CloseAdapter	proc	near

		push	es
		push	di
                cmp     DGroup:IsOpen,0
                je      skipNADClose		; DEADISSUE BUGBUG no POPs
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADClose
                call    Print
                pop     si
ENDIF
		call	NADClose

IFDEF _VERBOSE  ; print success or fail msg for NADClose
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADCloseOK ; set ok msg
                jnc     NADCloseRetOK            ; branch if really ok
                mov     si,offset msg_NADCloseErr ; set error msg
NADCloseRetOK:  call    Print
                pop     si
                popf
ENDIF
                pop	di
				pop	es
                jnc     @F
CloseFail:      mov     ax, PXENV_EXIT_FAILURE
				mov	word ptr es:[di],PXENV_STATUS_FAILURE
				ret                 ; carry set to indicate error
skipNADClose:	pop		di
				pop		es
;;jrl 980722    stc
;;JRL 980722    jmp short CloseFail
;
@@:	        	mov     DGroup:IsOpen,0     ; JL - indicate closed state
				mov	ax,PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
				ret
;
UNDI_CloseAdapter	endp
;==========================================================================
; UNDI_Transmit
;===============
; Description:	Transmit a frame onto the medium.
;
; Entry:	ES:DI = Pointer to NIC_Transmit
;		Board Interrupts COULD BE disabled.
;		System Interrupts are enabled.
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;		Board and System Interrupts are enabled
;
;==========================================================================
UNDI_Transmit	proc	near

                cmp     DGroup:IsOpen,0     ; is port really "Open"?
                je      DS_TransmitError    ; no, so abort
				cmp	(NIC_Transmit ptr es:[di]).T_Protocol, 3 ; largest supported #
				ja	DS_NotSupported

				mov	bx, di			; free DI, it is used for ED frags
                cli
				call	TransmitSetup
                sti
				jc	DS_TransmitError	; return error -- packet size exceeded

;*** perhaps increment statistic???  - jump to specific error label in future

				mov	cx, 10
TX_try_again:	push	cx
				push	di
				push	es		; save ptr to UNDI_TRANSMIT parm struc
				mov	ax, ds		; (can't assume NADTransmit will save ES:BX)
				mov	es, ax
				mov	si, offset DGroup:TxED 	; ES:SI ptr to transmit ED
IFDEF _VERBOSE
                push    si
                mov     si,offset msg_callNADTransmit
                call    Print
                pop     si
ENDIF
				call	NADTransmitPacket
IFDEF _VERBOSE  ; print success or fail msg for NADTransmitPacket
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADTransmitOK ; set ok msg
                jnc     NADTransmitRetOK            ; branch if really ok
                mov     si,offset msg_NADTransmitErr ; set error msg
NADTransmitRetOK:   call    Print
                pop     si
                popf
ENDIF
				pop	es
				pop	di		; ES:DI ptr to UNDI_TRANSMIT parm struc
				pop	cx

				test	TxED.ED_ErrCode, -1	; did the transmit complete OK?
				jz	DS_TransmitSuccess

		  loop	TX_try_again
				jmp	DS_TransmitError	; no, return PXENV_STATUS_FAILURE

DS_TransmitSuccess:

;;        push    dx
;;        mov     edx,    CR0
;;        test    dx, 1
;;        je      real_mode4
;; BREAK
;;real_mode4:
;;       pop dx
				mov	cx, TxED.ED_Length      ; CX has length of packet transmitted
				mov	bx, TxType              ; BX has packet type
                                                ; BX=0 for directed packet
                                                ; BX=1 for broadcast packet
                                                ; BX=2 for multicast packet
				mov	ax, 1			; tx post processing callback
				call	DWORD PTR GenIntCallback    ; call SWI to tell it transmit complete

				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
				ret

DS_NotSupported: mov	word ptr es:[di], PXENV_STATUS_UNSUPPORTED  ; status
		jmp	DS_ErrorExit

;*** this is a good place to differentiate between various Tx errors and set
; statistics if we see that it's needed

DS_TransmitError: mov	word ptr es:[di], PXENV_STATUS_FAILURE ; status
DS_ErrorExit:	mov	ax, PXENV_EXIT_FAILURE
		stc
		ret
;
UNDI_Transmit	endp
;==========================================================================
; TransmitSetup
;===============
; Description : This routine translates UNDI_TX parameters to the format
;		required by NADTransmit.
;
; Entry:	ES:BX -> NIC_Transmit param block structure
;			  NDIS transmit buffer descriptor
;		CLD is in effect
;		System Interrupts are enabled
;
; Exit: 	AX = 0, CY clear if translation went OK
;		AX = -1, CY set if MAX_PACKET length exceeded
;		BX,DI,BP,DS,ES preserved
;
; 970514 0.00 GK
;==========================================================================
TransmitSetup	proc	near

				push	bp
				push	es
				push	bx
				push	ds
				push	di

				mov	di, offset DGroup:TxED.ED_FragOff

; DS:DI ptr to TxED's 1st fragment descriptor
;--------------------------------------------------------------------------
; swap ES/DS so that DGROUP is pointed to by ES, BuffDesc by DS
;--------------------------------------------------------------------------
				push	ds
				push	es
				pop	ds			; DS:BX ptr to UNDI TxBuffDesc
				pop	es			; ES:DI ptr to TxED
				xor	bp, bp			; assume no media header
				mov	es:TxED.ED_FragCount, bp ; no fragments yet
;----------------------------------------------------------------------
;	Check if we need to add the media header
;--------------------------------------------------------------------
				cmp	(NIC_Transmit ptr ds:[bx]).T_Protocol, 0
				je	PFT_NoMediaHeader
; fill destination addr
				cmp	(NIC_Transmit ptr ds:[bx]).T_XmitFlag, 0
				je	PFT_DestAddrGiven	; take dest addr from T_DestAddrOffset
; fill broadcast addr
				xor	eax, eax
				dec	eax			; all F's
				mov	dword ptr es:MediaHeader, eax
				mov	word ptr es:MediaHeader+4, ax
				jmp	PFT_DestAddrFilled

PFT_DestAddrGiven:
				push	ds
				lds	si, dword ptr (NIC_Transmit ptr ds:[bx]).T_DestAddrOffset
				mov	eax, DWORD PTR [si]
				mov	dword ptr es:MediaHeader, eax
				mov	ax, WORD PTR [si+4]
				mov	word ptr es:MediaHeader+4, ax
				pop	ds

PFT_DestAddrFilled:				; fill source addr
				mov	eax, DWORD PTR es:Net_Address
				mov	dword ptr es:MediaHeader+6, eax
				mov	ax, WORD PTR es:Net_Address+4
				mov	word ptr es:MediaHeader+10, ax	; fill protocol type(This is Ethernet II)

				cmp	(NIC_Transmit ptr ds:[bx]).T_Protocol, P_IP
				jne	@F

				mov	ax,  TYPE_IP
				jmp	PFT_MediaHeaderDone
@@:             cmp	(NIC_Transmit ptr ds:[bx]).T_Protocol, P_ARP
				jne	@F

				mov	ax, TYPE_ARP
				jmp	PFT_MediaHeaderDone
@@:				mov	ax, TYPE_RARP				; must be RARP
PFT_MediaHeaderDone:
				xchg	al, ah
				mov	word ptr es:MediaHeader+12, ax
				mov	ax, offset DGroup:MediaHeader
				stosw				; frag1.offset = MediaHeader
				mov	ax, es
				stosw				; frag1.segment = ES (DGROUP)
				mov	ax, 14			; size of MediaHeader
				add	bp, ax			; BP = size of packet data so far
				stosw				; frag1.length = 14 (size of MediaHeader)
						; ES:DI now points to frag2
				inc	es:TxED.ED_FragCount	; bump fragment count by 1

				mov	eax, dword ptr es:MediaHeader
				and	ax, WORD PTR es:MediaHeader+4
				cmp	eax, -1
				jz	BCast

				mov	al, byte ptr es:MediaHeader
				cmp	al, 01h
				jz	MCast

				mov	ax, TYPE_UCAST
				jmp	set_xtype
MCast:			mov	ax, TYPE_MCAST
				jmp	set_xtype
BCast:			mov	ax, TYPE_BCAST
set_xtype:		mov	es:TxType, ax		;971030

PFT_NoMediaHeader:				; get the TBD into ds:si
				lds	si, dword ptr (NIC_Transmit ptr ds:[bx]).T_TBDOffset
;--------------------------------------------------------------------------
; Copy the Immediate Data if any
;--------------------------------------------------------------------------
				mov	cx, (TxBufDesc ptr ds:[si]).TxImmedLen
				or	cx, cx
				jz	PFT_NoImmediateData

				add	bp, cx
				cmp	bp, MAX_PACKET		; should not go beyond the buf size
				ja	len_error

				mov	ax, word ptr (TxBufDesc ptr ds:[si]).TxImmedPtr
				stosw				; frag1 (or frag2) = TxImmedptr
				mov	ax, word ptr (TxBufDesc ptr ds:[si]).TxImmedPtr+2
				stosw
				mov	ax, cx
				stosw				; this frag all defined, ES:DI ptr to
						;  next ED fragment
				inc	es:TxED.ED_FragCount	; bump fragment count by 1
;--------------------------------------------------------------------------
; Now copy TxDataBlock pointers/lengths to the ED fragments
;
; ES:DI points to next ED fragment descriptor
; DS:SI points to TransmitBufferDescriptor.
; BX will contain # of Fragment Descriptor Structures starting at TxDataBlk.
;--------------------------------------------------------------------------
PFT_NoImmediateData:
				mov	bx, (TxBufDesc ptr ds:[si]).TxDataCount
				or	bx, bx
				jz	PFT_NoDataBlocks

				lea	si, (TxBufDesc ptr ds:[si]).TxDataBlk
PFT_FragmentsLoop:
				mov	cx, (TxDataBlock ptr ds:[si]).TxDataLen
				or	cx, cx
				jz	PFT_NextFragment
;
;- remember to track total number of bytes in BP, no error checking though.
;
				add	bp, cx
				cmp	bp, MAX_PACKET	;; should not go beyond the buf size
				ja	len_error

				mov	ax, word ptr (TxDataBlock ptr ds:[si]).TxDataPtr
				stosw
				mov	ax, word ptr (TxDataBlock ptr ds:[si]).TxDataPtr+2
				stosw
				mov	ax, cx
				stosw
				inc	es:TxED.ED_FragCount	; bump fragment count by 1
PFT_NextFragment:
				add	si, TYPE TxDataBlock
				dec	bx
				jnz	PFT_FragmentsLoop
PFT_NoDataBlocks:
				pop	di	    ;; restore to the start
				pop	ds
				pop	bx
				pop	es

				mov	TxED.ED_Length, bp	; set total transmit length into TxED
;--------------------------------------------------------------------------
				push	es			; save ES

				mov	si, TxED.ED_FragOff ; DS:SI ptr to 1st fragment
				mov	ax, [si+6]
				or	ax, [si+8]
				or	ax, [si+10]
				jnz	PFT_NonZeroAddress

				mov	ax, WORD PTR Net_Address
				mov	[si+6], ax
				mov	ax, WORD PTR Net_Address+2
				mov	[si+8], ax
				mov	ax, WORD PTR Net_Address+4
				mov	[si+10], ax
PFT_NonZeroAddress:
				pop	es			; restore ES
				pop	bp
				xor	ax, ax
				clc
				ret
len_error:		pop	di			; restore to the start
				pop	ds
				pop	bx
				pop	es
				pop	bp
				mov	ax, -1
				stc
				ret
;
TransmitSetup	endp
;==========================================================================
; UNDI_DriverISR
;================
; Description:	Interrupt service routine for receiving packets
;
; Entry:	None
;
; Exit: 	None
;==========================================================================

UNDI_DriverISR	proc	far
;   			BREAK
				push	ds
				push	es
				push	eax
				push	ebx
				push	ecx
				push	edx
				push	esi
				push	edi
				push	ebp
;;   mov     edx,    CR0
;;   test    dx, 1
;;   je      real_mode3
real_mode3:     mov 	ax, cs:ApiEntry.mlid_ds_sel
				mov 	ds, ax
IFDEF _VERBOSE
                push    si
                mov     si,offset msg_callNADDriverISR
                call    Print
                pop     si
ENDIF
; *******  Dmitry *************
; when entering this ISR low-level service routine should be processed
; in any case, otherwise we risk to miss interrupt.
; That's why code below is commented and moved after call to the
; DriverISR_Proc
; ******************************
;;                inc     DGroup:InAdapterIsr            ; inc reentrant count
;;                cmp     DGroup:InAdapterIsr,1          ; just us here?
;;                jne     skip_Isr                ; no, don't reenter

                call    DriverISR_Proc          ; adapter specific Rx ISR
                jc      not_our_isr
                inc     DGroup:InAdapterIsr            ; inc reentrant count
                cmp     DGroup:InAdapterIsr,1          ; just us here?
                jne     skip_Isr                ; no, don't reenter
                dec     DGroup:InAdapterIsr            ; dec reentrant count
;

IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADIsrOK ; set ok msg
                jnc     NADIsrRetOK            ; branch if really ok
                mov     si,offset msg_NADIsrErr ; set error msg
NADIsrRetOK:    call    Print
                pop     si
                popf
ENDIF
;;		jc	not_our_isr

				sti
				call	ProcessRxInt
				jmp short DriverISR_ret
skip_Isr:       dec     InAdapterIsr            ; dec reentrant count
        		jmp short DriverISR_ret
;
not_our_isr:
; *******  Dmitry *************
; too dangerous for now to chain interrupt - in some cases
; CF is set in the end of low-level service routine to
; indicate interrupt failure and not "not our interrupt" case.
; In case of interrupt failed we shouldn't process Rx Buffer,
; but it would be illegal to call original vector.
; Needs further elaboration
; ******************************
;;        cmp	OrgINTVector_Seg, 0	; segment == 0?
;; 		jne     ChainTheInt
DriverISR_ret:	cli
		        pop	ebp
				pop	edi
				pop	esi
				pop	edx
				pop	ecx
				pop	ebx
				pop	eax
				pop	es
				pop	ds
				iret
;
ChainTheInt:    pop	ebp     ; safer to chain this way with a jump
				pop	edi     ; after clearing our saved stuff off the stack
				pop	esi
				pop	edx
				pop	ecx
				pop	ebx
				pop	eax
				pop	es
				pop	ds
                cli                             ; simulate interrupt
				jmp 	DWORD PTR OrgINTVector_Off ; and a JMP far
;
UNDI_DriverISR	endp
;==========================================================================
; UNDI_SetMCastAddr
;===================
; Description:	Change the list of multicast addresses and
;		resets the adapter to accept it.
;
; Entry:	ES:DI contains NIC_SetMCastAddr
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_SetMCastAddr	proc	near

		push	es
		push	di
;
;- Set ES:SI = Multicast list, Set CX to # of MC entries.
;
		mov	cx, (NIC_SetMCastAddr ptr es:[di]).SM_MCBuf.MC_MCastAddrCount
		lea	si, (NIC_SetMCastAddr ptr es:[di]).SM_MCBuf.MC_MCastAddr
;;JRL 980511		mov	ax, 1			; save mcast address list
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADMCast
                call    Print
                pop     si
ENDIF
		call	NADMCastChange
IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADMCastChangeOK ; set ok msg
                jnc     NADMCastRetOK            ; branch if really ok
                mov     si,offset msg_NADMCastChangeErr ; set error msg
NADMCastRetOK:   call    Print
                pop     si
                popf
ENDIF
				pop	di
				pop	es
				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
				ret
;
UNDI_SetMCastAddr	endp
;==========================================================================
; UNDI_SetStationAddress
;========================
; Description:	Sets MAC address to be the input value
;
; Entry:	ES:DI contains the param blk
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_SetStationAddress	proc	near

				mov	si, offset DGroup:Net_Address
				mov	eax, dword ptr (NIC_SetStationAddr ptr es:[di]).SS_StationAddr
				mov	dword ptr [si], eax         ; put 4 bytes of new MAC address in
				mov	ax, word ptr (NIC_SetStationAddr ptr es:[di]).SS_StationAddr+4
				mov	word ptr [si+4], ax         ; put 2 bytes of new mac address in
;; JL - PATCHED OUT 980715
;               cmp     IsOpen,0                        ; disallow if nic not 'open'
;               jne     setMacFailed
				call	NADSetMACAddress		; SI points to 6 byte MAC address
				jc setMacFailed
        		mov	ax, PXENV_EXIT_SUCCESS
		        mov	word ptr es:[di], PXENV_STATUS_SUCCESS
        		clc
SSA_Exit:		ret
setMacFailed:   mov	ax, PXENV_EXIT_FAILURE
				mov	word ptr es:[di], PXENV_STATUS_UNSUPPORTED
				stc
				jmp short SSA_Exit
;
UNDI_SetStationAddress	endp
;==========================================================================
; UNDI_SetPacketFilter
;======================
; Description:	Resets the adapter's Rx unit to accept a new filter.
;
; Entry:	ES:DI points to the filter parameter
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_SetPacketFilter	proc	near

				movzx	ax, (NIC_SetPacketFilter ptr es:[di]).SP_NewFilter
				test	ax, NOT (FLTR_DIRECTED OR FLTR_MLTCST OR FLTR_BRDCST OR FLTR_PRMSCS)
				jz	    FilterValueOK

				mov	ax, PXENV_EXIT_FAILURE
				mov	word ptr es:[di], PXENV_STATUS_FAILURE
				stc
				ret
FilterValueOK:	mov	RecFilter, ax
IFDEF   _VERBOSE
                push    si
                mov     si,offset msg_callNADSetFilter
                call    Print
                pop     si
ENDIF
				call	NADSetFilter
IFDEF _VERBOSE  ; print success or fail msg for NADInit
                pushf                                 ; save for carry test later
                push    si
                mov     si,offset msg_NADSetFilterOK  ; set ok msg
                jnc     NADSetFilterOK3               ; branch if really ok
                mov     si,offset msg_NADSetFilterErr ; set error msg
NADSetFilterOK3: call    Print
                pop     si
                popf
ENDIF
				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
				ret
;
UNDI_SetPacketFilter	endp
;==========================================================================
; UNDI_GetNICInfo
;=================
; Description:	Copies adapter variables into the input buffer
;
; Entry:	ES:DI contains NIC_GetInfo Pointer
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_GetNICInfo proc	 near

				mov	ax, IOBase
				mov	(NIC_GetInfo ptr es:[di]).GI_BaseIo, ax
                sub     ax,ax                   ; clr AH
				mov	al, IRQNumber
				mov	(NIC_GetInfo ptr es:[di]).GI_IntNumber, ax
; MTU
				mov	(NIC_GetInfo ptr es:[di]).GI_MTU, MAXIMUM_ETHERNET_PACKET_SIZE
				mov	(NIC_GetInfo ptr es:[di]).GI_HwType, ETHER_TYPE
				mov	(NIC_GetInfo ptr es:[di]).GI_HwAddrLen, ETHERNET_ADDRESS_LENGTH
; Permanent address
				mov	eax, DWORD PTR Node_Address
				mov	dword ptr (NIC_GetInfo ptr es:[di]).GI_PermNodeAddress, eax
				mov	ax, WORD PTR Node_Address+4
				mov	word ptr (NIC_GetInfo ptr es:[di]).GI_PermNodeAddress+4, ax
; current address
				mov	eax, DWORD PTR Net_Address
				mov	dword ptr (NIC_GetInfo ptr es:[di]).GI_CurrentNodeAddress, eax
				mov	ax, WORD PTR Net_Address+4
				mov	word ptr (NIC_GetInfo ptr es:[di]).GI_CurrentNodeAddress+4, ax
; Get the on-board ROM address
				mov	ax, word ptr ROMBase
				mov	(NIC_GetInfo ptr es:[di]).GI_ROMAddress, ax
				mov	ax, 1
				mov	(NIC_GetInfo ptr es:[di]).GI_TxBufCt, ax
				mov	ax, NUM_ED
				mov	(NIC_GetInfo ptr es:[di]).GI_RxBufCt, ax
				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
				ret
;
UNDI_GetNICInfo endp
;==========================================================================
; GetNICType:
;=============
; Entry       :	es:di contains NICType_pnp/pci Pointer
;
; Exit        :
;==========================================================================
UNDI_GetNICType	proc	near

				mov	(NIC_GetNICType_pci ptr es:[di]).NicType, PCI_ADAPTER
                mov     ax,VendorId
				mov	(NIC_GetNICType_pci ptr es:[di]).Vendor_ID, ax
                mov     ax,DeviceId
				mov	(NIC_GetNICType_pci ptr es:[di]).Dev_ID,ax
				mov	(NIC_GetNICType_pci ptr es:[di]).Base_Class, PCI_BASE_CLASS
				mov	(NIC_GetNICType_pci ptr es:[di]).Sub_Class,PCI_SUB_CLASS
				mov	(NIC_GetNICType_pci ptr es:[di]).Prog_Intf,PCI_PROG_INTERFACE
; JL code
                mov     ebx,SubSystem_Id
                mov     (NIC_GetNICType_pci ptr es:[di]).SubSystemId,ebx
; JL ends
				mov	bx, PCIBusDevFunc
				mov	(NIC_GetNICType_pci ptr es:[di]).BusDevFunc, bx
;
	;; don't read the configuration data whenever this is called
	;; should not read in protected mode!!

;		push	di
;		mov 	di, REV_ID_REGISTER
;		PCI_READ_BYTE		;; cx will have it
;		pop	di
				mov	(NIC_GetNICType_pci ptr es:[di]).Rev, cl
				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
				ret
;
UNDI_GetNICType	endp
;==========================================================================
; UNDI_GetStatistics
;====================
; Description:	Reads statistical information from adapter.
;
; Entry:	ES:DI contains NIC_GetStatistics Pointer
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_GetStatistics	proc	near

				push	es
				push	di
				mov	si, offset DGroup:TxGoodFrames
                sub     ax,ax                   ; signal to get stats (not clear them)
IFDEF _VERBOSE
                push    si
                mov     si,offset msg_callNADGetStats
                call    Print
                pop     si
ENDIF
				call	NADGetStatistics    ; with AX=0 means get the stats

IFDEF _VERBOSE  ; print success or fail msg for NADGetStatistics
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADGetStatOK ; set ok msg
                jnc     NADGetStatOK            ; branch if really ok
                mov     si,offset msg_NADGetStatErr ; set error msg
NADGetStatOK:   call    Print
                pop     si
                popf
ENDIF
				pop	di
				pop	es
                jc      cantGetStats
				mov	eax, TxGoodFrames
				mov	(NIC_GetStatistics ptr es:[di]).GS_XmtGoodFrames, eax
				mov	eax, RxGoodFrames
				mov	(NIC_GetStatistics ptr es:[di]).GS_RcvGoodFrames, eax
				mov	eax, RxCRCErrors
				mov	(NIC_GetStatistics ptr es:[di]).GS_RcvCRCErrors, eax
				mov	eax, RxDiscarded
				mov	(NIC_GetStatistics ptr es:[di]).GS_RcvResourceErrors, eax

				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
getStatsExit:	ret
cantGetStats:   mov	ax, PXENV_EXIT_FAILURE
				mov	word ptr es:[di], PXENV_STATUS_UNSUPPORTED
				stc
                jmp short getStatsExit
;
UNDI_GetStatistics	endp
;==========================================================================
; UNDI_ClearStatistics
;======================
; Description:	Clears the statistical information from the adapter.
;
; Entry:	ES:DI points to para block
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
UNDI_ClearStatistics	proc	near

				push	es
				push	di

				mov	si, offset DGroup:TxGoodFrames
                mov     ax,1                    ; signal to clear statistics
IFDEF _VERBOSE
                push    si
                mov     si,offset msg_callNADGetStats
                call    Print
                pop     si
ENDIF
				call	NADGetStatistics        ; with AX != 0 means clr the stats
IFDEF _VERBOSE  ; print success or fail msg for NADGetStatistics
                pushf                           ; save for carry test later
                push    si
                mov     si,offset msg_NADGetStatOK ; set ok msg
                jnc     NADGetStatOK2           ; branch if really ok
                mov     si,offset msg_NADGetStatErr ; set error msg
NADGetStatOK2:  call    Print
                pop     si
                popf
ENDIF
				pop	di
				pop	es
                jc      cantClrStats            ; branch on lower level error
				mov	ax, PXENV_EXIT_SUCCESS
				mov	word ptr es:[di], PXENV_STATUS_SUCCESS
				clc
clrStatsExit:	ret
cantClrStats:   mov	ax, PXENV_EXIT_FAILURE
		mov	word ptr es:[di], PXENV_STATUS_UNSUPPORTED
		stc
                jmp short clrStatsExit
;
UNDI_ClearStatistics	endp
;==========================================================================
; UNDI_InitDiags
;================
; Description:	Initialize the run-time diagnostics.
;
; Entry:	ES:DI points to parameter block
;
; Exit: 	returns NOT_SUPPORTED IF lower level doesn't support
;==========================================================================
; TODO: Find out when it's legal to make this call to us so we can refuse
;       the call when it's made at the wrong time
;
UNDI_InitDiags	proc	near

                push    es                      ; save structure pointers
                push    di
                call    NADInitiateDiags       ; NEW - return status word in AX
                pop     di                      ; restore stucture pointers
                pop     es
                jc      diagsFail               ; did lower level support call?
                mov     es:[di],ax              ; TODO: use structure here
		mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS
		clc
                jmp short diagExit
diagsFail:	mov	ax, PXENV_EXIT_FAILURE
		mov	word ptr es:[di], PXENV_STATUS_UNSUPPORTED
		stc
diagExit:	ret
;
UNDI_InitDiags	endp
;==========================================================================
; UNDI_ForceInterrupt
;=====================
; Description:	Forces the adapter to generate an interrupt.
;
; Entry:	ES:DI points to parameter block
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;
; Note: 	A software handling for Rx is implemented here to
;		accommodate those adapters which may have problem on
;		generating interrupt by itself.
;==========================================================================
UNDI_ForceInterrupt	proc	near

		push	es
		push	di

		mov	ForcedInt, TRUE     ;

                cmp     SimulateInterrupts,0    ; if non-zero we need to fake ints
                je      dontFakeThem            ; else we don't need to
                pushf                           ; simulate int  JL
                call    UNDI_DriverISR          ; JL - call UNDI level ISR
                jmp short UF_Exit
;
dontFakeThem:	call	ProcessRxInt

UF_Exit:	pop	di
		pop	es
		mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS

		clc
		ret
;
UNDI_ForceInterrupt	endp
;------------------------------------------------------------------------------
ProcessRxInt	proc	near
;
;  DESCRIPTION: Checks and sets a re-entrancy flag
;               Checks for data in ED's ring buffer
;   PARAMETERS:
;      RETURNS:
;    CALLED BY: UNDI_DriverISR, UNDI_ForceInterrupt
;
		push	es

		cmp	InProcessRxInt, TRUE    ; are we IN this routine already?
		jz	RxIntRet                ; yes, don't re-enter
		mov	InProcessRxInt, TRUE    ; no, mark as entered
check_more:	mov	si,[EDListTail]         ; get ptr to ring buffer tail
		cmp	[EDListHead], si        ; same as head?
		jnz	data_avail              ; no, must have data in it
		cmp	word ptr [si].ED_Length, 0	;does this ED have data?
		jnz	data_avail
		cmp	ForcedInt, FALSE        ; called by other than UNDI_ForceInterrupt?
;;    nop
;;    nop ;JRL Test to see if this is a problem
 		jz	NoMoreData              ; yes, skip
; Comes here when called by UNDI_ForceInterrupt
		mov	ForcedInt, FALSE        ; unsignal flag
		mov	ax, 3			; software INT callback
		call	DWORD PTR GenIntCallback ; call General Interrupt Handler
		jmp	NoMoreData
data_avail:	nop
		mov	cx, [si].ED_Length
		lea	bx, [si].ED_FragOff	; point to 1st descriptor
		mov	ax, ds
		mov	es, ax
		mov	di, word ptr [bx].DPointer	; get fragment pointer
;
; Find the packet type & convert it into 0,1,2,3 and put in BX
;
                sub     bx,bx               ; make sure BH clr cuz we return result in BX
		mov	ax, (EtherHeader ptr es:[di]).E_Type
		xchg	al, ah
		cmp	ax, TYPE_IP
		jne	@F
		mov	bl, P_IP            ; signal packet type IP
		jmp	GotType
@@:		cmp	ax, TYPE_ARP
		jne	@F
		mov	bl, P_ARP           ; signal packet type ARP
		jmp	GotType
@@:		cmp	ax, TYPE_RARP
		jne	@F
		mov	bl, P_RARP          ; signal packet type RARP
		jmp	GotType
@@:		sub	bl, bl              ; BL = 0 ; signal unknown type
GotType:	mov	ax, ETHER_HEADER_LEN
;-------------------------------------------------------------------
; call the receive callback function.
;	ES:DI must contain the buffer
;	CX must contain the length
;	AX must contain the length of media header which is 6+6+2
;	BX must contain the packet type: 0 - P_UNKNOWN, 1 - P_IP,
;-------------------------------------------------------------------
		Call	DWORD PTR RxCallback    ; call application level callback routine

		cmp	ax, -1			;DELAY_COPY
		jz	DelayCopy		;yes

		mov	NeedIndComplete, TRUE
		call	PostED

		cmp	ForcedInt, FALSE
		je	check_more

; if ForcedInt is TRUE we call the GeneralInterruptHandler as a SWI
		mov	ForcedInt, FALSE        ; un-signal flag
		mov	ax, 3			; software INT callback
		call	DWORD PTR GenIntCallback
		jmp	check_more
NoMoreData:	cmp	NeedIndComplete, FALSE
		jz	OutRxInt
		mov	NeedIndComplete, FALSE
		mov	ax, 2			; rx post processing callback
		call	DWORD PTR GenIntCallback
DelayCopy:
OutRxInt:	mov	InProcessRxInt, FALSE   ; set flag that we are no longer in this code
RxIntRet:	pop	es
		ret
;
ProcessRxInt	endp
;==========================================================================
; UNDI_GetMCastAddr
;===================
; Description:	Converts given IP address to hardware multicast address
;
; Entry:	ES:DI points to NIC_GetMCastAddr parameter
;
; Exit: 	AX contains success/failure code,
;		CF cleared on success, set on error, and
;		the status field in parameter structure is set.
;==========================================================================
; ether net MCAST	Equ	01005e00h	; Ethernet multicast header

UNDI_GetMCastAddr	proc	near

		push	ebx
		mov	ebx, (NIC_GetMCastAddr ptr es:[di]).GM_InetAddr
		and	ebx, 0fffff700h 	;; take the last 23 bits.
						;; it is in host order now
		mov	(NIC_GetMCastAddr ptr es:[di]).GM_HwAddr, 01h
		mov	(NIC_GetMCastAddr ptr es:[di]).GM_HwAddr+1, 00h
		mov	(NIC_GetMCastAddr ptr es:[di]).GM_HwAddr+2, 5eh
		mov	(NIC_GetMCastAddr ptr es:[di]).GM_HwAddr+3, 0h
		mov	(NIC_GetMCastAddr ptr es:[di]).GM_HwAddr+4, 00h
		mov	(NIC_GetMCastAddr ptr es:[di]).GM_HwAddr+5, 00h
		or	dword ptr (NIC_GetMCastAddr ptr es:[di]).GM_HwAddr+2, ebx
		pop	ebx

		mov	ax, PXENV_EXIT_SUCCESS
		mov	word ptr es:[di], PXENV_STATUS_SUCCESS
		clc
		ret
;
UNDI_GetMCastAddr	endp
;**************************************************************************
; Routines for EDs handling
;--------------------------------------------------------------------
; InitEDMemory
;--------------
; Create memory for EDs and data buffers.  The data buffers can
; contain a complete ethernet packet (1500 bytes).
;
; Parameters:	none
;
; Returns:	nothing
;--------------------------------------------------------------------
InitEDMemory	proc	near

		push	es

		mov	ax, ds
		mov	es, ax                  ; ES = DS

; The ED's are linked together, the first dword contains a
; pointer to the next ED.

		mov	si, offset DGroup:RxEDs	; get address of 1st ED
		mov	bl, NUM_ED-1		; use bl as ED counter
initLoop:	mov	di, si
		mov	cx, (size ED_Struct)/2
		xor	ax, ax
	rep	stosw				; clear the ED

		mov	word ptr [si].ED_FragCount, 1	; define one fragment

		mov	ax, si			; put address in ax
		add	ax, size ED_Struct	; calc location of buffer following ED
		mov	[si].ED_FragOff, ax	; set location of data packet
		mov	[si].ED_FragSeg, ds
		mov	[si].ED_FragLen, MTU	; buffer size

		or	bl, bl			; is this the last ED?
		je	initDone		; yes

		add	ax, MTU 		; add size of buffer
		mov	[si].ED_Ptr, ax 	; set link pointer to next ED
		mov	si, ax			; move next address into di
		dec	bl
		jmp	short initLoop

initDone:	mov	ax, offset DGroup:RxEDs
		mov	[si].ED_Ptr, ax 	; link last ED back to the start

		mov	[EDListHead], ax	; set linked list head to start ED
		mov	[EDListTail], ax	; set linked list tail to start ED
		pop	es
		ret
;
InitEDMemory	endp
;------------------------------------------------------------------------
; GetED
;-------
; Check the head ED to see if it is available, if it is it's returned
; to the NAD and the head is changed to the next ED.
;
; Parameters:	none
;
; Returns:	es:si - pointer to ED
;		(si = 0 if no ED available)
;------------------------------------------------------------------------
GetED		proc	near

		cli				; disable interrupts
		push	ax
		mov	ax, ds
		mov	es, ax                  ; ES = DS

		mov	si, DGroup:[EDListHead]	; get ED at head of list
		cmp	word ptr [si].ED_Length, 0	; does this ED have data?
		je	edAvailable		; no - it's available

		xor	si, si			; return no ED available
		jmp	short getEDexit

edAvailable:	mov	DGroup:[EDListCurrent], si
		mov	ax, [si].ED_Ptr 	; get pointer to next ED
		mov	DGroup:[EDListHead], ax	; set next ED as head

		or	si, si			; reset zero flag
getEDexit:	pop	ax
		sti				; enable interrupts
		ret				; return (es:si is pointer to ED)
;
GetED		endp
;--------------------------------------------------------------------
; PostED
;--------
; Routine is called after a packet is received and has been copied
; into a data buffer in upper layer.
;
; Parameters:	none
;
; Returns:	nothing
;--------------------------------------------------------------------
PostED		proc	near

		cli
		push	es
		mov	ax, ds
		mov	es, ax                  ; ES = DS

		mov	si, [EDListTail]		; get ED at tail of list
		cmp	word ptr [si].ED_Length, 0	; does this ED have data?
		jz	nopost
		mov	word ptr [si].ED_Length, 0	; kill the data

		cmp	si, [EDListHead]
		mov	si, [si].ED_Ptr 		; get pointer to next ED
		jnz	postit
		cmp	word ptr [si].ED_Length, 0	; does this ED have data?
		jz	nopost
postit:		mov	[EDListTail], si		; set next ED as tail
nopost:		pop	es
		sti
		ret
;
PostED		endp
;------------------------------------------------------------------------------
; code added by jon
include stdio.asm   ; DisplayChar,Print,PrintDecimal,PrintHexWord,PrintHexByte
; code added ends
;------------------------------------------------------------------------------
Delay25ms	equ	0ea60h

	align	16

public		ApiEntry
ApiEntry	s_PXENV_ENTRY<>
ApiEntryPhyAddr	dd	0

; This ORG was added by Jon to make linked in code assemble at 1000H so
; we could org it at 1000h to generate a listing file and then re ORG it
; at 0000 for the actual obj file. The linker will locate it at 1000h
; in the finished binary.
;

IFDEF _DEBUG

ORG 0FFFh
    nop

ENDIF

_TEXT		Ends
;******************************************************************************
_DATA	segment	para public
	align	4
;
; Protocol's callback
;
RxCallback	dd	0
GenIntCallback	dd	0
;
; Don't change the order of the following four statistic variables
;
TxGoodFrames	dd	0	;1
RxGoodFrames	dd	0	;2
RxCRCErrors	dd	0	;3
RxDiscarded	dd	0	;3
;
; Transmit data variables   MOVED TO _BSS SEG
;
;TxED		ED_Struct <?>		; provide 9 additional fragments
;TxFrags 	Frag	9 dup (<?>)	;  for a total of 10 ED fragments
;MediaHeader	db	14 dup (?)	; destination, source, typelength
;					;  we only build and include this
;					;  header if protocol !=0
;
; Receive data variables
;
EDListHead	dw	0		; head pointer of ED list
EDListTail	dw	0		; tail pointer of ED list
EDListCurrent	dw	0		; pointer to current ED
;
; Adapter's infomation
;
BusType 	db	0
even
VendorID        dw      0
DeviceID        dw      0
PCIBusDevFunc	dw	0		;PCI bus & device function #
IOBase		dw	0		;adapter's base IO
ROMBase 	dw	0		;ROM base address
IRQNumber	db	0		;IRQ number
Node_Address	db	6 dup(0)	;adapter's permanent MAC address
Net_Address	db	6 dup(0)        ;MAC address in use
;
MultiCast_Addresses	Eth_MCastBuf <>
;
ForcedInt	db	0
NeedIndComplete	db	0
InProcessRxInt	db	0       ; flag to prevent re-entering this subroutine
;
RecFilter	dw	0
TxType		dw	0
;
SubSystem_Id     dd      0       ; extra info MS wanted
;
; STATE MACHINE INFORMATION     by Jon
;
SimulateInterrupts  db  0   ; set by adapter code if it needs ints simulated
IsOpen              db  0   ; when non-zero means the adapter is "Open" to Tx or Rx
IsInitialized		db	0	; set on UNDI_Initialize, clr on UNDI_Shutdown
InAdapterIsr        db  0   ; flag to prevent reentering ISR
NicIntsEnabled      db  0   ; driver code should set & clr this to let us know
                            ; when hardware interrupts from the nic are enabled
                            ; so we can use that info when deciding to chain to
                            ; previous interrupt handlers

;;IFDEF   _VERBOSE

msg_Entry   db  " Entering UNDI ",0
msg_Exit    db  " Exiting UNDI ",0dh,0ah,0
msg_CRLF    db  0Dh,0Ah,0

IFDEF _VERBOSE

msg_callNADInit     db  "Calling NADInit...",NULL
msg_callNADOpen     db  "Calling NADOpen...",NULL
msg_callNADClose    db  "Calling NADClose...",NULL
msg_callNADReset    db  "Calling NADReset...",NULL
msg_callNADSetFilter db "Calling NADSetFilter...",NULL
msg_callNADShutDown db  "Calling NADShutDown...",NULL
msg_callNADMCast    db  "Calling NADMCastChange...",NULL
msg_callNADGetStats db  "Calling NADGetStatistics...",NULL
msg_callNADTransmit db  "Calling NADTransmitPacket...",NULL
msg_callNADDriverISR db " ISR++.",NULL

msg_NADInitOK   db  "NADInit returns Success!",CR,LF,NULL
msg_NADInitErr  db  "ERROR: NADInit returned failure!",CR,LF,NULL

msg_NADOpenOK   db  "NADOpen returns Success!",CR,LF,NULL
msg_NADOpenErr  db  "ERROR: NADOpen returned failure!",CR,LF,NULL

msg_NADCloseOK   db  "NADClose returns Success!",CR,LF,NULL
msg_NADCloseErr  db  "ERROR: NADClose returned failure!",CR,LF,NULL

msg_NADResetOK   db  "NADReset returns Success!",CR,LF,NULL
msg_NADResetErr  db  "ERROR: NADReset returned failure!",CR,LF,NULL

msg_NADShutDownOK   db  "NADShutDown returns Success!",CR,LF,NULL
msg_NADShutDownErr  db  "ERROR: NADShutDown returned failure!",CR,LF,NULL

msg_NADSetFilterOK  db  "NADSetFilter returns Success!",CR,LF,NULL
msg_NADSetFilterErr db  "ERROR: NADSetFilter returned failure!",CR,LF,NULL

msg_NADMCastChangeOK  db  "NADMCastChange returns Success!",CR,LF,NULL
msg_NADMCastChangeErr db  "ERROR: NADMCastChange returned failure!",CR,LF,NULL

msg_NADGetStatOK    db  "NADGetStatistics returns Success!",CR,LF,NULL
msg_NADGetStatErr   db  "ERROR: NADGetStatistics returned failure!",CR,LF,NULL

msg_NADTransmitOK    db  "NADTransmit returned success!",CR,LF,NULL
msg_NADTransmitErr   db  "NAD DriverISR_Proc returned failure!",CR,LF,NULL

msg_NADIsrOK        db  "--ISR(ok) ",NULL
msg_NADIsrErr       db  "--ISR(err)",NULL


ENDIF

IFDEF _DEBUG
            ORG 0FFFh
            db  0CCh
ENDIF

_DATA	ends
;******************************************************************************
_BSS	segment
;
; Receiving buffer for ED
;

dummy		dw	0	;don't delete this in order to let offset RxEDs
				;   non-zero
public	RxEDs
RxEDs		db	(size ED_Struct + MTU) * NUM_ED dup (?) ;ED list & data buffer

;
; Transmit data variables
;
public	TxED
TxED		ED_Struct <?>		; provide 9 additional fragments
TxFrags 	Frag	9 dup (<?>)	;  for a total of 10 ED fragments
MediaHeader	db	14 dup (?)	; destination, source, typelength
					;  we only build and include this
					;  header if protocol !=0

_BSS	ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\br\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\br\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\ara\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\sources.inc ===
TARGETNAME=data
TARGETTYPE=NOTARGET
TARGETPATH=obj
SOURCES=
!IF $(386)
NTTARGETFILE0=make_data
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\br\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\ara\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\chs\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\bootfloppy\src\undi\smc9432\lm9432.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       LM9432.ASM    (C) Copyright 1995 Standard Microsystems Corp.
;                       All rights reserved.
;
;*                Contains confidential information and                     *
;*                     trade secrets proprietary to:                        *
;*                                                                          *
;*                  Standard MicroSystems Corporation                       *
;*                            6 Hughes	  
;*                           Irvine, CA                                     *
;
;       LMI lower routine assembly source file for 
;       Ethernet 9432 PCI adapter.
;
;$History: LM9432.ASM $
; 
; *****************  Version 1  *****************
; User: Paul Cowan   Date: 26/08/98   Time: 9:31a
; Created in $/Client Boot/NICS/SMC/9432/UNDI
;
;
;$NoKeywords: $
;
;       Author: najay
;	Date: 2/14/95
;
; By         Date     Ver.   Modification Description
; ------------------- -----  --------------------------------------
;
; Revision Log:
; $Log:   G:\sweng\src\lm9432\vcs\lm9432.avm  $
;  
;     Rev 1.79   24 Nov 1997 16:48:40   cosand
;  Changed init_etx_threshold to use the current tx descriptor rather than
;  making the first tx descriptor point to itself.  This fixes a problem with
;  LM_Send failing when check_bnc_port is called before init_etx_threshold
;  is called.
;  Changed epic_auto_detect to set line_speed to LINE_SPEED_10 when BNC is
;  being used.
;  Modified check_bnc_port to make it work when CODE_386 is defined.
;  
;     Rev 1.78   06 Nov 1997 13:49:54   cosand
;  Modified init_mii_registers, epic_auto_detect, and LM_Service_Events,
;  and added handle_phy_event and check_bnc_port to support the 9432BTX.
;  
;     Rev 1.77   11 Sep 1997 13:41:06   cosand
;  Added the routines init_tdk_phy and Ronnie Kunin's
;  read_phy_OUI, modified init_mii_registers and
;  handle_nway_complete to support the TDK 2120 PHY.
;  
;     Rev 1.76   05 Aug 1997 12:23:12   cosand
;  Changed all writes to the General Control and Non-Volatile Control
;  registers from 16 bits to 32 bits to avoid enabling unwanted features
;  in Epic XF.
;  
;     Rev 1.75   07 Jul 1997 18:54:08   cosand
;  In init_mii_registers added a delay which is executed when the SCRAMBLE
;  bit is set in adapter_flags1.  This delay allows the ScrambleOn keyword
;  to work reliably with the Synoptics Switch Model 28115 (Bay Networks Design).
;  
;     Rev 1.74   28 Mar 1997 13:47:24   ANDERS
;  In init_etx_idle backed out code that cleared transmit interrupt
;  status bits.  Since init_etx_idle is called by other parts of the 
;  LMAC besides init_etx_threshold, this change had caused the DOS ODI
;  driver to lose a transmit interrupt.
;  
;     Rev 1.73   27 Mar 1997 11:29:44   ANDERS
;  Test SCRAMBLE bit in AdapterStructure variable "adapter_flags1" &
;  if set execute scramble code.  Default is to NOT execute this code.
;  This applies to both the init_mii_registers & handle_nway_complete
;  routines.
;  The init_tx_queues routine will now check the EARLY_TX bit in the
;  "adapter_flags" variable of the AdapterStructure & only enable Early
;  Transmit if this bit is set.  This is for the EarlyTxOff keyword support.
;  In init_nic routine, output value from AdapterStructure variable "burstlen"
;  to EPC_PBLCNT (18h).  Default is 0, but may be changed by BurstLength
;  keyword.
;  In the same routine, test AdapterStructure variable "adapter_flags1" for
;  the READ_MULT bit being set & if set, set the GC_RD_MULT bit in the
;  "gen_cntl" variable of the AdapterStructure.  This later gets loaded to
;  the EPC_GEN_CONTROL register (0ch).
;  The init_etx_threshold routine has be restored to its original algorithem,
;  using 16 as the default threshold value.  In the init_etx_idle routine
;  clear transmit interrupt status bits before returning
;  
;     Rev 1.73   26 Mar 1997 15:06:16   ANDERS
;  Scramble code will not be executed unless SCRAMBLE bit in "adapter_flags"
;  is set.
;  Early transmit will not be enabled unless EARLY_TX in "adapter_flags" is set.
;  The register EPC_PBLCNT will loaded from the  "burstlen" adapterstructure
;  variable which is set by the UMAC.
;  
;     Rev 1.72   10 Mar 1997 11:29:10   cosand
;  Changed init_mii_registers and handle_nway_complete to toggle the
;  Scramble Disable bit in Mercury register 31.  This is a software
;  workaround for a bug in the Mercury PHY in which the 9432TX can't
;  receive data when it is connected to a Bay Networks Baystack 100.
;  
;     Rev 1.71   04 Mar 1997 15:55:00   ANDERS
;  If DEFed out call to LM_Enable_Adpater in LM_Initialize_Adpater routine if
;  CODE_386 is defined.  Instead return rax=SUCCESS to fix bug found in DOS
;  Client32 where interrupts were enabled before interrupt vector was set.
;  In init_etx_threshold routine load EPC_XMIT_COPY_THRESH register with a
;  default of 40 (was 16), the exit without doing Early Transmit adjustment
;  as this routine wasn't working (stop-gap fix to release 32 bit odi driver)
;  
;     Rev 1.70   26 Feb 1997 17:26:20   cosand
;  Changed init_mii_registers to make the PHY drop link before forcing
;  it to a particular speed.  If we are connected to an nway device,
;  this will cause it to renegotiate.  Changed init_nic to not enable
;  the GP2 interrupt when Auto-Negotiation is off.  
;  
;     Rev 1.69   20 Feb 1997 14:59:58   ANDERS
;  Changed all CX register references used in any type of "loop" or
;  "dec" counter to RCX macro that defines CX to be 16 bits or 32 bits
;  depending on if CODE_386 is defined for the conditional assembly
;  
;     Rev 1.68   14 Feb 1997 18:46:08   cosand
;  Changed init_mii_registers to write a zero (was 2000h) to the PHY Basic
;  Mode Control Register before enabling nway to prevent the Mercury PHY
;  from sending runt packets on a 10Mbps network during initialization.
;  
;     Rev 1.67   05 Feb 1997 11:57:12   ANDERS
;  In LMSTRUCT.inc set default value of 9432 General Control register
;  to 0410h (was 0010h) to enable transmit DMA PCI "memory read multiple"
;  command.
;  
;     Rev 1.66   24 Jan 1997 18:19:34   cosand
;  Changed init_tx_queues and init_tx_threshold to correctly restore the
;  loopback mode select bits of the transmit control register.  This fixes a
;  bug in which init_tx_threshold was always switching the Epic out of full
;  duplex mode.
;  Removed all references to mode_bits, it is not being used by any umacs.
;  
;     Rev 1.65   22 Jan 1997 11:44:34   cosand
;  Changed version string.
;  
;     Rev 1.64   20 Jan 1997 17:26:10   cosand
;  Changed init_mii_registers to turn off bit 1 in Mercury PHY register 27
;  to improve long cable length performance.  Changed the PHY reset delay
;  counters in init_mii_registers from 80 to 80h.
;  
;     Rev 1.63   08 Jan 1997 19:14:46   cosand
;  Changed init_nic to enable the GP2 interrupt.
;  Changed init_mii_registers to enable the autonegotiation complete
;  interrupt in the Mercury PHY when MEDIA_TYPE_AUTO_NEGOTIATE is set
;  in media_type2.
;  Added the function handle_nway_complete.
;  Changed LM_Service_Events to call handle_nway_complete when a GP2
;  interrupt occurs.
;  Added a delay to init_mii_registers between resetting the PHY and
;  the first write to a PHY register to fix a problem with the Mercury
;  PHY not initializing properly in a Pentium Pro 200.
;  
;     Rev 1.62   31 Oct 1996 15:58:08   cosand
;  Added a hardware reset delay for the QSI 6612 to init_mii_registers.
;  
;     Rev 1.61   23 Aug 1996 09:34:12   ANDERS
;  update vers string to 1.26
;  in "init_nic" & "lm_service_events" when referencing int_mask changed
;  reg ax to eax because int reg definitions for XE chip use bits 23-27
;  
;     Rev 1.61   21 Aug 1996 14:13:06   COOKE_J
;  Updated LMAC version string to 1.26
;  
;     Rev 1.60   24 Jul 1996 11:53:18   STEIGER
;  Updated LMAC version string to 1.25.
;  
;     Rev 1.59   28 Jun 1996 16:08:32   STEIGER
;  Changed several loop counts in cx to rcx to fix perceived lockup and
;  slow loading problems.
;  
;     Rev 1.58   12 Jun 1996 17:17:46   NAJARIAN
;  fixed fragment-list issues
;  
;     Rev 1.56   14 Feb 1996 15:07:30   NAJARIAN
;  fixed cardbus OLD_MII problem
;  
;     Rev 1.55   14 Feb 1996 13:35:36   NAJARIAN
;  fixed cardbus (OLD_MII) build
;  
;     Rev 1.54   13 Feb 1996 11:12:34   NAJARIAN
;  fixed early_rx bug which posted invalid packet lengths
;  
;     Rev 1.53   09 Feb 1996 11:17:58   NAJARIAN
;  fixed txugo code
;  
;     Rev 1.52   08 Feb 1996 17:19:36   NAJARIAN
;  added ENABLE_TX_PENDING no enabled fixes
;  
;     Rev 1.51   29 Jan 1996 15:00:20   NAJARIAN
;  added workaround for 'no erx on offset' hardware issue
;  
;     Rev 1.50   26 Jan 1996 09:50:14   NAJARIAN
;  reordered two lines in LM_Receive_Copy
;  
;     Rev 1.49   25 Jan 1996 16:29:18   NAJARIAN
;  fixed pending code in lm_receive_copy
;  
;     Rev 1.48   23 Jan 1996 16:03:58   NAJARIAN
;  removed extraneous tx_retry variable
;  
;     Rev 1.47   23 Jan 1996 15:46:00   NAJARIAN
;  fixed jump polarity problem in init_etx_threshold
;  
;     Rev 1.0   23 Jan 1996 15:44:46   NAJARIAN
;  Initial revision.
;  
;     Rev 1.46   23 Jan 1996 13:36:10   NAJARIAN
;  added early transmit preinitialization code
;  
;     Rev 1.45   19 Jan 1996 18:21:04   NAJARIAN
;  fixed receive routing algorithm
;  
;     Rev 1.44   18 Jan 1996 15:16:52   NAJARIAN
;  fixed push/pop sync problem in Open_Adapter with FREEBUF set
;  
;     Rev 1.43   18 Jan 1996 12:20:58   NAJARIAN
;  fixed packet size required code. The PACKET_SIZE_NOT_NEEDED declaration has 
;  removed from the LMAC. Not setting ENABLE_EARLY_RX will accomplish the same
;  functionality.
;  
;     Rev 1.42   17 Jan 1996 10:15:58   NAJARIAN
;  checked in the correct code this time.
;  
;     Rev 1.40   11 Jan 1996 11:01:50   NAJARIAN
;  fixed PKT_SIZE_NOT_NEEDED bug in LM_Service_Events. rbx was being
;  overwritten.
;  
;     Rev 1.39   05 Jan 1996 10:51:58   NAJARIAN
;  updated internal version number
;  
;     Rev 1.38   05 Jan 1996 10:44:22   NAJARIAN
;  added check on receive to route header copies and lm_receive_copy copies
;  
;     Rev 1.37   29 Dec 1995 13:54:52   ANDERSON
;  fixed lookahead version of lmse_receive_copy to correct packet status in bx.
;  
;     Rev 1.36   28 Dec 1995 11:49:22   NAJARIAN
;  fixed HARDWARE_FAILED return code in LM_Receive_Copy
;  
;     Rev 1.35   26 Dec 1995 10:58:10   CHAN_M
;  Added bounds to the wait for idle loops in LM_Close_Adapter.
;  
;     Rev 1.34   22 Dec 1995 21:56:28   CHAN_M
;  Added poll loops in LM_Close_Adapter to wait for EPIC to go idle. Without
;  these loops, resetting the epic after calling LM_Close_Adapter may lock up
;  the bus.
;  
;     Rev 1.33   21 Dec 1995 16:15:20   NAJARIAN
;  fixed lm_delete_group_address dup entry
;  
;     Rev 1.32   21 Dec 1995 16:14:00   NAJARIAN
;  fixed checkmultiadd endp typo
;  
;     Rev 1.31   21 Dec 1995 15:47:02   NAJARIAN
;  added HW_RX_FAILED return codes
;  
;     Rev 1.30   19 Dec 1995 10:56:08   NAJARIAN
;  added support for DOS ODI free buffer pool
;  added working tx underrun adjustment logic
;  added checks for rx lockup
;  added check for rxqueue not being set right (nextframe without rxqueue)
;  added several checks for bad status before calling the umac on receives
;  
;     Rev 1.29   09 Nov 1995 11:40:06   CHAN_M
;  Initialized pAS.num_rx_free_buffs to 0 in init_rx_queues.
;  
;     Rev 1.28   08 Nov 1995 16:16:00   NAJARIAN
;  added transmit retry logic
;  
;     Rev 1.27   07 Nov 1995 10:59:20   NAJARIAN
;  rearranged interrupt handling priority, fixed way TXUGO is handled
;  synchronized C and assembly code
;  
;     Rev 1.26   03 Nov 1995 15:24:24   NAJARIAN
;  fixed EVENTS_DISABLE bug in receive interrupt handler.
;  
;     Rev 1.25   19 Oct 1995 12:27:14   ANDERSON
;  fixed getver string to LM_9432_s2.2_v1.12.
; Change: fixed getver string to LM_9432_s2.2_v1.12.
;  
;     Rev 1.24   19 Oct 1995 11:21:12   NAJARIAN
;  fixed backoff timer initialization bug
;  
;     Rev 1.23   02 Oct 1995 19:24:42   NAJARIAN
;  fixed receive status posting stuff in lm_service_events
;  
;     Rev 1.22   02 Oct 1995 18:37:12   NAJARIAN
;  reordered code
;  
;     Rev 1.21   02 Oct 1995 18:17:26   NAJARIAN
;  fixed header copy problem
;  
;     Rev 1.20   02 Oct 1995 18:00:28   NAJARIAN
;  fixed ipxload lockup/data miscompare problem. Fixed Tx pending/Packetsize
;  0 problems.
;  
;     Rev 1.19   27 Sep 1995 10:01:34   NAJARIAN
;  fixed ENABLE_TX_PENDING and call_umac labels
;  
;     Rev 1.18   25 Sep 1995 14:46:56   NAJARIAN
;  fixed wait polarity on lm_send. Removed EZSTART stuff
;  
;     Rev 1.17   25 Sep 1995 14:33:20   NAJARIAN
;  added PKT_SIZE_NOT_NEEDED support. added ENABLE_TX_PENDING support. made
;  minor editing changes.
;  
;     Rev 1.16   19 Sep 1995 16:38:20   NAJARIAN
;  fixed version string
;  
;     Rev 1.15   18 Sep 1995 14:59:26   NAJARIAN
;  added sweng doc compliant function headers. Fixed bug in LM_Add_Multi_Addr
;  that would prevent multicast address from being added correctly.
;  
;     Rev 1.14   08 Sep 1995 15:34:32   CHAN_M
;  Fixed bug in initializing MII port
;  Fixed RX OVW processing
;  
;     Rev 1.13   29 Aug 1995 18:26:58   CHAN_M
;  Fixed bug in receiving multicast frames.
;  
;     Rev 1.12   29 Aug 1995 17:36:18   CHAN_M
;  Changed physical layer chip addr. to 3 for new boards.
;  Added support for MII port and auto detection between the 2 ports.
;  Added media_type2 and line_speed in lmstruct.inc
;  DMA complete is always checked once even if ENABLE_RX_PENDING is not on.
;  Made the IO loop for RX DMA complete less tight to allow DMA to proceed.
;  Added check for available TX descriptors before performing transmit.
;  Added optional code for transmit with double copy for performance evaluation.
;  
;     Rev 1.11   07 Aug 1995 16:52:50   NAJARIAN
;  added delay in init_nic
;  
;     Rev 1.10   28 Jul 1995 14:25:22   CHAN_M
;  Fixed bug in LM_Change_Receive_Mask reported by Fred K.
;  Reimplemented NWAY for the new boards.
;  
;     Rev 1.9   24 Jul 1995 13:38:58   CHAN_M
;  added error counters.
;  
;     Rev 1.8   20 Jul 1995 11:36:26   CHAN_M
;  1. Took out workaround code for xmit.
;  2. Stopped rx before changing receive control reg.
;  3. Fixed send complete logic to process all outstanding xmit frames during
;  xmit complete interrupt.
;  
;     Rev 1.7   17 Jul 1995 20:11:38   CHAN_M
;  1. Implemented Free Buffer Pool receive mechanism.
;  2. Implemented NWAY for National DP83840 PHY chip.
;  3. Implemented mechanism to set IAF when the transmit q is almost full.
;  
;     Rev 1.6   19 Jun 1995 17:34:48   CHAN_M
;  The tx_curr_off pointer (the last completed tx packet in the chain) is saved
;  before calling UM_Send_Complete.
;  Fixed the problem of q'ing the next receive descriptor twice when
;  ENABLE_RX_PENDING is not turned on.
;  
;     Rev 1.5   05 Jun 1995 16:17:06   CHAN_M
;  Unmasked Transmit Chain Complete in Interrupt Mask register.
;  Added check for NW_STATUS_VALID in Rx Status before checking CRC & FAE error
;  bits.
;  
;     Rev 1.4   05 Jun 1995 16:03:44   STEIGER
;  Set save errored packets bit in RX config register when early rx is enabled.
;  Added code to set appropriate status in AX on call to UM_Receive_Copy_Complete.
;  
;     Rev 1.3   05 Jun 1995 15:10:00   STEIGER
;  Fixed double instances of INT_RCV_ERR constant.
;  
;     Rev 1.2   17 May 1995 15:19:14   NAJARIAN
;  added 386 support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IFDEF DEBUG
db              '@(#) LM_9432_s3.01_x1.44',0,'$'
ELSE
db              '@(#) LM_9432_s3.01_v1.44',0,'$'
ENDIF

DEBUG_ADDR      equ     0ec99h
;OLD_MII		equ	0
;DOUBLE_COPY_TX	equ	0

ETX_CUTOFF	equ	500
ETX_MAX_THRESH	equ	1518

;****************************************************************************
;
; Function:     Debug_Call
;
; Synopis:      Cause a software debugger to breakpoint
;
; Input:        None
;
; Output:       None
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

public Debug_call
Debug_call      proc    far
		push    dx
		push    ax
		mov     dx, DEBUG_ADDR
		in      al, dx
		pop     ax
		pop     dx
		int 3
		iret
Debug_call      endp

;****************************************************************************
;
; Function:     LM_Add_Multi_Address    
;
; Synopis:      Adds Multicast address in adapter structure to
;               Multicast address table.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Add_Multi_Address

		push    edi
		push    esi
		push    ecx
		push    ebx
		PUSH_ES
		cld

		mov     rax, SUCCESS             ; Preset return code

ifndef CODE_386
		push    ds
		pop     es                      ; ES = DS
endif
		lea     rdi, pAS.mc_table
		mov     rcx, MC_TABLE_ENTRIES    ; CL == max number of
						; entries in table

AroundTheWorld:
		lea     rsi, pAS.multi_address
		push    edi
		push    ecx
		mov     rcx, 3
		repz    cmpsw
		pop     ecx
		pop     edi
		jnz     DoYerNeighbor
		cmp     byte ptr [rdi+6], 0ffh  ; If instance count >= 0ffh,
						; entry is maxed out.
		je      McTableFull
		inc     byte ptr [rdi+6]        ; Increment instance_count
		jmp     AddMultiDone            ; All Done

DoYerNeighbor:  
		add     rdi, 7                  ; Point to next address
		loop    AroundTheWorld          ; Check all addresses.
						; No match found, find
						; first empty table entry
		mov     rcx, MC_TABLE_ENTRIES    ; and insert address there
		lea     rdi, pAS.mc_table

CheckForEmpty:
		mov     bl, [rdi+6]              ; Check instance count for
		cmp     bl, 0                   ; this address.
		je      add_address             ; If instance count == 0
						; copy address to this space.
		add     rdi, 7                   ; Point to next address
		loop    CheckForEmpty           ; Loop for all entries.
		jmp     McTableFull             ; If no empty entries, bail out

add_address:    lea     rsi, pAS.multi_address
		mov     rcx, 3
		rep     movsw
		inc     byte ptr [rdi]           ; Increment instance_count
		jmp     AddMultiDone

McTableFull:    mov     rax, OUT_OF_RESOURCES

AddMultiDone:
		POP_ES
		pop     ebx
		pop     ecx
		pop     esi
		pop     edi

		ret

ASM_PCI_PROC_END        LM_Add_Multi_Address


;****************************************************************************
;
; Function:     set_CAM_registers	
;
; Synopis:      set the receive control registers from
;				the receive mask values
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

set_CAM_registers proc near
		push	dx

		mov	dx, pAS.io_base
		add	dx, EPC_MC_HASH_TABLE1

; delete for initial testing
		test	pAS.receive_mask, ACCEPT_MULTI_PROM
;		jz	no_multiprom

; set all multi bits to one
		mov	ax, 0ffffh
		out	dx, ax
		add	dx, EPC_MC_HASH_TABLE2 - EPC_MC_HASH_TABLE1
		out	dx, ax
		add	dx, EPC_MC_HASH_TABLE3 - EPC_MC_HASH_TABLE2
		out	dx, ax
		add	dx, EPC_MC_HASH_TABLE4 - EPC_MC_HASH_TABLE3
		out	dx, ax
			
set_CAM_done:
		pop	dx
		ret

no_multiprom:
		jmp	set_CAM_done

set_CAM_registers endp

;****************************************************************************
;
; Function:     set_receive_mask	
;
; Synopis:      set the receive control registers from
;		the receive mask values
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

set_receive_mask proc	near
		push	dx

		mov	dx, pAS.io_base
		add	dx, EPC_RECEIVE_CONTROL
		
		mov	ax, 0
		test	pAS.receive_mask, ACCEPT_MULTICAST or ACCEPT_MULTI_PROM
		jz	itx_nomulticast
		or	ax, RC_RCV_MULTICAST

itx_nomulticast:
		test	pAS.receive_mask, ACCEPT_BROADCAST
		jz	itx_nobroadcast
		or	ax, RC_RCV_BROADCAST

itx_nobroadcast:
		test	pAS.receive_mask, PROMISCUOUS_MODE
		jz	itx_nopromiscuous
		or	ax, RC_PROMISCUOUS_MODE

itx_nopromiscuous:
		test	pAS.receive_mask, ACCEPT_ERR_PACKETS
		jz	itx_noerrors
		or	ax, RC_RCV_ERRORED or RC_RCV_RUNT

itx_noerrors:
		test	pAS.receive_mask, EARLY_RX_ENABLE
		jz	itx_noerx
		or	ax, RC_EARLY_RECEIVE_ENABLE or RC_RCV_ERRORED

itx_noerx:
		out	dx, ax

; set receive lookahead size
		add	dx, EPC_RCV_COPY_THRESH - EPC_RECEIVE_CONTROL
		movzx	ax, pAS.rx_lookahead_size
		shl	ax, 4				; 16 byte increment
		out	dx, ax

		call	set_CAM_registers

		pop	dx
		ret

set_receive_mask endp

;****************************************************************************
;
; Function:     LM_Change_Receive_Mask
;
; Synopis:      Change the EPIC/100 receive configuration
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Change_Receive_Mask

		mov	ax, pAS.adapter_status
		cmp     ax, NOT_INITIALIZED
		jne     LM_Ch_Stat_ok
		mov     rax, ADAPTER_NOT_INITIALIZED
		jmp     LM_Ch_Msk_Done

LM_Ch_Stat_ok:
		cmp	ax, OPEN
		jnz	LM_Ch_rx_disabled

		push	dx
		push	rcx
IFNDEF CODE_386
		push	eax
ENDIF

; wait for rx idle first
		mov	dx, pAS.io_base
		mov	ax, CMD_STOP_RDMA or CMD_STOP_RX
		out	dx, ax
		add	dx, EPC_INT_STATUS

		mov	rcx, 800h

LM_Ch_wait_for_idle:
		dec	rcx
		jz	LM_Ch_Msk_failed
		push	rcx
		mov	rcx, 80h
		loop	$
		pop	rcx
		in	eax, dx
		test	eax, INT_RCV_IDLE
		jz	LM_Ch_wait_for_idle

IFNDEF CODE_386
		pop	eax
ENDIF
		pop	rcx
		pop	dx

LM_Ch_rx_disabled:
		call	set_receive_mask

LM_Ch_Msk_Done:
		cmp	pAS.adapter_status, OPEN
		jnz	LM_Ch_Msk_ret

		push	dx
		mov	dx, pAS.io_base
		mov	ax, CMD_START_RX or CMD_RXQUEUED
		out	dx, ax
		pop	dx
LM_Ch_Msk_ret:
		mov     rax, SUCCESS
		ret

LM_Ch_Msk_failed:
IFNDEF CODE_386
		pop	eax
ENDIF
		pop	rcx
		pop	dx
		
		mov	rax, HARDWARE_FAILED
		ret

ASM_PCI_PROC_END        LM_Change_Receive_Mask


;****************************************************************************
;
; Function:     LM_Close_Adapter        
;
; Synopis:      Closes adapter whose adapter structure is
;               indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Close_Adapter

		cmp     pAS.adapter_status, NOT_INITIALIZED
		jne     StatusOK
		mov     rax, ADAPTER_NOT_INITIALIZED
		jmp     NoStatusChange
					
StatusOK:
		call	LM_Disable_Adapter

		mov	dx, pAS.io_base
		add	dx, EPC_COMMAND
		mov	ax, CMD_STOP_RX or CMD_STOP_TDMA or CMD_STOP_RDMA
		out	dx, ax

		add	dx, EPC_INT_STATUS - EPC_COMMAND
IFNDEF CODE_386
		push	eax
ENDIF
		push	ecx
		mov	rcx, 1000h
lmc_wait_rx_idle:
		dec	rcx
		jz	lmc_start_wait_tx_idle
		in	ax, 61h
		in	ax, 61h
		in	eax, dx
		test	eax, INT_RCV_IDLE
		jz	lmc_wait_rx_idle

lmc_start_wait_tx_idle:
		mov	rcx, 1000h
lmc_wait_tx_idle:
		dec	rcx
		jz	lmc_tx_idle
		in	ax, 61h
		in	ax, 61h
		in	eax, dx
		test	eax, INT_XMIT_IDLE
		jz	lmc_wait_tx_idle

lmc_tx_idle:
		pop	ecx
IFNDEF CODE_386
		pop	eax
ENDIF

		mov	ax, 0ffffh
		out	dx, ax

		mov     pAS.adapter_status, CLOSED
		call    UM_Status_Change
		mov     rax, SUCCESS             ; Set return code
NoStatusChange:
		ret

ASM_PCI_PROC_END        LM_Close_Adapter

;****************************************************************************
;
; Function:     LM_Delete_Group_Address 
;
; Synopis:      returns INVALID_FUNCTION for Ethernet.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Delete_Group_Address

		mov     rax, INVALID_FUNCTION
		ret
ASM_PCI_PROC_END        LM_Delete_Group_Address


;****************************************************************************
;
; Function:     LM_Delete_Multi_Address 
;
; Synopis:      Removes Multicast address in adapter
;               structure from Multicast address table.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Delete_Multi_Address

		push    ecx
		push    edi
		push    esi
		PUSH_ES
		cld

		mov     rax, SUCCESS             ; Preset return code

ifndef CODE_386
		push    ds
		pop     es                      ; ES = DS
endif

		lea     rdi, pAS.mc_table
		mov     rcx, MC_TABLE_ENTRIES

FrootLoop:      lea     rsi, pAS.multi_address
		push    edi
		push    ecx
		mov     rcx, 3
		repz    cmpsw
		pop     ecx
		pop     edi
		jnz     TryNextDoor
		cmp     byte ptr [rdi+6], 0h    ; If instance count = 0h,
						; entry is alrady gone.
		je      McTableEmpty
		dec     byte ptr [rdi+6]        ; Decrement instance_count
		jmp     DeleteMultiDone         ; All Done

TryNextDoor:    add     rdi, 7                   ; Point to next address
		loop    FrootLoop               ; Check all addresses
						; If all entries checked and
						; no matches, bail out.

McTableEmpty:   mov     rax, OUT_OF_RESOURCES

DeleteMultiDone:
		POP_ES
		pop     esi
		pop     edi
		pop     ecx
		ret

ASM_PCI_PROC_END        LM_Delete_Multi_Address

;****************************************************************************
;
; Function:     LM_Disable_Adapter
;
; Synopis:      Disables adapter whose adapter structure is
;               indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Disable_Adapter
                push    eax
		push	dx
		mov	dx, pAS.io_base
		add	dx, EPC_GEN_CONTROL
		mov	eax, pAS.gen_cntl
		and	eax, NOT GC_INT_ENABLE
		out	dx, eax
		pop	dx
                pop     eax

		mov     rax, SUCCESS
		or      pAS.adapter_flags, ADAPTER_DISABLED
		ret

ASM_PCI_PROC_END        LM_Disable_Adapter

;****************************************************************************
;
; Function:     LM_Enable_Adapter
;
; Synopis:      Enables adapter whose adapter structure is
;		                  indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Enable_Adapter
                push    eax
		push	dx
		mov	dx, pAS.io_base
		add	dx, EPC_GEN_CONTROL
		mov	eax, pAS.gen_cntl
		or	eax, GC_INT_ENABLE
		out	dx, eax
		pop	dx
                pop     eax

		mov     rax, SUCCESS
		and     pAS.adapter_flags, not ADAPTER_DISABLED
		ret

ASM_PCI_PROC_END        LM_Enable_Adapter

;****************************************************************************
;
; Function:     LM_Get_Host_Ram_Size       
;
; Synopis:      Returns the size of Host Ram to allocate
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

IFDEF FREEBUFF
ASM_PCI_PROC		LM_Get_Host_Ram_Size
	push	cx
	push	dx
	mov	cx, pAS.num_of_tx_buffs
	add	cx, pAS.num_of_rx_buffs
	mov	ax, SIZE DMA_FRAG
	add	ax, DMA_FRAG_SIZE
	mul	cx

IFDEF DOUBLE_COPY_TX
	push	ax
	mov	ax, 1520
	sub	ax, DMA_FRAG_SIZE
	mov	cx, pAS.num_of_tx_buffs
	mul	cx
	mov	cx, ax
	pop	ax
	add	ax, cx
ENDIF
	pop	dx
	pop	cx
	ret
ASM_PCI_PROC_END	LM_Get_Host_Ram_Size
ENDIF


;****************************************************************************
;
; Function:     reset_nic       
;
; Synopis:      Resets the NIC on the adapter whose adapter structure
;                       is indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

reset_nic       proc    near
		push	dx
		mov	dx, pAS.io_base
		add	dx, EPC_GEN_CONTROL
		mov	eax, GC_SOFT_RESET
		out	dx, eax

; delay for ~ 1 us
; EPIC needs at least 15 internal clocks after initialization before
; it can be accessed. This is intel specific - it needs to be modified for
; the target OS
		in	al, 061h
		in	al, 061h
		in	al, 061h
		in	al, 061h
		in	al, 061h

		add	dx, EPC_TEST - EPC_GEN_CONTROL
		mov	ax, TEST_CLOCK
		out	dx, ax
		pop	dx
		ret

reset_nic       endp

;****************************************************************************
;
; Function:     init_tx_queues
;
; Synopis:      Initialize the transmit queues on the NIC
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

init_tx_queues  proc    near
		PUSH_ES
		push	eax
		push	ebx
		push	ecx
		push	edx
		push	esi
		push	edi

; initialize tx host memory
		mov	rbx, RWORD ptr pAS.host_ram_virt_addr	
		mov	edx, pAS.host_ram_phy_addr
		mov	rsi, rbx
		mov	pAS.tx_first_off, rbx
		mov	pAS.tx_curr_off, rbx
		movzx	ecx, pAS.num_of_tx_buffs
		mov	pAS.tx_free_desc_count, cx

init_txdma:
		mov	dword ptr [rbx].dma_status, 0
		mov	dword ptr [rbx].dma_buf_len, 0
		add	edx, size DMA_FRAG
		add	rsi, size DMA_FRAG
		mov	[rbx].dma_next_phys, edx
		mov	[rbx].dma_next_off, rsi
		add	rbx, size DMA_FRAG
		loop	init_txdma

; fix up loop
		sub	rbx, size DMA_FRAG
		mov	eax, pAS.host_ram_phy_addr
		mov	[rbx].dma_next_phys, eax
		mov	rax, RWORD ptr pAS.host_ram_virt_addr
		mov	[rbx].dma_next_off, rax

; init frag lists
		mov	rbx, RWORD ptr pAS.host_ram_virt_addr	
		mov	rdi, rbx 			; get txdma offset
		mov	edx, pAS.host_ram_phy_addr
		mov	eax, size DMA_FRAG
		xor	ecx, ecx
		mov	cx, pAS.num_of_tx_buffs
		add	cx, pAS.num_of_rx_buffs
		push	edx
		mul	ecx
		pop	edx

		add	rbx, rax
		add	edx, eax
		movzx	ecx, pAS.num_of_tx_buffs

tx_fraglist_loop:
		mov	dword ptr [rbx].fragment_count, 0
		mov	[rdi].dma_buf_addr, edx
		mov	[rdi].dma_buff_off, rbx
IFDEF DOUBLE_COPY_TX
		add	rbx, 1520
		add	edx, 1520
ELSE
		add	rbx, DMA_FRAG_SIZE
		add	edx, DMA_FRAG_SIZE
ENDIF
		add	rdi, size DMA_FRAG
		loop	tx_fraglist_loop

; initialize tx epic regs 		
		mov	dx, pAS.io_base
		add	dx, EPC_TRANSMIT_CONTROL				
		mov	bx, pAS.slot_timer		; slot timer
		shl	bx, 3
		mov	ax, bx
                test    pAS.line_speed, LINE_SPEED_FULL_DUPLEX
                jz      init_tx_half_duplex
                or      ax, TC_FULL_DUPLEX
init_tx_half_duplex:
; flag in "adapter_flags" must be set by UMAC to enable "early transmit"
		test	pAS.adapter_flags, EARLY_TX
		jz	init_tx_no_e_tx
		or	ax, TC_EARLY_XMIT_ENABLE
init_tx_no_e_tx:
		out	dx, ax

; zero out retry count
		mov	pAS.tx_pend, 0

; set the start of tx desc area
		add	dx, EPC_XMIT_CURR_DESC_ADDR - EPC_TRANSMIT_CONTROL
		mov	eax, pAS.host_ram_phy_addr
		out	dx, eax

		pop	edi
		pop	esi
		pop	edx
		pop	ecx
		pop	ebx
		pop	eax
		POP_ES

		ret

init_tx_queues  endp

;****************************************************************************
;
; Function:     init_rx_queues   
;
; Synopis:      Initialize the receive queues on the NIC
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

init_rx_queues  proc    near
		PUSH_ES
		push	eax
		push	ebx
		push	ecx
		push	edx
		push	esi
		push	edi

; init recv host memory
		mov	rbx, RWORD ptr pAS.host_ram_virt_addr	
		mov	edx, pAS.host_ram_phy_addr
		mov	eax, SIZE DMA_FRAG
		movzx	ecx, pAS.num_of_tx_buffs
		push	edx
		mul	ecx
		pop	edx
		add	edx, eax
		add	rbx, rax
		push	edx		; save rx_dma phys addr
		push	rbx		; save rx_dma virtual addr
		mov	rsi, rbx
		mov	pAS.rx_curr_lookahead, rbx
		mov	pAS.rx_curr_fraglist, rbx
IFDEF	FREEBUFF
		mov	pAS.rx_last_fraglist, rbx
		mov	pAS.num_rx_free_buffs, 0
		mov	eax, XDMA_FRAGLIST
ELSE
		movzx	eax, pAS.rx_lookahead_size
		shl	eax, 4				; 16 byte increment
		or	eax, RDMA_HEADER
ENDIF
		movzx	ecx, pAS.num_of_rx_buffs

init_rxdma:
		mov	dword ptr [rbx].dma_status, 0
		mov	dword ptr [rbx].dma_buf_len, eax
		add	edx, size DMA_FRAG
		add	rsi, size DMA_FRAG
		mov	[rbx].dma_next_phys, edx
		mov	[rbx].dma_next_off, rsi
		add	rbx, size DMA_FRAG
		loop	init_rxdma

; fix up loop
		sub	rbx, size DMA_FRAG

		pop	rax			; pop rx_dma virtual addr
		mov	[rbx].dma_next_off, rax
		pop	eax			; pop rx_dma phys addr
		mov	[rbx].dma_next_phys, eax

; init frag lists
		push	eax				; save rx_dma phys addr
		mov	edx, eax			; rx_dma phys addr
		mov	rbx, pAS.rx_curr_fraglist	; rx_dma virtual addr
		mov	rdi, rbx

		mov	eax, size DMA_FRAG
		movzx	ecx, pAS.num_of_rx_buffs
		push	edx
		mul	ecx
		pop	edx
		add	edx, eax			; tx_frag phys addr
		add	rbx, rax			; tx_frag virt addr

IFDEF DOUBLE_COPY_TX
		mov	eax, 1520
ELSE
		mov	eax, DMA_FRAG_SIZE
ENDIF
		movzx	ecx, pAS.num_of_tx_buffs
		push	edx
		mul	ecx
		pop	edx
		add	edx, eax			; rx_frag phys addr
		add	rbx, rax			; rx_frag virt addr

		movzx	ecx, pAS.num_of_rx_buffs

fraglist_loop:
		mov	dword ptr [rbx].fragment_count, 0
		mov	[rdi].dma_buf_addr, edx
		mov	[rdi].dma_buff_off, rbx
		add	rbx, DMA_FRAG_SIZE
		add	edx, DMA_FRAG_SIZE
		add	rdi, size DMA_FRAG
		loop	fraglist_loop

		mov	pAS.tx_scratch, edx	
ifndef FREEBUFF
; init first frag area
		mov	rbx, pAS.rx_curr_lookahead
		mov	dword ptr [rbx].dma_status, RDMA_OWNER_STATUS
endif

; wait for rx idle first
		mov	dx, pAS.io_base
		mov	ax, CMD_STOP_RDMA or CMD_STOP_RX
		out	dx, ax
		add	dx, EPC_INT_STATUS

		mov	rcx, 1000h
init_rx_wait_for_idle:
		dec	rcx
		jz	init_rx_set_rx_mask
		in	eax, dx
		test	eax, INT_RCV_IDLE
		jz	init_rx_wait_for_idle

; initialize rx epic regs
init_rx_set_rx_mask:
		call	set_receive_mask

; set the start of rx desc area
		mov	dx, pAS.io_base
		add	dx, EPC_RCV_CURR_DESC_ADDR
		pop	eax				; rx_dma phys addr
		out	dx, eax

		pop	edi
		pop	esi
		pop	edx
		pop	ecx
		pop	ebx
		pop	eax
		POP_ES

		ret

init_rx_queues  endp

;****************************************************************************
;
; Function:     init_nic        
;
; Synopis:      Initializes NIC on adapter whose adapter
;                       structure is indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************
	public	init_nic
init_nic        proc    near
		push	dx

; fix transmit backoff problem
		mov	dx, pAS.io_base
		add	dx, EPC_TRANSMIT_TEST
		mov	ax, 0
		out	dx, ax

		add	dx, EPC_INTERPACKET_GAP - EPC_TRANSMIT_TEST
		mov	ax, pAS.ipg_timer
		out	dx, ax

; Default value for EPC_PBLCNT reg is 0.  If keyword BurstLength detected
; by UMAC, the UMAC must load the BurstLength value to the AdapterStructure
; byte size variable "burstlen".
		add	dx, EPC_PBLCNT - EPC_INTERPACKET_GAP
		xor	ax, ax
		mov	al, pAS.burstlen
		out	dx, ax

		add	dx, EPC_INT_MASK - EPC_PBLCNT
IFDEF FREEBUFF
		mov	eax, PTA+PMA+APE+DPE+CNT+TXU+TXC+RXE+OVR+RCC+TCC
ELSE
	        mov	eax, PTA+PMA+APE+DPE+CNT+TXU+TXC+RXE+OVR+HCC+RCC+TCC
ENDIF
                test    pAS.media_type2, MEDIA_TYPE_AUTO_NEGOTIATE
                jz      skip_enable_GP2
                or      eax, GP2

skip_enable_GP2:
		mov	pAS.int_mask, eax	
		out	dx, eax

; Default to PCI "memory read" unless MemoryReadMultiple keyword has been
; detected.  If so, set PCI "memory read multiple" bit in gen_cntl variable
; that resides in adapter structure
		test	pAS.adapter_flags1, READ_MULT
		jz	rd_mult_not
		or	pAS.gen_cntl, GC_RD_MULT
rd_mult_not:

IFDEF OLD_MII
; set 10 or 100 mb outputs
		add	dx, EPC_NV_CONTROL - EPC_INT_MASK
		mov	ax, 0
		out	dx, ax				; disable everything

		mov	ax, NVC_GPOE2 or NVC_GPOE1	; set 100mb mode
		cmp	pAS.media_type, MEDIA_STP100_UTP100
		je	in_no10mb
		or	ax, NVC_GPIO1	; set 10mb mode

in_no10mb:
		out	dx, ax
ENDIF
		pop	dx
		ret

init_nic        endp

;****************************************************************************
;
; Function:     init_etx_idle
;
; Synopis:      poll for transmit to finish
;
; Input:        ds:bp (ebp)	AdapterStructure
;		dx		EPIC COMMAND reg
;
; Output:       eax		interrupt status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

init_etx_idle   proc    near
		push	rcx
		add	dx, EPC_INT_STATUS - EPC_COMMAND

; wait for transmitter to go idle

init_etx_wait:
		mov	rcx, 80h
		loop	$
		in	eax, dx
		test	eax, INT_XMIT_IDLE or INT_XMIT_QUEUE_EMPTY or INT_XMIT_UNDERRUN
		jz	init_etx_wait		

		add	dx, EPC_COMMAND - EPC_INT_STATUS
		pop	rcx
		ret

init_etx_idle	endp

;****************************************************************************
;
; Function:     init_etx_threshold
;
; Synopis:      sets an initial value for the early transmit
;		threshold.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

init_etx_threshold	proc	near
		push	dx
		push	rbx

; start with an early tx of 16
		mov	dx, pAS.io_base
		add	dx, EPC_XMIT_COPY_THRESH
		mov	ax, 16
		mov	pAS.early_tx_thresh, ax
		out	dx, ax

; if line speed is 10mb, no initial adjustment is needed
		cmp	pAS.line_speed, LINE_SPEED_10
		je	init_etx_end

; assume line speed is 100mb
; set the epic in loopback mode
		add	dx, EPC_TRANSMIT_CONTROL - EPC_XMIT_COPY_THRESH
		in	ax, dx
		and	ax, NOT TC_LOOPBACK_MODE
		or	ax, TC_INTERNAL_LOOPBACK
		out	dx, ax
					
; initialize one transmit buffer
;		mov	rbx, pAS.tx_first_off
;;;jcc
                mov     rbx, pAS.tx_curr_off
;;;jcc
;		push	[rbx].dma_next_phys	; save next pointer

;		mov	eax, pAS.host_ram_phy_addr
;		mov	[rbx].dma_next_phys, eax	; set one packet tx
		mov     ax, pAS.max_packet_size
                mov     [rbx].dma_buf_len, ax
                mov     [rbx].dma_len, ax
		add	dx, EPC_COMMAND - EPC_TRANSMIT_CONTROL

init_etx_loop:
                mov     [rbx].dma_status, XDMA_OWNER_STATUS
		mov	ax, CMD_TXQUEUED
		out	dx, ax

		call	init_etx_idle

; do early tx adjustment
		test	eax, INT_XMIT_UNDERRUN
		jz	init_etx_reset

; wait for txugo to clear (yech!)
init_etx_loop2:
		mov	ax, CMD_TXUGO
		out	dx, ax

; stop at end of current tx
		mov	ax, CMD_STOP_TDMA
		out	dx, ax

		call	init_etx_idle

		test	eax, INT_XMIT_UNDERRUN
		jnz	init_etx_loop2

		cmp	pAS.early_tx_thresh, ETX_MAX_THRESH
		ja	init_etx_reset

; update threshold
		add	dx, EPC_XMIT_COPY_THRESH - EPC_COMMAND
		add	pAS.early_tx_thresh, 4
		mov	ax, pAS.early_tx_thresh
		out	dx, ax
		add	dx, EPC_COMMAND - EPC_XMIT_COPY_THRESH
		jmp	init_etx_loop

; restore the transmit buffer
init_etx_reset:
; take epic out of loopback mode
		add	dx, EPC_TRANSMIT_CONTROL - EPC_COMMAND
		in	ax, dx
		and	ax, NOT TC_LOOPBACK_MODE
                test    pAS.line_speed, LINE_SPEED_FULL_DUPLEX
                jz      init_etx_half_duplex
                or      ax, TC_FULL_DUPLEX
init_etx_half_duplex:
		out	dx, ax

;		pop	[rbx].dma_next_phys
;;;jcc
; update the first and current transmit descriptor pointers
                mov     rbx, pAS.tx_curr_off
                mov     rbx, [rbx].dma_next_off
                mov     pAS.tx_first_off, rbx
                mov     pAS.tx_curr_off, rbx
;;;jcc

init_etx_end:
		pop	rbx
		pop	dx
		ret

init_etx_threshold	endp


;****************************************************************************
;
; Function:     init_mii_registers        
;
; Synopis:      Initializes PHY and related Epic registers.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

public init_mii_registers
init_mii_registers        proc    near

		push	eax
		push	dx
		push	bx
		push	ecx

IFDEF OLD_MII
		mov	dx, pAS.io_base
		add	dx, EPC_MII_CONFIG

		mov	eax, 0			; disable 10 and 100 mb
		out	dx, eax

; default to 100mb mode
		mov	eax, MII_SERIAL_MODE_ENABLE
		cmp	pAS.media_type, MEDIA_STP100_UTP100
		je	mii_100mb

; turn on 10 mb link light
		add	dx, EPC_MII_CONTROL - EPC_MII_CONFIG
		mov	eax, 0
		out	dx, eax
		add	dx, EPC_MII_CONFIG - EPC_MII_CONTROL

		mov	eax, MII_ENABLE_SMI or MII_SERIAL_MODE_ENABLE or MII_ENABLE_694
mii_100mb:
		out	dx, eax

init_mii_exit:
ELSE
; get mii phy organizationally unique identifier
                call    read_phy_OUI
                mov     pAS.phy_id, eax
                cmp     eax, 0000c039h
                jnz     init_mii_not_tdk_phy
                call    init_tdk_phy
                jmp     init_mii_exit

init_mii_not_tdk_phy:
                cmp     pAS.card_SSID, SSID9432BTX
                jnz     init_mii_check_nway
		test	pAS.media_type2, MEDIA_TYPE_AUTO_DETECT
                jnz     init_mii_auto_detect

init_mii_check_bnc:
		test	pAS.media_type2, MEDIA_TYPE_BNC
                jz      init_mii_check_nway
        	mov	dx, pAS.io_base
	        add	dx, EPC_MII_CONFIG              ; turn on BNC
                mov     ax, MII_ENABLE_SMI or MII_ENABLE_694 or MII_SERIAL_MODE_ENABLE
                out     dx, ax
		mov	bx, PHY_BMC_REG	                ; isolate mii and	
		mov	ax, PHY_ISOLATE                 ; turn off nway
		call	write_phy_register
                jmp     init_mii_fried

init_mii_auto_detect:
		call	epic_auto_detect
		test	pAS.media_type2, MEDIA_TYPE_BNC
                jnz     init_mii_enable_int
		test	pAS.media_type2, MEDIA_TYPE_UTP
                jz      init_mii_enable_int             ; jump if no media detected

init_mii_check_nway:
		test	pAS.media_type2, MEDIA_TYPE_AUTO_NEGOTIATE
		jz	init_mii_check_speed

		cmp	pAS.line_speed, LINE_SPEED_UNKNOWN
		jnz	init_mii_nway_complete

init_mii_reset_phy:
		mov	dx, pAS.io_base
		add	dx, EPC_NV_CONTROL
;		mov	eax, NVC_GPOE1 or NVC_GPIO1
		mov	eax, NVC_GPOE1                  ; drive gpio[1] low
		out	dx, eax                         ; required for 9432BTX

		add	dx, EPC_MII_CONFIG - EPC_NV_CONTROL
		mov	eax, MII_ENABLE_SMI
		out	dx, eax

		add	dx, EPC_GEN_CONTROL - EPC_MII_CONFIG
		mov	eax, pAS.gen_cntl
		or	eax, GC_HARD_RESET
		out	dx, eax

; the QSI 6612 requires a hardware reset to be at least 10 microseconds long
		mov	rcx, 80h
wait_for_reset:
                in      eax, dx
                loop    wait_for_reset
		and	eax, not GC_HARD_RESET
		out	dx, eax
; add delay after clearing GC_HARD_RESET as required by Mercury based
; adapters used on Pentium Pro 200 or similarly fast machines.
		mov	rcx, 80h
wait_for_reset_clear:
		jmp	$+2
		loop	wait_for_reset_clear

; The National PHY requires that something be written to the Basic Mode
; Control Register before enabling nway, or nway will not complete.
		mov	ax, 0
		mov	bx, PHY_BMC_REG
		call	write_phy_register

init_mii_start_nway:
		mov	ax, PHY_AN_ENABLE
		mov	bx, PHY_BMC_REG
		call	write_phy_register

		mov	ax, PHY_RESTART_AN or PHY_AN_ENABLE
		mov	bx, PHY_BMC_REG
		call	write_phy_register

		mov	ecx, 30000h
init_mii_nway_complete_loop:
		dec	ecx
		jz	init_mii_enable_int
		mov	bx, PHY_BMS_REG
		call	read_phy_register
		test	ax, PHY_AN_COMPLETE	;test for nway complete
		jz	init_mii_nway_complete_loop

init_mii_nway_complete:
		mov	bx, PHY_ANLPA_REG
		call	read_phy_register
		test	ax, PHY_100_BASE_TX_HD or PHY_10_BASE_T_HD
		jz	init_mii_workaround
		test	ax, PHY_100_BASE_TX_FD or PHY_100_BASE_TX_HD
		jnz	init_mii_report_100Mb

init_mii_report_10Mb:
		mov	pAS.line_speed, LINE_SPEED_10
		test	ax, PHY_10_BASE_T_FD
		jz	init_mii_enable_int

		jmp	short init_mii_set_epic_FD

init_mii_report_100Mb:
		mov	pAS.line_speed, LINE_SPEED_100
		test	ax, PHY_100_BASE_TX_FD
		jz	init_mii_enable_int

init_mii_set_epic_FD:
		mov	dx, pAS.io_base
		add	dx, EPC_TRANSMIT_CONTROL
		in	ax, dx
		or	ax, TC_FULL_DUPLEX
		out	dx, ax
		or	pAS.line_speed, LINE_SPEED_FULL_DUPLEX
		jmp	short init_mii_enable_int

; user selected (non-nway) speed

init_mii_check_speed:
		cmp	pAS.line_speed, LINE_SPEED_UNKNOWN
		jz	init_mii_qsi_workarounds        ; do nothing if line_speed
						        ; is not specified

; If we are connected to an nway device we want it to renegotiate, so
; we have to tell the phy to drop link.  So first put it in 10 Mbps
; half duplex mode, then put it in loopback mode, before setting it
; to the desired speed and duplex mode.
                mov     ax, 0                   ; 10 Mbps, half duplex
		mov	bx, PHY_BMC_REG
		call	write_phy_register

                mov     ax, 750
                call    epic_delay              ; 750 millisecond delay

                mov     ax, PHY_LOOPBACK
		call	write_phy_register

                mov     ax, 100
                call    epic_delay

		xor	ax, ax
		test	pAS.line_speed, LINE_SPEED_FULL_DUPLEX
		jz	init_mii_not_full_duplex

		mov	ax, PHY_FULL_DUPLEX

init_mii_not_full_duplex:
		test	pAS.line_speed, LINE_SPEED_100
		jz	init_mii_set_speed

		or	ax, PHY_SPEED_SELECT_100

init_mii_set_speed:
		mov	bx, PHY_BMC_REG
		call	write_phy_register

		test	pAS.line_speed, LINE_SPEED_FULL_DUPLEX
		jz	init_mii_qsi_workarounds

		mov	dx, pAS.io_base
		add	dx, EPC_TRANSMIT_CONTROL
		in	ax, dx
		or	ax, TC_FULL_DUPLEX
		out	dx, ax

; first clear, then enable the QSI 6612 autonegotiation complete interrupt
; and link down interrupt
init_mii_enable_int:
		test	pAS.media_type2, MEDIA_TYPE_AUTO_NEGOTIATE
                jz      init_mii_qsi_workarounds
                mov     bx, PHY_INT_SOURCE_REG
                call    read_phy_register
                mov     ax, PHY_INT_MODE or PHY_AN_COMPLETE_INT or PHY_LINK_DOWN_INT
                mov     bx, PHY_INT_MASK_REG
	        call	write_phy_register

init_mii_qsi_workarounds:
; turn off bit 1 in Mercury register 27 to improve long cable length performance
                mov     bx, 27
                call    read_phy_register
                and     ax, 0fffdh
	        call	write_phy_register

; To scramble or not to scramble, that is the question.
; Default is to NOT scramble (ie fried)
; Scramble only if keyword was detectd
		test	pAS.adapter_flags1, SCRAMBLE
		jz	init_mii_fried
; Toggle the scramble disable bit in Mercury register 31 to fix a Mercury
; bug in which the EPIC can't receive data when the PHY is connected to a
; Bay Networks BayStack 100.
                mov     ax, 750                 ; 750 ms delay required for
                call    epic_delay              ; Synoptics 28115 switch
                mov     bx, 31
                call    read_phy_register
                push    ax
                or      ax, 1
 	        call	write_phy_register
                pop     ax
	        call	write_phy_register

init_mii_fried:
		mov	dx, pAS.io_base
		add	dx, EPC_NV_CONTROL
		mov	eax, NVC_GPOE1
		out	dx, eax

ENDIF

init_mii_exit:
		pop	ecx
		pop	bx
		pop	dx
		pop	eax
		ret

IFNDEF OLD_MII
; National DP83840 workaround code
init_mii_workaround:
		mov	bx, 19h
		call	read_phy_register
		test	ax, 40h
		jz	init_mii_100Mb_half_duplex
		mov	pAS.line_speed, LINE_SPEED_10
		jmp	short init_mii_fried

init_mii_100Mb_half_duplex:
		mov	pAS.line_speed, LINE_SPEED_100
		jmp	short init_mii_fried
ENDIF
init_mii_registers        endp

;****************************************************************************
;
; Function:     read_phy_OUI        
;
; Synopis:      returns the OUI from the Phy (See Phy Identifier Registers)
;               on the Nic whose adapter structure is indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       eax	return status (OUI)
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

public read_phy_OUI
read_phy_OUI            proc    near
	push	ebx
	push	ecx
	push	edx

	mov	bx, PHY_ID_REG1
	call	read_phy_register

	xor	ecx, ecx		;clear extended part
	mov	cx, ax
	shl	ecx, 6			;make space for 6 lsbs

	mov	bx, PHY_ID_REG2
	call	read_phy_register

	and	eax, 0fc00h		;filter bits we want
	shr	eax, 10			;position as 6 lsbs

	or	eax, ecx		

	pop	edx
	pop	ecx
	pop	ebx

	ret

read_phy_OUI            endp

;****************************************************************************
;
; Function:     init_tdk_phy
;
; Synopis:      Initializes TDK PHY registers and related Epic registers.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

public init_tdk_phy
init_tdk_phy            proc    near
                push    bx
                push    ecx
                push    dx

		mov	dx, pAS.io_base
		add	dx, EPC_NV_CONTROL
                in      ax, dx
                and     ax, 0fbbfh              ; turn off statusreg_en bit
                or      ax, 800h                ; turn on phypwrdwn_n bit
                out     dx, ax

                add     dx, EPC_GEN_CONTROL - EPC_NV_CONTROL
		mov	eax, pAS.gen_cntl
		or	eax, GC_HARD_RESET
		out	dx, eax

		mov	rcx, 80h
init_tdk_reset:
                in      eax, dx
                loop    init_tdk_reset
		and	eax, not GC_HARD_RESET
		out	dx, eax

; a bug in the TDK 2120 rev. 3 requires all writes to be performed twice
		mov	ax, PHY_RESTART_AN or PHY_AN_ENABLE
		mov	bx, PHY_BMC_REG
		call	write_phy_register

		mov	ax, PHY_RESTART_AN or PHY_AN_ENABLE
		mov	bx, PHY_BMC_REG
		call	write_phy_register

		mov	ecx, 30000h
init_tdk_nway_complete_loop:
		dec	ecx
		jz	init_tdk_exit
		mov	bx, PHY_BMS_REG
		call	read_phy_register
		test	ax, PHY_AN_COMPLETE	;test for nway complete
		jz	init_tdk_nway_complete_loop

                call    handle_nway_complete

		mov	bx, PHY_BMC_REG
                call    read_phy_register

		mov	bx, PHY_BMS_REG
                call    read_phy_register

		mov	bx, PHY_ANLPA_REG
		call	read_phy_register

init_tdk_exit:
                pop     dx
                pop     ecx
                pop     bx
                ret
init_tdk_phy            endp

;****************************************************************************
;
; Function:     handle_nway_complete        
;
; Synopis:      Read the results of an autonegotiation-complete event
;               from the PHY and switch the Epic to full or half duplex.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       None
;
; Modified:     AdapterStructure.line_speed
;
; Notes:	None
;
;****************************************************************************

public handle_nway_complete
handle_nway_complete        proc    near
		push	ax
		push	dx
		push	bx

; If the PHY is a National then exit, the National PHY sometimes causes
; a GP2 interrupt when there is a cable disconnect.
;
                cmp     pAS.phy_id, 00080017h
                jz      handle_nway_exit

; There is a bug in the Mercury PHY.  If the result of autonegotiation is full
; duplex and the cable is pulled and plugged into a half duplex link partner,
; the result of autonegotiation will be full duplex.  This can be avoided if
; the PHY status register is read after an autonegotiation complete interrupt
; occurs.
;
                mov     bx, PHY_BMS_REG
                call    read_phy_register

; Read the PHY status register a second time to make sure its content is valid.
                call    read_phy_register

                mov     dx, pAS.io_base
                add     dx, EPC_TRANSMIT_CONTROL

		mov	bx, PHY_ANLPA_REG
		call	read_phy_register
                test    ax, PHY_100_BASE_TX_FD or PHY_100_BASE_TX_HD
                jz      handle_nway_10Mb
                mov     pAS.line_speed, LINE_SPEED_100
                test    ax, PHY_100_BASE_TX_FD
                jz      handle_nway_reset_epic_FD

handle_nway_set_epic_FD:
                in      ax, dx
                or      ax, TC_FULL_DUPLEX
                out     dx, ax
                or      pAS.line_speed, LINE_SPEED_FULL_DUPLEX
                jmp     short handle_nway_qsi_workaround

handle_nway_10Mb:
; If no valid bit is set in the link partner ability register, then exit
; without doing anything.
;
                test    ax, PHY_10_BASE_T_FD or PHY_10_BASE_T_HD
                jz      handle_nway_exit
                mov     pAS.line_speed, LINE_SPEED_10
                test    ax, PHY_10_BASE_T_FD
                jnz     handle_nway_set_epic_FD

handle_nway_reset_epic_FD:
                in      ax, dx
                and     ax, NOT TC_FULL_DUPLEX
                out     dx, ax

handle_nway_qsi_workaround:
; Jump if this is a TDK phy.
                cmp     pAS.phy_id, 0000c039h
                jz      handle_nway_exit

; To scramble or not to scramble, that is the question.
; Default is to NOT scramble
; Scramble only if keyword was detectd
		test	pAS.adapter_flags1, SCRAMBLE
		jz	handle_nway_exit
; Toggle the scramble disable bit in Mercury register 31 to fix a Mercury
; bug in which the EPIC can't receive data when the PHY is connected to a
; Bay Networks BayStack 100.
                mov     bx, 31
                call    read_phy_register
                push    ax
                or      ax, 1
	        call	write_phy_register
                pop     ax
	        call	write_phy_register

handle_nway_exit:
                pop     bx
                pop     dx
                pop     ax
                ret
handle_nway_complete        endp

;****************************************************************************
;
; Function:     handle_phy_event
;
; Synopis:      Handle a link-down or autonegotiation-complete event. If
;               the board is a 9432BTX in AutoDetect mode, switch between
;               utp and bnc when the current media is down.  Indicate the
;               new media type in media_type2.  Indicate the new line speed
;               and duplex mode in line_speed.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       None
;
; Modified:     AdapterStructure.media_type2
;               AdapterStructure.line_speed
;
; Notes:	None
;
;****************************************************************************

public handle_phy_event
handle_phy_event        proc    near

                mov     bx, PHY_INT_SOURCE_REG
                call    read_phy_register

                test    ax, PHY_AN_COMPLETE_INT
                jnz     handle_phy_nway_complete

                test    ax, PHY_LINK_DOWN_INT
                jz      handle_phy_exit

; If this is a 9432BTX in AutoDetect mode and the utp link is down, then
; switch to bnc.
handle_phy_link_down:
                cmp     pAS.card_SSID, SSID9432BTX
                jnz     handle_phy_exit
                test    pAS.media_type2, MEDIA_TYPE_AUTO_DETECT
                jz      handle_phy_exit

                and     pAS.media_type2, NOT MEDIA_TYPE_UTP
                or      pAS.media_type2, MEDIA_TYPE_BNC         ; indicate bnc

                mov     ax, PHY_ISOLATE or PHY_AN_ENABLE        ; isolate mii
                mov     bx, PHY_BMC_REG
                call    write_phy_register

                call    read_phy_register

                mov     dx, pAS.io_base                         ; turn on bnc
                add     dx, EPC_MII_CONFIG
		mov	ax, MII_ENABLE_SMI or MII_SERIAL_MODE_ENABLE or MII_ENABLE_694
                out     dx, ax

                add     dx, EPC_TRANSMIT_CONTROL - EPC_MII_CONFIG
                in      ax, dx
                and     ax, NOT TC_FULL_DUPLEX
                out     dx, ax                                  ; turn off full duplex
                mov     pAS.line_speed, LINE_SPEED_10           ; indicate 10, half duplex
                jmp     short handle_phy_exit

; If this is a 9432BTX in AutoDetect mode, then switch to utp.
handle_phy_nway_complete:
                cmp     pAS.card_SSID, SSID9432BTX
                jnz     handle_phy_utp

                test    pAS.media_type2, MEDIA_TYPE_AUTO_DETECT
                jz      handle_phy_utp

                and     pAS.media_type2, NOT MEDIA_TYPE_BNC
                or      pAS.media_type2, MEDIA_TYPE_UTP         ; indicate utp

                mov     dx, pAS.io_base
                add     dx, EPC_MII_CONFIG
                mov     ax, MII_ENABLE_SMI
                out     dx, ax                                  ; turn off bnc

                mov     ax, PHY_AN_ENABLE                       ; clear mii isolate
                mov     bx, PHY_BMC_REG                         ; bit
                call    write_phy_register

handle_phy_utp:
                call    handle_nway_complete

handle_phy_exit:
                ret

handle_phy_event        endp

;****************************************************************************
;
; Function:     epic_delay
;
; Synopsis:     Wait for ax milliseconds.
;
; Input:        ds:bp (ebp)	AdapterStructure
;               ax 
;
; Output:       None
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

epic_delay      	proc	near
        push    ecx
        push    dx

        mov     dx, pAS.io_base
        add     dx, EPC_PBLCNT
        movzx   ecx, ax
        shl     ecx, 11
epic_delay_loop:
        in      ax, dx
        dec     ecx
        jnz     epic_delay_loop

        pop     dx
        pop     ecx
        ret
epic_delay              endp

;****************************************************************************
;
; Function:     epic_auto_detect        
;
; Synopis:      Auto detect between UTP and BNC port.
;               The detected media is set in media_type2.
;               If neither UTP or BNC is detected, those
;               bits are cleared in media_type2.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     media_type2, line_speed
;
; Notes:	None
;
;****************************************************************************

public epic_auto_detect
epic_auto_detect	proc	near
        push    eax
        push    ebx
        push    ecx
        push    es
        push    rdi

        and     pAS.media_type2, MEDIA_TYPE_AUTO_NEGOTIATE or MEDIA_TYPE_AUTO_DETECT
	or	pAS.media_type2, MEDIA_TYPE_UTP

	mov	bx, PHY_BMS_REG
	call	read_phy_register		; read multiple times for
	call	read_phy_register		; the current UTP link status
	call	read_phy_register
	call	read_phy_register
	test	ax, PHY_LINK_STATUS		; check UTP link status
	jnz	epic_ad_done			; jmp if we have link

	and	pAS.media_type2, NOT MEDIA_TYPE_UTP
        call    check_bnc_port
        jc      epic_ad_done                    ; jump if bnc is down
        or      pAS.media_type2, MEDIA_TYPE_BNC
;;;jcc
        mov     pAS.line_speed, LINE_SPEED_10
;;;jcc

epic_ad_done:
        pop     rdi
        pop     es
        pop     ecx
        pop     ebx
        pop     eax
	ret

epic_auto_detect	endp

;****************************************************************************
;
; Function:     check_bnc_port
;
; Synopis:      Send a runt packet with a bad crc through the bnc port to
;               check if it is active.  The Epic is left in bnc mode whether
;               or not bnc is up.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     
;
; Notes:	On return the carry flag is cleared if bnc is up, set if bnc
;               is down.  Called by epic_auto_detect.
;
;****************************************************************************

public check_bnc_port
check_bnc_port          proc	near

        mov     ax, PHY_ISOLATE                 ; isolate mii
	or	ax, PHY_AN_ENABLE
        mov     bx, PHY_BMC_REG
        call    write_phy_register
        call    read_phy_register

	mov	dx, pAS.io_base
	add	dx, EPC_MII_CONFIG              ; turn on BNC
        mov     ax, MII_ENABLE_694 or MII_SERIAL_MODE_ENABLE or MII_ENABLE_SMI
        out     dx, ax

; the current 9432btx requires that gpio[1] be driven low in order to use bnc
	add	dx, EPC_NV_CONTROL - EPC_MII_CONFIG
	mov	eax, NVC_GPOE1
	out	dx, eax

        mov     ax, 500
        call    epic_delay

; build and send a test packet to check for BNC connection
ifdef CODE_386
        mov     edi, pAS.setup_ptr.virtual_addr
else
        les     di, pAS.setup_ptr.virtual_addr
endif        

; copy the node address to the test packet's source and destination fields
	mov	dx, pAS.io_base   
        add     dx, EPC_LANADDR1               
        in      ax, dx

        mov     es:[rdi], ax
        mov     es:[rdi]+6, ax
        add     dx, EPC_LANADDR2 - EPC_LANADDR1
        in      ax, dx
        mov     es:[rdi]+2, ax
        mov     es:[rdi]+8, ax
        add     dx, EPC_LANADDR3 - EPC_LANADDR2
        in      ax, dx
        mov     es:[rdi]+4, ax
        mov     es:[rdi]+10, ax

; fill in the rest of the packet with ones
        add     rdi, 12
        mov     ax, 0ffffh
        mov     rcx, 19
        rep     stosw

        mov     rbx, pAS.tx_curr_off            ; ptr to current tx descriptor
        mov     dword ptr [rbx].dma_buf_len, XDMA_FRAGLIST or XDMA_NOCRC
        mov     [rbx].dma_len, 50               ; packet length
        mov     rdi, [rbx].dma_buff_off         ; ptr to fragment list

ifndef CODE_386
        mov     ax, ds
        mov     es, ax          
endif

        mov     eax, 1                          ; fragment count
        stosd
        mov     eax, pAS.setup_ptr.phy_addr
        stosd
        mov     eax, 50                         ; buffer length
        stosd

; set the descriptor ownership to the nic
        mov     [rbx].dma_status, XDMA_OWNER_STATUS

        mov     dx, pAS.io_base
        add     dx, EPC_COMMAND
        mov     ax, CMD_TXQUEUED
        out     dx, ax                          ; start tx

        mov     ecx, 0f000000h
check_bnc_loop:
        dec     ecx
        jz      check_bnc_down                  ; jump if hardware fails
        test    [rbx].dma_status, XDMA_OWNER_STATUS
        jnz     check_bnc_loop                  ; wait for tx to complete

        test    [rbx].dma_status, XDMA_CARRIER_SENSE_LOST
        clc                                     ; indicate bnc is up
        jz      check_bnc_done                  ; jump if bnc is up
check_bnc_down:
        stc                                     ; indicate bnc is down

check_bnc_done:
;; update first and current transmit pointers
        mov     rdi, pAS.tx_curr_off
	mov	rdi, [rdi].dma_next_off
	mov	pAS.tx_first_off, rdi
        mov     pAS.tx_curr_off, rdi

        ret
check_bnc_port          endp

;****************************************************************************
;
; Function:     write_phy_register      
;
; Synopis:      Write value in ax to physical layer register
;                       bx.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       None
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

write_phy_register	proc	near
        push    ax
	push	dx
	mov	dx, pAS.io_base
	add	dx, EPC_MII_DATA
	out	dx, ax
	add	dx, EPC_MII_CONTROL - EPC_MII_DATA
	mov	ax, bx
	shl	ax, 4
	or	ax, MII_WRITE
	test	pAS.media_type2, MEDIA_TYPE_MII
	jnz	write_phy_mii
	or	ax, 3h SHL 9
write_phy_mii:
	out	dx, ax
write_phy_reg_loop:
	in	ax, dx
	test	ax, MII_WRITE
	jnz	write_phy_reg_loop
	pop	dx
        pop     ax
	ret
write_phy_register	endp

;****************************************************************************
;
; Function:     read_phy_register       
;
; Synopis:      Read physical layer register bx and return
;                      value in ax
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

public read_phy_register
read_phy_register	proc	near
	push	dx
	mov	dx, pAS.io_base
	add	dx, EPC_MII_CONTROL
	mov	ax, bx
	shl	ax, 4
	or	ax, MII_READ
	test	pAS.media_type2, MEDIA_TYPE_MII
	jnz	read_phy_mii
	or	ax, 3h SHL 9
read_phy_mii:
	out	dx, ax
read_phy_reg_loop:
	in	ax, dx
	test	ax, MII_READ
	jnz	read_phy_reg_loop
	add	dx, EPC_MII_DATA - EPC_MII_CONTROL
	in	ax, dx
	pop	dx
	ret
read_phy_register	endp

;****************************************************************************
;
; Function:     InitErrorCounters       
;
; Synopis:      Initializes error counters to point to
;               ds:[bp].dummy_vector if they are not
;               initialized by UMAC.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

InitErrorCounters       proc    near
		push    ax
		push    ebx
		push    ecx
		push    esi

		mov     rcx, (ptr_ring_OVW - ptr_rx_CRC_errors) / 4 + 1
		lea     rsi, pAS.ptr_rx_CRC_errors      ; Get address of first counter
		lea     rbx, pAS.dummy_vector           ; BX = offset of dummy vector.
							; DS:SI = offset of first counter.
ifndef CODE_386
		ror     ebx, 16
		mov     bx, ds
		ror     ebx, 16
endif

CheckVectors:
		cmp     dword ptr [rsi], 0
		jnz     SkipThisVector                  ; If null, fill with dummy vector.
		mov     [rsi], rbx

SkipThisVector:
		add     rsi, 4
		loop    CheckVectors

		pop     esi
		pop     ecx
		pop     ebx
		pop     ax

		ret
InitErrorCounters       endp

;****************************************************************************
;
; Function:     put_node_address	
;
; Synopis:      if the node address is set, get it from
;		the pAS, otherwise copy
;		the adapter node address to pAS
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

put_node_address proc	near
		push	eax
		push	dx

		movzx	eax, word ptr pAS.xnode_address[0]
		or	eax, dword ptr pAS.xnode_address[2]
		je	no_node_address

		mov	dx, pAS.io_base
		add	dx, EPC_LANADDR1
		mov	ax, word ptr pAS.xnode_address[0]
		out	dx, ax
		add	dx, EPC_LANADDR2 - EPC_LANADDR1
		mov	ax, word ptr pAS.xnode_address[2]
		out	dx, ax
		add	dx, EPC_LANADDR3 - EPC_LANADDR2
		mov	ax, word ptr pAS.xnode_address[4]
		out	dx, ax
		jmp	gna_done

no_node_address:
		mov	dx, pAS.io_base
		add	dx, EPC_LANADDR1
		in	ax, dx
		mov	word ptr pAS.xnode_address[0], ax
		add	dx, EPC_LANADDR2 - EPC_LANADDR1
		in	ax, dx
		mov	word ptr pAS.xnode_address[2], ax
		add	dx, EPC_LANADDR3 - EPC_LANADDR2
		in	ax, dx
		mov	word ptr pAS.xnode_address[4], ax

gna_done:
		pop	dx
		pop	eax
		ret

put_node_address endp

;****************************************************************************
;
; Function:     LM_Initialize_Adapter
;
; Synopis:      Initializes the adapter whose structure is 
;               indicated by DS:BP
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Initialize_Adapter

		push    ebx
		push    ecx
		push    edx
		push    esi
		push    edi
		push	eax

; set up physical base address
	
		call	reset_nic
		call	init_tx_queues
		call	init_rx_queues
		call	init_nic
		call	init_mii_registers
		call	init_etx_threshold

		call	put_node_address

		call    InitErrorCounters
		mov     pAS.adapter_status, INITIALIZED

IFDEF EZSTART
		call    PCI_LM_Enable_Adapter
ELSE
 IFNDEF CODE_386
		call    LM_Enable_Adapter
 ELSE
		mov	rax, SUCCESS
 ENDIF
ENDIF

LM_Init_Return:
		push    rax
		call    UM_Status_Change
		pop     rbx

		pop	eax
		mov	rax, rbx		; restore return code
		pop     edi
		pop     esi
		pop     edx
		pop     ecx
		pop     ebx

		ret

ASM_PCI_PROC_END        LM_Initialize_Adapter

;****************************************************************************
;
; Function:     LM_Interrupt_Req        
;
; Synopis:      Generates a hardware interrupt from the
;               adapter indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Interrupt_Req

		push    dx
                push    eax
		test    pAS.adapter_flags, ADAPTER_DISABLED
		mov     rax, OUT_OF_RESOURCES
		jnz     IntReqDone

		mov	dx, pAS.io_base
		add	dx, EPC_GEN_CONTROL
		in	eax, dx
                or      eax, GC_SW_INT
		out	dx, eax
		inc	pAS.int_bit
                pop     eax

		mov     rax, SUCCESS

IntReqDone:
		pop     dx
		ret

ASM_PCI_PROC_END        LM_Interrupt_Req

;****************************************************************************
;
; Function:     LM_Open_Adapter         
;
; Synopis:      Opens adapter whose adapter structure is
;               indicated by DS:BP.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Open_Adapter

			push    ecx
			push    edx
			cmp     pAS.adapter_status, NOT_INITIALIZED
			jne     CheckStat01
			mov     rax, ADAPTER_NOT_INITIALIZED
			jmp     LM_OADone
CheckStat01:            cmp     pAS.adapter_status, INITIALIZED
			je      OKToOpen
			cmp     pAS.adapter_status, OPEN
			je      AlreadyOpen
DoInit:
IFDEF EZSTART
			call    PCI_LM_Initialize_Adapter
ELSE
			call    LM_Initialize_Adapter
ENDIF
			cmp     rax, SUCCESS
			je      OKToOpen
			mov     rax, OPEN_FAILED
			mov     pAS.adapter_status, FAILED
			jmp     LM_OADone

OKToOpen:
IFDEF FREEBUFF
			mov	ax, pAS.num_rx_free_buffs
			cmp	ax, pAS.num_of_rx_buffs
			jz	RxBufferOK

			mov	rax, OPEN_FAILED
			jmp     LM_OADone

RxBufferOK:
ENDIF
; clear dma status bits (they power up on!)
			push	eax
			mov	dx, pAS.io_base
			add	dx, EPC_RCV_DMA_STATUS
			mov	eax, 0
			out	dx, eax
			pop	eax

; turn on the receiver and start receive dma's
			add	dx, EPC_COMMAND - EPC_RCV_DMA_STATUS
			mov	ax, CMD_START_RX or CMD_RXQUEUED
			out	dx, ax


AlreadyOpen:            
            mov     pAS.adapter_status, OPEN
			call    UM_Status_Change
            mov     rax, SUCCESS             ; Set return code
LM_OADone:  pop     edx
			pop     ecx
			ret

ASM_PCI_PROC_END        LM_Open_Adapter

;****************************************************************************
;
; Function:     LM_Put_Rx_Frag       
;
; Synopis:      Enqueues a Fragment list for receive
;
; Input:        ds:bp (ebp)	AdapterStructure
;               es:si (esi)     Fragment list pointer
;               dx:di (edi)     Handle
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

IFDEF FREEBUFF
ASM_PCI_PROC		LM_Put_Rx_Frag

	mov	ax, pAS.num_rx_free_buffs

	cmp	ax, pAS.num_of_rx_buffs
	jb	enqueue_it
	mov	rax, OUT_OF_RESOURCES
	ret
enqueue_it:
	push	ebx
	push	edi
	push	ecx

	mov	rbx, pAS.rx_last_fraglist
IFDEF CODE_386
	mov	[rbx].dma_handle, edi
ELSE
	mov	word ptr [rbx].dma_handle, di
	mov	word ptr [rbx].dma_handle+2, dx
ENDIF
	mov	rdi, [rbx].dma_buff_off
IFDEF CODE_386
	mov	ecx, [esi]
	movsd
	shl	ecx, 1
	rep	movsd
ELSE
	movzx	ecx, word ptr es:[si]
	push	ds
	push	es
	pop	ds
	pop	es
	mov	es:[di], ecx
	add	di, 4
	add	si, fragment_list
load_frag_loop:
	movsd
	lodsw
	and	ax, NOT PHYSICAL_ADDR
	stosw
	mov	word ptr es:[di], 0
	add	di, 2
	loop	load_frag_loop
	push	es
	push	ds
	pop	es
	pop	ds
ENDIF
	mov	dword ptr [rbx].dma_status, RDMA_OWNER_STATUS
	mov	rbx, [rbx].dma_next_off
	mov	pAS.rx_last_fraglist, rbx
	inc	pAS.num_rx_free_buffs

	cmp	pAS.adapter_status, OPEN
	jnz	LM_Put_Rx_Frag_Exit

	mov	ebx, edx			; save edx
	mov	dx, pAS.io_base
	mov	ax, CMD_RXQUEUED
	out	dx, ax
	mov	edx, ebx

LM_Put_Rx_Frag_Exit:
	pop	ecx
	pop	edi
	pop	ebx
	mov	eax, SUCCESS
	ret
	
ASM_PCI_PROC_END	LM_Put_Rx_Frag
ENDIF

;****************************************************************************
;
; Function:     LM_Receive_Copy 
;
; Synopis:      Copies data from the received packet to
;                  a Data buffer structure.
;
; Input:        ds:bp (ebp)	AdapterStructure
;       	cx    (ecx)	bytes to move
;               ax    (eax)	Offset in shared RAM
;               bx    (ebx)     Lookahead flag, 0 = Lookahead copy.
;               es:si (esi)     Pointer to data buffer structure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Receive_Copy
                push    edx
                push    ebx
                
; check for bad request
                cmp     pAS.adapter_status, OPEN
		jne     lrc_out_of_res

                movzx   edx, ax
                add     ax, cx                  
		cmp     ax, 600h      		; max possible ethernet size
		ja      lrc_out_of_res
                
; set up receive fragment
		mov	rbx, pAS.rx_curr_fraglist
		mov	rbx, [rbx].dma_next_off
		mov	pAS.rx_curr_fraglist, rbx
ifdef FREEBUF
		mov	[rbx].dma_buf_len, dx		; offset length
else
		mov	[rbx].dma_buf_len, 0		; offset length
endif
		
; initialize the fragment list
		push	rcx
                push    rsi
                push    rdi
		push	eax

                mov     rdi, [rbx].dma_buff_off
		mov	eax, 0

ifndef CODE_386
		push	es			; swap es and ds segments
		push	ds
		pop	es
		pop	ds
endif

ifndef CODE_386
                lodsw				; get fragment count
else
		lodsd
endif
		mov	rcx, rax
ifndef FREEBUF
		add	rax, 2
endif
		stosd

ifndef FREEBUF
; erx enable fix
; the epic will not do an early receive unless the packet
; starts at byte 0. Our fix is to prepend a scratch buffer to the
; beginning of the fragment list.
		mov	eax, es:[bp].tx_scratch
		stosd
		mov	eax, edx
		stosd
; end erx workaround
endif


rx_frag_loop:
; move a single fragment dw len, dd ptr to dd len, dd ptr
		movsd				; move pointer
ifndef CODE_386
                lodsw				; get fragment length
else
		lodsd
endif
                and     rax, NOT PHYSICAL_ADDR
                stosd
		loop	rx_frag_loop

ifndef FREEBUF
; fraglist error workaround
; the epic will post rx status at the completion of the fraglist dma.
; this is a problem when the dma fraglist is shorter that the received packet.
; In this case, NW_STATUS_VALID will be 0 and FRAGMENT_LIST_ERROR will be
; 1, causing the packet to be tossed. To fix this bug, we add an extra fragment 
; at the end of the fraglist to force the dma to wait for receive completion.
		mov	eax, es:[bp].tx_scratch
		stosd
		mov	eax, 256
		stosd
; end fraglist workaround
endif

ifndef CODE_386
		push	es			; swap es and ds segments
		push	ds
		pop	es
		pop	ds
endif

		pop	eax
                pop     rdi
                pop     rsi
                pop     rcx
                
; add rx fragment to nic chain (set status to nic)
		mov	[rbx].dma_control, RDMA_FRAGLIST SHR 16
                mov     dword ptr [rbx].dma_status, RDMA_OWNER_STATUS

; start rx (if not already going)
		mov	dx, pAS.io_base
		add	dx, EPC_COMMAND
		mov	ax, CMD_RXQUEUED
		out	dx, ax

		mov	rax, PENDING

lrc_return_wait:
		mov	rcx, 800h

lrc_wait_completion:
		test	dword ptr [rbx].dma_status, RDMA_OWNER_STATUS
		jz	lrc_dma_done
		test	pAS.adapter_flags, ENABLE_RX_PENDING
		jnz	lrc_exit
		push	rcx
		mov	rcx, 80h
		loop	$
		pop	rcx
		loop	lrc_wait_completion

lrc_dma_done:
		or	rcx, rcx
		jz	lrc_out_of_res

lrc_return:
		add	dx, EPC_INT_STATUS - EPC_COMMAND
                mov     ax, INT_RCV_COPY_DONE
		out	dx, ax			; clear receive copy int

		mov	rax, SUCCESS
		mov	dx, [rbx].dma_status
		and	dx, RDMA_CRC_ERR or RDMA_FA_ERR or RDMA_FRAG_LIST_ERR
		jz	lrc_no_errors
		mov	rax, HARDWARE_FAILED		

lrc_no_errors:
		test	dx, RDMA_FRAG_LIST_ERR
		jz	lrc_no_fle
		or	dx, RX_HW_FAILED

lrc_no_fle:
		mov	cx, [rbx].dma_len
		sub	cx, 4

lrc_exit:
                pop     ebx
		mov	bx, dx
                pop     edx
		ret

lrc_out_of_res:
		mov	rax, OUT_OF_RESOURCES
		jmp	lrc_exit

ASM_PCI_PROC_END        LM_Receive_Copy

;****************************************************************************
;
; Function:     LM_Send         
;
; Synopis:      send a packet
;
; Input:        ds:bp (ebp)  AdapterStructure
;		ES:SI (esi)  ptr to data buffer structure
;               CX    (ecx)  Transmit byte count
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Send

		push    ebx

                push    edx
                push    ecx
		push	eax

		mov     rax, OUT_OF_RESOURCES
                cmp     pAS.adapter_status, OPEN
		jne     LM_Send_done

		cmp     cx, pAS.max_packet_size
		ja      LM_Send_done

		cmp	pAS.tx_free_desc_count, 0
		jz	LM_Send_done
		
; increment retry counter
		inc	pAS.tx_pend
		jz	lms_notxugo
		mov	pAS.tx_pend, ETX_CUTOFF

lms_notxugo:
; if the nic owns this fragment, we are out of buffers
		mov	rbx, pAS.tx_curr_off
                test    [rbx].dma_status, XDMA_OWNER_STATUS
                jne     LM_Send_done

; fragment is ok to use. Initialize the controls
		dec	pAS.tx_free_desc_count
		cmp	pAS.tx_free_desc_count, 1
		jne	LM_Send_above_lo_water
IFDEF DOUBLE_COPY_TX
		and	ecx, 0ffffh
		or	ecx, XDMA_IAF or XDMA_LASTDESC
		mov	dword ptr [rbx].dma_buf_len, ecx
ELSE
		mov	dword ptr [rbx].dma_buf_len, XDMA_IAF or XDMA_FRAGLIST
ENDIF
		jmp	short LM_Send_setup_size
LM_Send_above_lo_water:
IFDEF DOUBLE_COPY_TX
		and	ecx, 0ffffh
		or	ecx, XDMA_LASTDESC
		mov	dword ptr [rbx].dma_buf_len, ecx
ELSE
                mov     dword ptr [rbx].dma_buf_len, XDMA_FRAGLIST
ENDIF
LM_Send_setup_size:

       mov     [rbx].dma_len, cx



IFNDEF DOUBLE_COPY_TX
; initialize the fragment list
                push    rdi
                push    rsi
                push    eax

		mov	eax, 0			; zero upper 16 bits
                mov     rdi, [rbx].dma_buff_off

ifndef CODE_386
		push	es			; swap es and ds segments
		push	ds
		pop	es
		pop	ds
endif

ifndef CODE_386


;;       mov     ecx,    CR0
;;       test    cx, 1
;;       jz      real_mode3

;;db  0F1h    

;;real_mode3:


                lodsw				; get fragment count
else
		lodsd
endif
		mov	rcx, rax
		stosd

tx_frag_loop:
; move a single fragment dw len, dd ptr to dd len, dd ptr
		movsd				; move pointer
ifndef CODE_386
                lodsw				; get fragment length
else
		lodsd
endif
                and     rax, NOT PHYSICAL_ADDR
                stosd
		loop	tx_frag_loop

ifndef CODE_386
		push	es			; swap es and ds segments
		push	ds
		pop	es
		pop	ds
endif

                pop     eax
                pop     rsi
                pop     rdi
ELSE
		push	eax
		push	esi
		push	edi

                mov     rdi, [rbx].dma_buff_off
		mov	ecx, [esi]
		add	esi, 4

tx_double_copy_loop:
		push	esi
		push	ecx

		mov	ecx, [esi+4]
		mov	esi, [esi]
		cmp	ecx, 3
		ja	tx_large
		rep	movsb
		jmp	tx_copy_done
tx_large:
		test	edi, 3
		jz	tx_dword

		mov	eax, edi
		and	eax, 3
		push	ecx
		mov	ecx, 4
		sub	ecx, eax
		mov	eax, ecx
		rep	movsb
		pop	ecx
		sub	ecx, eax
tx_dword:
		mov	eax, ecx
		shr	ecx, 2
		rep	movsd
		mov	ecx, eax
		and	ecx, 3
		jz	tx_copy_done
		rep	movsb
tx_copy_done:
		pop	ecx
		pop	esi
		add	esi, size FragmentStructure
		loop	tx_double_copy_loop

tx_update_curr_buff:
		pop	edi
		pop	esi
		pop	eax

ENDIF

; add tx fragment to nic chain (set status to nic)
                mov     [rbx].dma_status, XDMA_OWNER_STATUS

; start tx (if not already going)
		mov	dx, pAS.io_base

		add	dx, EPC_COMMAND
		mov	ax, CMD_TXQUEUED
		out	dx, ax

; bump tx pointer
		mov	rbx, [rbx].dma_next_off
		mov	pAS.tx_curr_off, rbx

IFDEF DOUBLE_COPY_TX
		mov	rax, SUCCESS
		jmp	LM_Send_done
ENDIF

; we ALWAYS return PENDING, and let UM_Send_Complete finish the transaction
                mov     rax, PENDING
		test	pAS.adapter_flags, ENABLE_TX_PENDING
		jnz	LM_Send_done

		call	init_etx_idle

; do early tx adjustment
		test	eax, INT_XMIT_UNDERRUN
		jz	LM_Send_no_txbump

; wait for txugo to clear (yech!)
lms_tx_wait:
		mov	ax, CMD_TXUGO
		out	dx, ax

IFDEF CODE_386
		push	ebx
		mov	ebx, pAS.ptr_tx_underruns
		add	errptr [ebx], 1
		pop	ebx
ELSE
		push	es
		push	bx
		les	bx, dword ptr pAS.ptr_tx_underruns
		add	errptr es:[bx], 1
		pop	bx
		pop	es
ENDIF

; stop at end of current tx
		mov	ax, CMD_STOP_TDMA
		out	dx, ax
		call	init_etx_idle

		test	eax, INT_XMIT_UNDERRUN
		jnz	lms_tx_wait

		cmp	pAS.early_tx_thresh, ETX_MAX_THRESH
		ja	LM_Send_no_txbump
		cmp	pAS.tx_pend, ETX_CUTOFF
		ja	LM_Send_no_txbump

; update threshold
		add	dx, EPC_XMIT_COPY_THRESH - EPC_COMMAND
		add	pAS.early_tx_thresh, 4
		mov	ax, pAS.early_tx_thresh
		out	dx, ax

		mov	pAS.tx_pend, 0

LM_Send_no_txbump:
		mov	rax, SUCCESS

LM_Send_done:
		mov	rcx, rax		; preserve error code
		pop	eax			; and upper 16 bits
		mov	rax, rcx
                pop     ecx
                pop     edx
		pop     ebx

		ret


ASM_PCI_PROC_END        LM_Send

;****************************************************************************
;
; Function:     CheckMultiAdd   
;
; Synopis:      Compares the address indicated by ES:SI to
;               all addresses in the adapter structure multicast
;               table, and the braodcast address located at BC_ADD
;               in the adapter structure.
;
; Input:        ds:bp (ebp)	AdapterStructure
;               es:si(esi)      data buffer
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

CheckMultiAdd   proc    near
			push    esi
			push    edi
			push    edx
			push    ecx
			push    ebx

			mov     rcx, MC_TABLE_ENTRIES+1  ; # of MC table entries
							; + broadcast address
							; entry.
			mov     rdi, rsi
			lea     rsi, pAS.bc_add         ; Start with b'cast
			test    pAS.receive_mask, ACCEPT_BROADCAST
			jnz     DontSkipBCAdd
			dec     rcx                      ; Decrement entry cnt
			lea     rsi, pAS.mc_table        ; Skip b'cast entry
DontSkipBCAdd:
			cld

GoopLoop:               push    esi
			push    edi
			push    ecx
			mov     rcx, 3
			repz    cmpsw
			pop     ecx
			pop     edi
			pop     esi
			jnz     TryNextAdd
			cmp     byte ptr [rsi+6], 0h     ; If inst. count = 0,
							; entry is invalid.
			je      AddHas0Cnt
			mov     rbx, SUCCESS
			jmp     CheckMADone     ; All Done

TryNextAdd:             add     rsi, 7          ; Point to next address
			loop    GoopLoop        ; Check all addresses
						; If all entries checked and
						; no matches, bail out.

AddHas0Cnt:             mov     rbx, OUT_OF_RESOURCES

CheckMADone:
			mov     rax, rbx          ; Get return code into AX

			pop     ebx
			pop     ecx
			pop     edx
			pop     edi
			pop     esi
			ret

CheckMultiAdd          endp

;****************************************************************************
;
; Function:     LM_Service_Events       
;
; Synopis:      Interrupt event handling routine.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Service_Events

		PUSH_ES
		push	ebx
                push    eax
		push	ecx
                push    edx
		push	edi

; test for software interrupt
		cmp	pAS.int_bit, 0
		jnz	lmse_handle_sw_int

; test for normal interrupt
		mov	dx, pAS.io_base
		add	dx, EPC_INT_STATUS
		in	eax, dx
		test	eax, INT_ACTIVE
                je      lmse_not_my_interrupt
		jmp	short lmse_initial_loop		
lmse_loop:
; main interrupt loop entry point
		in	eax, dx
		test	eax, INT_ACTIVE
                je      lmse_done_ok

lmse_initial_loop:
; scan the status for set interrupts
; test for receive complete
                test    eax, INT_RCV_COPY_DONE or INT_HEADER_COPY_DONE
                jne     lmse_receive_route

; handle transmit underrun
                test    eax, INT_XMIT_UNDERRUN
                jne     lmse_tx_error

; test for transmit complete
                test    eax, INT_XMIT_DONE or INT_XMIT_CHAIN_DONE
                jne     lmse_xmit_complete

; handle counter errors
                test    eax, INT_CNTR_OVERFLOW
                jne     lmse_counter_error

; handle soft errors
                test    eax, INT_RCV_ERR or INT_RCV_BUFF_OVERFLOW
                jne     lmse_soft_error

; handle end of queue situations
                test    eax, INT_RCV_QUEUE_EMPTY or INT_XMIT_QUEUE_EMPTY   
                jne     lmse_queue_error

; check for a pci bus error
; ( a pci error is considered fatal)
                test    eax, PTA or PMA or APE or DPE
                jne     lmse_hard_error

; check for a threshold interrupt
		test	eax, INT_RCV_COPY_THRESH
		jne	lmse_clear_thresh_copy

; check for a phy interrupt
                test    eax, INT_PHY_EVENT
                jnz     lmse_phy_int

lmse_done_ok:
                mov     rax, SUCCESS

lmse_done:
		pop	edi
                pop     edx
		pop	ecx
                mov     rbx, rax
                pop     eax
                mov     rax, rbx             ; restore return code
		pop	ebx
		POP_ES
        	ret

lmse_handle_sw_int:
		mov	dx, pAS.io_base
		add	dx, EPC_GEN_CONTROL
		in	eax, dx
                and     eax, NOT GC_SW_INT      ; clear sw int
		out	dx, eax
		dec	pAS.int_bit
		inc	pAS.hdw_int
		call	UM_Interrupt
		mov	dx, pAS.io_base
		add	dx, EPC_INT_STATUS
                jmp     lmse_loop

lmse_clear_thresh_copy:
		and	ax, INT_RCV_COPY_THRESH
		out	dx, ax
                jmp     lmse_loop


lmse_receive_route:
                and     ax, INT_HEADER_COPY_DONE or INT_RCV_COPY_DONE
		out	dx, ax

		mov	rdi, pAS.rx_curr_fraglist
		test	[rdi].dma_control, RDMA_HEADER SHR 16
		jz	lmse_receive_copy
		jmp	lmse_early_receive

lmse_tx_error:
		add	dx, EPC_COMMAND - EPC_INT_STATUS

lmse_tx_error1:
		mov	ax, CMD_TXUGO
		out	dx, ax

IFDEF CODE_386
		mov	ebx, pAS.ptr_tx_underruns
		add	errptr [ebx], 1
ELSE
		push	es
		les	bx, dword ptr pAS.ptr_tx_underruns
		add	errptr es:[bx], 1
		pop	es
ENDIF

; stop at end of current tx
		mov	ax, CMD_STOP_TDMA
		out	dx, ax

; wait for transmitter to go idle
		call	init_etx_idle

		test	eax, INT_XMIT_UNDERRUN
		jnz	lmse_tx_error1

; do early tx adjustment
		cmp	pAS.tx_pend, ETX_CUTOFF
		ja	lmse_etx_reset

		cmp	pAS.early_tx_thresh, ETX_MAX_THRESH
		ja	lmse_etx_reset

; update threshold
		add	dx, EPC_XMIT_COPY_THRESH - EPC_COMMAND
		add	pAS.early_tx_thresh, 4
		mov	ax, pAS.early_tx_thresh
		out	dx, ax
		add	dx, EPC_COMMAND - EPC_XMIT_COPY_THRESH
		mov	pAS.tx_pend, 0

lmse_etx_reset:
		add	dx, EPC_INT_STATUS - EPC_COMMAND
                jmp     lmse_loop

; handle counter errors
lmse_counter_error:
                and     ax, INT_CNTR_OVERFLOW
		out	dx, ax

		add	dx, EPC_CRC_ERR_CNT - EPC_INT_STATUS
		in	al, dx
		movzx	errAX, al

IFDEF CODE_386
		mov	ebx, pAS.ptr_rx_CRC_errors
		add	errptr [ebx], errAX
ELSE
		push	es
		les	bx, dword ptr pAS.ptr_rx_CRC_errors
		add	errptr es:[bx], errAX
		pop	es
ENDIF

		add	dx, EPC_FA_ERR_CNT - EPC_CRC_ERR_CNT
		in	al, dx
		movzx	errAX, al

IFDEF CODE_386
		mov	ebx, pAS.ptr_rx_align_errors
		add	errptr [ebx], errAX
ELSE
		push	es
		les	bx, dword ptr pAS.ptr_rx_align_errors
		add	errptr es:[bx], errAX
		pop	es
ENDIF

		add	dx, EPC_MISSED_PKT_CNT - EPC_FA_ERR_CNT
		in	al, dx
		movzx	errAX, al

IFDEF CODE_386
		mov	ebx, pAS.ptr_rx_lost_pkts
		add	errptr [ebx], errAX
ELSE
		push	es
		les	bx, dword ptr pAS.ptr_rx_lost_pkts
		add	errptr es:[bx], errAX
		pop	es
ENDIF

		add	dx, EPC_INT_STATUS - EPC_MISSED_PKT_CNT
		jmp	lmse_loop

; handle soft errors
lmse_soft_error:
		test	ax, INT_RCV_BUFF_OVERFLOW
		jz	lmse_no_ovw
IFDEF CODE_386
		mov	ebx, pAS.ptr_rx_overruns
		add	errptr [ebx], 1
ELSE
		push	es
		les	bx, dword ptr pAS.ptr_rx_overruns
		add	errptr es:[bx], 1
		pop	es
ENDIF

; see if receiver hung
		push	ax
		add	dx, EPC_COMMAND - EPC_INT_STATUS
		in	ax, dx
		test	ax, CMD_NEXTFRAME
		jz	lmse_no_nextframe_err

; requeue receive
		mov	ax, CMD_RXQUEUED
		out	dx, ax

lmse_no_nextframe_err:
		add	dx, EPC_INT_STATUS - EPC_COMMAND		
		pop	ax

lmse_no_ovw:
                and     ax, INT_RCV_ERR or INT_RCV_BUFF_OVERFLOW
		out	dx, ax
                jmp     lmse_loop

; handle end of queue situations
lmse_queue_error:
                and     ax, INT_RCV_QUEUE_EMPTY or INT_XMIT_QUEUE_EMPTY
		out	dx, ax
                jmp     lmse_loop

; check for a pci bus error
; (a pci error is considered fatal)
lmse_hard_error:
                and     eax, PTA or PMA or APE or DPE
		out	dx, eax

                mov     ax, HARDWARE_FAILED
                jmp     lmse_done

lmse_not_my_interrupt:
                mov     ax, NOT_MY_INTERRUPT
                jmp     lmse_done

check_multicast:
		call	CheckMultiAdd
		cmp	rax, SUCCESS
		jne	lse_bad_packet
		jmp	return_multicast

; test for early receive
lmse_early_receive:
		PUSH_ES
		push	esi
		push	ebx

		mov	rbx, pAS.rx_curr_lookahead
		mov	rsi, [rbx].dma_buff_off
ifndef CODE_386
		mov	es, word ptr pAS.host_ram_virt_addr+2
		test	byte ptr es:[si], 01h	; check for multicast packet
else
		test	byte ptr [esi], 01h
endif
		jz	return_multicast
		test	pAS.receive_mask, ACCEPT_MULTI_PROM
		jnz	return_multicast
		jmp	check_multicast

return_multicast:
; check NW_STATUS_VALID before checking CRC & FA error bits
		mov	ax, [rbx].dma_status
		test	ax, RDMA_NW_STATUS_VALID
		jnz	get_error_status

		xor	bx, bx
		mov	rcx, 0
		jmp	short call_umac

get_error_status:
IFDEF CODE_386
		xor	ecx, ecx
ENDIF
		mov	cx, [rbx].dma_len
		sub	cx, 4
		mov	bx, ax
		and	bx, RDMA_CRC_ERR or RDMA_FA_ERR
		jz	call_umac
IFDEF CODE_386
		mov	ebx, pAS.ptr_rx_CRC_errors
		add	errptr [ebx], 1
ELSE
		push	es
		les	bx, dword ptr pAS.ptr_rx_CRC_errors
		add	errptr es:[bx], 1
		pop	es
ENDIF
		mov	bx, ax
		and	bx, RDMA_CRC_ERR or RDMA_FA_ERR
call_umac:
		push	edx

		call	UM_Receive_Packet
	
		pop	edx

lse_bad_packet:
		pop	ebx
		pop	esi
		POP_ES

		cmp	rax, PENDING		; don't get next packet
		je	lmse_loop

; set up current rx descriptor as the header desc
lse_next_rxqueue:
		push	ebx
		push	eax

		mov	rbx, pAS.rx_curr_fraglist
		mov	rbx, [rbx].dma_next_off
		mov	pAS.rx_curr_lookahead, rbx
		mov	pAS.rx_curr_fraglist, rbx
		mov	dword ptr [rbx].dma_status, RDMA_OWNER_STATUS
		movzx	eax, pAS.rx_lookahead_size
		shl	eax, 4				; 16 byte increment
		or	eax, RDMA_HEADER
		mov	dword ptr [rbx].dma_buf_len, eax

		add	dx, EPC_COMMAND - EPC_INT_STATUS
		mov	ax, CMD_NEXTFRAME or CMD_RXQUEUED
		out	dx, ax
		add	dx, EPC_INT_STATUS - EPC_COMMAND

lse_rx_pend:
		pop	eax
		pop	ebx

		cmp	rax, EVENTS_DISABLED
		je	lmse_done		; stop processing ints
                jmp     lmse_loop

; test for receive complete
lmse_receive_copy:
IFDEF FREEBUFF
lmse_receive_copy_loop:
		cmp	pAS.num_rx_free_buffs, 0
		jz	lmse_loop
		mov	rdi, pAS.rx_curr_fraglist
		mov	bx, [rdi].dma_status
		test	bx, RDMA_OWNER_STATUS
		jnz	lmse_loop
		and	bx, NOT RX_HW_FAILED
		test	bx, RDMA_FRAG_LIST_ERR
		jz	lmse_no_fraglist_err
		add	dx, EPC_COMMAND - EPC_INT_STATUS
		mov	ax, CMD_NEXTFRAME
		out	dx, ax
		add	dx, EPC_INT_STATUS - EPC_COMMAND

lmse_hw_failed:
		or	bx, RX_HW_FAILED
		mov	rax, HARDWARE_FAILED
		jmp	short lmse_call_upper

lmse_no_fraglist_err:
		test	bx, RDMA_NW_STATUS_VALID
		jz	lmse_hw_failed

		mov	cx, [rdi].dma_len
		sub	cx, 4			; minus CRC

; XC bugfix (removed)
;		cmp	cx, 600h
;		jae	lmse_hw_failed

lmse_size_ok:
		and	bx, RDMA_CRC_ERR or RDMA_FA_ERR
		mov	rax, SUCCESS

lmse_call_upper:
IFNDEF CODE_386
		push	dx
		mov	dx, word ptr [di].dma_handle+2
		mov	di, word ptr [di].dma_handle
ELSE
		mov	edi, [edi].dma_handle
ENDIF
		call	UM_Receive_Packet
		dec	pAS.num_rx_free_buffs

IFDEF CODE_386
		or	esi, esi
ELSE
		mov	ax, es
		or	ax, si
ENDIF
		jz	no_new_frag
		call	LM_Put_Rx_Frag
no_new_frag:
IFNDEF CODE_386
		pop	dx
ENDIF
		mov	rdi, pAS.rx_curr_fraglist
		mov	rdi, [rdi].dma_next_off
		mov	pAS.rx_curr_fraglist, rdi
		jmp	lmse_receive_copy_loop

ELSE	; NOT FREEBUFF

		test	pAS.adapter_flags, ENABLE_RX_PENDING
		jz	lmse_loop	; next descriptor already q'd

		mov	rax, SUCCESS

; check packet status
		mov	rdi, pAS.rx_curr_fraglist
		mov	bx, [rdi].dma_status

		test	bx, RDMA_OWNER_STATUS
		jnz	lmse_bad_copy

		test	bx, RDMA_NW_STATUS_VALID
		jz	lmse_bad_copy

		and	bx, RDMA_CRC_ERR or RDMA_FA_ERR

; set packet length
		mov	cx, [rdi].dma_len
		sub	cx, 4			; remove CRC length

; XC bugfix (removed)
;		cmp	cx, 600h		; hw bug check
;		jae	lmse_bad_copy

lmse_good_copy:
		call	UM_Receive_Copy_Complete

		
; check for pending return
		cmp	rax, PENDING
		je	lmse_loop
		jmp	lse_next_rxqueue

lmse_bad_copy:
                mov     rax, HARDWARE_FAILED
		and	bx, RDMA_CRC_ERR or RDMA_FA_ERR
		or	bx, RX_HW_FAILED
		jmp	lmse_good_copy

ENDIF	; FREEBUFF

; test for transmit complete
lmse_xmit_complete:
                and     ax, INT_XMIT_CHAIN_DONE or INT_XMIT_DONE
		out	dx, ax

		mov	cx, pAS.num_of_tx_buffs
lmse_xmit_complete_loop:
		cmp	pAS.tx_free_desc_count, cx
		jz	lmse_loop		; no more outstanding xmits

		mov	rsi, pAS.tx_first_off
		mov	rax, SUCCESS
		mov	bx, [rsi].dma_status
		test	bx, XDMA_OWNER_STATUS
		jnz	lmse_loop

		test	bx, XDMA_XMIT_OK
		jnz	lmse_no_excess_coll
		test	bx, XDMA_EXCESSIVE_COLL
		jz	lmse_no_excess_coll
		mov	rax, MAX_COLLISIONS
IFDEF CODE_386
		mov     ebx, pAS.ptr_tx_max_collisions
		add     errptr [ebx], 1
ELSE
		push    es
		les     bx, dword ptr pAS.ptr_tx_max_collisions
		add     errptr es:[bx], 1
		pop     es
ENDIF
		jmp	short lmse_call_umsc

lmse_no_excess_coll:
		test	bx, XDMA_XMIT_WITH_COLL
		jz	lmse_no_coll
IFDEF CODE_386
		mov     ebx, pAS.ptr_tx_total_collisions
		add     errptr [ebx], 1			; add 1 for now
ELSE
		push    es
		les     bx, dword ptr pAS.ptr_tx_total_collisions
		add     errptr es:[bx], 1
		pop     es
ENDIF
		jmp	short lmse_call_umsc
lmse_no_coll:
		test	bx, XDMA_NON_DEFERRED_XMIT
		jnz	lmse_call_umsc
IFDEF CODE_386
		mov     ebx, pAS.ptr_tx_deferred
		add     errptr [ebx], 1
ELSE
		push    es
		les     bx, dword ptr pAS.ptr_tx_deferred
		add     errptr es:[bx], 1
		pop     es
ENDIF
lmse_call_umsc:
		inc	pAS.tx_free_desc_count
		push	ecx
		call	UM_Send_Complete
		pop	ecx
; update first transmit pointer
		mov	rsi, pAS.tx_first_off
		mov	rsi, [rsi].dma_next_off
		mov	pAS.tx_first_off, rsi

		cmp	rax, EVENTS_DISABLED
		je	lmse_done		; stop processing ints

		jmp	lmse_xmit_complete_loop

public lmse_phy_int
lmse_phy_int:
                call    handle_phy_event

        	mov	dx, pAS.io_base
	        add	dx, EPC_INT_STATUS
                in      ax, dx
                and     ax, INT_PHY_EVENT
	        out	dx, ax
                jmp     lmse_loop

ASM_PCI_PROC_END        LM_Service_Events

;****************************************************************************
;
; Function:     LM_Set_Funct_Address 
;
; Synopis:      returns INVALID_FUNCTION for Ethernet.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Set_Funct_Address

		mov     rax, INVALID_FUNCTION
		ret
ASM_PCI_PROC_END        LM_Set_Funct_Address

;****************************************************************************
;
; Function:     LM_Set_Group_Address 
;
; Synopis:      returns INVALID_FUNCTION for Ethernet.
;
; Input:        ds:bp (ebp)	AdapterStructure
;
; Output:       ax (eax)	return status
;
; Modified:     None
;
; Notes:	None
;
;****************************************************************************

ASM_PCI_PROC    LM_Set_Group_Address

		mov     rax, INVALID_FUNCTION
		ret

ASM_PCI_PROC_END        LM_Set_Group_Address
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\chs\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\br\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\chs\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\chs\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\cht\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\cht\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\cht\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\cht\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\cs\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\cs\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\cs\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\da\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\cs\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\da\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\da\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\da\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\el\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\el\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\br\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\el\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\cht\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\el\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\chs\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\el\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\es\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\es\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\es\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\es\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\es\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\fi\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\da\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\fi\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\cs\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\fi\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\fi\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\fi\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\fr\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\fr\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\fr\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\fr\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\ger\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\fr\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\ger\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\ger\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\ger\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\ger\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\heb\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\heb\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\hu\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\hu\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\hu\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\hu\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\it\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\hu\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\it\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\it\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\it\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\it\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\jpn\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\jpn\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\jpn\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\jpn\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\kor\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\kor\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\jpn\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\kor\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\kor\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\kor\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\nl\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\nl\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\nl\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\nl\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\nl\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\no\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\no\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\no\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\pl\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\no\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\pl\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\pl\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\no\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\pl\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\psu\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\pl\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\psu\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\pt\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\psu\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\psu\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\psu\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\pt\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\pt\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\pt\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\pt\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\ru\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\ru\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\ru\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\ru\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\ru\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\sv\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\sv\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\sv\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\sv\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\sv\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\tr\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\tr\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\tr\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\tr\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\tr\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\tst\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\tst\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\tst\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\tst\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\tst\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\usa\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\usa\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\usa\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\usa\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\data\usa\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\imirror\findfile.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    findfile.c

Abstract:

    This module implements IMFindFirst/IMFindNext

Author:


Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define IMIRROR_DIR_ENUM_BUFFER_SIZE 4096

ULONG
IMConvertNT2Win32Error(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}


DWORD
IMFindNextFile(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    HANDLE  DirHandle,
    PFILE_FULL_DIR_INFORMATION *lpFindFileData
    )
/*++

    ThreadContext - instance data for this enumeration

    DirHandle - handle of directory to query.

    lpFindFileData - On a successful find, this parameter returns information
        about the located file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    if (ThreadContext->FindBufferNext != NULL) {

        *lpFindFileData = (PFILE_FULL_DIR_INFORMATION) ThreadContext->FindBufferNext;

        if ((*lpFindFileData)->NextEntryOffset > 0) {

            ThreadContext->FindBufferNext =
                (PVOID)(((PCHAR)*lpFindFileData ) + (*lpFindFileData)->NextEntryOffset );
        } else {

            ThreadContext->FindBufferNext = NULL;
        }

        return ERROR_SUCCESS;
    }

    ThreadContext->FindBufferNext = NULL;

    Status = NtQueryDirectoryFile(
                DirHandle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                ThreadContext->FindBufferBase,
                ThreadContext->FindBufferLength,
                FileFullDirectoryInformation,
                FALSE,                  // return multiple entries
                NULL,
                FALSE                   // not a rescan
                );

    if (NT_SUCCESS( Status )) {

        *lpFindFileData = (PFILE_FULL_DIR_INFORMATION) ThreadContext->FindBufferBase;

        if ((*lpFindFileData)->NextEntryOffset > 0) {

            ThreadContext->FindBufferNext =
                (PVOID)(((PCHAR) *lpFindFileData ) + (*lpFindFileData)->NextEntryOffset );
        }
        return STATUS_SUCCESS;

    }

    *lpFindFileData = NULL;

    if (Status == STATUS_NO_MORE_FILES ||
        Status == STATUS_NO_SUCH_FILE ||
        Status == STATUS_OBJECT_NAME_NOT_FOUND) {

        return STATUS_SUCCESS;
    }
    return IMConvertNT2Win32Error( Status );
}


DWORD
IMFindFirstFile(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    HANDLE  DirHandle,
    PFILE_FULL_DIR_INFORMATION *lpFindFileData
    )
/*++

Routine Description:

    This returns all entries in a directory.  This allocates a buffer if
    needed and sets up the variables in the ThreadContext to track the
    enumeration.

Arguments:

    ThreadContext - instance data for this enumeration

    DirHandle - handle of directory to query.

    lpFindFileData - Supplies a pointer to a full dir info structure.
        This points into our buffer and should not be freed by the caller.

    No call is required to close this, but note that a thread context
    can only have a single enumeration going on at any time.

Return Value:

    Win32 error.  ERROR_SUCCESS is only successful case.

--*/

{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    UNICODE_STRING allFiles;

    if (ThreadContext->FindBufferBase == NULL) {

        ThreadContext->FindBufferBase = IMirrorAllocMem( IMIRROR_DIR_ENUM_BUFFER_SIZE );

        if (ThreadContext->FindBufferBase == NULL) {

            return STATUS_NO_MEMORY;
        }

        ThreadContext->FindBufferLength = IMIRROR_DIR_ENUM_BUFFER_SIZE;
    }

    RtlInitUnicodeString( &allFiles, L"*" );

    ThreadContext->FindBufferNext = NULL;

    Status = NtQueryDirectoryFile(
                DirHandle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                ThreadContext->FindBufferBase,
                ThreadContext->FindBufferLength,
                FileFullDirectoryInformation,
                FALSE,                  // return multiple entries
                &allFiles,
                TRUE
                );
    if (NT_SUCCESS( Status )) {

        *lpFindFileData = (PFILE_FULL_DIR_INFORMATION) ThreadContext->FindBufferBase;

        if ((*lpFindFileData)->NextEntryOffset > 0) {

            ThreadContext->FindBufferNext =
                (PVOID)(((PCHAR) *lpFindFileData ) + (*lpFindFileData)->NextEntryOffset );
        }
    } else {

        *lpFindFileData = NULL;
    }
    return IMConvertNT2Win32Error( Status );
}


#if 0
BOOL
IMSetFileTime(
    HANDLE hFile,
    CONST FILETIME *lpCreationTime,
    CONST FILETIME *lpLastAccessTime,
    CONST FILETIME *lpLastWriteTime,
    CONST FILETIME *lpChangeTime
    )

/*++

Routine Description:

    Identical to SetFileTime Win32 api, expect this also allows to specify a new ChangeTime.

Arguments:

    hFile - Supplies an open handle to a file whose modification date and
        times are to be written.  The file handle must have been created
        with GENERIC_WRITE access to the file.

    lpCreationTime - An optional parameter, that if specified supplies
        the new creation time for the file.  Some file system's do not
        support this time value, so this parameter may be ignored.

    lpLastAccessTime - An optional parameter, that if specified supplies
        the new last access time for the file.  Some file system's do
        not support this time value, so this parameter may be ignored.

    lpLastWriteTime - An optional parameter, that if specified supplies
        the new last write time for the file.  A file system must support
        this time value.

    lpChangeTime - An optional parameter, that if specified supplies
        the new change time for the file.  A file system must support
        this time value.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;


    //
    // Zero all the time values we can set.
    //

    RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));

    //
    // For each time value that is specified, copy it to the I/O system
    // record.
    //
    if (ARGUMENT_PRESENT( lpCreationTime )) {
        BasicInfo.CreationTime.LowPart = lpCreationTime->dwLowDateTime;
        BasicInfo.CreationTime.HighPart = lpCreationTime->dwHighDateTime;
    }

    if (ARGUMENT_PRESENT( lpLastAccessTime )) {
        BasicInfo.LastAccessTime.LowPart = lpLastAccessTime->dwLowDateTime;
        BasicInfo.LastAccessTime.HighPart = lpLastAccessTime->dwHighDateTime;
    }

    if (ARGUMENT_PRESENT( lpLastWriteTime )) {
        BasicInfo.LastWriteTime.LowPart = lpLastWriteTime->dwLowDateTime;
        BasicInfo.LastWriteTime.HighPart = lpLastWriteTime->dwHighDateTime;
    }

    if (ARGUMENT_PRESENT( lpChangeTime )) {
        BasicInfo.ChangeTime.LowPart = lpChangeTime->dwLowDateTime;
        BasicInfo.ChangeTime.HighPart = lpChangeTime->dwHighDateTime;
    }

    //
    // Set the requested times.
    //

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
    } else {
        IMConvertNT2Win32Error(Status);
        return FALSE;
        }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\imirror\imirror.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    imirror.h

Abstract:

    This is the include file for the IntelliMirror conversion DLL

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/

//
//  These are the action codes for the file error report callback
//

#define COPY_ERROR_ACTION_CREATE_FILE   1
#define COPY_ERROR_ACTION_OPEN_DIR      2
#define COPY_ERROR_ACTION_CREATE_DIR    3
#define COPY_ERROR_ACTION_SETATTR       4
#define COPY_ERROR_ACTION_GETATTR       5
#define COPY_ERROR_ACTION_GETACL        6
#define COPY_ERROR_ACTION_SETACL        7
#define COPY_ERROR_ACTION_DELETE        8
#define COPY_ERROR_ACTION_ENUMERATE     9
#define COPY_ERROR_ACTION_MALLOC       10
#define COPY_ERROR_ACTION_SETTIME      11
#define COPY_ERROR_ACTION_GETSFN       12
#define COPY_ERROR_ACTION_SETSFN       13


//
// Basic To Do items
//
typedef enum _IMIRROR_TODO {
    IMirrorNone,
    IMirrorInitialize,
    VerifySystemIsNt5,
    CheckPartitions,
    CopyPartitions,
    CopyFiles,
    CopyRegistry,
    PatchDSEntries,
    RebootSystem
} IMIRROR_TODO, *PIMIRROR_TODO;

//
// Client call back function definitions
//
typedef
NTSTATUS
(*IMIRROR_ERROR_CALLBACK)(
    IN PVOID Context,
    IN NTSTATUS Status,
    IN IMIRROR_TODO IMirrorFunctionId
    );

typedef
NTSTATUS
(*IMIRROR_NOWDOING_CALLBACK)(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String
    );

typedef
NTSTATUS
(*IMIRROR_GETMIRRORDIR_CALLBACK)(
    IN PVOID Context,
    OUT PWSTR Server,
    IN OUT PULONG Length
    );

typedef
NTSTATUS
(*IMIRROR_GETSETUP_CALLBACK)(
    IN PVOID Context,
    IN PWSTR Server,
    OUT PWSTR SetupPath,
    IN OUT PULONG Length
    );

typedef
NTSTATUS
(*IMIRROR_SETSYSTEM_CALLBACK)(
    IN PVOID Context,
    IN PWSTR SystemPath,
    IN ULONG Length
    );

typedef
NTSTATUS
(*IMIRROR_FILECREATE_CALLBACK)(
    IN PVOID Context,
    IN PWSTR FileName,
    IN ULONG FileAction,
    IN ULONG Status
    );

typedef
NTSTATUS
(*IMIRROR_REGSAVE_CALLBACK)(
    IN PVOID Context,
    IN PWSTR Name,
    IN ULONG Status
    );

typedef
NTSTATUS
(*IMIRROR_REINIT_CALLBACK)(
    IN PVOID Context
    );

typedef
NTSTATUS
(*IMIRROR_ADDTODO_CALLBACK)(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String,
    IN ULONG Length
    );

typedef
NTSTATUS
(*IMIRROR_REBOOT_CALLBACK)(
    IN PVOID Context
    );

typedef
NTSTATUS
(*IMIRROR_REMOVETODO_CALLBACK)(
    IN PVOID Context,
    IN IMIRROR_TODO Function,
    IN PWSTR String,
    IN ULONG Length
    );

typedef struct _IMIRROR_CALLBACK {
    PVOID Context;
    IMIRROR_ERROR_CALLBACK ErrorFn;
    IMIRROR_NOWDOING_CALLBACK NowDoingFn;
    IMIRROR_GETSETUP_CALLBACK GetSetupFn;
    IMIRROR_FILECREATE_CALLBACK FileCreateFn;
    IMIRROR_REGSAVE_CALLBACK RegSaveErrorFn;
    IMIRROR_REINIT_CALLBACK ReinitFn;
    IMIRROR_GETMIRRORDIR_CALLBACK GetMirrorDirFn;
    IMIRROR_SETSYSTEM_CALLBACK SetSystemDirFn;
    IMIRROR_ADDTODO_CALLBACK AddToDoFn;
    IMIRROR_REMOVETODO_CALLBACK RemoveToDoFn;
    IMIRROR_REBOOT_CALLBACK RebootFn;
} IMIRROR_CALLBACK, *PIMIRROR_CALLBACK;

extern IMIRROR_CALLBACK Callbacks;

//
// Dll entry point
//
DWORD
IMirrorInitDll(
    IN HINSTANCE hInst,
    IN DWORD Reason,
    IN PVOID Context
    );

VOID
IMirrorInitCallback(
    IN PIMIRROR_CALLBACK Callbacks
    );

NTSTATUS
ProcessToDoItems(
    VOID
    );

NTSTATUS
InitToDo(
    VOID
    );

VOID
ClearAllToDoItems(
    IN BOOLEAN MemoryOnly
    );

NTSTATUS
SaveAllToDoItems(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\imirror\imirror.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    imirror.c

Abstract:

    This is the file for the IntelliMirror conversion DLL basic To Do item processing.

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Global variables
//
LIST_ENTRY GlobalToDoList;
IMIRROR_CALLBACK Callbacks;
BYTE TmpBuffer[TMP_BUFFER_SIZE];
BYTE TmpBuffer2[TMP_BUFFER_SIZE];
BYTE TmpBuffer3[TMP_BUFFER_SIZE];
HANDLE ghInst;
BOOL fInitedFromRegistry;
BOOL fCallbackPreviouslySet = FALSE;

#ifdef DEBUGLOG

HANDLE hDebugLogFile = INVALID_HANDLE_VALUE;
CRITICAL_SECTION DebugFileLock;

#endif

//
// Definitions for this file
//
typedef struct _TODOITEM {
    IMIRROR_TODO Item;
    PVOID Buffer;
    ULONG Length;
} TODOITEM, *PTODOITEM;


typedef struct _TODOLIST {
    LIST_ENTRY ListEntry;
    ULONG ToDoNum;
    TODOITEM ToDoList[1];
} TODOLIST, *PTODOLIST;




//
// Main entry routine
//
DWORD
IMirrorInitDll(
    HINSTANCE hInst,
    DWORD Reason,
    PVOID Context
    )

/*++

Routine Description:

    This routine initializes all the components for this DLL

Arguments:

    hInst - Instance that is calling us.

    Reason - Why we are being invoked.

    Context - Context passed for this init.

Return Value:

    TRUE if successful, else FALSE

--*/

{
    if (Reason == DLL_PROCESS_ATTACH) {

#ifdef DEBUGLOG

        InitializeCriticalSection( &DebugFileLock );

        hDebugLogFile = CreateFile(L"C:\\imlog",
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              CREATE_ALWAYS,
                              0,
                              NULL);

        if (hDebugLogFile != INVALID_HANDLE_VALUE){

            UCHAR FileTmpBuf[MAX_PATH ];
            SYSTEMTIME Time;
            // log the start time
            GetLocalTime(&Time);
            sprintf(FileTmpBuf,"Starting on %d-%d-%d at %d:%d:%d\n",
                    Time.wMonth,
                    Time.wDay,
                    Time.wYear,
                    Time.wHour,
                    Time.wMinute,
                    Time.wSecond);

            IMLogToFile(FileTmpBuf);
        }
#endif
        ghInst = hInst;

#ifdef DEBUGLOG
    } else if (Reason == DLL_PROCESS_DETACH) {

        if (hDebugLogFile != INVALID_HANDLE_VALUE){

            SYSTEMTIME Time;
            UCHAR FileTmpBuf[MAX_PATH ];

            GetLocalTime(&Time);

            sprintf(FileTmpBuf,"Ending on %d-%d-%d at %d:%d:%d\n",
                    Time.wMonth, Time.wDay, Time.wYear,
                    Time.wHour, Time.wMinute, Time.wSecond);

            IMLogToFile(FileTmpBuf);
            IMFlushAndCloseLog();
            hDebugLogFile = INVALID_HANDLE_VALUE;
            DeleteCriticalSection( &DebugFileLock );
        }
#endif

    }

    return(TRUE);
}

VOID
IMirrorInitCallback(
    PIMIRROR_CALLBACK pCallbacks
    )

/*++

Routine Description:

    This routine initializes the call back structure with the one supplied by the client.

Arguments:

    pCallbacks - Client supplied information for making callbacks to the client.

Return Value:

    None.

--*/

{
    if (pCallbacks != NULL) {
        Callbacks = *pCallbacks;
        if (fInitedFromRegistry) {
            IMirrorReinit();
        }
    }
}

//
//
//
// Main processing loop
//
//
//
NTSTATUS
ProcessToDoItems(
    VOID
    )

/*++

Routine Description:

    This routine is the main processing loop for To Do Items.

Arguments:

    None

Return Value:

    STATUS_SUCCESS if it completed all to do items properly.

--*/

{
    IMIRROR_TODO Item;
    PVOID pBuffer;
    ULONG Length;
    NTSTATUS Status;

    Status = InitToDo();
    if ( Status != STATUS_SUCCESS )
        return Status;

    while (1) {

        Status = GetNextToDoItem(&Item, &pBuffer, &Length);

        if (!NT_SUCCESS(Status)) {
            IMirrorHandleError(Status, IMirrorNone);
            return Status;
        }

        switch (Item) {

        case IMirrorNone:
            return STATUS_SUCCESS;

        case VerifySystemIsNt5:
            Status = CheckIfNt5(pBuffer, Length);
            break;

        case CheckPartitions:
            Status = CheckForPartitions(pBuffer, Length);
            break;

        case CopyPartitions:
            Status = CopyCopyPartitions(pBuffer, Length);
            break;

        case CopyFiles:
            Status = CopyCopyFiles(pBuffer, Length);
            break;

        case CopyRegistry:
            Status = CopyCopyRegistry(pBuffer, Length);
            break;
#if 0
        case PatchDSEntries:
            Status = ModifyDSEntries(pBuffer, Length);
            break;
#endif
        case RebootSystem:
            Status = Callbacks.RebootFn(Callbacks.Context);
            break;
        }

        IMirrorFreeMem(pBuffer);

    }

}

//
//
//
// TO DO Item functions
//
//
//

NTSTATUS
InitToDo(
    VOID
    )

/*++

Routine Description:

    This routine reads from the registry all the current ToDo items and puts
    them in a single TODOLIST.

Arguments:

    None

Return Value:

    STATUS_SUCCESS if it was initialized properly, else the appropriate error code.

--*/

{
#if 0
    PTODOLIST pToDoList;
    PTODOLIST pNewToDoList;
    PTODOITEM pToDoItem;
    PLIST_ENTRY pListEntry;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;
    HANDLE Handle;
    ULONG ByteCount;
    ULONG BytesLeft;
    ULONG i;
    PBYTE pBuffer;
#endif
    NTSTATUS Status;

    //
    // Initialize global variables
    //
    InitializeListHead(&GlobalToDoList);

#if 0
    //
    //
    // Read the current ToDo list from the registry
    //
    //
    RtlInitUnicodeString(&UnicodeString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\RemoteBoot");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = NtOpenKey(&Handle,
                       KEY_ALL_ACCESS,
                       &ObjectAttributes
                      );

    if (!NT_SUCCESS(Status)) {
        goto NoRegistry;
    }

    RtlInitUnicodeString(&UnicodeString, L"ConversionState");

    //
    // Get the size of the buffer needed
    //
    ByteCount = 0;
    Status = NtQueryValueKey(Handle,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             NULL,
                             0,
                             &ByteCount
                            );

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        NtClose(Handle);
        goto NoRegistry;
    }

    pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)IMirrorAllocMem(ByteCount);

    if (pKeyInfo == NULL) {
        NtClose(Handle);
        return STATUS_NO_MEMORY;
    }

    //
    // Get the buffer from the registry
    //
    Status = NtQueryValueKey(Handle,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             pKeyInfo,
                             ByteCount,
                             &ByteCount
                            );

    if (!NT_SUCCESS(Status)) {
        IMirrorFreeMem(pKeyInfo);
        NtClose(Handle);
        return Status;
    }

    pBuffer = &(pKeyInfo->Data[0]);
    BytesLeft = pKeyInfo->DataLength;
    ByteCount = BytesLeft;

    //
    // Now translate the buffer into our internal structures.
    //
    while (BytesLeft != 0) {

        pToDoList = (PTODOLIST)(pBuffer + ByteCount - BytesLeft);

        ASSERT(pToDoList->ToDoNum != 0);

        pNewToDoList = IMirrorAllocMem(sizeof(TODOLIST) +
                                      sizeof(TODOITEM) * (pToDoList->ToDoNum - 1)
                                     );

        if (pNewToDoList == NULL) {
            ClearAllToDoItems(TRUE);
            NtClose(Handle);
            return STATUS_NO_MEMORY;
        }
        BytesLeft -= (sizeof(TODOLIST) + sizeof(TODOITEM) * (pToDoList->ToDoNum - 1));

        pToDoItem = &(pToDoList->ToDoList[0]);

        //
        // Translate over one entire TODOLIST
        //
        while (pNewToDoList->ToDoNum < pToDoList->ToDoNum) {

            i = pNewToDoList->ToDoNum;
            pNewToDoList->ToDoList[i] = *pToDoItem;
            pNewToDoList->ToDoList[i].Buffer = IMirrorAllocMem(pToDoItem->Length);
            BytesLeft -= pToDoItem->Length;

            if (pNewToDoList->ToDoList[i].Buffer == NULL) {
                ClearAllToDoItems(TRUE);
                while (i > 0) {
                    i--;
                    IMirrorFreeMem(pNewToDoList->ToDoList[i].Buffer);
                }
                IMirrorFreeMem(pNewToDoList);
                NtClose(Handle);
                return STATUS_NO_MEMORY;
            }

            RtlMoveMemory(pNewToDoList->ToDoList[i].Buffer,
                          pToDoItem + 1,
                          pToDoItem->Length
                         );

            pNewToDoList->ToDoNum++;
            pToDoItem = (PTODOITEM)(((PBYTE)pToDoItem) + pToDoItem->Length);
            pToDoItem++;
        }

        //
        // Add this list to the global To Do list
        //
        InsertTailList(&GlobalToDoList, &(pNewToDoList->ListEntry));

    }

    //
    // Remove everything from the registry so we don't accidentally restart again and again and...
    //
    RtlInitUnicodeString(&UnicodeString, L"ConversionState");

    Status = NtDeleteValueKey(Handle, &UnicodeString);

    NtClose(Handle);

    if (!IsListEmpty(&GlobalToDoList)) {
        fInitedFromRegistry = TRUE;
        return STATUS_SUCCESS;
    }

NoRegistry:
#endif
    fInitedFromRegistry = FALSE;

    //
    // If there is nothing in the registry, presume this is a fresh start.
    //

    Status = AddCheckMachineToDoItems();

    if (!NT_SUCCESS(Status)) {
        ClearAllToDoItems(TRUE);
        return Status;
    }

    Status = AddCopyToDoItems();

    if (!NT_SUCCESS(Status)) {
        ClearAllToDoItems(TRUE);
        return Status;
    }

    if ( Callbacks.RebootFn ) {
        AddToDoItem( RebootSystem, NULL, 0 );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
GetNextToDoItem(
    OUT PIMIRROR_TODO Item,
    OUT PVOID *Buffer,
    OUT PULONG Length
    )
/*++

Routine Description:

    This routine gets the next thing TODO from the global list.

    NOTE: The client is responsible for freeing Buffer.

Arguments:

    Item - Place to store the next item to process.

    Buffer - Any context for the item.

    Length - Number of bytes in Buffer.

Return Value:

    STATUS_SUCCESS if it was able to get an item, else an appropriate error code.

--*/
{
    PTODOLIST pToDoList;
    PTODOLIST pNewToDoList;
    PLIST_ENTRY pListEntry;

    *Item = IMirrorNone;
    *Buffer = NULL;
    *Length = 0;

    pToDoList = NULL;

    while (!IsListEmpty(&GlobalToDoList)) {

        //
        // Get the first list
        //
        pListEntry = RemoveHeadList(&GlobalToDoList);

        pToDoList = CONTAINING_RECORD(pListEntry,
                                      TODOLIST,
                                      ListEntry
                                     );

        if (pToDoList->ToDoNum != 0) {
            break;
        }

        IMirrorFreeMem(pToDoList);
        pToDoList = NULL;

    }

    if (IsListEmpty(&GlobalToDoList) && (pToDoList == NULL)) {
        return STATUS_SUCCESS;
    }

    ASSERT(pToDoList->ToDoNum != 0);

    //
    // Found the first item.
    //

    *Item = pToDoList->ToDoList[0].Item;
    *Buffer = pToDoList->ToDoList[0].Buffer;
    *Length = pToDoList->ToDoList[0].Length;

    if (Callbacks.RemoveToDoFn != NULL) {

        Callbacks.RemoveToDoFn( Callbacks.Context, *Item, *Buffer, *Length );
    }

    pToDoList->ToDoNum--;

    //
    // Now create a new ToDo list for anything that may get added by the processing of this item.
    // This creates an effective 'stack' of to do items, so that things get processed in the
    // correct order.
    //

    pNewToDoList = IMirrorAllocMem(sizeof(TODOLIST));

    if (pNewToDoList == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Do an effective "pop" on the current list, by moving everything else up the list
    //
    if (pToDoList->ToDoNum == 0) {
        IMirrorFreeMem(pToDoList);
    } else {
        RtlMoveMemory(&(pToDoList->ToDoList[0]), &(pToDoList->ToDoList[1]), sizeof(TODOITEM) * pToDoList->ToDoNum);
        InsertHeadList(&GlobalToDoList, pListEntry);
    }

    //
    // Now push on the new space for new items.
    //
    pNewToDoList->ToDoNum = 0;
    InsertHeadList(&GlobalToDoList, &(pNewToDoList->ListEntry));

    return STATUS_SUCCESS;
}

NTSTATUS
AddToDoItem(
    IN IMIRROR_TODO Item,
    IN PVOID Buffer,
    IN ULONG Length
    )
/*++

Routine Description:

    This routine adds a TODO item to the end of the current list.  It allocates
    new memory and copies the buffer.

Arguments:

    Item - The item id.

    Buffer - Buffer for any arguments, context for the item.

    Length - Length of the buffer in bytes.

Return Value:

    STATUS_SUCCESS if it was able to add the item, else an appropriate error status.

--*/

{
    PTODOLIST pNewToDoList;
    PLIST_ENTRY pListEntry;
    PBYTE pBuf;
    LIST_ENTRY TmpToDoList;
    PTODOLIST pToDoList;
    ULONG i;
    ULONG err;

    if (Callbacks.AddToDoFn != NULL) {

        err = Callbacks.AddToDoFn( Callbacks.Context, Item, Buffer, Length );

        if (err != STATUS_SUCCESS) {

            //
            //  if the UI bounces the request, we'll treat it as success.
            //

            return STATUS_SUCCESS;
        }
    }

    //
    // Allocate space for the buffer
    //
    if (Length != 0) {

        pBuf = IMirrorAllocMem(Length);

        if (pBuf == NULL) {
            return STATUS_NO_MEMORY;
        }

    } else {
        pBuf = NULL;
    }

    //
    // Get the current TODO List
    //
    if (IsListEmpty(&GlobalToDoList)) {

        pNewToDoList = IMirrorAllocMem(sizeof(TODOLIST));
        if (pNewToDoList == NULL) {
            IMirrorFreeMem(pBuf);
            return STATUS_NO_MEMORY;
        }

        pNewToDoList->ToDoNum = 1;

    } else {

        pListEntry = RemoveHeadList(&GlobalToDoList);

        pToDoList = CONTAINING_RECORD(pListEntry,
                                      TODOLIST,
                                      ListEntry
                                     );

        //
        // Allocate space for the new item
        //
        pNewToDoList = IMirrorReallocMem(pToDoList, sizeof(TODOLIST) + sizeof(TODOITEM) * pToDoList->ToDoNum);

        if (pNewToDoList == NULL) {
            InsertHeadList(&GlobalToDoList, pListEntry);
            IMirrorFreeMem(pBuf);
            return STATUS_NO_MEMORY;
        }

        pNewToDoList->ToDoNum++;

    }

    //
    // Insert the item at the end of the list
    //
    if (pBuf != NULL) {
        RtlMoveMemory(pBuf, Buffer, Length);
    }
    pNewToDoList->ToDoList[pNewToDoList->ToDoNum - 1].Item = Item;
    pNewToDoList->ToDoList[pNewToDoList->ToDoNum - 1].Buffer = pBuf;
    pNewToDoList->ToDoList[pNewToDoList->ToDoNum - 1].Length = Length;

    pListEntry = &(pNewToDoList->ListEntry);
    InsertHeadList(&GlobalToDoList, pListEntry);

    return STATUS_SUCCESS;
}

VOID
ClearAllToDoItems(
    IN BOOLEAN MemoryOnly
    )
/*++

Routine Description:

    This routine clears out all To Do items in memory and the registry

Arguments:

    MemoryOnly - TRUE if to only clear the stuff in memory.

Return Value:

    None.

--*/
{
    PTODOLIST pToDoList;
    PLIST_ENTRY pListEntry;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle;
    NTSTATUS Status;

    //
    // Clear out all the items in memory
    //
    while (!IsListEmpty(&GlobalToDoList)) {

        //
        // Get the first list
        //
        pListEntry = RemoveHeadList(&GlobalToDoList);

        pToDoList = CONTAINING_RECORD(pListEntry,
                                      TODOLIST,
                                      ListEntry
                                     );

        while (pToDoList->ToDoNum != 0) {
            pToDoList->ToDoNum--;

            if (Callbacks.RemoveToDoFn != NULL) {

                Callbacks.RemoveToDoFn( Callbacks.Context,
                                        pToDoList->ToDoList[pToDoList->ToDoNum].Item,
                                        pToDoList->ToDoList[pToDoList->ToDoNum].Buffer,
                                        pToDoList->ToDoList[pToDoList->ToDoNum].Length );
            }

            if (pToDoList->ToDoList[pToDoList->ToDoNum].Length != 0) {
                IMirrorFreeMem(pToDoList->ToDoList[pToDoList->ToDoNum].Buffer);
            }
        }

        IMirrorFreeMem(pToDoList);

    }

    if (MemoryOnly) {
        return;
    }

    //
    // Now clear out the ones in the registry
    //
    RtlInitUnicodeString(&UnicodeString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\RemoteBoot");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = NtOpenKey(&Handle,
                       KEY_ALL_ACCESS,
                       &ObjectAttributes
                      );

    if (!NT_SUCCESS(Status)) {
        return;
    }

    RtlInitUnicodeString(&UnicodeString, L"ConversionState");

    Status = NtDeleteValueKey(Handle, &UnicodeString);

    NtClose(Handle);
}

NTSTATUS
SaveAllToDoItems(
    VOID
    )
/*++

Routine Description:

    This routine writes out all To Do items in the list to the registry so that conversion
    can be restarted later.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS if it was able to save, else an appropriate error status.

--*/
{
    return STATUS_SUCCESS;
#if 0
    PTODOLIST pToDoList;
    PTODOITEM pToDoItem;
    PLIST_ENTRY pListEntry;
    LIST_ENTRY TmpGlobalList;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle;
    ULONG ByteCount;
    ULONG i;
    PBYTE pBuffer;
    PBYTE pTmp;
    NTSTATUS Status;

    //
    // First find the size of buffer that will be needed.
    //
    ByteCount = 0;
    InitializeListHead(&TmpGlobalList);
    while (!IsListEmpty(&GlobalToDoList)) {

        //
        // Get the first list
        //
        pListEntry = RemoveHeadList(&GlobalToDoList);

        pToDoList = CONTAINING_RECORD(pListEntry,
                                      TODOLIST,
                                      ListEntry
                                     );

        //
        // Get the size of all the items
        //
        i = 0;

        while (i < pToDoList->ToDoNum) {

            if (i == 0) {
                ByteCount += sizeof(TODOLIST);
            } else {
                ByteCount += sizeof(TODOITEM);
            }

            ByteCount += pToDoList->ToDoList[i].Length;

            i++;

        }

        //
        // Save the entry away for later
        //
        InsertTailList(&TmpGlobalList, pListEntry);

    }

    if (ByteCount == 0) {
        return STATUS_SUCCESS;
    }

    //
    // Restore global list
    //
    while (!IsListEmpty(&TmpGlobalList)) {
        pListEntry = RemoveHeadList(&TmpGlobalList);
        InsertTailList(&GlobalToDoList, pListEntry);
    }

    //
    // Allocate a buffer for everything.
    //
    pBuffer = IMirrorAllocMem(ByteCount);

    if (pBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Fill the buffer
    //
    pTmp = pBuffer;

    while (!IsListEmpty(&GlobalToDoList)) {

        //
        // Get the first list
        //
        pListEntry = RemoveHeadList(&GlobalToDoList);

        pToDoList = CONTAINING_RECORD(pListEntry,
                                      TODOLIST,
                                      ListEntry
                                     );

        //
        // Copy all the items
        //
        i = 0;

        while (i < pToDoList->ToDoNum) {

            if (i == 0) {
                RtlMoveMemory(pTmp, pToDoList, sizeof(TODOLIST));
                pToDoItem = &(((PTODOLIST)pTmp)->ToDoList[0]);
                pTmp += sizeof(TODOLIST);
            } else {
                RtlMoveMemory(pTmp, &(pToDoList->ToDoList[i]), sizeof(TODOITEM));
                pToDoItem = (PTODOITEM)pTmp;
                pTmp += sizeof(TODOITEM);
            }

            if (pToDoList->ToDoList[i].Length != 0) {
                RtlMoveMemory(pTmp, pToDoList->ToDoList[i].Buffer, pToDoList->ToDoList[i].Length);
                pTmp += pToDoList->ToDoList[i].Length;
            }

            pToDoItem->Buffer = NULL;
            i++;

        }

        //
        // Save the entry away for later
        //
        InsertTailList(&TmpGlobalList, pListEntry);

    }

    //
    // Restore global list
    //
    while (!IsListEmpty(&TmpGlobalList)) {
        pListEntry = RemoveHeadList(&TmpGlobalList);
        InsertTailList(&GlobalToDoList, pListEntry);
    }

    //
    // Now write the buffer to the registry
    //
    RtlInitUnicodeString(&UnicodeString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\RemoteBoot");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = NtCreateKey(&Handle,
                         KEY_ALL_ACCESS,
                         &ObjectAttributes,
                         0,
                         (PUNICODE_STRING)NULL,
                         0,
                         &i     // disposition
                         );

    if (!NT_SUCCESS(Status)) {
        IMirrorFreeMem(pBuffer);
        return Status;
    }

    RtlInitUnicodeString(&UnicodeString, L"ConversionState");

    Status = NtSetValueKey(Handle,
                           &UnicodeString,
                           0,
                           REG_BINARY,
                           pBuffer,
                           ByteCount
                          );

    NtClose(Handle);
    IMirrorFreeMem(pBuffer);
    return Status;
#endif
}

NTSTATUS
ModifyToDoItem(
    IN IMIRROR_TODO Item,
    IN PVOID Buffer,
    IN ULONG Length
    )
/*++

Routine Description:

    This routine changes the parameters to the first TODO item that matches Item.

Arguments:

    Item - The item id.

    Buffer - Buffer for any arguments, context for the item.

    Length - Length of the buffer in bytes.

Return Value:

    STATUS_SUCCESS if it was able to change the item, else an appropriate error status.

--*/

{
    PLIST_ENTRY pListEntry;
    LIST_ENTRY TmpGlobalList;
    PTODOLIST pToDoList;
    ULONG i;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    InitializeListHead(&TmpGlobalList);
    while (!IsListEmpty(&GlobalToDoList)) {

        //
        // Get the first list
        //
        pListEntry = RemoveHeadList(&GlobalToDoList);

        pToDoList = CONTAINING_RECORD(pListEntry,
                                      TODOLIST,
                                      ListEntry
                                     );

        //
        // Save the entry away for later
        //
        InsertTailList(&TmpGlobalList, pListEntry);

        //
        // Walk the list until we find an item that matches.
        //
        i = 0;

        while (i < pToDoList->ToDoNum) {

            if (pToDoList->ToDoList[i].Item == Item) {

                if (pToDoList->ToDoList[i].Length == Length) {

                    RtlMoveMemory(pToDoList->ToDoList[i].Buffer, Buffer, Length);

                } else {

                    PVOID pTmp;

                    pTmp = IMirrorAllocMem(Length);

                    if (pTmp == NULL) {
                        return STATUS_NO_MEMORY;
                    }

                    if (pToDoList->ToDoList[i].Length != 0) {
                        IMirrorFreeMem(pToDoList->ToDoList[i].Buffer);
                    }

                    pToDoList->ToDoList[i].Buffer = pTmp;
                    pToDoList->ToDoList[i].Length = Length;

                    RtlMoveMemory(pTmp, Buffer, Length);

                }

                Status = STATUS_SUCCESS;
                goto Done;
            }

            i++;

        }

    }

Done:

    //
    // Restore global list
    //
    while (!IsListEmpty(&TmpGlobalList)) {
        pListEntry = RemoveTailList(&TmpGlobalList);
        InsertHeadList(&GlobalToDoList, pListEntry);
    }

    return Status;
}

NTSTATUS
CopyToDoItemParameters(
    IN IMIRROR_TODO Item,
    OUT PVOID Buffer,
    IN OUT PULONG Length
    )
/*++

Routine Description:

    This routine finds the first instance of Item, and copies its current parameters into Buffer.

Arguments:

    Item - The item id.

    Buffer - The arguments, context for the item.

    Length - Length of the buffer in bytes.

Return Value:

    STATUS_SUCCESS if it was able to change the item, else an appropriate error status.

--*/

{
    PLIST_ENTRY pListEntry;
    LIST_ENTRY TmpGlobalList;
    PTODOLIST pToDoList;
    ULONG i;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    InitializeListHead(&TmpGlobalList);
    while (!IsListEmpty(&GlobalToDoList)) {

        //
        // Get the first list
        //
        pListEntry = RemoveHeadList(&GlobalToDoList);

        pToDoList = CONTAINING_RECORD(pListEntry,
                                      TODOLIST,
                                      ListEntry
                                     );

        //
        // Save the entry away for later
        //
        InsertTailList(&TmpGlobalList, pListEntry);

        //
        // Walk the list until we find an item that matches.
        //
        i = 0;

        while (i < pToDoList->ToDoNum) {

            if (pToDoList->ToDoList[i].Item == Item) {

                if (pToDoList->ToDoList[i].Length <= *Length) {

                    if (pToDoList->ToDoList[i].Length != 0) {

                        RtlMoveMemory(Buffer,
                                      pToDoList->ToDoList[i].Buffer,
                                      pToDoList->ToDoList[i].Length
                                     );

                    }

                    Status = STATUS_SUCCESS;

                } else {

                    Status = STATUS_INSUFFICIENT_RESOURCES;

                }

                *Length = pToDoList->ToDoList[i].Length;
                goto Done;
            }

            i++;

        }

    }

Done:

    //
    // Restore global list
    //
    while (!IsListEmpty(&TmpGlobalList)) {
        pListEntry = RemoveTailList(&TmpGlobalList);
        InsertHeadList(&GlobalToDoList, pListEntry);
    }

    return Status;
}
#if 0

NTSTATUS
IMirrorDoReboot(
    IN PVOID pBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine saves all the current to do items in the registry, and asks the UI if the
    reboot should be executed now.

Arguments:

    pBuffer - Pointer to any arguments passed in the to do item.

    Length - Length, in bytes of the arguments.

Return Value:

    STATUS_SUCCESS if it completes adding all the to do items properly.

--*/

{
    NTSTATUS Status;
    BOOL fRebootNow;
    BOOLEAN WasEnabled;
    DWORD Error;


    //
    // Add items to reverify the machine when the reboot is complete.
    //
#if 0
    Status = AddToDoItem(VerifyNetworkComponents, NULL, 0);

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, IMirrorInitialize);
        return Status;
    }
#endif
    //
    // Now save everything away...
    //
    Status = SaveAllToDoItems();
    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, IMirrorReboot);
        return Status;
    }

    ClearAllToDoItems(TRUE);

    IMirrorWarnReboot(&fRebootNow);

    if (!fRebootNow) {
        return STATUS_SUCCESS;
    }


    //
    // Reboot the machine to start CSC
    //
    Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                 (BOOLEAN)TRUE,
                                 TRUE,
                                 &WasEnabled
                               );

    if (Status == STATUS_NO_TOKEN) {

        //
        // No thread token, use the process token
        //

        Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                     (BOOLEAN)TRUE,
                                     FALSE,
                                     &WasEnabled
                                   );
        }


    if (!InitiateSystemShutdown(NULL, NULL, 0, TRUE, TRUE)) {
        IMirrorHandleError(ERROR_SUCCESS_REBOOT_REQUIRED, IMirrorReboot);
    }

    return STATUS_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\imirror\ckmach.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ckmach.h

Abstract:

    This is the include file for supporting checking a machine to see if it can
    be converted to IntelliMirror.

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/

//
// Main processing functions
//
NTSTATUS
AddCheckMachineToDoItems(
    VOID
    );

//
// Support functions to do individual tasks
//
NTSTATUS
CheckIfNt5(
    IN PVOID Buffer,
    IN ULONG Length
    );

NTSTATUS
CheckForPartitions(
    IN PVOID Buffer,
    IN ULONG Length
    );
//
// Utility functions
//
NTSTATUS
NtPathToDosPath(
    IN PWCHAR NtPath,
    OUT PWCHAR DosPath,
    IN BOOLEAN GetDriveOnly,
    IN BOOLEAN NtPathIsBasic
    );

NTSTATUS
NtNameToArcName(
    IN PWSTR NtName,
    OUT PWSTR ArcName,
    IN BOOLEAN NtNameIsBasic
    );

NTSTATUS
GetBaseDeviceName(
    IN PWSTR SymbolicName,
    OUT PWSTR Buffer,
    IN ULONG Size
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\imirror\copy.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    copy.c

Abstract:

    This is for supporting copying files, creating new files, and copying the registries to
    the remote server.

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

WCHAR pConfigPath[MAX_PATH];
WCHAR pSystemPath[MAX_PATH];
WCHAR pCSDVersion[128];
WCHAR pProcessorArchitecture[64];
WCHAR pCurrentType[128];
WCHAR pHalName[128];

#if 0
IMIRROR_MODIFY_DS_INFO ModifyInfo;
#endif

NTSTATUS
AddCopyToDoItems(
    VOID
    )

/*++

Routine Description:

    This routine adds all the to do items necessary for copying files and registries to
    a server installation point, as well as creating new files necessary for remote boot.

Arguments:

    None

Return Value:

    STATUS_SUCCESS if it completes adding all the to do items properly.

--*/

{
    NTSTATUS Status;
    Status = AddToDoItem(CheckPartitions, NULL, 0);

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, IMirrorInitialize);
        return Status;
    }

    Status = AddToDoItem(CopyPartitions, NULL, 0);

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, IMirrorInitialize);
        return Status;
    }
#if 0
    Status = AddToDoItem(PatchDSEntries, &ModifyInfo, sizeof(ModifyInfo)); // NOTE: This MUST come before MungeRegistry

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, IMirrorInitialize);
        return Status;
    }
#endif
    return STATUS_SUCCESS;
}










//
// Functions for processing each TO DO item
//

NTSTATUS
CopyCopyPartitions(
    IN PVOID pBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine verifies that any partition on the same disk as in the parameter pBuffer, has
    enough free space to hold all the files in the partition that is also in pBuffer.

Arguments:

    pBuffer - Pointer to any arguments passed in the to do item.

    Length - Length, in bytes of the arguments.

Return Value:

    STATUS_SUCCESS if it completes adding all the to do items properly.

--*/

{
    NTSTATUS Status;
    PLIST_ENTRY listEntry;
    PMIRROR_VOLUME_INFO mirrorVolInfo;
    ULONG numberPartitions;
    BOOLEAN copyRegistry = FALSE;
    ULONG NameLength;
    ULONG TmpUlong;
    ULONG baseLength;
    BOOLEAN gotUncPath = FALSE;

    IMirrorNowDoing(CopyPartitions, NULL);

    if (GlobalMirrorCfgInfo == NULL) {

        Status = CheckForPartitions( pBuffer, Length );

        if (!NT_SUCCESS(Status)) {
            IMirrorHandleError(Status, CopyPartitions);
            return Status;
        }
    }

    listEntry = GlobalMirrorCfgInfo->MirrorVolumeList.Flink;

    numberPartitions = 0;
    Status = STATUS_SUCCESS;

    while (listEntry != &GlobalMirrorCfgInfo->MirrorVolumeList) {

        mirrorVolInfo = (PMIRROR_VOLUME_INFO) CONTAINING_RECORD(
                                                listEntry,
                                                MIRROR_VOLUME_INFO,
                                                ListEntry
                                                );
        listEntry = listEntry->Flink;

        if (mirrorVolInfo->MirrorUncPath == NULL) {

            if (! gotUncPath) {

                gotUncPath = TRUE;
                NameLength = TMP_BUFFER_SIZE;

                Status = IMirrorGetMirrorDir( (PWCHAR)TmpBuffer,
                                             &NameLength);

                if (!NT_SUCCESS(Status)) {

                    IMirrorHandleError(Status, CopyPartitions);
                    return Status;
                }

                baseLength = lstrlenW( (PWCHAR) TmpBuffer );
            }

            swprintf(   (PWCHAR)TmpBuffer2,
                        L"\\Mirror%d",
                        mirrorVolInfo->MirrorTableIndex );

            *((PWCHAR)(TmpBuffer)+baseLength) = L'\0';

            lstrcatW( (PWCHAR)TmpBuffer, (PWCHAR)TmpBuffer2 );

            NameLength = (lstrlenW( (PWCHAR)TmpBuffer ) + 1) * sizeof(WCHAR);

            mirrorVolInfo->MirrorUncPath = IMirrorAllocMem(NameLength);

            if (mirrorVolInfo->MirrorUncPath == NULL) {

                Status = STATUS_NO_MEMORY;
                IMirrorHandleError(Status, CopyPartitions);
                return Status;
            }

            RtlMoveMemory( mirrorVolInfo->MirrorUncPath,
                           TmpBuffer,
                           NameLength );
        }

        IMirrorNowDoing(CopyPartitions, mirrorVolInfo->MirrorUncPath);

        if (mirrorVolInfo->IsBootDisk) {

            copyRegistry = TRUE;
        }

        Status = AddToDoItem(CopyFiles, &mirrorVolInfo->DriveLetter, sizeof(WCHAR));

        if (!NT_SUCCESS(Status)) {
            IMirrorHandleError(Status, CheckPartitions);
            return Status;
        }

        numberPartitions++;
    }

    if (copyRegistry) {

        Status = AddToDoItem(CopyRegistry, pBuffer, Length);

        if (!NT_SUCCESS(Status)) {
            IMirrorHandleError(Status, CopyPartitions);
            return Status;
        }
    }

    //
    //  write out the mirror config file locally so that if we restart, we
    //  can retrieve the same config again.
    //

    if (numberPartitions && ! GlobalMirrorCfgInfo->SysPrepImage) {

        //
        // Write it out to \\SystemRoot\System32\IMirror.dat
        //

        Status = GetBaseDeviceName(L"\\SystemRoot", (PWCHAR)TmpBuffer2, sizeof(TmpBuffer2));

        wcscat((PWCHAR)TmpBuffer2, L"\\System32\\");
        wcscat((PWCHAR)TmpBuffer2, IMIRROR_DAT_FILE_NAME );

        Status = NtPathToDosPath((PWCHAR)TmpBuffer2, (PWCHAR)TmpBuffer, FALSE, FALSE);

        if (NT_SUCCESS(Status)) {

            Status = WriteMirrorConfigFile((PWCHAR) TmpBuffer);

            if (!NT_SUCCESS(Status)) {
                IMirrorHandleError(Status, CopyPartitions);
            }
        }
    }

    return Status;
}



NTSTATUS
CopyCopyFiles(
    IN PVOID pBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine copies all the files on the given drive to the remote server.

Arguments:

    pBuffer - Pointer to any arguments passed in the to do item.
              The argument must be the drive letter

    Length - Length, in bytes of the arguments.  Should be sizeof(WCHAR)

Return Value:

    STATUS_SUCCESS if it completes the to do item properly.

--*/

{
    PLIST_ENTRY listEntry;
    PMIRROR_VOLUME_INFO mirrorVolInfo;
    NTSTATUS Status;
    WCHAR LocalBuffer[TMP_BUFFER_SIZE];
    WCHAR SourcePath[8];
    PCOPY_TREE_CONTEXT copyContext = NULL;
    BOOLEAN BackupPriviledged = FALSE;

    Status = IMirrorNowDoing(CopyFiles, NULL);
    if ( Status != NO_ERROR ) {
        return Status;
    }

    if (GlobalMirrorCfgInfo == NULL) {

        Status = CheckForPartitions( pBuffer, Length );

        if (!NT_SUCCESS(Status)) {
            IMirrorHandleError(Status, CopyFiles);
            return Status;
        }
    }

    if (Length != sizeof(WCHAR) || pBuffer == NULL) {

        IMirrorHandleError(ERROR_INVALID_DRIVE, CopyFiles);
        return ERROR_INVALID_DRIVE;
    }

    listEntry = GlobalMirrorCfgInfo->MirrorVolumeList.Flink;

    while (listEntry != &GlobalMirrorCfgInfo->MirrorVolumeList) {

        mirrorVolInfo = (PMIRROR_VOLUME_INFO) CONTAINING_RECORD(
                                                listEntry,
                                                MIRROR_VOLUME_INFO,
                                                ListEntry
                                                );
        listEntry = listEntry->Flink;

        if (mirrorVolInfo->DriveLetter == *(PWCHAR)pBuffer) {
            break;
        }

        mirrorVolInfo = NULL;
    }
    if (mirrorVolInfo == NULL) {

        IMirrorHandleError(ERROR_INVALID_DRIVE, CopyFiles);
        return ERROR_INVALID_DRIVE;
    }

    //
    // Create root directory, don't fail if it already exists
    //
    if (!CreateDirectory(mirrorVolInfo->MirrorUncPath, NULL)) {

        Status = GetLastError();

        if (Status != ERROR_ALREADY_EXISTS) {
            IMirrorHandleError(Status, CopyFiles);
            return Status;
        }
    }

    //
    //   create the config file in this mirror root
    //

    lstrcpyW( LocalBuffer, mirrorVolInfo->MirrorUncPath );
    wcscat( LocalBuffer, L"\\");
    wcscat( LocalBuffer, IMIRROR_DAT_FILE_NAME );

    Status = WriteMirrorConfigFile(LocalBuffer);

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CopyFiles);
        return Status;
    }

    if (!GlobalMirrorCfgInfo->SysPrepImage) {

        //
        //  create staging directory if one is required
        //

        lstrcpyW( LocalBuffer, mirrorVolInfo->MirrorUncPath );
        wcscat( LocalBuffer, L"\\Staging");

        if (!CreateDirectory( LocalBuffer, NULL)) {
            Status = GetLastError();

            if (Status != ERROR_ALREADY_EXISTS) {
                IMirrorHandleError(Status, CopyFiles);
                return Status;
            }
        }
    }

    if (mirrorVolInfo->PartitionActive) {

        //
        //  copy the boot code to the server
        //

        lstrcpyW( LocalBuffer, mirrorVolInfo->MirrorUncPath );
        wcscat( LocalBuffer, L"\\BootCode.dat");

        Status = SaveBootSector(    mirrorVolInfo->DiskNumber,
                                    mirrorVolInfo->PartitionNumber,
                                    mirrorVolInfo->BlockSize,
                                    LocalBuffer );

        if (Status != STATUS_SUCCESS) {
            IMirrorHandleError(Status, CopyFiles);
            return Status;
        }
    }

    //
    // Create UserData directory, don't fail if it already exists
    //

    lstrcpyW( LocalBuffer, mirrorVolInfo->MirrorUncPath );
    wcscat( LocalBuffer, L"\\UserData");

    if (!CreateDirectory( LocalBuffer, NULL)) {
        Status = GetLastError();

        if (Status != ERROR_ALREADY_EXISTS) {
            IMirrorHandleError(Status, CopyFiles);
            return Status;
        }
    }

    //
    //  set up the dest path ready for really long file names.
    //

    if (*(mirrorVolInfo->MirrorUncPath) == L'\\' &&
        *(mirrorVolInfo->MirrorUncPath+1) == L'\\') {

        if (*(mirrorVolInfo->MirrorUncPath+2) == L'?') {

            // dest is \\?\..., it's of the correct format

            lstrcpyW( LocalBuffer, mirrorVolInfo->MirrorUncPath );

        } else {

            // dest is \\billg1\imirror
            // format should be \\?\UNC\billg1\imirror

            lstrcpyW( LocalBuffer, L"\\\\?\\UNC" );
            lstrcatW( LocalBuffer, mirrorVolInfo->MirrorUncPath + 1 );
        }
    } else {

        // dest is something like X:
        // format should be \\?\X:

        lstrcpyW( LocalBuffer, L"\\\\?\\" );
        lstrcatW( LocalBuffer, mirrorVolInfo->MirrorUncPath );
    }

    wcscat( LocalBuffer, L"\\UserData");

    SourcePath[0] = L'\\';  // format is L"\\\\?\\E:"
    SourcePath[1] = L'\\';
    SourcePath[2] = L'?';
    SourcePath[3] = L'\\';
    SourcePath[4] = mirrorVolInfo->DriveLetter;
    SourcePath[5] = L':';
    SourcePath[6] = L'\\';
    SourcePath[7] = L'\0';

    //
    // Copy all the files
    //

    Status = AllocateCopyTreeContext( &copyContext, TRUE );

    if (Status != ERROR_SUCCESS) {

        IMirrorHandleError(Status, CopyFiles);
        return Status;
    }

    if (RTEnableBackupRestorePrivilege()) {
        BackupPriviledged = TRUE;
    }

    Status = CopyTree( copyContext,
                       (BOOLEAN) (mirrorVolInfo->PartitionType == PARTITION_IFS),
                       &SourcePath[0],
                       LocalBuffer );

    if (BackupPriviledged) {
        RTDisableBackupRestorePrivilege();
    }

    if (copyContext->Cancelled) {
        //
        //  since the copy was cancelled, let's bail on the rest of the processing.
        //

        ClearAllToDoItems(TRUE);
    }

    FreeCopyTreeContext( copyContext );

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CopyFiles);
        return(Status);
    }
    return Status;
}

NTSTATUS
CopyCopyRegistry(
    IN PVOID pBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine copies the currently running registries to the server.

Arguments:

    pBuffer - Pointer to any arguments passed in the to do item.

    Length - Length, in bytes of the arguments.

Return Value:

    STATUS_SUCCESS if it completes the to do item properly.

--*/

{
    NTSTATUS Status;
    PLIST_ENTRY listEntry;
    ULONG Error;
    PMIRROR_VOLUME_INFO mirrorVolInfo;

    IMirrorNowDoing(CopyRegistry, NULL);

    if (GlobalMirrorCfgInfo == NULL) {

        Status = CheckForPartitions( pBuffer, Length );

        if (!NT_SUCCESS(Status)) {
            IMirrorHandleError(Status, CopyRegistry);
            return Status;
        }
    }

    listEntry = GlobalMirrorCfgInfo->MirrorVolumeList.Flink;

    while (listEntry != &GlobalMirrorCfgInfo->MirrorVolumeList) {

        mirrorVolInfo = (PMIRROR_VOLUME_INFO) CONTAINING_RECORD(
                                                listEntry,
                                                MIRROR_VOLUME_INFO,
                                                ListEntry
                                                );
        listEntry = listEntry->Flink;

        if (mirrorVolInfo->IsBootDisk) {
            break;
        }

        mirrorVolInfo = NULL;
    }
    if (mirrorVolInfo == NULL) {

        IMirrorHandleError(ERROR_INVALID_DRIVE, CopyRegistry);
        return ERROR_INVALID_DRIVE;
    }

    //
    // Now do registry backup
    //

    Error = DoFullRegBackup( mirrorVolInfo->MirrorUncPath );
    if (Error != NO_ERROR) {
        IMirrorHandleError(Error, CopyRegistry);
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
WriteMirrorConfigFile(
    PWCHAR DestFile
    )
{
    ULONG bufferSize;
    PCHAR buffer;
    PLIST_ENTRY listEntry;
    PMIRROR_VOLUME_INFO mirrorVolInfo;
    PMIRROR_VOLUME_INFO_FILE mirrorVolInfoFile;
    PMIRROR_CFG_INFO_FILE mirrorInfoFile;
    ULONG pathLength;
    ULONG systemPathLength;
    ULONG csdVersionLength;
    ULONG processorArchitectureLength;
    ULONG currentTypeLength;
    ULONG halNameLength;
    PWCHAR nextString;
    NTSTATUS Status;
    HANDLE fileHandle;

retryWriteConfig:

    mirrorInfoFile = NULL;
    Status = STATUS_SUCCESS;
    fileHandle = INVALID_HANDLE_VALUE;

    ASSERT(GlobalMirrorCfgInfo != NULL);

    systemPathLength = (lstrlenW( GlobalMirrorCfgInfo->SystemPath ) + 1) * sizeof(WCHAR);
    csdVersionLength = (lstrlenW( GlobalMirrorCfgInfo->CSDVersion ) + 1) * sizeof(WCHAR);
    processorArchitectureLength = (lstrlenW( GlobalMirrorCfgInfo->ProcessorArchitecture ) + 1) * sizeof(WCHAR);
    currentTypeLength = (lstrlenW( GlobalMirrorCfgInfo->CurrentType ) + 1) * sizeof(WCHAR);
    halNameLength = (lstrlenW( GlobalMirrorCfgInfo->HalName ) + 1) * sizeof(WCHAR);

    bufferSize = sizeof( MIRROR_CFG_INFO_FILE ) +
                (sizeof( MIRROR_VOLUME_INFO_FILE ) *
                 (GlobalMirrorCfgInfo->NumberVolumes - 1)) +
                 systemPathLength +
                 csdVersionLength +
                 processorArchitectureLength +
                 currentTypeLength +
                 halNameLength;

    listEntry = GlobalMirrorCfgInfo->MirrorVolumeList.Flink;

    while (listEntry != &GlobalMirrorCfgInfo->MirrorVolumeList) {

        mirrorVolInfo = (PMIRROR_VOLUME_INFO) CONTAINING_RECORD(
                                                listEntry,
                                                MIRROR_VOLUME_INFO,
                                                ListEntry
                                                );
        listEntry = listEntry->Flink;
        bufferSize += ((lstrlenW( mirrorVolInfo->MirrorUncPath ) + 1) * sizeof(WCHAR)) +
                      ((lstrlenW( mirrorVolInfo->VolumeLabel ) + 1) * sizeof(WCHAR)) +
                      ((lstrlenW( mirrorVolInfo->NtName ) + 1) * sizeof(WCHAR)) +
                      ((lstrlenW( mirrorVolInfo->ArcName ) + 1) * sizeof(WCHAR));
    }

    mirrorInfoFile = (PMIRROR_CFG_INFO_FILE) IMirrorAllocMem( bufferSize );

    if (mirrorInfoFile == NULL) {

        Status = STATUS_NO_MEMORY;
        goto exitWriteFile;
    }

    mirrorInfoFile->MirrorVersion = IMIRROR_CURRENT_VERSION;
    mirrorInfoFile->FileLength = bufferSize;
    mirrorInfoFile->NumberVolumes = GlobalMirrorCfgInfo->NumberVolumes;
    mirrorInfoFile->SystemPathLength = systemPathLength;
    mirrorInfoFile->CSDVersionLength = csdVersionLength;
    mirrorInfoFile->ProcessorArchitectureLength = processorArchitectureLength;
    mirrorInfoFile->CurrentTypeLength = currentTypeLength;
    mirrorInfoFile->HalNameLength = halNameLength;
    mirrorInfoFile->SysPrepImage = GlobalMirrorCfgInfo->SysPrepImage;
    mirrorInfoFile->Debug = GlobalMirrorCfgInfo->Debug;
    mirrorInfoFile->MajorVersion = GlobalMirrorCfgInfo->MajorVersion;
    mirrorInfoFile->MinorVersion = GlobalMirrorCfgInfo->MinorVersion;
    mirrorInfoFile->BuildNumber = GlobalMirrorCfgInfo->BuildNumber;
    mirrorInfoFile->KernelFileVersionMS = GlobalMirrorCfgInfo->KernelFileVersionMS;
    mirrorInfoFile->KernelFileVersionLS = GlobalMirrorCfgInfo->KernelFileVersionLS;
    mirrorInfoFile->KernelFileFlags = GlobalMirrorCfgInfo->KernelFileFlags;

    mirrorVolInfoFile = &mirrorInfoFile->Volumes[mirrorInfoFile->NumberVolumes];
    nextString = (PWCHAR) mirrorVolInfoFile;

    mirrorInfoFile->SystemPathOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
    lstrcpyW( nextString, GlobalMirrorCfgInfo->SystemPath );
    nextString += systemPathLength / sizeof(WCHAR);

    mirrorInfoFile->CSDVersionOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
    lstrcpyW( nextString, GlobalMirrorCfgInfo->CSDVersion );
    nextString += csdVersionLength / sizeof(WCHAR);

    mirrorInfoFile->ProcessorArchitectureOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
    lstrcpyW( nextString, GlobalMirrorCfgInfo->ProcessorArchitecture );
    nextString += processorArchitectureLength / sizeof(WCHAR);

    mirrorInfoFile->CurrentTypeOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
    lstrcpyW( nextString, GlobalMirrorCfgInfo->CurrentType );
    nextString += currentTypeLength / sizeof(WCHAR);

    mirrorInfoFile->HalNameOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
    lstrcpyW( nextString, GlobalMirrorCfgInfo->HalName );
    nextString += halNameLength / sizeof(WCHAR);

    listEntry = GlobalMirrorCfgInfo->MirrorVolumeList.Flink;

    mirrorVolInfoFile = &mirrorInfoFile->Volumes[0];

    while (listEntry != &GlobalMirrorCfgInfo->MirrorVolumeList) {

        mirrorVolInfo = (PMIRROR_VOLUME_INFO) CONTAINING_RECORD(
                                                listEntry,
                                                MIRROR_VOLUME_INFO,
                                                ListEntry
                                                );
        listEntry = listEntry->Flink;

        mirrorVolInfoFile->MirrorTableIndex = mirrorVolInfo->MirrorTableIndex;
        mirrorVolInfoFile->DriveLetter = mirrorVolInfo->DriveLetter;
        mirrorVolInfoFile->PartitionType = mirrorVolInfo->PartitionType;
        mirrorVolInfoFile->PartitionActive = mirrorVolInfo->PartitionActive;
        mirrorVolInfoFile->IsBootDisk = mirrorVolInfo->IsBootDisk;
        mirrorVolInfoFile->CompressedVolume = mirrorVolInfo->CompressedVolume;
        mirrorVolInfoFile->DiskSignature = mirrorVolInfo->DiskSignature;
        mirrorVolInfoFile->BlockSize = mirrorVolInfo->BlockSize;
        mirrorVolInfoFile->LastUSNMirrored = mirrorVolInfo->LastUSNMirrored;
        mirrorVolInfoFile->FileSystemFlags = mirrorVolInfo->FileSystemFlags;
        wcscpy(mirrorVolInfoFile->FileSystemName, mirrorVolInfo->FileSystemName);
        mirrorVolInfoFile->DiskSpaceUsed = mirrorVolInfo->DiskSpaceUsed;
        mirrorVolInfoFile->StartingOffset = mirrorVolInfo->StartingOffset;
        mirrorVolInfoFile->PartitionSize = mirrorVolInfo->PartitionSize;
        mirrorVolInfoFile->DiskNumber = mirrorVolInfo->DiskNumber;
        mirrorVolInfoFile->PartitionNumber = mirrorVolInfo->PartitionNumber;

        // set the path in the config file relative to the root of this
        // image.  As example, set it to L"\Mirror1\UserData"

        swprintf(   (PWCHAR)TmpBuffer2,
                    L"\\Mirror%d\\UserData",
                    mirrorVolInfo->MirrorTableIndex );

        pathLength = (lstrlenW( (PWCHAR)TmpBuffer2 ) + 1) * sizeof(WCHAR);
        mirrorVolInfoFile->MirrorUncLength = pathLength;
        mirrorVolInfoFile->MirrorUncPathOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
        lstrcpyW( nextString, (PWCHAR)TmpBuffer2 );
        nextString += pathLength / sizeof(WCHAR);

        pathLength = (lstrlenW( mirrorVolInfo->VolumeLabel ) + 1) * sizeof(WCHAR);
        mirrorVolInfoFile->VolumeLabelLength = pathLength;
        mirrorVolInfoFile->VolumeLabelOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
        lstrcpyW( nextString, mirrorVolInfo->VolumeLabel );
        nextString += pathLength / sizeof(WCHAR);

        pathLength = (lstrlenW( mirrorVolInfo->NtName ) + 1) * sizeof(WCHAR);
        mirrorVolInfoFile->NtNameLength = pathLength;
        mirrorVolInfoFile->NtNameOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
        lstrcpyW( nextString, mirrorVolInfo->NtName );
        nextString += pathLength / sizeof(WCHAR);

        pathLength = (lstrlenW( mirrorVolInfo->ArcName ) + 1) * sizeof(WCHAR);
        mirrorVolInfoFile->ArcNameLength = pathLength;
        mirrorVolInfoFile->ArcNameOffset = (ULONG)((PCHAR) nextString - (PCHAR) mirrorInfoFile);
        lstrcpyW( nextString, mirrorVolInfo->ArcName );
        nextString += pathLength / sizeof(WCHAR);

        mirrorVolInfoFile++;

        //
        //  call off to the wizard to tell him what the system directory
        //  is if we have a valid one.
        //

        if (mirrorVolInfo->IsBootDisk && (systemPathLength > 3 * sizeof(WCHAR))) {

            //
            //  pass it in the form of "MirrorX\UserData\WinNT"
            //  so we have to skip the C: in the systempath
            //

            swprintf(   (PWCHAR)TmpBuffer2,
                        L"Mirror%d\\UserData",
                        mirrorVolInfo->MirrorTableIndex );

            lstrcatW( (PWCHAR)TmpBuffer2, GlobalMirrorCfgInfo->SystemPath + 2 );
            IMirrorSetSystemPath(   (PWCHAR) TmpBuffer2,
                                    (lstrlenW( (PWCHAR) TmpBuffer2)) );
        }
    }

    fileHandle = CreateFile(    DestFile,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_ARCHIVE,
                                NULL );

    if (fileHandle == INVALID_HANDLE_VALUE) {

        Status = GetLastError();
        goto exitWriteFile;
    }

    if (!WriteFile( fileHandle,
                    mirrorInfoFile,
                    bufferSize,
                    &bufferSize,
                    NULL)) {

        Status = GetLastError();
        goto exitWriteFile;
    }

exitWriteFile:

    if (fileHandle != INVALID_HANDLE_VALUE) {

        CloseHandle( fileHandle );
        fileHandle = INVALID_HANDLE_VALUE;
    }

    if (mirrorInfoFile) {
        IMirrorFreeMem( mirrorInfoFile );
        mirrorInfoFile = NULL;
    }

    if (Status != ERROR_SUCCESS) {

        DWORD errorCase;

        errorCase = ReportCopyError(   NULL,
                                       DestFile,
                                       COPY_ERROR_ACTION_CREATE_FILE,
                                       Status );
        if (errorCase == STATUS_RETRY) {
            goto retryWriteConfig;
        }
        if ( errorCase == ERROR_SUCCESS ) {
            Status = ERROR_SUCCESS;
        }
    }
    return Status;
}

#define MIN_BOOT_SECTOR_BLOCK_SIZE  512

NTSTATUS
SaveBootSector(
    DWORD DiskNumber,
    DWORD PartitionNumber,
    DWORD BlockSize,
    PWCHAR DestFile
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    DWORD bufferSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE bootSectorHandle = INVALID_HANDLE_VALUE;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PUCHAR AlignedBuffer;
    PUCHAR allocatedBuffer = NULL;

    swprintf((PWCHAR)TmpBuffer, L"\\Device\\Harddisk%d\\Partition%d", DiskNumber, PartitionNumber );

    RtlInitUnicodeString(&UnicodeString, (PWCHAR)TmpBuffer);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = NtCreateFile(&bootSectorHandle,
                          (ACCESS_MASK)FILE_GENERIC_READ,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0
                         );

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CopyPartitions);
        goto exitSaveBootSector;
    }

    if (BlockSize < MIN_BOOT_SECTOR_BLOCK_SIZE) {

        BlockSize = MIN_BOOT_SECTOR_BLOCK_SIZE;
    }

    if (BlockSize + MIN_BOOT_SECTOR_BLOCK_SIZE > TMP_BUFFER_SIZE) {

        allocatedBuffer = IMirrorAllocMem( BlockSize + MIN_BOOT_SECTOR_BLOCK_SIZE );

        if (allocatedBuffer == NULL) {

            Status = STATUS_NO_MEMORY;
            goto exitSaveBootSector;
        }

        AlignedBuffer = ALIGN(allocatedBuffer, MIN_BOOT_SECTOR_BLOCK_SIZE);

    } else {

        AlignedBuffer = ALIGN(TmpBuffer, MIN_BOOT_SECTOR_BLOCK_SIZE);
    }

    Status = NtReadFile(bootSectorHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        AlignedBuffer,
                        BlockSize,
                        NULL,
                        NULL
                       );

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CopyPartitions);
        goto exitSaveBootSector;
    }

    fileHandle = CreateFile(    DestFile,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_ARCHIVE,
                                NULL );

    if (fileHandle == INVALID_HANDLE_VALUE) {

        Status = GetLastError();
        goto exitSaveBootSector;
    }

    if (!WriteFile( fileHandle,
                    AlignedBuffer,
                    BlockSize,
                    &bufferSize,
                    NULL)) {

        Status = GetLastError();

    } else {

        Status = STATUS_SUCCESS;
    }

exitSaveBootSector:

    if (bootSectorHandle != INVALID_HANDLE_VALUE) {
        NtClose(bootSectorHandle);
    }

    if (fileHandle != INVALID_HANDLE_VALUE) {
        NtClose(fileHandle);
    }

    if (allocatedBuffer) {
        IMirrorFreeMem( allocatedBuffer );
    }

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CopyPartitions);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\imirror\mirror.c ===
/*
Module Name:

    mirror.c

Abstract:

    This module implements routines to copy up a tree to a destination.

Author:

    Andy Herron May 27 1998

Revision History:

*/

#include "precomp.h"
#pragma hdrstop

#define RNDM_CONSTANT   314159269    /* default scrambling constant */
#define RNDM_PRIME     1000000007    /* prime number for scrambling  */

//
// Compute a string hash value that is invariant to case
//
#define COMPUTE_STRING_HASH( _pus, _phash ) {                \
    PWCHAR _p = _pus;                                        \
    ULONG _chHolder =0;                                      \
                                                             \
    while( *_p != L'\0' ) {                                  \
        _chHolder = 37 * _chHolder + (unsigned int) *(_p++); \
    }                                                        \
                                                             \
    *(_phash) = abs(RNDM_CONSTANT * _chHolder) % RNDM_PRIME; \
}

#ifdef DEBUGLOG

#define DEBUG_LOG_BUFFER_SIZE 1024

extern HANDLE hDebugLogFile;
extern CRITICAL_SECTION DebugFileLock;
UCHAR DebugLogFileBuffer[DEBUG_LOG_BUFFER_SIZE];
ULONG DebugLogFileOffset = 0;

#endif

BOOLEAN IMirrorUpdatedTokens = FALSE;

//
//  this is the structure we use to track what files already exist on the
//  destination
//

typedef struct _EXISTING_MIRROR_FILE {
    LIST_ENTRY ListEntry;
    DWORD  NameHashValue;
    DWORD  FileAttributes;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    ULONG  FileNameLength;
    ULONG  EaSize;
WCHAR  FileName[1];
} EXISTING_MIRROR_FILE, *PEXISTING_MIRROR_FILE;

//
//  this is the structure we use to track the directories that we still need
//  to copy.
//

typedef struct _COPY_DIRECTORY {
    LIST_ENTRY ListEntry;
    PCOPY_TREE_CONTEXT CopyContext;

    BOOLEAN DirectoryRoot;      // is this the root of the volume?
    DWORD  SourceAttributes;
    PWCHAR Source;
    PWCHAR Dest;
    PWCHAR NtSourceName;
    PWCHAR NtDestName;
    WCHAR  SourceBuffer[1];
} COPY_DIRECTORY, *PCOPY_DIRECTORY;

DWORD
CreateMatchingDirectory (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PCOPY_DIRECTORY DirectoryInfo
    );

DWORD
MirrorFile(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR SourceFileName,
    PFILE_FULL_DIR_INFORMATION SourceFindData,
    PWCHAR DestFileName,
    PEXISTING_MIRROR_FILE ExistingMirrorFile
    );

DWORD
UnconditionalDelete (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR SourceFile,
    PWCHAR FileToDelete,
    DWORD  Attributes,
    PWCHAR NameBuffer
    );

DWORD
StoreOurSecurityStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Source,
    PWCHAR Dest,
    DWORD  AttributesToStore,
    LARGE_INTEGER ChangeTime
    );

DWORD
StoreOurSFNStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Source,
    PWCHAR Dest,
    PWCHAR ShortFileName
    );


DWORD
GetOurSecurityStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Dest,
    PMIRROR_ACL_STREAM MirrorAclStream
    );

DWORD
GetOurSFNStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Dest,
    PMIRROR_SFN_STREAM MirrorSFNStream,
    PWCHAR SFNBuffer,
    DWORD  SFNBufferSize
    );


DWORD
CopySubtree(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PCOPY_DIRECTORY DirectoryInfo
    );

BOOL
IMSetFileTime(
    HANDLE hFile,
    CONST FILETIME *lpCreationTime,
    CONST FILETIME *lpLastAccessTime,
    CONST FILETIME *lpLastWriteTime,
    CONST FILETIME *lpChangeTime
    );

DWORD
IMirrorOpenDirectory (
    HANDLE *Handle,
    PWCHAR NtDirName,
    DWORD Disposition,
    BOOLEAN IsSource,
    DWORD SourceAttributes,
    PFILE_BASIC_INFORMATION BasicDirInfo OPTIONAL
    );

#ifdef IMIRROR_SUPPORT_ENCRYPTED
DWORD
IMCopyEncryptFile(
    PCOPY_TREE_CONTEXT CopyContext,
    LPWSTR SourceFileName,
    LPWSTR DestFileName
);
#endif

NTSTATUS
CanHandleReparsePoint (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR SourceFileName,
    DWORD FileAttributes
    );

DWORD
AllocateCopyTreeContext (
    PCOPY_TREE_CONTEXT *CopyContext,
    BOOLEAN DeleteOtherFiles
    )
/*++

Description:

    This routine allocates the necessary structure that we pass around
    that contains all of our "global" data during copying a large tree.

Parameters:

    CopyContext : Location to put allocated structure.

    DeleteOtherFiles : Do we remove files and dirs that aren't on the master?

Return Value:

    Win32 error code

++*/
{
    PCOPY_TREE_CONTEXT context;

    *CopyContext = IMirrorAllocMem(sizeof( COPY_TREE_CONTEXT ));

    context = *CopyContext;

    if (context == NULL) {

        return GetLastError();
    }

    InitializeListHead( &(context->PendingDirectoryList) );
    InitializeCriticalSection( &(context->Lock) );
    context->Cancelled = FALSE;
    context->DeleteOtherFiles = DeleteOtherFiles;

    return ERROR_SUCCESS;
}


VOID
FreeCopyTreeContext (
    PCOPY_TREE_CONTEXT CopyContext
    )
/*++

Description:

    This routine frees the necessary structures that we pass around
    that contains all of our "global" data during copying a large tree.

Parameters:

    CopyContext : Structure that is no longer needed.

Return Value:

    None

++*/
{
    while (IsListEmpty( &(CopyContext->PendingDirectoryList) ) == FALSE) {

        PCOPY_DIRECTORY copyDir;
        PLIST_ENTRY listEntry = RemoveHeadList( &(CopyContext->PendingDirectoryList) );

        copyDir = (PCOPY_DIRECTORY) CONTAINING_RECORD(  listEntry,
                                                        COPY_DIRECTORY,
                                                        ListEntry );

        IMirrorFreeMem( copyDir );
    }

    DeleteCriticalSection( &CopyContext->Lock );
    return;
}

DWORD
CopyTree (
    PCOPY_TREE_CONTEXT CopyContext,
    BOOLEAN IsNtfs,
    PWCHAR SourceRoot,
    PWCHAR DestRoot
    )
/*++

Description:

    This is the main routine that initiates the full subtree copy.

Parameters:

    CopyContext : Structure that is no longer needed.

    SourceRoot  : source tree to copy in NT format, not DOS format.

    DestRoot    : location to copy it to

Return Value:

    Win32 error code

++*/
{
    DWORD err;
    DWORD sourceAttributes;
    IMIRROR_THREAD_CONTEXT threadContext;
    COPY_DIRECTORY rootDir;
    //
    //  if we were to create multiple threads handling copying this subtree,
    //  this is where we'll setup the threads where each has their own
    //  thread context.
    //

    if (! IMirrorUpdatedTokens) {

        HANDLE hToken;

        // Enable the privileges necessary to copy security information.

        err = GetTokenHandle(&hToken);

        if (err == ERROR_SUCCESS) {

            SetPrivs(hToken, TEXT("SeSecurityPrivilege"));
//          SetPrivs(hToken, TEXT("SeBackupPrivilege"));
//          SetPrivs(hToken, TEXT("SeRestorePrivilege"));
//          SetPrivs(hToken, TEXT("SeTakeOwnershipPrivilege"));

            IMirrorUpdatedTokens = TRUE;
        }
    }

retryCopyTree:

    RtlZeroMemory( &threadContext, sizeof( threadContext ));
    threadContext.CopyContext = CopyContext;
    threadContext.IsNTFS = IsNtfs;
    threadContext.SourceDirHandle = INVALID_HANDLE_VALUE;
    threadContext.DestDirHandle = INVALID_HANDLE_VALUE;
    threadContext.SDBufferLength = IMIRROR_INITIAL_SD_LENGTH;
    threadContext.SFNBufferLength = IMIRROR_INITIAL_SFN_LENGTH;

    InitializeListHead( &threadContext.FilesToIgnore );

    sourceAttributes = GetFileAttributes( SourceRoot );

    if (sourceAttributes == (DWORD) -1) {

        ULONG action;

        err = GetLastError();
        action = ReportCopyError( CopyContext,
                                  SourceRoot,
                                  COPY_ERROR_ACTION_GETATTR,
                                  err );
        if (action == STATUS_RETRY) {

            goto retryCopyTree;

        } else if (action == STATUS_REQUEST_ABORTED) {

            goto exitCopyTree;
        }

        //
        //  the user told us to ignore the error.  we'll do our best.
        //
        sourceAttributes = FILE_ATTRIBUTE_DIRECTORY;
    }

    GetRegistryFileList( &threadContext.FilesToIgnore );

    RtlZeroMemory( &rootDir, sizeof( COPY_DIRECTORY ));
    rootDir.CopyContext = CopyContext;
    rootDir.DirectoryRoot = TRUE;
    rootDir.SourceAttributes = sourceAttributes;
    rootDir.Source = SourceRoot;
    rootDir.Dest = DestRoot;

    err = CopySubtree( &threadContext,
                       &rootDir
                       );

    ASSERT( threadContext.SourceDirHandle == INVALID_HANDLE_VALUE );
    ASSERT( threadContext.DestDirHandle == INVALID_HANDLE_VALUE );

    EnterCriticalSection( &CopyContext->Lock );

    while ((CopyContext->Cancelled == FALSE) &&
           (IsListEmpty( &(CopyContext->PendingDirectoryList) ) == FALSE)) {

        PCOPY_DIRECTORY copyDir;
        PLIST_ENTRY listEntry = RemoveHeadList( &(CopyContext->PendingDirectoryList) );

        copyDir = (PCOPY_DIRECTORY) CONTAINING_RECORD(  listEntry,
                                                        COPY_DIRECTORY,
                                                        ListEntry );
        LeaveCriticalSection( &CopyContext->Lock );

        err = CopySubtree(  &threadContext,
                            copyDir
                            );

        ASSERT( threadContext.SourceDirHandle == INVALID_HANDLE_VALUE );
        ASSERT( threadContext.DestDirHandle == INVALID_HANDLE_VALUE );

        IMirrorFreeMem( copyDir );

        EnterCriticalSection( &CopyContext->Lock );
    }

exitCopyTree:

    if (threadContext.SDBuffer) {

        IMirrorFreeMem( threadContext.SDBuffer );
    }
    if (threadContext.SFNBuffer) {

        IMirrorFreeMem( threadContext.SFNBuffer );
    }
    if (threadContext.DirectoryBuffer) {

        IMirrorFreeMem( threadContext.DirectoryBuffer );
    }
    if ( threadContext.FindBufferBase ) {

        IMirrorFreeMem( threadContext.FindBufferBase );
    }

    while (IsListEmpty( &(threadContext.FilesToIgnore) ) == FALSE) {

        PIMIRROR_IGNORE_FILE_LIST ignoreListEntry;
        PLIST_ENTRY listEntry = RemoveHeadList( &(threadContext.FilesToIgnore) );

        ignoreListEntry = (PIMIRROR_IGNORE_FILE_LIST)
                            CONTAINING_RECORD(  listEntry,
                                                IMIRROR_IGNORE_FILE_LIST,
                                                ListEntry );
        IMirrorFreeMem( ignoreListEntry );
    }

    return err;
}


DWORD
CopySubtree(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PCOPY_DIRECTORY DirectoryInfo
    )
/*++

Description:

    This routine enumerates the directories on the client to continue
    traversing the tree.   It then enumerates the files on the slave
    ( to compare them against what is on the master ), it then ensures
    that all files on the master are up on the slave.  It then deletes all
    files on the slave that are not on the master.

Parameters:

    ThreadContext   : data for this instance of copying a tree

    DirectoryInfo   : information on the source and dest that we know of

Return Value:

    Win32 error code
++*/
{
    DWORD err;
    PWCHAR destFileName;
    PWCHAR sourceFileName;
    ULONG destFileNameSize;
    ULONG sourceFileNameSize;
    PWCHAR endOfSourcePath;
    PWCHAR endOfDestPath;
    LIST_ENTRY existingMirrorFilesList;
    PLIST_ENTRY listEntry;
    PEXISTING_MIRROR_FILE existingMirrorFile;
    BOOLEAN deleteExistingMirrorFilesNotInMaster;
    PCOPY_TREE_CONTEXT copyContext;
    UNICODE_STRING ntSourcePath;
    UNICODE_STRING ntDestPath;
    PFILE_FULL_DIR_INFORMATION findData;
    ULONG errorCase;
    
    
retryCopySubtree:

    errorCase = ERROR_SUCCESS;
    destFileName = NULL;
    sourceFileName = NULL;
    deleteExistingMirrorFilesNotInMaster = FALSE;
    copyContext = ThreadContext->CopyContext;

    InitializeListHead( &existingMirrorFilesList );
    RtlInitUnicodeString( &ntSourcePath, NULL );
    RtlInitUnicodeString( &ntDestPath, NULL );

    //
    //  since some of the NT specific calls use the NT format of the name,
    //  we grab that up front so as not to have to do it every time.
    //

    if (RtlDosPathNameToNtPathName_U(   DirectoryInfo->Source,
                                        &ntSourcePath,
                                        NULL,
                                        NULL ) == FALSE) {

        err = STATUS_OBJECT_PATH_NOT_FOUND;

        errorCase = ReportCopyError(  copyContext,
                                      DirectoryInfo->Source,
                                      COPY_ERROR_ACTION_OPEN_DIR,
                                      err );
        goto exitCopySubtree;
    }

    if (RtlDosPathNameToNtPathName_U(   DirectoryInfo->Dest,
                                        &ntDestPath,
                                        NULL,
                                        NULL ) == FALSE) {

        err = STATUS_OBJECT_PATH_NOT_FOUND;

        errorCase = ReportCopyError(  copyContext,
                                      DirectoryInfo->Dest,
                                      COPY_ERROR_ACTION_OPEN_DIR,
                                      err );
        goto exitCopySubtree;
    }

    DirectoryInfo->NtSourceName = ntSourcePath.Buffer;
    DirectoryInfo->NtDestName = ntDestPath.Buffer;

    //
    //  Create a directory on the slave that matches this one.  This will
    //  open handles to both the source and dest directories.  We cache the
    //  handle in case other operations need it.
    //

    err = CreateMatchingDirectory( ThreadContext, DirectoryInfo );
    if (err != ERROR_SUCCESS) {
        goto exitCopySubtree;
    }

    destFileNameSize = (lstrlenW( DirectoryInfo->Dest ) + 5 + MAX_PATH) * sizeof(WCHAR);
    destFileName = IMirrorAllocMem( destFileNameSize );

    if (destFileName == NULL) {

        err = GetLastError();

        errorCase = ReportCopyError(  copyContext,
                                      DirectoryInfo->Dest,
                                      COPY_ERROR_ACTION_MALLOC,
                                      err );
        goto exitCopySubtree;
    }

    lstrcpyW( destFileName, DirectoryInfo->Dest );
    lstrcatW( destFileName, L"\\" );

    
    // track the next character after the trailing backslash

    endOfDestPath = destFileName + lstrlenW( destFileName );

    sourceFileNameSize = (lstrlenW( DirectoryInfo->Source ) + 5 + MAX_PATH) * sizeof(WCHAR);
    sourceFileName = IMirrorAllocMem( sourceFileNameSize );

    if (sourceFileName == NULL) {

        err = GetLastError();

        errorCase = ReportCopyError(  copyContext,
                                      DirectoryInfo->Source,
                                      COPY_ERROR_ACTION_MALLOC,
                                      err );
        goto exitCopySubtree;
    }
    
    lstrcpyW( sourceFileName, DirectoryInfo->Source );
    if (!DirectoryInfo->DirectoryRoot) {
        lstrcatW( sourceFileName, L"\\" );
    }


    // track the next character after the trailing backslash

    endOfSourcePath = sourceFileName + lstrlenW( sourceFileName );

    //
    //  enumerate all files/directories on the target so that we have the
    //  details to grovel correctly.
    //

    err = IMFindFirstFile( ThreadContext,
                           ThreadContext->DestDirHandle,
                           &findData );

    while ( findData != NULL &&
            err == ERROR_SUCCESS &&
            copyContext->Cancelled == FALSE) {

        InterlockedIncrement( &copyContext->DestFilesScanned );

        if (((findData->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) &&
             (findData->FileName[0] == L'.')) {

            if ((findData->FileNameLength == sizeof(WCHAR)) ||
                (findData->FileName[1] == L'.' &&
                 findData->FileNameLength == 2*sizeof(WCHAR))) {

                goto skipToNextDir1;
            }
        }

        if (DirectoryInfo->DirectoryRoot &&
            ((findData->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
            ((!_wcsnicmp(&findData->FileName[0],
                         L"pagefile.sys",
                         findData->FileNameLength)) ||
             (!_wcsnicmp(&findData->FileName[0],
                         L"hiberfil.sys",
                         findData->FileNameLength)))) {

            goto skipToNextDir1;
        }

        
        existingMirrorFile = (PEXISTING_MIRROR_FILE) IMirrorAllocMem(
                        sizeof(EXISTING_MIRROR_FILE) +
                        findData->FileNameLength);

        if (existingMirrorFile == NULL) {

            err = GetLastError();

            errorCase = ReportCopyError(   copyContext,
                                           destFileName,
                                           COPY_ERROR_ACTION_MALLOC,
                                           err );
            goto exitCopySubtree;
        }

        existingMirrorFile->FileAttributes = findData->FileAttributes;
        existingMirrorFile->CreationTime = findData->CreationTime;
        existingMirrorFile->LastWriteTime = findData->LastWriteTime;
        existingMirrorFile->ChangeTime = findData->ChangeTime;
        existingMirrorFile->EndOfFile  = findData->EndOfFile;
        existingMirrorFile->EaSize     = findData->EaSize;
        existingMirrorFile->FileNameLength = findData->FileNameLength;
        
        RtlCopyMemory( &existingMirrorFile->FileName[0],
                       &findData->FileName[0],
                       findData->FileNameLength );
        existingMirrorFile->FileName[ findData->FileNameLength / sizeof(WCHAR) ] = UNICODE_NULL;

        COMPUTE_STRING_HASH( &existingMirrorFile->FileName[0],
                             &existingMirrorFile->NameHashValue );

        InsertTailList( &existingMirrorFilesList, &existingMirrorFile->ListEntry );

skipToNextDir1:

        err = IMFindNextFile( ThreadContext,
                              ThreadContext->DestDirHandle,
                              &findData );
    }

    //
    //  copy all files up from the source to the dest
    //

    err = IMFindFirstFile( ThreadContext,
                           ThreadContext->SourceDirHandle,
                           &findData );

    if (err != ERROR_SUCCESS) {

        if (err == STATUS_NO_MORE_FILES) {

            err = ERROR_SUCCESS;

        } else {
            errorCase = ReportCopyError(  copyContext,
                                          DirectoryInfo->Source,
                                          COPY_ERROR_ACTION_ENUMERATE,
                                          err );
            goto exitCopySubtree;
        }
    }

    while ( findData != NULL &&
            err == ERROR_SUCCESS &&
            copyContext->Cancelled == FALSE) {

        DWORD nameHashValue;

        if (((findData->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) &&
             (findData->FileName[0] == L'.')) {

            if ((findData->FileNameLength == sizeof(WCHAR)) ||
                (findData->FileName[1] == L'.' &&
                 findData->FileNameLength == 2*sizeof(WCHAR))) {

                goto skipToNextDir;
            }
        }

        if (DirectoryInfo->DirectoryRoot &&
            ((findData->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
            (!_wcsnicmp(&findData->FileName[0],
                        L"pagefile.sys",
                        findData->FileNameLength))) {

            goto skipToNextDir;
        }

        InterlockedIncrement( &copyContext->SourceFilesScanned );

        RtlCopyMemory( endOfSourcePath,
                       findData->FileName,
                       findData->FileNameLength );
        *(endOfSourcePath+(findData->FileNameLength/sizeof(WCHAR))) = UNICODE_NULL;

        RtlCopyMemory( endOfDestPath,
                       findData->FileName,
                       findData->FileNameLength );
        *(endOfDestPath+(findData->FileNameLength/sizeof(WCHAR))) = UNICODE_NULL;

        //
        //  search the list of existing files on the target to see if
        //  it's already there.
        //

        COMPUTE_STRING_HASH( endOfDestPath, &nameHashValue );

        listEntry = existingMirrorFilesList.Flink;

        existingMirrorFile = NULL;

        while (listEntry != &existingMirrorFilesList) {

            existingMirrorFile = (PEXISTING_MIRROR_FILE) CONTAINING_RECORD(
                                                    listEntry,
                                                    EXISTING_MIRROR_FILE,
                                                    ListEntry );
            listEntry = listEntry->Flink;

            if ((existingMirrorFile->NameHashValue == nameHashValue) &&
                (existingMirrorFile->FileNameLength == findData->FileNameLength) &&
                (CompareStringW( LOCALE_SYSTEM_DEFAULT,
                                 NORM_IGNORECASE,
                                 endOfDestPath,
                                 findData->FileNameLength / sizeof(WCHAR),
                                 &existingMirrorFile->FileName[0],
                                 existingMirrorFile->FileNameLength / sizeof(WCHAR)) == 2)) {
                break;
            }

            existingMirrorFile = NULL;
        }

        if ((findData->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {

            //
            //  this is a file, let's mirror it up from the master.
            //

            (VOID)MirrorFile(   ThreadContext,
                                sourceFileName,
                                findData,
                                destFileName,
                                existingMirrorFile
                                );
        } else {

            //
            //  it's a directory, put it on the pending list.
            //
            PCOPY_DIRECTORY copyDir;
            ULONG sourceLength;

            sourceLength = lstrlenW( sourceFileName ) + 1;  // space for null
            copyDir = (PCOPY_DIRECTORY) IMirrorAllocMem(
                            sizeof( COPY_DIRECTORY ) +
                            (( sourceLength +
                               lstrlenW( destFileName ) + 1 )
                               * sizeof(WCHAR)));

            if (copyDir == NULL) {

                err = GetLastError();

                errorCase = ReportCopyError(  copyContext,
                                              sourceFileName,
                                              COPY_ERROR_ACTION_MALLOC,
                                              err );
                goto exitCopySubtree;
            }

            //
            //  we save off all info we know about both the source and the
            //  dest so that we don't have to go read it again.
            //

            copyDir->CopyContext = copyContext;
            copyDir->DirectoryRoot = FALSE;
            copyDir->SourceAttributes = findData->FileAttributes;
            copyDir->Source = &copyDir->SourceBuffer[0];
            lstrcpyW( copyDir->Source, sourceFileName );

            copyDir->Dest = &copyDir->SourceBuffer[sourceLength];
            lstrcpyW( copyDir->Dest, destFileName );

            EnterCriticalSection( &copyContext->Lock );

            InsertHeadList( &(copyContext->PendingDirectoryList), &copyDir->ListEntry );

            LeaveCriticalSection( &copyContext->Lock );
        }

        if (existingMirrorFile != NULL) {

            RemoveEntryList( &existingMirrorFile->ListEntry );
            IMirrorFreeMem( existingMirrorFile );
        }

skipToNextDir:
        err = IMFindNextFile( ThreadContext,
                              ThreadContext->SourceDirHandle,
                              &findData );

        if (err != ERROR_SUCCESS) {

            if (err == STATUS_NO_MORE_FILES) {

                err = ERROR_SUCCESS;

            } else {
                errorCase = ReportCopyError(  copyContext,
                                              DirectoryInfo->Source,
                                              COPY_ERROR_ACTION_ENUMERATE,
                                              err );
                goto exitCopySubtree;
            }
        }
    }

    if (err == ERROR_SUCCESS) {

        //
        //  now go through list of remaining files and directories that were on
        //  the destination but not on the source to delete them.  We only do
        //  that if we successfully made it through all existing master files.
        //

        if (copyContext->DeleteOtherFiles) {

            deleteExistingMirrorFilesNotInMaster = TRUE;
        }
    }

exitCopySubtree:

    while (IsListEmpty( &existingMirrorFilesList ) == FALSE) {

        listEntry = RemoveHeadList( &existingMirrorFilesList );

        existingMirrorFile = (PEXISTING_MIRROR_FILE) CONTAINING_RECORD( listEntry,
                                                                EXISTING_MIRROR_FILE,
                                                                ListEntry );
        if ((errorCase == STATUS_SUCCESS) &&
            deleteExistingMirrorFilesNotInMaster &&
            (copyContext->Cancelled == FALSE)) {

            lstrcpyW( endOfDestPath, &existingMirrorFile->FileName[0] );

            UnconditionalDelete(    ThreadContext,
                                    DirectoryInfo->Source,
                                    destFileName,
                                    existingMirrorFile->FileAttributes,
                                    NULL );
        }

        IMirrorFreeMem( existingMirrorFile );
    }

    if (destFileName != NULL) {
        IMirrorFreeMem( destFileName );
    }
    if (sourceFileName != NULL) {
        IMirrorFreeMem( sourceFileName );
    }
    if ( ThreadContext->SourceDirHandle != INVALID_HANDLE_VALUE ) {

        NtClose( ThreadContext->SourceDirHandle );
        ThreadContext->SourceDirHandle = INVALID_HANDLE_VALUE;
    }
    if ( ThreadContext->DestDirHandle != INVALID_HANDLE_VALUE ) {

        NtClose( ThreadContext->DestDirHandle );
        ThreadContext->DestDirHandle = INVALID_HANDLE_VALUE;
    }
    if (ntSourcePath.Buffer) {

        RtlFreeHeap( RtlProcessHeap(), 0, ntSourcePath.Buffer );
    }

    if (ntDestPath.Buffer) {

        RtlFreeHeap( RtlProcessHeap(), 0, ntDestPath.Buffer );
    }

    if (errorCase == STATUS_RETRY) {

        goto retryCopySubtree;
    }
    if ( errorCase == ERROR_SUCCESS ) {
        err = ERROR_SUCCESS;        // we ignore all errors if user told us to
    }
    return err;
}

DWORD
CreateMatchingDirectory (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PCOPY_DIRECTORY DirectoryInfo
    )
/*++

Description:

    This routine ensures that the destination directory on the mirror
    matches the source directory.  It doesn't handle the files
    or subdirectories, just the actual directory itself.

Parameters:

    ThreadContext   : instance data for this thread copying a tree

    DirectoryInfo   : structure containing all the info for the directory

Return Value:

    Win32 error code
++*/
{
    FILE_BASIC_INFORMATION sourceDirInfo;
    FILE_BASIC_INFORMATION destDirInfo;
    DWORD err;
    BOOLEAN updateBasic;
    BOOLEAN updateStoredSecurityAttributes;
    BOOLEAN createdDir;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG errorCase;

retryCreateDir:

    updateBasic = FALSE;
    updateStoredSecurityAttributes = FALSE;
    createdDir = FALSE;

    err = IMirrorOpenDirectory( &ThreadContext->SourceDirHandle,
                                DirectoryInfo->NtSourceName,
                                FILE_OPEN,
                                TRUE,
                                DirectoryInfo->SourceAttributes,
                                &sourceDirInfo
                                );

    if (err != ERROR_SUCCESS) {

        errorCase = ReportCopyError(    ThreadContext->CopyContext,
                                        DirectoryInfo->Source,
                                        COPY_ERROR_ACTION_OPEN_DIR,
                                        err );
        if (errorCase == STATUS_RETRY) {
            goto retryCreateDir;
        }
        if (errorCase == ERROR_SUCCESS) {
            err = ERROR_SUCCESS;
        }
        return err;
    }

    if (DirectoryInfo->SourceAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

        errorCase = ReportCopyError(    ThreadContext->CopyContext,
                                        DirectoryInfo->Source,
                                        COPY_ERROR_ACTION_OPEN_DIR,
                                        ERROR_REPARSE_ATTRIBUTE_CONFLICT );

        err = ERROR_REPARSE_ATTRIBUTE_CONFLICT;

        if (errorCase == STATUS_RETRY) {
            goto retryCreateDir;
        }
        
        //
        // we can't ever succeed a create request, so don't allow the 
        // code to return ERROR_SUCCESS, instead always force an abort
        //
        if (errorCase == ERROR_SUCCESS) {
            //err = ERROR_SUCCESS;
            err = ERROR_REQUEST_ABORTED;
        }

        return err;
    }

    ASSERT( (DirectoryInfo->SourceAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0);

    err = IMirrorOpenDirectory( &ThreadContext->DestDirHandle,
                                DirectoryInfo->NtDestName,
                                FILE_OPEN,
                                FALSE,
                                FILE_ATTRIBUTE_DIRECTORY,
                                &destDirInfo
                                );

    if (err == STATUS_NOT_A_DIRECTORY) {

        DWORD DestAttributes = GetFileAttributes( DirectoryInfo->Dest );

        //
        //  this is not a directory on the dest, let's delete it.
        //

        DestAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;    // be real sure of this

        err = UnconditionalDelete(  ThreadContext,
                                    DirectoryInfo->Source,
                                    DirectoryInfo->Dest,
                                    DestAttributes,
                                    NULL );
        if (err != ERROR_SUCCESS) {
            return err;
        }
    }

    if (ThreadContext->DestDirHandle == INVALID_HANDLE_VALUE) {

        //
        //  try to create the destination directory from the source
        //

        err = IMirrorOpenDirectory( &ThreadContext->DestDirHandle,
                                    DirectoryInfo->NtDestName,
                                    FILE_CREATE,
                                    FALSE,
                                    FILE_ATTRIBUTE_DIRECTORY,
                                    &destDirInfo
                                    );

        // report either success or failure up to the caller

        if (!NT_SUCCESS( err )) {

            errorCase = ReportCopyError(    ThreadContext->CopyContext,
                                            DirectoryInfo->Dest,
                                            COPY_ERROR_ACTION_CREATE_DIR,
                                            err );
            if (errorCase == STATUS_RETRY) {
                goto retryCreateDir;
            }
            if (errorCase == ERROR_SUCCESS) {
                err = ERROR_SUCCESS;
            }
            return err;
        }

        //
        //  this is for the success case so it won't fail.
        //

        ReportCopyError(   ThreadContext->CopyContext,
                           DirectoryInfo->Dest,
                           COPY_ERROR_ACTION_CREATE_DIR,
                           ERROR_SUCCESS );

        InterlockedIncrement( &ThreadContext->CopyContext->DirectoriesCreated );

        createdDir = TRUE;
        updateBasic = TRUE;
        updateStoredSecurityAttributes = TRUE;
        
    } else {

        MIRROR_ACL_STREAM aclStream;
        
        //
        //  let's get the security descriptor and extended attributes to
        //  see if we need to update our alternate data stream on the target.
        //

        err = GetOurSecurityStream( ThreadContext, DirectoryInfo->Dest, &aclStream );

        if (!NT_SUCCESS( err )) {

            updateStoredSecurityAttributes = TRUE;

        } else {

            destDirInfo.ChangeTime = aclStream.ChangeTime;

            if (( aclStream.ChangeTime.QuadPart != sourceDirInfo.ChangeTime.QuadPart ) ||
                ( aclStream.ExtendedAttributes != DirectoryInfo->SourceAttributes ) ) {

                updateStoredSecurityAttributes = TRUE;
            }
        }

        //
        //  if the creation time or lastwrite time is different, then we'll
        //  update them on the target to match the source.
        //

        if (( destDirInfo.CreationTime.QuadPart != sourceDirInfo.CreationTime.QuadPart ) ||
            ( destDirInfo.LastWriteTime.QuadPart != sourceDirInfo.LastWriteTime.QuadPart )) {

            updateBasic = TRUE;
        }
    }

    //
    //  Save the complete attribute values in the alternate data stream
    //     on the slave file.
    //

    if (updateStoredSecurityAttributes || DirectoryInfo->DirectoryRoot) {

        err = StoreOurSecurityStream(  ThreadContext,
                                       DirectoryInfo->Source,
                                       DirectoryInfo->Dest,
                                       DirectoryInfo->SourceAttributes,
                                       sourceDirInfo.ChangeTime
                                       );
        updateBasic = TRUE;
    }

    if ((err == ERROR_SUCCESS) &&
        updateBasic &&
        (DirectoryInfo->DirectoryRoot == FALSE)) {

        destDirInfo.CreationTime = sourceDirInfo.CreationTime;
        destDirInfo.LastWriteTime = sourceDirInfo.LastWriteTime;
        destDirInfo.ChangeTime = sourceDirInfo.ChangeTime;

        destDirInfo.FileAttributes = 0;     // leave dir attributes alone.

        err = NtSetInformationFile(    ThreadContext->DestDirHandle,
                                       &IoStatusBlock,
                                       &destDirInfo,
                                       sizeof( FILE_BASIC_INFORMATION ),
                                       FileBasicInformation
                                       );

        err = IMConvertNT2Win32Error( err );
        if ( err != ERROR_SUCCESS) {

            errorCase = ReportCopyError(    ThreadContext->CopyContext,
                                            DirectoryInfo->Dest,
                                            COPY_ERROR_ACTION_SETATTR,
                                            GetLastError() );
            if (errorCase == STATUS_RETRY) {
                goto retryCreateDir;
            }
            if (errorCase == ERROR_SUCCESS) {
                err = ERROR_SUCCESS;
            }
        } else if (! createdDir ) {

            InterlockedIncrement( &ThreadContext->CopyContext->AttributesModified );
        }
    }

    //
    // Save off our SFN information too.
    //
    if( (err == ERROR_SUCCESS) && (DirectoryInfo->DirectoryRoot == FALSE) ) {


        WCHAR ShortFileNameInStream[MAX_PATH*2];
        WCHAR *p = NULL;


        //
        // Get the short file name on the source directory.
        //
        ShortFileNameInStream[0] = L'\0';

        //
        // It's likely that our path looks like \??\C:\xxxxx,
        // which GetShortPathName will fail on.  We need to fix
        // up the path so it looks like a good ol' DOS path.
        //
        if( p = wcsrchr(DirectoryInfo->NtSourceName, L':') ) {
            p -= 1;
        } else {
            p = DirectoryInfo->NtSourceName;
        }
        err = GetShortPathName( p,
                                ShortFileNameInStream,
                                sizeof(ShortFileNameInStream)/sizeof(WCHAR) );
        
        
        //
        // If we got a short file name, then go set that information in
        // the alternate stream in our destination file.
        //
        if( err == 0 ) {
            err = GetLastError();
        } else {
            if( wcscmp(ShortFileNameInStream, p) ) {
            
                //
                // The short file name is different from the name of
                // our source file, so better save it off.
                //
                if( p = wcsrchr(ShortFileNameInStream, L'\\') ) {
                    p += 1;
                } else {
                    p = ShortFileNameInStream;
                }
        
        
                if( *p != '\0' ) {

                    WCHAR SavedCharacter = L'\0';
                    PWSTR q = NULL;
                    //
                    // Incredibly nausiating hack where CreateFile explodes
                    // when we send him a "\??\UNC\...." path, which is exactly
                    // what we're probably going to send him when we call into
                    // StoreOurSFNStream().  We'll need to patch the NtDestName
                    // here, then restore it when we come back.
                    //
                    if( q = wcsstr(DirectoryInfo->NtDestName, L"\\??\\UNC\\") ) {
                        SavedCharacter = DirectoryInfo->NtDestName[6];
                        DirectoryInfo->NtDestName[6] = L'\\';
                        q = &DirectoryInfo->NtDestName[6];
                    } else {
                        q = DirectoryInfo->NtDestName;
                    }
                    err = StoreOurSFNStream( ThreadContext,
                                             DirectoryInfo->NtSourceName,
                                             q,
                                             p );
                    if( SavedCharacter != L'\0' ) {
                        // restore the destination path.
                        DirectoryInfo->NtDestName[6] = SavedCharacter;
                    }
        
                }
            }
        }

        //
        // Cover up any errors here because it's certainly not fatal.
        //
        err = ERROR_SUCCESS;
    }


    return err;
}


DWORD
IMirrorOpenDirectory (
    HANDLE *Handle,
    PWCHAR NtDirName,
    DWORD Disposition,
    BOOLEAN IsSource,
    DWORD SourceAttributes,
    PFILE_BASIC_INFORMATION BasicDirInfo OPTIONAL
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeInput;
    DWORD createOptions;
    DWORD desiredAccess;

    BOOLEAN TranslationStatus;
    BOOLEAN StrippedTrailingSlash;

    ASSERT( Handle != NULL );
    ASSERT( *Handle == INVALID_HANDLE_VALUE );

    RtlInitUnicodeString(&UnicodeInput,NtDirName);

    if ((UnicodeInput.Length > 2 * sizeof(WCHAR)) &&
        (UnicodeInput.Buffer[(UnicodeInput.Length>>1)-1] == L'\\') &&
        (UnicodeInput.Buffer[(UnicodeInput.Length>>1)-2] != L':' )) {

        UnicodeInput.Length -= sizeof(UNICODE_NULL);
        StrippedTrailingSlash = TRUE;

    } else {

        StrippedTrailingSlash = FALSE;
    }

    createOptions = FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT;
    desiredAccess = FILE_LIST_DIRECTORY | SYNCHRONIZE | FILE_TRAVERSE | FILE_READ_ATTRIBUTES;

    if (IsSource) {

        createOptions |= FILE_OPEN_FOR_BACKUP_INTENT;

    } else {

        desiredAccess |= FILE_ADD_FILE |
                         FILE_ADD_SUBDIRECTORY |
                         FILE_WRITE_ATTRIBUTES |
                         FILE_DELETE_CHILD;
    }

retryCreate:

    InitializeObjectAttributes(
        &Obja,
        &UnicodeInput,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    //  Open the directory for the desired access.  This may create it.
    //

    Status = NtCreateFile(
                Handle,
                desiredAccess,
                &Obja,
                &IoStatusBlock,
                NULL,
                SourceAttributes,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                Disposition,
                createOptions,
                NULL,
                0 );

    if ( Status == STATUS_INVALID_PARAMETER && StrippedTrailingSlash ) {
        //
        // open of a pnp style path failed, so try putting back the trailing slash
        //
        UnicodeInput.Length += sizeof(UNICODE_NULL);
        StrippedTrailingSlash = FALSE;
        goto retryCreate;
    }

    if (*Handle == NULL) {

        *Handle = INVALID_HANDLE_VALUE;
    }

    if (NT_SUCCESS( Status ) && BasicDirInfo != NULL) {

        //
        //  read the attributes for the caller too
        //

        Status = NtQueryInformationFile(    *Handle,
                                            &IoStatusBlock,
                                            BasicDirInfo,
                                            sizeof( FILE_BASIC_INFORMATION ),
                                            FileBasicInformation
                                            );
    }

    return IMConvertNT2Win32Error( Status );
}


DWORD
MirrorFile(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR SourceFileName,
    PFILE_FULL_DIR_INFORMATION SourceFindData,
    PWCHAR DestFileName,
    PEXISTING_MIRROR_FILE ExistingMirrorFile
    )
{
    DWORD err;
    BOOLEAN fileIsAlreadyThere;
    PCOPY_TREE_CONTEXT copyContext;
    BOOLEAN updateStoredSecurityAttributes;
    BOOLEAN updateStoredSFNAttributes;
    BOOLEAN updateBasic;
    BOOLEAN isEncrypted;
    FILE_BASIC_INFORMATION fileBasicInfo;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    MIRROR_ACL_STREAM aclStream;
    MIRROR_SFN_STREAM SFNStream;
    ULONG errorCase;
    static FARPROC pSetFileShortName = NULL;
    static BOOL AlreadyCheckedForExport = FALSE;
    WCHAR ShortFileNameInStream[32];
    WCHAR ShortFileName[MAX_PATH],*p;

retryMirrorFile:

    if ( fileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( fileHandle );
        fileHandle = INVALID_HANDLE_VALUE;
    }

    errorCase = STATUS_SUCCESS;
    err = STATUS_SUCCESS;
    fileIsAlreadyThere = FALSE;
    copyContext = ThreadContext->CopyContext;
    updateStoredSecurityAttributes = TRUE;
    updateStoredSFNAttributes = TRUE;
    updateBasic = TRUE;
    isEncrypted = FALSE;


    ShortFileName[0] = L'\0';
    GetShortPathName( 
        SourceFileName, 
        ShortFileName, 
        sizeof(ShortFileName)/sizeof(WCHAR) );
    if (p = wcsrchr(ShortFileName, L'\\')) {
        p += 1;        
    } else {
        p = ShortFileName;
    }
            
    if (!AlreadyCheckedForExport) {
        HMODULE hKernel32 = GetModuleHandle(L"kernel32.dll");

        if (hKernel32) {
            pSetFileShortName = GetProcAddress(
                                    hKernel32, 
                                    "SetFileShortNameW");
        }

        AlreadyCheckedForExport = TRUE;
    }

    // don't copy file if callback says not to

    if ((err = IMirrorNowDoing(CopyFiles, SourceFileName)) != ERROR_SUCCESS) {

        if (err == STATUS_REQUEST_ABORTED) {

            copyContext->Cancelled = TRUE;
        }
        return STATUS_SUCCESS;
    }

#ifndef IMIRROR_SUPPORT_ENCRYPTED

    //
    //  sorry, for this release we currently don't support encrypted files.
    //

    if (SourceFindData->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {

        errorCase = ReportCopyError(   copyContext,
                                       SourceFileName,
                                       COPY_ERROR_ACTION_CREATE_FILE,
                                       ERROR_FILE_ENCRYPTED );
        if (errorCase == STATUS_RETRY) {
            SourceFindData->FileAttributes = GetFileAttributes( SourceFileName );
            goto retryMirrorFile;
        }
        if (errorCase == ERROR_SUCCESS) {

            err = STATUS_SUCCESS;

        } else {

            err = ERROR_FILE_ENCRYPTED;
        }
        return err;
    }
#endif

    fileBasicInfo.FileAttributes = 0;       // by default, leave them alone

    if (SourceFindData->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

        err = CanHandleReparsePoint( ThreadContext,
                                     SourceFileName,
                                     SourceFindData->FileAttributes
                                     );
        if (!NT_SUCCESS(err)) {

            errorCase = ReportCopyError(   copyContext,
                                           SourceFileName,
                                           COPY_ERROR_ACTION_CREATE_FILE,
                                           err );
            if (errorCase == STATUS_RETRY) {
                SourceFindData->FileAttributes = GetFileAttributes( SourceFileName );
                goto retryMirrorFile;
            }
            if (errorCase == ERROR_SUCCESS) {

                err = STATUS_SUCCESS;
            }
            return err;
        }

        SourceFindData->FileAttributes &= ~FILE_ATTRIBUTE_REPARSE_POINT;
    }

    if (ExistingMirrorFile) {

        if ((ExistingMirrorFile->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
            ((ExistingMirrorFile->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) !=
             (SourceFindData->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED))) {

            //
            //  it exists as a directory.  Master is always right, let's
            //  delete the directory.
            //
            //  Also, if the master and slave differ in whether the file is
            //  encrypted or not, delete the slave.
            //

            err = UnconditionalDelete(  ThreadContext,
                                        SourceFileName,
                                        DestFileName,
                                        ExistingMirrorFile->FileAttributes,
                                        NULL );

            if (err != ERROR_SUCCESS) {
                return err;
            }

            ExistingMirrorFile = NULL;

        } else {

            //
            //  if the files are the same, leave it be.
            //

            if ((SourceFindData->CreationTime.QuadPart == ExistingMirrorFile->CreationTime.QuadPart ) &&
                (SourceFindData->LastWriteTime.QuadPart == ExistingMirrorFile->LastWriteTime.QuadPart) &&
                (SourceFindData->EaSize == ExistingMirrorFile->EaSize) &&
                (SourceFindData->EndOfFile.QuadPart == ExistingMirrorFile->EndOfFile.QuadPart)) {

                fileIsAlreadyThere = TRUE;
                updateBasic = FALSE;

                //
                //  let's get the security descriptor and extended attributes to
                //  see if we need to update our alternate data stream on the target.
                //

                err = GetOurSecurityStream( ThreadContext, DestFileName, &aclStream );

                if ((err == ERROR_SUCCESS) &&
                    (aclStream.ChangeTime.QuadPart == SourceFindData->ChangeTime.QuadPart) &&
                    (SourceFindData->FileAttributes == aclStream.ExtendedAttributes)) {

                    updateStoredSecurityAttributes = FALSE;

                } else {

                    err = ERROR_SUCCESS;
                }

                //
                // let's get the short file name to see if we need to update 
                // our alternate data stream on the target.
                //

                err = GetOurSFNStream( 
                            ThreadContext, 
                            DestFileName, 
                            &SFNStream, 
                            ShortFileNameInStream, 
                            sizeof(ShortFileNameInStream) );

                if ((err == ERROR_SUCCESS) &&
                    *p != L'\0' &&
                    (wcscmp(ShortFileNameInStream, p) == 0)) {

                    updateStoredSFNAttributes = FALSE;

                } else {

                    err = ERROR_SUCCESS;
                }



            }
        }
    }

    //
    //  if the file already exists but it's not current or our alternate
    //  stream needs updating, let's update the attributes such that we can
    //  modify the file.
    //

    fileBasicInfo.CreationTime.QuadPart = SourceFindData->CreationTime.QuadPart;
    fileBasicInfo.LastWriteTime.QuadPart = SourceFindData->LastWriteTime.QuadPart;
    fileBasicInfo.LastAccessTime.QuadPart = SourceFindData->LastAccessTime.QuadPart;
    fileBasicInfo.ChangeTime.QuadPart = SourceFindData->ChangeTime.QuadPart;

    err = ERROR_SUCCESS;

    if (! fileIsAlreadyThere) {

#ifdef IMIRROR_SUPPORT_ENCRYPTED
        if (SourceFindData->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {

            err = IMCopyEncryptFile( ThreadContext->CopyContext,
                                     SourceFileName,
                                     DestFileName );
            isEncrypted = TRUE;

        } else {
#endif
            if (CopyFile( SourceFileName, DestFileName, FALSE) == FALSE) {

                err = GetLastError();

            } else {

                err = ERROR_SUCCESS;
            }
#ifdef IMIRROR_SUPPORT_ENCRYPTED
        }
#endif
        if (err == ERROR_SHARING_VIOLATION) {

            //
            //  we ignore sharing violations for the following files :
            //      system registry files
            //      tracking.log
            //      ntuser.dat & ntuser.dat.log
            //      usrclass.dat & usrclass.dat.log
            //

            PWCHAR fileName = SourceFileName;
            PIMIRROR_IGNORE_FILE_LIST ignoreListEntry;
            ULONG componentLength;
            PLIST_ENTRY listEntry;

            if (_wcsicmp(SourceFileName, L"\\\\?\\")) {

                PWCHAR firstSlash;

                fileName += 4;      // now fileName points to L"C:\WINNT..."

                firstSlash = fileName;
                while (*firstSlash != L'\\' && *firstSlash != L'\0') {
                    firstSlash++;
                }
                if (*firstSlash != L'\0') {
                    fileName = firstSlash+1;  // now fileName points to L"WINNT\..."
                }
            }

            componentLength = lstrlenW( fileName );

            listEntry = ThreadContext->FilesToIgnore.Flink;

            while (listEntry != &(ThreadContext->FilesToIgnore)) {

                ignoreListEntry = (PIMIRROR_IGNORE_FILE_LIST)
                                    CONTAINING_RECORD(  listEntry,
                                                        IMIRROR_IGNORE_FILE_LIST,
                                                        ListEntry );

                if (CompareStringW( LOCALE_SYSTEM_DEFAULT,
                                    NORM_IGNORECASE,
                                    fileName,
                                    min( componentLength, ignoreListEntry->FileNameLength),
                                    &ignoreListEntry->FileName[0],
                                    ignoreListEntry->FileNameLength) == 2) {

                    // it matched one of our special files.  we'll ignore the
                    // error but also not set the attributes on the image.

                    return err;
                }

                listEntry = listEntry->Flink;
            }
        }

        // report either success or failure up to the caller

        if (err == ERROR_SUCCESS) {

            ReportCopyError(   ThreadContext->CopyContext,
                               SourceFileName,
                               COPY_ERROR_ACTION_CREATE_FILE,
                               err );

            InterlockedIncrement( &copyContext->FilesCopied );
            copyContext->BytesCopied.QuadPart += SourceFindData->EndOfFile.QuadPart;

        } else {

            errorCase = ReportCopyError(   ThreadContext->CopyContext,
                                           SourceFileName,
                                           COPY_ERROR_ACTION_CREATE_FILE,
                                           err );
            if (errorCase == STATUS_RETRY) {
                goto retryMirrorFile;
            }
            if (errorCase == ERROR_SUCCESS) {

                err = STATUS_SUCCESS;
            }
            return err;
        }

        updateStoredSecurityAttributes = TRUE;
        updateStoredSFNAttributes = TRUE;
        updateBasic = TRUE;
        fileBasicInfo.FileAttributes = 0;   // don't set the attribute again.

        if (err == STATUS_SUCCESS) {

            //
            //  we just created the file so we'll just give it the archive
            //  bit as an attribute since we've saved off the rest in the
            //  stream.
            //

            if (! SetFileAttributes( DestFileName, FILE_ATTRIBUTE_ARCHIVE )) {

                err = GetLastError();

                errorCase = ReportCopyError(   copyContext,
                                               DestFileName,
                                               COPY_ERROR_ACTION_SETATTR,
                                               err );
                if (errorCase == STATUS_RETRY) {
                    goto retryMirrorFile;
                }
                if (errorCase == ERROR_SUCCESS) {

                    err = STATUS_SUCCESS;
                }
            }
        }
    }

    if ((err == ERROR_SUCCESS) && updateStoredSFNAttributes && (*p != L'\0')) {

        err = StoreOurSFNStream(  ThreadContext,
                                  SourceFileName,
                                  DestFileName,
                                  p
                                );
        updateBasic = TRUE;
    }

    if ((err == ERROR_SUCCESS) && updateStoredSecurityAttributes) {

        err = StoreOurSecurityStream(  ThreadContext,
                                       SourceFileName,
                                       DestFileName,
                                       SourceFindData->FileAttributes,
                                       SourceFindData->ChangeTime
                                       );
        updateBasic = TRUE;
    }

    if ((err == ERROR_SUCCESS) && updateBasic) {

        //
        //  set create date and lastUpdate date to correct values
        //

        fileHandle = CreateFile(    DestFileName,
                                    FILE_WRITE_ATTRIBUTES | DELETE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL );

        if (fileHandle == INVALID_HANDLE_VALUE) {

            err = GetLastError();

        } else {
            
            //
            // first try to set the short name.  If this fails, we just ignore
            // the error.
            //
            
            
            if (pSetFileShortName) {
                pSetFileShortName( fileHandle, p );                
            }

            //
            //  if we're making a change to an existing file, update the ARCHIVE bit.
            //

            if (fileIsAlreadyThere &&
                0 == (fileBasicInfo.FileAttributes & FILE_ATTRIBUTE_ARCHIVE)) {

                fileBasicInfo.FileAttributes |= FILE_ATTRIBUTE_ARCHIVE;
            }

            //
            //  set create date and lastUpdate date to correct values
            //

            err = NtSetInformationFile(    fileHandle,
                                           &IoStatusBlock,
                                           &fileBasicInfo,
                                           sizeof( FILE_BASIC_INFORMATION ),
                                           FileBasicInformation
                                           );

            err = IMConvertNT2Win32Error( err );
        }
        if (err != STATUS_SUCCESS) {

            errorCase = ReportCopyError(   copyContext,
                                           DestFileName,
                                           COPY_ERROR_ACTION_SETTIME,
                                           err );
            if (errorCase == STATUS_RETRY) {
                goto retryMirrorFile;
            }
            if (errorCase == ERROR_SUCCESS) {

                err = STATUS_SUCCESS;
            }
        } else if (fileIsAlreadyThere) {

            InterlockedIncrement( &copyContext->AttributesModified );
        }
    }

    if (err == STATUS_SUCCESS) {

        //
        //  report that we succeeded in copying the file
        //

        (VOID)ReportCopyError(   copyContext,
                                 SourceFileName,
                                 COPY_ERROR_ACTION_CREATE_FILE,
                                 err );
    }

    if ( fileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( fileHandle );
    }
    return err;
}

DWORD
UnconditionalDelete (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR SourceFile,
    PWCHAR FileToDelete,
    DWORD  Attributes,
    PWCHAR NameBuffer
    )
{
    DWORD err;
    BOOLEAN allocatedBuffer;
    BOOLEAN reportError;
    PCOPY_TREE_CONTEXT copyContext;

retryDelete:

    err = ERROR_SUCCESS;
    allocatedBuffer = FALSE;
    reportError = TRUE;
    copyContext = ThreadContext->CopyContext;

    if (copyContext->DeleteOtherFiles == FALSE) {

        err = ERROR_WRITE_PROTECT;
        goto exitWithError;
    }

    if ((Attributes & (FILE_ATTRIBUTE_READONLY |
                       FILE_ATTRIBUTE_HIDDEN   |
                       FILE_ATTRIBUTE_SYSTEM)) != 0) {

        // set the attributes back to normal

        Attributes &= ~FILE_ATTRIBUTE_READONLY;
        Attributes &= ~FILE_ATTRIBUTE_HIDDEN;
        Attributes &= ~FILE_ATTRIBUTE_SYSTEM;

        SetFileAttributesW( FileToDelete, Attributes );
    }

    if ((Attributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {

        if (! DeleteFile( FileToDelete )) {

            err = GetLastError();

        } else {

            InterlockedIncrement( &copyContext->FilesDeleted );
        }
    } else {

        //
        //  remove all files and subdirectories recursively here...
        //

        HANDLE fileEnum = INVALID_HANDLE_VALUE;
        WIN32_FIND_DATA findData;
        PWCHAR startFileName;
        ULONG dirLength;

        if (NameBuffer == NULL) {

            NameBuffer = IMirrorAllocMem( TMP_BUFFER_SIZE );

            if (NameBuffer == NULL) {

                err = STATUS_NO_MEMORY;
                goto exitWithError;
            }

            lstrcpyW( NameBuffer, FileToDelete );
            allocatedBuffer = TRUE;
        }

        dirLength = lstrlenW( NameBuffer );
        lstrcatW( NameBuffer, L"\\*" );

        // remember the start of the char after the backslash to slap in the name

        startFileName = NameBuffer + dirLength + 1;

        err = ERROR_SUCCESS;
        fileEnum = FindFirstFile( NameBuffer, &findData );

        if (fileEnum != INVALID_HANDLE_VALUE) {

            while (copyContext->Cancelled == FALSE) {

                if (((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) &&
                     (findData.cFileName[0] == L'.')) {

                    if ((findData.cFileName[1] == L'\0') ||
                        (findData.cFileName[1] == L'.' &&
                         findData.cFileName[2] == L'\0')) {

                        goto skipToNextDir;
                    }
                }

                lstrcpyW( startFileName, &findData.cFileName[0] );

                err = UnconditionalDelete(  ThreadContext,
                                            SourceFile,
                                            NameBuffer,
                                            findData.dwFileAttributes,
                                            NameBuffer );

                if (err != ERROR_SUCCESS) {

                    reportError = FALSE;
                    break;
                }
skipToNextDir:
                if (! FindNextFile( fileEnum, &findData)) {

                    err = GetLastError();
                    if (err == ERROR_NO_MORE_FILES) {
                        err = ERROR_SUCCESS;
                        break;
                    }
                }
            }
            FindClose( fileEnum );
            *(NameBuffer+dirLength) = L'\0';
        }

        if (err == ERROR_SUCCESS) {

            if (! RemoveDirectory( FileToDelete ) ) {

                err = GetLastError();

            } else {

                InterlockedIncrement( &copyContext->DirectoriesDeleted );
            }
        }
    }

exitWithError:

    // we report the error for both success and failure

    if (allocatedBuffer && NameBuffer != NULL) {

        IMirrorFreeMem( NameBuffer );
    }

    if (reportError) {

        DWORD errorCase;

        errorCase = ReportCopyError(   copyContext,
                                       FileToDelete,
                                       COPY_ERROR_ACTION_DELETE,
                                       err );
        if (errorCase == STATUS_RETRY) {
            goto retryDelete;
        }
        if (errorCase == ERROR_SUCCESS) {
            err = ERROR_SUCCESS;
        }
    }
    return err;
}

DWORD
StoreOurSecurityStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Source,
    PWCHAR Dest,
    DWORD  AttributesToStore,
    LARGE_INTEGER ChangeTime
    )
//
//  This routine stores off the acl from the master into a named alternate
//  data stream on the destination.  It saves off both the ACL and a few
//  file attributes that couldn't be stored in the normal directory entry.
//
{
    PSECURITY_DESCRIPTOR SourceSD;
    PCOPY_TREE_CONTEXT copyContext;
    DWORD err;
    DWORD requiredLength;
    HANDLE hAclFile;
    PWCHAR aclFileName;
    ULONG action;
    MIRROR_ACL_STREAM mirrorAclStream;
    DWORD BytesWritten;
    DWORD deleteAclFile;
    DWORD errorCase;

retryWriteStream:

    errorCase = STATUS_SUCCESS;
    SourceSD = NULL;
    copyContext = ThreadContext->CopyContext;
    err = ERROR_SUCCESS;
    requiredLength = 0;
    hAclFile = INVALID_HANDLE_VALUE;
    action = COPY_ERROR_ACTION_GETACL;
    deleteAclFile = FALSE;

    //
    //  We use the SDBuffer on the thread context to store not only the
    //  security descriptor but also the file name of the alternate data stream.
    //

    requiredLength = (lstrlenW( Dest ) + lstrlenW( IMIRROR_ACL_STREAM_NAME ) + 1) * sizeof(WCHAR);

    if (ThreadContext->SDBuffer == NULL || requiredLength > ThreadContext->SDBufferLength) {

        if (ThreadContext->SDBuffer != NULL) {

            IMirrorFreeMem( ThreadContext->SDBuffer );
            ThreadContext->SDBuffer = NULL;
            ThreadContext->SDBufferLength = requiredLength;
        }

        if (requiredLength > ThreadContext->SDBufferLength) {
            ThreadContext->SDBufferLength = requiredLength;
        }

        ThreadContext->SDBuffer = IMirrorAllocMem( ThreadContext->SDBufferLength );

        if (ThreadContext->SDBuffer == NULL) {

            err = GetLastError();

            errorCase = ReportCopyError(  copyContext,
                                          Source,
                                          COPY_ERROR_ACTION_MALLOC,
                                          err );
            goto IMCEExit;
        }
    }

    aclFileName = (PWCHAR) ThreadContext->SDBuffer;
    lstrcpyW( aclFileName, Dest );
    lstrcatW( aclFileName, IMIRROR_ACL_STREAM_NAME );

    hAclFile  = CreateFile(     aclFileName,
                                GENERIC_WRITE,
                                0,              // Exclusive access.
                                NULL,           // Default security descriptor.
                                CREATE_ALWAYS,  // Overrides if file exists.
                                0,              // no special attributes
                                NULL
                                );

    if (hAclFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();

        errorCase = ReportCopyError(  copyContext,
                                      Source,
                                      COPY_ERROR_ACTION_CREATE_FILE,
                                      err );
        goto IMCEExit;
    }

    //
    //  read the source security descriptor into the buffer allocated off the
    //  thread context.
    //

    if (ThreadContext->IsNTFS == FALSE) {

        requiredLength = 0;

    } else {

        err = ERROR_INSUFFICIENT_BUFFER;

        while (err == ERROR_INSUFFICIENT_BUFFER) {

            if (ThreadContext->SDBuffer == NULL) {

                ThreadContext->SDBuffer = IMirrorAllocMem( ThreadContext->SDBufferLength );

                if (ThreadContext->SDBuffer == NULL) {

                    err = GetLastError();
                    break;
                }
            }

            SourceSD = (PSECURITY_DESCRIPTOR) ThreadContext->SDBuffer;

            //
            // get SD of the SourceRoot file.  This comes back self relative.
            //
            if (GetFileSecurity( Source,
                                 (DACL_SECURITY_INFORMATION |
                                  GROUP_SECURITY_INFORMATION |
                                  SACL_SECURITY_INFORMATION |
                                  OWNER_SECURITY_INFORMATION),
                                SourceSD,
                                ThreadContext->SDBufferLength,
                                &requiredLength )) {

                err = ERROR_SUCCESS;

            } else {

                err = GetLastError();

                if ((err == ERROR_INSUFFICIENT_BUFFER) ||
                    (requiredLength > ThreadContext->SDBufferLength)) {

                    // let's try it again with a bigger buffer.

                    ThreadContext->SDBufferLength = requiredLength;
                    IMirrorFreeMem( ThreadContext->SDBuffer );
                    ThreadContext->SDBuffer = NULL;
                    err = ERROR_INSUFFICIENT_BUFFER;
                }
            }
        }

        if (err != ERROR_SUCCESS) {

            errorCase = ReportCopyError(  copyContext,
                                          Source,
                                          COPY_ERROR_ACTION_GETACL,
                                          err );
            goto IMCEExit;
        }

        InterlockedIncrement( &copyContext->SourceSecurityDescriptorsRead );
        ASSERT( IsValidSecurityDescriptor(SourceSD) );
    }

    mirrorAclStream.StreamVersion = IMIRROR_ACL_STREAM_VERSION;
    mirrorAclStream.StreamLength = sizeof( MIRROR_ACL_STREAM ) +
                                   requiredLength;
    mirrorAclStream.ChangeTime.QuadPart = ChangeTime.QuadPart;
    mirrorAclStream.ExtendedAttributes = AttributesToStore;
    mirrorAclStream.SecurityDescriptorLength = requiredLength;

    if ((WriteFile( hAclFile,
                    &mirrorAclStream,
                    sizeof( MIRROR_ACL_STREAM ),
                    &BytesWritten,
                    NULL        // No overlap.
                    ) == FALSE) ||
         (BytesWritten < sizeof( MIRROR_ACL_STREAM ))) {

        deleteAclFile = TRUE;
        err = GetLastError();

        errorCase = ReportCopyError(  copyContext,
                                      Source,
                                      COPY_ERROR_ACTION_SETACL,
                                      err );
        goto IMCEExit;
    }

    if (ThreadContext->IsNTFS) {

        if ((WriteFile( hAclFile,
                        SourceSD,
                        requiredLength,
                        &BytesWritten,
                        NULL        // No overlap.
                        ) == FALSE) ||
             (BytesWritten < requiredLength )) {

            deleteAclFile = TRUE;
            err = GetLastError();

            errorCase = ReportCopyError(  copyContext,
                                          Source,
                                          COPY_ERROR_ACTION_SETACL,
                                          err );
            goto IMCEExit;
        }

        InterlockedIncrement( &copyContext->SecurityDescriptorsWritten );
    }

IMCEExit:

    if (hAclFile != INVALID_HANDLE_VALUE) {

        CloseHandle( hAclFile );

        if (deleteAclFile) {

            // the file didn't get written properly, let's delete

            aclFileName = (PWCHAR) ThreadContext->SDBuffer;
            lstrcpyW( aclFileName, Dest );
            lstrcatW( aclFileName, IMIRROR_ACL_STREAM_NAME );

            DeleteFile( aclFileName );
        }
    }
    if (errorCase == STATUS_RETRY) {
        goto retryWriteStream;
    }
    if (errorCase == ERROR_SUCCESS) {
        err = ERROR_SUCCESS;
    }
    return err;
}

DWORD
StoreOurSFNStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Source,
    PWCHAR Dest,
    PWCHAR ShortFileName
    )
//
//  This routine stores off the short file name from the master into a named
//  alternate data stream on the destination.  
//
{
    
    PCOPY_TREE_CONTEXT copyContext;
    DWORD err;
    DWORD requiredLength;
    DWORD ShortFileNameLength;
    HANDLE hSFNFile;
    PWCHAR SFNFileName;
    ULONG action;
    MIRROR_SFN_STREAM mirrorSFNStream;
    DWORD BytesWritten;
    BOOL deleteSFNFile;
    DWORD errorCase;


retryWriteStream:

    errorCase = STATUS_SUCCESS;
    
    copyContext = ThreadContext->CopyContext;
    err = ERROR_SUCCESS;
    requiredLength = 0;
    hSFNFile = INVALID_HANDLE_VALUE;
    action = COPY_ERROR_ACTION_GETSFN;
    deleteSFNFile = FALSE;

    ShortFileNameLength = (wcslen(ShortFileName)+1)*sizeof(WCHAR);

    //
    //  We use the SFNBuffer on the thread context to store the file name of the
    //  alternate data stream.
    //

    requiredLength = (lstrlenW( Dest ) + lstrlenW( IMIRROR_SFN_STREAM_NAME ) + 1) * sizeof(WCHAR);
    if (requiredLength < ShortFileNameLength) {
        requiredLength = ShortFileNameLength;
    }

    if (ThreadContext->SFNBuffer == NULL || (requiredLength > ThreadContext->SFNBufferLength)) {

        if (ThreadContext->SFNBuffer != NULL) {

            IMirrorFreeMem( ThreadContext->SFNBuffer );
            ThreadContext->SFNBuffer = NULL;            
        }

        if (requiredLength > ThreadContext->SFNBufferLength) {
            ThreadContext->SFNBufferLength = requiredLength;
        }
        
        ThreadContext->SFNBuffer = IMirrorAllocMem( ThreadContext->SFNBufferLength );
        

        if (ThreadContext->SFNBuffer == NULL) {

            err = GetLastError();

            errorCase = ReportCopyError(  copyContext,
                                          Source,
                                          COPY_ERROR_ACTION_MALLOC,
                                          err );
            goto IMCEExit;
        }
    }

    SFNFileName = (PWCHAR) ThreadContext->SFNBuffer;
    lstrcpyW( SFNFileName, Dest );
    lstrcatW( SFNFileName, IMIRROR_SFN_STREAM_NAME );

    hSFNFile  = CreateFile(     SFNFileName,
                                GENERIC_WRITE,
                                0,              // Exclusive access.
                                NULL,           // Default security descriptor.
                                CREATE_ALWAYS,  // Overrides if file exists.
                                FILE_FLAG_BACKUP_SEMANTICS,  // Open directories too.
                                NULL
                                );

    if (hSFNFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();

        errorCase = ReportCopyError(  copyContext,
                                      Source,
                                      COPY_ERROR_ACTION_CREATE_FILE,
                                      err );
        goto IMCEExit;
    }


    mirrorSFNStream.StreamVersion = IMIRROR_SFN_STREAM_VERSION;
    mirrorSFNStream.StreamLength = sizeof( MIRROR_SFN_STREAM ) + ShortFileNameLength;
    
    if ((WriteFile( hSFNFile,
                    &mirrorSFNStream,
                    sizeof( MIRROR_SFN_STREAM ),
                    &BytesWritten,
                    NULL        // No overlap.
                    ) == FALSE) ||
         (BytesWritten < sizeof( MIRROR_SFN_STREAM ))) {

        deleteSFNFile = TRUE;
        err = GetLastError();

        errorCase = ReportCopyError(  copyContext,
                                      Source,
                                      COPY_ERROR_ACTION_SETSFN,
                                      err );
        goto IMCEExit;
    }

    if ((WriteFile( hSFNFile,
                    ShortFileName,
                    ShortFileNameLength,
                    &BytesWritten,
                    NULL        // No overlap.
                    ) == FALSE) ||
             (BytesWritten < ShortFileNameLength )) {

        deleteSFNFile = TRUE;
        err = GetLastError();

        errorCase = ReportCopyError(  copyContext,
                                      Source,
                                      COPY_ERROR_ACTION_SETSFN,
                                      err );
        goto IMCEExit;
    }

    InterlockedIncrement( &copyContext->SFNWritten );
    

IMCEExit:

    if (hSFNFile != INVALID_HANDLE_VALUE) {

        CloseHandle( hSFNFile );

        if (deleteSFNFile) {

            // the file didn't get written properly, let's delete

            SFNFileName = (PWCHAR) ThreadContext->SFNBuffer;
            lstrcpyW( SFNFileName, Dest );
            lstrcatW( SFNFileName, IMIRROR_SFN_STREAM_NAME );

            DeleteFile( SFNFileName );
        }
    }
    if (errorCase == STATUS_RETRY) {
        goto retryWriteStream;
    }
    if (errorCase == ERROR_SUCCESS) {
        err = ERROR_SUCCESS;
    }
    return err;
}


DWORD
GetOurSFNStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Dest,
    PMIRROR_SFN_STREAM MirrorSFNStream,
    PWCHAR SFNBuffer,
    DWORD  SFNBufferSize
    )
//
//  This routine reads the short filename stream header from the destination.  We do this
//  to get the fields out of it so that we can determine if it needs updating.
//
{
    DWORD err = ERROR_SUCCESS;
    DWORD requiredLength = 0;
    HANDLE hSFNFile = INVALID_HANDLE_VALUE;
    PWCHAR SFNFileName;
    DWORD BytesRead;

    //
    //  We use the SFNBuffer on the thread context to store not only the
    //  security descriptor but also the file name of the alternate data stream.
    //
    if (!Dest || *Dest == L'\0') {
        err = ERROR_INVALID_PARAMETER;
        goto IMCEExit;
    }

    requiredLength = (lstrlenW( Dest ) + lstrlenW( IMIRROR_SFN_STREAM_NAME ) + 1) * sizeof(WCHAR);

    if (ThreadContext->SFNBuffer == NULL || requiredLength > ThreadContext->SFNBufferLength) {

        if (ThreadContext->SFNBuffer != NULL) {

            IMirrorFreeMem( ThreadContext->SFNBuffer );
            ThreadContext->SFNBuffer = NULL;
            ThreadContext->SFNBufferLength = requiredLength;
        }

        if (requiredLength > ThreadContext->SFNBufferLength) {
            ThreadContext->SFNBufferLength = requiredLength;
        }

        ThreadContext->SFNBuffer = IMirrorAllocMem( ThreadContext->SFNBufferLength );

        if (ThreadContext->SFNBuffer == NULL) {

            err = GetLastError();
            goto IMCEExit;
        }
    }

    SFNFileName = (PWCHAR) ThreadContext->SFNBuffer;
    lstrcpyW( SFNFileName, Dest );
    lstrcatW( SFNFileName, IMIRROR_SFN_STREAM_NAME );

    hSFNFile  = CreateFile(     SFNFileName,
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,           // Default security descriptor.
                                OPEN_EXISTING,
                                0,              // no special attributes
                                NULL
                                );

    if (hSFNFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();
        goto IMCEExit;
    }

    
    if ((ReadFile( hSFNFile,
                   MirrorSFNStream,
                   sizeof( MIRROR_SFN_STREAM ),
                   &BytesRead,
                   NULL        // No overlap.
                   ) == FALSE) ||
         (BytesRead < sizeof( MIRROR_SFN_STREAM )) ||
         (MirrorSFNStream->StreamVersion != IMIRROR_SFN_STREAM_VERSION) ||
         (MirrorSFNStream->StreamLength < sizeof( MIRROR_SFN_STREAM ))) {

        err = ERROR_INVALID_DATA;
    }

    if ((MirrorSFNStream->StreamLength - sizeof(MIRROR_SFN_STREAM)) > SFNBufferSize) {
        err = ERROR_INSUFFICIENT_BUFFER;
    } else {
        if ((ReadFile( hSFNFile,
                  SFNBuffer,
                  MirrorSFNStream->StreamLength - sizeof(MIRROR_SFN_STREAM),
                  &BytesRead,
                  NULL ) == FALSE) ||
            (BytesRead != (MirrorSFNStream->StreamLength - sizeof(MIRROR_SFN_STREAM)))) {
            err = ERROR_INVALID_DATA;
        }
    }

IMCEExit:

    if (hSFNFile != INVALID_HANDLE_VALUE) {

        CloseHandle( hSFNFile );
    }

    return err;
}

DWORD
GetOurSecurityStream (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR Dest,
    PMIRROR_ACL_STREAM MirrorAclStream
    )
//
//  This routine reads the stream header from the destination.  We do this
//  to get the fields out of it so that we can determine if it needs updating.
//
{
    PSECURITY_DESCRIPTOR SourceSD = NULL;
    DWORD err = ERROR_SUCCESS;
    DWORD requiredLength = 0;
    HANDLE hAclFile = INVALID_HANDLE_VALUE;
    PWCHAR aclFileName;
    DWORD BytesRead;

    //
    //  We use the SDuffer on the thread context to store not only the
    //  security descriptor but also the file name of the alternate data stream.
    //

    if (!Dest || *Dest == L'\0') {
        err = ERROR_INVALID_PARAMETER;
        goto IMCEExit;
    }
    requiredLength = (lstrlenW( Dest ) + lstrlenW( IMIRROR_ACL_STREAM_NAME ) + 1) * sizeof(WCHAR);

    if (ThreadContext->SDBuffer == NULL || requiredLength > ThreadContext->SDBufferLength) {

        if (ThreadContext->SDBuffer != NULL) {

            IMirrorFreeMem( ThreadContext->SDBuffer );
            ThreadContext->SDBuffer = NULL;
            ThreadContext->SDBufferLength = requiredLength;
        }

        if (requiredLength > ThreadContext->SDBufferLength) {
            ThreadContext->SDBufferLength = requiredLength;
        }

        ThreadContext->SDBuffer = IMirrorAllocMem( ThreadContext->SDBufferLength );

        if (ThreadContext->SDBuffer == NULL) {

            err = GetLastError();
            goto IMCEExit;
        }
    }

    aclFileName = (PWCHAR) ThreadContext->SDBuffer;
    lstrcpyW( aclFileName, Dest );
    lstrcatW( aclFileName, IMIRROR_ACL_STREAM_NAME );

    hAclFile  = CreateFile(     aclFileName,
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,           // Default security descriptor.
                                OPEN_EXISTING,
                                0,              // no special attributes
                                NULL
                                );

    if (hAclFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();
        goto IMCEExit;
    }

    //
    //  read the header of the stream.  We don't bother reading the security
    //  descriptor because all we need is the ChangeTime (which changes with
    //  the security descriptor).
    //

    if ((ReadFile( hAclFile,
                   MirrorAclStream,
                   sizeof( MIRROR_ACL_STREAM ),
                   &BytesRead,
                   NULL        // No overlap.
                   ) == FALSE) ||
         (BytesRead < sizeof( MIRROR_ACL_STREAM )) ||
         (MirrorAclStream->StreamVersion != IMIRROR_ACL_STREAM_VERSION) ||
         (MirrorAclStream->StreamLength < sizeof( MIRROR_ACL_STREAM ))) {

        err = ERROR_INVALID_DATA;
    }

IMCEExit:

    if (hAclFile != INVALID_HANDLE_VALUE) {

        CloseHandle( hAclFile );
    }

    return err;
}

#ifdef DEBUGLOG
VOID
IMLogToFile(
    PSTR  Buffer
    )
/*++

Routine Description:

    Write message to log file.

Arguments:

    Buffer - NULL terminated message.

Return Value:

    None

--*/
{
    ULONG Len;
    ULONG NumWritten;

    AcquireCriticalSection( &DebugFileLock );

    if (hDebugLogFile == INVALID_HANDLE_VALUE){

       ReleaseCriticalSection( &DebugFileLock );
       return;
    }

    Len = strlen(Buffer);

    //
    // this check also accounts for NULL byte that is added
    //
    if (DebugLogFileOffset + Len >= (DEBUG_LOG_BUFFER_SIZE-1) ){
        WriteFile(hDebugLogFile, DebugLogFileBuffer, DebugLogFileOffset + 1, &NumWritten, NULL);
        DebugLogFileOffset = 0;
    }

    memcpy(&DebugLogFileBuffer[DebugLogFileOffset], Buffer, Len);
    DebugLogFileOffset += Len;
    DebugLogFileBuffer[DebugLogFileOffset++]='\0';
    ReleaseCriticalSection( &DebugFileLock );

    return;
}

VOID
IMFlushAndCloseLog(
    VOID
    )
{
    ULONG NumWritten;

    AcquireCriticalSection( &DebugFileLock );

    if (hDebugLogFile != INVALID_HANDLE_VALUE) {
        WriteFile(hDebugLogFile, DebugLogFileBuffer, DebugLogFileOffset + 1, &NumWritten, NULL);
        CloseHandle(hDebugLogFile);
        hDebugLogFile = INVALID_HANDLE_VALUE;
    }
    ReleaseCriticalSection( &DebugFileLock );
}
#endif



ULONG
ReportCopyError (
    PCOPY_TREE_CONTEXT CopyContext OPTIONAL,
    PWCHAR File,
    DWORD  ActionCode,
    DWORD  Err
    )
//
//  This returns either ERROR_SUCCESS, STATUS_RETRY, or STATUS_REQUEST_ABORTED
//
//  ERROR_SUCCESS means we just continue on and ignore the error.
//  STATUS_RETRY means we retry the operation
//  STATUS_REQUEST_ABORTED means we bail.
//
{
    ULONG ntErr = ERROR_SUCCESS;

    if (CopyContext != NULL) {

        if (Err != ERROR_SUCCESS) {

            InterlockedIncrement( &CopyContext->ErrorsEncountered );
        }
    }

    if (Callbacks.FileCreateFn == NULL) {

        if (Err != ERROR_SUCCESS) {
            if (ActionCode == COPY_ERROR_ACTION_DELETE) {

                printf( "error %u while deleting %S\n", Err, File );

            } else {

                printf( "error %u while copying %S\n", Err, File );
            }
        } else {

            if (ActionCode == COPY_ERROR_ACTION_DELETE) {

                printf( "deleted %S\n", File );

            } else {

                printf( "copied %S\n", File );
            }
        }
    }

    if (Err != STATUS_SUCCESS) {

        ntErr = IMirrorFileCreate(File, ActionCode, Err);

        if (ntErr == STATUS_REQUEST_ABORTED ||
            ntErr == ERROR_REQUEST_ABORTED) {

            ntErr = STATUS_REQUEST_ABORTED;
            CopyContext->Cancelled = TRUE;

        } else if ((ntErr != STATUS_RETRY) &&
                   (ntErr != ERROR_SUCCESS)) {

            ntErr = ERROR_SUCCESS;
        }
    }

    return ntErr;
}

#ifdef IMIRROR_SUPPORT_ENCRYPTED
DWORD
IMReadRawCallback(
    PBYTE pData,
    PVOID pCallbackContext,
    ULONG Length
    )
/*++
Routine Description
    Call back function registered by IMCopyEncryptFile

Arguments:
    pData - Data to copied
    pCallbackContext  - call back context
    Length - size, in bytes, of Data to be copied.

Return value:
    Win 32 error code on failure, otherwise ERROR_SUCCESS

--*/
{
    DWORD Status = ERROR_SUCCESS;
    DWORD BytesWritten = Length;

    if ( Length &&
         !WriteFile( (HANDLE) pCallbackContext,
                     pData,
                     Length,
                     &BytesWritten,
                     NULL        // No overlap.
                     )){

        Status = GetLastError();
    }

    return Status;
}

DWORD
IMCopyEncryptFile(
    PCOPY_TREE_CONTEXT CopyContext,
    LPWSTR SourceFileName,
    LPWSTR DestFileName
)
/*++
Routine Description
    Copies the source file to destination file while preserving the encryption information.

Arguments:
    CopyContext     - global data for this instance of copying a tree
    SourceFileName  - source file name
    DestFileName     - destination file name

Return value:
    Win 32 error code on failure, otherwise ERROR_SUCCESS

--*/
{
    DWORD Error;
    PVOID pContext = NULL;
    HANDLE hDestFile = INVALID_HANDLE_VALUE;
    ULONG errorCase;

retryCopyEncrypt:

    hDestFile = INVALID_HANDLE_VALUE;
    pContext = NULL;
    Error = ERROR_SUCCESS;
    errorCase = ERROR_SUCCESS;

    hDestFile = CreateFile(     DestFileName,
                                GENERIC_WRITE | GENERIC_READ,
                                0, // Exclusive access.
                                NULL, // Default security descriptor.
                                CREATE_ALWAYS, // Overrides if file exists.
                                FILE_ATTRIBUTE_ARCHIVE,
                                NULL
                                );

    if (hDestFile == INVALID_HANDLE_VALUE) {

        Error = GetLastError() ;

        errorCase = ReportCopyError( CopyContext,
                                     DestFileName,
                                     COPY_ERROR_ACTION_CREATE_FILE,
                                     Error );
        goto IMCEExit;
    }

    Error = OpenEncryptedFileRawW(  SourceFileName,
                                    0,  // Export
                                    &pContext
                                    );

    if (Error != ERROR_SUCCESS){

        errorCase = ReportCopyError( CopyContext,
                                     SourceFileName,
                                     COPY_ERROR_ACTION_CREATE_FILE,
                                     Error );
        goto IMCEExit;
    }

    Error = ReadEncryptedFileRaw( (PFE_EXPORT_FUNC)IMReadRawCallback,
                                  (PVOID) hDestFile,   //app call back context
                                  pContext
                                  );

    if (Error != ERROR_SUCCESS) {

        errorCase = ReportCopyError( CopyContext,
                                     SourceFileName,
                                     COPY_ERROR_ACTION_CREATE_FILE,
                                     Error );
        goto IMCEExit;
    }

IMCEExit:
    if (hDestFile != INVALID_HANDLE_VALUE){
        CloseHandle(hDestFile);
    }
    if (pContext){
        CloseEncryptedFileRaw(pContext);
    }
    if (errorCase == STATUS_RETRY) {
        goto retryCopyEncrypt;
    }
    if (errorCase == ERROR_SUCCESS) {
        Error = ERROR_SUCCESS;
    }

    return Error;
}
#endif

NTSTATUS
SetPrivs(
    IN HANDLE TokenHandle,
    IN LPTSTR lpszPriv
    )
/*++

Routine Description:

    This routine enables the given privilege in the given token.

Arguments:



Return Value:

    FALSE                       - Failure.
    TRUE                        - Success.

--*/
{
    LUID SetPrivilegeValue;
    TOKEN_PRIVILEGES TokenPrivileges;

    //
    // First, find out the value of the privilege
    //

    if (!LookupPrivilegeValue(NULL, lpszPriv, &SetPrivilegeValue)) {
        return GetLastError();
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = SetPrivilegeValue;
    TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges( TokenHandle,
                                FALSE,
                                &TokenPrivileges,
                                sizeof(TOKEN_PRIVILEGES),
                                NULL,
                                NULL)) {

        return GetLastError();
    }

    return ERROR_SUCCESS;
}

NTSTATUS
GetTokenHandle(
    IN OUT PHANDLE TokenHandle
    )
/*++

Routine Description:

    This routine opens the current process object and returns a
    handle to its token.

Arguments:


Return Value:

    NTSTATUS

--*/
{
    HANDLE ProcessHandle;
    NTSTATUS Result;

    ProcessHandle = OpenProcess(PROCESS_QUERY_INFORMATION,
                                FALSE,
                                GetCurrentProcessId());

    if (ProcessHandle == NULL) {
        return GetLastError();
    }

    Result = OpenProcessToken(ProcessHandle,
                              TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                              TokenHandle);

    CloseHandle(ProcessHandle);

    if (Result) {
        Result = ERROR_SUCCESS;
    } else {
        Result = GetLastError();
    }
    return Result;
}

NTSTATUS
CanHandleReparsePoint (
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    PWCHAR SourceFileName,
    DWORD FileAttributes
    )
//
//  This routine checks the type of reparse point a file is.  If it is a
//  reparse point we can handle (e.g. a structured storage document) then
//  return success.  Otherwise we return the appropriate error.
//
{
    return(ERROR_REPARSE_ATTRIBUTE_CONFLICT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\imirror\copy.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    copy.h

Abstract:

    This the include file for supporting copying files, creating new files, and
    copying the registries to the remote server.

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/


extern WCHAR pConfigPath[MAX_PATH];

//
// Define structure for an on-disk master boot record. (pulled from
// private\windows\setup\textmode\kernel\sppartit.h)
//
typedef struct _ON_DISK_PTE {
    UCHAR ActiveFlag;
    UCHAR StartHead;
    UCHAR StartSector;
    UCHAR StartCylinder;
    UCHAR SystemId;
    UCHAR EndHead;
    UCHAR EndSector;
    UCHAR EndCylinder;
    UCHAR RelativeSectors[4];
    UCHAR SectorCount[4];
} ON_DISK_PTE, *PON_DISK_PTE;
typedef struct _ON_DISK_MBR {
    UCHAR       BootCode[440];
    UCHAR       NTFTSignature[4];
    UCHAR       Filler[2];
    ON_DISK_PTE PartitionTable[4];
    UCHAR       AA55Signature[2];
} ON_DISK_MBR, *PON_DISK_MBR;

#define ALIGN(p,val) (PVOID)((((UINT_PTR)(p) + (val) - 1)) & (~((val) - 1)))
#define U_USHORT(p)    (*(USHORT UNALIGNED *)(p))
#define U_ULONG(p)     (*(ULONG  UNALIGNED *)(p))

typedef struct _MIRROR_VOLUME_INFO {
    LIST_ENTRY ListEntry;
    DWORD   MirrorTableIndex;
    WCHAR   DriveLetter;
    UCHAR   PartitionType;
    BOOLEAN PartitionActive;
    BOOLEAN IsBootDisk;
    BOOLEAN CompressedVolume;
    PWCHAR  MirrorUncPath;
    DWORD   DiskNumber;
    DWORD   PartitionNumber;
    DWORD   DiskSignature;
    DWORD   BlockSize;
    DWORD   LastUSNMirrored;
    ULONG   FileSystemFlags;
    WCHAR   FileSystemName[16];
    PWCHAR  VolumeLabel;
    PWCHAR  NtName;
    PWCHAR  ArcName;
    LARGE_INTEGER DiskSpaceUsed;
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER PartitionSize;
} MIRROR_VOLUME_INFO, *PMIRROR_VOLUME_INFO;


typedef struct _MIRROR_CFG_INFO {
    DWORD   MirrorVersion;
    DWORD   FileLength;
    DWORD   NumberVolumes;
    PWCHAR  SystemPath;
    BOOLEAN SysPrepImage;   // if FALSE, means it's a mirror
    BOOLEAN Debug;
    ULONG   NumberOfProcessors;
    ULONG   MajorVersion;
    ULONG   MinorVersion;
    ULONG   BuildNumber;
    ULONG   KernelFileVersionMS;
    ULONG   KernelFileVersionLS;
    ULONG   KernelFileFlags;
    PWCHAR  CSDVersion;
    PWCHAR  ProcessorArchitecture;
    PWCHAR  CurrentType;
    PWCHAR  HalName;
    LIST_ENTRY MirrorVolumeList;
} MIRROR_CFG_INFO, *PMIRROR_CFG_INFO;

extern PMIRROR_CFG_INFO GlobalMirrorCfgInfo;

typedef struct _IMIRROR_IGNORE_FILE_LIST {
    LIST_ENTRY ListEntry;
    USHORT FileNameLength;
    WCHAR FileName[1];
} IMIRROR_IGNORE_FILE_LIST, *PIMIRROR_IGNORE_FILE_LIST;

//
// Main processing functions
//
NTSTATUS
AddCopyToDoItems(
    VOID
    );


//
// Functions for processing each to do item
//
NTSTATUS
CopyCopyFiles(
    IN PVOID pBuffer,
    IN ULONG Length
    );

NTSTATUS
CopyCopyPartitions(
    IN PVOID pBuffer,
    IN ULONG Length
    );

NTSTATUS
CopyCopyRegistry(
    IN PVOID pBuffer,
    IN ULONG Length
    );

//
// Helper functions in filecopy.c
//
#if 0
NTSTATUS
DoFileCopy(
    IN PWSTR pMachineDir,
    IN PWSTR pSrc,
    IN BOOLEAN CheckConfig
    );

NTSTATUS
CopyNode(
    IN PWIN32_FIND_DATA pSrcFindData,
    IN BOOLEAN fFirstTime
    );
#endif

DWORD
CallBackFn(LPCWSTR             lpszName,
           DWORD               dwStatus,
           DWORD               dwHintFlags,
           DWORD               dwPinCount,
           WIN32_FIND_DATAW    *lpFind32,
           DWORD               dwReason,
           DWORD               dwParam1,
           DWORD               dwParam2,
           DWORD               dwContext
          );

#if 0
BOOLEAN
CopyPath(
    IN OUT PWCHAR *ppDest,
    IN OUT PULONG pLength,
    IN PWCHAR pSrc
    );

BOOLEAN
CatPath(
    IN OUT PWCHAR *ppDest,
    IN OUT PULONG pLength,
    IN PWCHAR pSrc
    );
#endif
//
// Helper functions in regcopy.c
//
DWORD
DoFullRegBackup(
    PWCHAR MirrorRoot
    );

DWORD
DoSpecificRegBackup(
    PWSTR HivePath,
    HKEY HiveRoot,
    PWSTR HiveName
    );

DWORD
GetRegistryFileList(
    PLIST_ENTRY ListHead
    );

//
// Global Defines
//
#define TMP_BUFFER_SIZE 1024
#define ARRAYSIZE( _x ) ( sizeof( _x ) / sizeof( _x[ 0 ] ) )

//
// Global variables
//
extern BYTE TmpBuffer[TMP_BUFFER_SIZE];
extern BYTE TmpBuffer2[TMP_BUFFER_SIZE];
extern BYTE TmpBuffer3[TMP_BUFFER_SIZE];
extern HANDLE ghInst;

//
// Memory functions
//
#define IMirrorAllocMem(x) LocalAlloc( LPTR, x)
#define IMirrorFreeMem(x)  LocalFree(x)
#define IMirrorReallocMem(x, sz)  LocalReAlloc(x, sz, LMEM_MOVEABLE)


//
// Error handling
//
#define IMirrorHandleError(_s, _f) ((Callbacks.ErrorFn != NULL) ? \
                                      Callbacks.ErrorFn(Callbacks.Context, _s, _f) : 0)

#define IMirrorNowDoing(_f, _s) ((Callbacks.NowDoingFn != NULL) ? \
                                      Callbacks.NowDoingFn(Callbacks.Context, _f, _s) : 0)

#define IMirrorGetMirrorDir(_s, _l) ((Callbacks.GetMirrorDirFn != NULL) ? \
                                      Callbacks.GetMirrorDirFn(Callbacks.Context, _s, _l) : 0)

#define IMirrorGetSetupPath(_s, _p, _l) ((Callbacks.GetSetupFn != NULL) ? \
                                      Callbacks.GetSetupFn(Callbacks.Context, _s, _p, _l) : 0)

#define IMirrorSetSystemPath(_p, _l) ((Callbacks.SetSystemDirFn != NULL) ? \
                                      Callbacks.SetSystemDirFn(Callbacks.Context, _p, _l) : 0)

#define IMirrorFileCreate(_f, _a, _e) ((Callbacks.FileCreateFn != NULL) ? \
                                      Callbacks.FileCreateFn(Callbacks.Context, _f, _a, _e) : 0)

#define IMirrorRegSaveError(_p, _s) ((Callbacks.RegSaveErrorFn != NULL) ? \
                                      Callbacks.RegSaveErrorFn(Callbacks.Context, _p, _s) : 0)

#define IMirrorReinit() ((Callbacks.ReinitFn != NULL) ? \
                                      Callbacks.ReinitFn(Callbacks.Context) : 0)
//
// To Do item functions
//

NTSTATUS
GetNextToDoItem(
    OUT PIMIRROR_TODO Item,
    OUT PVOID *Buffer,
    OUT PULONG Length
    );

NTSTATUS
AddToDoItem(
    IN IMIRROR_TODO Item,
    IN PVOID Buffer,
    IN ULONG Length
    );

NTSTATUS
ModifyToDoItem(
    IN IMIRROR_TODO Item,
    IN PVOID Buffer,
    IN ULONG Length
    );

NTSTATUS
CopyToDoItemParameters(
    IN IMIRROR_TODO Item,
    OUT PVOID Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
WriteMirrorConfigFile(
    PWCHAR DestFile
    );

NTSTATUS
SaveBootSector(
    DWORD DiskNumber,
    DWORD PartitionNumber,
    DWORD BlockSize,
    PWCHAR DestFile
    );

extern WCHAR pConfigPath[MAX_PATH];
extern WCHAR pSystemPath[MAX_PATH];
extern WCHAR pCSDVersion[128];
extern WCHAR pProcessorArchitecture[64];
extern WCHAR pCurrentType[128];
extern WCHAR pHalName[128];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\imirror\ckmach.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ckmach.c

Abstract:

    This is for supporting checking a machine to see if it can be converted to IntelliMirror.

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop
#include <ntverp.h>

PMIRROR_CFG_INFO GlobalMirrorCfgInfo = NULL;


//
// Support functions to do individual tasks
//
NTSTATUS
AddCheckMachineToDoItems(
    VOID
    )

/*++

Routine Description:

    This routine adds all the to do items necessary for checking out the local machine for
    conversion.

Arguments:

    None

Return Value:

    STATUS_SUCCESS if it completes adding all the to do items properly.

--*/

{
    NTSTATUS Status;

    Status = AddToDoItem(VerifySystemIsNt5, NULL, 0);

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, IMirrorInitialize);
        return Status;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
CheckIfNt5(
    IN PVOID pBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine verifies that the current system is NT5 workstation, x86

Arguments:

    pBuffer - Pointer to any arguments passed in the to do item.

    Length - Length, in bytes of the arguments.

Return Value:

    STATUS_SUCCESS if it completes adding all the to do items properly.

--*/

{
    OSVERSIONINFO OsVersion;
    DWORD productVersion[] = { VER_PRODUCTVERSION };

    IMirrorNowDoing(VerifySystemIsNt5, NULL);

    RtlZeroMemory(&OsVersion, sizeof(OSVERSIONINFO));
    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!GetVersionEx(&OsVersion)) {
        IMirrorHandleError(GetLastError(), VerifySystemIsNt5);
        return GetLastError();
    }

    if (OsVersion.dwPlatformId != VER_PLATFORM_WIN32_NT) {
        IMirrorHandleError(ERROR_OLD_WIN_VERSION, VerifySystemIsNt5);
        return ERROR_OLD_WIN_VERSION;
    }

    if (OsVersion.dwMajorVersion != productVersion[0]) {
        IMirrorHandleError(ERROR_OLD_WIN_VERSION, VerifySystemIsNt5);
        return ERROR_OLD_WIN_VERSION;
    }

    //
    //  We're changing the format of the alternate data stream.  As such,
    //  we're introducing an incompatiblility.  We'll pick this up here and
    //  return to riprep.exe the error.  Otherwise the user doesn't find out
    //  about it until text mode setup on restoring the image.
    //
    //  The NT build number that this is getting checked into is 2080.
    //

    if (OsVersion.dwBuildNumber < 2080) {

        DbgPrint("build number is %u\n", OsVersion.dwBuildNumber);
        IMirrorHandleError(ERROR_OLD_WIN_VERSION, VerifySystemIsNt5);
        return ERROR_OLD_WIN_VERSION;
    }
    return STATUS_SUCCESS;
}

BOOLEAN
ReadRegistryString(
    IN PWCHAR KeyName,
    IN PWCHAR ValueName,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine reads a string from the registry into Buffer.

Arguments:

    KeyName - The registry key.

    ValueName - The value under that key to read, or NULL if the name of
        the first key under that key is to be read.

    Buffer - The buffer to hold the result.

    BufferLength - The length of Buffer.

Return Value:

    TRUE if success, FALSE if any errors occur.

--*/

{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_PARTIAL_INFORMATION pValueInfo = NULL;
    PKEY_BASIC_INFORMATION pKeyInfo = NULL;
    HANDLE Handle = NULL;
    ULONG ByteCount;
    ULONG BytesLeft;
    PBYTE pBuffer;
    NTSTATUS Status;
    PVOID ResultData;
    ULONG ResultDataLength;
    BOOLEAN ReturnValue = FALSE;

    //
    //
    // Open the key.
    //
    //
    RtlInitUnicodeString(&UnicodeString, KeyName);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = NtOpenKey(&Handle,
                       KEY_ALL_ACCESS,
                       &ObjectAttributes
                      );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    if (ValueName != NULL) {

        RtlInitUnicodeString(&UnicodeString, ValueName);

        //
        // Get the size of the buffer needed
        //
        ByteCount = 0;
        Status = NtQueryValueKey(Handle,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 NULL,
                                 0,
                                 &ByteCount
                                );

        if (Status != STATUS_BUFFER_TOO_SMALL) {
            goto Cleanup;
        }

        pValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)IMirrorAllocMem(ByteCount);

        if (pValueInfo == NULL) {
            goto Cleanup;
        }

        //
        // Get the buffer from the registry
        //
        Status = NtQueryValueKey(Handle,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 pValueInfo,
                                 ByteCount,
                                 &ByteCount
                                );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        if (pValueInfo->Type != REG_SZ) {
            goto Cleanup;
        }

        ResultData = pValueInfo->Data;
        ResultDataLength = pValueInfo->DataLength;

    } else {

        //
        // Get the size of the buffer needed
        //
        ByteCount = 0;
        Status = NtEnumerateKey(Handle,
                                0,
                                KeyBasicInformation,
                                NULL,
                                0,
                                &ByteCount
                               );

        if (Status != STATUS_BUFFER_TOO_SMALL) {
            goto Cleanup;
        }

        pKeyInfo = (PKEY_BASIC_INFORMATION)IMirrorAllocMem(ByteCount);

        if (pKeyInfo == NULL) {
            goto Cleanup;
        }

        //
        // Get the name from the registry
        //
        Status = NtEnumerateKey(Handle,
                                0,
                                KeyBasicInformation,
                                pKeyInfo,
                                ByteCount,
                                &ByteCount
                               );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        ResultData = pKeyInfo->Name;
        ResultDataLength = pKeyInfo->NameLength;

    }

    if (ResultDataLength > BufferLength) {
        goto Cleanup;
    }

    memcpy(Buffer, ResultData, ResultDataLength);

    //
    // NULL-terminate it just in case, if there is room.
    //

    if (ResultDataLength <= BufferLength - sizeof(WCHAR)) {
        ((PWCHAR)Buffer)[ResultDataLength / sizeof(WCHAR)] = L'\0';
    }


    ReturnValue = TRUE;

Cleanup:

    if (pValueInfo != NULL) {
        IMirrorFreeMem(pValueInfo);
    }

    if (pKeyInfo != NULL) {
        IMirrorFreeMem(pKeyInfo);
    }

    if (Handle != NULL) {
        NtClose(Handle);
    }

    return ReturnValue;
}

NTSTATUS
CheckForPartitions(
    IN PVOID pBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine enumerates all partitions and formats the GlobalMirrorCfgInfo
    global structure.

    It also fills in the pConfigPath.

Arguments:

    pBuffer - Pointer to any arguments passed in the to do item.

    Length - Length, in bytes of the arguments.

Return Value:

    STATUS_SUCCESS if it completes adding all the to do items properly.

--*/

{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    PARTITION_INFORMATION_EX PartitionInfoEx;
    PARTITION_INFORMATION PartitionInfo;
    HANDLE Handle;
    ULONG MirrorNumber;
    ULONG DiskNumber;
    ULONG PartitionNumber;
    PULONG pTmpUlong;
    NTSTATUS Status;
    BOOLEAN foundBoot = FALSE;
    BOOLEAN foundSystem = FALSE;
    FILE_FS_SIZE_INFORMATION SizeInfo;
    LARGE_INTEGER UsedSpace;
    LARGE_INTEGER FreeSpace;
    ON_DISK_MBR OnDiskMbr;
    PUCHAR AlignedBuffer;
    UINT previousMode;

    HANDLE DosDevicesDir;
    ULONG Context;
    WCHAR SystemDriveLetter;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    ULONG dosLength;
    BOOLEAN RestartScan;
    PMIRROR_VOLUME_INFO mirrorVolInfo;
    ULONG diskSignature;
    DWORD fileSystemFlags;
    WCHAR fileSystemName[16];
    WCHAR volumeLabel[33];
    ULONG volumeLabelLength;
    WCHAR arcName[MAX_PATH];
    ULONG ntNameLength;
    ULONG arcNameLength;
    OSVERSIONINFO osVersionInfo;
    SYSTEM_INFO systemInfo;
    DWORD fileVersionInfoSize;
    DWORD versionHandle;
    PVOID versionInfo;
    VS_FIXEDFILEINFO * fixedFileInfo;
    UINT fixedFileInfoLength;
    WCHAR kernelPath[MAX_PATH];
    PWCHAR kernelPathPart;
    WCHAR versionString[64];
    BOOL b;
#ifndef IMIRROR_NO_TESTING_LIMITATIONS
    ULONG numberOfDrives = 0;
#endif
    BOOLEAN isDynamic = FALSE;
    BOOLEAN UsePartitionInfoEx = TRUE;

    IMirrorNowDoing(CheckPartitions, NULL);

    if (GlobalMirrorCfgInfo) {

        return STATUS_SUCCESS;
    }

    GlobalMirrorCfgInfo = IMirrorAllocMem(sizeof(MIRROR_CFG_INFO));

    if (GlobalMirrorCfgInfo == NULL) {
        Status = STATUS_NO_MEMORY;
        IMirrorHandleError(Status, CheckPartitions);
        return Status;
    }

    //
    // Disable hard error popups for this thread.
    //

    previousMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    GlobalMirrorCfgInfo->MirrorVersion = IMIRROR_CURRENT_VERSION;
    GlobalMirrorCfgInfo->FileLength = 0;
    GlobalMirrorCfgInfo->SystemPath = NULL;
    GlobalMirrorCfgInfo->SysPrepImage = TRUE;  
    GlobalMirrorCfgInfo->NumberVolumes = 0;

    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osVersionInfo)) {
        GlobalMirrorCfgInfo->MajorVersion = osVersionInfo.dwMajorVersion;
        GlobalMirrorCfgInfo->MinorVersion = osVersionInfo.dwMinorVersion;
        GlobalMirrorCfgInfo->BuildNumber = osVersionInfo.dwBuildNumber;
        lstrcpyW(pCSDVersion, osVersionInfo.szCSDVersion);
        GlobalMirrorCfgInfo->CSDVersion = pCSDVersion;
    }

    if (SearchPath(
            NULL,
            L"ntoskrnl.exe",
            NULL,
            MAX_PATH,
            kernelPath,
            &kernelPathPart)) {
        fileVersionInfoSize = GetFileVersionInfoSize(kernelPath, &versionHandle);
        if (fileVersionInfoSize != 0) {
            versionInfo = IMirrorAllocMem(fileVersionInfoSize);
            if (versionInfo != NULL) {
                if (GetFileVersionInfo(
                        kernelPath,
                        versionHandle,
                        fileVersionInfoSize,
                        versionInfo)) {
                    if (VerQueryValue(
                            versionInfo,
                            L"\\",
                            &fixedFileInfo,
                            &fixedFileInfoLength)) {
                        GlobalMirrorCfgInfo->KernelFileVersionMS = fixedFileInfo->dwFileVersionMS;
                        GlobalMirrorCfgInfo->KernelFileVersionLS = fixedFileInfo->dwFileVersionLS;
                        GlobalMirrorCfgInfo->KernelFileFlags = fixedFileInfo->dwFileFlags;
                        DbgPrint("MS %lx LS %lx flags %lx\n",
                            GlobalMirrorCfgInfo->KernelFileVersionMS,
                            GlobalMirrorCfgInfo->KernelFileVersionLS,
                            GlobalMirrorCfgInfo->KernelFileFlags);
                    }
                }
                IMirrorFreeMem(versionInfo);
            }
        }
    }

    if (GetSystemMetrics(SM_DEBUG)) {
        GlobalMirrorCfgInfo->Debug = TRUE;
    }

    GetSystemInfo(&systemInfo);
    GlobalMirrorCfgInfo->NumberOfProcessors = systemInfo.dwNumberOfProcessors;

    if (ReadRegistryString(
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\Environment",
            L"PROCESSOR_ARCHITECTURE",
            pProcessorArchitecture,
            sizeof(pProcessorArchitecture))) {
        DbgPrint("processor arch is %ws\n", pProcessorArchitecture);
        GlobalMirrorCfgInfo->ProcessorArchitecture = pProcessorArchitecture;
    }

    if (ReadRegistryString(
            L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion",
            L"CurrentType",
            pCurrentType,
            sizeof(pCurrentType))) {
        DbgPrint("current type is %ws\n", pCurrentType);
        GlobalMirrorCfgInfo->CurrentType = pCurrentType;
    }

    if (ReadRegistryString(
            L"\\Registry\\Machine\\Hardware\\RESOURCEMAP\\Hardware Abstraction Layer",
            NULL,
            pHalName,
            sizeof(pHalName))) {
        DbgPrint("HAL name is %ws\n", pHalName);
        GlobalMirrorCfgInfo->HalName = pHalName;
    }

    InitializeListHead( &GlobalMirrorCfgInfo->MirrorVolumeList );

    //
    // Get local system drive letter and \\Systemroot\System32\Config path
    //

    Status = GetBaseDeviceName(L"\\SystemRoot", (PWCHAR)TmpBuffer2, sizeof(TmpBuffer2));

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CheckPartitions);
        goto ExitCheckPartitions;
    }

    Status = NtPathToDosPath(   (PWCHAR) TmpBuffer2,
                                pConfigPath,
                                FALSE,
                                FALSE);

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CheckPartitions);
        goto ExitCheckPartitions;
    }

    ASSERT( pConfigPath[1] == L':' );
    SystemDriveLetter = (WCHAR) pConfigPath[0];

    //
    //  save off the system path so that we can write it out to
    //  the imirror.dat file
    //

    lstrcpyW( pSystemPath, pConfigPath );

    GlobalMirrorCfgInfo->SystemPath = pSystemPath;

    wcscat( pConfigPath, L"\\System32\\Config");

    //
    // Open \DosDevices directory.
    //
    RtlInitUnicodeString(&UnicodeString,L"\\Device");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = NtOpenDirectoryObject(&DosDevicesDir,
                                   DIRECTORY_QUERY,
                                   &ObjectAttributes
                                  );

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, CheckPartitions);
        goto ExitCheckPartitions;
    }

    //
    // Iterate each object in that directory that is a directory.
    //
    Context = 0;
    RestartScan = TRUE;

    Status = NtQueryDirectoryObject(DosDevicesDir,
                                    TmpBuffer,
                                    sizeof(TmpBuffer),
                                    TRUE,
                                    RestartScan,
                                    &Context,
                                    &dosLength
                                   );

    RestartScan = FALSE;
    DirInfo = (POBJECT_DIRECTORY_INFORMATION)TmpBuffer;
    MirrorNumber = 1;

    while (NT_SUCCESS(Status)) {

        DirInfo->Name.Buffer[DirInfo->Name.Length/sizeof(WCHAR)] = 0;
        DirInfo->TypeName.Buffer[DirInfo->TypeName.Length/sizeof(WCHAR)] = 0;

        //
        // Skip this entry if it's not a "HardDiskN"
        //

        if ((DirInfo->Name.Length > (sizeof(L"Harddisk")-sizeof(WCHAR))) &&
            (!wcsncmp(DirInfo->Name.Buffer,L"Harddisk",(sizeof(L"Harddisk")/sizeof(WCHAR))-1)) &&
            !lstrcmpi(DirInfo->TypeName.Buffer, L"Directory")) {

            PWCHAR diskNumberPtr;

            PartitionNumber = 0;
            DiskNumber = 0;

            diskNumberPtr = &DirInfo->Name.Buffer[(sizeof(L"Harddisk")/sizeof(WCHAR))-1];

            while (*diskNumberPtr >= L'0' && *diskNumberPtr <= L'9' ) {

                DiskNumber *= 10;
                DiskNumber += *(diskNumberPtr) - L'0';
                diskNumberPtr++;
            }

            if (*diskNumberPtr != L'\0') {

                //
                //  if the device name wasn't of form HardDiskN, skip this entry.
                //

                goto getNextDevice;
            }

            diskSignature = 0;

            //
            //  get the disk signature, continue if it fails.
            //

            swprintf((PWCHAR)TmpBuffer2, L"\\Device\\Harddisk%d\\Partition0", DiskNumber);

            RtlInitUnicodeString(&UnicodeString, (PWCHAR)TmpBuffer2);

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL
                                      );

            Status = NtCreateFile(&Handle,
                                  (ACCESS_MASK)FILE_GENERIC_READ,
                                  &ObjectAttributes,
                                  &IoStatus,
                                  NULL,
                                  FILE_ATTRIBUTE_NORMAL,
                                  FILE_SHARE_READ,
                                  FILE_OPEN,
                                  FILE_SYNCHRONOUS_IO_NONALERT,
                                  NULL,
                                  0
                                 );

            if (NT_SUCCESS(Status)) {

                ASSERT(sizeof(ON_DISK_MBR) == 512);
                AlignedBuffer = ALIGN(TmpBuffer, 512);

                Status = NtReadFile(Handle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatus,
                                    AlignedBuffer,
                                    sizeof(ON_DISK_MBR),
                                    NULL,
                                    NULL
                                   );

                if (NT_SUCCESS(Status)) {

                    RtlMoveMemory(&OnDiskMbr, AlignedBuffer, sizeof(ON_DISK_MBR));

                    ASSERT(U_USHORT(OnDiskMbr.AA55Signature) == 0xAA55);

                    diskSignature = U_ULONG(OnDiskMbr.NTFTSignature);

                    //
                    //  check to see if this disk is dynamic
                    //

                    if (OnDiskMbr.PartitionTable[0].SystemId == PARTITION_LDM ||
                        OnDiskMbr.PartitionTable[1].SystemId == PARTITION_LDM ||
                        OnDiskMbr.PartitionTable[2].SystemId == PARTITION_LDM ||
                        OnDiskMbr.PartitionTable[3].SystemId == PARTITION_LDM) {

                        isDynamic = TRUE;
                        NtClose(Handle);
                        goto getNextDevice;
                    }
                }
                NtClose(Handle);
            }

            while (1) {

                PartitionNumber++;

                swprintf((PWCHAR)TmpBuffer2, L"\\Device\\Harddisk%d\\Partition%d", DiskNumber, PartitionNumber);

                RtlInitUnicodeString(&UnicodeString, (PWCHAR)TmpBuffer2);

                InitializeObjectAttributes(&ObjectAttributes,
                                           &UnicodeString,
                                           OBJ_CASE_INSENSITIVE,
                                           NULL,
                                           NULL
                                          );

                Status = NtCreateFile(&Handle,
                                      (ACCESS_MASK)FILE_GENERIC_READ,
                                      &ObjectAttributes,
                                      &IoStatus,
                                      NULL,
                                      FILE_ATTRIBUTE_NORMAL,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                      FILE_OPEN,
                                      FILE_SYNCHRONOUS_IO_NONALERT,
                                      NULL,
                                      0
                                     );

                if (!NT_SUCCESS(Status)) {
                    break;      // on to next disk
                }

                Status = NtDeviceIoControlFile(Handle,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &IoStatus,
                                               IOCTL_DISK_GET_PARTITION_INFO_EX,
                                               NULL,
                                               0,
                                               &PartitionInfoEx,
                                               sizeof(PARTITION_INFORMATION_EX) );

                if( (Status == STATUS_NOT_IMPLEMENTED) || (Status == STATUS_INVALID_DEVICE_REQUEST) ) {

                    //
                    // We're on an old build that didn't have this IOCTL.
                    //
                    UsePartitionInfoEx = FALSE;

                    Status = NtDeviceIoControlFile(Handle,
                                                   NULL,
                                                   NULL,
                                                   NULL,
                                                   &IoStatus,
                                                   IOCTL_DISK_GET_PARTITION_INFO,
                                                   NULL,
                                                   0,
                                                   &PartitionInfo,
                                                   sizeof(PARTITION_INFORMATION) );
                }


                if (!NT_SUCCESS(Status)) {
                    NtClose(Handle);
                    continue;   // on to next partition
                }

                //
                // For Whistler, ignore GPT partitions.
                //

                if( (UsePartitionInfoEx) && (PartitionInfoEx.PartitionStyle != PARTITION_STYLE_MBR) ) {
                    NtClose(Handle);
                    continue;
                }

                Status = NtQueryVolumeInformationFile(Handle,
                                                      &IoStatus,
                                                      &SizeInfo,
                                                      sizeof(SizeInfo),
                                                      FileFsSizeInformation );

                NtClose(Handle);

                if (!NT_SUCCESS(Status)) {
                    continue;   // on to next partition
                }

                Status = NtPathToDosPath(   (PWCHAR) TmpBuffer2,
                                            (PWCHAR) TmpBuffer,
                                            TRUE,
                                            FALSE);

                if (!NT_SUCCESS(Status)) {
                    continue;   // on to next partition
                }

                if ((lstrlenW((PWCHAR) TmpBuffer) == 0) ||
                    *(((PWCHAR)TmpBuffer)+1) != L':') {

                    continue;   // on to next partition
                }

                //
                // Get the ARC name of the partition.
                //

                NtNameToArcName( (PWCHAR) TmpBuffer2,
                                 (PWCHAR) arcName,
                                 FALSE);

                //
                // Get the file system type. We add a \ to the end
                // of TmpBuffer if there isn't one.
                //

                if (((PWCHAR)TmpBuffer)[lstrlenW((PWCHAR)TmpBuffer) - 1] != L'\\') {
                    wcscat((PWCHAR)TmpBuffer, L"\\");
                }

                b = GetVolumeInformationW(
                        (PWCHAR) TmpBuffer,
                        volumeLabel,
                        ARRAYSIZE(volumeLabel),
                        NULL,      // no volume serial number requested
                        NULL,      // no maximum name length requested
                        &fileSystemFlags,
                        fileSystemName,
                        ARRAYSIZE(fileSystemName));

                if (!b) {
                    continue;
                }

                //
                // Calculate the amount of free space on the drive.
                //
                FreeSpace = RtlExtendedIntegerMultiply(
                                SizeInfo.AvailableAllocationUnits,
                                SizeInfo.SectorsPerAllocationUnit * SizeInfo.BytesPerSector
                                );

                UsedSpace = RtlExtendedIntegerMultiply(
                                SizeInfo.TotalAllocationUnits,
                                SizeInfo.SectorsPerAllocationUnit * SizeInfo.BytesPerSector
                                );

                UsedSpace = RtlLargeIntegerSubtract(
                                UsedSpace,
                                FreeSpace
                                );

#ifndef IMIRROR_NO_TESTING_LIMITATIONS

                numberOfDrives++;

                //
                //  for NT 5.0, the test group doesn't want to test more than a single
                //  partition.  Now that the test team is dictating what the feature set
                //  is, we'll return an error if we have more than a single partition or
                //  disk.
                //

                if ( (UsePartitionInfoEx  && !PartitionInfoEx.Mbr.BootIndicator) ||
                     (!UsePartitionInfoEx && !PartitionInfo.BootIndicator)) {

                    if (*(PWCHAR)TmpBuffer == SystemDriveLetter) {

                        IMirrorHandleError(STATUS_MISSING_SYSTEMFILE, CheckPartitions);
                        NtClose(DosDevicesDir);
                        Status = STATUS_MISSING_SYSTEMFILE;
                        goto ExitCheckPartitions;
                    }
                    continue;
                }

                if (*(PWCHAR)TmpBuffer != SystemDriveLetter) {

                    // if another drive is marked bootable but it isn't the
                    // system drive, we'll ignore it.  We'll pick up the
                    // error down below if this is the only bootable drive.
#if 0
                    if ( (UsePartitionInfoEx  && PartitionInfoEx.Mbr.BootIndicator) ||
                         (!UsePartitionInfoEx && PartitionInfo.BootIndicator)) {

                        IMirrorHandleError(STATUS_MISSING_SYSTEMFILE, CheckPartitions);
                        NtClose(DosDevicesDir);
                        Status = STATUS_MISSING_SYSTEMFILE;
                        goto ExitCheckPartitions;
                    }
#endif
                    continue;
                }
#endif
                mirrorVolInfo = IMirrorAllocMem(sizeof(MIRROR_VOLUME_INFO));

                if (mirrorVolInfo == NULL) {
                    NtClose(DosDevicesDir);
                    Status = STATUS_NO_MEMORY;
                    IMirrorHandleError(Status, CheckPartitions);
                    goto ExitCheckPartitions;
                }

                //
                // Save the NT and ARC device names.
                //

                ntNameLength = (lstrlenW( (PWCHAR)TmpBuffer2 ) + 1) * sizeof(WCHAR);

                mirrorVolInfo->NtName = IMirrorAllocMem(ntNameLength);

                if (mirrorVolInfo->NtName == NULL) {

                    Status = STATUS_NO_MEMORY;
                    IMirrorHandleError(Status, CheckPartitions);
                    NtClose(DosDevicesDir);
                    goto ExitCheckPartitions;
                }

                arcNameLength = (lstrlenW( (PWCHAR)arcName ) + 1) * sizeof(WCHAR);

                mirrorVolInfo->ArcName = IMirrorAllocMem(arcNameLength);

                if (mirrorVolInfo->ArcName == NULL) {

                    Status = STATUS_NO_MEMORY;
                    IMirrorHandleError(Status, CheckPartitions);
                    NtClose(DosDevicesDir);
                    goto ExitCheckPartitions;
                }

                memcpy(mirrorVolInfo->NtName, TmpBuffer2, ntNameLength);
                memcpy(mirrorVolInfo->ArcName, arcName, arcNameLength);

                mirrorVolInfo->DriveLetter = *(PWCHAR)TmpBuffer;
                mirrorVolInfo->PartitionType = UsePartitionInfoEx ? PartitionInfoEx.Mbr.PartitionType : PartitionInfo.PartitionType;

                //
                // If this is a non-NTFS volume, check if it is configured
                // for compression
                //
                if ( ((UsePartitionInfoEx  && (PartitionInfoEx.Mbr.PartitionType != PARTITION_IFS)) ||
                      (!UsePartitionInfoEx && (PartitionInfo.PartitionType != PARTITION_IFS))) 
                     &&
                     (fileSystemFlags & FS_VOL_IS_COMPRESSED) ) {

                    mirrorVolInfo->CompressedVolume = TRUE;

                } else {

                    mirrorVolInfo->CompressedVolume = FALSE;
                    
                }

                if ( (UsePartitionInfoEx  && (PartitionInfoEx.Mbr.BootIndicator)) ||
                     (!UsePartitionInfoEx && (PartitionInfo.BootIndicator)) ) {

                    foundBoot = TRUE;
                    mirrorVolInfo->PartitionActive = TRUE;

                } else {

                    mirrorVolInfo->PartitionActive = FALSE;
                }

                if (*(PWCHAR)TmpBuffer == SystemDriveLetter) {

                    foundSystem = TRUE;
                    mirrorVolInfo->IsBootDisk = TRUE;

                } else {

                    mirrorVolInfo->IsBootDisk = FALSE;
                }

                mirrorVolInfo->DiskNumber = DiskNumber;
                mirrorVolInfo->PartitionNumber = PartitionNumber;
                mirrorVolInfo->MirrorTableIndex = MirrorNumber++;
                mirrorVolInfo->MirrorUncPath = NULL;
                mirrorVolInfo->LastUSNMirrored = 0;
                mirrorVolInfo->BlockSize = SizeInfo.BytesPerSector;
                mirrorVolInfo->DiskSignature = diskSignature;
                mirrorVolInfo->FileSystemFlags = fileSystemFlags;
                wcscpy(mirrorVolInfo->FileSystemName, fileSystemName);

                volumeLabelLength = (lstrlenW( (PWCHAR)volumeLabel ) + 1) * sizeof(WCHAR);
                mirrorVolInfo->VolumeLabel = IMirrorAllocMem(volumeLabelLength);
                if (mirrorVolInfo->VolumeLabel == NULL) {
                    Status = STATUS_NO_MEMORY;
                    IMirrorHandleError(Status, CheckPartitions);
                    NtClose(DosDevicesDir);
                    goto ExitCheckPartitions;
                }
                memcpy(mirrorVolInfo->VolumeLabel, volumeLabel, volumeLabelLength);

                mirrorVolInfo->StartingOffset = UsePartitionInfoEx ? PartitionInfoEx.StartingOffset : PartitionInfo.StartingOffset;
                mirrorVolInfo->PartitionSize  = UsePartitionInfoEx ? PartitionInfoEx.PartitionLength : PartitionInfo.PartitionLength;
                mirrorVolInfo->DiskSpaceUsed = UsedSpace;

                InsertTailList( &GlobalMirrorCfgInfo->MirrorVolumeList,
                                &mirrorVolInfo->ListEntry );

                GlobalMirrorCfgInfo->NumberVolumes = MirrorNumber - 1;
            }
        }
        //
        // Go on to next object.
        //
getNextDevice:
        Status = NtQueryDirectoryObject(
                    DosDevicesDir,
                    TmpBuffer,
                    sizeof(TmpBuffer),
                    TRUE,
                    RestartScan,
                    &Context,
                    &dosLength
                    );
    }

    NtClose(DosDevicesDir);

    if ((!foundBoot) || (!foundSystem) ) {

        Status = (isDynamic ? STATUS_OBJECT_TYPE_MISMATCH : STATUS_MISSING_SYSTEMFILE);
        IMirrorHandleError(Status, CheckPartitions);
        goto ExitCheckPartitions;
    }
#ifndef IMIRROR_NO_TESTING_LIMITATIONS
    if (numberOfDrives > 1) {
        IMirrorHandleError(ERROR_INVALID_DRIVE, CheckPartitions);
        Status = ERROR_INVALID_DRIVE;
    } else {
        Status = STATUS_SUCCESS;
    }
#else
    Status = STATUS_SUCCESS;
#endif

ExitCheckPartitions:

    SetErrorMode( previousMode );
    return Status;
}

NTSTATUS
NtPathToDosPath(
    IN PWSTR NtPath,
    OUT PWSTR DosPath,
    IN BOOLEAN GetDriveOnly,
    IN BOOLEAN NtPathIsBasic
    )

/*++

Routine Description:

    This routine calls off to convert a \Device\HarddiskX\PartitionY\<path> to Z:\<path>

Arguments:

    NtPath - Something like \Device\Harddisk0\Partition2\WINNT

    DosPath - Will be something like D: or D:\WINNT, depending on flag below.

    GetDriveOnly - TRUE if the caller only wants the DOS drive.

    NtPathIsBasic - TRUE if NtPath is not symbolic link.

Return Value:

    STATUS_SUCCESS if it completes filling in DosDrive, else an appropriate error code.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    HANDLE DosDevicesDir;
    HANDLE DosDevicesObj;
    HANDLE ObjectHandle;
    ULONG Context;
    ULONG Length;
    BOOLEAN RestartScan;
    WCHAR LinkTarget[2*MAX_PATH];
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    WCHAR LocalBuffer[MAX_PATH];
    WCHAR LocalBuffer2[MAX_PATH];
    PWCHAR pTmp;
    PWCHAR NameSpace[] = { L"\\??", L"\\GLOBAL??" };
    UINT i;
    
    if (NtPath == NULL) {
        return ERROR_PATH_NOT_FOUND;
    }

    if (!NtPathIsBasic) {

        //
        // Find the end of the \device\harddiskX\partitionY string
        //
        wcscpy(LocalBuffer2, NtPath);
        pTmp = LocalBuffer2;
        if (*pTmp != L'\\') {
            return ERROR_PATH_NOT_FOUND;
        }

        pTmp = wcsstr(pTmp + 1, L"\\");

        if (pTmp == NULL) {
            return ERROR_PATH_NOT_FOUND;
        }

        pTmp = wcsstr(pTmp + 1, L"\\");

        if (pTmp == NULL) {
            return ERROR_PATH_NOT_FOUND;
        }

        pTmp = wcsstr(pTmp + 1, L"\\");

        if (pTmp != NULL) {
            *pTmp = UNICODE_NULL;
            pTmp++;
        }

        //
        // Find the base NT device name
        //
        Status = GetBaseDeviceName(LocalBuffer2, LocalBuffer, sizeof(LocalBuffer));

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

    } else {

        wcscpy(LocalBuffer, NtPath);
        pTmp = NULL;

    }

    //
    // Open \DosDevices directory.  First try the "normal" dosdevices path, 
    // then try the global dosdevices path.
    //
    for (i = 0; i < sizeof(NameSpace)/sizeof(PWCHAR *); i++) {
        
        RtlInitUnicodeString(&UnicodeString,NameSpace[i]);
    
        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );
    
        Status = NtOpenDirectoryObject(&DosDevicesDir,
                                       DIRECTORY_QUERY,
                                       &ObjectAttributes
                                      );
    
        if (!NT_SUCCESS(Status)) {
            DosDevicesDir = NULL;   
        } else {
        
    
            //
            // Iterate each object in that directory.
            //
            Context = 0;
            RestartScan = TRUE;
        
            Status = NtQueryDirectoryObject(DosDevicesDir,
                                            TmpBuffer3,
                                            sizeof(TmpBuffer3),
                                            TRUE,
                                            RestartScan,
                                            &Context,
                                            &Length
                                           );
        
            RestartScan = FALSE;
            DirInfo = (POBJECT_DIRECTORY_INFORMATION)TmpBuffer3;
        
            while (NT_SUCCESS(Status)) {
        
                DirInfo->Name.Buffer[DirInfo->Name.Length/sizeof(WCHAR)] = 0;
                DirInfo->TypeName.Buffer[DirInfo->TypeName.Length/sizeof(WCHAR)] = 0;
        
                //
                // Skip this entry if it's not a symbolic link.
                //
                if ((DirInfo->Name.Length != 0) &&
                    (DirInfo->Name.Buffer[1] == L':') &&
                    !lstrcmpi(DirInfo->TypeName.Buffer, L"SymbolicLink")) {
        
                    //
                    // Get this \DosDevices object's link target.
                    //
                    swprintf(LocalBuffer2, L"%ws\\%ws", NameSpace[i], DirInfo->Name.Buffer);
        
                    Status = GetBaseDeviceName(LocalBuffer2, LinkTarget, sizeof(LinkTarget));
        
                    if (NT_SUCCESS(Status)) {
        
                        //
                        // See if it's a prefix of the path we're converting,
                        //
                        if(!_wcsnicmp(LocalBuffer, LinkTarget, wcslen(LinkTarget))) {
        
                            //
                            // Got a match.
                            //
                            lstrcpy(DosPath, DirInfo->Name.Buffer);
        
                            if (!GetDriveOnly) {
        
                                if (NtPathIsBasic) {
        
                                    lstrcat(DosPath, LocalBuffer + wcslen(LinkTarget));
        
                                } else if (pTmp != NULL) {
        
                                    lstrcat(DosPath, L"\\");
                                    lstrcat(DosPath, pTmp);
        
                                }
        
                            }
        
                            NtClose(DosDevicesDir);
                            return(STATUS_SUCCESS);
                        }
                    }
                }

                //
                // Go on to next object.
                //
                Status = NtQueryDirectoryObject(
                            DosDevicesDir,
                            TmpBuffer3,
                            sizeof(TmpBuffer3),
                            TRUE,
                            RestartScan,
                            &Context,
                            &Length
                            );
            
            }
    
            NtClose(DosDevicesDir);
    
        }

    }

    return(Status);

}

NTSTATUS
NtNameToArcName(
    IN PWSTR NtName,
    OUT PWSTR ArcName,
    IN BOOLEAN NtNameIsBasic
    )

/*++

Routine Description:

    This routine calls off to convert a \Device\HarddiskX\PartitionY to
    the ARC name.

Arguments:

    NtPath - Something like \Device\Harddisk0\Partition2

    DosPath - Will be something like \Arcname\multi(0)disk(0)rdisk(0)partition(1).

    NtNameIsBasic - TRUE if NtName is not symbolic link.

Return Value:

    STATUS_SUCCESS if it completes filling in ArcName, else an appropriate error code.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    HANDLE DosDevicesDir;
    HANDLE DosDevicesObj;
    HANDLE ObjectHandle;
    ULONG Context;
    ULONG Length;
    BOOLEAN RestartScan;
    WCHAR LinkTarget[2*MAX_PATH];
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    WCHAR LocalBuffer[MAX_PATH];
    WCHAR LocalBuffer2[MAX_PATH];
    PWCHAR pTmp;

    if (!NtNameIsBasic) {

        //
        // Find the base NT device name
        //
        Status = GetBaseDeviceName(NtName, LocalBuffer, sizeof(LocalBuffer));

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

    } else {

        wcscpy(LocalBuffer, NtName);

    }

    //
    // Open \ArcName directory.
    //
    RtlInitUnicodeString(&UnicodeString,L"\\ArcName");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = NtOpenDirectoryObject(&DosDevicesDir,
                                   DIRECTORY_QUERY,
                                   &ObjectAttributes
                                  );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Iterate each object in that directory.
    //
    Context = 0;
    RestartScan = TRUE;

    Status = NtQueryDirectoryObject(DosDevicesDir,
                                    TmpBuffer3,
                                    sizeof(TmpBuffer3),
                                    TRUE,
                                    RestartScan,
                                    &Context,
                                    &Length
                                   );

    RestartScan = FALSE;
    DirInfo = (POBJECT_DIRECTORY_INFORMATION)TmpBuffer3;

    while (NT_SUCCESS(Status)) {

        DirInfo->Name.Buffer[DirInfo->Name.Length/sizeof(WCHAR)] = 0;
        DirInfo->TypeName.Buffer[DirInfo->TypeName.Length/sizeof(WCHAR)] = 0;

        //
        // Skip this entry if it's not a symbolic link.
        //
        if ((DirInfo->Name.Length != 0) &&
            !lstrcmpi(DirInfo->TypeName.Buffer, L"SymbolicLink")) {

            //
            // Get this \DosDevices object's link target.
            //
            swprintf(LocalBuffer2, L"\\ArcName\\%ws", DirInfo->Name.Buffer);

            Status = GetBaseDeviceName(LocalBuffer2, LinkTarget, sizeof(LinkTarget));

            if (NT_SUCCESS(Status)) {

                //
                // See if the base name of this link matches the base
                // name of what we are looking for.
                //

                if(!_wcsnicmp(LocalBuffer, LinkTarget, wcslen(LinkTarget))) {

                    //
                    // Got a match.
                    //
                    lstrcpy(ArcName, DirInfo->Name.Buffer);

                    NtClose(DosDevicesDir);
                    return STATUS_SUCCESS;
                }
            }
        }

        //
        // Go on to next object.
        //
        Status = NtQueryDirectoryObject(
                    DosDevicesDir,
                    TmpBuffer3,
                    sizeof(TmpBuffer3),
                    TRUE,
                    RestartScan,
                    &Context,
                    &Length
                    );
    }

    NtClose(DosDevicesDir);
    return Status;
}

NTSTATUS
GetBaseDeviceName(
    IN PWSTR SymbolicName,
    OUT PWSTR Buffer,
    IN ULONG Size
    )

/*++

Routine Description:

    This routine drills down thru symbolic links until it finds the base device name.

Arguments:

    SymbolicName - The name to start with.

    Buffer - The output buffer.

    Size - Length, in bytes of Buffer

Return Value:

    STATUS_SUCCESS if it completes adding all the to do items properly.

--*/

{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle;
    NTSTATUS Status;

    //
    // Start at the first name
    //
    RtlInitUnicodeString(&UnicodeString, SymbolicName);

    InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,
       OBJ_CASE_INSENSITIVE,
       NULL,
       NULL
       );

    Status = NtOpenSymbolicLinkObject(&Handle,
                                      (ACCESS_MASK)SYMBOLIC_LINK_QUERY,
                                      &ObjectAttributes
                                     );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    while (TRUE) {

        //
        // Take this open and get the next name
        //
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = (USHORT)Size;
        UnicodeString.Buffer = (PWCHAR)Buffer;
        Status = NtQuerySymbolicLinkObject(Handle,
                                           &UnicodeString,
                                           NULL
                                          );

        NtClose(Handle);

        Buffer[(UnicodeString.Length / sizeof(WCHAR))] = UNICODE_NULL;

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // See if the next name is also a symbolic name
        //

        RtlInitUnicodeString(&UnicodeString, Buffer);

        InitializeObjectAttributes(
           &ObjectAttributes,
           &UnicodeString,
           OBJ_CASE_INSENSITIVE,
           NULL,
           NULL
           );

        Status = NtOpenSymbolicLinkObject(&Handle,
                                          (ACCESS_MASK)SYMBOLIC_LINK_QUERY,
                                          &ObjectAttributes
                                         );

        if (!NT_SUCCESS(Status)) {
            return STATUS_SUCCESS;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\imirror\precomp.h ===
#define SECURITY_WIN32

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>

#include <winldap.h>
#include <dsgetdc.h>
#include <sspi.h>
#include <secext.h>

#include <ntdddisk.h>

#include <aclapi.h>
#include <remboot.h>

#include "imirror.h"
#include "ckmach.h"
#include "copy.h"
#include "mirror.h"
#include "regtool.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\imirror\regtool.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    regtool.h

Abstract:

    This is the include file for the REGTOOL.DLL registry helper.

Author:

    Steve Wood (stevewo) 16-Nov-1995

Revision History:

--*/

//
// Routines for accessing registry.  Allows code to access any of the following
// registry locations with the same code:
//
//      Windows NT registry on local machine
//      Windows NT registry on remote machine
//      Windows NT hive files
//

#define REG_TARGET_DISCONNECTED    0
#define REG_TARGET_LOCAL_REGISTRY  1
#define REG_TARGET_REMOTE_REGISTRY 2
#define REG_TARGET_HIVE_REGISTRY   4

typedef struct _REG_CONTEXT_OPEN_HIVE_KEY {
    struct _REG_CONTEXT_OPEN_HIVE_KEY *Next;
    HKEY KeyHandle;
    ULONG ReferenceCount;
} REG_CONTEXT_OPEN_HIVE_KEY, *PREG_CONTEXT_OPEN_HIVE_KEY;

typedef struct _REG_CONTEXT {
    struct _REG_CONTEXT *Next;
    ULONG Target;
    HKEY MachineRoot;
    HKEY UsersRoot;
    HKEY CurrentUserRoot;
    WCHAR MachinePath[ MAX_PATH ];
    WCHAR UsersPath[ MAX_PATH ];
    WCHAR CurrentUserPath[ MAX_PATH ];
    ULONG MachinePathLength;
    ULONG UsersPathLength;
    ULONG CurrentUserPathLength;
    HKEY HiveRootHandle;
    OBJECT_ATTRIBUTES HiveRootKey;
    PREG_CONTEXT_OPEN_HIVE_KEY OpenHiveKeys;
} REG_CONTEXT, *PREG_CONTEXT;


BOOLEAN
RTEnableBackupRestorePrivilege( void );

void
RTDisableBackupRestorePrivilege( void );

LONG
RTConnectToRegistry(
    IN PWSTR MachineName,
    IN PWSTR HiveFileName,
    IN PWSTR HiveRootName,
    OUT PWSTR *DefaultRootKeyName,
    OUT PREG_CONTEXT RegistryContext
    );

LONG
RTDisconnectFromRegistry(
    IN PREG_CONTEXT RegistryContext
    );

LONG
RTCreateKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateOptions,
    IN PVOID SecurityDescriptor,
    OUT PHKEY ReturnedKeyHandle,
    OUT PULONG Disposition
    );


LONG
RTOpenKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG OpenOptions,
    OUT PHKEY ReturnedKeyHandle
    );

#define HKEY_REGISTRY_ROOT          (( HKEY ) (ULONG_PTR)((LONG)0x8000000A) )

LONG
RTCloseKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    );

LONG
RTEnumerateValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN ULONG Index,
    OUT PULONG ValueType,
    IN OUT PULONG ValueNameLength,
    OUT PWSTR ValueName,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    );


LONG
RTQueryValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PWSTR ValueName,
    OUT PULONG ValueType,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\imirror\regtool.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regtool.c

Abstract:

    This file contains functions for supporting the registry tools
    REGINI, REGDMP, REGDIR and REGFIND

Author:

    Steve Wood (stevewo) 15-Nov-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

LONG
RegLoadHive(
    IN PREG_CONTEXT RegistryContext,
    IN PWSTR HiveFileName,
    IN PWSTR HiveRootName
    );

void
RegUnloadHive(
    IN PREG_CONTEXT RegistryContext
    );

BOOLEAN PrivilegeEnabled;
BOOLEAN RestoreWasEnabled;
BOOLEAN BackupWasEnabled;

BOOLEAN
RTEnableBackupRestorePrivilege( void )
{
    NTSTATUS Status;

    //
    // Try to enable backup and restore privileges
    //
    Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                 TRUE,               // Enable
                                 FALSE,              // Not impersonating
                                 &RestoreWasEnabled  // previous state
                               );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Status = RtlAdjustPrivilege( SE_BACKUP_PRIVILEGE,
                                 TRUE,               // Enable
                                 FALSE,              // Not impersonating
                                 &BackupWasEnabled   // previous state
                               );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    PrivilegeEnabled = TRUE;
    return TRUE;
}


void
RTDisableBackupRestorePrivilege( void )
{
    //
    // Restore privileges to what they were
    //

    RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                        RestoreWasEnabled,
                        FALSE,
                        &RestoreWasEnabled
                      );

    RtlAdjustPrivilege( SE_BACKUP_PRIVILEGE,
                        BackupWasEnabled,
                        FALSE,
                        &BackupWasEnabled
                      );

    PrivilegeEnabled = FALSE;
    return;
}


LONG
RTConnectToRegistry(
    IN PWSTR MachineName,
    IN PWSTR HiveFileName,
    IN PWSTR HiveRootName,
    OUT PWSTR *DefaultRootKeyName,
    OUT PREG_CONTEXT RegistryContext
    )
{
    LONG Error;

    if (MachineName != NULL) {
        if (HiveRootName || HiveFileName ) {
            return ERROR_INVALID_PARAMETER;
            }

        Error = RegConnectRegistry( MachineName, HKEY_LOCAL_MACHINE, (PHKEY)&RegistryContext->MachineRoot );
        if (Error == NO_ERROR) {
            Error = RegConnectRegistry( MachineName, HKEY_USERS, (PHKEY)&RegistryContext->UsersRoot );
            if (Error == NO_ERROR) {
                Error = RegOpenKey( RegistryContext->UsersRoot, L".Default", &RegistryContext->CurrentUserRoot );
                }
            }

        if (Error != NO_ERROR) {
            if (RegistryContext->MachineRoot != NULL) {
                RegCloseKey( RegistryContext->MachineRoot );
                RegistryContext->MachineRoot = NULL;
                }

            if (RegistryContext->UsersRoot != NULL) {
                RegCloseKey( RegistryContext->UsersRoot );
                RegistryContext->UsersRoot = NULL;
                }

            return Error;
            }

        wcscpy( RegistryContext->MachinePath, L"\\Registry\\Machine" );
        wcscpy( RegistryContext->UsersPath, L"\\Registry\\Users" );
        wcscpy( RegistryContext->CurrentUserPath, L"\\Registry\\Users\\.Default" );
        RegistryContext->Target = REG_TARGET_REMOTE_REGISTRY;
        }
    else if (HiveRootName != NULL || HiveFileName != NULL) {
        if (HiveRootName == NULL || HiveFileName == NULL ) {
            return ERROR_INVALID_PARAMETER;
            }

        if (!PrivilegeEnabled && !RTEnableBackupRestorePrivilege()) {
            return ERROR_PRIVILEGE_NOT_HELD;
            }

        RegistryContext->MachineRoot = NULL;
        RegistryContext->UsersRoot = NULL;
        RegistryContext->CurrentUserRoot = NULL;

        Error = RegLoadHive( RegistryContext, HiveFileName, HiveRootName );
        if (Error != NO_ERROR) {
            return Error;
            }

        if (DefaultRootKeyName != NULL && *DefaultRootKeyName == NULL) {
            *DefaultRootKeyName = HiveRootName;
            }
        RegistryContext->Target = REG_TARGET_HIVE_REGISTRY;
        }
    else {
        NTSTATUS Status;
        UNICODE_STRING CurrentUserKeyPath;

        RegistryContext->MachineRoot = HKEY_LOCAL_MACHINE;
        RegistryContext->UsersRoot = HKEY_USERS;
        RegistryContext->CurrentUserRoot = HKEY_CURRENT_USER;

        wcscpy( RegistryContext->MachinePath, L"\\Registry\\Machine" );
        wcscpy( RegistryContext->UsersPath, L"\\Registry\\Users" );
        Status = RtlFormatCurrentUserKeyPath( &CurrentUserKeyPath );
        if (!NT_SUCCESS( Status )) {
            SetLastError( RtlNtStatusToDosError( Status ) );
            return FALSE;
            }

        wcscpy( RegistryContext->CurrentUserPath, CurrentUserKeyPath.Buffer );
        RtlFreeUnicodeString( &CurrentUserKeyPath );

        RegistryContext->Target = REG_TARGET_LOCAL_REGISTRY;
        }

    if (DefaultRootKeyName != NULL && *DefaultRootKeyName == NULL) {
        *DefaultRootKeyName = L"\\Registry";
        }
    RegistryContext->MachinePathLength = wcslen( RegistryContext->MachinePath );
    RegistryContext->UsersPathLength = wcslen( RegistryContext->UsersPath );
    RegistryContext->CurrentUserPathLength = wcslen( RegistryContext->CurrentUserPath );
    return NO_ERROR;
}


LONG
RTDisconnectFromRegistry(
    IN PREG_CONTEXT RegistryContext
    )
{
    switch( RegistryContext->Target ) {
        case REG_TARGET_DISCONNECTED:
            break;

        case REG_TARGET_LOCAL_REGISTRY:
            break;

        case REG_TARGET_REMOTE_REGISTRY:
            break;

        case REG_TARGET_HIVE_REGISTRY:
            RegUnloadHive( RegistryContext );
            break;
        }

    if (PrivilegeEnabled) {
        RTDisableBackupRestorePrivilege();
        }

    RegistryContext->Target = REG_TARGET_DISCONNECTED;
    return NO_ERROR;
}

UNICODE_STRING RegHiveRootName;

LONG
RegLoadHive(
    IN PREG_CONTEXT RegistryContext,
    IN PWSTR HiveFileName,
    IN PWSTR HiveRootName
    )
{
    NTSTATUS Status;
    UNICODE_STRING NtFileName;
    OBJECT_ATTRIBUTES File;

    if (!RtlDosPathNameToNtPathName_U( HiveFileName,
                                       &NtFileName,
                                       NULL,
                                       NULL
                                     )
       ) {
        return ERROR_BAD_PATHNAME;
        }
    InitializeObjectAttributes( &File,
                                &NtFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    RtlInitUnicodeString( &RegHiveRootName, L"\\Registry");
    InitializeObjectAttributes( &RegistryContext->HiveRootKey,
                                &RegHiveRootName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = NtOpenKey( &RegistryContext->HiveRootHandle,
                        MAXIMUM_ALLOWED,
                        &RegistryContext->HiveRootKey
                      );

    RtlFreeHeap(RtlProcessHeap(), 0, NtFileName.Buffer);

    if (!NT_SUCCESS(Status)) {
        return RtlNtStatusToDosError( Status );
        }

    RtlInitUnicodeString( &RegHiveRootName, HiveRootName );
    InitializeObjectAttributes( &RegistryContext->HiveRootKey,
                                &RegHiveRootName,
                                OBJ_CASE_INSENSITIVE,
                                RegistryContext->HiveRootHandle,
                                NULL
                              );
    NtUnloadKey( &RegistryContext->HiveRootKey );
    Status = NtLoadKey( &RegistryContext->HiveRootKey, &File );
    if (!NT_SUCCESS( Status )) {
        return RtlNtStatusToDosError( Status );
        }

    return NO_ERROR;

}

void
RegUnloadHive(
    IN PREG_CONTEXT RegistryContext
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    PREG_CONTEXT_OPEN_HIVE_KEY p, p1;

    Status = NtOpenKey( &Handle,
                        MAXIMUM_ALLOWED,
                        &RegistryContext->HiveRootKey
                      );
    if (NT_SUCCESS( Status )) {
        NtFlushKey( Handle );
        NtClose( Handle );
        }

    p = RegistryContext->OpenHiveKeys;
    while (p) {
        RegCloseKey( p->KeyHandle );
        p1 = p;
        p = p->Next;
        HeapFree( GetProcessHeap(), 0, p1 );
        };

    do {
        Status = NtUnloadKey( &RegistryContext->HiveRootKey );
        }
    while (NT_SUCCESS( Status ) );

    NtClose( RegistryContext->HiveRootHandle );
    return;
}


void
RegRememberOpenKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    )
{
    PREG_CONTEXT_OPEN_HIVE_KEY p, *pp;

    pp = &RegistryContext->OpenHiveKeys;
    while ((p = *pp) != NULL) {
        if (p->KeyHandle == KeyHandle) {
            p->ReferenceCount += 1;
            return;
            }
        else {
            pp = &p->Next;
            }
        }

    p = HeapAlloc( GetProcessHeap(), 0, sizeof( *p ) );
    if (p != NULL) {
        p->KeyHandle = KeyHandle;
        p->ReferenceCount = 1;
        p->Next = NULL;
        *pp = p;
        }

    return;
}


void
RegForgetOpenKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    )
{
    PREG_CONTEXT_OPEN_HIVE_KEY p, *pp;

    pp = &RegistryContext->OpenHiveKeys;
    while ((p = *pp) != NULL) {
        if (p->KeyHandle == KeyHandle) {
            p->ReferenceCount -= 1;
            if (p->ReferenceCount == 0) {
                *pp = p->Next;
                HeapFree( GetProcessHeap(), 0, p );
                return;
                }
            }
        else {
            pp = &p->Next;
            }
        }

    return;
}

BOOLEAN
RegCheckPrefix(
    IN OUT PCWSTR *s,
    IN PCWSTR Prefix,
    IN ULONG PrefixLength
    )
{
    if (PrefixLength == 0) {
        return FALSE;
        }

    if (!_wcsnicmp( *s, Prefix, PrefixLength )) {
        *s += PrefixLength;
        return TRUE;
        }

    return FALSE;
}


BOOLEAN
RegValidateKeyPath(
    IN PREG_CONTEXT RegistryContext,
    IN OUT PHKEY RootKeyHandle,
    IN OUT PCWSTR *SubKeyName
    )
{
    PCWSTR s;

    s = *SubKeyName;
    if (*RootKeyHandle == NULL) {
        if (RegCheckPrefix( &s, L"USER:", 5 ) ||
            RegCheckPrefix( &s, L"HKEY_CURRENT_USER", 17 )
           ) {
            if (RegistryContext->CurrentUserRoot == NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
                }

            if (*s == L'\\') {
                s += 1;
                }
            else
            if (s[-1] != L':' && *s != UNICODE_NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
                }

            *RootKeyHandle = RegistryContext->CurrentUserRoot;
            }
        else
        if (RegCheckPrefix( &s, L"HKEY_LOCAL_MACHINE", 18 )) {
            if (*s == L'\\') {
                s += 1;
                }
            else
            if (*s != UNICODE_NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
                }

            *RootKeyHandle = RegistryContext->MachineRoot;
            }
        else
        if (RegCheckPrefix( &s, L"HKEY_USERS", 10 )) {
            if (*s == L'\\') {
                s += 1;
                }
            else
            if (*s != UNICODE_NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
                }

            *RootKeyHandle = RegistryContext->UsersRoot;
            }
        else
        if (*s != L'\\') {
            SetLastError( ERROR_BAD_PATHNAME );
            return FALSE;
            }
        else
        if (RegCheckPrefix( &s, RegistryContext->MachinePath, RegistryContext->MachinePathLength )) {
            *RootKeyHandle = RegistryContext->MachineRoot;
            if (*s == L'\\') {
                s += 1;
                }
            }
        else
        if (RegCheckPrefix( &s, RegistryContext->UsersPath, RegistryContext->UsersPathLength )) {
            *RootKeyHandle = RegistryContext->UsersRoot;
            if (*s == L'\\') {
                s += 1;
                }
            }
        else
        if (RegCheckPrefix( &s, RegistryContext->CurrentUserPath, RegistryContext->CurrentUserPathLength )) {
            *RootKeyHandle = RegistryContext->CurrentUserRoot;
            if (*s == L'\\') {
                s += 1;
                }
            }
        else
        if (!_wcsicmp( *SubKeyName, L"\\Registry" )) {
            *RootKeyHandle = NULL;
            }
        else {
            SetLastError( ERROR_BAD_PATHNAME );
            return FALSE;
            }
        }
    else
    if (*s == L'\\') {
        SetLastError( ERROR_BAD_PATHNAME );
        return FALSE;
        }

    *SubKeyName = s;
    return TRUE;
}

LONG
RTCreateKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateOptions,
    IN PVOID SecurityDescriptor,
    OUT PHKEY ReturnedKeyHandle,
    OUT PULONG Disposition
    )
{
    LONG Error;
    SECURITY_ATTRIBUTES SecurityAttributes;

    if (!RegValidateKeyPath( RegistryContext, &RootKeyHandle, &SubKeyName )) {
        return GetLastError();
        }

    if (RootKeyHandle == NULL) {
        *Disposition = REG_OPENED_EXISTING_KEY;
        *ReturnedKeyHandle = HKEY_REGISTRY_ROOT;
        return NO_ERROR;
        }
    else
    if (RootKeyHandle == HKEY_REGISTRY_ROOT) {
        *ReturnedKeyHandle = NULL;
        if (!_wcsicmp( SubKeyName, L"Machine" )) {
            *ReturnedKeyHandle = RegistryContext->MachineRoot;
            }
        else
        if (!_wcsicmp( SubKeyName, L"Users" )) {
            *ReturnedKeyHandle = RegistryContext->UsersRoot;
            }


        if (*ReturnedKeyHandle != NULL) {
            return NO_ERROR;
            }
        else {
            return ERROR_PATH_NOT_FOUND;
            }
        }

    SecurityAttributes.nLength = sizeof( SecurityAttributes );
    SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;
    SecurityAttributes.bInheritHandle = FALSE;
    Error = RegCreateKeyEx( RootKeyHandle,
                            SubKeyName,
                            0,
                            NULL,
                            CreateOptions,
                            (REGSAM)DesiredAccess,
                            &SecurityAttributes,
                            ReturnedKeyHandle,
                            Disposition
                          );
    if (Error == NO_ERROR &&
        RegistryContext->Target == REG_TARGET_HIVE_REGISTRY
       ) {
        RegRememberOpenKey( RegistryContext, *ReturnedKeyHandle );
        }

    if (Error == NO_ERROR &&
        *Disposition == REG_OPENED_EXISTING_KEY &&
        SecurityDescriptor != NULL
       ) {
        RegSetKeySecurity( *ReturnedKeyHandle,
                           DACL_SECURITY_INFORMATION,
                           SecurityDescriptor
                         );
        }

    return Error;
}

LONG
RTOpenKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG OpenOptions,
    OUT PHKEY ReturnedKeyHandle
    )
{
    LONG Error;

    if (!RegValidateKeyPath( RegistryContext, &RootKeyHandle, &SubKeyName )) {
        return GetLastError();
        }

    if (RootKeyHandle == NULL) {
        *ReturnedKeyHandle = HKEY_REGISTRY_ROOT;
        return NO_ERROR;
        }
    else
    if (RootKeyHandle == HKEY_REGISTRY_ROOT) {
        *ReturnedKeyHandle = NULL;
        if (!_wcsicmp( SubKeyName, L"Machine" )) {
            *ReturnedKeyHandle = RegistryContext->MachineRoot;
            }
        else
        if (!_wcsicmp( SubKeyName, L"Users" )) {
            *ReturnedKeyHandle = RegistryContext->UsersRoot;
            }

        if (*ReturnedKeyHandle != NULL) {
            return NO_ERROR;
            }
        else {
            return ERROR_PATH_NOT_FOUND;
            }
        }

    Error = RegOpenKeyEx( RootKeyHandle,
                          SubKeyName,
                          OpenOptions,
                          DesiredAccess,
                          ReturnedKeyHandle
                        );
    if (Error == NO_ERROR &&
        RegistryContext->Target == REG_TARGET_HIVE_REGISTRY
       ) {
        RegRememberOpenKey( RegistryContext, *ReturnedKeyHandle );
        }

    return Error;
}

LONG
RTCloseKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    )
{
    LONG Error;

    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        return NO_ERROR;
        }
    else {
        Error = RegCloseKey( KeyHandle );
        if (Error == NO_ERROR &&
            RegistryContext->Target == REG_TARGET_HIVE_REGISTRY
           ) {
            RegForgetOpenKey( RegistryContext, KeyHandle );
            }

        return Error;
        }
}

LONG
RTEnumerateValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN ULONG Index,
    OUT PULONG ValueType,
    IN OUT PULONG ValueNameLength,
    OUT PWSTR ValueName,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    )
{
    ULONG Error;

    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        return ERROR_NO_MORE_ITEMS;
        }
    else {
        Error = RegEnumValue( KeyHandle,
                              Index,
                              ValueName,
                              ValueNameLength,
                              NULL,
                              ValueType,
                              ValueData,
                              ValueDataLength
                            );
        if (Error == NO_ERROR) {
            RtlZeroMemory( (PCHAR)ValueData + *ValueDataLength, 4 - (*ValueDataLength & 3) );
            }

        return Error;
        }
}

LONG
RTQueryValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PWSTR ValueName,
    OUT PULONG ValueType,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    )
{
    LONG Error;

    Error = RegQueryValueEx( KeyHandle,
                             ValueName,
                             NULL,
                             ValueType,
                             ValueData,
                             ValueDataLength
                           );

    if (Error == NO_ERROR) {
        RtlZeroMemory( (PCHAR)ValueData + *ValueDataLength, 4 - (*ValueDataLength & 3) );
        }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\newrb\debug.c ===
/****************************************************************************

  Copyright (c) Microsoft Corporation 1997
  All rights reserved

  File: DEBUG.CPP

  Debugging utilities
 
 ***************************************************************************/

#include "pch.h"

DEFINE_MODULE("Debugging");

#ifdef DEBUG

// Constants
#define DEBUG_OUTPUT_BUFFER_SIZE  512

// Globals
DWORD g_TraceMemoryIndex = 0;
DWORD g_dwCounter        = 0;
DWORD g_dwTraceFlags     = TF_FUNC | TF_CALLS;

// Statics
static const TCHAR g_szNULL[]    = TEXT("");
static const TCHAR g_szTrue[]    = TEXT("True");
static const TCHAR g_szFalse[]   = TEXT("False");
static const TCHAR g_szFormat[]  = TEXT("%-40s  %-10.10s ");
static const TCHAR g_szUnknown[] = TEXT("<unknown>");

//
// Debugging strrchr( )
//
LPCTSTR
dbgstrrchr( LPCTSTR lpsz, char ch )
{
    LPCTSTR psz = lpsz;

    while ( *psz )
        ++psz;

    while ( psz >= lpsz && *psz != ch )
        --psz;

    return psz;

}

//
// Adds 'g_dwCounter' spaces to debug spew
//
void
dbgspace( void )
{
    DWORD dw;
    for( dw = 1; dw < g_dwCounter; dw++ )
        DebugMsg( TEXT("| ") );
}

//
// Takes the filename and line number and put them into a string buffer.
//
// NOTE: the buffer is assumed to be of size DEBUG_OUTPUT_BUFFER_SIZE.
//
LPTSTR
dbgmakefilelinestring( 
    LPTSTR  pszBuf, 
    LPCTSTR pszFile, 
    UINT    uLine )
{
    LPVOID args[2];

    args[0] = (LPVOID) pszFile;
    args[1] = (LPVOID) uLine;

    FormatMessage( 
        FORMAT_MESSAGE_FROM_STRING | 
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
        TEXT("%1(%2!u!):"),
        0,                          // error code
        0,                          // default language
        (LPTSTR) pszBuf,            // output buffer
        DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
        (va_list*) &args );           // arguments

    return pszBuf;
}



//
// TraceMsg()
//
void
TraceMsg( 
    DWORD dwCheckFlags,
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS 
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

        va_start( valist, pszFormat );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );

        OutputDebugString( szBuf );
    }
}

//
// TraceMessage()
//
void
TraceMessage( 
    LPCTSTR pszFile, 
    UINT    uLine, 
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS 
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( !pszModule )
        {
            pszModule = g_szUnknown;
        }

        if ( !pszFile )
        {
            wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
        }
        else
        {
            TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

            dbgmakefilelinestring( szFileLine, pszFile, uLine );
            wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
        }

        OutputDebugString( szBuf );

        dbgspace( );

        va_start( valist, pszFormat );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );

        OutputDebugString( szBuf );
    }

}

//
// DebugMessage()
//
void
DebugMessage( 
    LPCTSTR  pszFile, 
    UINT    uLine, 
    LPCTSTR  pszModule, 
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

    if ( !pszModule )
    {
        pszModule = g_szUnknown;
    }

    if ( !pszFile )
    {
        wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
    }
    else
    {
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        dbgmakefilelinestring( szFileLine, pszFile, uLine );
        wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
    }

    OutputDebugString( szBuf );

    dbgspace( );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist );
    va_end( valist );

    OutputDebugString( szBuf );

}

//
// DebugMsg()
//
void 
DebugMsg( 
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );

    OutputDebugString( szBuf );
}


//
// Displays a dialog box with the failed assertion. User has the option of
// breaking.
//
BOOL
AssertMessage( 
    LPCTSTR  pszFile, 
    UINT    uLine, 
    LPCTSTR  pszModule, 
    LPCTSTR pszfn, 
    BOOL    fTrue )
{
    if ( !fTrue )
    {
        TCHAR szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        // Make sure everything is cool before we blow up somewhere else.
        if ( pszFile == NULL )
        {
            pszFile = g_szNULL;
        }

        if ( pszModule == NULL )
        {
            pszModule = g_szNULL;
        }

        if ( pszfn == NULL )
        {
            pszfn = g_szNULL;
        }

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-40s  %-10s ASSERT: %s\n"),
            szFileLine, pszModule, pszfn );

        OutputDebugString( szBuf );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nAssertion:\t%s\t\n\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn );

        if ( IDNO == MessageBox( NULL, szBuf, TEXT("Assertion Failed!"), 
                MB_YESNO|MB_ICONWARNING ) )
            return FALSE;   // don't break
    }

    return !fTrue;

}

//
// Traces HRESULT errors. A dialog will appear is there is an error
// in the hr.
//
HRESULT
TraceHR( 
    LPCTSTR  pszFile, 
    UINT    uLine, 
    LPCTSTR  pszModule, 
    LPCTSTR pszfn, 
    HRESULT hr )
{
    if ( hr )
    {
        TCHAR  szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR pszMsgBuf;

        switch ( hr )
        {
        case S_FALSE:
            pszMsgBuf = TEXT("S_FALSE\n");
            break;

        default:
            FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPTSTR)&pszMsgBuf,
                0,
                NULL
            );
        }

        // Make sure everything is cool before we blow up somewhere else.
        Assert( pszMsgBuf != NULL );
        Assert( pszFile != NULL );
        Assert( pszModule != NULL );
        Assert( pszfn != NULL );

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-40s  %-10s HRESULT: hr = 0x%08x - %s"),
            szFileLine, pszModule, hr, pszMsgBuf );

        OutputDebugString( szBuf );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nFunction:\t%s\t\nhr =\t0x%08x - %s\t\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn, hr, pszMsgBuf );

        if ( IDYES == MessageBox( NULL, szBuf, TEXT("Trace HRESULT"), 
                MB_YESNO|MB_ICONWARNING ) )
            DEBUG_BREAK;

        LocalFree( pszMsgBuf );

    }

    return hr;

}


//
// Memory allocation and tracking
//

typedef struct _MEMORYBLOCK {
    HGLOBAL hglobal;
    DWORD   dwBytes;
    UINT    uFlags;
    LPCTSTR pszFile;
    UINT    uLine;
    LPCTSTR pszModule;
    LPCTSTR pszComment;
    struct _MEMORYBLOCK *pNext;
} MEMORYBLOCK, *LPMEMORYBLOCK;

//
// Adds a MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    UINT    uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmb     = (LPMEMORYBLOCK) GlobalAlloc( 
                                                    GMEM_FIXED, 
                                                    sizeof(MEMORYBLOCK) );

        if ( !pmb )
        {
            GlobalFree( hglobal );
            return NULL;
        }

        pmb->hglobal    = hglobal;
        pmb->dwBytes    = dwBytes;
        pmb->uFlags     = uFlags;
        pmb->pszFile    = pszFile;
        pmb->uLine      = uLine;
        pmb->pszModule  = pszModule;
        pmb->pszComment = pszComment;
        pmb->pNext      = pmbHead;

        TlsSetValue( g_TraceMemoryIndex, pmb );
    }

    return hglobal;
}

//
// Removes a MEMORYBLOCK to the memory tracking list.
//
void
DebugMemoryDelete( 
    HGLOBAL hglobal )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmbLast = NULL;

        while ( pmbHead && pmbHead->hglobal != hglobal )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        }

        if ( pmbHead )
        {
            if ( pmbLast )
            {
                pmbLast->pNext = pmbHead->pNext;
            }
            else
            {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );
            }
        }
    }
}

//
// Allocates memory and adds the MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugAlloc( 
    LPCTSTR pszFile,
    UINT    uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    HGLOBAL       hglobal = GlobalAlloc( uFlags, dwBytes );

    return DebugMemoryAdd( hglobal, pszFile, uLine, pszModule, uFlags, dwBytes, pszComment );
}

//
// Remove the MEMORYBLOCK to the memory tracking list, memsets the
// memory to 0xFE and then frees the memory.
//
HGLOBAL
DebugFree( 
    HGLOBAL hglobal )
{
    DebugMemoryDelete( hglobal );

    return GlobalFree( hglobal );
}

//
// Checks the memory tracking list. If it is not empty, it will dump the
// list and break.
//
void
DebugMemoryCheck( )
{
    BOOL          fFoundLeak = FALSE;
    LPMEMORYBLOCK pmb = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );

    while ( pmb )
    {
        LPVOID args[ 5 ];
        TCHAR  szOutput[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( fFoundLeak == FALSE )
        {
            OutputDebugString(TEXT("\n***************************** Memory leak detected *****************************\n\n"));
          //OutputDebugString("1234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1...");
            OutputDebugString(TEXT("Filename(Line Number):                    Module     Addr/HGLOBAL  Size   String\n"));
            fFoundLeak = TRUE;
        }

        args[0] = (LPVOID) pmb->hglobal;
        args[1] = (LPVOID) &szFileLine;
        args[2] = (LPVOID) pmb->pszComment;
        args[3] = (LPVOID) pmb->dwBytes;
        args[4] = (LPVOID) pmb->pszModule;

        dbgmakefilelinestring( szFileLine, pmb->pszFile, pmb->uLine );

        if ( !!(pmb->uFlags & GMEM_MOVEABLE) )
        {
            FormatMessage( 
                FORMAT_MESSAGE_FROM_STRING | 
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-40s!  %5!-10s! H 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) &szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (va_list*) &args );           // arguments
        }
        else
        {    
            FormatMessage( 
                FORMAT_MESSAGE_FROM_STRING | 
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-40s!  %5!-10s! A 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) &szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (va_list*) &args );           // arguments
        }

        OutputDebugString( szOutput );

        pmb = pmb->pNext;
    }

    if ( fFoundLeak == TRUE )
    {
        OutputDebugString(TEXT("\n***************************** Memory leak detected *****************************\n\n"));
    }

    Assert( !fFoundLeak );
}

//
// Global Management Functions - 
//
// These are in debug and retail but are internally they change
// depending on the build.
//

#if 0
void * __cdecl operator new(unsigned int t_size )
{
    return DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, GPTR, t_size, TEXT("new()") );
}

void __cdecl operator delete(void *pv)
{
    TraceFree( pv );
}
#endif

#else // ! DEBUG -- It's retail

//
// Global Management Functions - 
//
// These are in debug and retail but are internally they change
// depending on the build.
//
#if 0
void * __cdecl operator new(unsigned int t_size )
{
    return LocalAlloc( GPTR, t_size );
}

void __cdecl operator delete(void *pv)
{
    LocalFree( pv );
}
#endif
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\imirror\modify.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    modify.h

Abstract:

    This the include file for supporting modifying boot.ini and the DS entries for this machine.

Author:

    Sean Selitrennikoff - 5/4/98

Revision History:

--*/

//
// Data types used in modification
//

#error ("this code is not currently compiled in.  un-"#if 0" it to use it")

#if 0
typedef struct _IMIRROR_MODIFY_DS_INFO {
    WCHAR SetupPath[MAX_PATH];
    WCHAR ServerName[MAX_PATH];
} IMIRROR_MODIFY_DS_INFO, *PIMIRROR_MODIFY_DS_INFO;

//
// Functions for processing each to do item
//
NTSTATUS
ModifyDSEntries(
    IN PVOID pBuffer,
    IN ULONG Length
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\imirror\mirror.h ===
/*
Module Name:

    mirror.h

Abstract:

    This module is the header file for the code that copies from one
    tree to another.

Author:

    Andy Herron May 27 1998

Revision History:

*/

//
//  This structure contains all the global data passed around for the
//  different instances of copying subtrees active.
//

typedef struct _COPY_TREE_CONTEXT {

    LIST_ENTRY PendingDirectoryList;

    LARGE_INTEGER BytesCopied;
    ULONG FilesCopied;
    ULONG AttributesModified;
    ULONG SourceFilesScanned;
    ULONG DestFilesScanned;
    ULONG DirectoriesCreated;
    ULONG ErrorsEncountered;
    ULONG FilesDeleted;
    ULONG DirectoriesDeleted;
    ULONG SecurityDescriptorsWritten;
    ULONG SourceSecurityDescriptorsRead;
    ULONG SFNWritten;
    BOOLEAN Cancelled;
    BOOLEAN DeleteOtherFiles;

    CRITICAL_SECTION Lock;

} COPY_TREE_CONTEXT, *PCOPY_TREE_CONTEXT;


//
//  this is the structure we use to track per thread instance data, per thread
//  buffers, etc.
//

#define IMIRROR_INITIAL_SD_LENGTH 2048
#define IMIRROR_INITIAL_SFN_LENGTH 32

typedef struct _IMIRROR_THREAD_CONTEXT {
    PCOPY_TREE_CONTEXT CopyContext;

    LPBYTE SDBuffer;
    DWORD  SDBufferLength;

    LPBYTE SFNBuffer;
    DWORD  SFNBufferLength;

    LPBYTE DirectoryBuffer;
    DWORD  DirectoryBufferLength;
    BOOLEAN IsNTFS;
    HANDLE SourceDirHandle;
    HANDLE DestDirHandle;

    PVOID FindBufferBase;
    PVOID FindBufferNext;
    ULONG FindBufferLength;

    LIST_ENTRY FilesToIgnore;

} IMIRROR_THREAD_CONTEXT, *PIMIRROR_THREAD_CONTEXT;

//
//  This structure is used to report back errors that occurred during copying.
//

typedef struct _COPY_ERROR {
    LIST_ENTRY ListEntry;
    DWORD Error;
    DWORD ActionCode;
    PWCHAR FileName;
    WCHAR  FileNameBuffer[1];
} COPY_ERROR, *PCOPY_ERROR;

#define IMIRROR_ATTRIBUTES_TO_REPLICATE ( FILE_ATTRIBUTE_HIDDEN    | \
                                          FILE_ATTRIBUTE_READONLY  | \
                                          FILE_ATTRIBUTE_SYSTEM    | \
                                          FILE_ATTRIBUTE_TEMPORARY | \
                                          FILE_ATTRIBUTE_NORMAL    | \
                                          FILE_ATTRIBUTE_DIRECTORY | \
                                          FILE_ATTRIBUTE_ARCHIVE )

#define IMIRROR_ATTRIBUTES_TO_STORE (~(IMIRROR_ATTRIBUTES_TO_REPLICATE))

#define IMIRROR_ATTRIBUTES_TO_IGNORE ( FILE_ATTRIBUTE_OFFLINE             | \
                                       FILE_ATTRIBUTE_SPARSE_FILE         | \
                                       FILE_ATTRIBUTE_NOT_CONTENT_INDEXED )

//
//  These are the functions in mirror.c
//

#ifdef DEBUGLOG

VOID
IMLogToFile (
    PSTR Buffer
    );

VOID
IMFlushAndCloseLog (
    VOID
    );

#endif

DWORD
AllocateCopyTreeContext (
    PCOPY_TREE_CONTEXT *CopyContext,
    BOOLEAN DeleteOtherFiles
    );

VOID
FreeCopyTreeContext (
    PCOPY_TREE_CONTEXT CopyContext
    );

DWORD
CopyTree (
    PCOPY_TREE_CONTEXT CopyContext,
    BOOLEAN IsNtfs,
    PWCHAR SourceRoot,
    PWCHAR DestRoot
    );

ULONG
ReportCopyError (
    PCOPY_TREE_CONTEXT CopyContext OPTIONAL,
    PWCHAR File,
    DWORD  ActionCode,
    DWORD err
    );

ULONG
IMConvertNT2Win32Error(
    IN NTSTATUS Status
    );

DWORD
IMFindNextFile(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    HANDLE  DirHandle,
    PFILE_FULL_DIR_INFORMATION *lpFindFileData
    );

DWORD
IMFindFirstFile(
    PIMIRROR_THREAD_CONTEXT ThreadContext,
    HANDLE  DirHandle,
    PFILE_FULL_DIR_INFORMATION *lpFindFileData
    );

NTSTATUS
GetTokenHandle(
    IN OUT PHANDLE TokenHandle
    );

NTSTATUS
SetPrivs(
    IN HANDLE TokenHandle,
    IN LPTSTR lpszPriv
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\imirror\regcopy.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    regcopy.c

Abstract:

    This is for supporting copying and munging the registry files.

Author:

    Sean Selitrennikoff - 4/5/98

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

typedef BOOL (*PFNGETPROFILESDIRECTORYW)(LPWSTR lpProfile, LPDWORD dwSize);

PWSTR HivePath;
HKEY HiveRoot;
PWSTR HiveName;
REG_CONTEXT RegistryContext;

PWSTR MachineName;
PWSTR HiveFileName;
PWSTR HiveRootName;



DWORD
DoFullRegBackup(
    PWCHAR MirrorRoot
    )

/*++

Routine Description:

    This routine copies all the registries to the given server path.

Arguments:

    None.

Return Value:

    NO_ERROR if everything was backed up properly, else the appropriate error code.

--*/

{
    PWSTR w;
    LONG Error;
    HKEY HiveListKey;
    PWSTR KeyName;
    PWSTR FileName;
    PWSTR Name;
    DWORD ValueIndex;
    DWORD ValueType;
    DWORD ValueNameLength;
    DWORD ValueDataLength;
    WCHAR ConfigPath[ MAX_PATH ];
    WCHAR HiveName[ MAX_PATH ];
    WCHAR HivePath[ MAX_PATH ];
    WCHAR FilePath[ MAX_PATH ];
    HANDLE hInstDll;
    PFNGETPROFILESDIRECTORYW pfnGetProfilesDirectory;
    NTSTATUS Status;
    BOOLEAN savedBackup;

    //
    // First try and give ourselves enough priviledge
    //
    if (!RTEnableBackupRestorePrivilege()) {
        return(GetLastError());
    }

    //
    // Now attach to the registry
    //
    Error = RTConnectToRegistry(MachineName,
                                HiveFileName,
                                HiveRootName,
                                NULL,
                                &RegistryContext
                               );

    if (Error != NO_ERROR) {
        RTDisableBackupRestorePrivilege();
        return Error;
    }

    //
    // Get handle to hivelist key
    //
    KeyName = L"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Hivelist";
    Error = RTOpenKey(&RegistryContext,
                      NULL,
                      KeyName,
                      MAXIMUM_ALLOWED,
                      0,
                      &HiveListKey
                     );

    if (Error != NO_ERROR) {
        RTDisconnectFromRegistry(&RegistryContext);
        return Error;
    }

    //
    // get path data for system hive, which will allow us to compute
    // path name to config dir in form that hivelist uses.
    // (an NT internal form of path)  this is NOT the way the path to
    // the config directory should generally be computed.
    //

    ValueDataLength = sizeof(ConfigPath);
    Error = RTQueryValueKey(&RegistryContext,
                            HiveListKey,
                            L"\\Registry\\Machine\\System",
                            &ValueType,
                            &ValueDataLength,
                            ConfigPath
                           );
    if (Error != NO_ERROR) {
        RTDisconnectFromRegistry(&RegistryContext);
        return Error;
    }
    w = wcsrchr(ConfigPath, L'\\');
    *w = UNICODE_NULL;


    //
    // ennumerate entries in hivelist.  for each entry, find it's hive file
    // path then save it.
    //
    for (ValueIndex = 0; TRUE; ValueIndex++) {

        savedBackup = FALSE;
        ValueType = REG_NONE;
        ValueNameLength = ARRAYSIZE( HiveName );
        ValueDataLength = sizeof( HivePath );

        Error = RTEnumerateValueKey(&RegistryContext,
                                    HiveListKey,
                                    ValueIndex,
                                    &ValueType,
                                    &ValueNameLength,
                                    HiveName,
                                    &ValueDataLength,
                                    HivePath
                                   );
        if (Error == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Error != NO_ERROR) {
            RTDisconnectFromRegistry(&RegistryContext);
            return Error;
        }

        if ((ValueType == REG_SZ) && (ValueDataLength > sizeof(UNICODE_NULL))) {
            //
            // there's a file, compute it's path, hive branch, etc
            //

            if (w = wcsrchr( HivePath, L'\\' )) {
                *w++ = UNICODE_NULL;
            }
            FileName = w;

            if (w = wcsrchr( HiveName, L'\\' )) {
                *w++ = UNICODE_NULL;
            }
            Name = w;

            HiveRoot = NULL;
            if (w = wcsrchr( HiveName, L'\\' )) {
                w += 1;
                if (!_wcsicmp( w, L"MACHINE" )) {
                    HiveRoot = HKEY_LOCAL_MACHINE;
                } else if (!_wcsicmp( w, L"USER" )) {
                    HiveRoot = HKEY_USERS;
                } else {

                    Status = IMirrorRegSaveError(w, ERROR_PATH_NOT_FOUND);

                    if (Status == STATUS_RETRY) {
                        continue;
                    }

                    if (!NT_SUCCESS(Status)) {
                        return Error;
                    }

                }

            }

            if (FileName != NULL && Name != NULL && HiveRoot != NULL) {

                //
                // Extract the path name from HivePath
                //
                if (_wcsicmp(HivePath, L"\\Device")) {

                    w = HivePath + 1;
                    w = wcsstr(w, L"\\");
                    w++;
                    w = wcsstr(w, L"\\");
                    w++;

                } else if (*(HivePath + 1) == L':') {

                    w = HivePath + 2;

                } else {

                    Status = IMirrorRegSaveError(HivePath, ERROR_PATH_NOT_FOUND);

                    if (Status == STATUS_RETRY) {
                        continue;
                    }

                    if (!NT_SUCCESS(Status)) {
                        return Error;
                    }

                }

                //
                // Do the save
                //

                swprintf( FilePath, L"%ws\\UserData\\%ws\\%ws", MirrorRoot, w, FileName );

                IMirrorNowDoing(CopyRegistry, FileName);

                //
                //  if the file already exists, rename it to a backup name
                //  so that if it fails, we'll restore it.
                //

                lstrcpyW( (PWCHAR) TmpBuffer, FilePath );
                lstrcatW( (PWCHAR) TmpBuffer, L".old" );
                if (MoveFileEx( FilePath, (PWCHAR) TmpBuffer, MOVEFILE_REPLACE_EXISTING)) {

                    savedBackup = TRUE;
                }

RetrySave:
                Error = DoSpecificRegBackup(FilePath,
                                            HiveRoot,
                                            Name
                                           );

                if (Error != NO_ERROR) {

                    Status = IMirrorRegSaveError(Name, Error);

                    if (Status == STATUS_RETRY) {
                        goto RetrySave;
                    }

                    if (!NT_SUCCESS(Status)) {

                        if (savedBackup) {

                            if (MoveFileEx( (PWCHAR) TmpBuffer, FilePath, MOVEFILE_REPLACE_EXISTING)) {

                                savedBackup = FALSE;
                            }
                        }
                        return Error;
                    }
                }
            }
        }
    }

    RTDisconnectFromRegistry(&RegistryContext);
    return NO_ERROR;
}

DWORD
DoSpecificRegBackup(
    PWSTR HivePath,
    HKEY HiveRoot,
    PWSTR HiveName
    )


/*++

Routine Description:

    This routine copies all the registries to the given server path.

Arguments:

    HivePath - file name to pass directly to OS

    HiveRoot - HKEY_LOCAL_MACHINE or HKEY_USERS

    HiveName - 1st level subkey under machine or users

Return Value:

    NO_ERROR if everything was backed up properly, else the appropriate error code.

--*/

{
    HKEY HiveKey;
    ULONG Disposition;
    LONG Error;
    char *Reason;

    //
    // get a handle to the hive.  use special create call what will
    // use privileges
    //

    Reason = "accessing";
    Error = RTCreateKey(&RegistryContext,
                        HiveRoot,
                        HiveName,
                        KEY_READ,
                        REG_OPTION_BACKUP_RESTORE,
                        NULL,
                        &HiveKey,
                        &Disposition
                       );
    if (Error == NO_ERROR) {
        Reason = "saving";
        Error = RegSaveKey(HiveKey, HivePath, NULL);
        RTCloseKey(&RegistryContext, HiveKey);
    }

    return Error;
}

DWORD
GetRegistryFileList(
    PLIST_ENTRY ListHead
    )

/*++

Routine Description:

    This routine stores all registry file names to a list.

Arguments:

    None.

Return Value:

    NO_ERROR if everything was backed up properly, else the appropriate error code.

--*/

{
    LONG Error;
    HKEY HiveListKey;
    PWSTR KeyName;
    PWSTR FileName;
    PWSTR Name;
    DWORD ValueIndex;
    DWORD ValueType;
    DWORD ValueNameLength;
    DWORD ValueDataLength;
    WCHAR HiveName[ MAX_PATH ];
    WCHAR HivePath[ MAX_PATH ];
    NTSTATUS Status;
    PIMIRROR_IGNORE_FILE_LIST entry;

    //
    // enter all hardcoded files that we don't want to mirror here...
    //

    FileName = L"System Volume Information\\tracking.log";

    entry = IMirrorAllocMem(sizeof(IMIRROR_IGNORE_FILE_LIST) +
                            ((lstrlenW(FileName) + 1) * sizeof(WCHAR)));

    if (entry != NULL) {

        lstrcpyW( &entry->FileName[0], FileName );
        entry->FileNameLength = (USHORT) lstrlenW( FileName );
        InsertHeadList( ListHead, &entry->ListEntry );
    }

    //
    // Now attach to the registry
    //
    Error = RTConnectToRegistry(MachineName,
                                HiveFileName,
                                HiveRootName,
                                NULL,
                                &RegistryContext
                               );

    if (Error != NO_ERROR) {
        return Error;
    }

    //
    // Get handle to hivelist key
    //
    KeyName = L"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Hivelist";
    Error = RTOpenKey(&RegistryContext,
                      NULL,
                      KeyName,
                      MAXIMUM_ALLOWED,
                      0,
                      &HiveListKey
                     );

    if (Error != NO_ERROR) {
        RTDisconnectFromRegistry(&RegistryContext);
        return Error;
    }

    //
    // ennumerate entries in hivelist.  for each entry, find it's hive file
    // path then save it.
    //
    for (ValueIndex = 0; TRUE; ValueIndex++) {

        ValueType = REG_NONE;
        ValueNameLength = ARRAYSIZE( HiveName );
        ValueDataLength = sizeof( HivePath );

        Error = RTEnumerateValueKey(&RegistryContext,
                                    HiveListKey,
                                    ValueIndex,
                                    &ValueType,
                                    &ValueNameLength,
                                    HiveName,
                                    &ValueDataLength,
                                    HivePath
                                   );
        if (Error != NO_ERROR) {
            if (Error == ERROR_NO_MORE_ITEMS) {
                Error = NO_ERROR;
            }
            break;
        }

        if ((ValueType == REG_SZ) && (ValueDataLength > sizeof(UNICODE_NULL))) {

            //
            // Extract the path name from HivePath
            //
            if (_wcsicmp(HivePath, L"\\Device")) {

                FileName = HivePath + 1;
                FileName = wcsstr(FileName, L"\\");
                FileName++;
                FileName = wcsstr(FileName, L"\\");
                FileName++;     // now points to L"\winnt\system32\config\sam"

            } else if (*(HivePath + 1) == L':') {

                FileName = HivePath + 2;

            } else {

                FileName = HivePath;
            }

            entry = IMirrorAllocMem(sizeof(IMIRROR_IGNORE_FILE_LIST) +
                                    ((lstrlenW(FileName) + 1) * sizeof(WCHAR)));

            if (entry != NULL) {

                lstrcpyW( &entry->FileName[0], FileName );
                entry->FileNameLength = (USHORT) lstrlenW( FileName );
                InsertHeadList( ListHead, &entry->ListEntry );
            }
        }
    }

    RTDisconnectFromRegistry(&RegistryContext);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\imirror\modify.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    modify.c

Abstract:

    This is for modifying boot.ini and DS entries

Author:

    Sean Selitrennikoff - 5/4/98

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#if 0

WCHAR BootPath[TMP_BUFFER_SIZE];
WCHAR ComputerName[TMP_BUFFER_SIZE];
WCHAR DsPath[TMP_BUFFER_SIZE];


NTSTATUS
ModifyDSEntries(
    IN PVOID pBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine does all the munging of DS entries to make this machine look
    like a remote boot client.

Arguments:

    pBuffer - Pointer to any arguments passed in the to do item.

    Length - Length, in bytes of the arguments.

Return Value:

    STATUS_SUCCESS if it completes the to do item properly.

--*/

{
    NTSTATUS Status;
    PLDAP LdapHandle;
    ULONG TmpUlong;
    ULONG LdapError;

    LDAPMod FilePathMod;

    WCHAR *AttrValues1[2];

    PLDAPMod Modifiers[2];

    PIMIRROR_MODIFY_DS_INFO pModifyInfo;

    DWORD Error;
    HKEY hkey;
    PWCHAR pTmp;

    HANDLE Handle;
    IO_STATUS_BLOCK IoStatus;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;

    PUCHAR pch;

    DWORD NameLength;
    DWORD SidLength;
    DWORD DomainLength;
    DWORD RequestSize;
    SID_NAME_USE snu;

    PDOMAIN_CONTROLLER_INFO DCInfo;

    IMirrorNowDoing(PatchDSEntries, NULL);

    if (Length != sizeof(IMIRROR_MODIFY_DS_INFO)) {
        IMirrorHandleError(ERROR_DS_SERVER_DOWN, PatchDSEntries);
        return ERROR_DS_SERVER_DOWN;
    }

    pModifyInfo = (PIMIRROR_MODIFY_DS_INFO)pBuffer;

    //
    // Verify that server exists.
    //
    Status = VerifyServerExists(pModifyInfo->ServerName,
                                (wcslen(pModifyInfo->ServerName) + 1) * sizeof(WCHAR)
                               );

    if (!NT_SUCCESS(Status)) {
        IMirrorHandleError(Status, PatchDSEntries);
        return Status;
    }
    //
    // Get the computer name
    //
    NameLength = TMP_BUFFER_SIZE;
    if (!GetComputerName(ComputerName, &NameLength)) {
        IMirrorHandleError(STATUS_NO_MEMORY, PatchDSEntries);
        return STATUS_NO_MEMORY;
    }
    ComputerName[NameLength] = UNICODE_NULL;
    NameLength++;

    //
    //
    // Before doing anything else, setup the values we are going to use later.
    //
    //

    //
    // Setup BootPath
    //
    swprintf(BootPath, L"%ws\\Clients\\%ws\\startrom.com", pModifyInfo->ServerName, ComputerName);

    //
    // Get the path to this machine object
    //
    TmpUlong = sizeof(DsPath);
    if (!GetComputerObjectName(NameFullyQualifiedDN, DsPath, &TmpUlong)) {
        Error = GetLastError();
        IMirrorHandleError(Error, PatchDSEntries);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Connect to the DS
    //
    LdapHandle = ldap_init(NULL, LDAP_PORT);

    if (LdapHandle == NULL) {
        Error = GetLastError();
        IMirrorHandleError(Error, PatchDSEntries);
        return STATUS_UNSUCCESSFUL;
    }

    TmpUlong = DS_DIRECTORY_SERVICE_REQUIRED | DS_IP_REQUIRED;
    ldap_set_option(LdapHandle, LDAP_OPT_GETDSNAME_FLAGS, &TmpUlong);

    TmpUlong = (ULONG) LDAP_OPT_ON;
    ldap_set_option(LdapHandle, LDAP_OPT_REFERRALS, (void *)&TmpUlong);

    TmpUlong = LDAP_VERSION3;
    ldap_set_option(LdapHandle, LDAP_OPT_VERSION, &TmpUlong);

    LdapError = ldap_connect(LdapHandle,0);

    if (LdapError != LDAP_SUCCESS) {
        ldap_unbind(LdapHandle);
        IMirrorHandleError(LdapError, PatchDSEntries);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Make the binding
    //
    LdapError = ldap_bind_s(LdapHandle, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    if (LdapError != LDAP_SUCCESS) {
        ldap_unbind(LdapHandle);
        IMirrorHandleError(LdapError, PatchDSEntries);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Setup the attribute changes
    //

    FilePathMod.mod_op = LDAP_MOD_REPLACE;
    FilePathMod.mod_type = L"netbootMachineFilePath";
    FilePathMod.mod_values = AttrValues1;
    AttrValues1[0] = BootPath;
    AttrValues1[1] = NULL;

    Modifiers[0] = &FilePathMod;
    Modifiers[1] = NULL;

    //
    // Submit the changes to the DS
    //
    LdapError = ldap_modify_s(LdapHandle, DsPath, Modifiers);

    ldap_unbind(LdapHandle);

    if (LdapError != LDAP_SUCCESS) {
        IMirrorHandleError(LdapError, PatchDSEntries);
        return STATUS_UNSUCCESSFUL;
    }
    return STATUS_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\newrb\newrb.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/


#ifndef _NEWRB_H_
#define _NEWRB_H_


// Globals
extern HINSTANCE g_hinstance;


#endif // _NEWRB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\newrb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by newrb.rc
//
#define IDD_CLIENT                      107
#define IDC_E_MAC                       1000
#define IDC_E_MACHINENAME               1001
#define IDC_E_CONTAINER                 1002
#define IDC_S_NUMBER                    1005
#define IDC_ADD                         1006
#define IDC_REMOVE                      1007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\newrb\pch.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

  File: PCH.H

  Precompiled header file for RBSETUP.
 
 ***************************************************************************/

#define UNICODE

#if DBG == 1
#define DEBUG
#endif

#include <windows.h>

#include "newrb.h"
#include "debug.h"
#include "utils.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\newrb\debug.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

  File: DEBUG.H

  Debugging utilities header
 
 ***************************************************************************/


#ifndef _DEBUG_H_
#define _DEBUG_H_

#if DBG==1

// Globals
extern DWORD g_TraceMemoryIndex;
extern DWORD g_dwCounter;
extern DWORD g_dwTraceFlags;

extern const TCHAR g_szTrue[];
extern const TCHAR g_szFalse[];

// Trace Flags
enum {
    TF_ALWAYS           = 0xFFFFFFFF,
    TF_NEVER            = 0x00000000,
    TF_QUERYINTERFACE   = 0x00000001,
    TF_FUNC             = 0x00000002,
    TF_CALLS            = 0x00000004,
    TF_MEMORYALLOCS     = 0x00000008
};


// Macros
#define DEFINE_MODULE( _module ) static const TCHAR g_szModule[] = TEXT(_module);
#define __MODULE__ g_szModule

// #define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#if defined(_X86_)
#define DEBUG_BREAK { _asm int 3 }
#else
#define DEBUG_BREAK
#endif

#define INITIALIZE_TRACE_MEMORY     g_TraceMemoryIndex = TlsAlloc( ); TlsSetValue( g_TraceMemoryIndex, NULL)
#define UNINITIALIZE_TRACE_MEMORY   DebugMemoryCheck( )

#ifdef Assert
#undef Assert
#endif
#define Assert( _fn ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), !!(_fn) ) ) DEBUG_BREAK

#ifdef AssertMsg
#undef AssertMsg
#endif
#define AssertMsg( _fn, _msg ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), !!(_fn) ) ) DEBUG_BREAK

#define TraceAlloc( _flags, _size ) DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, _flags, _size, TEXT(#_size) )
#define TraceFree( _hmem )          DebugFree( _hmem )

// Tracing
#define TraceFunc( _msg ) \
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT(_msg) ); \
    g_dwCounter--; \

#define TraceClsFunc( _msg ) \
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("%s::%s"), TEXT(SZTHISCLASS), TEXT(_msg) );\
    g_dwCounter--; \

#define TraceDo( _fn ) {\
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("V\n") ); \
    g_dwCounter--; \
}

#define TraceMsgDo( _fn, _msg ) {\
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT(_msg), _fn ); \
    g_dwCounter--; \
}

#define DebugDo( _fn ) {\
    g_dwCounter++; \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("V\n") ); \
    g_dwCounter--; \
}

#define DebugMsgDo( _fn, _msg ) {\
    g_dwCounter++; \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("+ %s\n"), TEXT(#_fn) ); \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), _fn); \
    g_dwCounter--; \
}

// HRESULT testing
#define THR( _fn ) \
    TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn )

#define RRETURN( _fn ) \
    return TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn )

#define QIRETURN( _fn ) \
    if ( !!( TF_QUERYINTERFACE & g_dwTraceFlags ) )\
        return TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn ); \
    else if ( hr ) \
        DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("QueryInterface() failed()") ); \
    return _fn

#define RRETURN1( _fn, _ok ) {\
    TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), \
        ( ( _fn == _ok ) ? S_OK : _fn ) ); \
    return _fn;\
    }

// Thread-safe inc/decrements
#define InterlockDecrement( _var ) {\
    --_var;\
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_QUERYINTERFACE, TEXT("Decremented %s = %u\n"), TEXT(#_var), _var );\
    g_dwCounter--; \
     }
#define InterlockIncrement( _var ) {\
    ++_var;\
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_QUERYINTERFACE, TEXT("Incremented %s = %u\n"), TEXT(#_var), _var );\
    g_dwCounter--; \
    }

// Other
#define BOOLTOSTRING( _fBool ) ( !!(_fBool) ? g_szTrue : g_szFalse )

// Functions
void
TraceMsg( 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... );

void
DebugMsg( 
    LPCTSTR pszFormat,
    ... );

void
TraceMessage( 
    LPCTSTR pszFile, 
    UINT    uLine, 
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... );

void 
DebugMessage( 
    LPCTSTR pszFile, 
    UINT    uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszFormat,
    ... );

BOOL
AssertMessage( 
    LPCTSTR pszFile, 
    UINT    uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    BOOL    fTrue );

HRESULT
TraceHR( 
    LPCTSTR pszFile, 
    UINT    uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    HRESULT hr );

// Memory Functions
HGLOBAL
DebugAlloc( 
    LPCTSTR pszFile,
    UINT    uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

HGLOBAL
DebugFree( 
    HGLOBAL hMem );

HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    UINT    uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

#define DebugMemoryAddHandle( _handle ) \
    DebugMemoryAdd( _handle, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_MOVEABLE, 0, TEXT("_handle") );

#define DebugMemoryAddAddress( _pv ) \
    DebugMemoryAdd( _pv, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT("_pv") );

void
DebugMemoryDelete( 
    HGLOBAL hglobal );

void
DebugMemoryCheck( );

//
//
#else // it's RETAIL    ******************************************************
//
//

// Debugging -> NOPs
#define Assert( _fn )
#define DebugDo( _fn )
#define DebugMsgDo( _fn, _msg )
#define DEFINE_MODULE( _module )
#define AssertMsg               (void)
#define TraceMsg                (void)
#define DebugMsg                (void)
#define TraceMessage            (void)
#define DebugMessage            (void)
#define AssertMessage           (void)
#define TraceHR                 (void)
#define DebugMemoryAddHandle( _handle )
#define DebugMemoryAddAddress( _pv )
#define INITIALIZE_TRACE_MEMORY
#define UNINITIALIZE_TRACE_MEMORY
#define DebugMemoryDelete( _h )

// Tracing -> just do operation
#define TraceDo( _fn )          _fn
#define TraceMsgDo( _fn, _msg ) _fn

// HRESULT testing -> do retail
#define THR
#define RRETURN( _fn )          return _fn

// Thread-safe inc/decrements -> do retail
#define InterlockDecrement( _var )      --_var
#define InterlockIncrement( _var )      ++_var

// Memory Functions -> do retail
#define TraceAlloc( _flags, _size )     GlobalAlloc( _flags, _size )
#define TraceFree( _pv )                GlobalFree( _pv )

#endif // DBG==1

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\newrb\utils.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#ifndef _UTILS_H_
#define _UTILS_H_

void 
CenterDialog( 
    HWND hwndDlg );

void 
ClearMessageQueue( void );

int
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType );

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\newrb\main.c ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#include "pch.h"

#include <commctrl.h>
#include <windowsx.h>

DEFINE_MODULE("Main");

// Globals
HINSTANCE g_hinstance = NULL;

#define BINL_PARAMETERS_KEY L"System\\CurrentControlSet\\Services\\Binlsvc\\Parameters"

#define GUID_SIZE 32
#define MAC_SIZE 12
#define MACHINE_NAME_SIZE 20


//
//
//
DWORD
OscCreateAccount(
    LPTSTR GUID,
    LPTSTR Name
    )
{
    DWORD Error;
    TCHAR szGUID[ GUID_SIZE + 1 ];

    HKEY hkeyParams;
    HKEY hkey;
    DWORD dw = 0;

    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                BINL_PARAMETERS_KEY,
                0,
                KEY_READ | KEY_WRITE,
                &hkeyParams );
    Assert( Error == ERROR_SUCCESS );
    if ( Error != ERROR_SUCCESS )
        goto Cleanup;

    Error = RegSetValueEx(
                hkeyParams,
                L"AllowAllClients",
                0,
                REG_DWORD,
                (LPBYTE) &dw,
                sizeof(dw));
    Assert( Error == ERROR_SUCCESS );


    if ( lstrlen( GUID ) == MAC_SIZE )
    {
        wsprintf( szGUID, TEXT("%020x%s"), 0, GUID );
    }
    else
    {
        lstrcpy( szGUID, GUID );
    }

    Error = RegCreateKey(
                hkeyParams,
                szGUID,
                &hkey );
    Assert( Error == ERROR_SUCCESS );

    if ( Error == ERROR_SUCCESS )
    {
        RegCloseKey( hkey );
    }

    RegCloseKey( hkeyParams );

Cleanup:
    return Error;
}

//
//
//
DWORD
OscDeleteAccount(
    LPTSTR GUID,
    LPTSTR Name
    )
{
    DWORD Error;
    TCHAR szGUID[ GUID_SIZE + 1 ];

    HKEY hkeyParams;
    HKEY hkey;
    DWORD dw = 0;

    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                BINL_PARAMETERS_KEY,
                0,
                KEY_READ | KEY_WRITE,
                &hkeyParams );
    Assert( Error == ERROR_SUCCESS );
    if ( Error != ERROR_SUCCESS )
        goto Cleanup;

    Error = RegSetValueEx(
                hkeyParams,
                L"AllowAllClients",
                0,
                REG_DWORD,
                (LPBYTE) &dw,
                sizeof(dw));
    Assert( Error == ERROR_SUCCESS );


    if ( lstrlen( GUID ) == MAC_SIZE )
    {
        wsprintf( szGUID, TEXT("%020x%s"), 0, GUID );
    }
    else
    {
        lstrcpy( szGUID, GUID );
    }

    Error = RegDeleteKey(
                hkeyParams,
                szGUID );
    Assert( Error == ERROR_SUCCESS );

    RegCloseKey( hkeyParams );

Cleanup:
    return Error;
}

//
//
//
BOOL CALLBACK
ClientDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            CenterDialog( hDlg );
            SendMessage( GetDlgItem( hDlg, IDC_E_MAC), EM_LIMITTEXT, (WPARAM)32, 0 );
            Button_SetCheck( GetDlgItem( hDlg, IDC_ADD ), BST_CHECKED );
            break;

        case WM_COMMAND:
            {
                switch ( LOWORD( wParam ) )
                {
                case IDOK:
                    {
                        DWORD dwLen;
                        TCHAR szGUID[ GUID_SIZE + 1 ];
                        TCHAR szMachineName[ MACHINE_NAME_SIZE + 1];
                        GetDlgItemText( hDlg, IDC_E_MAC, szGUID, ARRAYSIZE( szGUID ) );
                        GetDlgItemText( hDlg, IDC_E_MACHINENAME, szMachineName, ARRAYSIZE( szMachineName ) );

                        dwLen = lstrlen( szGUID );
                        if (( dwLen != GUID_SIZE ) && ( dwLen != MAC_SIZE ))
                        {
                            MessageBox( hDlg, 
                                        TEXT("A valid GUID is 32 digits.\nA valid MAC is 12.\nPlease correct your entry."), 
                                        TEXT("Not a valid GUID/MAC"), 
                                        MB_OK );
                        }
                        else
                        {
                            if ( BST_CHECKED == Button_GetCheck( GetDlgItem( hDlg, IDC_ADD ) ) )
                            {
                                OscCreateAccount( szGUID, szMachineName );
                            }
                            else
                            {
                                OscDeleteAccount( szGUID, szMachineName );
                            }
                        }
                    }
                    Edit_SetText( GetDlgItem( hDlg, IDC_E_MAC), L"" );
                    break;

                case IDCANCEL:
                    EndDialog( hDlg, IDCANCEL );
                    break;

                case IDC_E_MAC:
                    {
                        DWORD dwLen;
                        TCHAR szGUID[ GUID_SIZE + 1 ];
                        TCHAR szNumber[ 64 ];

                        GetDlgItemText( hDlg, IDC_E_MAC, szGUID, ARRAYSIZE( szGUID ));
                        dwLen = lstrlen( szGUID );

                        wsprintf( szNumber, TEXT("Digits = %u"), dwLen );
                        SetWindowText( GetDlgItem( hDlg, IDC_S_NUMBER), szNumber );
                    }
                    break;
                }
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


//
// WinMain()
//
int APIENTRY 
WinMain(
    HINSTANCE hInstance, 
    HINSTANCE hPrevInstance, 
    LPSTR lpCmdLine, 
    int nCmdShow)
{
    HRESULT hr = S_OK;
    HKEY    hkey;
    DWORD   Error;

    g_hinstance = hInstance;

    INITIALIZE_TRACE_MEMORY;

    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                BINL_PARAMETERS_KEY,
                0,
                KEY_QUERY_VALUE,
                &hkey );

    if( Error != ERROR_SUCCESS ) {
        return -2;
    }

    Error = DialogBox( g_hinstance, MAKEINTRESOURCE( IDD_CLIENT ), NULL, ClientDlgProc );
    Assert( Error != -1 );

    UNINITIALIZE_TRACE_MEMORY;

    RRETURN(hr);
}


// stolen from the CRT, used to shrink our code
int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPSTR pszCmdLine = GetCommandLineA();


    if ( *pszCmdLine == '\"' ) 
    {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else 
    {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) 
    {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never come here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\newrb\utils.c ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#include "pch.h"

DEFINE_MODULE("Utils");

#define SMALL_BUFFER_SIZE   256

//
// Centers a dialog.
//
void 
CenterDialog( 
    HWND hwndDlg )
{
    RECT    rc;
    RECT    rcScreen;
    int     x, y;
    int     cxDlg, cyDlg;
    int     cxScreen; 
    int     cyScreen; 

    SystemParametersInfo( SPI_GETWORKAREA, 0, &rcScreen, 0 );

    cxScreen = rcScreen.right - rcScreen.left;
    cyScreen = rcScreen.bottom - rcScreen.top;

    GetWindowRect( hwndDlg, &rc );

    cxDlg = rc.right - rc.left;
    cyDlg = rc.bottom - rc.top;

    y = rcScreen.top + ( ( cyScreen - cyDlg ) / 2 );
    x = rcScreen.left + ( ( cxScreen - cxDlg ) / 2 );

    SetWindowPos( hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE );
}

//
// Eats all mouse and keyboard messages.
//
void 
ClearMessageQueue( void )
{
    MSG   msg;

    while ( PeekMessage( (LPMSG)&msg, NULL, WM_KEYFIRST, WM_MOUSELAST, 
                PM_NOYIELD | PM_REMOVE ) );
}

//
// Create a message box from resource strings.
//
int
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType )
{
    TCHAR szText[ SMALL_BUFFER_SIZE ];
    TCHAR szCaption[ SMALL_BUFFER_SIZE ];
    DWORD dw;

    dw = LoadString( g_hinstance, idsCaption, szCaption, ARRAYSIZE( szCaption ) );
    Assert( dw );
    dw = LoadString( g_hinstance, idsText, szText, ARRAYSIZE( szText ) );
    Assert( dw );

    return MessageBox( hParent, szText, szCaption, uType );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\osdisp\osdisp.c ===
//
// DISPLAY OSCHOOSE SCREENS
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include <windows.h>
#include <winsock.h>

#undef ERROR

#include <stdio.h>


CHAR DomainName[64];
CHAR UserName[64];
CHAR Password[64];

VOID
BiosConsoleWrite(
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );


ULONG __cdecl
BiosConsoleGetKey(
    void
    );

ULONG __cdecl
BiosConsoleGetCounter(
    void
    );

#include "..\boot\oschoice\oscheap.c"
#define _BUILDING_OSDISP_
#include "..\boot\oschoice\parse.c"

#if DBG
ULONG NetDebugFlag =
        DEBUG_ERROR             |
        DEBUG_OSC;
#endif

//
// This is declared and expected by parse.c, so we defined the functions
// for the macros it uses (GET_KEY and GET_COUNTER) and NULL the rest out.
//

EXTERNAL_SERVICES_TABLE ServicesTable = {
    NULL,     // RebootProcessor
    NULL,     // DiskIOSystem
    BiosConsoleGetKey,
    BiosConsoleGetCounter,
    NULL,     // Reboot
    NULL,     // AbiosServices
    NULL,     // DetectHardware
    NULL,     // HardwareCursor
    NULL,     // GetDateTime
    NULL,     // ComPort
    NULL,     // IsMcaMachine
    NULL,     // GetStallCount
    NULL,     // InitializeDisplayForNt
    NULL,     // GetMemoryDescriptor
    NULL,     // GetEddsSector
    NULL,     // GetElToritoStatus
    NULL      // GetExtendedInt13Params
};
PEXTERNAL_SERVICES_TABLE ExternalServicesTable = &ServicesTable;

//
// This is used by the ArcWrite function -- it only cares about the firmware vector
// which is the 28th entry.
//

PVOID FirmwareVector[38] = {
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, (PVOID)BiosConsoleWrite, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL
};

SYSTEM_PARAMETER_BLOCK GlobalSystemBlock = {
    0,      // Signature
    0,      // Length
    0,      // Version
    0,      // Revision
    NULL,   // RestartBlock
    NULL,   // DebugBlock
    NULL,   // GenerateExceptionVector
    NULL,   // TlbMissExceptionVector
    sizeof(FirmwareVector),
    FirmwareVector,
    0,      // VendorVectorLength
    NULL,   // VendorVector
    0,      // AdapterCount
    0,      // Adapter0Type
    0,      // Adapter0Length
    NULL    // Adapter0Vector
};




//
// Current screen position.
//
USHORT TextColumn = 0;
USHORT TextRow  = 0;

//
// Height and width of the console.
//
USHORT ScreenWidthCells;
USHORT ScreenHeightCells;

//
// Current text attribute
//
UCHAR TextCurrentAttribute = 0x07;      // start with white on black.

//
// Standard input and output handles.
//
HANDLE StandardInput;
HANDLE StandardOutput;

UCHAR EightySpaces[] =
"                                                                                ";

//
// defines for doing console I/O
//
#define CSI 0x95
#define SGR_INVERSE 7
#define SGR_NORMAL 0

//
// static data for console I/O
//
BOOLEAN ControlSequence=FALSE;
BOOLEAN EscapeSequence=FALSE;
BOOLEAN FontSelection=FALSE;
BOOLEAN HighIntensity=FALSE;
BOOLEAN Blink=FALSE;
ULONG PCount=0;

#define CONTROL_SEQUENCE_MAX_PARAMETER 10
ULONG Parameter[CONTROL_SEQUENCE_MAX_PARAMETER];

#define KEY_INPUT_BUFFER_SIZE 16
UCHAR KeyBuffer[KEY_INPUT_BUFFER_SIZE];
ULONG KeyBufferEnd=0;
ULONG KeyBufferStart=0;

//
// array for translating between ANSI colors and the VGA standard
//
UCHAR TranslateColor[] = {0,4,2,6,1,5,3,7};

#define ASCI_ESC  0x1b


//
// Need this to link.
//

ULONG BlConsoleOutDeviceId = 0;



CHAR
BlProcessScreen(
    IN PCHAR InputString,
    OUT PCHAR OutputString
    );

CHAR g_OutputString[1024];

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    DWORD Error;
    int i;
    HANDLE hFile;
    DWORD fileSize, bytesRead;
    PCHAR fileBuffer;
    CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
    CONSOLE_CURSOR_INFO cursorInfo;
    COORD coord;
    PCHAR pszScreenName;
    CHAR LastKey;

    if (argc < 2) {
        printf("USAGE: %s [screen-file-name]\n", argv[0]);
        return -1;
    }

    //
    // Set up the console correctly. We allocate our own and resize
    // it to 80 x 25.
    //

    FreeConsole();
    AllocConsole();

    StandardInput = GetStdHandle(STD_INPUT_HANDLE);
    StandardOutput = GetStdHandle(STD_OUTPUT_HANDLE);

    ScreenWidthCells = 81;
    ScreenHeightCells = 25;

    coord.X = ScreenWidthCells;
    coord.Y = ScreenHeightCells;

    SetConsoleScreenBufferSize(StandardOutput, coord);

    //
    // This actually turns *off* most processing.
    //

    SetConsoleMode(StandardInput, ENABLE_PROCESSED_INPUT);

    //
    // Hide the cursor.
    //

    cursorInfo.dwSize = 1;
    cursorInfo.bVisible = FALSE;

    SetConsoleCursorInfo(StandardOutput, &cursorInfo);

    //
    // Open the first parameter as a file.
    //
    pszScreenName = argv[1];

NextScreen:
    hFile = CreateFileA(pszScreenName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);

    if (hFile == INVALID_HANDLE_VALUE ) {
        printf("Could not open %s!\n", argv[1]);
        return -1;
    }

    fileSize = GetFileSize(hFile, NULL);

    printf("File %s is %d bytes\n", argv[1], fileSize);

    fileBuffer = LocalAlloc(0, fileSize+1);
    if (fileBuffer == NULL) {
        printf("Allocate failed!\n");
        return -1;
    }

    if (!ReadFile(hFile, fileBuffer, fileSize, &bytesRead, NULL)) {
        printf("Read failed\n");
        return -1;
    }

    if (bytesRead != fileSize) {
        printf("Too few bytes read\n");
        return -1;
    }

    CloseHandle(hFile);

    fileBuffer[fileSize] = '\0';

    LastKey = BlProcessScreen(fileBuffer, g_OutputString);
    if (SpecialAction == ACTION_REFRESH)
        goto NextScreen;

    {
        PCHAR psz = strchr( g_OutputString, '\n' );
        if ( psz )
            *psz = '\0';
        pszScreenName = g_OutputString;
        if ( strcmp( pszScreenName, "REBOOT" ) != 0 
            && strcmp( pszScreenName, "LAUNCH" ) != 0 \
            && strcmp( pszScreenName, "" ) != 0 ) {
            // add the extension and jump to the next screen
            strcat( g_OutputString, ".osc" );
            goto NextScreen;
        }
    }
    //
    // I can't figure out how to write to the old console -- so for
    // now just display it and pause.
    //

    BlpClearScreen();

    SetConsoleTextAttribute(StandardOutput, 0x7);

    printf("String returned was <%s>\n", g_OutputString);
    printf("Press any key to exit\n");


    while (GET_KEY() == 0) {
        ;
    }

}



VOID
TextGetCursorPosition(
    OUT PULONG X,
    OUT PULONG Y
    )

/*++

Routine Description:

    Gets the position of the soft cursor.

Arguments:

    X - Receives column coordinate of where character would be written.

    Y - Receives row coordinate of where next character would be written.

Returns:

    Nothing.

--*/

{
    *X = (ULONG)TextColumn;
    *Y = (ULONG)TextRow;
}


VOID
TextSetCursorPosition(
    IN ULONG X,
    IN ULONG Y
    )

/*++

Routine Description:

    Moves the location of the software cursor to the specified X,Y position
    on screen.

Arguments:

    X - Supplies the X-position of the cursor

    Y - Supplies the Y-position of the cursor

Return Value:

    None.

--*/

{
    COORD coord;

    TextColumn = (USHORT)X;
    TextRow = (USHORT)Y;

    coord.X = (USHORT)X;
    coord.Y = (USHORT)Y;

    SetConsoleCursorPosition(StandardOutput, coord);
}


VOID
TextSetCurrentAttribute(
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Sets the character attribute to be used for subsequent text display.

Arguments:

Returns:

    Nothing.

--*/

{
    TextCurrentAttribute = Attribute;

    SetConsoleTextAttribute(StandardOutput, Attribute);
}


UCHAR
TextGetCurrentAttribute(
    VOID
    )
{
    return(TextCurrentAttribute);
}


PUCHAR
TextCharOut(
    IN PUCHAR pc
    )
{
    DWORD numWritten;

    WriteConsoleA(StandardOutput, pc, 1, &numWritten, NULL);

    return(pc+1);
}


VOID
TextClearToEndOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the line
    by writing blanks with the current video attribute.

Arguments:

    None

Returns:

    Nothing


--*/

{
    unsigned u;
    ULONG OldX,OldY;
    UCHAR temp;

    //
    // Fill with blanks up to char before cursor position.
    //
    temp = ' ';
    TextGetCursorPosition(&OldX,&OldY);
    for(u=TextColumn; u<ScreenWidthCells; u++) {
        TextCharOut(&temp);
    }
    TextSetCursorPosition(OldX,OldY);
}


VOID
TextClearFromStartOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the start of the line to the current cursor position
    by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    unsigned u;
    ULONG OldX,OldY;
    UCHAR temp = ' ';

    //
    // Fill with blanks up to char before cursor position.
    //
    TextGetCursorPosition(&OldX,&OldY);
    TextSetCursorPosition(0,OldY);
    for(u=0; u<TextColumn; u++) {
        TextCharOut(&temp);
    }
    TextSetCursorPosition(OldX,OldY);
}

VOID
TextClearToEndOfDisplay(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the video
    display by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    USHORT x,y;
    ULONG OldX,OldY;
    DWORD numWritten;

    TextGetCursorPosition(&OldX,&OldY);

    //
    // Clear current line
    //
    TextClearToEndOfLine();

    //
    // Clear the remaining lines
    //

    for(y=TextRow+1; y<ScreenHeightCells; y++) {

        TextSetCursorPosition(0, y);
        WriteConsoleA(StandardOutput, EightySpaces, ScreenWidthCells, &numWritten, NULL);

    }

    TextSetCursorPosition(OldX,OldY);
}


VOID
TextClearDisplay(
    VOID
    )

/*++

Routine Description:

    Clears the video display and positions the cursor
    at the upper left corner of the screen (0,0).

Arguments:

    None

Returns:

    Nothing

--*/

{
    USHORT y;
    DWORD numWritten;

    //
    // Clear screen.
    //
    for(y=0; y<ScreenHeightCells; y++) {

        TextSetCursorPosition(0, y);
        WriteConsoleA(StandardOutput, EightySpaces, ScreenWidthCells, &numWritten, NULL);

    }
    TextSetCursorPosition(0,0);
}



//
// This function was stolen from ..\lib\i386\biosdrv.c (except the return
// type was changed to VOID).
//

VOID
BiosConsoleWrite(
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Outputs to the console.  (In this case, the VGA display)

Arguments:

    FileId - Supplies the FileId to be written (should always be 1 for this
             function)

    Buffer - Supplies characters to be output

    Length - Supplies the length of the buffer (in bytes)

    Count  - Returns the actual number of bytes written

Return Value:

    ESUCCESS - Console write completed succesfully.

--*/
{
    ARC_STATUS Status;
    PUCHAR String;
    ULONG Index;
    UCHAR a;
    PUCHAR p;

    //
    // Process each character in turn.
    //

    Status = ESUCCESS;
    String = (PUCHAR)Buffer;

    for ( *Count = 0 ;
          *Count < Length ;
          (*Count)++, String++ ) {

        //
        // If we're in the middle of a control sequence, continue scanning,
        // otherwise process character.
        //

        if (ControlSequence) {

            //
            // If the character is a digit, update parameter value.
            //

            if ((*String >= '0') && (*String <= '9')) {
                Parameter[PCount] = Parameter[PCount] * 10 + *String - '0';
                continue;
            }

            //
            // If we are in the middle of a font selection sequence, this
            // character must be a 'D', otherwise reset control sequence.
            //

            if (FontSelection) {

                //if (*String == 'D') {
                //
                //    //
                //    // Other fonts not implemented yet.
                //    //
                //
                //} else {
                //}

                ControlSequence = FALSE;
                FontSelection = FALSE;
                continue;
            }

            switch (*String) {

            //
            // If a semicolon, move to the next parameter.
            //

            case ';':

                PCount++;
                if (PCount > CONTROL_SEQUENCE_MAX_PARAMETER) {
                    PCount = CONTROL_SEQUENCE_MAX_PARAMETER;
                }
                Parameter[PCount] = 0;
                break;

            //
            // If a 'J', erase part or all of the screen.
            //

            case 'J':

                switch (Parameter[0]) {
                    case 0:
                        //
                        // Erase to end of the screen
                        //
                        TextClearToEndOfDisplay();
                        break;

                    case 1:
                        //
                        // Erase from the beginning of the screen
                        //
                        break;

                    default:
                        //
                        // Erase entire screen
                        //
                        TextClearDisplay();
                        break;
                }

                ControlSequence = FALSE;
                break;

            //
            // If a 'K', erase part or all of the line.
            //

            case 'K':

                switch (Parameter[0]) {

                //
                // Erase to end of the line.
                //

                    case 0:
                        TextClearToEndOfLine();
                        break;

                    //
                    // Erase from the beginning of the line.
                    //

                    case 1:
                        TextClearFromStartOfLine();
                        break;

                    //
                    // Erase entire line.
                    //

                    default :
                        TextClearFromStartOfLine();
                        TextClearToEndOfLine();
                        break;
                }

                ControlSequence = FALSE;
                break;

            //
            // If a 'H', move cursor to position.
            //

            case 'H':
                TextSetCursorPosition(Parameter[1]-1, Parameter[0]-1);
                ControlSequence = FALSE;
                break;

            //
            // If a ' ', could be a FNT selection command.
            //

            case ' ':
                FontSelection = TRUE;
                break;

            case 'm':
                //
                // Select action based on each parameter.
                //
                // Blink and HighIntensity are by default disabled
                // each time a new SGR is specified, unless they are
                // explicitly specified again, in which case these
                // will be set to TRUE at that time.
                //

                HighIntensity = FALSE;
                Blink = FALSE;

                for ( Index = 0 ; Index <= PCount ; Index++ ) {
                    switch (Parameter[Index]) {

                    //
                    // Attributes off.
                    //

                    case 0:
                        TextSetCurrentAttribute(7);
                        HighIntensity = FALSE;
                        Blink = FALSE;
                        break;

                    //
                    // High Intensity.
                    //

                    case 1:
                        TextSetCurrentAttribute(0xf);
                        HighIntensity = TRUE;
                        break;

                    //
                    // Underscored.
                    //

                    case 4:
                        break;

                    //
                    // Blink.
                    //

                    case 5:
                        TextSetCurrentAttribute(0x87);
                        Blink = TRUE;
                        break;

                    //
                    // Reverse Video.
                    //

                    case 7:
                        TextSetCurrentAttribute(0x70);
                        HighIntensity = FALSE;
                        Blink = FALSE;
                        break;

                    //
                    // Font selection, not implemented yet.
                    //

                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                        break;

                    //
                    // Foreground Color
                    //

                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                        a = TextGetCurrentAttribute();
                        a &= 0x70;
                        a |= TranslateColor[Parameter[Index]-30];
                        if (HighIntensity) {
                            a |= 0x08;
                        }
                        if (Blink) {
                            a |= 0x80;
                        }
                        TextSetCurrentAttribute(a);
                        break;

                    //
                    // Background Color
                    //

                    case 40:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    case 47:
                        a = TextGetCurrentAttribute();
                        a &= 0x8f;
                        a |= TranslateColor[Parameter[Index]-40] << 4;
                        TextSetCurrentAttribute(a);
                        break;

                    default:
                        break;
                    }
                }

            default:
                ControlSequence = FALSE;
                break;
            }

        //
        // This is not a control sequence, check for escape sequence.
        //

        } else {

            //
            // If escape sequence, check for control sequence, otherwise
            // process single character.
            //

            if (EscapeSequence) {

                //
                // Check for '[', means control sequence, any other following
                // character is ignored.
                //

                if (*String == '[') {

                    ControlSequence = TRUE;

                    //
                    // Initialize first parameter.
                    //

                    PCount = 0;
                    Parameter[0] = 0;
                }
                EscapeSequence = FALSE;

            //
            // This is not a control or escape sequence, process single character.
            //

            } else {

                switch (*String) {
                    //
                    // Check for escape sequence.
                    //

                    case ASCI_ESC:
                        EscapeSequence = TRUE;
                        break;

                    default:
                        p = TextCharOut(String);
                        //
                        // Each pass through the loop increments String by 1.
                        // If we output a dbcs char we need to increment by
                        // one more.
                        //
                        (*Count) += (p - String) - 1;
                        String += (p - String) - 1;
                        break;
                }

            }
        }
    }
    return;
}


ULONG __cdecl
BiosConsoleGetKey(
    VOID
    )
{
    INPUT_RECORD inputRecord;
    DWORD numRead;

    //
    // Loop until we see a key event or nothing.
    //

    while (TRUE) {
    
        PeekConsoleInput(
            StandardInput,
            &inputRecord,
            1,
            &numRead);
    
        if (numRead == 0) {
    
            //
            // We read nothing -- sleep for a bit (since callers tend to loop
            // calling this) and return.
            //
    
            Sleep(100);
            return 0;
        }

        ReadConsoleInput(
            StandardInput,
            &inputRecord,
            1,
            &numRead);

        if (inputRecord.EventType != KEY_EVENT) {
            continue;
        }

        //
        // We had a key event -- process the key down ones.
        //

        if (inputRecord.Event.KeyEvent.bKeyDown) {

            //
            // Construct the correct scancode/ASCII value combination.
            //

            //
            // HACK: shift-tab needs to be special-cased for some reason.
            //

            if ((inputRecord.Event.KeyEvent.uChar.AsciiChar == 0x09) &&
                ((inputRecord.Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED) != 0)) {

                return 0x0f00;

            } else {
    
                return
                    (((inputRecord.Event.KeyEvent.wVirtualScanCode) & 0xff) << 8) +
                    inputRecord.Event.KeyEvent.uChar.AsciiChar;

            }

        }

    }

}

ULONG __cdecl
BiosConsoleGetCounter(
    VOID
    )
{
    //
    // GetTickCount is in milliseconds, we want an 18.2/sec counter
    //

    return (GetTickCount() * 182) / 10000;

}



//
// These two functions were taken from ..\lib\regboot.c.
//
VOID
BlpPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    )

/*++

Routine Description:

    Sets the position of the cursor on the screen.

Arguments:

    Column - supplies new Column for the cursor position.

    Row - supplies new Row for the cursor position.

Return Value:

    None.

--*/

{
    CHAR Buffer[16];
    ULONG Count;

    sprintf(Buffer, ASCI_CSI_OUT "%d;%dH", Row, Column);

    PRINTL(Buffer);

}


VOID
BlpClearScreen(
    VOID
    )

/*++

Routine Description:

    Clears the screen.

Arguments:

    None

Return Value:

    None.

--*/

{
    CHAR Buffer[16];
    ULONG Count;

    sprintf(Buffer, ASCI_CSI_OUT "2J");

    PRINTL(Buffer);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbinstal\pch.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

  File: PCH.H

  Precompiled header file for RBSETUP.
 
 ***************************************************************************/

#define UNICODE

#if DBG == 1
#define DEBUG
#endif

#include <windows.h>

#include "rbinstal.h"
#include "debug.h"
#include "utils.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbinstal\dialogs.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#ifndef _DIALOGS_H_
#define _DIALOGS_H_

BOOL CALLBACK 
WelcomeDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam );

BOOL CALLBACK 
RemoteBootDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam );

BOOL CALLBACK 
EULADlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam );

BOOL CALLBACK 
FinishDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam );

BOOL CALLBACK 
SourceDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam );

BOOL CALLBACK 
InfoDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam );

BOOL CALLBACK 
SetupDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam );

BOOL
WizardDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL CALLBACK 
OSDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam );

#endif // _DIALOGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbinstal\debug.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

  File: DEBUG.H

  Debugging utilities header
 
 ***************************************************************************/


#ifndef _DEBUG_H_
#define _DEBUG_H_

#if DBG==1

// Globals
extern DWORD g_TraceMemoryIndex;
extern DWORD g_dwCounter;
extern DWORD g_dwTraceFlags;

extern const TCHAR g_szTrue[];
extern const TCHAR g_szFalse[];

// Trace Flags
enum {
    TF_ALWAYS           = 0xFFFFFFFF,
    TF_NEVER            = 0x00000000,
    TF_QUERYINTERFACE   = 0x00000001,
    TF_FUNC             = 0x00000002,
    TF_CALLS            = 0x00000004,
    TF_MEMORYALLOCS     = 0x00000008
};


// Macros
#define DEFINE_MODULE( _module ) static const TCHAR g_szModule[] = TEXT(_module);
#define __MODULE__ g_szModule

// #define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#define DEBUG_BREAK { _asm int 3 }

#define INITIALIZE_TRACE_MEMORY     g_TraceMemoryIndex = TlsAlloc( ); TlsSetValue( g_TraceMemoryIndex, NULL)
#define UNINITIALIZE_TRACE_MEMORY   DebugMemoryCheck( )

#ifdef Assert
#undef Assert
#endif
#define Assert( _fn ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), !!(_fn) ) ) DEBUG_BREAK

#ifdef AssertMsg
#undef AssertMsg
#endif
#define AssertMsg( _fn, _msg ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), !!(_fn) ) ) DEBUG_BREAK

#define TraceAlloc( _flags, _size ) DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, _flags, _size, TEXT(#_size) )
#define TraceFree( _hmem )          DebugFree( _hmem )

// Tracing
#define TraceFunc( _msg ) \
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT(_msg) ); \
    g_dwCounter--; \

#define TraceClsFunc( _msg ) \
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("%s::%s"), TEXT(SZTHISCLASS), TEXT(_msg) );\
    g_dwCounter--; \

#define TraceDo( _fn ) {\
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("V\n") ); \
    g_dwCounter--; \
}

#define TraceMsgDo( _fn, _msg ) {\
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT(_msg), _fn ); \
    g_dwCounter--; \
}

#define DebugDo( _fn ) {\
    g_dwCounter++; \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("V\n") ); \
    g_dwCounter--; \
}

#define DebugMsgDo( _fn, _msg ) {\
    g_dwCounter++; \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("+ %s\n"), TEXT(#_fn) ); \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), _fn); \
    g_dwCounter--; \
}

// HRESULT testing
#define THR( _fn ) \
    TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn )

#define RRETURN( _fn ) \
    return TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn )

#define QIRETURN( _fn ) \
    if ( !!( TF_QUERYINTERFACE & g_dwTraceFlags ) )\
        return TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn ); \
    else if ( hr ) \
        DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("QueryInterface() failed()") ); \
    return _fn

#define RRETURN1( _fn, _ok ) {\
    TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), \
        ( ( _fn == _ok ) ? S_OK : _fn ) ); \
    return _fn;\
    }

// Thread-safe inc/decrements
#define InterlockDecrement( _var ) {\
    --_var;\
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_QUERYINTERFACE, TEXT("Decremented %s = %u\n"), TEXT(#_var), _var );\
    g_dwCounter--; \
     }
#define InterlockIncrement( _var ) {\
    ++_var;\
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_QUERYINTERFACE, TEXT("Incremented %s = %u\n"), TEXT(#_var), _var );\
    g_dwCounter--; \
    }

// Other
#define BOOLTOSTRING( _fBool ) ( !!(_fBool) ? g_szTrue : g_szFalse )

// Functions
void
TraceMsg( 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... );

void
DebugMsg( 
    LPCTSTR pszFormat,
    ... );

void
TraceMessage( 
    LPCTSTR pszFile, 
    UINT    uLine, 
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... );

void 
DebugMessage( 
    LPCTSTR pszFile, 
    UINT    uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszFormat,
    ... );

BOOL
AssertMessage( 
    LPCTSTR pszFile, 
    UINT    uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    BOOL    fTrue );

HRESULT
TraceHR( 
    LPCTSTR pszFile, 
    UINT    uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    HRESULT hr );

// Memory Functions
HGLOBAL
DebugAlloc( 
    LPCTSTR pszFile,
    UINT    uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

HGLOBAL
DebugFree( 
    HGLOBAL hMem );

HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    UINT    uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

#define DebugMemoryAddHandle( _handle ) \
    DebugMemoryAdd( _handle, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_MOVEABLE, 0, TEXT("_handle") );

#define DebugMemoryAddAddress( _pv ) \
    DebugMemoryAdd( _pv, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT("_pv") );

void
DebugMemoryDelete( 
    HGLOBAL hglobal );

void
DebugMemoryCheck( );

//
//
#else // it's RETAIL    ******************************************************
//
//

// Debugging -> NOPs
#define Assert( _fn )
#define DebugDo( _fn )
#define DebugMsgDo( _fn, _msg )
#define DEFINE_MODULE( _module )
#define AssertMsg               (void)
#define TraceMsg                (void)
#define DebugMsg                (void)
#define TraceMessage            (void)
#define DebugMessage            (void)
#define AssertMessage           (void)
#define TraceHR                 (void)
#define DebugMemoryAddHandle( _handle )
#define DebugMemoryAddAddress( _pv )

// Tracing -> just do operation
#define TraceDo( _flag, _fn )           _fn
#define TraceMsgDo( _flag, _fn, _msg )  _fn

// HRESULT testing -> do retail
#define THR
#define RRETURN( _fn )          return _fn
#define RRETURN( _fn, _ok );    return _fn

// Thread-safe inc/decrements -> do retail
#define InterlockDecrement( _var )      --_var
#define InterlockIncrement( _var )      ++_var

// Memory Functions -> do retail
#define TraceAlloc( _flags, _size )     GlobalAlloc( _flags, _size )
#define TraceFree( _pv )                GlobalFree( _pv )

#endif // DBG==1

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbinstal\dialogs.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#include "pch.h"

#include <windowsx.h>
#include <prsht.h>
#include <shlobj.h>
#include <setupapi.h>
#include <pshpack2.h>
#include <poppack.h>
#include <commctrl.h>   // includes the common control header


#include "setup.h"

DEFINE_MODULE("Dialogs");

#define WIZPAGE_FULL_PAGE_WATERMARK 0x00000001
#define WIZPAGE_SEPARATOR_CREATED   0x00000002

#define SMALL_BUFFER_SIZE   256

#define BITMAP_WIDTH    16
#define BITMAP_HEIGHT   16
#define LG_BITMAP_WIDTH	32
#define LG_BITMAP_HEIGHT 32

//
// Stuff used for watermarking
//
CONST BITMAPINFOHEADER *g_pbihWatermark;
PVOID       g_pWatermarkBitmapBits;
HPALETTE    g_hWatermarkPalette;
INT         g_uWatermarkPaletteColorCount;
WNDPROC     g_OldWizardProc;

//
// Enum for SetDialogFont().
//
typedef enum {
    DlgFontTitle,
    DlgFontBold
} MyDlgFont;


VOID
SetDialogFont(
    IN HWND      hdlg,
    IN UINT      ControlId,
    IN MyDlgFont WhichFont
    )
{
    static HFONT BigBoldFont = NULL;
    static HFONT BoldFont    = NULL;
    static HFONT NormalFont  = NULL;
    HFONT Font;
    LOGFONT LogFont;
    TCHAR FontSizeString[24];
    int FontSize;
    HDC hdc;
	DWORD dw;

    switch(WhichFont) {

    case DlgFontTitle:

        if(!BigBoldFont) {

            if ( Font = 
                (HFONT) SendDlgItemMessage( hdlg, ControlId, WM_GETFONT, 0, 0) )
            {
                if ( GetObject( Font, sizeof(LOGFONT), &LogFont) )
                {
                    dw = LoadString( g_hinstance, 
                                        IDS_LARGEFONTNAME, 
                                        LogFont.lfFaceName, 
                                        LF_FACESIZE);
					Assert( dw );
                    LogFont.lfWeight = 700;
                    FontSize = 15;

                    if ( hdc = GetDC(hdlg) )
                    {
                        LogFont.lfHeight = 
                            0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

                        BigBoldFont = CreateFontIndirect(&LogFont);

                        ReleaseDC(hdlg,hdc);
                    }
                }
            }
        }
        Font = BigBoldFont;
        break;

    case DlgFontBold:

        if ( !BoldFont ) 
        {
            if ( Font = 
                (HFONT) SendDlgItemMessage( hdlg, ControlId, WM_GETFONT, 0, 0 ))
            {
                if ( GetObject( Font, sizeof(LOGFONT), &LogFont ) ) 
                {

                    LogFont.lfWeight = FW_BOLD;

                    if ( hdc = GetDC( hdlg ) ) 
                    {
                        BoldFont = CreateFontIndirect( &LogFont );
                        ReleaseDC( hdlg, hdc );
                    }
                }
            }
        }
        Font = BoldFont;
        break;

    default:
        //
        // Nothing to do here.
        //
        Font = NULL;
        break;
    }

    if( Font ) 
    {
        SendDlgItemMessage( hdlg, ControlId, WM_SETFONT, (WPARAM) Font, 0 );
    }
}

//
// Paints the watermark.
//
BOOL
PaintWatermark(
    IN HWND hdlg,
    IN HDC  DialogDC,
    IN UINT XOffset,
    IN UINT YOffset,
    IN UINT YHeight )
{
    HPALETTE OldPalette;
    RECT     rect;
    int      Height;
    int      Width;

    OldPalette = SelectPalette( DialogDC, g_hWatermarkPalette, TRUE );

    Width  = g_pbihWatermark->biWidth - ( 2 * XOffset );
    Height = ( YHeight ? YHeight : g_pbihWatermark->biHeight ) - YOffset;

    SetDIBitsToDevice(
        DialogDC, 
        0, 
        0, 
        Width, 
        Height, 
        XOffset,
        YHeight ? ( g_pbihWatermark->biHeight - YHeight ) : YHeight,
        0, g_pbihWatermark->biHeight,
        g_pWatermarkBitmapBits,
        (BITMAPINFO *) g_pbihWatermark,
        DIB_RGB_COLORS );

    GetClientRect( hdlg, &rect );
    if ( Height && Height < rect.bottom ) 
    {
        ExcludeClipRect( DialogDC, 0, 0, Width + 2 * XOffset, Height );
        return FALSE;
    }

    return TRUE;
}

//
// Paints the watermark background within an HWND
//
BOOL
PaintBackgroundWithWatermark(
    HWND hDlg,
    HWND hwnd,
    HDC  hDC )
{
    RECT rc1, rc2;
    RECT rcDivider;
    HWND hwndDivider = GetDlgItem( hDlg, IDC_DIVIDER );

    GetClientRect( GetParent( hDlg ), &rc1 );
    MapWindowPoints( GetParent( hDlg ), NULL, (POINT *) &rc1, 2 );

    GetClientRect( hwnd, &rc2 );
    MapWindowPoints( hwnd, NULL, (POINT *) &rc2, 2 );

    if ( hwndDivider )
    {
        GetClientRect( hwndDivider, &rcDivider );
        MapWindowPoints( hwndDivider, GetParent( hDlg ), 
                         (POINT *) &rcDivider, 2 );
    }
    else
    {
        rcDivider.top = 0;
    }

    return PaintWatermark( hwnd, hDC, rc2.left-rc1.left, 
                        rc2.top-rc1.top, rcDivider.top );
}

//
// Check to see if the directory exists. If not, ask the user if we
// should create it.
//
BOOL
CheckDirectory( HWND hDlg, LPTSTR pszPath, BOOL fAllowCreate )
{
    BOOL  fReturn  = FALSE;
    WIN32_FILE_ATTRIBUTE_DATA fad;
    DWORD dwAttrib = GetFileAttributes( pszPath );

    if ( dwAttrib == 0xFFFFffff )
    {
        if ( ERROR_FILE_NOT_FOUND == GetLastError( ) )
        {
            if ( fAllowCreate &&
                IDYES == MessageBoxFromStrings( hDlg, IDS_CREATEDIRCAPTION, IDS_CREATEDIRTEXT, MB_YESNO ) )
            {
                g_Options.fCreateDirectory = TRUE;
                fReturn = TRUE;
                goto Cleanup;
            }
            else if ( !fAllowCreate )
            {
                MessageBoxFromStrings( hDlg, IDS_DIRDOESNOTEXISTCAPTION, IDS_DIRDOESNOTEXISTTEXT, MB_OK );
            }
        }
        goto Cleanup;
    }

    fReturn = TRUE;

Cleanup:
    SetWindowLong( hDlg, DWL_MSGRESULT, (fReturn ? 0 : -1 ) );
    return fReturn;
}

//
// Adjusts and draws a bitmap transparently in the RECT prc.
//
void DrawBitmap( 
    HANDLE hBitmap,
    LPDRAWITEMSTRUCT lpdis,
    LPRECT prc )
{
    BITMAP  bm;
    HDC     hDCBitmap;
    int     dy;

    GetObject( hBitmap, sizeof(bm), &bm );

    hDCBitmap = CreateCompatibleDC( NULL );
    SelectObject( hDCBitmap, hBitmap );

    // center the image
    dy = 2 + prc->bottom - bm.bmHeight;

    StretchBlt( lpdis->hDC, prc->left, prc->top + dy, prc->right, prc->bottom, 
          hDCBitmap, 0, 0, bm.bmWidth, bm.bmHeight, SRCAND );

    DeleteDC( hDCBitmap );
}

//
// Draws a bitmap transparently in reponse to a WM_DRAWITEM
//
void 
DrawBitmap(
    HANDLE hBitmap,
    LPDRAWITEMSTRUCT lpdis )
{
    HDC     hDCBitmap;

    hDCBitmap = CreateCompatibleDC( NULL );
    SelectObject( hDCBitmap, hBitmap );
    BitBlt( lpdis->hDC, 0, 0, lpdis->rcItem.right, lpdis->rcItem.bottom, 
            hDCBitmap, 0, 0, SRCAND );
    DeleteDC( hDCBitmap );
}

//
// Verifies that the user wanted to cancel setup.
//
BOOL 
VerifyCancel( HWND hParent )
{
    TCHAR szText[ SMALL_BUFFER_SIZE ];
    TCHAR szCaption[ SMALL_BUFFER_SIZE ];

    dw = LoadString( g_hinstance, IDS_CANCELCAPTION, szCaption, 
        ARRAYSIZE( szCaption ));
	Assert( dw );
    dw = LoadString( g_hinstance, IDS_CANCELTEXT, szText, 
        ARRAYSIZE( szText ));
	Assert( dw );

    g_Options.fAbort = 
        ( IDYES == MessageBoxFromStrings( hParent, 
                                          IDS_CANCELCAPTION, 
                                          IDS_CANCELTEXT, 
                                          MB_YESNO ) );
    
    SetWindowLong( hParent, DWL_MSGRESULT, ( g_Options.fAbort ? 0 : - 1 ) );    

    return !g_Options.fAbort;
}

//
// Base dialog proc - all unhandled calls are passed here. If they are not
// handled here, then the default dialog proc will handle them.
//
BOOL CALLBACK 
BaseDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            SetDialogFont( hDlg, IDC_S_TITLE1, DlgFontTitle );
            //SetDialogFont( hDlg, IDC_S_TITLE2, DlgFontTitle );
            //SetDialogFont( hDlg, IDC_S_TITLE3, DlgFontTitle );
            SetDialogFont( hDlg, IDC_S_BOLD1,  DlgFontBold  );
            SetDialogFont( hDlg, IDC_S_BOLD2,  DlgFontBold  );
            SetDialogFont( hDlg, IDC_S_BOLD3,  DlgFontBold  );
            break;

        case WM_DRAWITEM:
            if ( LOWORD( wParam ) >= IDC_I_BUTTON1 && 
                 LOWORD( wParam ) <= IDC_I_BUTTON7 )
                DrawBitmap( g_hGraphic, (LPDRAWITEMSTRUCT) lParam );
            break;

        case WM_PALETTECHANGED:
            if ((HWND)wParam != hDlg)
            {
                InvalidateRect(hDlg, NULL, NULL);
                UpdateWindow(hDlg);
            }
            break;

        case WM_ERASEBKGND:
            return PaintBackgroundWithWatermark( hDlg, hDlg, (HDC) wParam );

        case WM_CTLCOLORSTATIC:
            if ( LOWORD( wParam ) == IDC_DIVIDER )
            {
                return FALSE;
            }
            else
            {
                // erase background
                PaintBackgroundWithWatermark( hDlg, (HWND) lParam, (HDC) wParam );

                // setup transparent mode
                SetBkMode( (HDC) wParam, TRANSPARENT );
                SetBkColor( (HDC) wParam, GetSysColor( COLOR_3DFACE ) );
                return( (BOOL) GetStockObject( HOLLOW_BRUSH ) );
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}
//
// "Welcome's" (the first page's) dialog proc.
//
BOOL CALLBACK 
WelcomeDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;
    static BOOL fFirstTime = FALSE;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            CenterDialog( GetParent( hDlg ) );
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );

        case WM_NOTIFY:
            lpnmhdr = (NMHDR FAR *) lParam;
            switch ( lpnmhdr->code )
            {
                // ignore these
                case PSN_KILLACTIVE:
                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                case PSN_RESET:
                    SetWindowLong( hDlg, DWL_MSGRESULT, FALSE );
                    break;

                case PSN_QUERYCANCEL:
                    return VerifyCancel( hDlg );
                    break;

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT );
                    ClearMessageQueue( );

                    // eliminate flicker
                    if ( !fFirstTime )
                    {
                        fFirstTime = TRUE;
                    }
                    else
                    {
                        PostMessage( GetParent(hDlg), WMX_FORCEDREPAINT, 0, NULL );
                    }
                    break;

                case PSN_HELP:
                    // 
                    // TODO: Add help
                    //
                    break;

                default:
                    AssertMsg( FALSE, "Unhandled PSN message" );
                    return FALSE;
            }
            break;

        default:
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}


//
// Remote Boot Directory dialog proc.
//
BOOL CALLBACK 
RemoteBootDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;
	DWORD dw;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            Edit_SetText( GetDlgItem( hDlg, IDC_E_RBPATH), g_Options.szRemoteBootPath );
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );

        case WM_NOTIFY:
            lpnmhdr = (NMHDR FAR *) lParam;
            switch ( lpnmhdr->code )
            {
                // ignore these
                case PSN_WIZBACK:
                case PSN_KILLACTIVE:
                case PSN_RESET:
                    SetWindowLong( hDlg, DWL_MSGRESULT, FALSE );
                    break;

                case PSN_WIZNEXT:
                    Edit_GetText( GetDlgItem( hDlg, IDC_E_RBPATH ), g_Options.szRemoteBootPath, ARRAYSIZE( g_Options.szRemoteBootPath ));
                    g_Options.fCreateDirectory = FALSE;
                    CheckDirectory( hDlg, g_Options.szRemoteBootPath, TRUE );
                    break;

                case PSN_QUERYCANCEL:
                    return VerifyCancel( hDlg );
                    break;

                case PSN_SETACTIVE:
                    if ( g_Options.fError || g_Options.fKnowRBDirectory )
                    {
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );   // do not show this page
                    }
                    else
                    {
                        DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_RBPATH) );
                        PropSheet_SetWizButtons( GetParent( hDlg ), 
                            dwLen ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK );
                        ClearMessageQueue( );

                        PostMessage( GetParent(hDlg), WMX_FORCEDREPAINT, 0, (LPARAM) GetDlgItem( hDlg, IDC_DIVIDER ) );
                    }
                    break;

                case PSN_HELP:
                    // 
                    // TODO: Add help
                    //
                    break;

                default:
                    AssertMsg( FALSE, "Unhandled PSN message" );
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch( LOWORD( wParam))
            {
                case IDC_E_RBPATH:
                {
                    if ( HIWORD(wParam) == EN_CHANGE )
                    {
                        DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_RBPATH) );
                        PropSheet_SetWizButtons( GetParent( hDlg ), 
                            dwLen ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK );
                    }
                }
                break;

                case IDC_B_BROWSE:
                    {
                        TCHAR szTitle[ SMALL_BUFFER_SIZE ];
                        BROWSEINFO bs;
                        ZeroMemory( &bs, sizeof(bs) );
                        bs.hwndOwner = hDlg;
                        dw = LoadString( g_hinstance, IDS_BROWSECAPTION_RBDIR, szTitle, ARRAYSIZE( szTitle ) );
						Assert( dw );
                        bs.lpszTitle = (LPTSTR) &szTitle;
                        bs.ulFlags = BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS;
                        LPITEMIDLIST pidl = SHBrowseForFolder( &bs );
                        SHGetPathFromIDList( pidl, g_Options.szRemoteBootPath );
                        Edit_SetText( GetDlgItem( hDlg, IDC_E_RBPATH ), g_Options.szRemoteBootPath );
                    }
                    break;

                default:
                    break;
            }
            break;

        default:
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// OS Name dialog proc.
//
BOOL CALLBACK 
OSDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            Edit_SetText( GetDlgItem( hDlg, IDC_E_OSNAME ), g_Options.szName );
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );

        case WM_NOTIFY:
            lpnmhdr = (NMHDR FAR *) lParam;
            switch ( lpnmhdr->code )
            {
                // ignore these
                case PSN_KILLACTIVE:
                case PSN_WIZBACK:
                case PSN_RESET:
                    SetWindowLong( hDlg, DWL_MSGRESULT, FALSE );
                    break;

                case PSN_WIZNEXT:
                    Edit_GetText( GetDlgItem( hDlg, IDC_E_OSNAME ), g_Options.szName, ARRAYSIZE( g_Options.szName ) );
                    break;

                case PSN_QUERYCANCEL:
                    return VerifyCancel( hDlg );
                    break;

                case PSN_SETACTIVE:
                    {
                        if ( g_Options.fError )
                        {
                            SetWindowLong( hDlg, DWL_MSGRESULT, -1 );   // do not show this page
                        }

                        DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_OSNAME) );
                        PropSheet_SetWizButtons( GetParent( hDlg ), 
                            dwLen ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK );
                        ClearMessageQueue( );

                        PostMessage( GetParent(hDlg), WMX_FORCEDREPAINT, 0, (LPARAM) GetDlgItem( hDlg, IDC_DIVIDER ) );
                    }
                    break;

                case PSN_HELP:
                    // 
                    // TODO: Add help
                    //
                    break;

                default:
                    AssertMsg( FALSE, "Unhandled PSN message" );
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch( LOWORD( wParam))
            {
                case IDC_E_OSNAME:
                {
                    if ( HIWORD(wParam) == EN_CHANGE )
                    {
                        DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_OSNAME ) );
                        PropSheet_SetWizButtons( GetParent( hDlg ), 
                            dwLen ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK );
                    }
                }
                break;
            }
            break;

        default:
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}


//
// Remote Boot Directory dialog proc.
//
BOOL CALLBACK 
SourceDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;
	DWORD dw;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            Edit_SetText( GetDlgItem( hDlg, IDC_E_SOURCEPATH ), g_Options.szSourcePath );
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );

        case WM_NOTIFY:
            lpnmhdr = (NMHDR FAR *) lParam;
            switch ( lpnmhdr->code )
            {
                // ignore these
                case PSN_KILLACTIVE:
                case PSN_WIZBACK:
                case PSN_RESET:
                    SetWindowLong( hDlg, DWL_MSGRESULT, FALSE );
                    break;

                case PSN_WIZNEXT:
                    {
                        DWORD   dwLen;

                        Edit_GetText( GetDlgItem( hDlg, IDC_E_SOURCEPATH ), g_Options.szSourcePath, ARRAYSIZE( g_Options.szSourcePath ) );

                        dwLen = lstrlen( g_Options.szSourcePath ) - 1;
                        if ( g_Options.szSourcePath[ dwLen ] == TEXT('\\') )
                        {
                            g_Options.szSourcePath[ dwLen ] = 0;
                        }

                        if ( CheckDirectory( hDlg, g_Options.szSourcePath, FALSE ) )
                        {
                            HANDLE hFile;

                            hFile = OpenLayoutInf( );

                            if ( hFile == INVALID_HANDLE_VALUE )
                            {
                                MessageBoxFromStrings( hDlg, IDS_INVALIDSOURCECAPTION, IDS_INVALIDSOURCETEXT, MB_OK );
                                SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                            }
                            else
                            {
                                SetupCloseInfFile( hFile );
                            }
                        }
                        g_Options.fIntel = 
                            ( ( 0x0003 & Button_GetState( GetDlgItem( hDlg, IDC_C_INTEL ) ) ) ==
                              BST_CHECKED );
                        g_Options.fAlpha = 
                            ( ( 0x0003 & Button_GetState( GetDlgItem( hDlg, IDC_C_ALPHA ) ) ) ==
                              BST_CHECKED );
                    }
                    break;

                case PSN_QUERYCANCEL:
                    return VerifyCancel( hDlg );
                    break;

                case PSN_SETACTIVE:
                    {
                        PostMessage( GetParent(hDlg), WMX_FORCEDREPAINT, 0, (LPARAM) GetDlgItem( hDlg, IDC_DIVIDER ) );
                        DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_SOURCEPATH) );
                        PropSheet_SetWizButtons( GetParent( hDlg ), 
                            dwLen ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK );
                        ClearMessageQueue( );
                    }
                    break;

                case PSN_HELP:
                    // 
                    // TODO: Add help
                    //
                    break;

                default:
                    AssertMsg( FALSE, "Unhandled PSN message" );
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch( LOWORD( wParam))
            {
                case IDC_E_SOURCEPATH:
                    if ( HIWORD(wParam) != EN_CHANGE )
                        return BaseDlgProc( hDlg, uMsg, wParam, lParam );
                    // fall thru...
                case IDC_C_INTEL:
                case IDC_C_ALPHA:
                    {
                        g_Options.fIntel = 
                            ( ( 0x0003 & Button_GetState( GetDlgItem( hDlg, IDC_C_INTEL ) ) ) ==
                              BST_CHECKED );
                        g_Options.fAlpha = 
                            ( ( 0x0003 & Button_GetState( GetDlgItem( hDlg, IDC_C_ALPHA ) ) ) ==
                              BST_CHECKED );
                        DWORD dwLen = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_SOURCEPATH ) );
                        PropSheet_SetWizButtons( GetParent( hDlg ), 
                            ( dwLen && ( g_Options.fIntel || g_Options.fAlpha )) ? 
                                PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK );
                    }
                    break;

                case IDC_B_BROWSE:
                    {
                        TCHAR szTitle[ SMALL_BUFFER_SIZE ];
                        BROWSEINFO bs;
                        ZeroMemory( &bs, sizeof(bs) );
                        bs.hwndOwner = hDlg;
                        dw = LoadString( g_hinstance, IDS_BROWSECAPTION_SOURCEDIR, szTitle, ARRAYSIZE( szTitle ) );
						Assert( dw );
                        bs.lpszTitle = (LPTSTR) &szTitle;
                        bs.ulFlags = BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS;
                        LPITEMIDLIST pidl = SHBrowseForFolder( &bs );
                        SHGetPathFromIDList( pidl, g_Options.szSourcePath );
                        Edit_SetText( GetDlgItem( hDlg, IDC_E_SOURCEPATH ), g_Options.szSourcePath );
                    }
                    break;

                default:
                    break;
            }
            break;

        case WM_CTLCOLORSTATIC:
            if ( (HWND) lParam != GetDlgItem( hDlg, IDC_C_INTEL ) &&
                 (HWND) lParam != GetDlgItem( hDlg, IDC_C_ALPHA) )
            {
                return BaseDlgProc( hDlg, uMsg, wParam, lParam );
            }
            return FALSE;


        default:
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// Information dialog proc.
//
BOOL CALLBACK 
InfoDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;
	DWORD dw;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            {
                TCHAR szText[ SMALL_BUFFER_SIZE ] = { 0 };
                DWORD dwLen = 0;

                if ( g_Options.fIntel )
                {
                    dw = LoadString( g_hinstance, IDS_INTEL, szText, ARRAYSIZE( szText ) );
					Assert( dw );

                    if ( g_Options.fAlpha )
                    {
                        dwLen = lstrlen( szText );
                        szText[ dwLen++ ] = TEXT(' ');

                        dw = LoadString( g_hinstance, IDS_AND, &szText[ dwLen ], ARRAYSIZE( szText ) - dwLen );
						Assert( dw );

                        dwLen = lstrlen( szText );
                        szText[ dwLen++ ] = TEXT(' ');
                    }
                }

                if ( g_Options.fAlpha )
                {
                    dw = LoadString( g_hinstance, IDS_ALPHA, &szText[ dwLen ], ARRAYSIZE( szText ) - dwLen );
					Assert( dw );
                }

                SetDlgItemInt(  hDlg, IDC_S_CLIENTS,    70, FALSE );
                SetDlgItemText( hDlg, IDC_S_SOURCEPATH, g_Options.szSourcePath );
                SetDlgItemText( hDlg, IDC_S_PLATFORM,   szText );
                SetDlgItemText( hDlg, IDC_S_REMOTEBOOT, g_Options.szRemoteBootPath );
            }
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );

        case WM_NOTIFY:
            lpnmhdr = (NMHDR FAR *) lParam;
            switch ( lpnmhdr->code )
            {
                // ignore these
                case PSN_KILLACTIVE:
                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                case PSN_RESET:
                    SetWindowLong( hDlg, DWL_MSGRESULT, FALSE );
                    break;

                case PSN_QUERYCANCEL:
                    return VerifyCancel( hDlg );
                    break;

                case PSN_SETACTIVE:
                    if ( g_Options.fError )
                    {
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );   // do not show this page
                    }
                    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK);
                    ClearMessageQueue( );
                    PostMessage( GetParent(hDlg), WMX_FORCEDREPAINT, 0, (LPARAM) GetDlgItem( hDlg, IDC_DIVIDER ) );
                    break;

                case PSN_HELP:
                    // 
                    // TODO: Add help
                    //
                    break;

                default:
                    AssertMsg( FALSE, "Unhandled PSN message" );
                    return FALSE;
            }
            break;

        default:
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

enum { STATE_NOTSTARTED, STATE_STARTED, STATE_DONE, STATE_ERROR };

typedef HRESULT (*PFNOPERATION)( HWND hDlg );

typedef struct {
    HANDLE hChecked;
    HANDLE hError;
    HANDLE hArrow;
    HANDLE hFontNormal;
    HANDLE hFontBold;
    int    dwWidth;
    int    dwHeight;
} SETUPDLGDATA, *LPSETUPDLGDATA;

typedef struct {
    UINT   uState;
    UINT   rsrcId;
    PFNOPERATION pfn;
    TCHAR  szText[ SMALL_BUFFER_SIZE ];
} LBITEMDATA, *LPLBITEMDATA;

LBITEMDATA items[] = {
    { STATE_NOTSTARTED, IDS_CREATINGDIRECTORYTREE, CreateDirectories,       TEXT("") },
    { STATE_NOTSTARTED, IDS_COPYINGFILES,          CopyFiles,               TEXT("") },
    { STATE_NOTSTARTED, IDS_UPDATINGREGISTRY,      ModifyRegistry,          TEXT("") },
    { STATE_NOTSTARTED, IDS_STARTING_SERVICES,     StartRemoteBootServices, TEXT("") },
    { STATE_NOTSTARTED, IDS_CREATINGSHARES,        CreateRemoteBootShare,   TEXT("") }
};

//
// Setup dialog proc.
//
BOOL CALLBACK 
SetupDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam )
{
    static BOOL bDoneFirstPass;
    LPSETUPDLGDATA psdd = (LPSETUPDLGDATA) GetWindowLong( hDlg, GWL_USERDATA );
	DWORD dw;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            {
                BITMAP bm;
                // grab the bitmaps
                psdd = 
                    (LPSETUPDLGDATA) TraceAlloc( GMEM_FIXED, sizeof(SETUPDLGDATA) );

                psdd->hChecked = LoadImage( g_hinstance, 
                                            MAKEINTRESOURCE( IDB_CHECK ), 
                                            IMAGE_BITMAP, 
                                            0, 0, 
                                            LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
                DebugMemoryAddHandle( psdd->hChecked );
                GetObject( psdd->hChecked, sizeof(bm), &bm );
                psdd->dwWidth = bm.bmWidth;

                psdd->hError   = LoadImage( g_hinstance, 
                                            MAKEINTRESOURCE( IDB_X ), 
                                            IMAGE_BITMAP, 
                                            0, 0, 
                                            LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
                DebugMemoryAddHandle( psdd->hError );
                GetObject( psdd->hError, sizeof(bm), &bm );
                psdd->dwWidth = ( psdd->dwWidth > bm.bmWidth ? psdd->dwWidth : bm.bmWidth );

                psdd->hArrow   = LoadImage( g_hinstance, 
                                            MAKEINTRESOURCE( IDB_ARROW ), 
                                            IMAGE_BITMAP, 
                                            0, 0, 
                                            LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
                DebugMemoryAddHandle( psdd->hArrow );
                GetObject( psdd->hArrow, sizeof(bm), &bm );
                psdd->dwWidth = ( psdd->dwWidth > bm.bmWidth ? 
                                  psdd->dwWidth : 
                                  bm.bmWidth );

                HWND    hwnd = GetDlgItem( hDlg, IDC_L_SETUP );

                HFONT hFontOld = (HFONT) SendMessage( hwnd, WM_GETFONT, 0, 0);
                if(hFontOld != NULL)
                {
                    LOGFONT lf;
                    if ( GetObject( hFontOld, sizeof(LOGFONT), (LPSTR) &lf ) )
                    {
                        dw = LoadString( g_hinstance, 
                                            IDS_LARGEFONTNAME, 
                                            lf.lfFaceName, 
                                            LF_FACESIZE );
						Assert( dw );
                        lf.lfWidth = 0;
                        lf.lfWeight = 400;
                        lf.lfHeight -= 4;
                        psdd->hFontNormal = CreateFontIndirect(&lf);
                        DebugMemoryAddHandle( psdd->hFontNormal );

                        lf.lfWeight = 700;
                        psdd->hFontBold = CreateFontIndirect(&lf);
                        DebugMemoryAddHandle( psdd->hFontBold );
                    }
                }

                HDC hDC = GetDC( NULL );
                HANDLE hOldFont = SelectObject( hDC, psdd->hFontBold );
                TEXTMETRIC tm;
                GetTextMetrics( hDC, &tm );
                psdd->dwHeight = tm.tmHeight + 2;
                SelectObject( hDC, hOldFont );
                ReleaseDC( NULL, hDC );

                ListBox_SetItemHeight( hwnd, -1, psdd->dwHeight );

                SetWindowLong( hDlg, GWL_USERDATA, (LONG) psdd );

                for( int i = 0; i < ARRAYSIZE(items); i++ )
                {
                    dw = LoadString( g_hinstance, 
                                        items[ i ].rsrcId, 
                                        items[ i ].szText, 
                                        ARRAYSIZE( items[ i ].szText ) );
					Assert( dw );
                    ListBox_AddString( hwnd, &items[ i ] );
                }

                bDoneFirstPass = FALSE;
            }
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );

        case WM_DESTROY:
            {
                Assert( psdd );
                DeleteObject( psdd->hChecked );
                DebugMemoryDelete( psdd->hChecked );
                DeleteObject( psdd->hError );
                DebugMemoryDelete( psdd->hError );
                DeleteObject( psdd->hArrow );
                DebugMemoryDelete( psdd->hArrow );               
                DeleteObject( psdd->hFontNormal );
                DebugMemoryDelete( psdd->hFontNormal );               
                DeleteObject( psdd->hFontBold );
                DebugMemoryDelete( psdd->hFontBold );               
                TraceFree( psdd );
                SetWindowLong( hDlg, GWL_USERDATA, NULL );
            }
            break;

        case WM_NOTIFY:
            {
                NMHDR FAR   *lpnmhdr = (NMHDR FAR *) lParam;
                switch ( lpnmhdr->code )
                {
                    // ignore these
                    case PSN_KILLACTIVE:
                    case PSN_WIZNEXT:
                    case PSN_WIZBACK:
                    case PSN_RESET:
                        SetWindowLong( hDlg, DWL_MSGRESULT, FALSE );
                        break;

                    case PSN_QUERYCANCEL:
                        return VerifyCancel( hDlg );
                        break;

                    case PSN_SETACTIVE:
                        if ( g_Options.fError )
                        {
                            SetWindowLong( hDlg, DWL_MSGRESULT, -1 );   // do not show this page
                        }
                        PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
                        PostMessage( GetParent(hDlg), WMX_FORCEDREPAINT, 0, (LPARAM) GetDlgItem( hDlg, IDC_DIVIDER ) );
                        ClearMessageQueue( );
                        break;

                    case PSN_HELP:
                        // 
                        // TODO: Add help
                        //
                        break;

                    default:
                        //AssertMsg( FALSE, "Unhandled PSN message" );
                        return FALSE;
                }
            }
            break;

        case WM_STARTSETUP:
            {
                HWND hwnd = GetDlgItem( hDlg, IDC_L_SETUP );
                RECT rc;
                
                GetClientRect( hwnd, &rc );
                
                for( int i = 0; i < ARRAYSIZE( items ) && !g_Options.fError; i++ )
                {
                    items[ i ].uState = STATE_STARTED;
                    InvalidateRect( hwnd, &rc, TRUE );

                    items[ i ].uState = items[ i ].pfn( hDlg ) ? 
                                        STATE_ERROR :   // not S_OK
                                        STATE_DONE;     // S_OK
                    InvalidateRect( hwnd, &rc, TRUE );
                }
                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_FINISH );
            }
            break;

        case WM_CTLCOLORLISTBOX:
            // cheat by changing the message
            return BaseDlgProc( hDlg, WM_CTLCOLORSTATIC, wParam, lParam );

        case WM_CTLCOLORSTATIC:
            if ( (HWND) lParam != GetDlgItem( hDlg, IDC_S_OPERATION ) &&
                 (HWND) lParam != GetDlgItem( hDlg, IDC_G_OPERATION ) )
            {
                return BaseDlgProc( hDlg, uMsg, wParam, lParam );
            }
            return FALSE;

        case WM_MEASUREITEM:
            {
                LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT) lParam;
                RECT    rc;                
                HWND    hwnd = GetDlgItem( hDlg, IDC_L_SETUP );

                GetClientRect( hwnd, &rc );

                lpmis->itemWidth = rc.right - rc.left;
                lpmis->itemHeight = 15;
            }
            break;

        case WM_DRAWITEM:
            {
                Assert( psdd );

                LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam;
                LPLBITEMDATA plbid = (LPLBITEMDATA) lpdis->itemData;
                RECT rc = lpdis->rcItem;
                HANDLE hOldFont = INVALID_HANDLE_VALUE;

                rc.right = rc.bottom = psdd->dwWidth;
                
                switch ( plbid->uState )
                {
                    case STATE_NOTSTARTED:
                        hOldFont = SelectObject( lpdis->hDC, psdd->hFontNormal );
                        break;

                    case STATE_STARTED:
                        DrawBitmap( psdd->hArrow, lpdis, &rc );
                        hOldFont = SelectObject( lpdis->hDC, psdd->hFontBold );
                        break;

                    case STATE_DONE:
                        DrawBitmap( psdd->hChecked, lpdis, &rc );
                        hOldFont = SelectObject( lpdis->hDC, psdd->hFontNormal );
                        break;

                    case STATE_ERROR:
                        DrawBitmap( psdd->hError, lpdis, &rc );
                        hOldFont = SelectObject( lpdis->hDC, psdd->hFontNormal );
                        break;
                }

                rc = lpdis->rcItem;
                rc.left += psdd->dwHeight;

                DrawText( lpdis->hDC, plbid->szText, -1, &rc, DT_LEFT | DT_VCENTER );

                if ( hOldFont != INVALID_HANDLE_VALUE )
                {
                    SelectObject( lpdis->hDC, hOldFont );
                }

                if ( !bDoneFirstPass && lpdis->itemID == ARRAYSIZE( items ) - 1 )
                {
                    // delay the message until we have painted at least once.
                    bDoneFirstPass = TRUE;
                    PostMessage( hDlg, WM_STARTSETUP, 0, 0 );
                }
                
            }
            break;

        default:
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}

//
// Finish dialog proc
//
BOOL CALLBACK 
FinishDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam )
{
    NMHDR FAR   *lpnmhdr;
	DWORD dw;

    switch ( uMsg )
    {
        case WM_NOTIFY:
            lpnmhdr = (NMHDR FAR *) lParam;
            switch ( lpnmhdr->code )
            {
                case PSN_SETACTIVE:
                    PostMessage( GetParent(hDlg), WMX_FORCEDREPAINT, 0, (LPARAM) GetDlgItem( hDlg, IDC_DIVIDER ) );
                    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_FINISH );
                    ClearMessageQueue( );
                    if ( g_Options.fError )
                    {
                        TCHAR   szText[ SMALL_BUFFER_SIZE ];
                        //dw = LoadString( g_hinstance, IDS_ERROR, szText, ARRAYSIZE( szText ) );
						//Assert( dw );
                        //dw = SetWindowText( GetDlgItem( hDlg, IDC_S_FINISH ), szText );
						//Assert( dw );

                        dw = LoadString( g_hinstance, IDS_CLOSE, szText, ARRAYSIZE( szText ) );
						Assert( dw );
                        PropSheet_SetFinishText( GetParent( hDlg ), szText );
                    }
                    // fall thru
                // ignore these
                case PSN_KILLACTIVE:
                case PSN_WIZFINISH:
                case PSN_RESET:
                    SetWindowLong( hDlg, DWL_MSGRESULT, FALSE );
                    break;

                case PSN_HELP:
                    // 
                    // TODO: Add help
                    //
                    break;

                default:
                    AssertMsg( FALSE, "Unhandled PSN message" );
                    return FALSE;
            }
            break;

        default:
            return BaseDlgProc( hDlg, uMsg, wParam, lParam );
    }
    return TRUE;
}



VOID
AdjustWatermarkBitmap(
    IN HWND   hdlg,
    IN HDC    hdc
    )
{
    static BOOL Adjusted = FALSE;
    RECT rect;
    RECT rect2;
    HWND Separator;
    PVOID Bits;
    HBITMAP hDib;
    HBITMAP hOldBitmap;
    BITMAPINFO *BitmapInfo;
    HDC MemDC;
    int i;
    BOOL b;

    if(Adjusted) {
        return;
    }

    //
    // Determine whether the bitmap needs to be stretched.
    // If the width is within 10 pixels and the height is within 5
    // then we don't worry about stretching.
    //
    // Note that 0x3026 is the identifier of the bottom divider in
    // the template. This is kind of slimy but it works.
    //
    Separator = GetDlgItem(hdlg,0x3026);
    if(!Separator) {
        goto c0;
    }
    GetClientRect(Separator,&rect2);
    MapWindowPoints(Separator,hdlg,(LPPOINT)&rect2,2);
    GetClientRect(hdlg,&rect);

    b = TRUE;
    i = rect.right - g_pbihWatermark->biWidth;
    if((i < -10) || (i > 10)) {
        b = FALSE;
    }
    i = rect2.top - g_pbihWatermark->biHeight;
    if((i < -5) || (i > 5)) {
        b = FALSE;
    }

    if(b) {
        goto c0;
    }

    //
    // Create a copy of the existing bitmap's header structure.
    // We then modify the width and height and leave everything else alone.
    //
    BitmapInfo = 
        (LPBITMAPINFO) TraceAlloc( 
            GMEM_FIXED, 
            g_pbihWatermark->biSize + 
                (g_uWatermarkPaletteColorCount * sizeof(RGBQUAD)) );
    if(!BitmapInfo) {
        goto c0;
    }

    CopyMemory(
        BitmapInfo,
        g_pbihWatermark,
        g_pbihWatermark->biSize + (g_uWatermarkPaletteColorCount * sizeof(RGBQUAD))
        );

    BitmapInfo->bmiHeader.biWidth = rect.right + 1;
    BitmapInfo->bmiHeader.biHeight = rect2.top;

    hDib = CreateDIBSection(NULL,BitmapInfo,DIB_RGB_COLORS,&Bits,NULL,0);
    if(!hDib) {
        goto c1;
    }

    //
    // Create a "template" memory DC and select the DIB we created
    // into it. Passing NULL to CreateCompatibleDC creates a DC into which
    // any format bitmap can be selected. We don't want to use the dialog's
    // DC because if the pixel depth of the watermark bitmap differs from
    // the screen, we wouldn't be able to select the dib into the mem dc.
    //
    MemDC = CreateCompatibleDC(NULL);
    if(!MemDC) {
        goto c2;
    }

    hOldBitmap = (HBITMAP) SelectObject(MemDC,hDib);
    if(!hOldBitmap) {
        goto c3;
    }

    //
    // Do the stretch operation from the source bitmap onto
    // the dib.
    //
    SetStretchBltMode(MemDC,COLORONCOLOR);
    i = StretchDIBits(
            MemDC,
            0,0,
            rect.right+1,
            rect2.top,
            0,0,
            g_pbihWatermark->biWidth,
            g_pbihWatermark->biHeight,
            g_pWatermarkBitmapBits,
            (BITMAPINFO *)g_pbihWatermark,
            DIB_RGB_COLORS,
            SRCCOPY
            );

    if(i == GDI_ERROR) {
        goto c4;
    }

    //
    // Got everything we need, set up pointers to use new bitmap data.
    //
    g_pWatermarkBitmapBits = Bits;
    g_pbihWatermark = (BITMAPINFOHEADER *)BitmapInfo;

    b = TRUE;

c4:
    SelectObject(MemDC,hOldBitmap);
c3:
    DeleteDC(MemDC);
c2:
    if(!b) {
        DeleteObject(hDib);
    }
c1:
    if(!b) {
        TraceFree(BitmapInfo);
    }
    DebugMemoryDelete(BitmapInfo);  // don't track, we'll leak it on purpose.
c0:
    Adjusted = TRUE;
    return;
}

//
// Subclass WndProc for the wizard window.
//
// We do this so we can draw the watermark background.
//
BOOL
WizardDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    static int iHeight = 0;

    switch(msg) {

    case WM_PALETTECHANGED:
        //
        // If this is our window we need to avoid selecting and realizing
        // because doing so would cause an infinite loop between WM_QUERYNEWPALETTE
        // and WM_PALETTECHANGED.
        //
        if((HWND)wParam == hdlg) {
            return(FALSE);
        }
        //
        // FALL THROUGH
        //
    case WM_QUERYNEWPALETTE:
        {
            HDC hdc;
            HPALETTE pal;

            hdc = GetDC( hdlg );
            pal = SelectPalette( hdc, g_hWatermarkPalette, (msg == WM_PALETTECHANGED) );
            RealizePalette( hdc );
            InvalidateRect( hdlg, NULL, TRUE );
            if( pal ) 
            {
                SelectPalette( hdc, pal, TRUE );
            }

            ReleaseDC( hdlg, hdc );
        }
        return(TRUE);

    case WM_ERASEBKGND:
        {
            HWND CurrentPage;

            AdjustWatermarkBitmap( hdlg, (HDC)wParam);

            b = PaintWatermark( hdlg, (HDC)wParam, 0, 0, iHeight );
        }
        break;

    case WMX_FORCEDREPAINT:
        {
            HWND hwndDivider = (HWND) lParam;

            // Find where the divider is on this page
            if ( hwndDivider )
            {
                RECT rcDivider;
                GetClientRect( hwndDivider, &rcDivider );
                MapWindowPoints( hwndDivider, hdlg, (POINT *)&rcDivider, 2 );
                iHeight = rcDivider.top;
            }
            else
            {
                iHeight = 0;
            }

            InvalidateRect( hdlg, NULL, TRUE );
            b = TRUE;
        }
        break;

    default:
        {
            b = CallWindowProc( g_OldWizardProc, hdlg, msg, wParam, lParam );
        }
        break;
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\pin\pin.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pin.c

Abstract:

Author:

    Chuck Lenzmeier (chuckl)

Revision History:

--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <g:\nt\private\ntos\rdr2\csc\inc\cscapi.h>


#if 1
DWORD DebugLevel = 1;
#define dprintf(_lvl_,_x_) if ((_lvl_) <= DebugLevel) printf _x_
#define DEBUG(_x_) _x_
#else
#define dprintf(_lvl_,_x_)
#define DEBUG(_x_)
#endif

typedef enum {
    OP_PIN = 1,
    OP_UNPIN,
    OP_DELETE,
    OP_QUERY,
    OP_READ,
    OP_QUERY_SPARSE,
    OP_QUERY_FULL,
    OP_QUERY_FREE,
    OP_QUERY_NOT_IN_DB,
    OP_QUERY_SYSTEM,
    OP_QUERY_NOT_SYSTEM
} OPERATION;

OPERATION Operation;
BOOL Recurse = TRUE;
BOOL TotalsOnly = FALSE;
BOOL SkipSymbols = TRUE;
BOOL SkipPagefile = TRUE;

#define PAGE_SIZE 4096

//
// Common header for container entries (directories and keys).
//

typedef struct _CONTAINER_ENTRY {
    LIST_ENTRY SiblingListEntry;
    LIST_ENTRY ContainerList;
    struct _CONTAINER_ENTRY *Parent;
} CONTAINER_ENTRY, *PCONTAINER_ENTRY;

//
// Macros for manipulating containers and objects.
//

#define InitializeContainer(_container,_parent) {               \
        InitializeListHead(&(_container)->ContainerList);       \
        (_container)->Parent = (PCONTAINER_ENTRY)(_parent);     \
    }

#define InsertContainer(_container,_subcontainer) {                                         \
        dprintf( 3, ("inserting subcontainer %x on container %x, list head at %x = %x,%x\n",\
                _subcontainer, _container, &_container->ContainerList,                      \
                _container->ContainerList.Flink, _container->ContainerList.Blink) );        \
        InsertTailList(&(_container)->ContainerList,&(_subcontainer)->SiblingListEntry);    \
        dprintf( 3, ("inserted subcontainer %x on container %x, list head at %x = %x,%x\n", \
                _subcontainer, _container, &_container->ContainerList,                      \
                _container->ContainerList.Flink, _container->ContainerList.Blink) );        \
    }

#define RemoveContainer(_container) RemoveEntryList(&(_container)->SiblingListEntry)

#define GetFirstContainer(_container)                                               \
        ((_container)->ContainerList.Flink != &(_container)->ContainerList ?        \
            CONTAINING_RECORD( (_container)->ContainerList.Flink,                   \
                               CONTAINER_ENTRY,                                     \
                               SiblingListEntry ) : NULL)

#define GetNextContainer(_container)                                                        \
        ((_container)->SiblingListEntry.Flink != &(_container)->Parent->ContainerList ?     \
            CONTAINING_RECORD( (_container)->SiblingListEntry.Flink,                        \
                               CONTAINER_ENTRY,                                             \
                               SiblingListEntry ) : NULL)

#define GetParent(_container) (_container)->Parent

//
// Structures for entries in the watch tree.
//

typedef struct _DIRECTORY_ENTRY {
    CONTAINER_ENTRY ;
    WCHAR Name[1];
} DIRECTORY_ENTRY, *PDIRECTORY_ENTRY;


VOID
OpenAndReadFile (
    PWCH File
    )
{
    HANDLE fileHandle;
    DWORD fileSize;
    HANDLE mappingHandle;
    PUCHAR mappedBase;
    DWORD i;
    PUCHAR p;
    DWORD j;

    fileHandle = CreateFile(
                    File,
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
    if ( fileHandle == INVALID_HANDLE_VALUE ) {
        printf( "Couldn't open %ws: %d\n", File, GetLastError() );
        return;
    }

    fileSize = SetFilePointer( fileHandle, 0, NULL, FILE_END );

    if ( fileSize == 0xFFFFFFFF ) {

        printf( "SetFilePointer(END) failed with %d\n", GetLastError() );

    } else if ( fileSize != 0 ) {

        mappingHandle = CreateFileMapping(
                            fileHandle,
                            NULL,
                            PAGE_READONLY,
                            0,
                            fileSize,
                            NULL
                            );
        if ( mappingHandle == NULL ) {

            printf( "Couldn't create mapping %ws: %d\n", File, GetLastError() );

        } else {

            mappedBase = MapViewOfFile( mappingHandle, FILE_MAP_READ, 0, 0, fileSize );

            if ( mappedBase == NULL ) {

                printf( "Couldn't map view %ws: %d\n", File, GetLastError() );

            } else {

                //printf( "OpenAndReadFile: fileSize = %x, mappedBase = %x\n", fileSize, mappedBase );

                j = 0;

                for ( i = 0, p = mappedBase;
                      i < fileSize;
                      i += PAGE_SIZE, p += PAGE_SIZE ) {
                    j += *p;
                }

                UnmapViewOfFile( mappedBase );
            }
        }

        CloseHandle( mappingHandle );
    }

    CloseHandle( fileHandle );

    return;
}


DWORD
OperateOnFile (
    PWCH Directory,
    PWCH File
    )
{
    DWORD pathLength;
    DWORD status;
    DWORD pinCount;
    DWORD hintFlags;
    BOOL inDatabase;
    BOOL printThis;
    DWORD count = 0;

    pathLength = wcslen( Directory );
    if ( File != NULL ) {
        wcscat( Directory, L"\\" );
        wcscat( Directory, File );
    }

    inDatabase = CSCQueryFileStatusW( Directory, &status, &pinCount, &hintFlags );

    if ( Operation == OP_PIN ) {

        if ( !inDatabase || (pinCount == 0) ) {
            inDatabase = CSCPinFileW( Directory, hintFlags, &status, &pinCount, &hintFlags );
            if ( !TotalsOnly ) printf( "%ws : PINNED : pin count %d, hint flags %x, status %x\n", Directory, pinCount, hintFlags, status );
            count = 1;
        } else if ( (status & FLAG_CSC_COPY_STATUS_SPARSE) != 0 ) {
            printf( "%ws : SPARSE : pin count %d, hint flags %x, status %x\n", Directory, pinCount, hintFlags, status );
        }

    } else if ( Operation == OP_UNPIN ) {

        if ( inDatabase && (pinCount != 0) ) {
            inDatabase = CSCUnpinFileW( Directory, hintFlags, &status, &pinCount, &hintFlags );
            if ( !TotalsOnly ) printf( "%ws : UNPINNED : pin count %d, hintFlags %x, status %x\n", Directory, pinCount, hintFlags, status );
            count = 1;
        }

    } else if ( Operation == OP_DELETE ) {

        if ( inDatabase ) {
            inDatabase = CSCDeleteW( Directory );
            if ( inDatabase ) {
                if ( !TotalsOnly ) printf( "%ws : DELETED\n", Directory );
            } else {
                printf( "%ws : DELETE FAILED\n", Directory );
            }
            count = 1;
        }

    } else if ( Operation == OP_READ ) {

        if ( inDatabase &&
             ((hintFlags & FLAG_CSC_HINT_PIN_SYSTEM) != 0) &&
             ((status & FLAG_CSC_COPY_STATUS_SPARSE) != 0) ) {
            if ( !TotalsOnly ) printf( "%ws : READING\n", Directory );
            OpenAndReadFile( Directory );
            count = 1;
        }

    } else {

        if ( inDatabase ) {

            printThis = FALSE;

            if ( Operation == OP_QUERY ) {
                printThis = TRUE;
            } else {
                if ( (Operation == OP_QUERY_FREE) &&
                     ((hintFlags & FLAG_CSC_HINT_PIN_SYSTEM) == 0) ) {
                    printThis = TRUE;
                }
                if ( (Operation == OP_QUERY_SPARSE) &&
                     ((status & FLAG_CSC_COPY_STATUS_SPARSE) != 0) ) {
                    printThis = TRUE;
                }
                if ( (Operation == OP_QUERY_FULL) &&
                     ((status & FLAG_CSC_COPY_STATUS_SPARSE) == 0) ) {
                    printThis = TRUE;
                }
                if ( (Operation == OP_QUERY_SYSTEM) &&
                     ((hintFlags & FLAG_CSC_HINT_PIN_SYSTEM) != 0) ) {
                    printThis = TRUE;
                }
                if ( (Operation == OP_QUERY_NOT_SYSTEM) &&
                     ((hintFlags & FLAG_CSC_HINT_PIN_SYSTEM) == 0) ) {
                    printThis = TRUE;
                }
            }

            if ( printThis ) {
                if ( !TotalsOnly ) printf( "%ws : pin count %d, hint flags %x, status %x\n", Directory, pinCount, hintFlags, status );
                count = 1;
            }

        } else if ( (Operation == OP_QUERY) || (Operation == OP_QUERY_NOT_IN_DB) ) {
            if ( !TotalsOnly ) printf( "%ws : not in database\n", Directory );
            count = 1;
        }
    }

    Directory[pathLength] = 0;

    return count;
}


VOID
WalkDirectory (
    IN PWCH Directory
    )

/*++

Routine Description:

Arguments:

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    DIRECTORY_ENTRY rootDirectory;
    PDIRECTORY_ENTRY currentDirectory;
    PDIRECTORY_ENTRY newDirectory;
    WIN32_FIND_DATA fileData;
    HANDLE findHandle;
    DWORD attributes;
    DWORD error;
    BOOL ok;
    WCHAR currentPath[MAX_PATH + 1];
    DWORD count = 0;

    //
    // Get the address of the root directory entry.
    //

    currentDirectory = &rootDirectory;
    InitializeContainer( currentDirectory, NULL );

    wcscpy( currentPath, Directory );
    if ( currentPath[wcslen(currentPath)-1] == '\\' ) {
        currentPath[wcslen(currentPath)-1] = 0;
    }

    attributes = GetFileAttributes( currentPath );
    if ( attributes == 0xffffffff ) {
        printf( "Error querying %ws: %d\n", currentPath, GetLastError() );
        return;
    }

    if ( (attributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {

        //
        // The input name represents a file, not a directory.  Process the file.
        //

        dprintf( 2, ("  found file %ws\n", currentPath) );
        count += OperateOnFile( currentPath, NULL );

    } else {

        do {

            //
            // Look for files/directories in the current directory.
            //

            wcscat( currentPath, L"\\*" );
            dprintf( 2, ("FindFirst for %ws\n", currentPath) );
            findHandle = FindFirstFile( currentPath, &fileData );
            currentPath[wcslen(currentPath) - 2] = 0;

            if ( findHandle != INVALID_HANDLE_VALUE ) {

                do {

                    if ( (fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {

                        //
                        // The entry returned is for a file.  Process the file.
                        //

                        if ( !SkipPagefile || (_wcsicmp(fileData.cFileName,L"pagefile.sys") != 0) ) {
                            dprintf( 2, ("  found file %ws\\%ws\n", currentPath, fileData.cFileName) );
                            count += OperateOnFile( currentPath, fileData.cFileName );
                        }

                    } else if (Recurse &&
                               (wcscmp(fileData.cFileName,L".") != 0) &&
                               (wcscmp(fileData.cFileName,L"..") != 0) &&
                               (!SkipSymbols || (_wcsicmp(fileData.cFileName,L"symbols") != 0))) {

                        //
                        // The entry returned is for a directory.  Add it to the tree.
                        //

                        dprintf( 2, ("  found directory %ws\\%ws\n", currentPath, fileData.cFileName) );
                        newDirectory = malloc( sizeof(DIRECTORY_ENTRY) - sizeof(WCHAR) +
                                                 ((wcslen(fileData.cFileName) + 1) * sizeof(WCHAR)) );
                        if ( newDirectory == NULL ) {
                            FindClose( findHandle );
                            printf( "Out of memory\n" );
                            return;
                        }

                        InitializeContainer( newDirectory, currentDirectory );
                        wcscpy( newDirectory->Name, fileData.cFileName );
                        InsertContainer( currentDirectory, newDirectory );

                    }

                    //
                    // Find another entry in the directory.
                    //

                    ok = FindNextFile( findHandle, &fileData );

                } while ( ok );

                //
                // All entries found.  Close the find handle.
                //

                FindClose( findHandle );

            } // findHandle != INVALID_HANDLE_VALUE

            //
            // If the current directory has subdirectories, recurse into the
            // first one.
            //

            newDirectory = (PDIRECTORY_ENTRY)GetFirstContainer( currentDirectory );
            dprintf( 3, ("done with directory %ws; first child %ws\n", currentPath, newDirectory == NULL ? L"(none)" : newDirectory->Name ));
            if ( newDirectory != NULL ) {

                currentDirectory = newDirectory;
                wcscat( currentPath, L"\\" );
                wcscat( currentPath, currentDirectory->Name );

            } else {

                //
                // The directory has no subdirectories.  Walk back up the
                // tree looking for a sibling directory to process.
                //

                while ( TRUE ) {

                    //
                    // If the current directory is the root directory, we're done.
                    //

                    if ( currentDirectory == &rootDirectory ) {
                        currentDirectory = NULL;
                        break;
                    }

                    //
                    // Strip the name of the current directory off of the path.
                    //

                    *wcsrchr(currentPath, L'\\') = 0;

                    //
                    // If the parent directory has more subdirectories,
                    // recurse into the next one.  Otherwise, move up
                    // to the parent directory and try again.
                    //

                    newDirectory = (PDIRECTORY_ENTRY)GetNextContainer( currentDirectory );
                    if ( newDirectory != NULL ) {
                        currentDirectory = newDirectory;
                        wcscat( currentPath, L"\\" );
                        wcscat( currentPath, currentDirectory->Name );
                        break;
                    } else {
                        currentDirectory = (PDIRECTORY_ENTRY)GetParent( currentDirectory );
                    }
                }
            }

        } while ( currentDirectory != NULL );
    }

    if ( count != 0 ) {
        printf( "%d files%s\n", count, TotalsOnly ? "" : " listed" );
    }

    return;

} // WalkDirectory

int
__cdecl
wmain (
    int argc,
    PWCH argv[]
    )
{
    int c = --argc;
    PWCH *v = &argv[1];
    PWCH a;

    while ( c != 0 ) {
        a = *v;
        if ( *a != '-' ) {
            break;
        }
        a++;
        while ( *a != 0 ) {
            if ( tolower(*a) == 'd' ) {
                Recurse = FALSE;
            } else if ( tolower(*a) == 't' ) {
                TotalsOnly = TRUE;
            } else {
                goto usage;
            }
            a++;
        }
        c--;
        v++;
    }

    if ( c < 2 ) {
        goto usage;
    }

    if ( _wcsicmp(v[1],L"pin") == 0 ) {
        Operation = OP_PIN;
    } else if ( _wcsicmp(v[1],L"unpin") == 0 ) {
        Operation = OP_UNPIN;
    } else if ( _wcsicmp(v[1],L"delete") == 0 ) {
        Operation = OP_DELETE;
    } else if ( _wcsicmp(v[1],L"query") == 0 ) {
        Operation = OP_QUERY;
    } else if ( _wcsicmp(v[1],L"sparse") == 0 ) {
        Operation = OP_QUERY_SPARSE;
    } else if ( _wcsicmp(v[1],L"full") == 0 ) {
        Operation = OP_QUERY_FULL;
    } else if ( _wcsicmp(v[1],L"free") == 0 ) {
        Operation = OP_QUERY_FREE;
    } else if ( _wcsicmp(v[1],L"read") == 0 ) {
        Operation = OP_READ;
    } else if ( _wcsicmp(v[1],L"nid") == 0 ) {
        Operation = OP_QUERY_NOT_IN_DB;
    } else if ( _wcsicmp(v[1],L"sys") == 0 ) {
        Operation = OP_QUERY_SYSTEM;
    } else if ( _wcsicmp(v[1],L"nosys") == 0 ) {
        Operation = OP_QUERY_NOT_SYSTEM;
    } else {
        goto usage;
    }

    WalkDirectory( v[0] );

    return 0;

usage:

    printf( "usage: %ws [-d] [-t] <directory> <pin|unpin|delete|query|sparse|full|free|read|nid|sys|nosys>\n", argv[0] );
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbinstal\debug.cpp ===
/****************************************************************************

  Copyright (c) Microsoft Corporation 1997
  All rights reserved

  File: DEBUG.CPP

  Debugging utilities
 
 ***************************************************************************/

#include "pch.h"

DEFINE_MODULE("Debugging");

#ifdef DEBUG

// Constants
#define DEBUG_OUTPUT_BUFFER_SIZE  512

// Globals
DWORD g_TraceMemoryIndex = 0;
DWORD g_dwCounter        = 0;
DWORD g_dwTraceFlags     = TF_FUNC | TF_CALLS;

// Statics
static const TCHAR g_szNULL[]    = TEXT("");
static const TCHAR g_szTrue[]    = TEXT("True");
static const TCHAR g_szFalse[]   = TEXT("False");
static const TCHAR g_szFormat[]  = TEXT("%-40s  %-10.10s ");
static const TCHAR g_szUnknown[] = TEXT("<unknown>");

//
// Debugging strrchr( )
//
LPCTSTR
dbgstrrchr( LPCTSTR lpsz, char ch )
{
    LPCTSTR psz = lpsz;

    while ( *psz )
        ++psz;

    while ( psz >= lpsz && *psz != ch )
        --psz;

    return psz;

}

//
// Adds 'g_dwCounter' spaces to debug spew
//
void
dbgspace( void )
{
    for( DWORD dw = 1; dw < g_dwCounter; dw++ )
        DebugMsg( TEXT("| ") );
}

//
// Takes the filename and line number and put them into a string buffer.
//
// NOTE: the buffer is assumed to be of size DEBUG_OUTPUT_BUFFER_SIZE.
//
LPTSTR
dbgmakefilelinestring( 
    LPTSTR  pszBuf, 
    LPCTSTR pszFile, 
    UINT    uLine )
{
    LPVOID args[2];

    args[0] = (LPVOID) pszFile;
    args[1] = (LPVOID) uLine;

    FormatMessage( 
        FORMAT_MESSAGE_FROM_STRING | 
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
        TEXT("%1(%2!u!):"),
        0,                          // error code
        0,                          // default language
        (LPTSTR) pszBuf,            // output buffer
        DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
        (char**) &args );           // arguments

    return pszBuf;
}



//
// TraceMsg()
//
void
TraceMsg( 
    DWORD dwCheckFlags,
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS 
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

        va_start( valist, pszFormat );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );

        OutputDebugString( szBuf );
    }
}

//
// TraceMessage()
//
void
TraceMessage( 
    LPCTSTR pszFile, 
    UINT    uLine, 
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS 
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( !pszModule )
        {
            pszModule = g_szUnknown;
        }

        if ( !pszFile )
        {
            wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
        }
        else
        {
            TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

            dbgmakefilelinestring( szFileLine, pszFile, uLine );
            wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
        }

        OutputDebugString( szBuf );

        dbgspace( );

        va_start( valist, pszFormat );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );

        OutputDebugString( szBuf );
    }

}

//
// DebugMessage()
//
void
DebugMessage( 
    LPCTSTR  pszFile, 
    UINT    uLine, 
    LPCTSTR  pszModule, 
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

    if ( !pszModule )
    {
        pszModule = g_szUnknown;
    }

    if ( !pszFile )
    {
        wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
    }
    else
    {
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        dbgmakefilelinestring( szFileLine, pszFile, uLine );
        wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
    }

    OutputDebugString( szBuf );

    dbgspace( );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist );
    va_end( valist );

    OutputDebugString( szBuf );

}

//
// DebugMsg()
//
void 
DebugMsg( 
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );

    OutputDebugString( szBuf );
}


//
// Displays a dialog box with the failed assertion. User has the option of
// breaking.
//
BOOL
AssertMessage( 
    LPCTSTR  pszFile, 
    UINT    uLine, 
    LPCTSTR  pszModule, 
    LPCTSTR pszfn, 
    BOOL    fTrue )
{
    if ( !fTrue )
    {
        TCHAR szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        // Make sure everything is cool before we blow up somewhere else.
        if ( pszFile == NULL )
        {
            pszFile = g_szNULL;
        }

        if ( pszModule == NULL )
        {
            pszModule = g_szNULL;
        }

        if ( pszfn == NULL )
        {
            pszfn = g_szNULL;
        }

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-40s  %-10s ASSERT: %s\n"),
            szFileLine, pszModule, pszfn );

        OutputDebugString( szBuf );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nAssertion:\t%s\t\n\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn );

        if ( IDNO == MessageBox( NULL, szBuf, TEXT("Assertion Failed!"), 
                MB_YESNO|MB_ICONWARNING ) )
            return FALSE;   // don't break
    }

    return !fTrue;

}

//
// Traces HRESULT errors. A dialog will appear is there is an error
// in the hr.
//
HRESULT
TraceHR( 
    LPCTSTR  pszFile, 
    UINT    uLine, 
    LPCTSTR  pszModule, 
    LPCTSTR pszfn, 
    HRESULT hr )
{
    if ( hr )
    {
        TCHAR  szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR pszMsgBuf;

        switch ( hr )
        {
        case S_FALSE:
            pszMsgBuf = TEXT("S_FALSE\n");
            break;

        default:
            FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPTSTR)&pszMsgBuf,
                0,
                NULL
            );
        }

        // Make sure everything is cool before we blow up somewhere else.
        Assert( pszMsgBuf != NULL );
        Assert( pszFile != NULL );
        Assert( pszModule != NULL );
        Assert( pszfn != NULL );

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-40s  %-10s HRESULT: hr = 0x%08x - %s"),
            szFileLine, pszModule, hr, pszMsgBuf );

        OutputDebugString( szBuf );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nFunction:\t%s\t\nhr =\t0x%08x - %s\t\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn, hr, pszMsgBuf );

        if ( IDYES == MessageBox( NULL, szBuf, TEXT("Trace HRESULT"), 
                MB_YESNO|MB_ICONWARNING ) )
            DEBUG_BREAK;

        LocalFree( pszMsgBuf );

    }

    return hr;

}


//
// Memory allocation and tracking
//

typedef struct _MEMORYBLOCK {
    HGLOBAL hglobal;
    DWORD   dwBytes;
    UINT    uFlags;
    LPCTSTR pszFile;
    UINT    uLine;
    LPCTSTR pszModule;
    LPCTSTR pszComment;
    _MEMORYBLOCK *pNext;
} MEMORYBLOCK, *LPMEMORYBLOCK;

//
// Adds a MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    UINT    uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmb     = (LPMEMORYBLOCK) GlobalAlloc( 
                                                    GMEM_FIXED, 
                                                    sizeof(MEMORYBLOCK) );

        if ( !pmb )
        {
            GlobalFree( hglobal );
            return NULL;
        }

        pmb->hglobal    = hglobal;
        pmb->dwBytes    = dwBytes;
        pmb->uFlags     = uFlags;
        pmb->pszFile    = pszFile;
        pmb->uLine      = uLine;
        pmb->pszModule  = pszModule;
        pmb->pszComment = pszComment;
        pmb->pNext      = pmbHead;

        TlsSetValue( g_TraceMemoryIndex, pmb );
    }

    return hglobal;
}

//
// Removes a MEMORYBLOCK to the memory tracking list.
//
void
DebugMemoryDelete( 
    HGLOBAL hglobal )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmbLast = NULL;

        while ( pmbHead && pmbHead->hglobal != hglobal )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        }

        if ( pmbHead )
        {
            if ( pmbLast )
            {
                pmbLast->pNext = pmbHead->pNext;
            }
            else
            {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );
            }
        }
    }
}

//
// Allocates memory and adds the MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugAlloc( 
    LPCTSTR pszFile,
    UINT    uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    HGLOBAL       hglobal = GlobalAlloc( uFlags, dwBytes );

    return DebugMemoryAdd( hglobal, pszFile, uLine, pszModule, uFlags, dwBytes, pszComment );
}

//
// Remove the MEMORYBLOCK to the memory tracking list, memsets the
// memory to 0xFE and then frees the memory.
//
HGLOBAL
DebugFree( 
    HGLOBAL hglobal )
{
    DebugMemoryDelete( hglobal );

    return GlobalFree( hglobal );
}

//
// Checks the memory tracking list. If it is not empty, it will dump the
// list and break.
//
void
DebugMemoryCheck( )
{
    BOOL          fFoundLeak = FALSE;
    LPMEMORYBLOCK pmb = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );

    while ( pmb )
    {
        LPVOID args[ 5 ];
        TCHAR  szOutput[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( fFoundLeak == FALSE )
        {
            OutputDebugString(TEXT("\n***************************** Memory leak detected *****************************\n\n"));
          //OutputDebugString("1234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1...");
            OutputDebugString(TEXT("Filename(Line Number):                    Module     Addr/HGLOBAL  Size   String\n"));
            fFoundLeak = TRUE;
        }

        args[0] = (LPVOID) pmb->hglobal;
        args[1] = (LPVOID) &szFileLine;
        args[2] = (LPVOID) pmb->pszComment;
        args[3] = (LPVOID) pmb->dwBytes;
        args[4] = (LPVOID) pmb->pszModule;

        dbgmakefilelinestring( szFileLine, pmb->pszFile, pmb->uLine );

        if ( !!(pmb->uFlags & GMEM_MOVEABLE) )
        {
            FormatMessage( 
                FORMAT_MESSAGE_FROM_STRING | 
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-40s!  %5!-10s! H 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) &szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (char**) &args );           // arguments
        }
        else
        {    
            FormatMessage( 
                FORMAT_MESSAGE_FROM_STRING | 
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-40s!  %5!-10s! A 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) &szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (char**) &args );           // arguments
        }

        OutputDebugString( szOutput );

        pmb = pmb->pNext;
    }

    if ( fFoundLeak == TRUE )
    {
        OutputDebugString(TEXT("\n***************************** Memory leak detected *****************************\n\n"));
    }

    Assert( !fFoundLeak );
}

#endif // DEBUG

//
// Global Management Functions - 
//
// These are in debug and retail but are internally they change
// depending on the build.
//

void * __cdecl operator new(unsigned int t_size )
{
    return DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, GPTR, t_size, TEXT("new()") );
}

void __cdecl operator delete(void *pv)
{
    TraceFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbinstal\rbinstal.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

  File: RBSETUP.H
 
 ***************************************************************************/


#ifndef _RBINSTAL_H_
#define _RBINSTAL_H_

// Global macros
#define ARRAYSIZE( _x ) ( sizeof( _x ) / sizeof( _x[ 0 ] ) )

#define WM_STARTSETUP    WM_USER + 0x200
#define WMX_FORCEDREPAINT WM_USER + 0x210

// Global structures
typedef struct {
    BOOL    fAcceptEULA:1;
    BOOL    fCreateDirectory:1;
    BOOL    fError:1;
    BOOL    fAbort:1;
    BOOL    fIntel:1;
    BOOL    fAlpha:1;
    BOOL    fKnowRBDirectory:1;

    TCHAR   szRemoteBootPath[ MAX_PATH ];
    TCHAR   szSourcePath[ MAX_PATH ];
    TCHAR   szName[ MAX_PATH ];

    TCHAR   szImagesPath[ MAX_PATH ];
    TCHAR   szSetupPath[ MAX_PATH ];

} OPTIONS, *LPOPTIONS;

// Globals
extern OPTIONS g_Options;
extern HINSTANCE g_hinstance;
extern HANDLE    g_hGraphic;

//
// Stuff used for watermarking
//
extern CONST BITMAPINFOHEADER *g_pbihWatermark;
extern PVOID       g_pWatermarkBitmapBits;
extern HPALETTE    g_hWatermarkPalette;
extern INT         g_uWatermarkPaletteColorCount;
extern WNDPROC     g_OldWizardProc;

#endif // _RBINSTAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbinstal\main.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#include "pch.h"

#include <windowsx.h>
#include <prsht.h>
#include <lm.h>

#include "dialogs.h"

DEFINE_MODULE("Main");

// Globals
HINSTANCE g_hinstance = NULL;
HANDLE    g_hGraphic  = NULL;
OPTIONS   g_Options;

// Constants
#define NUMBER_OF_PAGES 10

typedef struct _DLGTEMPLATE2 {
    WORD DlgVersion;
    WORD Signature;
    DWORD HelpId;
    DWORD StyleEx;
    DWORD Style;
    WORD cDlgItems;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE2;


HPALETTE
CreateDIBPalette(
    LPBITMAPINFO  pbi,
    int          *piColorCount )
{
    LPBITMAPINFOHEADER pbih;
    HPALETTE           hPalette;

    pbih = (LPBITMAPINFOHEADER) pbi;

    //
    // No palette needed for >= 16 bpp
    //
    *piColorCount = (pbih->biBitCount <= 8)
                ? (1 << pbih->biBitCount)
                : 0;

    if ( *piColorCount ) 
    {
        LPLOGPALETTE       pLogPalette;

        pLogPalette = 
            (LPLOGPALETTE) TraceAlloc( GMEM_FIXED, 
                sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * ( *piColorCount)) );
        if( !pLogPalette ) 
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return NULL;
        }

        pLogPalette->palVersion    = 0x300;
        pLogPalette->palNumEntries = *piColorCount;

        for( int i = 0; i < *piColorCount; i++ ) 
        {
            pLogPalette->palPalEntry[i].peRed   = pbi->bmiColors[i].rgbRed;
            pLogPalette->palPalEntry[i].peGreen = pbi->bmiColors[i].rgbGreen;
            pLogPalette->palPalEntry[i].peBlue  = pbi->bmiColors[i].rgbBlue;
            pLogPalette->palPalEntry[i].peFlags = 0;
        }

        hPalette = CreatePalette( pLogPalette );
        TraceFree( pLogPalette );
    } 
    else 
    {
        hPalette = NULL;
    }

    return hPalette;
}

//
// Retreives device-independent bitmap data and a color table from a
// bitmap in a resource.
//
BOOL
GetBitmapDataAndPalette(
    HINSTANCE                g_hinstance,
    LPCTSTR                  pszId,
    HPALETTE                *phPalette,
    PINT                     piColorCount,
    CONST BITMAPINFOHEADER **ppbih )
{
    BOOL    fResult   = FALSE;
    HRSRC   hBlock    = NULL;
    HGLOBAL hResource = NULL;

    //
    // None of FindResource(), LoadResource(), or LockResource()
    // need to have cleanup routines called in Win32.
    //
    hBlock = FindResource( g_hinstance, pszId, RT_BITMAP );
    if( !hBlock ) 
        goto Error;

    hResource = LoadResource( g_hinstance, hBlock );
    if( !hResource )
        goto Error;

    *ppbih = (LPBITMAPINFOHEADER) LockResource( hResource );
    if( *ppbih == NULL )
        goto Error;

    *phPalette = CreateDIBPalette( (LPBITMAPINFO) *ppbih, piColorCount );

    fResult = TRUE;

Error:
    return fResult;
}

//
// Property sheet callback to handle the initialization of the watermark.
//
int CALLBACK
Winnt32SheetCallback(
    IN HWND   hDlg,
    IN UINT   uMsg,
    IN LPARAM lParam
    )
{
    switch( uMsg ) 
    {
        case PSCB_PRECREATE:
            {
                DLGTEMPLATE *DlgTemplate;
                //
                // Make sure we get into the foreground.
                //
                DlgTemplate = (DLGTEMPLATE *)lParam;
                DlgTemplate->style &= ~DS_CONTEXTHELP;
                DlgTemplate->style |= DS_SETFOREGROUND;
            }
            break;

        case PSCB_INITIALIZED:
            {
                //
                // Load the watermark bitmap and override the dialog procedure for the wizard.
                //
                HDC     hdc;
                WNDPROC OldWizardProc;

                CenterDialog( hDlg );

                hdc = GetDC(NULL);

                GetBitmapDataAndPalette(
                    g_hinstance,
                      (!hdc || (GetDeviceCaps(hdc,BITSPIXEL) < 8))
                    ? MAKEINTRESOURCE(IDB_WATERMARK16) : MAKEINTRESOURCE(IDB_WATERMARK256),
                    &g_hWatermarkPalette,
                    &g_uWatermarkPaletteColorCount,
                    &g_pbihWatermark );

                g_pWatermarkBitmapBits = (LPBYTE)g_pbihWatermark
                                    + g_pbihWatermark->biSize + (g_uWatermarkPaletteColorCount * sizeof(RGBQUAD));

                if(hdc) 
                    ReleaseDC(NULL,hdc);

                g_OldWizardProc = 
                    (WNDPROC) SetWindowLong( hDlg, DWL_DLGPROC, (LONG) WizardDlgProc );
            }
            break;
    }

    return(0);
}

//
// Adds a page to the dialog.
//
void 
AddPage(
    LPPROPSHEETHEADER ppsh, 
    UINT id, 
    DLGPROC pfn )
{
    PROPSHEETPAGE psp;

    ZeroMemory( &psp, sizeof(psp) );
    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT | PSP_HASHELP | PSP_USETITLE;
    psp.pszTitle    = MAKEINTRESOURCE( IDS_APPNAME );
    psp.hInstance   = ppsh->hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(id);
    psp.pfnDlgProc  = pfn;

    ppsh->phpage[ ppsh->nPages ] = CreatePropertySheetPage( &psp );
    if ( ppsh->phpage[ ppsh->nPages ] )
        ppsh->nPages++;
}

// 
// Creates the UI pages and kicks off the property sheet.
//
HRESULT
InitSetupPages( )
{
    HRESULT         hr = S_OK;
    HPROPSHEETPAGE  rPages[ NUMBER_OF_PAGES ];
    PROPSHEETHEADER pshead;

    ZeroMemory( &pshead, sizeof(pshead) );
    pshead.dwSize       = sizeof(pshead);
    pshead.dwFlags      = PSH_WIZARD | PSH_PROPTITLE | PSH_USEHICON |
                          PSH_USECALLBACK;
    pshead.hwndParent   = NULL;
    pshead.nStartPage   = 0;
    pshead.hInstance    = g_hinstance;
    pshead.pszCaption   = MAKEINTRESOURCE( IDS_APPNAME );
    pshead.nPages       = 0;
    pshead.phpage       = rPages;
    pshead.hIcon        = LoadIcon( g_hinstance, MAKEINTRESOURCE( IDI_SETUP ) );
    pshead.pfnCallback  = Winnt32SheetCallback;

    AddPage( &pshead, IDD_WELCOME,      (DLGPROC) WelcomeDlgProc );
    AddPage( &pshead, IDD_RBDIRECTORY,  (DLGPROC) RemoteBootDlgProc );
    AddPage( &pshead, IDD_OS,           (DLGPROC) OSDlgProc );
    AddPage( &pshead, IDD_SETUPDIR,     (DLGPROC) SourceDlgProc );
    AddPage( &pshead, IDD_INFO,         (DLGPROC) InfoDlgProc );
    AddPage( &pshead, IDD_SETUP,        (DLGPROC) SetupDlgProc );
    AddPage( &pshead, IDD_FINISH,       (DLGPROC) FinishDlgProc );
 
    if( PropertySheet( &pshead ) == -1)
    {
       hr = E_FAIL;
    }

    RRETURN(hr);
}

//
// Initializes g_Options.
//
void
InitializeOptions( void )
{
    TCHAR sz[ MAX_PATH ];
    LPSHARE_INFO_502 psi;
	DWORD dw;

    dw = LoadString( g_hinstance, IDS_DEFAULTPATH, sz, ARRAYSIZE( sz ) );
	Assert( dw );
    dw = ExpandEnvironmentStrings( sz, g_Options.szRemoteBootPath, ARRAYSIZE( szRemoteBootPath ) );
	Assert( dw );
    dw = LoadString( g_hinstance, IDS_DEFAULTSETUP, g_Options.szName, ARRAYSIZE( g_Options.szName ) );
	Assert( dw );
    g_Options.szSourcePath[ 0 ] = 0;

    g_Options.fCreateDirectory  = FALSE;
    g_Options.fError            = FALSE;
    g_Options.fAbort            = FALSE;
    g_Options.fKnowRBDirectory  = FALSE;

    dw = LoadString( g_hinstance, IDS_REMOTEBOOTSHARENAME, sz, ARRAYSIZE( sz ) );
	Assert( dw );
    if ( NERR_Success == NetShareGetInfo( NULL, sz, 502, (LPBYTE *)&psi ) )
    {
        lstrcpy( g_Options.szRemoteBootPath, psi->shi502_path );
        g_Options.fKnowRBDirectory  = TRUE;
    }
}

//
// WinMain()
//
int APIENTRY 
WinMain(
    HINSTANCE hInstance, 
    HINSTANCE hPrevInstance, 
    LPSTR lpCmdLine, 
    int nCmdShow)
{
    HANDLE  hMutex;
    HRESULT hr = E_FAIL;

    g_hinstance = hInstance;

    INITIALIZE_TRACE_MEMORY;

    // allow only one instance running at a time
    TraceMsgDo( hMutex = CreateMutex( NULL, TRUE, TEXT("RemoteBootSetup.Mutext")),
        "V hMutex = 0x%08x\n" );
    if ((hMutex != NULL) && (GetLastError() == ERROR_ALREADY_EXISTS))
    {
        //
        // TODO: Do something fancy like find the other instance and
        //       bring it to the foreground.
        //
        goto Cleanup;
    }

    g_hGraphic = LoadImage( g_hinstance, MAKEINTRESOURCE( IDB_BUTTON ), IMAGE_BITMAP, 
                     0, 0, LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
    Assert( g_hGraphic );
    DebugMemoryAddHandle( g_hGraphic );

    InitializeOptions( );

    hr = THR( InitSetupPages( ) );

Cleanup:
    if ( hMutex )
        CloseHandle( hMutex );

    if ( g_hGraphic )
    {
        DebugMemoryDelete( g_hGraphic );
        DeleteObject( g_hGraphic );
    }

    UNINITIALIZE_TRACE_MEMORY;

    RRETURN(hr);
}


// stolen from the CRT, used to shrink our code
int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPSTR pszCmdLine = GetCommandLineA();


    if ( *pszCmdLine == '\"' ) 
    {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else 
    {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) 
    {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never come here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbinstal\utils.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#ifndef _UTILS_H_
#define _UTILS_H_

void 
CenterDialog( 
    HWND hwndDlg );

void 
ClearMessageQueue( void );

int
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType );

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbsetup\client\debug.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

  File: DEBUG.H

  Debugging utilities header
 
 ***************************************************************************/


#ifndef _DEBUG_H_
#define _DEBUG_H_

#if DBG==1

// Globals
extern DWORD g_TraceMemoryIndex;
extern DWORD g_dwCounter;
extern DWORD g_dwTraceFlags;

extern const TCHAR g_szTrue[];
extern const TCHAR g_szFalse[];

// Trace Flags
enum {
    TF_ALWAYS           = 0xFFFFFFFF,
    TF_NEVER            = 0x00000000,
    TF_QUERYINTERFACE   = 0x00000001,
    TF_FUNC             = 0x00000002,
    TF_CALLS            = 0x00000004,
    TF_MEMORYALLOCS     = 0x00000008
};


// Macros
#define DEFINE_MODULE( _module ) static const TCHAR g_szModule[] = TEXT(_module);
#define __MODULE__ g_szModule

// #define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#define DEBUG_BREAK { _asm int 3 }

#define INITIALIZE_TRACE_MEMORY     g_TraceMemoryIndex = TlsAlloc( ); TlsSetValue( g_TraceMemoryIndex, NULL)
#define UNINITIALIZE_TRACE_MEMORY   DebugMemoryCheck( )

#ifdef Assert
#undef Assert
#endif
#define Assert( _fn ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), !!(_fn) ) ) DEBUG_BREAK

#ifdef AssertMsg
#undef AssertMsg
#endif
#define AssertMsg( _fn, _msg ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), !!(_fn) ) ) DEBUG_BREAK

#define TraceAlloc( _flags, _size ) DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, _flags, _size, TEXT(#_size) )
#define TraceFree( _hmem )          DebugFree( _hmem )

// Tracing
#define TraceFunc( _msg ) \
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT(_msg) ); \
    g_dwCounter--; \

#define TraceClsFunc( _msg ) \
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("%s::%s"), TEXT(SZTHISCLASS), TEXT(_msg) );\
    g_dwCounter--; \

#define TraceDo( _fn ) {\
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("V\n") ); \
    g_dwCounter--; \
}

#define TraceMsgDo( _fn, _msg ) {\
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT(_msg), _fn ); \
    g_dwCounter--; \
}

#define DebugDo( _fn ) {\
    g_dwCounter++; \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("V\n") ); \
    g_dwCounter--; \
}

#define DebugMsgDo( _fn, _msg ) {\
    g_dwCounter++; \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("+ %s\n"), TEXT(#_fn) ); \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), _fn); \
    g_dwCounter--; \
}

// HRESULT testing
#define THR( _fn ) \
    TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn )

#define RRETURN( _fn ) \
    return TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn )

#define QIRETURN( _fn ) \
    if ( !!( TF_QUERYINTERFACE & g_dwTraceFlags ) )\
        return TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn ); \
    else if ( hr ) \
        DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("QueryInterface() failed()") ); \
    return _fn

#define RRETURN1( _fn, _ok ) {\
    TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), \
        ( ( _fn == _ok ) ? S_OK : _fn ) ); \
    return _fn;\
    }

// Thread-safe inc/decrements
#define InterlockDecrement( _var ) {\
    --_var;\
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_QUERYINTERFACE, TEXT("Decremented %s = %u\n"), TEXT(#_var), _var );\
    g_dwCounter--; \
     }
#define InterlockIncrement( _var ) {\
    ++_var;\
    g_dwCounter++; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_QUERYINTERFACE, TEXT("Incremented %s = %u\n"), TEXT(#_var), _var );\
    g_dwCounter--; \
    }

// Other
#define BOOLTOSTRING( _fBool ) ( !!(_fBool) ? g_szTrue : g_szFalse )

// Functions
void
TraceMsg( 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... );

void
DebugMsg( 
    LPCTSTR pszFormat,
    ... );

void
TraceMessage( 
    LPCTSTR pszFile, 
    UINT    uLine, 
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... );

void 
DebugMessage( 
    LPCTSTR pszFile, 
    UINT    uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszFormat,
    ... );

BOOL
AssertMessage( 
    LPCTSTR pszFile, 
    UINT    uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    BOOL    fTrue );

HRESULT
TraceHR( 
    LPCTSTR pszFile, 
    UINT    uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    HRESULT hr );

// Memory Functions
HGLOBAL
DebugAlloc( 
    LPCTSTR pszFile,
    UINT    uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

HGLOBAL
DebugFree( 
    HGLOBAL hMem );

HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    UINT    uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

#define DebugMemoryAddHandle( _handle ) \
    DebugMemoryAdd( _handle, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_MOVEABLE, 0, TEXT("_handle") );

#define DebugMemoryAddAddress( _pv ) \
    DebugMemoryAdd( _pv, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT("_pv") );

void
DebugMemoryDelete( 
    HGLOBAL hglobal );

void
DebugMemoryCheck( );

//
//
#else // it's RETAIL    ******************************************************
//
//

// Debugging -> NOPs
#define Assert( _fn )
#define DebugDo( _fn )
#define DebugMsgDo( _fn, _msg )
#define DEFINE_MODULE( _module )
#define AssertMsg               (void)
#define TraceMsg                (void)
#define DebugMsg                (void)
#define TraceMessage            (void)
#define DebugMessage            (void)
#define AssertMessage           (void)
#define TraceHR                 (void)
#define DebugMemoryAddHandle( _handle )
#define DebugMemoryAddAddress( _pv )

// Tracing -> just do operation
#define TraceDo( _flag, _fn )           _fn
#define TraceMsgDo( _flag, _fn, _msg )  _fn

// HRESULT testing -> do retail
#define THR
#define RRETURN( _fn )          return _fn
#define RRETURN( _fn, _ok );    return _fn

// Thread-safe inc/decrements -> do retail
#define InterlockDecrement( _var )      --_var
#define InterlockIncrement( _var )      ++_var

// Memory Functions -> do retail
#define TraceAlloc( _flags, _size )     GlobalAlloc( _flags, _size )
#define TraceFree( _pv )                GlobalFree( _pv )

#endif // DBG==1

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbinstal\setup.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#ifndef _SETUP_H_
#define _SETUP_H_

HINF
OpenLayoutInf( );

HRESULT
CreateDirectories( HWND hDlg );

HRESULT
CopyFiles( HWND hDlg );

HRESULT
ModifyRegistry( HWND hDlg );

HRESULT
StartRemoteBootServices( HWND hDlg );

HRESULT
CreateRemoteBootShare( HWND hDlg );

#endif // _SETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\rbinstal\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rbinstal.rc
//
#define IDS_APPNAME                     1
#define IDB_CHECK                       1
#define IDB_X                           2
#define IDS_EULAFILENAME                3
#define IDB_ARROW                       3
#define IDS_CANCELCAPTION               4
#define IDS_CANCELTEXT                  5
#define IDS_DEFAULTPATH                 6
#define IDS_CREATEDIRCAPTION            7
#define IDS_CREATEDIRTEXT               8
#define IDS_DIRDOESNOTEXISTCAPTION      9
#define IDS_DIRDOESNOTEXISTTEXT         10
#define IDS_BROWSECAPTION_RBDIR         11
#define IDS_BROWSECAPTION_SOURCEDIR     12
#define IDS_SETUP                       13
#define IDS_IMAGES                      14
#define IDS_ERROR                       15
#define IDS_CLOSE                       16
#define IDS_DEFAULTSETUP                17
#define IDS_NTSETUPINFFILENAME          18
#define IDS_INVALIDSOURCECAPTION        20
#define IDS_INVALIDSOURCETEXT           21
#define IDS_INTELPATH                   22
#define IDS_ABORTING                    23
#define IDS_STARTING_SERVICES           26
#define IDS_CREATINGDIRECTORIES         28
#define IDS_ERROR_STARTING_SERVICE      29
#define IDS_REGISTRYFAILEDCAPTION       30
#define IDS_REGISTRYFAILEDTEXT          31
#define IDS_COPYING                     32
#define IDS_TFTPD                       33
#define IDS_TFTPD_SERVICENAME           34
#define IDS_BINL                        35
#define IDS_BINL_SERVICENAME            36
#define IDS_REMOTEBOOTSHAREREMARK       37
#define IDS_REMOTEBOOTSHARENAME         38
#define IDS_SHAREERRORCAPTION           39
#define IDS_SHAREERRORTEXT              40
#define IDS_CREATINGSHARES              41
#define IDS_FILESTOBECOPIED             43
#define IDS_TFTPD_PATH                  44
#define IDS_BINL_PATH                   45
#define IDS_UPDATING_REGISTRY           46
#define IDS_MUSTSELECTCAPTION           47
#define IDS_MUSTSELECTTEXT              48
#define IDS_ALPHAPATH                   49
#define IDS_TEMPLATEPATH       