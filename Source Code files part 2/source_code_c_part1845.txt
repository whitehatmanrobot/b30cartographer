       glpfnDisplayPaletteWindowNotify(WindowNotifyEnumDisablePrnOpts);
    }
*/

    return true;
}

void CFuncTest::RunSamples()
// Toggle options dialog box
{
    if (m_hWndDlg!=NULL)
    {
        if (!IsWindowVisible(m_hWndDlg))
            ShowWindow(m_hWndDlg,SW_SHOW);
        else
            ShowWindow(m_hWndDlg,SW_HIDE);
    }
}

BOOL CFuncTest::AddPrimitive(CPrimitive *pPrimitive)
// Adds a primitive to the primitive test list in options dialog box
{
    HWND hWnd;
    LRESULT iItem;

    hWnd=GetDlgItem(m_hWndDlg,IDC_PRIMITIVES);

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)false,0);    // Reset selection

    iItem=SendMessageA(hWnd,LB_ADDSTRING,0,(LPARAM)pPrimitive->m_szName);
    if (iItem<0)
        return false;

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)true,0);     // Pick top element as selection

    // Data is a pointer to the primitive base class
    SendMessageA(hWnd,LB_SETITEMDATA,(WPARAM)iItem,(LPARAM)pPrimitive);

    return true;
}

BOOL CFuncTest::AddOutput(COutput *pOutput)
// Adds an output to the output list in options dialog box
{
    HWND hWnd;
    LRESULT iItem;

    hWnd=GetDlgItem(m_hWndDlg,IDC_OUTPUTS);

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)false,0);    // Reset selection

    iItem=SendMessageA(hWnd,LB_ADDSTRING,0,(LPARAM)pOutput->m_szName);
    if (iItem<0)
        return false;

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)true,0);     // Pick top element as selection

    // Data is a pointer to the output base class
    SendMessageA(hWnd,LB_SETITEMDATA,(WPARAM)iItem,(LPARAM)pOutput);

    return true;
}

BOOL CFuncTest::AddSetting(CSetting *pSetting)
// Adds a setting to the settings list in options dialog box
{
    HWND hWnd;
    LRESULT iItem;

    hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
    iItem=SendMessageA(hWnd,LB_ADDSTRING,0,(LPARAM)pSetting->m_szName);
    if (iItem<0)
        return false;

    // Data is a pointer to the setting base class
    SendMessageA(hWnd,LB_SETITEMDATA,(WPARAM)iItem,(LPARAM)pSetting);

    return true;
}

RECT CFuncTest::GetTestRect(int nCol,int nRow)
{
    RECT Rect;

    GetClientRect(g_hWndMain, &Rect);

    return Rect;
}

void CFuncTest::RunTest(COutput *pOutput,CPrimitive *pPrimitive)
// Runs one test using the given output, primitive, and settings that have m_bUseSetting=true
{
    char szBuffer[256];
    MSG Msg;
    Graphics *g=NULL;
    CSetting *pSetting;
    RECT Rect;
    HDC hDC;
    HWND hWnd;
    int iItem;
    LRESULT cItemMax;
    int nX;
    int nY;
    BOOL bFirstSetting=true;

    __try
    {
        sprintf(szBuffer,"%s on %s",pPrimitive->m_szName,pOutput->m_szName);

        Rect=GetTestRect(m_nPageCol,m_nPageRow);    // Get test area

        // Clear test area
        if (m_bEraseBkgd)
        {
            hDC=GetDC(m_hWndMain);
            FillRect(hDC,&Rect,g_hbrBackground);
            ReleaseDC(m_hWndMain,hDC);
        }

        if (m_bDriverHacks)
        {
            glpfnDisplayPaletteWindowNotify(WindowNotifyEnumEnablePrnOpts);
        }
        else
        {
            glpfnDisplayPaletteWindowNotify(WindowNotifyEnumDisablePrnOpts);
        }

        // Initialize output and get graphics pointer
        // Let pOutput modify the nX,nY in case we are drawing to a dib, we do not
        //   want to be translating.
        nX=Rect.left;
        nY=Rect.top;
        g=pOutput->PreDraw(nX,nY);
        if (g==NULL)
            return;

        // Move test to test area
        g->TranslateTransform((float)nX,(float)nY);

        // Set each setting in the list box
        hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
        cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
        for (iItem=0;iItem<cItemMax;iItem++) {
            pSetting=(CSetting*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);
            pSetting->Set(g);
            if (pSetting->m_bUseSetting)
            {
                if (bFirstSetting)
                {
                    strcat(szBuffer," (");
                    bFirstSetting=false;
                }
                else
                {
                    strcat(szBuffer,", ");
                }
                strcat(szBuffer,pSetting->m_szName);
            }
        }
        if (!bFirstSetting)
            strcat(szBuffer,")");

        // We do have some primitives (CachedBitmap) which don't respect the 
        // world transform so we need some way to access the offset to the
        // test rectangle.

        pPrimitive->SetOffset(nX, nY);

        // Draw primitive test
        pPrimitive->Draw(g);

        // Destroy graphics pointer
        delete g;

        // Finish off the output
        pOutput->PostDraw(Rect);

        // Write description of test
        hDC=GetDC(m_hWndMain);
        SetBkMode(hDC,TRANSPARENT);
        DrawTextA(hDC,szBuffer,-1,&Rect,DT_CENTER|DT_WORDBREAK);
        ReleaseDC(m_hWndMain,hDC);

        // Determine page col/row where next test will be drawn
        GetClientRect(m_hWndMain,&Rect);
        m_nPageCol++;
        if (m_nPageCol*TESTAREAWIDTH+TESTAREAWIDTH>Rect.right)
        {
            m_nPageCol=0;
            m_nPageRow++;
            if (m_nPageRow*TESTAREAHEIGHT+TESTAREAHEIGHT>Rect.bottom)
            // If graphics page is full, wait or pause
            {
                m_nPageRow=0;
                if (m_bUsePageDelay)
                    Sleep(m_nPageDelay);        // Wait
                else
                {                               // Pause for next input message
                    // Clear old input messages
                    while (GetInputState())
                        PeekMessageA(&Msg,NULL,0,0,PM_REMOVE);

                    // Wait for new input message
                    while (!GetInputState())
                        Sleep(100);
                }
            }
        }
    }__except(EXCEPTION_ACCESS_VIOLATION,1){
        printf("%s caused AV\n",szBuffer);
        g_nResult=1;                       // Return 1 if there was an AV
    }
}

void CFuncTest::InitRun()
// Initialise test run, grabs all info from the options dialog box
{
    HWND hWnd;
    char szDelay[10];
    char szNumPaths[10];
    RECT Rect;
    HDC hDC;

    // Hide options dialog
//  ShowWindow(m_hWndDlg,SW_HIDE);

    // Grab options
/*
    hWnd=GetDlgItem(m_hWndDlg,IDC_PAGEDELAY);
    if (SendMessageA(hWnd,BM_GETCHECK,0,0)==BST_CHECKED)
        m_bUsePageDelay=true;
    else
*/
        m_bUsePageDelay=false;

    hWnd=GetDlgItem(m_hWndDlg,IDC_NUMPATHS);
    SendMessageA(hWnd,WM_GETTEXT,(WPARAM)10,(LPARAM)szNumPaths);
    gnPaths=atoi(szNumPaths);

/*
    hWnd=GetDlgItem(m_hWndDlg,IDC_DELAY);
    SendMessageA(hWnd,WM_GETTEXT,(WPARAM)10,(LPARAM)szDelay);
    m_nPageDelay=atoi(szDelay);
*/

    hWnd=GetDlgItem(m_hWndDlg,IDC_ERASEBKGD);
    if (SendMessageA(hWnd,BM_GETCHECK,0,0)==BST_CHECKED)
        m_bEraseBkgd=true;
    else
        m_bEraseBkgd=false;

    hWnd=GetDlgItem(m_hWndDlg,IDC_DRIVERHACKS);
    if (SendMessageA(hWnd,BM_GETCHECK,0,0)==BST_CHECKED)
    {
        m_bDriverHacks=true;
        glpfnDisplayPaletteWindowNotify(WindowNotifyEnumEnablePrnOpts);
    }
    else
    {
        m_bDriverHacks=false;
        glpfnDisplayPaletteWindowNotify(WindowNotifyEnumDisablePrnOpts);
    }

/*
    hWnd=GetDlgItem(m_hWndDlg,IDC_APPENDTEST);
    if (SendMessageA(hWnd,BM_GETCHECK,0,0)==BST_CHECKED)
        m_bAppendTest=true;
    else
*/
        m_bAppendTest=false;

    // Erase entire main window
    if (!m_bAppendTest && m_bEraseBkgd)
    {
        GetClientRect(m_hWndMain,&Rect);
        hDC=GetDC(m_hWndMain);
        FillRect(hDC,&Rect,g_hbrBackground);
        ReleaseDC(m_hWndMain,hDC);
    }

    if (!m_bAppendTest)
    {
        // Reset page row/col
        m_nPageRow=0;
        m_nPageCol=0;
    }
}

void CFuncTest::EndRun()
{
    int nX;
    int nY;
    RECT rTestArea;
    RECT rWindow;
    HDC hDC;

    hDC=GetDC(m_hWndMain);
    GetClientRect(m_hWndMain,&rWindow);

    // Draw lines on bottom right corner of last test
    // Figure out what was the last m_nPageCol and m_nPageRow
    nX=m_nPageCol-1;
    nY=m_nPageRow;
    if (nX<0) {
        nX=(rWindow.right/(int)TESTAREAWIDTH)-1;
        nY--;
        if (nY<0) {
            nY=(rWindow.bottom/(int)TESTAREAHEIGHT)-1;
        }
    }
    // Get the x,y coordinates
    nX=nX*(int)TESTAREAWIDTH;
    nY=nY*(int)TESTAREAHEIGHT;
    // Draw both lines
/*
    Rectangle(hDC,nX+(int)TESTAREAWIDTH-3,nY,nX+(int)TESTAREAWIDTH,nY+(int)TESTAREAHEIGHT);
    Rectangle(hDC,nX,nY+(int)TESTAREAHEIGHT-3,nX+(int)TESTAREAWIDTH,nY+(int)TESTAREAWIDTH);
*/

    // Clear the rest of the test areas on page
    if (m_bEraseBkgd)
    {
        nX=m_nPageCol;
        nY=m_nPageRow;
        while ((nX>0) || (nY>0))
        {
            rTestArea=GetTestRect(nX,nY);
            FillRect(hDC,&rTestArea,g_hbrBackground);
            nX++;
            if (nX*TESTAREAWIDTH+TESTAREAWIDTH>rWindow.right)
            {
                nX=0;
                nY++;
                if (nY*TESTAREAHEIGHT+TESTAREAHEIGHT>rWindow.bottom)
                // If graphics page is full
                {
                    nY=0;
                }
            }
        }
    }

    ReleaseDC(m_hWndMain,hDC);
}

void CFuncTest::Run()
// Runs all selected tests
{
    COutput *pOutput;
    CPrimitive *pPrimitive;
    CSetting *pSetting;
    HWND hWnd;
    HWND hWndOutput;
    int iOutput;
    LRESULT cOutputMax;
    int iItem;
    LRESULT cItemMax;

    InitRun();      // Init test run

    // Do the selected output loop
    hWndOutput=GetDlgItem(m_hWndDlg,IDC_OUTPUTS);
    cOutputMax=SendMessageA(hWndOutput,LB_GETCOUNT,0,0);
    for (iOutput=0;iOutput<cOutputMax;iOutput++) {
        pOutput=(COutput*)SendMessageA(hWndOutput,LB_GETITEMDATA,(WPARAM)iOutput,0);
        if (SendMessageA(hWndOutput,LB_GETSEL,(WPARAM)iOutput,0)<=0)
            continue;

        // Set each setting according to what is selected in the list box
        hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
        cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
        for (iItem=0;iItem<cItemMax;iItem++) {
            pSetting=(CSetting*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);

            if (SendMessageA(hWnd,LB_GETSEL,(WPARAM)iItem,0)>0)
                pSetting->m_bUseSetting=true;
            else
                pSetting->m_bUseSetting=false;
        }

        // Draw each primitive selected in the list box
        hWnd=GetDlgItem(m_hWndDlg,IDC_PRIMITIVES);
        cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
        for (iItem=0;iItem<cItemMax;iItem++) {
            pPrimitive=(CPrimitive*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);

            if (SendMessageA(hWnd,LB_GETSEL,(WPARAM)iItem,0)>0)
                RunTest(pOutput,pPrimitive);
        }
    }

    EndRun();
}

void CFuncTest::ClearAllSettings()
// Clear all settings to m_bUseSetting=false
{
    CSetting *pSetting;
    HWND hWnd;
    LRESULT cItemMax;
    int iItem;

    // Set all settings off
    hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
    cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
    for (iItem=0;iItem<cItemMax;iItem++) {
        pSetting=(CSetting*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);
        pSetting->m_bUseSetting=false;
    }
}

INT_PTR CALLBACK CFuncTest::DlgProc(HWND hWndDlg,UINT Msg,WPARAM wParam,LPARAM lParam)
// Options dialog proc
{
    switch (Msg)
    {
        case WM_INITDIALOG:
            return true;
        case WM_COMMAND:
            if (HIWORD(wParam)==BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_RUN:
                        g_FuncTest.Run();
                        return true;
                    case IDC_CLOSE:
                        EndDialog(hWndDlg,0);
                        return true;
                }
            }
            else if (HIWORD(wParam)==LBN_DBLCLK)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_PRIMITIVES:
                        g_FuncTest.Run();
                        return true;
                }
            }
            break;
        case WM_CLOSE:
            ShowWindow(hWndDlg,SW_HIDE);
            return true;
    }

    return false;
}

#define UNICODE
#define _UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\chdc.h ===
/******************************Module*Header*******************************\
* Module Name: CHDC.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CHDC_H
#define __CHDC_H

#include "COutput.h"

class CHDC : public COutput  
{
public:
	CHDC(BOOL bRegression);
	virtual ~CHDC();

	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	HPALETTE m_hPal;
	HPALETTE m_hOldPal;
	HDC m_hDC;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\chwnd.cpp ===
/******************************Module*Header*******************************\
* Module Name: CHWND.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CHWND.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CHWND::CHWND(BOOL bRegression)
{
	strcpy(m_szName,"HWND");
	m_bRegression=bRegression;
}

CHWND::~CHWND()
{
}

Graphics *CHWND::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;

	g=Graphics::FromHWND(g_FuncTest.m_hWndMain);

	return g;
}

void CHWND::PostDraw(RECT rTestArea)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\coutput.cpp ===
/******************************Module*Header*******************************\
* Module Name: COutput.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "COutput.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

COutput::COutput()
{
	strcpy(m_szName,"No name assigned");
	m_bRegression=false;
}

COutput::~COutput()
{

}

BOOL COutput::Init()
{
	return g_FuncTest.AddOutput(this);
}

void COutput::PostDraw(RECT rTestArea)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\coutput.h ===
/******************************Module*Header*******************************\
* Module Name: COutput.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __COUTPUT_H
#define __COUTPUT_H

#include "Global.h"

class COutput  
{
public:
	COutput();
	virtual ~COutput();

	virtual BOOL Init();										// Add output to output list in functest dialog
	virtual Graphics *PreDraw(int &nOffsetX,int &nOffsetY)=0;	// Set up graphics at the given X,Y offset
	virtual void PostDraw(RECT rTestArea);						// Finish off graphics at rTestArea

	char m_szName[256];
	BOOL m_bRegression;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\chdc.cpp ===
/******************************Module*Header*******************************\
* Module Name: CHDC.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CHDC.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CHDC::CHDC(BOOL bRegression)
{
	strcpy(m_szName,"HDC");
	m_hPal=NULL;
	m_hOldPal=NULL;
	m_hDC=NULL;
	m_bRegression=bRegression;
}

CHDC::~CHDC()
{
}

Graphics *CHDC::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;

	m_hDC=GetDC(g_FuncTest.m_hWndMain);
	g=Graphics::FromHDC(m_hDC);

	return g;
}

void CHDC::PostDraw(RECT rTestArea)
{
	if (m_hOldPal)
		SelectPalette(m_hDC,m_hOldPal,FALSE);

	ReleaseDC(g_FuncTest.m_hWndMain,m_hDC);
	DeleteObject(m_hPal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\chwnd.h ===
/******************************Module*Header*******************************\
* Module Name: CHWND.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CHWND_H
#define __CHWND_H

#include "COutput.h"

class CHWND : public COutput  
{
public:
	CHWND(BOOL bRegression);
	virtual ~CHWND();

	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\cpaths.h ===
/******************************Module*Header*******************************\
* Module Name: CPaths.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPATHS_H
#define __CPATHS_H

#include "CPrimitive.h"

class CPaths : public CPrimitive  
{
public:
	CPaths(BOOL bRegression);
	virtual ~CPaths();

	void Draw(Graphics *g);

	VOID TestBezierPath(Graphics* g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\cpaths.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPaths.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPaths.h"
#include <limits.h>
#include <stdio.h>

extern gnPaths;
extern HWND g_hWndMain;

CPaths::CPaths(BOOL bRegression)
{
	strcpy(m_szName,"Paths");
	m_bRegression=bRegression;
}

CPaths::~CPaths()
{
}

void CPaths::Draw(Graphics *g)
{
    TestBezierPath(g);
}

VOID CPaths::TestBezierPath(Graphics *g)
{
    REAL width = 4;         // Pen width
    REAL offset;
    Point points[4];
    RectF rect;
    RECT  crect;
    int   i;

    // find avg size of testarea. 4 => top & bottom strokes of path + a white
    // width wide border, plus 1 => the white square in the center
    GetClientRect(g_hWndMain, &crect);
    width = (REAL)((crect.bottom - crect.top) / ((4 * gnPaths) + 1));
    offset = width;

    Color blackColor(128, 0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);

    for(i = 1; i <= gnPaths; i++) {

        GraphicsPath* path = new GraphicsPath(FillModeAlternate);

        rect.X = offset;
        rect.Y = offset;
        rect.Width = crect.right - (2 * offset);
        rect.Height = crect.bottom - (2 * offset);

        path->AddRectangle(rect);
        g->DrawPath(&blackPen, path);

        delete path;

        offset += (width * 2);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\cprimitive.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrimitive.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrimitive.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CPrimitive::CPrimitive()
{
	strcpy(m_szName,"No name assigned");
	m_bRegression=false;
}

CPrimitive::~CPrimitive()
{

}

BOOL CPrimitive::Init()
{
	g_FuncTest.AddPrimitive(this);
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\cprimitive.h ===
/******************************Module*Header*******************************\
* Module Name: CPrimitive.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRIMITIVE_H
#define __CPRIMITIVE_H

#include "Global.h"

class CPrimitive  
{
public:
	CPrimitive();
	virtual ~CPrimitive();

	virtual BOOL Init();
	virtual void Draw(Graphics *g)=0;
    void SetOffset(int x, int y)
    {
        m_ix = x;
        m_iy = y;
    }

	char m_szName[256];
	BOOL m_bRegression;

    // Offset for this test.

    INT m_ix;
    INT m_iy;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\cprinter.h ===
/******************************Module*Header*******************************\
* Module Name: CPrinter.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRINTER_H
#define __CPRINTER_H

#include "COutput.h"

class CPrinter : public COutput  
{
public:
	CPrinter(BOOL bRegression);
	virtual ~CPrinter();

	BOOL Init();
	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	HDC m_hDC;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\cprinting.h ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRINTING_H
#define __CPRINTING_H

#include "..\CPrimitive.h"

class CPrinting : public CPrimitive  
{
public:
	CPrinting(BOOL bRegression);
	virtual ~CPrinting();

	void Draw(Graphics *g);

	VOID TestPerfPrinting(Graphics *g);
	VOID TestTextPrinting(Graphics *g);
        
        VOID TestNolan1(Graphics *g);
        VOID TestNolan2(Graphics *g);

        VOID TestBug104604(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\cprinting.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrinting.h"

CPrinting::CPrinting(BOOL bRegression)
{
	strcpy(m_szName,"Printing");
	m_bRegression=bRegression;
}

CPrinting::~CPrinting()
{
}

VOID CPrinting::TestTextPrinting(Graphics *g)
{
    Font f(L"Arial", 60);

    FontFamily  ff(L"Arial");
    RectF	  rectf1( 20,   0, 300, 200);
    RectF	  rectf2( 20, 300, 300, 200);
    RectF	  rectf3(220,   0, 300, 200);
    RectF	  rectf4(220, 300, 300, 200);


    Color color1(0xff, 100, 0, 200);
    Color color2(128, 100, 0, 200);
    Color color3(0xff, 0, 100, 200);
    Color color4(128, 0, 100, 0);
    SolidBrush brush1(color1);
    SolidBrush brush2(color2);
    LinearGradientBrush brush3(rectf3, color3, color4, LinearGradientModeForwardDiagonal);

    g->DrawString(L"Color1", 6, &f, rectf1, NULL, &brush1);
    g->DrawString(L"Color2", 6, &f, rectf2, NULL, &brush2);
    g->DrawString(L"Color3", 6, &f, rectf3, NULL, &brush3);
}

VOID CPrinting::TestPerfPrinting(Graphics *g)
{
/*
   Analyze file size based on output of StretchDIBits.  The claim by DonC is that when we StretchDIBits a
   subrectangle of a large DIB, it sends the large DIB to the printer and then clips to the subrectangle.
   How stupid, but it apparently does on Win98 postscript.

   So this is the results of my test:  1000x1000 DIB (32bpp).  I blitted two chunks:

   This is 200x200 source rectangle (part of a band):

04/27/2000  03:00p              22,198 nt5pcl
04/27/2000  03:02p             268,860 nt5ps			// Level 1 ps
04/27/2000  02:47p              17,488 w98pcl
04/27/2000  02:47p           6,207,459 w98ps			// Level 1 ps

   This is 1000x200 source rectangle (an entire band):

04/27/2000  03:06p              80,291 nt5pcl
04/27/2000  03:06p           1,266,123 nt5ps			// Level 1 ps
04/27/2000  02:51p              60,210 w98pcl
04/27/2000  02:52p           6,207,457 w98ps			// Level 1 ps

   Also compared 32bpp vs. 24bpp DIB.  The results were contradictary:

  04/27/2000  03:59p      <DIR>          ..
  04/27/2000  03:06p              80,291 nt5pcl
  04/27/2000  03:51p             122,881 nt5pcl24
  04/27/2000  03:06p           1,266,123 nt5ps
  04/27/2000  03:51p           1,262,332 nt5ps24
  04/27/2000  02:51p              60,210 w98pcl
  04/27/2000  03:39p             101,216 w98pcl24
  04/27/2000  02:52p           6,207,457 w98ps
  04/27/2000  03:39p           6,207,457 w98ps24

*/
    if (1) 
    {
        BITMAPINFO bi;
        ZeroMemory(&bi, sizeof(BITMAPINFO));

        bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biSizeImage = 0;

        bi.bmiHeader.biWidth = 1000;
        bi.bmiHeader.biHeight = 1000;
        bi.bmiHeader.biBitCount = 32;

        ARGB* Bits = (ARGB*)malloc(bi.bmiHeader.biWidth *
                              bi.bmiHeader.biHeight *
                              sizeof(ARGB));

        ARGB* Ptr = Bits;

        // To eliminate RLE/ASCII85 encoding, set to random bits
        for (INT i=0; i<bi.bmiHeader.biHeight; i++)
            for (INT j=0; j<bi.bmiHeader.biWidth; j++) 
            {
                *Ptr++ = (ARGB)(i | (j<<16));
            }

        HDC hdc = g->GetHDC();

        StretchDIBits(hdc, 0, 0, 1000, 200, 
                      0, 700, 1000, 200, Bits, &bi,
                      DIB_RGB_COLORS, SRCCOPY);

        g->ReleaseHDC(hdc);

        free(Bits);

    }
}

void CPrinting::Draw(Graphics *g)
{
// TestPerfPrinting(g);
// TestTextPrinting(g);
TestBug104604(g);

if (0)
    {

#if 1
    HDC hdc = g->GetHDC();

    HDC bufHdc = CreateCompatibleDC(hdc);

    HBITMAP BufDIB = NULL;
    ARGB* argb;

    struct {
       BITMAPINFO bitmapInfo;
       RGBQUAD rgbQuad[4];
    } bmi;

    INT width=100;
    INT height=100;

    ZeroMemory(&bmi.bitmapInfo, sizeof(bmi.bitmapInfo));

    bmi.bitmapInfo.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bitmapInfo.bmiHeader.biWidth       = width;
    bmi.bitmapInfo.bmiHeader.biHeight      = -height;
    bmi.bitmapInfo.bmiHeader.biPlanes      = 1;
    bmi.bitmapInfo.bmiHeader.biBitCount    = 24;
    bmi.bitmapInfo.bmiHeader.biCompression = BI_RGB;
	
    RGBQUAD red = { 0, 0, 0xFF, 0}; // red
    RGBQUAD green = { 0, 0xFF, 0, 0}; // green
    RGBQUAD blue = { 0xFF, 0, 0, 0}; // blue

    bmi.bitmapInfo.bmiColors[0] = red;
    bmi.bitmapInfo.bmiColors[1] = green;
    bmi.bitmapInfo.bmiColors[2] = blue;

    // if assert fails, then we didn't clean up properly by calling End()
//    ASSERT(BufDIB == NULL);

    BufDIB = CreateDIBSection(bufHdc,
                 &bmi.bitmapInfo,
                 DIB_RGB_COLORS,
                 (VOID**) &argb,
                 NULL,
                 0);
//    ASSERT(BufDIB != NULL);

    memset(argb, 0, 3*width*height);

    INT i,j;
    BYTE* tempptr = (BYTE*)argb;
    for (i=0; i<height; i++)
    {
        for (j=0; j<width; j++)
        {
            if (i==j)
            {
                *tempptr++ = 0xFF;
                *tempptr++ = 0x80;
                *tempptr++ = 0x40;
            }
            else
                tempptr += 3;    
        }
        if ((((ULONG_PTR)tempptr) % 4) != 0) tempptr += 4-(((ULONG_PTR)tempptr) % 4);
    }

    INT mode = GetMapMode(bufHdc);
//    WARNING(("MapMode printing = %08x\n", mode));

    SelectObject(bufHdc, BufDIB);
/*
for (i=0; i<100; i++)
{
    int result = StretchBlt(hdc, 0, i*2, 2*width, 2, bufHdc, 0, i, width, 0, SRCCOPY);
    INT joke = GetLastError();
	joke++;
}
 */
//	int result = StretchBlt(hdc, 0, 0, 50, 50, bufHdc, 0, 0, 50, 50, SRCCOPY);
	
	for (i=0; i<50; i++)
	{
		int result = StretchBlt(hdc, 0, 100+i*2, 100, 1, bufHdc, 0, i*2, 100, 1, SRCCOPY);
    }
//   int result = StretchBlt(hdc, 0, 0, 200, 200, bufHdc, 0, 0, 100, 100, SRCCOPY);

//    ASSERT(result != 0);

    g->ReleaseHDC(hdc);

    DeleteDC(bufHdc);
    DeleteObject(BufDIB);

#endif

#if 1
    REAL widthF = 4; // Pen width

    Color redColor(255, 0, 0);

    SolidBrush brush1(Color(0xFF,0xFF,0,0));
    SolidBrush brush2(Color(0x80,0x80,0,0));

    SolidBrush brush3(Color(0xFF,0xFF,0,0));
    SolidBrush brush4(Color(0x80,0x80,0,0));

    Color colors1[] = { Color(0xFF,0xFF,0,0),
                        Color(0xFF,0,0xFF,0),
                        Color(0xFF,0,0,0xFF),
                        Color(0xFF,0x80,0x80,0x80) };
    Color colors2[] = { Color(0x80,0xFF,0,0),
                        Color(0x80,0,0xFF,0),
                        Color(0x80,0,0,0xFF),
                        Color(0x80,0x80,0x80,0x80) };

    //SolidBrush brush3(colors1[2]);
    //SolidBrush brush4(colors2[2]);

    // Default Wrap: Clamp to small rectangle 
//    RectangleGradientBrush brush3(Rect(125,275,50,50),
//                                  &colors1[0]);//,
                                  //WrapModeClamp);
    // Default Wrap: Clamp to 
//    RectangleGradientBrush brush4(Rect(250,250,100,100),
//                                  &colors2[0]);//,
                                  //WrapModeClamp);

    g->SetPageScale(1.2f);

    // no path clip
    g->FillRectangle(&brush1, Rect(0,25,500,50));

    // tests solid + opaque combinations + path clip only
    g->FillEllipse(&brush1, Rect(100,100,100,100));
    g->FillEllipse(&brush2, Rect(300,100,100,100));
    g->FillEllipse(&brush3, Rect(100,250,100,100));
    g->FillEllipse(&brush4, Rect(300,250,100,100));

    // tests visible clip + path clip
    Region origRegion;
    g->GetClip(&origRegion);
    Region *newRegion = new Region();
    newRegion->MakeInfinite();

    //Rect horzRect(150, 600, 500, 25);
    //Rect vertRect(150, 600, 25, 500);
    Rect horzRect(100, 400, 500, 25);
    Rect vertRect(100, 400, 25, 500);
    Region *horzRegion = new Region(horzRect);
    Region *vertRegion = new Region(vertRect);

    for (i = 0; i < 10; i++)
    {   
        newRegion->Xor(horzRegion);
        newRegion->Xor(vertRegion);
        horzRegion->Translate(0, 50);
        vertRegion->Translate(50, 0);
    }
    delete horzRegion;
    delete vertRegion;

    // Set grid clipping
    g->SetClip(newRegion);

    // set wrap mode from Clamp to Tile    
//    brush3.SetWrapMode(WrapModeTile);
//    brush4.SetWrapMode(WrapModeTile);

    // tests solid + opaque combinations + visible clip +  path clip only

    g->FillEllipse(&brush1, Rect(100,400,100,100));
    g->FillEllipse(&brush2, Rect(300,400,100,100));
    g->FillEllipse(&brush3, Rect(100,550,100,100));
    g->FillEllipse(&brush4, Rect(300,550,100,100));

    // restore original clip region
    g->SetClip(&origRegion);
    delete newRegion;

    // Test case which stretches beyond GetTightBounds() DrawBounds API

    PointF pts[8];

    pts[0].X = 2150.0f; pts[0].Y = 2928.03f;
    pts[1].X = 1950.0f; pts[1].Y = 3205.47f;
    pts[2].X = 1750.0f; pts[2].Y = 2650.58f;
    pts[3].X = 1550.0f; pts[3].Y = 2928.03f;
    pts[4].X = 1550.0f; pts[4].Y = 3371.97f;
    pts[5].X = 1750.0f; pts[5].Y = 3094.53f;
    pts[6].X = 1950.0f; pts[6].Y = 3649.42f;
    pts[7].X = 2150.0f; pts[7].Y = 3371.97f;

    BYTE types[8] = { 1, 3, 3, 3, 1, 3, 3, 0x83 };


    Bitmap *bitmap = new Bitmap(L"winnt256.bmp");

    // Test g->DrawImage
    if (bitmap && bitmap->GetLastStatus() == Ok) 
    {

        int i;

        for (i=0; i<8; i++) 
        {
            pts[i].X = pts[i].X / 8.0f;
            pts[i].Y = pts[i].Y / 8.0f;
        }

        TextureBrush textureBrush(bitmap, WrapModeTile);

        GraphicsPath path(&pts[0], &types[0], 8);

        g->FillPath(&textureBrush, &path);

        // Text using WrapModeClamp
        for (i=0; i<8; i++)
           pts[i].X += 200.0f;

        TextureBrush textureBrush2(bitmap, WrapModeClamp);

        GraphicsPath path2(&pts[0], &types[0], 8);

        g->FillPath(&textureBrush2, &path2);

        delete bitmap;
    }

/*
    Font font(50.0f * g->GetDpiY() / 72.0f, // emSize
              FontFamily(L"Arial"), // faceName,
              0,
              (Unit)g->GetPageUnit()
              );

    // will fail on Win9x
    LPWSTR str = L"Printing Support is COOL";
    GpRectF layoutRect1(200, 200, 300, 100);
    GpRectF layoutRect2(200, 400, 300, 100);
    GpRectF layoutRect3(200, 600, 300, 100);
    GpRectF layoutRect4(200, 800, 300, 100);

    INT len = 0;
    LPWSTR strPtr = str;
    while (*str != '\0') { len++; str++; }

    StringFormat format1 = StringFormatDirectionRightToLeft;
    StringFormat format2 = StringFormatDirectionVertical;
    StringFormat format3 = StringFormatDirectionRightToLeft;
    StringFormat format4 = StringFormatDirectionVertical;

    // Test DDI: SolidText (Brush 1 or 2)
    g->DrawString(strPtr, len, &font, &layoutRect1, &format1, &brush1);
    g->DrawString(strPtr, len, &font, &layoutRect2, &format2, &brush2);   

    // Test DDI: BrushText (Brush 3 or 4)
    g->DrawString(strPtr, len, &font, &layoutRect3, &format3, &brush3);
    g->DrawString(strPtr, len, &font, &layoutRect4, &format4, &brush4);   

    // Test DDI: StrokePath
    // Test DDI: FillRegion
*/
#endif
    }

}

// Try this from Nolan Lettelier
VOID CPrinting::TestNolan1(Graphics *g)
{
/*	TestInit(hdc);

	Graphics *pg = Graphics::FromHDC(hdc);
	if (pg == NULL)
	{
		assert(0);
		return false;
	}

	int sts;
	int alpha = 255, red = 255, green = 0, blue = 255;
	Color c1(alpha,red,green,blue);
	Point p1(150,150), p2(300,300);
	Color c2(255, 255-red, 255-green, 255-blue);
	LineGradientBrush gb(p1, p2, c1, c2);

	Pen p(&gb, 50.0);

	sts = pg->DrawLine(&p,0, 0, 500, 500);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,100, 500, 100);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,350, 500, 350);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,500, 500, 0);
	assert(sts == Ok);
	delete pg;
	return true;
        */
}

VOID CPrinting::TestNolan2(Graphics *g)
{
    /*
        CString lineText("NolanRules");
        
	Graphics *pg = g;
        if (pg == NULL)
	{
		assert(0);
		return false;
	}
        Unit origUnit = pg->GetPageUnit();
        Matrix origXform;
        pg->GetTransform(&origXform);

        pg->SetPageUnit(UnitInch);
        pg->ScaleTransform(8.0f/1000.0f, 8.0f/1000.0f);

	Status sts;
	int alpha = 255, red = 255, green = 0, blue = 255;
	RectF rg(150,150,300,175);
	Color c1(alpha,red,green,blue);
	Color c2(255, 255-red, 255-green, 255-blue);
	LineGradientBrush gb(rg, c1, c2, LineGradientModeVertical);

	WCHAR *famName[] = {
		L"Comic Sans MS"
		, L"Courier New"
		, L"Times New Roman"
		, L"Tahoma"
		, L"Arial"
		, L"Lucida Console"
		, L"Garamond"
		, L"Palatino"
		, L"Univers"
		, L"Marigold"
		, L"Albertus"
		, L"Antique Olive"
	};

	int famCount = sizeof(famName) / sizeof(WCHAR *);

	WCHAR *s = L"GDI+ GradientFill";
	
	RectF r(30,30,0,0);
	StringFormat sf(0);
	FontFamily *pFontFamily;

	float lineHeight = 60;
	int i;
	for (i = 0, r.Y = 30 ; r.Y < 800 ; r.Y += lineHeight, ++i)
	{
		pFontFamily = new FontFamily(famName[i % famCount]);
		while (pFontFamily == NULL || pFontFamily->GetLastStatus()
!= Ok)
		{
			delete pFontFamily;
			++i;
			pFontFamily = new FontFamily(famName[i % famCount]);
		}
			
		Font f(*pFontFamily, lineHeight * 5 / 6, 0, UnitPoint);
		sts = pg->DrawString(s, wcslen(s), &f, &r, &sf, &gb);
//		CHECK_RESULT(sts, "TestGradientLinearVertical2 DrawString");
		delete pFontFamily;
	}

	delete pg;
	
        pg->SetPageUnit(origUnit);
        pg->SetTransform(&origXform);
        return true;
*/

} // TestGradientLinearVertical2

VOID CPrinting::TestBug104604(Graphics *g)
{
    BYTE* memory = new BYTE[8*8*3];
    // checkerboard pattern
    for (INT i=0; i<8*8; i += 3)
    {
        if (i%2)
        {
            memory[i] = 0xff;
            memory[i+1] = 0;
            memory[i+2] = 0;
        }
        else
        {
            memory[i] = 0;
            memory[i+1] = 0;
            memory[i+2] = 0xff;
        }
    }
    
    Bitmap bitmap(8,8, 8*3, PixelFormat24bppRGB, memory);
    
    TextureBrush brush(&bitmap);

    g->SetCompositingMode(CompositingModeSourceCopy);
    g->FillRectangle(&brush, 0, 0, 100, 100);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\cprinter.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrinter.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrinter.h"

CPrinter::CPrinter(BOOL bRegression)
{
	m_hDC=NULL;
	strcpy(m_szName,"Printer");
	m_bRegression=bRegression;
}

CPrinter::~CPrinter()
{
}

BOOL CPrinter::Init()
{
	// hidden API to turn on our printing code
	DllExports::GdipDisplayPaletteWindowNotify((WindowNotifyEnum)0xFFFFFFFF);

	return COutput::Init();
}

Graphics *CPrinter::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;

	PRINTDLGA pd =
	{
	   sizeof(PRINTDLG),
	   NULL,            // hwndOwner
	   NULL,            // hDevMode
	   NULL,            // hDevNames
	   NULL,            // hDC
	   PD_RETURNDC,
	   1,
	   1,
	   1,
	   1,
	   1,
	   GetModuleHandleA(NULL),
	   NULL,
	   NULL,            // print hook
	   NULL,            // setup hook
	   NULL,            // print template name
	   NULL,            // setup template name
	   NULL,            // hPrintTemplate
	   NULL             // hSetupTemplate
	};

	if (!PrintDlgA(&pd))
	{
	   MessageBoxA(NULL, "No printer selected.", NULL, MB_OK);
	   return NULL;
	}

	DOCINFOA docinfo;
	docinfo.cbSize        = sizeof(DOCINFO);
	docinfo.lpszDocName   = "GDI+ Print Test";
	docinfo.lpszOutput    = NULL;         // put name here to output to file
	docinfo.lpszDatatype  = NULL;         // data type 'emf' or 'raw'
	docinfo.fwType        = 0;

	m_hDC = pd.hDC;
	INT printJobID = StartDocA(m_hDC, &docinfo);
	StartPage(m_hDC);

	SetStretchBltMode(m_hDC, HALFTONE);
	SetBrushOrgEx(m_hDC, 0, 0, NULL);

	g = Graphics::FromHDC(m_hDC);

	return g;
}

void CPrinter::PostDraw(RECT rTestArea)
{
	EndPage(m_hDC);
	EndDoc(m_hDC);
	DeleteDC(m_hDC);

	MessageBoxA(NULL, "Print Functionality Test Complete.", NULL, MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\csetting.h ===
/******************************Module*Header*******************************\
* Module Name: CSetting.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CSETTING_H
#define __CSETTING_H

#include "Global.h"

class CSetting  
{
public:
	CSetting();
	virtual ~CSetting();

	virtual BOOL Init();
	virtual void Set(Graphics *g)=0;

	char m_szName[256];
	BOOL m_bUseSetting;
	BOOL m_bRegression;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\csetting.cpp ===
/******************************Module*Header*******************************\
* Module Name: CSetting.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CSetting.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CSetting::CSetting()
{
	strcpy(m_szName,"No name assigned");
	m_bUseSetting=false;
	m_bRegression=false;
}

CSetting::~CSetting()
{

}

BOOL CSetting::Init()
{
	g_FuncTest.AddSetting(this);
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\debug.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   Debugging macros
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   09/07/1999 agodfrey
*       Moved from Engine\Common
*   02/07/2000 agodfrey
*       Made more of it private (for bug #35561).
*       Changed the output function to add "\n" automatically.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

// ONCE(code block)
//  Use this to make a code block execute only once per run.
//  Useful for cutting down on spew.
//  e.g.:
//      ONCE(WARNING(("Invalid arguments")));

#define ONCE(codeblock)      \
    {                        \
        static int doneOnce; \
        if (!doneOnce)       \
        {                    \
            { codeblock ; }  \
            doneOnce=1;      \
        }                    \
    }

#if DBG

// Global debug level

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_RIP     4

extern int GpDebugLevel;

///////////////////////////// DEPRECATED STUFF ///////////////////////////////

// Raw output function. Emits debug messages. Its direct use is depracated.
// It's useful for private debugging, though.

unsigned long _cdecl DbgPrint(char*, ...);

// Strip the directory prefix from a filename

const char*
StripDirPrefix(
    const char* filename
    );

// Use of DBGMSG is depracated - it's supplied only because driverd3d.cpp uses
// it.

#define DBGMSG(level, prefix, msg)       \
        {                                \
            if (GpDebugLevel <= (level)) \
            {                            \
                DbgPrint("%s %s (%d): ", prefix, StripDirPrefix(__FILE__), __LINE__); \
                DbgPrint msg;            \
            }                            \
        }

///////////////////////////// PRIVATE STUFF //////////////////////////////////

// Just leave this function alone. You don't want to call it yourself. Trust me.
char * _cdecl GpParseDebugString(char* format, ...);

// Ditto for this one.
void _cdecl GpLogDebugEvent(int level, char *file, unsigned int line, char *message);

#define LOG_DEBUG_EVENT(level, msg)                                  \
    {                                                                \
        if (GpDebugLevel <= (level))                                 \
        {                                                            \
            char *debugOutput = GpParseDebugString msg;              \
            GpLogDebugEvent(level, __FILE__, __LINE__, debugOutput); \
        }                                                            \
    }

//////////////////////////////// THE GOOD STUFF //////////////////////////////

// These macros are used for debugging. They expand to
// whitespace on a free build.
//
// GpDebugLevel
//  Global variable which holds the current debug level. You can use it to
//  control the quantity of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ASSERT(cond)
//  Verify that a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify that a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//
//  These macros require extra parentheses for the msg argument
//  for example:
//      WARNING(("App passed NULL pointer; ignoring it."));
//      ASSERTMSG(x > 0, ("x is less than 0"));
//
//  Each call to an output function is treated as a separate event -
//  if you want to build up a message, e.g. in a loop, build it up in a
//  string, and then call the output function.
//
//  This is because we don't always just output the string to the debugger -
//  when we link statically, we may send the output to a user-defined handler.
//
//  Don't put a trailing \n on the message. If the output is sent to the
//  debugger, the output function will add the \n itself.

#define VERBOSE(msg) LOG_DEBUG_EVENT(DBG_VERBOSE, msg)
#define TERSE(msg) LOG_DEBUG_EVENT(DBG_TERSE, msg)
#define WARNING(msg) LOG_DEBUG_EVENT(DBG_WARNING, msg)
#define RIP(msg) LOG_DEBUG_EVENT(DBG_RIP, msg)

#define ASSERT(cond)   \
    {                  \
        if (! (cond))  \
        {              \
            RIP(("Assertion failure: %s", #cond)); \
        }              \
    }

#define ASSERTMSG(cond, msg) \
    {                        \
        if (! (cond))        \
        {                    \
            RIP(msg);        \
        }                    \
    }

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define DBGMSG(level, prefix, msg) {}
#define VERBOSE(msg) {}
#define TERSE(msg) {}
#define WARNING(msg) {}

#define RIP(msg) {}
#define ASSERT(cond) {}
#define ASSERTMSG(cond, msg) {}

#endif // !DBG

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\debug.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*   Debugging routines
*
* Revision History:
*
*   09/07/1999 agodfrey
*       Created it.
*
\**************************************************************************/
#include "global.h"

// Optional callback function for reporting a debug event.

enum GpAltDebugEventLevel
{
    GpAltDebugFatal,
    GpAltDebugWarning
};

#define GpAltDebugEventFunction 0
//DEBUGEVENTFUNCTION GpAltDebugEventFunction = NULL;

#if DBG

// GpDebugLevel is used to control the amount/severity of debugging messages
// that are actually output.

int GpDebugLevel = DBG_TERSE;

/**************************************************************************\
*
* Function Description:
*
*   Removes the path portion of a pathname
*
* Arguments:
*
*   [IN] str - pathname to strip
*
* Return Value:
*
*   A pointer to the filename portion of the pathname
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

const char*
StripDirPrefix(
    const char* str
    )

{
    const char* p;

    p = strrchr(str, '\\');
    return p ? p+1 : str;
}

const int maxInputStringSize = 1024;

/**************************************************************************\
*
* Function Description:
*
*   Outputs to the debugger
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   Zero. This is to conform to NTDLL's definition of DbgPrint.
*
* Notes:
*
*   There will be no output if a debugger is not connected.
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

ULONG _cdecl
DbgPrint(
    char* format,
    ...
    )

{
    va_list arglist;
    va_start(arglist, format);
    
    char buf[maxInputStringSize];
    
    _vsnprintf(buf, maxInputStringSize, format, arglist);
    buf[maxInputStringSize-1]=0;
        
    OutputDebugStringA(buf);
    
    va_end(arglist);
    return 0;
}

// If we can't allocate memory for the debug string, we'll use this buffer
// in desperation. It's not thread-safe. I *did* say 'desperation'.

static char desperationBuffer[maxInputStringSize];

/**************************************************************************\
*
* Function Description:
*
*   Creates a new string, and sprintf's to it.
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   The probably-newly-allocated string result.
*
* Notes:
*
*   This function is not intended for general use. It guards against memory
*   failure by using a global buffer. So, while the caller is responsible
*   for freeing the memory, the caller must also check for that buffer.
*   i.e. we only want DbgEmitMessage to call this.
*
*   It's also only mostly thread-safe, because if we run out of memory,
*   we'll use that global buffer in a non-protected way.
*
*   This is the only solution I could find so that I could move most of the
*   implementation details out of the header file. The root cause is that
*   macros don't handle multiple arguments natively, so we have to pass
*   the printf arguments as a single macro argument (in parentheses).
*   Which means, the function that consumes those arguments can have no
*   other arguments.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it. Finally, I've found a way to get debug implementation
*       details out of the headers.
*
\**************************************************************************/

char * _cdecl
GpParseDebugString(
    char* format,
    ...
    )
{
    va_list arglist;
    va_start(arglist, format);
    
    // Don't use GpMalloc here so that we can use ASSERT and WARNING in 
    // our memory allocation routines.

    char *newBuf = static_cast<char *>(LocalAlloc(LMEM_FIXED, maxInputStringSize));
    if (!newBuf)
    {
        newBuf = desperationBuffer;
    }
    
    _vsnprintf(newBuf, maxInputStringSize, format, arglist);
    
    // Nuke the last byte, because MSDN isn't clear on what _vsnprintf does
    // in that case.
    
    newBuf[maxInputStringSize-1]=0;
        
    va_end(arglist);
    return newBuf;
}

/**************************************************************************\
*
* Function Description:
*
*   Processes a debug event. Frees the message string.
*
* Arguments:
*
* level   - The debug level of the event 
* file    - Should be __FILE__
* line    - Should be __LINE__
* message - The debug message.
*
* Notes:
*
*   You don't want to call this directly. That would be error-prone. 
*   Use ASSERT, WARNING, etc.
*
*   In Office, it will raise an 'assert' dialog if necessary.
*
*   Depending on the debug level, an identifying prefix will be output.
*
*   If the debug level is DBG_RIP, will suspend execution (e.g. by
*   hitting a breakpoint.)
*
* Note on Office interop:
*
*   Under Office, we'll pass WARNINGs and ASSERTs to a reporting function
*   they provide. Their function will breakpoint on ASSERTs.
*   Lesser events will just be sent to the debugger.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it.
*
\**************************************************************************/

void _cdecl 
GpLogDebugEvent(
    int level, 
    char *file, 
    unsigned int line,
    char *message
    )
{
    // We may want to add things to the passed-in message. So we need
    // a temporary buffer
    
    const int maxOutputStringSize = maxInputStringSize + 100;
    char tempBuffer[maxOutputStringSize+1];
    
    // MSDN's _vsnprintf doc isn't clear on this, so just in case:
    tempBuffer[maxOutputStringSize] = 0;
    int altDebugLevel = -1;
    
    char *prefix = "";
    
    if (GpDebugLevel <= (level))
    {
        switch (level)
        {
        case DBG_WARNING:
            prefix = "WRN ";
            if (GpAltDebugEventFunction)
            {
                altDebugLevel = GpAltDebugWarning;
            }    
            break;
            
        case DBG_RIP:
            prefix = "RIP ";
            if (GpAltDebugEventFunction)
            {
                altDebugLevel = GpAltDebugFatal;
            }    
            break;
        }
        
        // The convention is that we append the trailing \n, not the caller.
        // Two reasons:
        // 1) Callers tend to forget it.
        // 2) More importantly, it encourages the caller to think of each
        //    call as a separate event. This is important in some cases - e.g.
        //    when Office produces a popup for each event.

        _snprintf(
            tempBuffer, 
            maxOutputStringSize, 
            "%s%s(%d): %s\n",
            prefix,
            StripDirPrefix(file),
            line,
            message
            );
        
        if (altDebugLevel >= 0)
        {
            //GpAltDebugEventFunction(altDebugLevel, tempBuffer);
        }
        else
        {
            OutputDebugStringA(tempBuffer);
        }
    }
    
    // Free the message buffer
    
    if (message != desperationBuffer)
    {
        LocalFree(message);
    }
    
    // Force a breakpoint, if it's warranted.
    
    if ((GpDebugLevel <= DBG_RIP) && (level == DBG_RIP) && (altDebugLevel < 0))
    {
        DebugBreak();
    }
}
    
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\guid.c ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   GUID definition file
*
*   GUIDs that are needed by functest are defined here.
*
* Revision History:
*
*   10/22/1999 bhouse
*       Created it.
*
\**************************************************************************/

// NOTE: Since we use C++ precompiled headers this C file will not use
//       the precompiled header allowing us to define INITGUID and include
//       directdraw and d3d headers to generate the GUIDs defined by these
//       headers.

#define INITGUID
#include <ddraw.h>
#include <d3d.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\emfdcode\debug.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   Debugging macros
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   09/07/1999 agodfrey
*       Moved from Engine\Common
*   02/07/2000 agodfrey
*       Made more of it private (for bug #35561).
*       Changed the output function to add "\n" automatically.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

// ONCE(code block)
//  Use this to make a code block execute only once per run.
//  Useful for cutting down on spew.
//  e.g.:
//      ONCE(WARNING(("Invalid arguments")));

#define ONCE(codeblock)      \
    {                        \
        static int doneOnce; \
        if (!doneOnce)       \
        {                    \
            { codeblock ; }  \
            doneOnce=1;      \
        }                    \
    }

#if DBG

// Global debug level

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_RIP     4

extern int GpDebugLevel;

///////////////////////////// DEPRECATED STUFF ///////////////////////////////

// Raw output function. Emits debug messages. Its direct use is depracated.
// It's useful for private debugging, though.

unsigned long _cdecl DbgPrint(char*, ...);

// Strip the directory prefix from a filename

const char*
StripDirPrefix(
    const char* filename
    );

// Use of DBGMSG is depracated - it's supplied only because driverd3d.cpp uses
// it.

#define DBGMSG(level, prefix, msg)       \
        {                                \
            if (GpDebugLevel <= (level)) \
            {                            \
                DbgPrint("%s %s (%d): ", prefix, StripDirPrefix(__FILE__), __LINE__); \
                DbgPrint msg;            \
            }                            \
        }

///////////////////////////// PRIVATE STUFF //////////////////////////////////

// Just leave this function alone. You don't want to call it yourself. Trust me.
char * _cdecl GpParseDebugString(char* format, ...);

// Ditto for this one.
void _cdecl GpLogDebugEvent(int level, char *file, unsigned int line, char *message);

#define LOG_DEBUG_EVENT(level, msg)                                  \
    {                                                                \
        if (GpDebugLevel <= (level))                                 \
        {                                                            \
            char *debugOutput = GpParseDebugString msg;              \
            GpLogDebugEvent(level, __FILE__, __LINE__, debugOutput); \
        }                                                            \
    }

//////////////////////////////// THE GOOD STUFF //////////////////////////////

// These macros are used for debugging. They expand to
// whitespace on a free build.
//
// GpDebugLevel
//  Global variable which holds the current debug level. You can use it to
//  control the quantity of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ASSERT(cond)
//  Verify that a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify that a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//
//  These macros require extra parentheses for the msg argument
//  for example:
//      WARNING(("App passed NULL pointer; ignoring it."));
//      ASSERTMSG(x > 0, ("x is less than 0"));
//
//  Each call to an output function is treated as a separate event -
//  if you want to build up a message, e.g. in a loop, build it up in a
//  string, and then call the output function.
//
//  This is because we don't always just output the string to the debugger -
//  when we link statically, we may send the output to a user-defined handler.
//
//  Don't put a trailing \n on the message. If the output is sent to the
//  debugger, the output function will add the \n itself.

#define VERBOSE(msg) LOG_DEBUG_EVENT(DBG_VERBOSE, msg)
#define TERSE(msg) LOG_DEBUG_EVENT(DBG_TERSE, msg)
#define WARNING(msg) LOG_DEBUG_EVENT(DBG_WARNING, msg)
#define RIP(msg) LOG_DEBUG_EVENT(DBG_RIP, msg)

#define ASSERT(cond)   \
    {                  \
        if (! (cond))  \
        {              \
            RIP(("Assertion failure: %s", #cond)); \
        }              \
    }

#define ASSERTMSG(cond, msg) \
    {                        \
        if (! (cond))        \
        {                    \
            RIP(msg);        \
        }                    \
    }

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define DBGMSG(level, prefix, msg) {}
#define VERBOSE(msg) {}
#define TERSE(msg) {}
#define WARNING(msg) {}

#define RIP(msg) {}
#define ASSERT(cond) {}
#define ASSERTMSG(cond, msg) {}

#endif // !DBG

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\global.h ===
/******************************Module*Header*******************************\
* Module Name: Global.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __GLOBAL_H
#define __GLOBAL_H

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <objbase.h>
#include <math.h>
#include <winspool.h>
#include <commdlg.h>
#include <wingdi.h>
#include <ddraw.h>

#include "debug.h"

#define IStream int
#include <gdiplus.h>
using namespace Gdiplus;

#define TESTAREAWIDTH  800.0f
#define TESTAREAHEIGHT 800.0f

typedef void (*LPFNGDIPLUS)(WindowNotifyEnum);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by functest.rc
//
#define IDR_MENU1                       101
#define IDD_FUNCTEST                    102
#define IDC_COMBINATION                 1000
#define IDC_REGRESSION                  1001
#define IDC_RUN                         1002
#define IDC_PRIMITIVES                  1003
#define IDC_OUTPUTS                     1004
#define IDC_SETTINGS                    1005
#define IDC_PAGEPAUSE                   1008
#define IDC_PAGEDELAY                   1009
#define IDC_DELAY                       1010
#define IDC_ERASEBKGD                   1011
#define IDC_APPENDTEST                  1012
#define IDC_DRIVERHACKS                 1013
#define IDC_CLOSE                       1014
#define IDC_NUMPATHS                    1015
#define IDM_ALL                         40000
#define IDM_POLYGONS                    40001
#define IDM_PATHS                       40002
#define IDM_REGIONS                     40003
#define IDM_GRADIENTS                   40004
#define IDM_BITMAPS                     40005
#define IDM_IMAGING                     40006
#define IDM_PRIMITIVES                  40007
#define IDM_MIXED                       40008
#define IDM_TEXT                        40009
#define IDM_CONTAINERS                  40010
#define IDM_CONTAINERCLIP               40011
#define IDM_HATCH                       40012
#define IDM_DASHES                      40013
#define IDM_SOURCECOPY                  40014
#define IDM_COMPOUNDLINES               40015
#define IDM_PRINTING                    40016
#define IDM_BACKPRINTING                40017
#define IDM_INSETLINES                  40018
#define IDM_HWND                        40100
#define IDM_DIB                         40101
#define IDM_PRINTER                     40102
#define IDM_D3D                         40103
#define IDM_DIB_FILE                    40104
#define IDM_1BPP                        40200
#define IDM_2BPP                        40201
#define IDM_4BPP                        40202
#define IDM_8BPP                        40203
#define IDM_16BPP                       40204
#define IDM_24BPP                       40205
#define IDM_32BPP                       40206
#define IDM_TEST1                       40300
#define IDM_TEST10                      40301
#define IDM_TEST100                     40302
#define IDM_TEST1000                    40303
#define IDM_TESTREGRESS                 40304
#define IDM_HALFTONE                    40305
#define IDM_ANTIALIAS                   40306
#define IDM_TESTHDC                     40307
#define IDM_NEWPRINT                    40308
#define IDM_CACHEBACK                   40309
#define IDM_HIGHCOMPOSITINGQUALITY      40310
#define IDM_QUIT                        40500
#define IDM_ROT0                        40600
#define IDM_ROT10                       40601
#define IDM_ROT30                       40602
#define IDM_ROT45                       40603
#define IDM_ROT60                       40604
#define IDM_ROT90                       40605
#define IDM_RUN                         41000
#define IDM_COMBINATION                 41001
#define IDM_REGRESSION                  41002
#define IDM_SAMPLES                     65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         41003
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\driverhack\main.cpp ===
/******************************Module*Header*******************************\
* Module Name: Main.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  28-Apr-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <commctrl.h>
#include "CFuncTest.h"
#include "resource.h"

CFuncTest g_FuncTest;                                   // FuncTest (handles test runs)
HBRUSH g_hbrBackground=NULL;                            // Main window background color
HWND g_hWndMain=NULL;                                   // Main window
int g_nResult=0;                                        // Result of test run
int gnPaths = 2;

// Include all the outputs (classes derived from COutput)
#include "CHWND.h"
#include "CHDC.h"
#include "CPrinter.h"

// Include all the primitives (classes derived from CPrimitive)
#include "CPaths.h"
#include "CBanding.h"
#include "CExtra.h"

// Create global objects for each individual output
//   First constructor param is the regression flag
//   If true, the test will take part of the regression suite
CHWND g_HWND(true);
CHDC g_HDC(true);
CPrinter g_Printer(false);


LPFNGDIPLUS glpfnDisplayPaletteWindowNotify;

// Create global objects for each individual setting
//   First constructor param is the regression flag
//   If true, the test will take part of the regression suite

LRESULT CALLBACK WndProc(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam)
// Main window proc
{
    switch (Msg)
    {
        case WM_COMMAND:                // Process menu buttons
            switch(LOWORD(wParam))
            {
                case IDM_RUN:
                    g_FuncTest.Run();
                    break;
                case IDM_SAMPLES:
                    g_FuncTest.RunSamples();
                    break;
                case IDM_QUIT:
                    exit(0);
                    break;
            }
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;
    }

    return DefWindowProcA(hWnd,Msg,wParam,lParam);
}

void WindowUninit()
// Uninitializes window
{
    if (g_hbrBackground!=NULL)      // Destroy background brush
    {
        DeleteObject((HGDIOBJ)g_hbrBackground);
        g_hbrBackground=NULL;
    }
    if (g_hWndMain!=NULL)           // Destroy main window
    {
        DestroyWindow(g_hWndMain);
        g_hWndMain=NULL;
    }
}

BOOL WindowInit()
// Creates window and starts up app
{
    WNDCLASSA wc;
	HINSTANCE hInst=GetModuleHandleA(NULL);

    // Create white background brush
    g_hbrBackground=CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc      = WndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInst;
    wc.hIcon            = LoadIconA(NULL,MAKEINTRESOURCEA(32512));// IDI_APPLICATION);
    wc.hCursor          = LoadCursorA(NULL, IDC_ARROW);
    wc.hbrBackground    = g_hbrBackground;
    wc.lpszMenuName     = MAKEINTRESOURCEA(IDR_MENU1);
    wc.lpszClassName    = "DriverHack";
    if (!RegisterClassA(&wc))
		return false;

    g_hWndMain=CreateWindowExA(
		0,
        "DriverHack",
        "GDI+ Functionality Test",
        WS_OVERLAPPED|WS_CAPTION|WS_BORDER|WS_THICKFRAME|WS_MAXIMIZEBOX|
        WS_MINIMIZEBOX|WS_CLIPCHILDREN|WS_VISIBLE|WS_MAXIMIZE|WS_SYSMENU,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        hInst,
        NULL
    );
	HRESULT h=GetLastError();

    if (g_hWndMain==NULL)
        return false;

    ShowWindow(g_hWndMain,SW_SHOW);
    UpdateWindow(g_hWndMain);

    return true;
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 - Created  - KentD
*  04-28-00 - Modified - Jeff Vezina (t-jfvez)
*
\***************************************************************************/
__cdecl main(int argc,PCHAR argv[])
{
    MSG     msg;
    HMODULE hmodGdiPlus;

    CoInitialize(NULL);

    if (!WindowInit())
        return 0;
    if (!g_FuncTest.Init(g_hWndMain))
        return 0;

    hmodGdiPlus = LoadLibrary(TEXT("gdiplus.dll"));
    if(hmodGdiPlus) {
        glpfnDisplayPaletteWindowNotify = (LPFNGDIPLUS)
                 GetProcAddress(hmodGdiPlus, 
                                TEXT("GdipDisplayPaletteWindowNotify"));
    }
    if((glpfnDisplayPaletteWindowNotify == NULL) || (hmodGdiPlus == NULL)) {
        MessageBox(NULL,
                   "Unable to load gdiplus.dll",
                   "CfuncTest",
                   MB_OK);
        return FALSE;
    }
    
    // Init all primitives, graphics types, and graphics settings
    g_HWND.Init();
    g_HDC.Init();
    g_Printer.Init();

    // Put initializations into cextra.cpp, so that individual
    // developers can implement their own file for private usage.
    ExtraInitializations();

    while (GetMessageA(&msg,NULL,0,0)) {
        TranslateMessage(&msg);
        DispatchMessageA(&msg);
    }

    WindowUninit();

    FreeLibrary(hmodGdiPlus);

    CoUninitialize();

    return g_nResult;
}

#define UNICODE
#define _UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\emfdcode\cmndlg.c ===
/***********************************************************************

  MODULE     : CMNDLG.C

  FUNCTIONS  :

  COMMENTS   :

************************************************************************/

#include "windows.h"
#include "mfdcod32.h"

/**************************************************************************

  Function:  InitializeStruct(WORD, LPSTR)

   Purpose:  To initialize a structure for the current common dialog.
         This routine is called just before the common dialogs
         API is called.

   Returns:  void

   Comments:

   History:  Date      Author      Reason
         --------  ---------   -----------------------------------

          10/01/91  gregk       Created
          11/25/91  denniscr    mod for purposes of this app
          7/9/93    denniscr    modified for win32 and emf

**************************************************************************/

void InitializeStruct(wCommDlgType, lpStruct, lpszFilter)
WORD wCommDlgType;
LPSTR lpStruct;
LPSTR lpszFilter;
{
   LPFOCHUNK           lpFOChunk;
   LPFSCHUNK           lpFSChunk;

   switch (wCommDlgType)
   {
     case FILEOPENDLG:

       lpFOChunk = (LPFOCHUNK)lpStruct;

       *(lpFOChunk->szFile)            = 0;
       *(lpFOChunk->szFileTitle)       = 0;
       lpFOChunk->of.lStructSize       = OPENFILENAME_SIZE_VERSION_400;
       lpFOChunk->of.hwndOwner         = (HWND)hWndMain;
       lpFOChunk->of.hInstance         = (HANDLE)NULL;
       lpFOChunk->of.lpstrFilter       = gszFilter;
       lpFOChunk->of.lpstrCustomFilter = (LPSTR)NULL;
       lpFOChunk->of.nMaxCustFilter    = 0L;
       lpFOChunk->of.nFilterIndex      = 1L;
       lpFOChunk->of.lpstrFile         = lpFOChunk->szFile;
       lpFOChunk->of.nMaxFile          = (DWORD)sizeof(lpFOChunk->szFile);
       lpFOChunk->of.lpstrFileTitle    = lpFOChunk->szFileTitle;
       lpFOChunk->of.nMaxFileTitle     = 256;
       lpFOChunk->of.lpstrInitialDir     = (LPSTR)NULL;
       lpFOChunk->of.lpstrTitle        = (LPSTR)NULL;
       lpFOChunk->of.Flags             = OFN_HIDEREADONLY |
                                         OFN_PATHMUSTEXIST |
                                         OFN_FILEMUSTEXIST;
       lpFOChunk->of.nFileOffset       = 0;
       lpFOChunk->of.nFileExtension    = 0;
       lpFOChunk->of.lpstrDefExt       = (LPSTR)NULL;
       lpFOChunk->of.lCustData         = 0L;
       lpFOChunk->of.lpfnHook          = (LPOFNHOOKPROC)NULL;
       lpFOChunk->of.lpTemplateName    = (LPSTR)NULL;

       break;

     case FILESAVEDLG:

       lpFSChunk = (LPFSCHUNK)lpStruct;

       *(lpFSChunk->szFile)            = 0;
       *(lpFSChunk->szFileTitle)       = 0;
       lpFSChunk->of.lStructSize       = 0x4C; //OPENFILENAME_SIZE_VERSION_400
       lpFSChunk->of.hwndOwner         = (HWND)hWndMain;
       lpFSChunk->of.hInstance         = (HANDLE)NULL;
       lpFSChunk->of.lpstrFilter       = lpszFilter;
       lpFSChunk->of.lpstrCustomFilter = (LPSTR)NULL;
       lpFSChunk->of.nMaxCustFilter    = 0L;
       lpFSChunk->of.nFilterIndex      = 1L;
       lpFSChunk->of.lpstrFile         = lpFSChunk->szFile;
       lpFSChunk->of.nMaxFile          = (DWORD)sizeof(lpFSChunk->szFile);
       lpFSChunk->of.lpstrFileTitle  = lpFSChunk->szFileTitle;
       lpFSChunk->of.nMaxFileTitle     = 256;
       lpFSChunk->of.lpstrInitialDir     = (LPSTR)NULL;
       lpFSChunk->of.lpstrTitle        = (LPSTR)NULL;
       lpFSChunk->of.Flags             = OFN_HIDEREADONLY |
                                         OFN_OVERWRITEPROMPT;
       lpFSChunk->of.nFileOffset       = 0;
       lpFSChunk->of.nFileExtension    = 0;
       lpFSChunk->of.lpstrDefExt       = (LPSTR)"EMF";
       lpFSChunk->of.lCustData         = 0L;
       lpFSChunk->of.lpfnHook          = (LPOFNHOOKPROC)NULL;
       lpFSChunk->of.lpTemplateName    = (LPSTR)NULL;

       break;

     default:

       break;

   }

   return;
}

/***********************************************************************

  FUNCTION   : SplitPath

  PARAMETERS : LPSTR lpszFileName
           LPSTR lpszDrive
           LPSTR lpszDir
           LPSTR lpszFname
           LPSTR lpszExt

  PURPOSE    : split the fully qualified path into its components

  CALLS      : WINDOWS
         none

               APP
         none

  MESSAGES   : none

  RETURNS    : void

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

************************************************************************/

void SplitPath( lpszFileName, lpszDrive, lpszDir, lpszFname, lpszExt)
LPSTR lpszFileName;
LPSTR lpszDrive;
LPSTR lpszDir;
LPSTR lpszFname;
LPSTR lpszExt;
{
  char  szPath[MAXFILTERLEN];
  LPSTR lpszPath;
  LPSTR lpszTemp;
  int   nFileNameLen = nExtOffset - (nFileOffset + 1);
  int   i;

  /* init ptrs */
  lpszPath = szPath;
  lpszTemp = lpszFileName;

  /* pick off the path */
  for (i = 0; i < nFileOffset; i++, lpszTemp++, lpszPath++)
    *lpszPath = *lpszTemp;
  *lpszPath = '\0';

  lpszPath = szPath;

  /* pick off the drive designator */
  for (i = 0; i < 2; i++, lpszPath++, lpszDrive++)
    *lpszDrive = *lpszPath;
  *lpszDrive = '\0';

  /* pick off the directory */
  while (*lpszPath != '\0')
    *lpszDir++ = *lpszPath++;
  *lpszDir = '\0';

  /* reset temp ptr */
  lpszTemp = lpszFileName;

  /* index to filename */
  lpszTemp += nFileOffset;

  /* pick off the filename */
  for (i = 0; i < nFileNameLen; i++, lpszTemp++, lpszFname++)
    *lpszFname = *lpszTemp;
  *lpszFname = '\0';

  /* reset temp ptr */
  lpszTemp = lpszFileName;

  /* index to file extension */
  lpszTemp += nExtOffset;

  /* pick off the ext */
  while (*lpszTemp != '\0')
    *lpszExt++ = *lpszTemp++;
  *lpszExt = '\0';

}

/***********************************************************************

  FUNCTION   : OpenFileDialog

  PARAMETERS : LPSTR lpszOpenName

  PURPOSE    : init the OPENFILE structure and call the file open
           common dialog

  CALLS      : WINDOWS
         GlobalAlloc
         GlobalLock
         GlobalFree
         wsprintf
         GetOpenFileName

               APP
         InitializeStruct

  MESSAGES   : none

  RETURNS    : int (see returns for GetOpenFileName)

  COMMENTS   :

  HISTORY    : 11/25/91 - created - drc

************************************************************************/

int OpenFileDialog(lpszOpenName)
LPSTR lpszOpenName;

{
   int       nRet;
   HANDLE    hChunk;
   LPFOCHUNK lpFOChunk;

   hChunk = GlobalAlloc(GMEM_FIXED, sizeof(FOCHUNK));

   if (hChunk)  {
      lpFOChunk = (LPFOCHUNK)GlobalLock(hChunk);
      if (!lpFOChunk)  {
     GlobalFree(hChunk);
     lpFOChunk=NULL;
     return(0);
      }
   }
   else {
      lpFOChunk=NULL;
      return(0);
   }


   InitializeStruct(FILEOPENDLG, (LPSTR)lpFOChunk, NULL);

   nRet = GetOpenFileName( &(lpFOChunk->of) );

   if (nRet)  {
      wsprintf(lpszOpenName, (LPSTR)"%s", lpFOChunk->of.lpstrFile);
      nExtOffset =  lpFOChunk->of.nFileExtension;
      nFileOffset = lpFOChunk->of.nFileOffset;
   }

   GlobalUnlock(hChunk);
   GlobalFree(hChunk);

   return(nRet);

}

/***********************************************************************

  FUNCTION   : SaveFileDialog

  PARAMETERS : LPSTR lpszOpenName

  PURPOSE    : init the OPENFILE structure and call the file open
           common dialog

  CALLS      : WINDOWS
         GlobalAlloc
         GlobalLock
         GlobalFree
         wsprintf
         GetOpenFileName

               APP
         InitializeStruct

  MESSAGES   : none

  RETURNS    : int (see returns for GetSaveFileName)

  COMMENTS   : this could easily be merged with OpenFileDialog.  This
           would decrease the redundancy but this is more illustrative.

  HISTORY    : 11/25/91 - created - drc

************************************************************************/

int SaveFileDialog(lpszSaveName, lpszFilter)
LPSTR lpszSaveName;
LPSTR lpszFilter;

{
   int       nRet;
   HANDLE    hChunk;
   LPFOCHUNK lpFOChunk;

   hChunk = GlobalAlloc(GMEM_FIXED, sizeof(FOCHUNK));

   if (hChunk)  {
      lpFOChunk = (LPFOCHUNK)GlobalLock(hChunk);
      if (!lpFOChunk)  {
     GlobalFree(hChunk);
     lpFOChunk=NULL;
     return(0);
      }
   }
   else {
      lpFOChunk=NULL;
      return(0);
   }


   InitializeStruct(FILESAVEDLG, (LPSTR)lpFOChunk, lpszFilter);

   nRet = GetSaveFileName( &(lpFOChunk->of) );

   if (nRet)
      wsprintf(lpszSaveName, (LPSTR)"%s", lpFOChunk->of.lpstrFile);

   GlobalUnlock(hChunk);
   GlobalFree(hChunk);

   return(nRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\emfdcode\debug.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*   Debugging routines
*
* Revision History:
*
*   09/07/1999 agodfrey
*       Created it.
*
\**************************************************************************/
#include "global.h"

// Optional callback function for reporting a debug event.

enum GpAltDebugEventLevel
{
    GpAltDebugFatal,
    GpAltDebugWarning
};

#define GpAltDebugEventFunction 0
//DEBUGEVENTFUNCTION GpAltDebugEventFunction = NULL;

#if DBG

// GpDebugLevel is used to control the amount/severity of debugging messages
// that are actually output.

int GpDebugLevel = DBG_TERSE;

/**************************************************************************\
*
* Function Description:
*
*   Removes the path portion of a pathname
*
* Arguments:
*
*   [IN] str - pathname to strip
*
* Return Value:
*
*   A pointer to the filename portion of the pathname
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

const char*
StripDirPrefix(
    const char* str
    )

{
    const char* p;

    p = strrchr(str, '\\');
    return p ? p+1 : str;
}

const int maxInputStringSize = 1024;

/**************************************************************************\
*
* Function Description:
*
*   Outputs to the debugger
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   Zero. This is to conform to NTDLL's definition of DbgPrint.
*
* Notes:
*
*   There will be no output if a debugger is not connected.
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

ULONG _cdecl
DbgPrint(
    char* format,
    ...
    )

{
    va_list arglist;
    va_start(arglist, format);
    
    char buf[maxInputStringSize];
    
    _vsnprintf(buf, maxInputStringSize, format, arglist);
    buf[maxInputStringSize-1]=0;
        
    OutputDebugStringA(buf);
    
    va_end(arglist);
    return 0;
}

// If we can't allocate memory for the debug string, we'll use this buffer
// in desperation. It's not thread-safe. I *did* say 'desperation'.

static char desperationBuffer[maxInputStringSize];

/**************************************************************************\
*
* Function Description:
*
*   Creates a new string, and sprintf's to it.
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   The probably-newly-allocated string result.
*
* Notes:
*
*   This function is not intended for general use. It guards against memory
*   failure by using a global buffer. So, while the caller is responsible
*   for freeing the memory, the caller must also check for that buffer.
*   i.e. we only want DbgEmitMessage to call this.
*
*   It's also only mostly thread-safe, because if we run out of memory,
*   we'll use that global buffer in a non-protected way.
*
*   This is the only solution I could find so that I could move most of the
*   implementation details out of the header file. The root cause is that
*   macros don't handle multiple arguments natively, so we have to pass
*   the printf arguments as a single macro argument (in parentheses).
*   Which means, the function that consumes those arguments can have no
*   other arguments.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it. Finally, I've found a way to get debug implementation
*       details out of the headers.
*
\**************************************************************************/

char * _cdecl
GpParseDebugString(
    char* format,
    ...
    )
{
    va_list arglist;
    va_start(arglist, format);
    
    // Don't use GpMalloc here so that we can use ASSERT and WARNING in 
    // our memory allocation routines.

    char *newBuf = static_cast<char *>(LocalAlloc(LMEM_FIXED, maxInputStringSize));
    if (!newBuf)
    {
        newBuf = desperationBuffer;
    }
    
    _vsnprintf(newBuf, maxInputStringSize, format, arglist);
    
    // Nuke the last byte, because MSDN isn't clear on what _vsnprintf does
    // in that case.
    
    newBuf[maxInputStringSize-1]=0;
        
    va_end(arglist);
    return newBuf;
}

/**************************************************************************\
*
* Function Description:
*
*   Processes a debug event. Frees the message string.
*
* Arguments:
*
* level   - The debug level of the event 
* file    - Should be __FILE__
* line    - Should be __LINE__
* message - The debug message.
*
* Notes:
*
*   You don't want to call this directly. That would be error-prone. 
*   Use ASSERT, WARNING, etc.
*
*   In Office, it will raise an 'assert' dialog if necessary.
*
*   Depending on the debug level, an identifying prefix will be output.
*
*   If the debug level is DBG_RIP, will suspend execution (e.g. by
*   hitting a breakpoint.)
*
* Note on Office interop:
*
*   Under Office, we'll pass WARNINGs and ASSERTs to a reporting function
*   they provide. Their function will breakpoint on ASSERTs.
*   Lesser events will just be sent to the debugger.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it.
*
\**************************************************************************/

void _cdecl 
GpLogDebugEvent(
    int level, 
    char *file, 
    unsigned int line,
    char *message
    )
{
    // We may want to add things to the passed-in message. So we need
    // a temporary buffer
    
    const int maxOutputStringSize = maxInputStringSize + 100;
    char tempBuffer[maxOutputStringSize+1];
    
    // MSDN's _vsnprintf doc isn't clear on this, so just in case:
    tempBuffer[maxOutputStringSize] = 0;
    int altDebugLevel = -1;
    
    char *prefix = "";
    
    if (GpDebugLevel <= (level))
    {
        switch (level)
        {
        case DBG_WARNING:
            prefix = "WRN ";
            if (GpAltDebugEventFunction)
            {
                altDebugLevel = GpAltDebugWarning;
            }    
            break;
            
        case DBG_RIP:
            prefix = "RIP ";
            if (GpAltDebugEventFunction)
            {
                altDebugLevel = GpAltDebugFatal;
            }    
            break;
        }
        
        // The convention is that we append the trailing \n, not the caller.
        // Two reasons:
        // 1) Callers tend to forget it.
        // 2) More importantly, it encourages the caller to think of each
        //    call as a separate event. This is important in some cases - e.g.
        //    when Office produces a popup for each event.

        _snprintf(
            tempBuffer, 
            maxOutputStringSize, 
            "%s%s(%d): %s\n",
            prefix,
            StripDirPrefix(file),
            line,
            message
            );
        
        if (altDebugLevel >= 0)
        {
            //GpAltDebugEventFunction(altDebugLevel, tempBuffer);
        }
        else
        {
            OutputDebugStringA(tempBuffer);
        }
    }
    
    // Free the message buffer
    
    if (message != desperationBuffer)
    {
        LocalFree(message);
    }
    
    // Force a breakpoint, if it's warranted.
    
    if ((GpDebugLevel <= DBG_RIP) && (level == DBG_RIP) && (altDebugLevel < 0))
    {
        DebugBreak();
    }
}
    
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\emfdcode\mydata.hpp ===
#include "Gdiplus.h"

class MYPATTERNBRUSH
{
public:
    UINT            bitsOffset;
    BITMAPINFO *    bmi;

    MYPATTERNBRUSH()
    {
        bitsOffset = 0;
        bmi = NULL;
    }
    ~MYPATTERNBRUSH()
    {
        if (bmi != NULL)
            delete [] bmi;
    }
};

class MYOBJECTS
{
public:
    enum MYOBJECTTYPE
    {
        UnknownObjectType,
        PenObjectType,
        BrushObjectType,
    };
    MYOBJECTTYPE        type;
    UINT                color;
    int                 penWidth;
    int                 patIndex;
    MYPATTERNBRUSH *    brushPattern;

    MYOBJECTS()
    {
        type = UnknownObjectType;
        color = 0;
        penWidth = 1;
        patIndex = -1;
        brushPattern = NULL;
    }
    
    ~MYOBJECTS()
    {
        if (brushPattern != NULL)
            delete brushPattern;
    }
};

class MYDATA
{
public:
    int                         recordNum;
    int                         numObjects;
    int                         containerId;
    HWND                        hwnd;
    Gdiplus::Graphics *         g;
    Gdiplus::Metafile *         metafile;
    SIZEL                       windowExtent;
    SIZEL                       viewportExtent;
    UINT                        mapMode;
    POINTL                      viewportOrg;
    POINTL                      windowOrg;
    float                       dx;
    float                       dy;
    float                       scaleX;
    float                       scaleY;
    MYOBJECTS *                 pObjects;
    MYPATTERNBRUSH *            curBrushPattern;
    int                         curPatIndex;
    int                         curBrush;
    int                         curPen;
    int                         curPenWidth;
    Gdiplus::FillMode           fillMode;
    Gdiplus::PointF             curPos;
    DWORD                       arcDirection;
    Gdiplus::GraphicsPath *     path;
    BOOL                        pathOpen;
    float                       miterLimit;
    Gdiplus::Matrix             matrix;

    MYDATA(HWND inHwnd) 
    { 
        g = NULL;
        hwnd = inHwnd;
        recordNum = 0;
        numObjects = 0;
        containerId = 0;
        mapMode = MM_TEXT; 
        count = 0; 
        windowExtent.cx = 100; 
        windowExtent.cy = 100; 
        viewportExtent.cx = 100; 
        viewportExtent.cy = 100;
        viewportOrg.x = 0;
        viewportOrg.y = 0;
        windowOrg.x = 0;
        windowOrg.y = 0;
        dx = 0;
        dy = 0;
        scaleX = 1;
        scaleY = 1;
        pObjects = NULL;
        curBrushPattern = NULL;
        curPatIndex = -1;
        curBrush = 0;
        curPen = 0;
        curPenWidth = 1;
        fillMode = Gdiplus::FillModeAlternate;
        curPos.X = 0;
        curPos.Y = 0;
        arcDirection = AD_COUNTERCLOCKWISE;
        path = NULL;
        pathOpen = FALSE;
        miterLimit = 10;
    }
    ~MYDATA()
    {
        delete [] pObjects;
        delete path;
    }
    
    void PushId(int id)
    {
        if (count >= 10) count--;
        ids[count++] = id;
    }
    int PopId()
    {
        if (count <= 0) return 0;
        return ids[--count];
    }

protected:
    int ids[10];
    int count;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\emfdcode\mfdcod32.h ===
#include "resource.h"
#include "commdlg.h"

#define     GlobalSizePtr(lp)       \
                (GlobalUnlockPtr(lp), (BOOL)GlobalSize(GlobalPtrHandle(lp)))

#define  APPNAME     "Metafile Decoder"

#define  DESTDISPLAY     0
#define  DESTMETA        1
#define  DESTDIB         2
#define  DESTPRN         3

extern int      iDestDC;
//
//common dialog structures and constants
//
#define MAXFILTERLEN 256

typedef struct tagFOCHUNK  {
        OPENFILENAME of;
        char szFile[256];
        char szFileTitle[256];
} FOCHUNK;

typedef FOCHUNK FAR *LPFOCHUNK;
typedef FOCHUNK FAR *LPFSCHUNK;
typedef WORD (CALLBACK* FARHOOK)(HWND,UINT,WPARAM,LPARAM);
//
//structure of ptrs to global memory for emf header and
//description string
//
typedef struct tagEHNMETAMEMPTR  {
        LPENHMETAHEADER lpEMFHdr;
        LPTSTR          lpDescStr;
        LPPALETTEENTRY  lpPal;
        WORD            palNumEntries;
} EHNMETAMEMPTR, *PEHNMETAMEMPTR, *LPEHNMETAMEMPTR;
//
//clipboard data definitions
//
#define      CLP_ID         0xC350
#define      CLP_NT_ID      0xC351
#define      CLPBK_NT_ID    0xC352
#define      CLPMETANAMEMAX 79
//
//NT clipboard file header
//
typedef struct  {
   WORD        FileIdentifier;
   WORD        FormatCount;
} NTCLIPFILEHEADER;
//
// NT clipboard file format header
//
typedef struct  {
   DWORD FormatID;
   DWORD DataLen;
   DWORD DataOffset;
   WCHAR  Name[CLPMETANAMEMAX];
} NTCLIPFILEFORMAT, *LPNTCLIPFILEFORMAT;

//
//Win 3.1 clipboard file header
//
#pragma pack(1)
typedef struct {
        WORD FileIdentifier;
        WORD FormatCount;
} CLIPFILEHEADER;
//
//Win 3.1 clipboard format header
//
typedef struct {
        WORD  FormatID;
        DWORD DataLen;
        DWORD DataOffset;
        char  Name[CLPMETANAMEMAX];
} CLIPFILEFORMAT, FAR *LPCLIPFILEFORMAT;
//
//Win 3.1 metafilepict structure
//
typedef struct tagOLDMETAFILEPICT {
    short      mm;
    short      xExt;
    short      yExt;
    WORD       hMF;
} OLDMETAFILEPICT;

typedef OLDMETAFILEPICT FAR *LPOLDMETAFILEPICT;
//
//placeable metafile data definitions
//
typedef struct tagOLDRECT
{
    short   left;
    short   top;
    short   right;
    short   bottom;
} OLDRECT;
//
//placeable metafile header
//
typedef struct {
        DWORD   key;
        WORD    hmf;
        OLDRECT bbox;
        WORD    inch;
        DWORD   reserved;
        WORD    checksum;
}PLACEABLEWMFHEADER;
#pragma pack()

#define  PLACEABLEKEY    0x9AC6CDD7
//
//metafile function table lookup data definitions
//
#define  NUMENHMETARECORDS             255  // includes WFM, EMF, EMF+
typedef struct tagEMFMETARECORDS {
        char *szRecordName;
        DWORD iType;
} EMFMETARECORDS, *LPEMFMETARECORDS;

#define  NUMMETAFUNCTIONS 79                // WMF record types
/*
typedef struct tagMETAFUNCTIONS {
        char *szFuncName;
        WORD value;
} METAFUNCTIONS;
*/

typedef LPWORD  LPPARAMETERS;
typedef LPDWORD LPEMFPARAMETERS;
//
//global vars for main module
//
#ifdef MAIN

HANDLE hInst;
HANDLE CurrenthDlg;
HANDLE hSaveCursor;
HWND   hWndMain;
HWND   hWndList;

LPPARAMETERS lpMFParams;
LPEMFPARAMETERS lpEMFParams;
HANDLE hMem;
HANDLE hSelMem;
int FAR *lpSelMem;
EHNMETAMEMPTR EmfPtr;
//
//flags
//
BOOL bInPaint;
BOOL bPlayRec;
BOOL bPlayItAll;
BOOL bBadFile      = FALSE;
BOOL bValidFile    = FALSE;
BOOL bEnhMeta      = FALSE;
BOOL bMetaFileOpen = FALSE;
BOOL bMetaInRam    = FALSE;
BOOL bPlaceableMeta= FALSE;
BOOL bPlayList     = FALSE;
BOOL bPlaySelList  = TRUE;
BOOL bEnumRange;

int  iEnumAction;
int  iStartRange;
int  iEndRange;

DWORD iCount = 0;               //index into lpSelMem
DWORD iNumSel = 0;               //number of listbox selections

//
//common fo dialog vars
//
char gszSaveEMFFilter[MAXFILTERLEN]="Enhanced MetaFile(*.EMF)\0*.EMF\0\0";
char gszSaveWMFFilter[MAXFILTERLEN]="Windows MetaFile(*.WMF)\0*.WMF\0\0";
char gszFilter[MAXFILTERLEN]="All Supported File Types(*.EMF,*.WMF,*.CLP)\0*.EMF;*.WMF;*.CLP\0Enhanced MetaFiles(*.EMF)\0*.EMF\0Windows Metafiles(*.WMF)\0*.WMF\0Clipboard Pictures(*.CLP)\0*.CLP\0\0";
char gszBuffer[MAXFILTERLEN];
int  nFileOffset;
int  nExtOffset;
//
//file io related vars
//
char                  OpenName[144];
char                  SaveName[144];
char                  str[255];
OFSTRUCT              ofStruct;
DWORD                 iLBItemsInBuf;
char                  fnameext[20];
//
//metafile related vars
//
HANDLE                hMF;
HENHMETAFILE          hemf;
METAFILEPICT          MFP;
METARECORD            MetaRec;
METAHEADER            mfHeader;
PLACEABLEWMFHEADER    placeableWMFHeader;
ENHMETAHEADER         emfHeader;
ENHMETARECORD         emfMetaRec;
DWORD                 iRecNum = 0;
HANDLE                hMFP;
LPMETAFILEPICT        lpMFP = NULL;
LPOLDMETAFILEPICT     lpOldMFP = NULL;
HGLOBAL               hMFBits;
LPSTR                 lpMFBits = NULL;

//
//printer variables
//
HDC                   hPr;                 // handle for printer device context
POINT                 PhysPageSize;        // information about the page
BOOL                  bAbort;              // FALSE if user cancels printing
HWND                  hAbortDlgWnd;
FARPROC               lpAbortDlg;
FARPROC               lpAbortProc;

#endif /* if defined MAIN */
//
//externs
//
#ifndef MAIN

extern HANDLE         hInst;
extern HANDLE         CurrenthDlg;
extern HANDLE         hSaveCursor;
extern HWND           hWndMain;
extern HWND           hWndList;

extern LPPARAMETERS   lpMFParams;
extern LPEMFPARAMETERS lpEMFParams;
extern HANDLE         hMem;
extern HANDLE         hSelMem;
extern int FAR        *lpSelMem;
extern EHNMETAMEMPTR  EmfPtr;
//
//flags
//
extern BOOL           bInPaint;
extern BOOL           bPlayRec;
extern BOOL           bPlayItAll;
extern BOOL           bBadFile;
extern BOOL           bValidFile;
extern BOOL           bEnhMeta;
extern BOOL           bMetaFileOpen;
extern BOOL           bMetaInRam;
extern BOOL           bPlaceableMeta;
extern BOOL           bPlayList;
extern BOOL           bPlaySelList;
extern BOOL           bEnumRange;

extern int            iEnumAction;
extern int            iStartRange;
extern int            iEndRange;

extern DWORD          iCount;              //index into lpSelMem
extern DWORD          iNumSel;             //number of listbox selections
//
//common dialog vars
//
extern char gszSaveEMFFilter[MAXFILTERLEN];
extern char gszSaveWMFFilter[MAXFILTERLEN];
extern char gszFilter[MAXFILTERLEN];
extern char gszBuffer[MAXFILTERLEN];
extern int  nFileOffset;
extern int  nExtOffset;
//
//file io related vars
//
extern char           OpenName[144];
extern char           SaveName[144];
extern char           str[256];
extern OFSTRUCT       ofStruct;
extern DWORD          iLBItemsInBuf;
extern char           fnameext[20];
//
//metafile related vars
//
extern HANDLE         hMF;
extern HENHMETAFILE   hemf;
extern METAFILEPICT   MFP;
extern METARECORD     MetaRec;
extern METAHEADER     mfHeader;
extern PLACEABLEWMFHEADER  placeableWMFHeader;
extern ENHMETAHEADER  emfHeader;
extern ENHMETARECORD  emfMetaRec;
extern DWORD          iRecNum;
extern EMFMETARECORDS emfMetaRecords[];
// extern METAFUNCTIONS  MetaFunctions[];
extern HANDLE         hMFP;
extern LPMETAFILEPICT lpMFP;
extern LPOLDMETAFILEPICT lpOldMFP;
extern HGLOBAL        hMFBits;
extern LPSTR          lpMFBits;
//
//printer variables
//
extern HDC            hPr;                 // handle for printer device context
extern POINT          PhysPageSize;        // information about the page
extern BOOL           bAbort;              // FALSE if user cancels printing
extern HWND           hAbortDlgWnd;

#endif /* if !defined MAIN */
//
//function prototypes
//
//
//MFDCOD32.C

int     APIENTRY WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
BOOL    InitApplication(HANDLE);
BOOL    InitInstance(HANDLE, int);
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
HANDLE  FAR PASCAL OpenDlg(HWND, unsigned, WORD, LONG);
void    WaitCursor(BOOL);
//
//WMFMETA.C
//
int    CALLBACK EnhMetaFileEnumProc(HDC, LPHANDLETABLE, LPENHMETARECORD, int, LPARAM);
int    CALLBACK MetaEnumProc(HDC, LPHANDLETABLE, LPMETARECORD, int, LPARAM);
BOOL   LoadParameterLB(HWND, DWORD, int);
BOOL   PlayMetaFileToDest(HWND, int);
BOOL   RenderClipMeta(LPVOID, int, WORD);
BOOL   RenderPlaceableMeta(int);
void   SetPlaceableExts(HDC, PLACEABLEWMFHEADER, int);
void   SetNonPlaceableExts(HDC, int);
VOID   SetClipMetaExts(HDC, LPMETAFILEPICT, LPOLDMETAFILEPICT, int);
BOOL   ProcessFile(HWND, LPSTR);
BOOL   ProcessWMF(HWND hWnd, LPSTR lpFileName);
BOOL   ProcessCLP(HWND hWnd, LPSTR lpFileName);
BOOL   ProcessEMF(HWND hWnd, LPSTR lpFileName);
BOOL   GetEMFCoolStuff(void);
BOOL   GetEMFCoolStuff(void);
int    EnumMFIndirect(HDC hDC, LPHANDLETABLE lpHTable,
                      LPMETARECORD lpMFR,
                      LPENHMETARECORD lpEMFR,
                      int nObj, LPARAM lpData);
BOOL ConvertWMFtoEMF(HMETAFILE hmf, LPSTR lpszFileName);
BOOL ConvertEMFtoWMF(HDC hrefDC, HENHMETAFILE hEMF, LPSTR lpszFileName);
//
//DLGPROC.C
//
INT_PTR CALLBACK WMFRecDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK EnhMetaHeaderDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK HeaderDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK ClpHeaderDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK PlaceableHeaderDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK EnumRangeDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK ListDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK PlayFromListDlgProc(HWND, unsigned, WPARAM, LPARAM);
INT_PTR CALLBACK About(HWND, unsigned, WPARAM, LPARAM);
//
//WMFPRINT.C
//
BOOL    PrintWMF(BOOL);
HANDLE  GetPrinterDC(BOOL);
INT_PTR CALLBACK AbortDlg(HWND, unsigned, WPARAM, LPARAM);
BOOL    CALLBACK AbortProc(HDC, int);
//
//CMNDLG.C
//
void InitializeStruct(WORD, LPSTR, LPSTR);
int  OpenFileDialog(LPSTR);
int  SaveFileDialog(LPSTR, LPSTR);
void SplitPath( LPSTR, LPSTR, LPSTR, LPSTR, LPSTR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\emfdcode\global.h ===
/******************************Module*Header*******************************\
* Module Name: Global.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __GLOBAL_H
#define __GLOBAL_H

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <objbase.h>
#include <math.h>
#include <winspool.h>
#include <commdlg.h>
#include <wingdi.h>
#include <ddraw.h>

#include "debug.h"

#define IStream int
#include <gdiplus.h>
using namespace Gdiplus;

#define TESTAREAWIDTH  256.0f
#define TESTAREAHEIGHT 256.0f

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\emfdcode\dibstream.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   dibstream.hpp
*
* Abstract:
*
*   Wrap an IStream interface around DIB data.
*
* Revision History:
*
*   07/01/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _DIBSTREAM_HPP
#define _DIBSTREAM_HPP

// NOTE: This is not a thread-safe object.

class DibStream : public IStream
{
public:

    // Constructor

    DibStream(const BITMAPINFO* bmi, const BYTE* bits)
    {
        ComRefCount = 1;
        CurrentPos = 0;
        DibBits = bits;

        ZeroMemory(HeaderBuffer, sizeof(HeaderBuffer));

        // Figure out the size of header information

        HeaderSize = sizeof(BITMAPINFOHEADER);

        const BITMAPINFOHEADER* bmih = &bmi->bmiHeader;
        ULONG n = bmih->biClrUsed;

        if (n == 0)
        {
            switch (bmih->biBitCount)
            {
            case 1:
            case 4:
            case 8:
                n = 1 << bmih->biBitCount;
                break;

            case 16:
            case 32:
                if (bmih->biCompression == BI_BITFIELDS)
                    n = 3;
                break;
            }
        }

        HeaderSize += n * sizeof(RGBQUAD);

        memcpy(&HeaderBuffer[sizeof(BITMAPFILEHEADER)], bmi, HeaderSize);
        HeaderSize += sizeof(BITMAPFILEHEADER);

        // Figure out the size of bitmap data

        n = bmih->biSizeImage;

        if (n == 0 && bmih->biCompression == BI_RGB)
        {
            // Scanline is always DWORD-aligned

            n = ((bmih->biWidth * bmih->biBitCount) + 7) / 8;
            n = (n + 3) & ~3;

            n *= abs(bmih->biHeight);
        }

        TotalSize = HeaderSize + n;

        // Fix BMP file header information

        BITMAPFILEHEADER* fileHeader = (BITMAPFILEHEADER*) HeaderBuffer;
        
        fileHeader->bfType = 0x4D42;
        fileHeader->bfSize = TotalSize;
        fileHeader->bfOffBits = HeaderSize;
    }

    // Query interface

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv)
    {
        if (riid == IID_IUnknown)
            *ppv = static_cast<IUnknown*>(this);
        else if (riid == IID_IStream)
            *ppv = static_cast<IStream*>(this);
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }

        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    // Increment reference count

    STDMETHOD_(ULONG, AddRef)(VOID)
    {
        return InterlockedIncrement(&ComRefCount);
    }

    // Decrement reference count

    STDMETHOD_(ULONG, Release)(VOID)
    {
        ULONG count = InterlockedDecrement(&ComRefCount);

        if (count == 0)
            delete this;

        return count;
    }

    // Read data

    STDMETHOD(Read)(
        VOID* buf,
        ULONG cb,
        ULONG* cbRead
        )
    {
        ULONG n = TotalSize - CurrentPos;

        if (cb > n)
            cb = n;

        if (CurrentPos >= HeaderSize)
        {
            // Read bitmap data

            memcpy(buf, DibBits + (CurrentPos - HeaderSize), cb);
        }
        else
        {
            // Read header data

            n = HeaderSize - CurrentPos;

            if (cb <= n)
            {
                memcpy(buf, &HeaderBuffer[CurrentPos], cb);
            }
            else
            {
                memcpy(buf, &HeaderBuffer[CurrentPos], n);
                memcpy((BYTE*) buf + n, DibBits, cb - n);
            }
        }

        CurrentPos += cb;
        *cbRead = cb;

        return S_OK;
    }

    // Change read pointer

    STDMETHOD(Seek)(
        LARGE_INTEGER offset,
        DWORD origin,
        ULARGE_INTEGER* newPos
        )
    {
        LONGLONG pos;

        switch (origin)
        {
        case STREAM_SEEK_SET:

            pos = offset.QuadPart;
            break;

        case STREAM_SEEK_END:

            pos = TotalSize;
            break;

        case STREAM_SEEK_CUR:

            pos = (LONGLONG) CurrentPos + offset.QuadPart;
            break;

        default:

            pos = -1;
            break;
        }

        if (pos < 0 || pos > TotalSize)
            return E_INVALIDARG;

        CurrentPos = (ULONG) pos;

        if (newPos)
            newPos->QuadPart = pos;

        return S_OK;
    }

    // Get information

    STDMETHOD(Stat)(
        STATSTG* statstg,
        DWORD statFlag
        )
    {
        ZeroMemory(statstg, sizeof(STATSTG));

        statstg->type = STGTY_STREAM;
        statstg->cbSize.QuadPart = TotalSize;
        statstg->grfMode = STGM_READ;

        return S_OK;
    }

    STDMETHOD(Write)(
        const VOID* buf,
        ULONG cb,
        ULONG* cbWritten
        )
    {
        return STG_E_ACCESSDENIED;
    }

    STDMETHOD(CopyTo)(
        IStream* stream,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER* cbRead,
        ULARGE_INTEGER* cbWritten
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(SetSize)(
        ULARGE_INTEGER newSize
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(Commit)(
        DWORD commitFlags
        )
    {
        return S_OK;
    }

    STDMETHOD(Revert)()
    {
        return E_NOTIMPL;
    }

    STDMETHOD(LockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(UnlockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(Clone)(
        IStream** stream
        )
    {
        return E_NOTIMPL;
    }

private:

    LONG ComRefCount;
    ULONG HeaderSize;
    ULONG TotalSize;
    ULONG CurrentPos;
    const BYTE* DibBits;

    // Large enough buffer for storing bitmap file header information

    BYTE HeaderBuffer[sizeof(BITMAPFILEHEADER) +
                      sizeof(BITMAPINFOHEADER) +
                      sizeof(RGBQUAD) * 256];
};

#endif // !_DIBSTREAM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\emfdcode\mfdcod32.c ===
/***************************************************************************

    PROGRAM: mfdcod32

    PURPOSE: view and decode Windows Metafiles and Enhanced Metafiles.

    FUNCTIONS:

    WinMain() - calls initialization function, processes message loop
    InitApplication() - initializes window data and registers window
    InitInstance() - saves instance handle and creates main window
    MainWndProc() - processes messages
    WaitCursor() - loads hourglass cursor/restores original cursor

    HISTORY: 1/16/91 - wrote it - Dennis Crain
             5/20/93 - ported to win32 (NT) - Dennis Crain
             7/1/93  - added enhanced metafile functionality - denniscr

***************************************************************************/

#define MAIN

#include <windows.h>
#include <windowsx.h>
#include "mfdcod32.h"

int      iDestDC;

/**********************************************************************

  FUNCTION   : WinMain

  PARAMETERS : HANDLE
               HANDLE
               LPSTR
               int

  PURPOSE    : calls initialization function, processes message loop

  CALLS      : WINDOWS
                GetMessage
                TranslateMessage
                DispatchMessage

               APP
                InitApplication

  RETURNS    : int

  COMMENTS   : Windows recognizes this function by name as the initial entry
               point for the program.  This function calls the application
               initialization routine, if no other instance of the program is
               running, and always calls the instance initialization routine.
               It then executes a message retrieval and dispatch loop that is
               the top-level control structure for the remainder of execution.
               The loop is terminated when a WM_QUIT message is received, at
               which time this function exits the application instance by
               returning the value passed by PostQuitMessage().

               If this function must abort before entering the message loop,
               it returns the conventional value NULL.

  HISTORY    : 1/16/91 - created - denniscr

***********************************************************************/

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    MSG msg;

    if (!hPrevInstance)
    if (!InitApplication(hInstance))
        return (FALSE);
    //
    //Perform initializations that apply to a specific instance
    //
    if (!InitInstance(hInstance, nCmdShow))
    return (FALSE);
    //
    //Acquire and dispatch messages until a WM_QUIT message is received.
    //
    while (GetMessage(&msg, NULL, 0, 0))
    {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
    }
    return ((int) msg.wParam);

    UNREFERENCED_PARAMETER( lpCmdLine );
}

/**********************************************************************

  FUNCTION   : InitApplication

  PARAMETERS : HANDLE hInstance

  PURPOSE    : Initializes window data and registers window class

  CALLS      : WINDOWS
         RegisterClass

  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   : This function is called at initialization time only if no
           other instances of the application are running.  This function
           performs initialization tasks that can be done once for any
           number of running instances.

           In this case, we initialize a window class by filling out a
           data structure of type WNDCLASS and calling the Windows
           RegisterClass() function.  Since all instances of this
           application use the same window class, we only need to do this
           when the first instance is initialized.

  HISTORY    : 1/16/91 - created - modified from SDK sample app GENERIC

***********************************************************************/

BOOL InitApplication(hInstance)
HINSTANCE hInstance;                       // current instance
{
    WNDCLASS  wc;

    bInPaint = FALSE;
    //
    //Fill in window class structure with parameters that describe the
    //main window.
    //
    wc.style = 0;                         //Class style(s)
    wc.lpfnWndProc = (WNDPROC)MainWndProc;//Function to retrieve messages for
                                          //windows of this class
    wc.cbClsExtra = 0;                    //No per-class extra data
    wc.cbWndExtra = 0;                    //No per-window extra data
    wc.hInstance = hInstance;             //Application that owns the class
    wc.hIcon = LoadIcon(hInstance, "WMFICON");
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_BTNSHADOW + 1);
    wc.lpszMenuName =  "MetaMenu";        //Name of menu resource in .RC file
    wc.lpszClassName = "MetaWndClass";    //Name used in call to CreateWindow
    //
    //Register the window class and return success/failure code
    //
    return (RegisterClass(&wc));

}

/**********************************************************************

  FUNCTION   : InitInstance

  PARAMETERS : HANDLE  hInstance - Current instance identifier
           int     nCmdShow  - Param for first ShowWindow() call

  PURPOSE    : Saves instance handle and creates main window

  CALLS      : WINDOWS
         CreateWindow
         ShowWindow
         UpdateWindow

  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   : This function is called at initialization time for every
           instance of this application.  This function performs
           initialization tasks that cannot be shared by multiple
           instances.

           In this case, we save the instance handle in a static variable
           and create and display the main program window.

  HISTORY    :

***********************************************************************/

BOOL InitInstance(hInstance, nCmdShow)
HINSTANCE  hInstance;          // Current instance identifier.
int        nCmdShow;           // Param for first ShowWindow() call.
{
    HWND   hWnd;               // Main window handle.
    HDC    hDC ;               // Main DC handle

    // Save the instance handle in static variable, which will be used in
    // many subsequence calls from this application to Windows.

    hInst = hInstance;

    // Create a main window for this application instance.

    hWnd = CreateWindow(
    "MetaWndClass",                 // See RegisterClass() call.
    APPNAME,                        // Text for window title bar.
    WS_OVERLAPPEDWINDOW,            // Window style.
    CW_USEDEFAULT,                  // Default horizontal position.
    CW_USEDEFAULT,                  // Default vertical position.
    CW_USEDEFAULT,                  // Default width.
    CW_USEDEFAULT,                  // Default height.
    NULL,                           // Overlapped windows have no parent.
    NULL,                           // Use the window class menu.
    hInstance,                      // This instance owns this window.
    NULL                            // Pointer not needed.
    );
    //
    // If window could not be created, return "failure"
    //
    if (!hWnd)
    return (FALSE);

    hWndMain = hWnd;

    //
    // Make the window visible; update its client area; and return "success"
    //
    ShowWindow(hWnd, nCmdShow);  // Show the window
    UpdateWindow(hWnd);          // Sends WM_PAINT message
    return (TRUE);               // Returns the value from PostQuitMessage

}

BOOL bConvertToGdiPlus = FALSE;
BOOL bUseGdiPlusToPlay = FALSE;

/**********************************************************************

  FUNCTION   : MainWndProc

  PARAMETERS : HWND hWnd        -  window handle
           unsigned message -  type of message
           WORD wParam      -  additional information
           LONG lParam      -  additional information

  PURPOSE    : Processes messages

  CALLS      :

  MESSAGES   : WM_CREATE

           WM_COMMAND

         wParams
         - IDM_EXIT
         - IDM_ABOUT
         - IDM_OPEN
         - IDM_PRINT
         - IDM_PRINTDLG
         - IDM_LIST
         - IDM_CLEAR
         - IDM_ENUM
         - IDM_ENUMRANGE
         - IDM_ALLREC
         - IDM_DESTDISPLAY
         - IDM_DESTMETA
         - IDM_HEADER
         - IDM_CLIPHDR
         - IDM_PLACEABLEHDR

           WM_DESTROY

  RETURNS    : long

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

***********************************************************************/

LRESULT CALLBACK MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT        rect;
    INT_PTR     iFOpenRet;
    char        TempOpenName[128];
    INT_PTR     iDlgRet;
    BOOL        releaseDC = FALSE;

    switch (message)
    {
    case WM_CREATE:
        //
        // init the state of the menu items
        //
        CheckMenuItem(GetMenu(hWnd), IDM_DESTDISPLAY, MF_CHECKED);
        break;

    case WM_COMMAND:
        //
        // message: command from application menu
        //
        switch (LOWORD(wParam))
        {

        case IDM_EXIT: // file exit menu option

           PostQuitMessage(0);
           break;

        case IDM_ABOUT: // about box

           DialogBox(hInst,                      // current instance
                "AboutBox",                  // resource to use
                 hWnd,                       // parent handle
                 About);               // About() instance address
           break;

        case IDM_OPEN: // select a metafile to open

            // save the name of previously opened file
            if (lstrlen((LPSTR)OpenName) != 0)
            lstrcpy((LPSTR)TempOpenName, (LPSTR)OpenName);
            //
            // initialize file info flags
            //
            if (!bMetaFileOpen) {
              bBadFile = FALSE;
              bValidFile = FALSE;
            }
            //
            // clear the client area
            //
            GetClientRect(hWnd, (LPRECT)&rect);
            InvalidateRect(hWnd, (LPRECT)&rect, TRUE);
            //
            // call file open dlg
            //
            iFOpenRet = OpenFileDialog((LPSTR)OpenName);
            //
            // if a file was selected
            //
            if (iFOpenRet)
            {
              //
              // if file contains a valid metafile and it was rendered
              //
              if (!ProcessFile(hWnd, (LPSTR)OpenName))
              lstrcpy((LPSTR)OpenName, (LPSTR)TempOpenName);
            }
            else
              lstrcpy((LPSTR)OpenName, (LPSTR)TempOpenName);
            break;

        case IDM_SAVEAS:
            {
              int   iSaveRet;
              LPSTR   lpszFilter;
              //
              //get a name of a file to copy the metafile to
              //
              lpszFilter = (bEnhMeta) ? gszSaveWMFFilter : gszSaveEMFFilter;

              iSaveRet = SaveFileDialog((LPSTR)SaveName, lpszFilter);
              //
              //if the file selected is this metafile then warn user
              //
              if (!lstrcmp((LPSTR)OpenName, (LPSTR)SaveName))
                MessageBox(hWnd, (LPSTR)"Cannot overwrite the opened metafile!",
                           (LPSTR)"Copy Metafile", MB_OK | MB_ICONEXCLAMATION);

              else
              //
              //the user didn't hit the cancel button
              //
              if (iSaveRet)
              {
                HDC hrefDC;

                WaitCursor(TRUE);
                if (!bEnhMeta)
                  ConvertWMFtoEMF(hMF, (LPSTR)SaveName);
                else
                {
                  // Try to get a printer DC by default

                  //hrefDC = GetPrinterDC(FALSE);
                  hrefDC = NULL;
                  if (hrefDC == NULL)
                  {
                      releaseDC = TRUE;
                      hrefDC = GetDC(NULL);
                  }
                  ConvertEMFtoWMF(hrefDC, hemf, (LPSTR)SaveName);
                  if (releaseDC)
                  {
                      ReleaseDC(hWnd, hrefDC);
                  }
                  else
                  {
                      DeleteDC(hrefDC);
                  }
                }
              }
            }
            break;

        case IDM_PRINT: // play the metafile to a printer DC
            PrintWMF(FALSE);
            break;
        case IDM_PRINTDLG:
            PrintWMF(TRUE);
            break;

        case IDM_LIST: // list box containing all records of metafile

            WaitCursor(TRUE);
            DialogBox(hInst,             // current instance
                 "LISTRECS",                         // resource to use
                  hWnd,                      // parent handle
                  ListDlgProc);            // About() instance address
            WaitCursor(FALSE);
            break;

        case IDM_CLEAR: // clear the client area

            GetClientRect(hWnd, (LPRECT)&rect);
            InvalidateRect(hWnd, (LPRECT)&rect, TRUE);
            break;

        case IDM_ENUM: // play - step - all menu option

            // set flags appropriately before playing to destination
            bEnumRange = FALSE;
            bPlayItAll = FALSE;
            PlayMetaFileToDest(hWnd, iDestDC);
            break;

        case IDM_ENUMRANGE: // play - step - range menu option
            //
            // odd logic here...this just forces evaluation of the
            //   enumeration range in MetaEnumProc. We are not "playing
            //   it all"
            //
            bPlayItAll = TRUE;

            iDlgRet = DialogBox(hInst,"ENUMRANGE",hWnd,EnumRangeDlgProc);
            //
            // if cancel button not pressed, play to destination
            //
            if (iDlgRet != IDCANCEL)
              PlayMetaFileToDest(hWnd, iDestDC);
            break;


        case IDM_ALLREC: // play - all menu option
            //
            // set flag appropriately and play to destination
            //
            bEnumRange = FALSE;
            bPlayItAll = TRUE;
            bPlayRec = TRUE;
            PlayMetaFileToDest(hWnd, iDestDC);
            break;

        case IDM_DESTDISPLAY: // play - destination - display menu option

            CheckMenuItem(GetMenu(hWnd), IDM_DESTDISPLAY, MF_CHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTMETA, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTDIB, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTPRN, MF_UNCHECKED);

            //
            // set destination flag to display
            //
            iDestDC = DESTDISPLAY;
            break;

        case IDM_DESTMETA: // play - destination - metafile menu option

            CheckMenuItem(GetMenu(hWnd), IDM_DESTDISPLAY, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTMETA, MF_CHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTDIB, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTPRN, MF_UNCHECKED);

            // set destination flag to metafile
            iDestDC = DESTMETA;
            break;

        case IDM_DESTDIB:
            CheckMenuItem(GetMenu(hWnd), IDM_DESTDISPLAY, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTMETA, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTDIB, MF_CHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTPRN, MF_UNCHECKED);

            iDestDC = DESTDIB;
            break;

        case IDM_DESTPRN:
            CheckMenuItem(GetMenu(hWnd), IDM_DESTDISPLAY, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTMETA, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTDIB, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_DESTPRN, MF_CHECKED);

            iDestDC = DESTPRN;
            break;

        case IDM_ENHHEADER:
           if (bValidFile)
             DialogBox(hInst,"ENHMETAHEADER",hWnd,EnhMetaHeaderDlgProc);
           break;

        case IDM_HEADER: // display the common metafile header
           if (bValidFile)
             DialogBox(hInst,"HEADER",hWnd,HeaderDlgProc);
           break;

        case IDM_CLIPHDR: // display the metafilepict of a clipboard file
           if (bValidFile)
             DialogBox(hInst, "CLIPHDR", hWnd, ClpHeaderDlgProc);
           break;

        case IDM_PLACEABLEHDR: // display the placeable metafile header
           if (bValidFile)
             DialogBox(hInst,"PLACEABLEHDR",hWnd, PlaceableHeaderDlgProc);
           break;

        case IDM_GDIPLUS_CONVERT:
            //
            // clear the client area
            //
            GetClientRect(hWnd, (LPRECT)&rect);
            InvalidateRect(hWnd, (LPRECT)&rect, TRUE);

            if (!bConvertToGdiPlus)
            {
                bConvertToGdiPlus = TRUE;
                CheckMenuItem(GetMenu(hWnd), IDM_GDIPLUS_CONVERT, MF_CHECKED);
                goto NoGdipPlay;
            }
            else
            {
NoGdipConvert:
                bConvertToGdiPlus = FALSE;
                CheckMenuItem(GetMenu(hWnd), IDM_GDIPLUS_CONVERT, MF_UNCHECKED);
            }
            break;

        // use (or not) GDI+ to play the metafile
        case IDM_GDIPLUS_PLAY:
            //
            // clear the client area
            //
            GetClientRect(hWnd, (LPRECT)&rect);
            InvalidateRect(hWnd, (LPRECT)&rect, TRUE);

            if (!bUseGdiPlusToPlay)
            {
                bUseGdiPlusToPlay = TRUE;
                CheckMenuItem(GetMenu(hWnd), IDM_GDIPLUS_PLAY, MF_CHECKED);
                goto NoGdipConvert;
            }
            else
            {
NoGdipPlay:
                bUseGdiPlusToPlay = FALSE;
                CheckMenuItem(GetMenu(hWnd), IDM_GDIPLUS_PLAY, MF_UNCHECKED);
            }
            break;

        default:  // let Windows process it
            return (DefWindowProc(hWnd, message, wParam, lParam));
        }
        break;

    case WM_DESTROY: // message: window being destroyed
        //
        //if memory for metafile pict is around nuke it
        //
        if (lpMFP != NULL || lpOldMFP != NULL)
        {
          GlobalUnlock(hMFP);
          GlobalFree(hMFP);
        }
        //
        //if the memory for placeable and clipboard wmf bits is around
        //free it
        //
        if (lpMFBits != NULL)
          GlobalFreePtr(lpMFBits);
        //
        //if the memory for the emf header, desc string and palette
        //is still around then nuke it
        //
        if (EmfPtr.lpEMFHdr)
          GlobalFreePtr(EmfPtr.lpEMFHdr);
        if (EmfPtr.lpDescStr)
          GlobalFreePtr(EmfPtr.lpDescStr);
        if (EmfPtr.lpPal)
          GlobalFreePtr(EmfPtr.lpPal);

        PostQuitMessage(0);
        break;


    default:  // passes it on if unproccessed
        return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return ((LRESULT)0);
}

/**********************************************************************

  FUNCTION   : WaitCursor

  PARAMETERS : BOOL bWait - TRUE for the hour glass cursor
                FALSE to return to the previous cursor

  PURPOSE    : toggle the mouse cursor to the hourglass and back

  CALLS      : WINDOWS
         LoadCursor
         SetCursor

  MESSAGES   : none

  RETURNS    : void

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

***********************************************************************/

void WaitCursor(bWait)
BOOL bWait;
{
  HCURSOR hCursor;
  static HCURSOR hOldCursor;
  //
  // if hourglass cursor is to be used
  //
  if (bWait)
  {
    hCursor = LoadCursor(NULL, IDC_WAIT);
    hOldCursor = SetCursor(hCursor);
  }
  else
    SetCursor(hOldCursor);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\emfdcode\dlgproc.c ===
/***********************************************************************

  MODULE     : DLGPROC.C

  FUNCTIONS  : WMFRecDlgProc
               EnumRangeDlgProc
               PlayFromListDlgProc
               HeaderDlgProc
               PlaceableHeaderDlgProc
               ClpHeaderDlgProc
               ListDlgProc
               About

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

************************************************************************/

#include "windows.h"
#include "mfdcod32.h"

#define GDIP_WMF_RECORD_BASE            0x00010000
#define GDIP_WMF_RECORD_TO_EMFPLUS(n)   ((INT)((n) | GDIP_WMF_RECORD_BASE))

/***********************************************************************

  FUNCTION   : WMFRecDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    : dialog procedure to handle the user input from the
               dialog box that displays the contents of the metafile
               record.

  CALLS      : WINDOWS
                 lstrcpy
                 GlobalLock
                 GlobalUnlock
                 wsprintf
                 SendDlgItemMessage
                 EndDialog
               APP
                 WaitCursor

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc
               6/30/93 - modified to work with EMF under Win32 - denniscr

************************************************************************/

INT_PTR CALLBACK WMFRecDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
  int i;
  char szMetaFunction[50];
  HFONT hFont;
  static int iButton = IDB_HEX ;
  static RECT rcWnd = { 0, 0, 0, 0 };

  switch (message)
  {
  case WM_INITDIALOG:
      //
      //font for the parameters listbox
      //
      hFont = GetStockObject(ANSI_FIXED_FONT);

      if( rcWnd.bottom != rcWnd.top && rcWnd.right != rcWnd.left)
        SetWindowPos(hDlg, HWND_NOTOPMOST, rcWnd.left, rcWnd.top, rcWnd.right - rcWnd.left, rcWnd.bottom - rcWnd.top, 0 ) ;
      //
      //select that font into the parameter listbox
      //
      SendDlgItemMessage(hDlg, IDL_PARAMETERS, WM_SETFONT, (WPARAM) hFont, (LPARAM)FALSE);
      //
      //initialize the controls of the dialog box to reflect the
      //contents of the current metafile record
      //
      //but first, lookup the metafile function
      //
      if (bEnhMeta)
      {
        for (i = NUMMETAFUNCTIONS; i < NUMENHMETARECORDS; i++)
        {
          if (emfMetaRec.iType == emfMetaRecords[i].iType)
            break;
        }
        //
        //if not found then it is an unknown record
        //
        if (emfMetaRec.iType != emfMetaRecords[i].iType)
            lstrcpy((LPSTR)szMetaFunction, (LPSTR)"Unknown");
        else
            lstrcpy((LPSTR)szMetaFunction,(LPSTR)emfMetaRecords[i].szRecordName);
        //
        //init the size control
        //
        SetDlgItemInt(hDlg, IDE_RECSIZE, (UINT)emfMetaRec.nSize, FALSE);
        //
        //load the parameter listbox with the parameters displayed in hex bytes
        //
        LoadParameterLB(hDlg, (emfMetaRec.nSize - sizeof(emfMetaRec.nSize) -
                        sizeof(emfMetaRec.iType))/sizeof(DWORD), iButton);
      }
      else
      {
        for (i = 0; i < NUMMETAFUNCTIONS; i++)
        {
          if (GDIP_WMF_RECORD_TO_EMFPLUS(MetaRec.rdFunction) == (INT)emfMetaRecords[i].iType)
            break;
        }
        //
        //if not found then it is an unknown record
        //
        if (GDIP_WMF_RECORD_TO_EMFPLUS(MetaRec.rdFunction) != (INT)emfMetaRecords[i].iType)
            lstrcpy((LPSTR)szMetaFunction, (LPSTR)"Unknown");
        else
            lstrcpy((LPSTR)szMetaFunction,(LPSTR)emfMetaRecords[i].szRecordName);
        //
        //init the size control
        //
        SetDlgItemInt(hDlg, IDE_RECSIZE, (DWORD)MetaRec.rdSize, FALSE);
        //
        //load the parameter listbox with the parameters displayed in hex bytes
        //
        LoadParameterLB(hDlg, MetaRec.rdSize - 3, iButton);
      }

      //
      //init the record number
      ///
      SetDlgItemInt(hDlg, IDE_RECNUM, iRecNum, FALSE);
      //
      //init the function name control
      //
      SetDlgItemText(hDlg, IDE_FUNCTION, (LPSTR)szMetaFunction);
      //
      //check the Hex radio button
      //
      SendDlgItemMessage(hDlg, iButton, BM_SETCHECK, TRUE, 0L);
      //
      //load the parameter listbox with the parameters displayed in hex bytes
      //
      return(TRUE);
      break;

   case WM_COMMAND:
      switch(LOWORD(wParam))
        {

        /* this will handle the checking and  unchecking of the three buttons */
        case IDB_HEX:
        case IDB_DEC:
        case IDB_CHAR:
        case IDB_WORD:
            CheckRadioButton(hDlg, IDB_HEX,  IDB_CHAR, LOWORD(wParam));
            if (bEnhMeta)
              LoadParameterLB(hDlg, (emfMetaRec.nSize - sizeof(emfMetaRec.nSize) -
                              sizeof(emfMetaRec.iType))/sizeof(DWORD), LOWORD(wParam));
            else
              LoadParameterLB(hDlg, MetaRec.rdSize - 3,  LOWORD(wParam));
            iButton = LOWORD(wParam);
            break;

        case IDGO:
            /* display the hourglass cursor while metafile is playing */
            WaitCursor(TRUE);

            bPlayItAll = TRUE;
            bEnumRange = FALSE;
            /* fall through with appropriate flags set */

        case IDOK:
            GetWindowRect( hDlg, &rcWnd ) ;
            bPlayRec = TRUE;
            /* fall through with appropriate flags set */

        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            return(TRUE);
            break;

        case IDQUITENUM:
            /* quit the enumeration.  Setup Dialogbox to return
               FALSE as this return value is checked in a test
               to end the enumeration */
            EndDialog(hDlg, FALSE);
            return(TRUE);
            break;

        default:
           return (FALSE);
        }
     break;

  default:
     return(FALSE);
     break;
   }
return (TRUE);
}

/***********************************************************************

  FUNCTION   : EnumRangeDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    : This dialog box lets the user specify whether all records
               or a range are to be played.

  CALLS      : WINDOWS
                 SendDlgItemMessage
                 GetDlgItemInt
                 HIWORD
                 MessageBox
                 SetFocus
                 InvalidateClientRect
                 EndDialog

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 1/16/91 - created - Dennis Crain

************************************************************************/

INT_PTR CALLBACK EnumRangeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL lpTranslated;
    RECT rect;

    switch (message) {
        case WM_INITDIALOG:
            /* play all of the mf records is the default */
            SendDlgItemMessage(hDlg, IDCB_ALL, BM_SETCHECK, 1, 0L);
            return (TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case IDE_FROM:

                    /* if the user elects to play a range of record then
                       turn the play all check off */

            if (HIWORD(wParam) == EN_CHANGE)
                        SendDlgItemMessage(hDlg, IDCB_ALL, BM_SETCHECK, 0, 0L);
                    break;

                case IDE_TO:
            if (HIWORD(wParam) == EN_CHANGE)
                        SendDlgItemMessage(hDlg, IDCB_ALL, BM_SETCHECK, 0, 0L);
                    break;

                case IDOK:

                   /* if a range of records is to be played */

                   if ( !IsDlgButtonChecked(hDlg, IDCB_ALL) ) {

                     /* set the enumerate range flag */
                     bEnumRange = TRUE;

                     /* initialize the play record flag */
                     bPlayRec = FALSE;

                     /* get the range */
                     iStartRange = GetDlgItemInt(hDlg, IDE_FROM, (BOOL FAR *)&lpTranslated, FALSE);

                     /* trap the error where the start value has not been entered */
                     if (!iStartRange) {
                         MessageBox(hWndMain, "Invalid FROM value",
                                    NULL, MB_OK | MB_ICONEXCLAMATION);
                         SetFocus(GetDlgItem(hDlg, IDE_FROM));
                     break;

                     }

                     iEndRange = GetDlgItemInt(hDlg, IDE_TO, (BOOL FAR *)&lpTranslated, FALSE);
                     if (!iEndRange) {
                         MessageBox(hWndMain, "Invalid TO value",
                                    NULL, MB_OK | MB_ICONEXCLAMATION);
                         SetFocus(GetDlgItem(hDlg, IDE_TO));

                        break;
                     }

                   }
                   /* all records are to be played */
                   else {
                     /* set the enumerate range to false */
                     bEnumRange = FALSE;

                     /* initialize the play it all flag - yes this should
                        be false! */
                     bPlayItAll = FALSE;

                     /* init the play record flag */
                     bPlayRec = TRUE;
                   }
                   /* force paint of the client area */
                   GetClientRect(hWndMain, (LPRECT)&rect);
                   InvalidateRect(hWndMain, (LPRECT)&rect, TRUE);

                   EndDialog(hDlg, TRUE);
                   return (TRUE);
                   break;

                case IDCANCEL:
                   /* user didn't really want to play the metafile */
                   bEnumRange = FALSE;
                   bPlayItAll = TRUE;
                   bPlayRec   = FALSE;
                   EndDialog(hDlg, IDCANCEL);
                   return (TRUE);
                   break;

                default:
                   return (FALSE);
                }
        break;
    }
    return (FALSE);                           /* Didn't process a message    */
}

/***********************************************************************

  FUNCTION   : PlayFromListDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    : a means to indicate whether the selected or unselected
               records among the list of metafile records are to be
               played.

  CALLS      : WINDOWS
                 SendDlgItemMessage
                 IsDlgButtonChecked
                 HIWORD

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 1/16/91 - created - Dennis Crain

************************************************************************/

INT_PTR CALLBACK PlayFromListDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
        case WM_INITDIALOG:
            /* the default is to play the selected records */
            SendDlgItemMessage(hDlg, IDCB_SEL, BM_SETCHECK, 1, 0L);
            return (TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
              case IDOK:
                /* was the play selected or play unselected button checked? */
                if ( IsDlgButtonChecked(hDlg, IDCB_SEL) )
                    bPlaySelList = TRUE;
                else
                    bPlaySelList = FALSE;

                EndDialog(hDlg, TRUE);
                return (TRUE);

              case IDCB_SEL:
                /* show the button click */
        if (HIWORD(wParam) == BN_CLICKED)
                   SendDlgItemMessage(hDlg, IDCB_UNSEL, BM_SETCHECK, 0, 0L);
                break;

              case IDCB_UNSEL:
                /* show the button click */
        if (HIWORD(wParam) == BN_CLICKED)
                   SendDlgItemMessage(hDlg, IDCB_SEL, BM_SETCHECK, 0, 0L);
                break;

              default:
                return (FALSE);

            }
            break;
    }
    return (FALSE);
}

/***********************************************************************

  FUNCTION   : EnhMetaHeaderDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    : show the "standard" metafile header as described in the
               Windows SDK section 9.5.1 of the SDK Reference volume 2

  CALLS      : WINDOWS
                 wsprintf
                 SetDlgItemText
                 EndDialog

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   : Enhanced Metafile header format
    DWORD   iType;              // Record type EMR_HEADER
    DWORD   nSize;              // Record size in bytes.  This may be greater
                                // than the sizeof(ENHMETAHEADER).
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    RECTL   rclFrame;           // Inclusive-inclusive Picture Frame of metafile in .01 mm units
    DWORD   dSignature;         // Signature.  Must be ENHMETA_SIGNATURE.
    DWORD   nVersion;           // Version number
    DWORD   nBytes;             // Size of the metafile in bytes
    DWORD   nRecords;           // Number of records in the metafile
    WORD    nHandles;           // Number of handles in the handle table
                                // Handle index zero is reserved.
    WORD    sReserved;          // Reserved.  Must be zero.
    DWORD   nDescription;       // Number of chars in the unicode description string
                                // This is 0 if there is no description string
    DWORD   offDescription;     // Offset to the metafile description record.
                                // This is 0 if there is no description string
    DWORD   nPalEntries;        // Number of entries in the metafile palette.
    SIZEL   szlDevice;          // Size of the reference device in pels
    SIZEL   szlMillimeters;     // Size of the reference device in millimeters

  HISTORY    : 6/29/93 - created - Dennis Crain

************************************************************************/

INT_PTR CALLBACK EnhMetaHeaderDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    char szBuf[30];

    switch (message) {
        case WM_INITDIALOG:
            //
            //format the record type
            //
            wsprintf((LPSTR)szBuf, "%x", EmfPtr.lpEMFHdr->iType);
            SetDlgItemText(hDlg, IDC_ITYPE, (LPSTR)szBuf);
            //
            //format the size of the header
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->nSize);
            SetDlgItemText(hDlg, IDC_NSIZE, (LPSTR)szBuf);
            //
            //format the signature
            //
            wsprintf((LPSTR)szBuf, "%x", EmfPtr.lpEMFHdr->dSignature);
            SetDlgItemText(hDlg, IDC_DSIGNATURE, (LPSTR)szBuf);
            //
            //format the version
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->nVersion);
            SetDlgItemText(hDlg, IDC_NVERSION, (LPSTR)szBuf);
            //
            //format the size of metafile in bytes
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->nBytes);
            SetDlgItemText(hDlg, IDC_NBYTES, (LPSTR)szBuf);
            //
            //format the number of records
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->nRecords);
            SetDlgItemText(hDlg, IDC_NRECORDS, (LPSTR)szBuf);
            //
            //format the number of handles
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->nHandles);
            SetDlgItemText(hDlg, IDC_NHANDLES, (LPSTR)szBuf);
            //
            //format the number of chars in the description string
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->nDescription);
            SetDlgItemText(hDlg, IDC_NDESCRIPTION, (LPSTR)szBuf);
            //
            //format the offset to the description
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->offDescription);
            SetDlgItemText(hDlg, IDC_OFFDESCRIPTION, (LPSTR)szBuf);
            //
            //if a description string exists then write it to static control
            //
            if (EmfPtr.lpDescStr)
                SetDlgItemText(hDlg, IDC_DESCSTRING, EmfPtr.lpDescStr);
            //
            //format the number of palette entries
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->nPalEntries);
            SetDlgItemText(hDlg, IDC_NPALENTRIES, (LPSTR)szBuf);
            //
            //format szlDevice values
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->szlDevice.cx);
            SetDlgItemText(hDlg, IDC_DEVCX, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->szlDevice.cy);
            SetDlgItemText(hDlg, IDC_DEVCY, (LPSTR)szBuf);
            //
            //format szlMillimeters values
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->szlMillimeters.cx);
            SetDlgItemText(hDlg, IDC_MILLCX, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->szlMillimeters.cy);
            SetDlgItemText(hDlg, IDC_MILLCY, (LPSTR)szBuf);
            //
            //format rclBounds values
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclBounds.left);
            SetDlgItemText(hDlg, IDC_BOUNDSL, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclBounds.top);
            SetDlgItemText(hDlg, IDC_BOUNDST, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclBounds.right);
            SetDlgItemText(hDlg, IDC_BOUNDSR, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclBounds.bottom);
            SetDlgItemText(hDlg, IDC_BOUNDSB, (LPSTR)szBuf);
            //
            //format rclFrame values
            //
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclFrame.left);
            SetDlgItemText(hDlg, IDC_FRAMEL, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclFrame.top);
            SetDlgItemText(hDlg, IDC_FRAMET, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclFrame.right);
            SetDlgItemText(hDlg, IDC_FRAMER, (LPSTR)szBuf);
            wsprintf((LPSTR)szBuf, "%d", EmfPtr.lpEMFHdr->rclFrame.bottom);
            SetDlgItemText(hDlg, IDC_FRAMEB, (LPSTR)szBuf);

            return (TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK) {
                EndDialog(hDlg, TRUE);
                return (TRUE);
            }
            break;
    }
    return (FALSE);
}

/***********************************************************************

  FUNCTION   : HeaderDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    : show the "standard" metafile header as described in the
               Windows SDK section 9.5.1 of the SDK Reference volume 2

  CALLS      : WINDOWS
                 wsprintf
                 SetDlgItemText
                 EndDialog

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   : Metafile header format

               WORD    mtType;
               WORD    mtHeaderSize;
               WORD    mtVersion;
               DWORD   mtSize;
               WORD    mtNoObjects;
               DWORD   mtMaxRecord;

               These fields have the following  meanings:

               Field          Definition

               mtType         specifies whether the metafile is in
                              memory or recorded in a disk file.
                              1 == memory 2 == disk

               mtHeaderSize   Specifies the size in words of the metafile
                              header

               mtVersion      Specifies the Windows version number.

               mtSize         Specifies the size in words of the file

               mtNoObjects    Specifies the maximum number of objects that
                              exist in the metafile at the same time

               mtMaxRecord    Specifies the size in words of the largest
                              record in the metafile.

               mtNoParameters Is not used

  HISTORY    : 1/16/91 - created - Dennis Crain

************************************************************************/

INT_PTR CALLBACK HeaderDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    char szBuf[30];

    switch (message) {
        case WM_INITDIALOG:
            /* format the Windows version number */
            wsprintf((LPSTR)szBuf, "%x", mfHeader.mtVersion);
            SetDlgItemText(hDlg, IDS_VER, (LPSTR)szBuf);

            /* format the size of the metafile */
            wsprintf((LPSTR)szBuf, "%lu", mfHeader.mtSize * 2L);
            SetDlgItemText(hDlg, IDS_SIZE, (LPSTR)szBuf);

            /* format the maximum numbers of objects that exist
               in the metafile at the same time */
            wsprintf((LPSTR)szBuf, "%d", mfHeader.mtNoObjects);
            SetDlgItemText(hDlg, IDS_OBJECTS, (LPSTR)szBuf);

            /* format the size of the largest record in the metafile */
            wsprintf((LPSTR)szBuf, "%lu", mfHeader.mtMaxRecord);
            SetDlgItemText(hDlg, IDS_MAXREC, (LPSTR)szBuf);
            return (TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK) {
                EndDialog(hDlg, TRUE);
                return (TRUE);
            }
            break;
    }
    return (FALSE);
}

/***********************************************************************

  FUNCTION   : PlaceableHeaderDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    : show the "extended" header of Placeable Metafiles.

  CALLS      : WINDOWS
                 wsprintf
                 SetDlgItemText
                 EndDialog

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   : Placeable metafile format

               DWORD    key;
               HANDLE   hmf;
               RECT     bbox;
               WORD     inch;
               DWORD    reserved;
               WORD     checksum;
               char     metafileData[];

               These fields have the following  meanings:

               Field         Definition

               key           Binary key that uniquely identifies this
                             file type.  This must be 0x9AC6CDD7L.

               hmf           Unused;  must be zero.

               bbox          The coordinates of a rectangle that tightly
                             bounds the picture. These coordinates are in
                             metafile units as defined below.

               inch          The number of metafile units to the inch.  To
                             avoid numeric overflow in PageMaker, this value
                             should be less than 1440.

               reserved      A reserved double word.  Must be zero.

               checksum      A checksum of the 10 words that precede it,
                             calculated by XORing zero with these 10 words
                             and putting the result in the checksum field.

               metafileData  The actual content of the Windows metafile
                             retrieved by copying the data returned by
                             GetMetafileBits to the file.  The number of
                             bytes should be equal to the MS-DOS file length
                             minus 22.  The content of a PageMaker placeable
                             metafile  cannot currently exceed 64K (this may
                             have changed in 4.0).

  HISTORY    : 1/16/91 - created - Dennis Crain

************************************************************************/

INT_PTR CALLBACK PlaceableHeaderDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    char szBuf[30];

    switch (message) {
        case WM_INITDIALOG:
            /* format the key */
            wsprintf((LPSTR)szBuf, "%lx", placeableWMFHeader.key);
            SetDlgItemText(hDlg, IDS_KEY, (LPSTR)szBuf);

            /* format the x origin of the bounding rectangle */
            wsprintf((LPSTR)szBuf, "%d", placeableWMFHeader.bbox.left);
            SetDlgItemText(hDlg, IDS_LEFT, (LPSTR)szBuf);

            /* format the x extent of the bounding rectangle */
            wsprintf((LPSTR)szBuf, "%d", placeableWMFHeader.bbox.right);
            SetDlgItemText(hDlg, IDS_RIGHT, (LPSTR)szBuf);

            /* format the y origin of the bounding rectangle */
            wsprintf((LPSTR)szBuf, "%d", placeableWMFHeader.bbox.top);
            SetDlgItemText(hDlg, IDS_TOP, (LPSTR)szBuf);

            /* format the y extent of the bounding rectangle */
            wsprintf((LPSTR)szBuf, "%d", placeableWMFHeader.bbox.bottom);
            SetDlgItemText(hDlg, IDS_BOT, (LPSTR)szBuf);

            /* format the number of metafile units per inch */
            wsprintf((LPSTR)szBuf, "%d", placeableWMFHeader.inch);
            SetDlgItemText(hDlg, IDS_INCH, (LPSTR)szBuf);

            /* format the checksum */
            wsprintf((LPSTR)szBuf, "%x", placeableWMFHeader.checksum);
            SetDlgItemText(hDlg, IDS_CHKSUM, (LPSTR)szBuf);

            return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
            if (LOWORD(wParam) == IDOK) {
                EndDialog(hDlg, TRUE);        /* Exits the dialog box        */
                return (TRUE);
            }
            break;
    }
    return (FALSE);                           /* Didn't process a message    */
}

/***********************************************************************

  FUNCTION   : ClpHeaderDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    : show the METAFILEPICT associated with the clipboard
               metafile.  This format is described on page 7-52 of
               the Windows SDK Reference Volume 2.

  CALLS      : WINDOWS
                 lstrcpy
                 wsprintf
                 SetDlgItemText
                 EndDialog

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   : METAFILEPICT format

               int    mm;
               int    xExt;
               int    yExt;
               HANDLE hMF;

               These fields have the following  meanings:

               Field         Definition

               mm            specifies the mapping mode in which the picture
                             is drawn.

               xExt          specifies the size of the metafile picture for
                             all modes except MM_ISOTROPIC and ANISOTROPIC
                             modes. See SDK reference for more info.

               yExt          as above...

               hMF           Identifies a memory metafile.

  HISTORY    : 1/16/91 - created - Dennis Crain
               7/1/93  - modified for win32

************************************************************************/

INT_PTR CALLBACK ClpHeaderDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    char szBuf[30];
    long lmm = (lpOldMFP != NULL) ? lpOldMFP->mm : lpMFP->mm;
    long lxExt = (lpOldMFP != NULL) ? lpOldMFP->xExt : lpMFP->xExt;
    long lyExt = (lpOldMFP != NULL) ? lpOldMFP->yExt : lpMFP->yExt;

    switch (message) {
        case WM_INITDIALOG:
            /*format the mapping mode */
        lstrcpy((LPSTR)szBuf, (lmm == MM_TEXT)    ? (LPSTR)"MM_TEXT"       :
                  (lmm == MM_LOMETRIC)            ? (LPSTR)"MM_LOMETRIC" :
                  (lmm == MM_HIMETRIC)            ? (LPSTR)"MM_HIMETRIC" :
                  (lmm == MM_LOENGLISH)           ? (LPSTR)"MM_LOENGLISH":
                  (lmm == MM_HIENGLISH)           ? (LPSTR)"MM_HIENGLISH":
                  (lmm == MM_TWIPS)               ? (LPSTR)"MM_TWIPS"     :
                  (lmm == MM_ISOTROPIC)           ? (LPSTR)"MM_ISOTROPIC":
                  (lmm == MM_ANISOTROPIC)         ? (LPSTR)"MM_ANISOTROPIC":
                                                    (LPSTR)"UNKOWN");
            SetDlgItemText(hDlg, IDE_MM, (LPSTR)szBuf);

            /* format the xExt */
        wsprintf((LPSTR)szBuf, "%d", lxExt);
            SetDlgItemText(hDlg, IDE_XEXT, (LPSTR)szBuf);

            /* format the yExt */
        wsprintf((LPSTR)szBuf, "%d", lyExt);
            SetDlgItemText(hDlg, IDE_YEXT, (LPSTR)szBuf);

            return (TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK) {
                EndDialog(hDlg, TRUE);
                return (TRUE);
            }
            break;
    }
    return (FALSE);
}

/***********************************************************************

  FUNCTION   : ListDlgProc

  PARAMETERS : HWND hDlg
               unsigned message
               WORD wParam
               LONG lParam

  PURPOSE    :

  CALLS      : WINDOWS
                 GetMetaFile
                 GetDC
                 EnumMetaFile
                 MakeProcInstance
                 FreeProcInstance
                 ReleaseDC
                 EndDialog
                 DeleteMetaFile
                 MessageBox
                 SendDlgItemMessage
                 GlobalAlloc
                 GlobalLock
                 DialogBox
               APP
                 PlayIt

  MESSAGES   : WM_INITDIALOG
               WM_COMMAND

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    :

************************************************************************/

void GetMetaFileAndEnum(
    HWND hwnd,
    HDC hDC,
    int iAction);

INT_PTR CALLBACK ListDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC hDC;

    CurrenthDlg = hDlg;
    switch (message) {
        case WM_INITDIALOG:
            hDC = GetDC(hWndMain);
            //
            //initalize the current record number
            //
            iRecNum = 0;
            //
            //enumerate the records into the listbox
            //
            GetMetaFileAndEnum(hWndMain, hDC, ENUMMFLIST);
            ReleaseDC(hWndMain, hDC);
            return (TRUE);

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
              case IDOK:

              case IDCANCEL:
                 EndDialog(hDlg, TRUE);
                 return(TRUE);
                 break;

              case IDL_PLAY:

                 //get the number of selected items

                 iNumSel = (DWORD) SendDlgItemMessage(hDlg,
                                              IDL_LBREC,
                                              LB_GETSELCOUNT,
                                              0,
                                              0L);

                 //allocate a buffer large enough to save the indexes

                 hSelMem = GlobalAlloc(GHND, iNumSel * sizeof(int));

                 //lock it down and assign a long ptr to it

                 if (hSelMem) {
                    lpSelMem = (int FAR *)GlobalLock(hSelMem);
                    if (!lpSelMem)
                        return(FALSE);
                 }
                 else
                    return(FALSE);

                 //get the actual indexes and put in buffer

                 iLBItemsInBuf = (DWORD) SendDlgItemMessage(hDlg,
                                                            IDL_LBREC,
                                                            LB_GETSELITEMS,
                                                            (WORD)iNumSel,
                                                            (LPARAM)lpSelMem);

                 bEnumRange = FALSE;
                 bPlayItAll = FALSE;
                 bPlayList  = TRUE;
                 iCount = 0; //reset index into lpSelMem

                 /*dialog to play selected or unselected records*/

                 DialogBox(hInst,
                           "PLAYWHAT",
                           hDlg,
                           PlayFromListDlgProc);

                 /* end this dialog prematurely to get on with playing of recs */
                 EndDialog(hDlg, TRUE);

                 /* play the metafile to the appropriate destination */
                 PlayMetaFileToDest(hWndMain, iDestDC);

                 break;

              default:
                 return (FALSE);
            }
            break;

    }
    return (FALSE);
}

/****************************************************************************

    FUNCTION: About(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages for "About" dialog box

    MESSAGES:

        WM_INITDIALOG - initialize dialog box
        WM_COMMAND    - Input received

    COMMENTS:

        No initialization is needed for this particular dialog box, but TRUE
        must be returned to Windows.

        Wait for user to click on "Ok" button, then close the dialog box.

****************************************************************************/

INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
        case WM_INITDIALOG:                /* message: initialize dialog box */
            return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
            if (LOWORD(wParam) == IDOK                /* "OK" box selected?          */
                || LOWORD(wParam) == IDCANCEL) {      /* System menu close command? */
                EndDialog(hDlg, TRUE);        /* Exits the dialog box        */
                return (TRUE);
            }
            break;
    }
    return (FALSE);                           /* Didn't process a message    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\emfdcode\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by MFDCOD32.RC
//
#define WMFDISPLAY                      0
#define ENUMMFSTEP                      0
#define FILEOPENDLG                     0
#define WMFPRINTER                      1
#define IDM_VIEW                        1
#define ENUMMFLIST                      1
#define FILESAVEDLG                     1
#define IDM_PLAY                        2
#define DEC                             10
#define HEX                             16
#define IDGO                            99
#define IDE_RECNUM                      100
#define IDE_RECSIZE                     101
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_SYMED_VALUE           101
#define IDE_FUNCTION                    102
#define _APS_NEXT_RESOURCE_VALUE        102
#define IDL_PARAMETERS                  103
#define IDM_ABOUT                       104
#define IDM_OPEN                        105
#define IDM_ENUM                        106
#define IDC_FILENAME                    107
#define IDC_EDIT                        108
#define IDC_FILES                       109
#define IDC_LISTBOX                     110
#define IDC_PATH                        111
#define IDM_HEADER                      112
#define IDS_VER                         113
#define IDS_SIZE                        114
#define IDS_OBJECTS                     115
#define IDS_MAXREC                      116
#define IDM_EXIT                        117
#define IDM_ALLREC                      118
#define IDM_GOTOREC                     119
#define IDM_CLEAR                       120
#define IDM_ENUMRANGE                   121
#define IDE_FROM                        122
#define IDE_TO                          123
#define IDCB_ALL                        124
#define IDL_PLAY                        125
#define IDL_PRINT                       126
#define IDM_LIST                        127
#define IDL_LBREC                       128
#define IDM_MM                          129
#define IDE_EDITMM                      130
#define IDCHANGE                        131
#define IDQUITENUM                      132
#define IDM_PRINT                       133
#define IDM_CLIPHDR                     134
#define IDM_PLACEABLEHDR                135
#define IDE_MM                          136
#define IDE_XEXT                        137
#define IDE_YEXT                        138
#define IDE_HMF                         139
#define IDS_KEY                         140
#define IDS_LEFT                        141
#define IDS_RIGHT                       142
#define IDS_TOP                         143
#define IDS_BOT                         144
#define IDS_INCH                        145
#define IDS_CHKSUM                      146
#define IDCB_SEL                        147
#define IDCB_UNSEL                      148
#define IDM_DESTDISPLAY                 149
#define IDM_DESTMETA                    150
#define IDB_HEX                         151
#define IDB_DEC                         152
#define IDB_CHAR                        153
#define IDM_SAVEAS                      154
#define IDM_HELPCONTENTS                155
#define IDM_GDIPLUS_CONVERT             156
#define IDB_WORD                        157
#define IDM_PRINTDLG                    158
#define IDM_GDIPLUS_PLAY                159
#define IDM_DESTDIB                     160
#define IDM_DESTPRN                     161

#define IDM_ENHHEADER					200
#define IDC_ITYPE                       1000
#define IDC_NSIZE                       1001
#define IDC_DSIGNATURE                  1002
#define IDC_NVERSION                    1003
#define IDC_NBYTES                      1004
#define IDC_NRECORDS                    1005
#define IDC_NHANDLES                    1006
#define IDC_NDESCRIPTION                1007
#define IDC_OFFDESCRIPTION              1008
#define IDC_NPALENTRIES                 1009
#define IDC_DESCSTRING                  1010
#define IDC_DEVCX                       1011
#define IDC_DEVCY                       1012
#define IDC_MILLCX                      1013
#define IDC_MILLCY                      1014
#define IDC_BOUNDSL                     1015
#define IDC_BOUNDST                     1016
#define IDC_BOUNDSR                     1017
#define IDC_BOUNDSB                     1018
#define IDC_FRAMEL                      1019
#define IDC_FRAMET                      1020
#define IDC_FRAMER                      1021
#define IDC_FRAMEB                      1022
#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\emfdcode\wmfmeta.cpp ===
/***********************************************************************

  MODULE     : WMFMETA.CPP

  FUNCTIONS  : MetaEnumProc
               GetMetaFileAndEnum
               LoadParameterLB
               PlayMetaFileToDest
               RenderClipMeta
               RenderPlaceableMeta
               SetPlaceableExts
               SetClipMetaExts
               ProcessFile

  COMMENTS   :

************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <objbase.h>
extern "C" {
#include "mfdcod32.h"
}
extern "C" {
  extern BOOL bConvertToGdiPlus;
  extern BOOL bUseGdiPlusToPlay;
}

#include "GdiPlus.h"

#include "MyData.hpp"
#include "dibstream.hpp"

#include "../gpinit.inc"

#ifndef ASSERT
#ifdef _DEBUG           // poor man's assert
#define ASSERT(cond)    if (!(cond)) { int b = 0; b = 1 / b; }
#else
#define ASSERT(cond)
#endif
#endif

// Check if a source is needed in a 3-way bitblt operation.
// This works on both rop and rop3.  We assume that a rop contains zero
// in the high byte.
//
// This is tested by comparing the rop result bits with source (column A
// below) vs. those without source (column B).  If the two cases are
// identical, then the effect of the rop does not depend on the source
// and we don't need a source device.  Recall the rop construction from
// input (pattern, source, target --> result):
//
//      P S T | R   A B         mask for A = 0CCh
//      ------+--------         mask for B =  33h
//      0 0 0 | x   0 x
//      0 0 1 | x   0 x
//      0 1 0 | x   x 0
//      0 1 1 | x   x 0
//      1 0 0 | x   0 x
//      1 0 1 | x   0 x
//      1 1 0 | x   x 0
//      1 1 1 | x   x 0

#define ISSOURCEINROP3(rop3)    \
        (((rop3) & 0xCCCC0000) != (((rop3) << 2) & 0xCCCC0000))

#ifndef EMR_SETICMMODE
#define EMR_SETICMMODE                  98
#define EMR_CREATECOLORSPACE            99
#define EMR_SETCOLORSPACE              100
#define EMR_DELETECOLORSPACE           101
#define EMR_GLSRECORD                  102
#define EMR_GLSBOUNDEDRECORD           103
#define EMR_PIXELFORMAT                104
#endif

#ifndef EMR_DRAWESCAPE
#define EMR_DRAWESCAPE                 105
#define EMR_EXTESCAPE                  106
#define EMR_STARTDOC                   107
#define EMR_SMALLTEXTOUT               108
#define EMR_FORCEUFIMAPPING            109
#define EMR_NAMEDESCAPE                110
#define EMR_COLORCORRECTPALETTE        111
#define EMR_SETICMPROFILEA             112
#define EMR_SETICMPROFILEW             113
#define EMR_ALPHABLEND                 114
#define EMR_SETLAYOUT                  115
#define EMR_TRANSPARENTBLT             116
#define EMR_GRADIENTFILL               118
#define EMR_SETLINKEDUFIS              119
#define EMR_SETTEXTJUSTIFICATION       120
#define EMR_COLORMATCHTOTARGETW        121
#define EMR_CREATECOLORSPACEW          122
#endif

#define TOREAL(i)   (static_cast<float>(i))


//
// Wrap a GDI+ TextureBrush object around DIB data
//

class DibBrush
{
public:

    DibBrush(const BITMAPINFO* bmi, const BYTE* bits) :
        dibStream(bmi, bits),
        bitmap(&dibStream),
        brush(&bitmap)
    {
    }

    operator Gdiplus::TextureBrush*()
    {
        return &brush;
    }

private:

    DibStream dibStream;
    Gdiplus::Bitmap bitmap;
    Gdiplus::TextureBrush brush;
};

//
//lookup table for EMF and WMF metafile records
//
EMFMETARECORDS emfMetaRecords[] = {
    "WmfSetBkColor"                    , Gdiplus::WmfRecordTypeSetBkColor                ,
    "WmfSetBkMode"                     , Gdiplus::WmfRecordTypeSetBkMode                 ,
    "WmfSetMapMode"                    , Gdiplus::WmfRecordTypeSetMapMode                ,
    "WmfSetROP2"                       , Gdiplus::WmfRecordTypeSetROP2                   ,
    "WmfSetRelAbs"                     , Gdiplus::WmfRecordTypeSetRelAbs                 ,
    "WmfSetPolyFillMode"               , Gdiplus::WmfRecordTypeSetPolyFillMode           ,
    "WmfSetStretchBltMode"             , Gdiplus::WmfRecordTypeSetStretchBltMode         ,
    "WmfSetTextCharExtra"              , Gdiplus::WmfRecordTypeSetTextCharExtra          ,
    "WmfSetTextColor"                  , Gdiplus::WmfRecordTypeSetTextColor              ,
    "WmfSetTextJustification"          , Gdiplus::WmfRecordTypeSetTextJustification      ,
    "WmfSetWindowOrg"                  , Gdiplus::WmfRecordTypeSetWindowOrg              ,
    "WmfSetWindowExt"                  , Gdiplus::WmfRecordTypeSetWindowExt              ,
    "WmfSetViewportOrg"                , Gdiplus::WmfRecordTypeSetViewportOrg            ,
    "WmfSetViewportExt"                , Gdiplus::WmfRecordTypeSetViewportExt            ,
    "WmfOffsetWindowOrg"               , Gdiplus::WmfRecordTypeOffsetWindowOrg           ,
    "WmfScaleWindowExt"                , Gdiplus::WmfRecordTypeScaleWindowExt            ,
    "WmfOffsetViewportOrg"             , Gdiplus::WmfRecordTypeOffsetViewportOrg         ,
    "WmfScaleViewportExt"              , Gdiplus::WmfRecordTypeScaleViewportExt          ,
    "WmfLineTo"                        , Gdiplus::WmfRecordTypeLineTo                    ,
    "WmfMoveTo"                        , Gdiplus::WmfRecordTypeMoveTo                    ,
    "WmfExcludeClipRect"               , Gdiplus::WmfRecordTypeExcludeClipRect           ,
    "WmfIntersectClipRect"             , Gdiplus::WmfRecordTypeIntersectClipRect         ,
    "WmfArc"                           , Gdiplus::WmfRecordTypeArc                       ,
    "WmfEllipse"                       , Gdiplus::WmfRecordTypeEllipse                   ,
    "WmfFloodFill"                     , Gdiplus::WmfRecordTypeFloodFill                 ,
    "WmfPie"                           , Gdiplus::WmfRecordTypePie                       ,
    "WmfRectangle"                     , Gdiplus::WmfRecordTypeRectangle                 ,
    "WmfRoundRect"                     , Gdiplus::WmfRecordTypeRoundRect                 ,
    "WmfPatBlt"                        , Gdiplus::WmfRecordTypePatBlt                    ,
    "WmfSaveDC"                        , Gdiplus::WmfRecordTypeSaveDC                    ,
    "WmfSetPixel"                      , Gdiplus::WmfRecordTypeSetPixel                  ,
    "WmfOffsetClipRgn"                 , Gdiplus::WmfRecordTypeOffsetClipRgn             ,
    "WmfTextOut"                       , Gdiplus::WmfRecordTypeTextOut                   ,
    "WmfBitBlt"                        , Gdiplus::WmfRecordTypeBitBlt                    ,
    "WmfStretchBlt"                    , Gdiplus::WmfRecordTypeStretchBlt                ,
    "WmfPolygon"                       , Gdiplus::WmfRecordTypePolygon                   ,
    "WmfPolyline"                      , Gdiplus::WmfRecordTypePolyline                  ,
    "WmfEscape"                        , Gdiplus::WmfRecordTypeEscape                    ,
    "WmfRestoreDC"                     , Gdiplus::WmfRecordTypeRestoreDC                 ,
    "WmfFillRegion"                    , Gdiplus::WmfRecordTypeFillRegion                ,
    "WmfFrameRegion"                   , Gdiplus::WmfRecordTypeFrameRegion               ,
    "WmfInvertRegion"                  , Gdiplus::WmfRecordTypeInvertRegion              ,
    "WmfPaintRegion"                   , Gdiplus::WmfRecordTypePaintRegion               ,
    "WmfSelectClipRegion"              , Gdiplus::WmfRecordTypeSelectClipRegion          ,
    "WmfSelectObject"                  , Gdiplus::WmfRecordTypeSelectObject              ,
    "WmfSetTextAlign"                  , Gdiplus::WmfRecordTypeSetTextAlign              ,
    "WmfDrawText"                      , Gdiplus::WmfRecordTypeDrawText                  ,
    "WmfChord"                         , Gdiplus::WmfRecordTypeChord                     ,
    "WmfSetMapperFlags"                , Gdiplus::WmfRecordTypeSetMapperFlags            ,
    "WmfExtTextOut"                    , Gdiplus::WmfRecordTypeExtTextOut                ,
    "WmfSetDIBToDev"                   , Gdiplus::WmfRecordTypeSetDIBToDev               ,
    "WmfSelectPalette"                 , Gdiplus::WmfRecordTypeSelectPalette             ,
    "WmfRealizePalette"                , Gdiplus::WmfRecordTypeRealizePalette            ,
    "WmfAnimatePalette"                , Gdiplus::WmfRecordTypeAnimatePalette            ,
    "WmfSetPalEntries"                 , Gdiplus::WmfRecordTypeSetPalEntries             ,
    "WmfPolyPolygon"                   , Gdiplus::WmfRecordTypePolyPolygon               ,
    "WmfResizePalette"                 , Gdiplus::WmfRecordTypeResizePalette             ,
    "WmfDIBBitBlt"                     , Gdiplus::WmfRecordTypeDIBBitBlt                 ,
    "WmfDIBStretchBlt"                 , Gdiplus::WmfRecordTypeDIBStretchBlt             ,
    "WmfDIBCreatePatternBrush"         , Gdiplus::WmfRecordTypeDIBCreatePatternBrush     ,
    "WmfStretchDIB"                    , Gdiplus::WmfRecordTypeStretchDIB                ,
    "WmfExtFloodFill"                  , Gdiplus::WmfRecordTypeExtFloodFill              ,
    "WmfSetLayout"                     , Gdiplus::WmfRecordTypeSetLayout                 ,
    "WmfResetDC"                       , Gdiplus::WmfRecordTypeResetDC                   ,
    "WmfStartDoc"                      , Gdiplus::WmfRecordTypeStartDoc                  ,
    "WmfStartPage"                     , Gdiplus::WmfRecordTypeStartPage                 ,
    "WmfEndPage"                       , Gdiplus::WmfRecordTypeEndPage                   ,
    "WmfAbortDoc"                      , Gdiplus::WmfRecordTypeAbortDoc                  ,
    "WmfEndDoc"                        , Gdiplus::WmfRecordTypeEndDoc                    ,
    "WmfDeleteObject"                  , Gdiplus::WmfRecordTypeDeleteObject              ,
    "WmfCreatePalette"                 , Gdiplus::WmfRecordTypeCreatePalette             ,
    "WmfCreateBrush"                   , Gdiplus::WmfRecordTypeCreateBrush               ,
    "WmfCreatePatternBrush"            , Gdiplus::WmfRecordTypeCreatePatternBrush        ,
    "WmfCreatePenIndirect"             , Gdiplus::WmfRecordTypeCreatePenIndirect         ,
    "WmfCreateFontIndirect"            , Gdiplus::WmfRecordTypeCreateFontIndirect        ,
    "WmfCreateBrushIndirect"           , Gdiplus::WmfRecordTypeCreateBrushIndirect       ,
    "WmfCreateBitmapIndirect"          , Gdiplus::WmfRecordTypeCreateBitmapIndirect      ,
    "WmfCreateBitmap"                  , Gdiplus::WmfRecordTypeCreateBitmap              ,
    "WmfCreateRegion"                  , Gdiplus::WmfRecordTypeCreateRegion              ,
    "EmfHeader"                        , Gdiplus::EmfRecordTypeHeader                     ,
    "EmfPolyBezier"                    , Gdiplus::EmfRecordTypePolyBezier                 ,
    "EmfPolygon"                       , Gdiplus::EmfRecordTypePolygon                    ,
    "EmfPolyline"                      , Gdiplus::EmfRecordTypePolyline                   ,
    "EmfPolyBezierTo"                  , Gdiplus::EmfRecordTypePolyBezierTo               ,
    "EmfPolyLineTo"                    , Gdiplus::EmfRecordTypePolyLineTo                 ,
    "EmfPolyPolyline"                  , Gdiplus::EmfRecordTypePolyPolyline               ,
    "EmfPolyPolygon"                   , Gdiplus::EmfRecordTypePolyPolygon                ,
    "EmfSetWindowExtEx"                , Gdiplus::EmfRecordTypeSetWindowExtEx             ,
    "EmfSetWindowOrgEx"                , Gdiplus::EmfRecordTypeSetWindowOrgEx             ,
    "EmfSetViewportExtEx"              , Gdiplus::EmfRecordTypeSetViewportExtEx           ,
    "EmfSetViewportOrgEx"              , Gdiplus::EmfRecordTypeSetViewportOrgEx           ,
    "EmfSetBrushOrgEx"                 , Gdiplus::EmfRecordTypeSetBrushOrgEx              ,
    "EmfEOF"                           , Gdiplus::EmfRecordTypeEOF                        ,
    "EmfSetPixelV"                     , Gdiplus::EmfRecordTypeSetPixelV                  ,
    "EmfSetMapperFlags"                , Gdiplus::EmfRecordTypeSetMapperFlags             ,
    "EmfSetMapMode"                    , Gdiplus::EmfRecordTypeSetMapMode                 ,
    "EmfSetBkMode"                     , Gdiplus::EmfRecordTypeSetBkMode                  ,
    "EmfSetPolyFillMode"               , Gdiplus::EmfRecordTypeSetPolyFillMode            ,
    "EmfSetROP2"                       , Gdiplus::EmfRecordTypeSetROP2                    ,
    "EmfSetStretchBltMode"             , Gdiplus::EmfRecordTypeSetStretchBltMode          ,
    "EmfSetTextAlign"                  , Gdiplus::EmfRecordTypeSetTextAlign               ,
    "EmfSetColorAdjustment"            , Gdiplus::EmfRecordTypeSetColorAdjustment         ,
    "EmfSetTextColor"                  , Gdiplus::EmfRecordTypeSetTextColor               ,
    "EmfSetBkColor"                    , Gdiplus::EmfRecordTypeSetBkColor                 ,
    "EmfOffsetClipRgn"                 , Gdiplus::EmfRecordTypeOffsetClipRgn              ,
    "EmfMoveToEx"                      , Gdiplus::EmfRecordTypeMoveToEx                   ,
    "EmfSetMetaRgn"                    , Gdiplus::EmfRecordTypeSetMetaRgn                 ,
    "EmfExcludeClipRect"               , Gdiplus::EmfRecordTypeExcludeClipRect            ,
    "EmfIntersectClipRect"             , Gdiplus::EmfRecordTypeIntersectClipRect          ,
    "EmfScaleViewportExtEx"            , Gdiplus::EmfRecordTypeScaleViewportExtEx         ,
    "EmfScaleWindowExtEx"              , Gdiplus::EmfRecordTypeScaleWindowExtEx           ,
    "EmfSaveDC"                        , Gdiplus::EmfRecordTypeSaveDC                     ,
    "EmfRestoreDC"                     , Gdiplus::EmfRecordTypeRestoreDC                  ,
    "EmfSetWorldTransform"             , Gdiplus::EmfRecordTypeSetWorldTransform          ,
    "EmfModifyWorldTransform"          , Gdiplus::EmfRecordTypeModifyWorldTransform       ,
    "EmfSelectObject"                  , Gdiplus::EmfRecordTypeSelectObject               ,
    "EmfCreatePen"                     , Gdiplus::EmfRecordTypeCreatePen                  ,
    "EmfCreateBrushIndirect"           , Gdiplus::EmfRecordTypeCreateBrushIndirect        ,
    "EmfDeleteObject"                  , Gdiplus::EmfRecordTypeDeleteObject               ,
    "EmfAngleArc"                      , Gdiplus::EmfRecordTypeAngleArc                   ,
    "EmfEllipse"                       , Gdiplus::EmfRecordTypeEllipse                    ,
    "EmfRectangle"                     , Gdiplus::EmfRecordTypeRectangle                  ,
    "EmfRoundRect"                     , Gdiplus::EmfRecordTypeRoundRect                  ,
    "EmfArc"                           , Gdiplus::EmfRecordTypeArc                        ,
    "EmfChord"                         , Gdiplus::EmfRecordTypeChord                      ,
    "EmfPie"                           , Gdiplus::EmfRecordTypePie                        ,
    "EmfSelectPalette"                 , Gdiplus::EmfRecordTypeSelectPalette              ,
    "EmfCreatePalette"                 , Gdiplus::EmfRecordTypeCreatePalette              ,
    "EmfSetPaletteEntries"             , Gdiplus::EmfRecordTypeSetPaletteEntries          ,
    "EmfResizePalette"                 , Gdiplus::EmfRecordTypeResizePalette              ,
    "EmfRealizePalette"                , Gdiplus::EmfRecordTypeRealizePalette             ,
    "EmfExtFloodFill"                  , Gdiplus::EmfRecordTypeExtFloodFill               ,
    "EmfLineTo"                        , Gdiplus::EmfRecordTypeLineTo                     ,
    "EmfArcTo"                         , Gdiplus::EmfRecordTypeArcTo                      ,
    "EmfPolyDraw"                      , Gdiplus::EmfRecordTypePolyDraw                   ,
    "EmfSetArcDirection"               , Gdiplus::EmfRecordTypeSetArcDirection            ,
    "EmfSetMiterLimit"                 , Gdiplus::EmfRecordTypeSetMiterLimit              ,
    "EmfBeginPath"                     , Gdiplus::EmfRecordTypeBeginPath                  ,
    "EmfEndPath"                       , Gdiplus::EmfRecordTypeEndPath                    ,
    "EmfCloseFigure"                   , Gdiplus::EmfRecordTypeCloseFigure                ,
    "EmfFillPath"                      , Gdiplus::EmfRecordTypeFillPath                   ,
    "EmfStrokeAndFillPath"             , Gdiplus::EmfRecordTypeStrokeAndFillPath          ,
    "EmfStrokePath"                    , Gdiplus::EmfRecordTypeStrokePath                 ,
    "EmfFlattenPath"                   , Gdiplus::EmfRecordTypeFlattenPath                ,
    "EmfWidenPath"                     , Gdiplus::EmfRecordTypeWidenPath                  ,
    "EmfSelectClipPath"                , Gdiplus::EmfRecordTypeSelectClipPath             ,
    "EmfAbortPath"                     , Gdiplus::EmfRecordTypeAbortPath                  ,
    "EmfReserved_069"                  , Gdiplus::EmfRecordTypeReserved_069               ,
    "EmfGdiComment"                    , Gdiplus::EmfRecordTypeGdiComment                 ,
    "EmfFillRgn"                       , Gdiplus::EmfRecordTypeFillRgn                    ,
    "EmfFrameRgn"                      , Gdiplus::EmfRecordTypeFrameRgn                   ,
    "EmfInvertRgn"                     , Gdiplus::EmfRecordTypeInvertRgn                  ,
    "EmfPaintRgn"                      , Gdiplus::EmfRecordTypePaintRgn                   ,
    "EmfExtSelectClipRgn"              , Gdiplus::EmfRecordTypeExtSelectClipRgn           ,
    "EmfBitBlt"                        , Gdiplus::EmfRecordTypeBitBlt                     ,
    "EmfStretchBlt"                    , Gdiplus::EmfRecordTypeStretchBlt                 ,
    "EmfMaskBlt"                       , Gdiplus::EmfRecordTypeMaskBlt                    ,
    "EmfPlgBlt"                        , Gdiplus::EmfRecordTypePlgBlt                     ,
    "EmfSetDIBitsToDevice"             , Gdiplus::EmfRecordTypeSetDIBitsToDevice          ,
    "EmfStretchDIBits"                 , Gdiplus::EmfRecordTypeStretchDIBits              ,
    "EmfExtCreateFontIndirect"         , Gdiplus::EmfRecordTypeExtCreateFontIndirect      ,
    "EmfExtTextOutA"                   , Gdiplus::EmfRecordTypeExtTextOutA                ,
    "EmfExtTextOutW"                   , Gdiplus::EmfRecordTypeExtTextOutW                ,
    "EmfPolyBezier16"                  , Gdiplus::EmfRecordTypePolyBezier16               ,
    "EmfPolygon16"                     , Gdiplus::EmfRecordTypePolygon16                  ,
    "EmfPolyline16"                    , Gdiplus::EmfRecordTypePolyline16                 ,
    "EmfPolyBezierTo16"                , Gdiplus::EmfRecordTypePolyBezierTo16             ,
    "EmfPolylineTo16"                  , Gdiplus::EmfRecordTypePolylineTo16               ,
    "EmfPolyPolyline16"                , Gdiplus::EmfRecordTypePolyPolyline16             ,
    "EmfPolyPolygon16"                 , Gdiplus::EmfRecordTypePolyPolygon16              ,
    "EmfPolyDraw16"                    , Gdiplus::EmfRecordTypePolyDraw16                 ,
    "EmfCreateMonoBrush"               , Gdiplus::EmfRecordTypeCreateMonoBrush            ,
    "EmfCreateDIBPatternBrushPt"       , Gdiplus::EmfRecordTypeCreateDIBPatternBrushPt    ,
    "EmfExtCreatePen"                  , Gdiplus::EmfRecordTypeExtCreatePen               ,
    "EmfPolyTextOutA"                  , Gdiplus::EmfRecordTypePolyTextOutA               ,
    "EmfPolyTextOutW"                  , Gdiplus::EmfRecordTypePolyTextOutW               ,
    "EmfSetICMMode"                    , Gdiplus::EmfRecordTypeSetICMMode                 ,
    "EmfCreateColorSpace"              , Gdiplus::EmfRecordTypeCreateColorSpace           ,
    "EmfSetColorSpace"                 , Gdiplus::EmfRecordTypeSetColorSpace              ,
    "EmfDeleteColorSpace"              , Gdiplus::EmfRecordTypeDeleteColorSpace           ,
    "EmfGLSRecord"                     , Gdiplus::EmfRecordTypeGLSRecord                  ,
    "EmfGLSBoundedRecord"              , Gdiplus::EmfRecordTypeGLSBoundedRecord           ,
    "EmfPixelFormat"                   , Gdiplus::EmfRecordTypePixelFormat                ,
    "EmfDrawEscape"                    , Gdiplus::EmfRecordTypeDrawEscape                 ,
    "EmfExtEscape"                     , Gdiplus::EmfRecordTypeExtEscape                  ,
    "EmfStartDoc"                      , Gdiplus::EmfRecordTypeStartDoc                   ,
    "EmfSmallTextOut"                  , Gdiplus::EmfRecordTypeSmallTextOut               ,
    "EmfForceUFIMapping"               , Gdiplus::EmfRecordTypeForceUFIMapping            ,
    "EmfNamedEscape"                   , Gdiplus::EmfRecordTypeNamedEscape                ,
    "EmfColorCorrectPalette"           , Gdiplus::EmfRecordTypeColorCorrectPalette        ,
    "EmfSetICMProfileA"                , Gdiplus::EmfRecordTypeSetICMProfileA             ,
    "EmfSetICMProfileW"                , Gdiplus::EmfRecordTypeSetICMProfileW             ,
    "EmfAlphaBlend"                    , Gdiplus::EmfRecordTypeAlphaBlend                 ,
    "EmfSetLayout"                     , Gdiplus::EmfRecordTypeSetLayout                  ,
    "EmfTransparentBlt"                , Gdiplus::EmfRecordTypeTransparentBlt             ,
    "EmfReserved_117"                  , Gdiplus::EmfRecordTypeReserved_117               ,
    "EmfGradientFill"                  , Gdiplus::EmfRecordTypeGradientFill               ,
    "EmfSetLinkedUFIs"                 , Gdiplus::EmfRecordTypeSetLinkedUFIs              ,
    "EmfSetTextJustification"          , Gdiplus::EmfRecordTypeSetTextJustification       ,
    "EmfColorMatchToTargetW"           , Gdiplus::EmfRecordTypeColorMatchToTargetW        ,
    "EmfCreateColorSpaceW"             , Gdiplus::EmfRecordTypeCreateColorSpaceW          ,
    "EmfPlusHeader"                    , Gdiplus::EmfPlusRecordTypeHeader                 ,
    "EmfPlusEndOfFile"                 , Gdiplus::EmfPlusRecordTypeEndOfFile              ,
    "EmfPlusComment"                   , Gdiplus::EmfPlusRecordTypeComment                ,
    "EmfPlusGetDC"                     , Gdiplus::EmfPlusRecordTypeGetDC                  ,
    "EmfPlusMultiFormatStart"          , Gdiplus::EmfPlusRecordTypeMultiFormatStart       ,
    "EmfPlusMultiFormatSection"        , Gdiplus::EmfPlusRecordTypeMultiFormatSection     ,
    "EmfPlusMultiFormatEnd"            , Gdiplus::EmfPlusRecordTypeMultiFormatEnd         ,
    "EmfPlusObject"                    , Gdiplus::EmfPlusRecordTypeObject                 ,
    "EmfPlusClear"                     , Gdiplus::EmfPlusRecordTypeClear                  ,
    "EmfPlusFillRects"                 , Gdiplus::EmfPlusRecordTypeFillRects              ,
    "EmfPlusDrawRects"                 , Gdiplus::EmfPlusRecordTypeDrawRects              ,
    "EmfPlusFillPolygon"               , Gdiplus::EmfPlusRecordTypeFillPolygon            ,
    "EmfPlusDrawLines"                 , Gdiplus::EmfPlusRecordTypeDrawLines              ,
    "EmfPlusFillEllipse"               , Gdiplus::EmfPlusRecordTypeFillEllipse            ,
    "EmfPlusDrawEllipse"               , Gdiplus::EmfPlusRecordTypeDrawEllipse            ,
    "EmfPlusFillPie"                   , Gdiplus::EmfPlusRecordTypeFillPie                ,
    "EmfPlusDrawPie"                   , Gdiplus::EmfPlusRecordTypeDrawPie                ,
    "EmfPlusDrawArc"                   , Gdiplus::EmfPlusRecordTypeDrawArc                ,
    "EmfPlusFillRegion"                , Gdiplus::EmfPlusRecordTypeFillRegion             ,
    "EmfPlusFillPath"                  , Gdiplus::EmfPlusRecordTypeFillPath               ,
    "EmfPlusDrawPath"                  , Gdiplus::EmfPlusRecordTypeDrawPath               ,
    "EmfPlusFillClosedCurve"           , Gdiplus::EmfPlusRecordTypeFillClosedCurve        ,
    "EmfPlusDrawClosedCurve"           , Gdiplus::EmfPlusRecordTypeDrawClosedCurve        ,
    "EmfPlusDrawCurve"                 , Gdiplus::EmfPlusRecordTypeDrawCurve              ,
    "EmfPlusDrawBeziers"               , Gdiplus::EmfPlusRecordTypeDrawBeziers            ,
    "EmfPlusDrawImage"                 , Gdiplus::EmfPlusRecordTypeDrawImage              ,
    "EmfPlusDrawImagePoints"           , Gdiplus::EmfPlusRecordTypeDrawImagePoints        ,
    "EmfPlusDrawString"                , Gdiplus::EmfPlusRecordTypeDrawString             ,
    "EmfPlusSetRenderingOrigin"        , Gdiplus::EmfPlusRecordTypeSetRenderingOrigin     ,
    "EmfPlusSetAntiAliasMode"          , Gdiplus::EmfPlusRecordTypeSetAntiAliasMode       ,
    "EmfPlusSetTextRenderingHint"      , Gdiplus::EmfPlusRecordTypeSetTextRenderingHint   ,
    "EmfPlusSetTextContrast"           , Gdiplus::EmfPlusRecordTypeSetTextContrast        ,
    "EmfPlusSetInterpolationMode"      , Gdiplus::EmfPlusRecordTypeSetInterpolationMode   ,
    "EmfPlusSetPixelOffsetMode"        , Gdiplus::EmfPlusRecordTypeSetPixelOffsetMode     ,
    "EmfPlusSetCompositingMode"        , Gdiplus::EmfPlusRecordTypeSetCompositingMode     ,
    "EmfPlusSetCompositingQuality"     , Gdiplus::EmfPlusRecordTypeSetCompositingQuality  ,
    "EmfPlusSave"                      , Gdiplus::EmfPlusRecordTypeSave                   ,
    "EmfPlusRestore"                   , Gdiplus::EmfPlusRecordTypeRestore                ,
    "EmfPlusBeginContainer"            , Gdiplus::EmfPlusRecordTypeBeginContainer         ,
    "EmfPlusBeginContainerNoParams"    , Gdiplus::EmfPlusRecordTypeBeginContainerNoParams ,
    "EmfPlusEndContainer"              , Gdiplus::EmfPlusRecordTypeEndContainer           ,
    "EmfPlusSetWorldTransform"         , Gdiplus::EmfPlusRecordTypeSetWorldTransform      ,
    "EmfPlusResetWorldTransform"       , Gdiplus::EmfPlusRecordTypeResetWorldTransform    ,
    "EmfPlusMultiplyWorldTransform"    , Gdiplus::EmfPlusRecordTypeMultiplyWorldTransform ,
    "EmfPlusTranslateWorldTransform"   , Gdiplus::EmfPlusRecordTypeTranslateWorldTransform,
    "EmfPlusScaleWorldTransform"       , Gdiplus::EmfPlusRecordTypeScaleWorldTransform    ,
    "EmfPlusRotateWorldTransform"      , Gdiplus::EmfPlusRecordTypeRotateWorldTransform   ,
    "EmfPlusSetPageTransform"          , Gdiplus::EmfPlusRecordTypeSetPageTransform       ,
    "EmfPlusResetClip"                 , Gdiplus::EmfPlusRecordTypeResetClip              ,
    "EmfPlusSetClipRect"               , Gdiplus::EmfPlusRecordTypeSetClipRect            ,
    "EmfPlusSetClipPath"               , Gdiplus::EmfPlusRecordTypeSetClipPath            ,
    "EmfPlusSetClipRegion"             , Gdiplus::EmfPlusRecordTypeSetClipRegion          ,
    "EmfPlusOffsetClip"                , Gdiplus::EmfPlusRecordTypeOffsetClip             ,
    "EmfPlusDrawDriverString"          , Gdiplus::EmfPlusRecordTypeDrawDriverString       ,
};

/*
METAFUNCTIONS MetaFunctions[] = {

     "SETBKCOLOR",           0x0201,
     "SETBKMODE",            0x0102,
     "SETMAPMODE",           0x0103,
     "SETROP2",              0x0104,
     "SETRELABS",            0x0105,
     "SETPOLYFILLMODE",      0x0106,
     "SETSTRETCHBLTMODE",    0x0107,
     "SETTEXTCHAREXTRA",     0x0108,
     "SETTEXTCOLOR",         0x0209,
     "SETTEXTJUSTIFICATION", 0x020A,
     "SETWINDOWORG",         0x020B,
     "SETWINDOWEXT",         0x020C,
     "SETVIEWPORTORG",       0x020D,
     "SETVIEWPORTEXT",       0x020E,
     "OFFSETWINDOWORG",      0x020F,
     "SCALEWINDOWEXT",       0x0400,
     "OFFSETVIEWPORTORG",    0x0211,
     "SCALEVIEWPORTEXT",     0x0412,
     "LINETO",               0x0213,
     "MOVETO",               0x0214,
     "EXCLUDECLIPRECT",      0x0415,
     "INTERSECTCLIPRECT",    0x0416,
     "ARC",                  0x0817,
     "ELLIPSE",              0x0418,
     "FLOODFILL",            0x0419,
     "PIE",                  0x081A,
     "RECTANGLE",            0x041B,
     "ROUNDRECT",            0x061C,
     "PATBLT",               0x061D,
     "SAVEDC",               0x001E,
     "SETPIXEL",             0x041F,
     "OFFSETCLIPRGN",        0x0220,
     "TEXTOUT",              0x0521,
     "BITBLT",               0x0922,
     "STRETCHBLT",           0x0B23,
     "POLYGON",              0x0324,
     "POLYLINE",             0x0325,
     "ESCAPE",               0x0626,
     "RESTOREDC",            0x0127,
     "FILLREGION",           0x0228,
     "FRAMEREGION",          0x0429,
     "INVERTREGION",         0x012A,
     "PAINTREGION",          0x012B,
     "SELECTCLIPREGION",     0x012C,
     "SELECTOBJECT",         0x012D,
     "SETTEXTALIGN",         0x012E,
     "DRAWTEXT",             0x062F,
     "CHORD",                0x0830,
     "SETMAPPERFLAGS",       0x0231,
     "EXTTEXTOUT",           0x0a32,
     "SETDIBTODEV",          0x0d33,
     "SELECTPALETTE",        0x0234,
     "REALIZEPALETTE",       0x0035,
     "ANIMATEPALETTE",       0x0436,
     "SETPALENTRIES",        0x0037,
     "POLYPOLYGON",          0x0538,
     "RESIZEPALETTE",        0x0139,
     "DIBBITBLT",            0x0940,
     "DIBSTRETCHBLT",        0x0b41,
     "DIBCREATEPATTERNBRUSH",0x0142,
     "STRETCHDIB",           0x0f43,
     "DELETEOBJECT",         0x01f0,
     "CREATEPALETTE",        0x00f7,
     "CREATEBRUSH",          0x00F8,
     "CREATEPATTERNBRUSH",   0x01F9,
     "CREATEPENINDIRECT",    0x02FA,
     "CREATEFONTINDIRECT",   0x02FB,
     "CREATEBRUSHINDIRECT",  0x02FC,
     "CREATEBITMAPINDIRECT", 0x02FD,
     "CREATEBITMAP",         0x06FE,
     "CREATEREGION",         0x06FF,
};
*/

/***********************************************************************

  FUNCTION   : MetaEnumProc

  PARAMETERS : HDC           hDC
               LPHANDLETABLE lpHTable
               LPMETARECORD  lpMFR
               int           nObj
               LPARAM        lpClientData


  PURPOSE    : callback for EnumMetaFile.

  CALLS      : EnumMFIndirect()

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc
               5/6/93  - modified for Win32 - denniscr

************************************************************************/

int CALLBACK MetaEnumProc(
HDC           hDC,
LPHANDLETABLE lpHTable,
LPMETARECORD  lpMFR,
int           nObj,
LPARAM        lpClientData)

{
  return EnumMFIndirect(hDC, lpHTable, lpMFR, NULL, nObj, lpClientData);
}

/***********************************************************************

  FUNCTION   : LoadParameterLB

  PARAMETERS : HWND  hDlg
           DWORD dwParams
           int   nRadix - HEX to display contents in base 16
                  DEC to display contents in base 10

  PURPOSE    : display the parameters of the metafile record in
           the parameter listbox

  CALLS      : WINDOWS
         GlobalLock
         GlobalUnlock
         SendDlgItemMessage
         wsprintf
         lstrlen

  MESSAGES   : WM_SETREDRAW
           WM_RESETCONTENT
           LB_ADDSTRING

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

************************************************************************/

BOOL LoadParameterLB(
HWND         hDlg,
DWORD        dwParams,
int          nRadix)
{
  DWORD i;
  BYTE nHiByte, nLoByte;
  BYTE nHiByteHi, nLoByteHi;
  WORD wHiWord, wLoWord;
  char szBuffer[40];
  char szDump[100];
  int  iValue = 0;
  DWORD dwValue = 0;

  switch (nRadix)  /* if nRadix is not a valid value, return FALSE */
  {
    case IDB_HEX:
    case IDB_DEC:
    case IDB_CHAR:
    case IDB_WORD:
        break;

    default :
        return FALSE;
  }
  //
  //init the strings
  //
  *szBuffer = '\0';
  *szDump = '\0';
  //
  //turn off redrawing of the listbox
  //
  SendDlgItemMessage(hDlg, IDL_PARAMETERS, WM_SETREDRAW, FALSE, 0L);
  //
  //reset the contents of the listbox
  //
  SendDlgItemMessage(hDlg, IDL_PARAMETERS, LB_RESETCONTENT, 0, 0L);

  // don't load an entire bitmap or other image into the dialog in hex
  if (dwParams > 1024)
  {
    dwParams = 1024;
  }

  if (bEnhMeta)
  {
    //
    //lock the memory where the parameters can be found
    //
    if (NULL == (lpEMFParams = (LPEMFPARAMETERS)GlobalLock(hMem)))
      return (FALSE);
    //
    //loop through the metafile record parameters
    //
    for (i = 0; i < dwParams; i++)
    {

      /* get the high and low byte of the parameter word */
      wHiWord = HIWORD(lpEMFParams[i]);
      wLoWord = LOWORD(lpEMFParams[i]);
      nLoByteHi = LOBYTE(wHiWord);
      nHiByteHi = HIBYTE(wHiWord);
      nLoByte   = LOBYTE(wLoWord);
      nHiByte   = HIBYTE(wLoWord);

      switch (nRadix)
      {
        case IDB_HEX: /* if we are to display as hexadecimal */
           /* format the bytes for the hex part of dump */
           wsprintf((LPSTR)szBuffer, (LPSTR)"%08x ", lpEMFParams[i]);
           break;

        case IDB_DEC:
           /* format the bytes for the decimal part of dump */
           dwValue = lpEMFParams[i];
           wsprintf((LPSTR)szBuffer, (LPSTR)"%lu ", dwValue );
           break;

        case IDB_CHAR:
           wsprintf((LPSTR)szBuffer, (LPSTR)"%c%c%c%c",
                    (nLoByte > 0x20) ? nLoByte : 0x2E,
                    (nHiByte > 0x20) ? nHiByte : 0x2E,
                    (nLoByteHi > 0x20) ? nLoByteHi : 0x2E,
                    (nHiByteHi > 0x20) ? nHiByteHi : 0x2E);
           break;

        case IDB_WORD: /* if we are to display as hexadecimal */
           /* format the bytes for the hex part of dump */
           wsprintf((LPSTR)szBuffer, (LPSTR)"%04x %04x ", wLoWord, wHiWord );
           break;


        default :
          return FALSE;
      }


      /* concatenate it onto whatever we have already formatted */
      lstrcat((LPSTR)szDump, (LPSTR)szBuffer);

      /* use every 8 words for hex/dec dump */
      if (!((i + 1) % 4))
      {

        /*add the string to the listbox */
        SendDlgItemMessage(hDlg, IDL_PARAMETERS, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szDump);

        /* re-init the hex/dec strings in preparation for next 8 words */
        *szDump = '\0';
      }
    }


  }
  else
  {
    /* lock the memory where the parameters can be found */
    if (NULL == (lpMFParams = (LPPARAMETERS)GlobalLock(hMem)))
      return (FALSE);

    /* loop through the metafile record parameters */
    for (i = 0; i < dwParams; i++)
    {

      /* get the high and low byte of the parameter word */
      nHiByte = HIBYTE(lpMFParams[i]);
      nLoByte = LOBYTE(lpMFParams[i]);

      switch (nRadix)
      {
        case IDB_HEX: /* if we are to display as hexadecimal */
           /* format the bytes for the hex part of dump */
           wsprintf((LPSTR)szBuffer, (LPSTR)"%02x %02x ", nLoByte, nHiByte );
           break;

        case IDB_DEC:
           /* format the bytes for the decimal part of dump */
           iValue = lpMFParams[i];
           wsprintf((LPSTR)szBuffer, (LPSTR)"%d ", iValue );
           break;

        case IDB_CHAR:
           wsprintf((LPSTR)szBuffer, (LPSTR)"%c%c",
                    (nLoByte > 0x20) ? nLoByte : 0x2E,
                    (nHiByte > 0x20) ? nHiByte : 0x2E);
           break;

        case IDB_WORD: /* if we are to display as hexadecimal */
           /* format the bytes for the hex part of dump */
           wsprintf((LPSTR)szBuffer, (LPSTR)"%02x%02x ", nHiByte, nLoByte );
           break;

        default :
          return FALSE;
      }


      /* concatenate it onto whatever we have already formatted */
      lstrcat((LPSTR)szDump, (LPSTR)szBuffer);

      /* use every 8 words for hex/dec dump */
      if (!((i + 1) % 8))
      {

        /*add the string to the listbox */
        SendDlgItemMessage(hDlg, IDL_PARAMETERS, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szDump);

        /* re-init the hex/dec strings in preparation for next 8 words */
        *szDump = '\0';
      }
    }
  } //else
  //
  //dump any leftover hex/dec dump
  //
  if (lstrlen((LPSTR)szDump))
    SendDlgItemMessage(hDlg, IDL_PARAMETERS, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szDump);
  //
  //enable redraw to the listbox
  //
  SendDlgItemMessage(hDlg, IDL_PARAMETERS, WM_SETREDRAW, TRUE, 0L);
  //
  //redraw it
  //
  InvalidateRect(GetDlgItem(hDlg,IDL_PARAMETERS), NULL, TRUE);
  //
  //unlock the memory used for the parameters
  //
  GlobalUnlock(hMem);

  return (TRUE);

}

extern "C"
void GetMetaFileAndEnum(
    HWND hwnd,
    HDC hDC,
    int iAction);

/***********************************************************************

  FUNCTION   : PlayMetaFileToDest

  PARAMETERS : HWND hWnd
               int  nDest - DC to play metafile to
                 DESTDISPLAY - play to the display
                 DESTMETA    - play into another metafile

  PURPOSE    : begin the enumeration of the metafile to the user selected
               destination.  Perform the housekeeping needs appropriate
               to that destination.

  CALLS      : WINDOWS
                 GetClientRect
                 InvalidateRect
                 GetDC
                 SetMapMode
                 OpenFileDialog
                 MessageBox
                 CreateMetaFile
                 DeleteMetaFile
                 CloseMetaFile

               APP
                 WaitCursor
                 SetClipMetaExts
                 SetPlaceableExts
                 GetMetaFileAndEnum

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

************************************************************************/

BOOL PlayMetaFileToDest(
HWND hWnd,
int  nDest)
{
  HDC hDC;
  RECT rect;
  int iSaveRet;
  //
  //if the file opened contained a valid metafile
  //
  if (bValidFile)
  {
    //
    //init the record count
    //
    iRecNum = 0;
    //
    //if we are stepping the metafile then clear the client area
    //
    if (!bPlayItAll)
    {
      GetClientRect(hWnd, (LPRECT)&rect);
      InvalidateRect(hWnd, (LPRECT)&rect, TRUE);
    }

    switch (nDest)
    {
      //
      //playing metafile to the display
      //
      case DESTDISPLAY:
        WaitCursor(TRUE);
        hDC = GetDC(hWnd);

        if (!bUseGdiPlusToPlay)
        {
            //
            //metafile read in from a clipboard file
            //
            if ( bMetaInRam && !bPlaceableMeta && !bEnhMeta)
              SetClipMetaExts(hDC, lpMFP, lpOldMFP, WMFDISPLAY);
            //
            //Windows placeable metafile
            //
            if (bPlaceableMeta && !bEnhMeta)
                SetPlaceableExts(hDC, placeableWMFHeader, WMFDISPLAY);
            //
            //Windows metafile
            //
            if (!bMetaInRam && !bEnhMeta)
            {
                SetNonPlaceableExts(hDC, WMFDISPLAY);
            }
        }
        //
        //begin the enumeration of the metafile
        //

        DWORD start, end;
        DWORD renderTime;
        char tmpBuf[512];

        start = GetTickCount();

        GetMetaFileAndEnum(hWnd, hDC, ENUMMFSTEP);

        end = GetTickCount();
        renderTime = end - start;
        wsprintf(tmpBuf, "Time: %d", renderTime);

        SetWindowText(hWnd, tmpBuf);

        ReleaseDC(hWnd, hDC);
        WaitCursor(FALSE);
        break;

    case DESTMETA:
        //
        //get a name of a file to play the metafile into
        //
        iSaveRet = SaveFileDialog((LPSTR)SaveName, (LPSTR)gszSaveEMFFilter);
        //
        //if the file selected is this metafile then warn user
        //
        if (!lstrcmp((LPSTR)OpenName, (LPSTR)SaveName))
          MessageBox(hWnd, (LPSTR)"Cannot overwrite the opened metafile!",
                           (LPSTR)"Play to Metafile", MB_OK | MB_ICONEXCLAMATION);

        else
          //
          //the user didn't hit the cancel button
          //
          if (iSaveRet)
          {
            WaitCursor(TRUE);
            //
            //create a disk based metafile
            //
            hDC = (bEnhMeta) ? CreateEnhMetaFile(NULL, (LPSTR)SaveName, NULL, NULL)
                             : CreateMetaFile((LPSTR)SaveName);
            //
            //begin the enumeration of the metafile
            //
            GetMetaFileAndEnum(hWnd, hDC, ENUMMFSTEP);
            //
            //done playing so close the metafile and delete the handle
            //
            if (bEnhMeta)
              DeleteEnhMetaFile(CloseEnhMetaFile(hDC));
            else
              DeleteMetaFile(CloseMetaFile(hDC));

            WaitCursor(FALSE);
          }

        break;

    case DESTDIB:
        {
            /* extents for the display DC */
            GetClientRect(hWndMain, &rect);
            INT cx = rect.right - rect.left;
            INT cy = rect.bottom - rect.top;

    /*        SetMapMode(hDC, ((lpOldMFP != NULL) ? lpOldMFP->mm : lpMFP->mm));

            SetViewportOrgEx(hDC, 0, 0, &lpPT);
     */

            WaitCursor(TRUE);
            hDC = GetDC(hWnd);
            BITMAPINFOHEADER bmi;
            memset(&bmi, 0, sizeof(BITMAPINFOHEADER));
            bmi.biSize = sizeof(BITMAPINFOHEADER);
            bmi.biBitCount = 24;
            bmi.biWidth = cx;
            bmi.biHeight = -cy;
            bmi.biPlanes = 1;

            VOID* bits = NULL;

            HBITMAP hBmp = CreateDIBSection(hDC, (BITMAPINFO*) &bmi, 0, &bits, NULL, 0);
            HDC hDCBmp = CreateCompatibleDC(hDC);
            ::SelectObject(hDCBmp, hBmp);

            FillRect(hDCBmp, &rect, (HBRUSH) ::GetStockObject(GRAY_BRUSH));

            if (!bUseGdiPlusToPlay)
            {
                //
                //metafile read in from a clipboard file
                //
                if ( bMetaInRam && !bPlaceableMeta && !bEnhMeta)
                  SetClipMetaExts(hDCBmp, lpMFP, lpOldMFP, WMFDISPLAY);
                //
                //Windows placeable metafile
                //
                if (bPlaceableMeta && !bEnhMeta)
                    SetPlaceableExts(hDCBmp, placeableWMFHeader, WMFDISPLAY);
                //
                //Windows metafile
                //
                if (!bMetaInRam && !bEnhMeta)
                {
                    SetNonPlaceableExts(hDCBmp, WMFDISPLAY);
                }
            }
            //
            //begin the enumeration of the metafile
            //

            start = GetTickCount();

            GetMetaFileAndEnum(hWnd, hDCBmp, ENUMMFSTEP);


            end = GetTickCount();
            renderTime = end - start;
            wsprintf(tmpBuf, "Time: %d", renderTime);

            SetWindowText(hWnd, tmpBuf);
            StretchDIBits(hDC, 0, 0, cx, cy, 0, 0, cx, cy, bits, (BITMAPINFO*)&bmi, 0, SRCCOPY);
            DeleteDC(hDCBmp);
            DeleteObject((HGDIOBJ) hBmp);

            ReleaseDC(hWnd, hDC);
            WaitCursor(FALSE);
            break;

        }
    case DESTPRN:
{
    HDC hPr = (HDC)NULL;
    PRINTDLG pd;

    memset(&pd, 0, sizeof(PRINTDLG));
    pd.lStructSize = sizeof(PRINTDLG);
    pd.Flags = PD_RETURNDC;
    pd.hwndOwner = hWndMain;

    //
    //get a DC for the printer
    //

    if (PrintDlg(&pd) != 0)
        hPr= pd.hDC;
    else
        break;

    //
    //if a DC could not be created then report the error and return
    //

    if (!hPr)
    {
        WaitCursor(FALSE);
        wsprintf((LPSTR)str, "Cannot print %s", (LPSTR)fnameext);
        MessageBox(hWndMain, (LPSTR)str, NULL, MB_OK | MB_ICONHAND);
        break;
    }

    //
    //define the abort function
    //

    SetAbortProc(hPr, AbortProc);

    //
    //Initialize the members of a DOCINFO structure.
    //

    DOCINFO di;
    memset(&di, 0, sizeof(di));
    di.cbSize = sizeof(DOCINFO);
    di.lpszDocName = (bEnhMeta) ? "Print EMF" : "Print WMF";
    di.lpszOutput = (LPTSTR) NULL;

    //
    //Begin a print job by calling the StartDoc
    //function.
    //

    if (SP_ERROR == (StartDoc(hPr, &di)))
    {
        //if (Escape(hPr, STARTDOC, 4, "Metafile", (LPSTR) NULL) < 0)  {
        MessageBox(hWndMain, "Unable to start print job",
                   NULL, MB_OK | MB_ICONHAND);
        DeleteDC(hPr);
        break;
    }

    //
    //clear the abort flag
    //

    bAbort = FALSE;

    //
    //Create the Abort dialog box (modeless)
    //

    hAbortDlgWnd = CreateDialog((HINSTANCE)hInst, "AbortDlg", hWndMain, AbortDlg);

    //
    //if the dialog was not created report the error
    //

    if (!hAbortDlgWnd)
    {
        WaitCursor(FALSE);
        MessageBox(hWndMain, "NULL Abort window handle",
                   NULL, MB_OK | MB_ICONHAND);
        break;
    }

    //
    //show Abort dialog
    //

    ShowWindow (hAbortDlgWnd, SW_NORMAL);

    //
    //disable the main window to avoid reentrancy problems
    //

    EnableWindow(hWndMain, FALSE);
    WaitCursor(FALSE);

    //
    //if we are still committed to printing
    //
       if (!bUseGdiPlusToPlay)
        {
            //
            //if this is a placeable metafile then set its origins and extents
            //

            if (bPlaceableMeta)
                SetPlaceableExts(hPr, placeableWMFHeader, WMFPRINTER);

            //
            //if this is a metafile contained within a clipboard file then set
            //its origins and extents accordingly
            //

            if ( (bMetaInRam) && (!bPlaceableMeta) )
                SetClipMetaExts(hPr, lpMFP, lpOldMFP, WMFPRINTER);
        }

      //
      //if this is a "traditional" windows metafile
      //
      RECT rc;

      rc.left = 0;
      rc.top = 0;
      rc.right = GetDeviceCaps(hPr, HORZRES);
      rc.bottom = GetDeviceCaps(hPr, VERTRES);

      POINT lpPT;
      SIZE lpSize;
      if (TRUE || !bMetaInRam)
      {
          SetMapMode(hPr, MM_TEXT);
          SetViewportOrgEx(hPr, 0, 0, &lpPT);

          //
          //set the extents to the driver supplied values for horizontal
          //and vertical resolution
          //

          SetViewportExtEx(hPr, rc.right, rc.bottom, &lpSize );
      }

      //
      //play the metafile directly to the printer.
      //No enumeration involved here
      //

      GetMetaFileAndEnum(hWnd, hPr, ENUMMFSTEP);

    //
    //eject page and end the print job
    //
    Escape(hPr, NEWFRAME, 0, 0L, 0L);

    EndDoc(hPr);

    EnableWindow(hWndMain, TRUE);

    //
    //destroy the Abort dialog box
    //
    DestroyWindow(hAbortDlgWnd);

    DeleteDC(hPr);

}


    default:
        break;
    }
    //
    //if playing list records then free the memory used for the list of
    //selected records
    //
    if (bPlayList)
    {
      GlobalUnlock(hSelMem);
      GlobalFree(hSelMem);
      bPlayList = FALSE;
    }
    //
    //success
    //
    return (TRUE);
  }
  else
    //
    //not a valid metafile
    //
    return (FALSE);
}

/***********************************************************************

  FUNCTION   : RenderClipMeta

  PARAMETERS : CLIPFILEFORMAT   *ClipHeader
               int          fh

  PURPOSE    : read metafile bits, metafilepict and metafile header
               of the metafile contained within a clipboard file

  CALLS      : WINDOWS
                 GlobalAlloc
                 GlobalLock
                 GlobalUnlock
                 GlobalFree
                 MessageBox
                 _llseek
                 _lread
                 _lclose
                 SetMetaFileBits

  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc
               5/23/93 - ported to NT.  it must handle 3.1 clipboard
                         as well as NT clipboard files - drc

************************************************************************/

BOOL RenderClipMeta(LPVOID lpvClipHeader, int fh, WORD ClipID)
{
  int               wBytesRead;
  long              lBytesRead;
  long              lSize;
  DWORD             lOffset;
  DWORD             dwSizeOfMetaFilePict;
  BOOL              bEMF = FALSE;
  LPNTCLIPFILEFORMAT lpNTClp;
  LPCLIPFILEFORMAT    lpClp;
  //
  //cast the void ptr to the clipfile header appropriately
  //
  if (bEnhMeta)
  {
    lpNTClp = (LPNTCLIPFILEFORMAT)lpvClipHeader;
    bEMF = TRUE;
  }
  else
    lpClp = (LPCLIPFILEFORMAT)lpvClipHeader;
  //
  //obtain the appropriate size of the metafilepict. win16 vs win32
  //
  dwSizeOfMetaFilePict = (ClipID == CLP_ID) ?
              sizeof(OLDMETAFILEPICT) :
              sizeof(METAFILEPICT);
  //
  //free any memory already allocated for the METAFILEPICT
  //
  if (lpMFP != NULL || lpOldMFP != NULL)
  {
    GlobalFreePtr(lpMFP);
    lpMFP = NULL;
  }
  //
  //allocate enough memory to read the metafile bits into
  //
  if (!(lpMFBits = (char*)GlobalAllocPtr(GHND, ((bEMF) ? lpNTClp->DataLen
                                            : lpClp->DataLen - dwSizeOfMetaFilePict))))
    return(FALSE);
  //
  //offset to the metafile bits
  //
  lOffset = ((bEMF) ? lpNTClp->DataOffset : lpClp->DataOffset + dwSizeOfMetaFilePict );
  //
  //size of metafile bits
  //
  lSize = (long)( ((bEMF) ? lpNTClp->DataLen : lpClp->DataLen - dwSizeOfMetaFilePict));
  //
  //seek to the beginning of the metafile bits
  //
  _llseek(fh, lOffset, 0);
  //
  //read the metafile bits
  //
  lBytesRead = _hread(fh, lpMFBits, lSize);
  //
  //if unable to read the metafile bits bail out
  //
  if( lBytesRead == -1 || lBytesRead < lSize)
  {
    GlobalFreePtr(lpMFBits);
    MessageBox(hWndMain, "Unable to read metafile bits",
                     NULL, MB_OK | MB_ICONHAND);
    return(FALSE);
  }
  //
  //return to beginning to read metafile header
  //
  _llseek(fh, lOffset, 0);
  //
  //read the metafile header
  //
  if (!bEMF)
    wBytesRead = _lread(fh, (LPSTR)&mfHeader, sizeof(METAHEADER));
  else
    wBytesRead = _lread(fh, (LPSTR)&emfHeader, sizeof(ENHMETAHEADER));
  //
  //if unable to read the header return
  //
  if( wBytesRead == -1 || (WORD)wBytesRead < ((bEMF) ? sizeof(ENHMETAHEADER) : sizeof(METAHEADER)) )
  {
    MessageBox(hWndMain, "Unable to read metafile header",
                     NULL, MB_OK | MB_ICONHAND);
    return(FALSE);
  }
  //
  //set the metafile bits to the memory allocated for that purpose
  //
  if (bEMF)
    //
    //win32
    //
    hemf = SetEnhMetaFileBits(GlobalSizePtr(lpMFBits), (const unsigned char *)lpMFBits);
  else
    //
    //win16
    //
    hMF  = SetMetaFileBitsEx(GlobalSizePtr(lpMFBits), (const unsigned char *)lpMFBits);

  if ( NULL == ((bEMF) ? hemf : hMF))
  {
    MessageBox(hWndMain, "Unable to set metafile bits",
               NULL, MB_OK | MB_ICONHAND);

    return(FALSE);
  }
  //
  //allocate memory for the metafile pict structure
  //
  if (!(hMFP = GlobalAlloc(GHND, dwSizeOfMetaFilePict)))
  {
    MessageBox(hWndMain, "Unable allocate memory for metafile pict",
                     NULL, MB_OK | MB_ICONHAND);
    return(FALSE);
  }
  //
  //lock the memory
  //
  if (ClipID == CLP_ID)
    lpOldMFP = (LPOLDMETAFILEPICT)GlobalLock(hMFP);
  else
    lpMFP = (LPMETAFILEPICT)GlobalLock(hMFP);

  if (!lpMFP && !lpOldMFP)
    {
      MessageBox(hWndMain, "unable to lock metafile pict memory",
                     NULL, MB_OK | MB_ICONHAND);
      GlobalFree(hMFP);
      return(FALSE);
    }
  //
  //reposition to the start of the METAFILEPICT header.
  //
  _llseek(fh, ((bEMF) ? lpNTClp->DataOffset : lpClp->DataOffset), 0);
  //
  //read the metafile pict structure
  //
  wBytesRead = _lread(fh, ((ClipID == CLP_ID) ? (LPVOID)lpOldMFP : (LPVOID)lpMFP),
              dwSizeOfMetaFilePict);
  //
  //if unable to read, return
  //
  if( wBytesRead == -1 || wBytesRead < (long)dwSizeOfMetaFilePict)  {
    MessageBox(hWndMain, "Unable to read metafile pict",
             NULL, MB_OK | MB_ICONHAND);
    GlobalUnlock(hMFP);
    GlobalFree(hMFP);
    return(FALSE);
  }

  if (bEnhMeta)
    GetEMFCoolStuff();
//DENNIS - check this out....

  /* update metafile handle */
  if (ClipID == CLP_ID)
     lpOldMFP->hMF = (WORD)hMF;
  else
     lpMFP->hMF = (HMETAFILE)hemf;

  return(TRUE);
}

/***********************************************************************

  FUNCTION   : RenderPlaceableMeta

  PARAMETERS : int fh - filehandle to the placeable metafile

  PURPOSE    : read the metafile bits, metafile header and placeable
               metafile header of a placeable metafile.

  CALLS      : WINDOWS
                 GlobalAlloc
                 GlobalLock
                 Global
                 DeleteMetaFile
                 SetMetaFileBits
                 _llseek
                 _lread
                 _lclose
                 MessageBox


  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc
               7/1/93 - modified for win32 - denniscr

************************************************************************/

BOOL RenderPlaceableMeta(
int fh)
{
  int      wBytesRead;
  long     lBytesRead;
  DWORD    dwSize;
  //
  //if there is currently a metafile loaded, get rid of it
  //
  if (bMetaInRam && hMF && !bEnhMeta)
    DeleteMetaFile((HMETAFILE)hMF);
  //
  //seek to beginning of file and read placeable header
  //
  _llseek(fh, 0, 0);
  //
  //read the placeable header
  //
  wBytesRead = _lread(fh, (LPSTR)&placeableWMFHeader, sizeof(PLACEABLEWMFHEADER));
  //
  //if there is an error, return
  //
  if( wBytesRead == -1 || wBytesRead < sizeof(PLACEABLEWMFHEADER) )  {
    MessageBox(hWndMain, "Unable to read placeable header",
                     NULL, MB_OK | MB_ICONHAND);
    return(FALSE);
  }
  //
  //return to read metafile header
  //
  _llseek(fh, sizeof(placeableWMFHeader), 0);
  //
  //read the metafile header
  //
  wBytesRead = _lread(fh, (LPSTR)&mfHeader, sizeof(METAHEADER));
  //
  //if there is an error return
  //
  if( wBytesRead == -1 || wBytesRead < sizeof(METAHEADER) )  {
    MessageBox(hWndMain, "Unable to read metafile header",
                     NULL, MB_OK | MB_ICONHAND);
    return(FALSE);
  }
  //
  //allocate memory for the metafile bits
  //
  if (!(lpMFBits = (char *)GlobalAllocPtr(GHND, (mfHeader.mtSize * 2L))))
  {
    MessageBox(hWndMain, "Unable to allocate memory for metafile bits",
                     NULL, MB_OK | MB_ICONHAND);
    return(FALSE);
  }
  //
  //seek to the metafile bits
  //
  _llseek(fh, sizeof(placeableWMFHeader), 0);
  //
  //read metafile bits
  //
  lBytesRead = _hread(fh, lpMFBits, mfHeader.mtSize * 2);
  //
  //if there was an error
  //
  if( lBytesRead == -1 )
  {
     MessageBox(hWndMain, "Unable to read metafile bits",
                NULL, MB_OK | MB_ICONHAND);
     GlobalFreePtr(lpMFBits);
     return(FALSE);
  }
  //
  //set the metafile bits to the memory that we allocated
  //
  dwSize = GlobalSizePtr(lpMFBits);

  if (!(hMF = SetMetaFileBitsEx(dwSize, (const unsigned char *)lpMFBits)))
    return(FALSE);

  return(TRUE);
}

/***********************************************************************

  FUNCTION   : SetPlaceableExts

  PARAMETERS : HDC               hDC
               PLACEABLEWMFHEADER phdr
               int               nDest

  PURPOSE    : set the origins and extents on the DC to correspond with
               the origins and extents specified within the placeable
               metafile header

  CALLS      : WINDOWS
                 GetClientRect
                 SetMapMode
                 SetWindowOrg
                 SetWindowExt
                 SetViewportOrg
                 SetViewportExt

               C runtime
                 labs

  MESSAGES   : none

  RETURNS    : void

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

************************************************************************/

void SetPlaceableExts(HDC hDC, PLACEABLEWMFHEADER phdr, int nDest)
{
  RECT        rect;
  POINT       lpPT;
  SIZE        lpSize;

  /* if setting the extents on the display DC */
  if (nDest != WMFPRINTER)
    GetClientRect(hWndMain, &rect);

  SetMapMode(hDC, MM_ANISOTROPIC);

  /* set the windows origin to correspond to the bounding box origin
     contained in the placeable header */
  SetWindowOrgEx(hDC, phdr.bbox.left, phdr.bbox.top, &lpPT);

  /* set the window extents based on the abs value of the bbox coords */
  SetWindowExtEx(hDC,phdr.bbox.right -phdr.bbox.left,
           phdr.bbox.bottom -phdr.bbox.top,
           &lpSize);

  /* set the viewport origin and extents */
  if (nDest != WMFPRINTER)
    {
      SetViewportOrgEx(hDC, 0, 0, &lpPT);
      SetViewportExtEx(hDC, rect.right, rect.bottom, &lpSize);
    }
  else
    {
      SetViewportOrgEx(hPr, 0, 0, &lpPT);
      SetViewportExtEx(hPr,GetDeviceCaps(hPr, HORZRES),
             GetDeviceCaps(hPr, VERTRES),
             &lpSize);
    }
}

void SetNonPlaceableExts(HDC hDC, int nDest)
{
  RECT        rect;
  POINT       lpPT;
  SIZE        lpSize;

  /* if setting the extents on the display DC */
  if (nDest != WMFPRINTER)
    GetClientRect(hWndMain, &rect);

  SetMapMode(hDC, MM_ANISOTROPIC);

  /* set the viewport origin and extents */
  if (nDest != WMFPRINTER)
    {
      SetViewportOrgEx(hDC, 0, 0, &lpPT);
      SetViewportExtEx(hDC, rect.right, rect.bottom, &lpSize);
    }
  else
    {
      SetViewportOrgEx(hPr, 0, 0, &lpPT);
      SetViewportExtEx(hPr,GetDeviceCaps(hPr, HORZRES),
             GetDeviceCaps(hPr, VERTRES),
             &lpSize);
    }
}


/***********************************************************************

  FUNCTION   : SetClipMetaExts

  PARAMETERS : HDC          hDC
               METAFILEPICT MFP
               int          nDest

  PURPOSE    : set the extents to the client rect for clipboard metafiles

  CALLS      : WINDOWS
                 GetClientRect
                 IntersectClipRect
                 SetMapMode
                 SetViewportOrg
                 SetViewportExt
                 SetWindowExt

  MESSAGES   : none

  RETURNS    : void

  COMMENTS   : this is not as robust as it could be.  A more complete
               approach might be something like Petzold discusses in
               his Programming Windows book on page 793 in the
               function PrepareMetaFile().

  HISTORY    : 1/16/91 - created - drc

************************************************************************/

void SetClipMetaExts(
HDC       hDC,
LPMETAFILEPICT    lpMFP,
LPOLDMETAFILEPICT lpOldMFP,
int       nDest)
{
  int   cx, cy;
  RECT  rect;
  POINT lpPT;
  SIZE  lpSize;
  long  lmm;
  long  lxExt;
  long  lyExt;

  /* extents for the display DC */
  if (nDest != WMFPRINTER)
    {
      GetClientRect(hWndMain, &rect);
      cx = rect.right - rect.left;
      cy = rect.bottom - rect.top;
      IntersectClipRect(hDC, rect.left, rect.top, rect.right, rect.bottom);
    }

  SetMapMode(hDC, ((lpOldMFP != NULL) ? lpOldMFP->mm : lpMFP->mm));

  /* set physical origin to 0, 0 */
  SetViewportOrgEx(hDC, 0, 0, &lpPT);

  /* given the mapping mode specified in the metafilepict */
  lmm = (lpOldMFP != NULL) ? lpOldMFP->mm : lpMFP->mm;
  lxExt = (lpOldMFP != NULL) ? lpOldMFP->xExt : lpMFP->xExt;
  lyExt = (lpOldMFP != NULL) ? lpOldMFP->yExt : lpMFP->yExt;

  switch (lmm)  {
    case MM_ISOTROPIC:
      if (lxExt && lyExt)
    SetWindowExtEx(hDC, lxExt, lyExt, &lpSize);

        /* fall through */

    case MM_ANISOTROPIC:
      if (nDest != WMFPRINTER)
    SetViewportExtEx(hDC, cx, cy, &lpSize);
      else
    SetViewportExtEx(hDC, GetDeviceCaps(hDC, HORZRES),
                GetDeviceCaps(hDC, VERTRES), &lpSize );
    break;

    default:
      break;
  }

}

/***********************************************************************

  FUNCTION   : ProcessFile

  PARAMETERS : HWND  hWnd
               LPSTR lpFileName

  PURPOSE    : open the metafile, determine if it contains a valid
               metafile, decide what type of metafile it is (wmf,
               clipboard, or placeable) and take care of some menu
               housekeeping tasks.

  CALLS      :

  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc

************************************************************************/

BOOL ProcessFile(
HWND  hWnd,
LPSTR lpFileName)
{
  //
  //for openfiledialog
  //
  char drive[3];
  char dir[MAX_PATH+1];
  char fname[MAX_PATH+1];
  char ext[5];

  char * pchCorrectSir;
  //
  //initialize these global handles to metafiles
  //
  if (hMF && !bMetaInRam)
  {
    DeleteMetaFile((HMETAFILE)hMF);
    hMF = NULL;
  }
  if (hemf && !bMetaInRam)
  {
    DeleteEnhMetaFile(hemf);
    hemf = NULL;
  }

  if (lpMFBits)
  {
    GlobalFreePtr(lpMFBits);
    lpMFBits = NULL;
    hemf = NULL;
    hMF = NULL;
  }

  bEnhMeta = FALSE;
  //
  //split the fully qualified filename into its components
  //
  SplitPath( lpFileName, (LPSTR)drive,
          (LPSTR)dir, (LPSTR)fname, (LPSTR)ext);

  pchCorrectSir = _strupr( _strdup( ext ) );
  //
  //if the memory for the emf header, desc string and palette
  //is still around then nuke it
  //
  if (EmfPtr.lpEMFHdr)
  {
    GlobalFreePtr(EmfPtr.lpEMFHdr);
    EmfPtr.lpEMFHdr = NULL ;
  }
  if (EmfPtr.lpDescStr)
  {
    GlobalFreePtr(EmfPtr.lpDescStr);
    EmfPtr.lpDescStr = NULL ;
  }
  if (EmfPtr.lpPal)
  {
    GlobalFreePtr(EmfPtr.lpPal);
    EmfPtr.lpPal = NULL ;
  }
  //
  //if the file is an enhanced metafile
  //
  if (lstrcmp((LPSTR)pchCorrectSir, (LPSTR)"CLP") == 0)
    return ProcessCLP(hWnd, lpFileName);
  //
  //if the file is a Windows metafile or a Windows or placeable metafile
  //as per the normal naming conventions
  //
  if (lstrcmp((LPSTR)pchCorrectSir, (LPSTR)"WMF") == 0)
    return ProcessWMF(hWnd, lpFileName);
  //
  //if the file is a clipboard file
  //
  if (lstrcmp((LPSTR)pchCorrectSir, (LPSTR)"EMF") == 0)
    return ProcessEMF(hWnd, lpFileName);

  return FALSE;
}

/***********************************************************************

  FUNCTION   : ProcessWMF

  PARAMETERS : HWND  hWnd
               LPSTR lpFileName

  PURPOSE    : open the metafile and determine if it is a Windows metafile or
               placeable metafile.  Then take care of some menu housekeeping
               tasks.

  CALLS      :

  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 6/23/93 - created - drc

************************************************************************/

BOOL ProcessWMF(HWND hWnd, LPSTR lpFileName)
{
  int        fh;
  int        wBytesRead;
  DWORD      dwIsPlaceable;
  char       szCaption[144];

  /* for openfiledialog */
  char drive[3];
  char dir[MAX_PATH+1];
  char fname[MAX_PATH+1];
  char ext[5];
  char * pchCorrectSir;
    //
    //split the fully qualified filename into its components
    //
    SplitPath( lpFileName, (LPSTR)drive,
            (LPSTR)dir, (LPSTR)fname, (LPSTR)ext);

    pchCorrectSir = _strupr( _strdup( ext ) );
    //
    //try to open the file.  It's existence has already been
    //checked by OpenFileDialog
    //
    fh = _lopen(lpFileName, OF_READ);
    //
    //if opened successfully
    //
    if (fh != -1)
    {
      //
      //always disable the clipboard and EMF header menu if we get here
      //
      EnableMenuItem(GetMenu(hWnd), IDM_CLIPHDR, MF_DISABLED | MF_GRAYED);
      EnableMenuItem(GetMenu(hWnd), IDM_ENHHEADER, MF_DISABLED | MF_GRAYED);
      //
      // read the first dword of the file to see if it is a placeable wmf
      //
      wBytesRead = _lread(fh,(LPSTR)&dwIsPlaceable, sizeof(dwIsPlaceable));

      if (wBytesRead == -1 || wBytesRead < sizeof(dwIsPlaceable))
      {
        _lclose(fh);
        MessageBox(hWndMain, "unable to read file", NULL,
                   MB_OK | MB_ICONEXCLAMATION);
        return (FALSE);

      }
      //
      // if this is windows metafile, not a placeable wmf
      //
      if (dwIsPlaceable != PLACEABLEKEY)
      {
        //  if (!bMetaInRam)
        hMF = GetMetaFile((LPSTR)OpenName);
        //
        //disable placeable header menu item
        //
        EnableMenuItem(GetMenu(hWnd), IDM_PLACEABLEHDR, MF_DISABLED|MF_GRAYED);
        //
        //seek to the beginning of the file
        //
        _llseek(fh, 0, 0);
        //
        //read the wmf header
        //
        wBytesRead = _lread(fh, (LPSTR)&mfHeader, sizeof(METAHEADER));
        //
        //done with file so close it
        //
        _lclose(fh);
        //
        //if read failed
        //
        if (wBytesRead == -1 || wBytesRead < sizeof(dwIsPlaceable))
        {
          MessageBox(hWndMain, "unable to read metafile header", NULL,
                     MB_OK | MB_ICONEXCLAMATION);
          return (FALSE);
        }
      }
      //
      //this is a placeable metafile
      //
      else
      {
        //
        //enable the placeable header menu item
        //
        EnableMenuItem(GetMenu(hWnd), IDM_PLACEABLEHDR, MF_ENABLED);
        //
        //convert the placeable format into something that can
        //be used with GDI metafile functions
        //
        RenderPlaceableMeta(fh);
        //
        //close the file
        //
        _lclose(fh);

      }
      //
      //at this point we have a metafile header regardless of whether
      //the metafile was a windows metafile or a placeable metafile
      //so check to see if it is valid.  There is really no good
      //way to do this so just make sure that the mtType is either
      //1 or 2 (memory or disk file)
      //
      if ( (mfHeader.mtType != 1) && (mfHeader.mtType != 2) )
      {
        //
        //set the program flags appropriately
        //
        bBadFile = TRUE;
        bMetaFileOpen = FALSE;
        bValidFile = FALSE;
        //
        //let the user know that this is an invalid metafile
        //
        MessageBox(hWndMain, "This file is not a valid metafile",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        //
        //restore the caption text to the default
        //
        SetWindowText(hWnd, (LPSTR)APPNAME);
        //
        //disable menu items, indicating that a valid metafile has not been
        //loaded
        //
        EnableMenuItem(GetMenu(hWnd), IDM_VIEW, MF_DISABLED|MF_GRAYED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PLAY, MF_DISABLED|MF_GRAYED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINT, MF_DISABLED|MF_GRAYED);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINTDLG, MF_DISABLED|MF_GRAYED);
        EnableMenuItem(GetMenu(hWnd), IDM_SAVEAS, MF_DISABLED|MF_GRAYED);
        //
        //refresh the menu bar to reflect above changes
        //
        DrawMenuBar(hWnd);
      }
      //
      //this is a valid metafile...at least based on the above criteria
      //
      else
      {
        //
        //modify and update the caption text
        //
        wsprintf((LPSTR)szCaption, (LPSTR)"%s - %s.%s",
                 (LPSTR)APPNAME, (LPSTR)fname, (LPSTR)ext);
        //
        //this could be used by the printing routines if unable to print
        //
        wsprintf((LPSTR)fnameext, (LPSTR)"%s.%s", (LPSTR)fname, (LPSTR)ext);

        SetWindowText(hWnd, (LPSTR)szCaption);
        //
        //enable the appropriate menu items
        //
        EnableMenuItem(GetMenu(hWnd), IDM_VIEW, MF_ENABLED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PLAY, MF_ENABLED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINT, MF_ENABLED);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINTDLG, MF_ENABLED);
        EnableMenuItem(GetMenu(hWnd), IDM_SAVEAS, MF_ENABLED);
        EnableMenuItem(GetMenu(hWnd), IDM_HEADER, MF_ENABLED);
        //
        //refresh the menu bar to reflect above changes
        //
        DrawMenuBar(hWnd);
        //
        //set global flags appropriately
        //
        bValidFile = TRUE;
        bMetaFileOpen = TRUE;

        if (dwIsPlaceable != PLACEABLEKEY)
        {
          bPlaceableMeta = FALSE;
          bMetaInRam = FALSE;
        }
        else
        {
          bPlaceableMeta = TRUE;
          bMetaInRam = TRUE;
        }
      }
      return (TRUE);

    } //if fh != -1
    else
      return (FALSE);
}

/***********************************************************************

  FUNCTION   : ProcessCLP

  PARAMETERS : HWND  hWnd
               LPSTR lpFileName

  PURPOSE    : open the metafile contained in the clipboard file and
               take care of some menu housekeeping tasks.

  CALLS      :

  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 6/23/93 - created - drc

************************************************************************/


BOOL ProcessCLP(HWND hWnd, LPSTR lpFileName)
{
  WORD             i;
  int              fh;
  DWORD            HeaderPos;
  DWORD            nSizeOfClipHeader;
  DWORD            nSizeOfClipFormat;
  NTCLIPFILEHEADER NTFileHeader;
  NTCLIPFILEFORMAT NTClipHeader;
  CLIPFILEHEADER   FileHeader;
  CLIPFILEFORMAT   ClipHeader;
  char             szCaption[144];
  WORD             wFileID;
  BOOL             bMetaFound = FALSE;
  LPVOID           lpvAddressOfHdr;

  /* for openfiledialog */
  char drive[3];
  char dir[MAX_PATH+1];
  char fname[MAX_PATH+1];
  char ext[5];
  char * pchCorrectSir;
    //
    //split the fully qualified filename into its components
    //
    SplitPath( lpFileName, (LPSTR)drive,
            (LPSTR)dir, (LPSTR)fname, (LPSTR)ext);

    pchCorrectSir = _strupr( _strdup( ext ) );
    //
    //try to open the file.  It's existence has already been
    //checked by OpenFileDialog
    fh = _lopen(lpFileName, OF_READ);
    //
    //if opened successfully
    if (fh != -1 )
    {
      //
      // read the clipboard fileidentifier
      //
      wFileID = 0;
      _lread(fh, (LPSTR)&wFileID, sizeof(WORD));
      _llseek(fh, 0, 0);
      //
      //if this is not a valid clipboard file based on the file
      //identifier of the file header
      //
      if (wFileID != CLP_ID && wFileID != CLP_NT_ID && wFileID != CLPBK_NT_ID)
      {

        _lclose(fh);
        MessageBox(hWndMain, "This file is not a valid clipboard file",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        return (FALSE);
      }
      switch (wFileID)
      {
        case CLP_ID:
            _lread(fh, (LPSTR)&FileHeader, sizeof(CLIPFILEHEADER));
            nSizeOfClipHeader = sizeof(CLIPFILEHEADER);
            nSizeOfClipFormat = sizeof(CLIPFILEFORMAT);
            HeaderPos = nSizeOfClipHeader;
          break;

        case CLP_NT_ID:
        case CLPBK_NT_ID:
            NTFileHeader.FormatCount = 0;
            _lread(fh, (LPSTR)&NTFileHeader, sizeof(NTCLIPFILEHEADER));
            nSizeOfClipHeader = sizeof(NTCLIPFILEHEADER);
            nSizeOfClipFormat = sizeof(NTCLIPFILEFORMAT);
            HeaderPos = nSizeOfClipHeader;
          break;

        default:
          break;
      }
      //
      //search the formats contained within the clipboard file looking
      //for a metafile.  Break if and when it is found
      //
      for (i=0;
           i < ((wFileID == CLP_ID) ? FileHeader.FormatCount : NTFileHeader.FormatCount);
           i++)
      {

        _llseek(fh, HeaderPos, 0);
        //
        //read the clipboard header found at current position
        //
        lpvAddressOfHdr = (wFileID == CLP_ID) ? (LPVOID)&ClipHeader : (LPVOID)&NTClipHeader;

        if(_lread(fh, (LPSTR)lpvAddressOfHdr, nSizeOfClipFormat) < nSizeOfClipFormat)
        //if(_lread(fh, (LPSTR)&ClipHeader, nSizeOfClipHeader) < nSizeOfClipHeader)
        {
          _lclose(fh);
          MessageBox(hWndMain, "read of clipboard header failed",
                       NULL, MB_OK | MB_ICONEXCLAMATION);
          return (FALSE);
        }
        //
        //increment the file offset to data
        //
        HeaderPos += nSizeOfClipFormat;
        //
        //if a metafile was found break...
        //this break assumes that CF_METAFILEPICT formats are always written before CF_ENHMETAFILE
        //formats.
        //
        if (wFileID == CLP_ID && ClipHeader.FormatID == CF_METAFILEPICT)
        {
          bMetaFound = TRUE;
          break;
        }

        if (wFileID == CLP_NT_ID || wFileID == CLPBK_NT_ID)
        {
          if (NTClipHeader.FormatID == CF_ENHMETAFILE)
//          HeaderPos += NTClipHeader.DataLen;
          //else
          {
            bMetaFound = TRUE;
            break;
          }
        }

      }  //for i < formatcount

      if (bMetaFound)
      {
        //
        //if there is currently a metafile loaded delete it.
        //
        if (wFileID == CLP_ID)
        {
          if ((bMetaInRam) && (hMF))
          {
            DeleteMetaFile((HMETAFILE)hMF);
            hMF = NULL;
          }
        }
        else
        {
          if ((bMetaInRam) && (hemf))
          {
            DeleteEnhMetaFile(hemf);
            hemf = NULL;
          }
        }

        //
        //modify and update the caption text
        //
        wsprintf((LPSTR)szCaption, (LPSTR)"%s - %s.%s",
                   (LPSTR)APPNAME, (LPSTR)fname, (LPSTR)ext);
        //
        //this could be used by the printing routines if unable to print
        //
        wsprintf((LPSTR)fnameext, (LPSTR)"%s.%s", (LPSTR)fname, (LPSTR)ext);

        SetWindowText(hWnd, (LPSTR)szCaption);
        //
        //enable the appropriate menu items
        //
        if (wFileID == CLP_ID)
        {
          EnableMenuItem(GetMenu(hWnd), IDM_ENHHEADER, MF_DISABLED | MF_GRAYED);
          EnableMenuItem(GetMenu(hWnd), IDM_HEADER, MF_ENABLED);
        }
        else
        {
          EnableMenuItem(GetMenu(hWnd), IDM_ENHHEADER, MF_ENABLED);
          EnableMenuItem(GetMenu(hWnd), IDM_HEADER, MF_DISABLED | MF_GRAYED);
        }

        EnableMenuItem(GetMenu(hWnd), IDM_PLACEABLEHDR, MF_DISABLED|MF_GRAYED);
        EnableMenuItem(GetMenu(hWnd), IDM_CLIPHDR, MF_ENABLED);
        EnableMenuItem(GetMenu(hWnd), IDM_VIEW, MF_ENABLED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PLAY, MF_ENABLED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINT, MF_ENABLED);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINTDLG, MF_ENABLED);
        EnableMenuItem(GetMenu(hWnd), IDM_SAVEAS, MF_ENABLED);
        //
        //refresh the menu bar
        //
        DrawMenuBar(hWnd);
        //
        //set the program flags appropriately
        //
        bValidFile = TRUE;
        bMetaFileOpen = TRUE;
        bMetaInRam = TRUE;
        bPlaceableMeta = FALSE;
        bEnhMeta = (wFileID == CLP_ID) ? FALSE : TRUE;
        //
        //convert the metafile contained within the clipboard file into
        //a format useable with GDI metafile functions
        //
        if (!RenderClipMeta(((wFileID == CLP_ID)? (LPVOID)&ClipHeader : (LPVOID)&NTClipHeader),
                              fh,
                              FileHeader.FileIdentifier))

          MessageBox(hWndMain, "Unable to render format",
                       NULL, MB_OK | MB_ICONEXCLAMATION);
        _lclose(fh);

      }
      //
      //a metafile was not found within the clipboard file
      //
      else
      {
        bBadFile = TRUE;
        bMetaFileOpen = FALSE;
        bValidFile = FALSE;
        bEnhMeta = FALSE;
        //
        //let the user know
        //
        MessageBox(hWndMain, "This CLP file doesn't contain a valid metafile",
                     NULL, MB_OK | MB_ICONEXCLAMATION);
        //
        //restore the caption text to default
        //
        SetWindowText(hWnd, (LPSTR)APPNAME);
        //
        //disable previously enabled menu items
        //
        EnableMenuItem(GetMenu(hWnd), IDM_VIEW, MF_DISABLED|MF_GRAYED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PLAY, MF_DISABLED|MF_GRAYED|MF_BYPOSITION);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINT, MF_DISABLED|MF_GRAYED);
        EnableMenuItem(GetMenu(hWnd), IDM_PRINTDLG, MF_DISABLED|MF_GRAYED);
        EnableMenuItem(GetMenu(hWnd), IDM_SAVEAS, MF_DISABLED|MF_GRAYED);
        //
        //refresh the menu bar to reflect these changes
        //
        DrawMenuBar(hWnd);
        _lclose(fh);
      }
      return (TRUE);
    }
    else
      return (FALSE);
}

/***********************************************************************

  FUNCTION   : ProcessEMF

  PARAMETERS : HWND  hWnd
               LPSTR lpFileName

  PURPOSE    : open the metafile contained in the clipboard file and
               take care of some menu housekeeping tasks.

  CALLS      :

  MESSAGES   : none

  RETURNS    : BOOL

  COMMENTS   :

  HISTORY    : 6/23/93 - created - drc

************************************************************************/


BOOL ProcessEMF(HWND hWnd, LPSTR lpFileName)
{
  char           szCaption[144];

  /* for openfiledialog */
  char drive[3];
  char dir[MAX_PATH+1];
  char fname[MAX_PATH+1];
  char ext[5];
  char * pchCorrectSir;

  bEnhMeta = FALSE;
    //
    //split the fully qualified filename into its components
    //
    SplitPath( lpFileName, (LPSTR)drive,
            (LPSTR)dir, (LPSTR)fname, (LPSTR)ext);

    pchCorrectSir = _strupr( _strdup( ext ) );
    //
    //always disable the clipboard, WMF and Placeable header menu if we get here
    //
    EnableMenuItem(GetMenu(hWnd), IDM_CLIPHDR, MF_DISABLED | MF_GRAYED);
    EnableMenuItem(GetMenu(hWnd), IDM_HEADER, MF_DISABLED | MF_GRAYED);
    EnableMenuItem(GetMenu(hWnd), IDM_PLACEABLEHDR, MF_DISABLED|MF_GRAYED);
    //
    //if emf was successfully opened
    //
    if (!hemf)
      hemf = GetEnhMetaFile(lpFileName);

    if (hemf)
    {
      GetEMFCoolStuff();
      //
      //modify and update the caption text
      //
      wsprintf((LPSTR)szCaption, (LPSTR)"%s - %s.%s",
                 (LPSTR)APPNAME, (LPSTR)fname, (LPSTR)ext);
      //
      //this could be used by the printing routines if unable to print
      //
      wsprintf((LPSTR)fnameext, (LPSTR)"%s.%s", (LPSTR)fname, (LPSTR)ext);

      SetWindowText(hWnd, (LPSTR)szCaption);
      //
      //enable the appropriate menu items
      //
      EnableMenuItem(GetMenu(hWnd), IDM_ENHHEADER, MF_ENABLED);
      EnableMenuItem(GetMenu(hWnd), IDM_VIEW, MF_ENABLED|MF_BYPOSITION);
      EnableMenuItem(GetMenu(hWnd), IDM_PLAY, MF_ENABLED|MF_BYPOSITION);
      EnableMenuItem(GetMenu(hWnd), IDM_PRINT, MF_ENABLED);
      EnableMenuItem(GetMenu(hWnd), IDM_PRINTDLG, MF_ENABLED);
      EnableMenuItem(GetMenu(hWnd), IDM_SAVEAS, MF_ENABLED);
      //
      //refresh the menu bar
      //
      DrawMenuBar(hWnd);
      //
      //set the program flags appropriately
      //
      bValidFile = TRUE;
      bMetaFileOpen = TRUE;
      bEnhMeta = TRUE;
      bMetaInRam = FALSE;
      bPlaceableMeta = FALSE;

    }
//    DeleteEnhMetaFile(hemf);
    else
    {
      bEnhMeta = FALSE;
      bValidFile = FALSE;
      bBadFile = TRUE;
      bMetaFileOpen = FALSE;
      //
      //let the user know
      //
      MessageBox(hWndMain, "This EMF file doesn't contain a valid metafile",
                     NULL, MB_OK | MB_ICONEXCLAMATION);
      //
      //restore the caption text to default
      //
      SetWindowText(hWnd, (LPSTR)APPNAME);
      //
      //disable previously enabled menu items
      //
      EnableMenuItem(GetMenu(hWnd), IDM_VIEW, MF_DISABLED|MF_GRAYED|MF_BYPOSITION);
      EnableMenuItem(GetMenu(hWnd), IDM_PLAY, MF_DISABLED|MF_GRAYED|MF_BYPOSITION);
      EnableMenuItem(GetMenu(hWnd), IDM_PRINT, MF_DISABLED|MF_GRAYED);
      EnableMenuItem(GetMenu(hWnd), IDM_PRINTDLG, MF_DISABLED|MF_GRAYED);
      EnableMenuItem(GetMenu(hWnd), IDM_SAVEAS, MF_DISABLED|MF_GRAYED);
      //
      //refresh the menu bar to reflect these changes
      //
      DrawMenuBar(hWnd);
    }

    return TRUE;
}

/***********************************************************************

  FUNCTION   : GetEMFCoolStuff

  PARAMETERS :

  PURPOSE    :

  CALLS      :

  MESSAGES   :

  RETURNS    :

  COMMENTS   :

  HISTORY    : created 7/8/93 - denniscr

************************************************************************/
BOOL GetEMFCoolStuff()
{
    //
    //init these ptrs
    //
    EmfPtr.lpEMFHdr  = NULL;
    EmfPtr.lpDescStr = NULL;
    EmfPtr.lpPal     = NULL;

    if (hemf)
    {
      //
      //obtain the sizes of the emf header, description string and palette
      //
      UINT uiHdrSize = GetEnhMetaFileHeader(hemf, 0, NULL);
      UINT uiDescStrSize = GetEnhMetaFileDescription(hemf, 0, NULL);
      UINT uiPalEntries = GetEnhMetaFilePaletteEntries(hemf, 0, NULL);
      //
      //if these are lengths > 0 then allocate memory to store them
      //
      if (uiHdrSize)
        EmfPtr.lpEMFHdr = (LPENHMETAHEADER)GlobalAllocPtr(GHND, uiHdrSize);
      if (uiDescStrSize)
        EmfPtr.lpDescStr = (LPTSTR)GlobalAllocPtr(GHND, uiDescStrSize);
      if (uiPalEntries)
        EmfPtr.lpPal = (LPPALETTEENTRY)GlobalAllocPtr(GHND, uiPalEntries * sizeof(PALETTEENTRY));
      //
      //so far the emf seems to be valid so continue
      //
      if (uiHdrSize)
      {
        //
        //get the actual emf header and description string
        //
        if (!GetEnhMetaFileHeader(hemf, uiHdrSize, EmfPtr.lpEMFHdr))
        {
          MessageBox(hWndMain, "unable to read enhanced metafile header", NULL,
                   MB_OK | MB_ICONEXCLAMATION);
          bValidFile = FALSE;
          return (FALSE);
        }
        else
        {
          //
          //get the description string if it exists
          //
          if (uiDescStrSize)
            GetEnhMetaFileDescription(hemf, uiDescStrSize, EmfPtr.lpDescStr);
          //
          //get the palette if it exists
          //
          if (uiPalEntries)
          {
            GetEnhMetaFilePaletteEntries(hemf, uiPalEntries, EmfPtr.lpPal);
            EmfPtr.palNumEntries = (WORD)uiPalEntries;
          }
        }
      }
   }
   return (TRUE);
}

float NormalizeAngle (double angle)
{
    if (angle >= 0)
    {
        while (angle >= 360)
        {
            angle -= 360;
        }
    }
    else
    {
        while (angle < 0)
        {
            angle += 360;
        }
    }
    return static_cast<float>(angle);
}

#define PI                  3.1415926535897932384626433832795
#define RADIANS_TO_DEGREES  (180.0 / PI)

float PointToAngle(float x, float y, float w, float h, float xVector, float yVector)
{
    BOOL        bScale = TRUE;

    if (w == h)
    {
        if (w == 0)
        {
            return 0;
        }
        bScale = FALSE;
    }

    float horRadius = w / 2;
    float verRadius = h / 2;
    float xOrigin = x + horRadius;
    float yOrigin = y + verRadius;

    if (horRadius == 0)
    {
        double  dAngle = asin(((double)(yVector - yOrigin)) / verRadius);

        if (xOrigin > xVector)
        {
            dAngle = PI - dAngle;
        }
        return NormalizeAngle(dAngle * RADIANS_TO_DEGREES);
    }
    else if (verRadius == 0)
    {
        double dAngle = acos(((double)(xVector - xOrigin)) / horRadius);

        if (yOrigin > yVector)
        {
            dAngle = -dAngle;
        }
        return NormalizeAngle(dAngle * RADIANS_TO_DEGREES);
    }

    if (yOrigin == yVector)
    {
        return static_cast<float>((xOrigin <= xVector) ? 0 : 180);
    }

    if (xOrigin == xVector)
    {
        return static_cast<float>((yOrigin < yVector) ? 90 : 270);;
    }

    if (bScale)
    {
        xVector = (float)(xOrigin + ((xVector - xOrigin) * ((double)verRadius / horRadius)));
    }

    return NormalizeAngle(atan2(yVector - yOrigin, xVector - xOrigin) * RADIANS_TO_DEGREES);
}

#define HS_DDI_MAX      6

typedef struct {
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[2];
} HATCHBRUSHINFO;

HATCHBRUSHINFO  hatchBrushInfo = {
    { sizeof(BITMAPINFOHEADER), 8, 8, 1, 1, BI_RGB, 32, 0, 0, 2, 0 },
    { { 255, 255, 255, 0 }, { 0, 0, 0, 0 } }
};

ULONG HatchPatterns[HS_DDI_MAX][8] = {

// Scans have to be DWORD aligned:

    { 0x00,                // ........     HS_HORIZONTAL 0
      0x00,                // ........
      0x00,                // ........
      0xff,                // ********
      0x00,                // ........
      0x00,                // ........
      0x00,                // ........
      0x00 },              // ........

    { 0x08,                // ....*...     HS_VERTICAL 1
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08 },              // ....*...

    { 0x80,                // *.......     HS_FDIAGONAL 2
      0x40,                // .*......
      0x20,                // ..*.....
      0x10,                // ...*....
      0x08,                // ....*...
      0x04,                // .....*..
      0x02,                // ......*.
      0x01 },              // .......*

    { 0x01,                // .......*     HS_BDIAGONAL 3
      0x02,                // ......*.
      0x04,                // .....*..
      0x08,                // ....*...
      0x10,                // ...*....
      0x20,                // ..*.....
      0x40,                // .*......
      0x80 },              // *.......

    { 0x08,                // ....*...     HS_CROSS 4
      0x08,                // ....*...
      0x08,                // ....*...
      0xff,                // ********
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08 },              // ....*...

    { 0x81,                // *......*     HS_DIAGCROSS 5
      0x42,                // .*....*.
      0x24,                // ..*..*..
      0x18,                // ...**...
      0x18,                // ...**...
      0x24,                // ..*..*..
      0x42,                // .*....*.
      0x81 }               // *......*
};

/***********************************************************************

  FUNCTION   : EnhMetaFileEnumProc

  PARAMETERS : HDC           hDC
               LPHANDLETABLE lpHTable
               LPMETARECORD  lpMFR
               int           nObj
               LPARAM        lpData


  PURPOSE    : callback for EnumEnhMetaFile.

  CALLS      : EnumMFIndirect()

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   :

  HISTORY    : created 6/30/93 - denniscr

************************************************************************/
int CALLBACK EnhMetaFileEnumProc(HDC hDC, LPHANDLETABLE lpHTable,
                                 LPENHMETARECORD lpEMFR, int nObj, LPARAM lpData)
{
  return EnumMFIndirect(hDC, lpHTable, NULL, lpEMFR, nObj, lpData);
}

void GetPixelSize (Gdiplus::Graphics * g, float * cx, float * cy)
{
    Gdiplus::PointF     points[2];

    points[0].X = points[0].Y = 0;
    points[1].X = points[1].Y = 1;

    g->TransformPoints(Gdiplus::CoordinateSpaceWorld, Gdiplus::CoordinateSpaceDevice, points, 2);

    *cx = points[1].X - points[0].X;
    *cy = points[1].Y - points[0].Y;
}

void GpPlayEnhMetaFileRecord(HDC hDC, LPHANDLETABLE lpHTable,
                            LPENHMETARECORD lpEMFR,
                            UINT nObj, LPARAM lpData)
{
if (!lpData) return;

    MYDATA *  myData = (MYDATA *)lpData;
    Gdiplus::Graphics * g = myData->g;

    myData->recordNum++;

    XFORM xForm;
    GetWorldTransform(hDC, &xForm);

    INT mapMode = GetMapMode(hDC);

    POINT org;
    SIZE size;
    GetViewportOrgEx(hDC, &org);
    GetViewportExtEx(hDC, &size);
    GetWindowOrgEx(hDC, &org);
    GetWindowExtEx(hDC, &size);

    switch (lpEMFR->iType)
    {
    case EMR_HEADER:
        {
            PENHMETAHEADER     pHeader = (PENHMETAHEADER)lpEMFR;
            RECT               clientRect;

            myData->recordNum = 1;
            myData->pObjects = new MYOBJECTS[pHeader->nHandles];
            myData->numObjects = pHeader->nHandles;
            GetClientRect(myData->hwnd, &clientRect);
            int         clientWidth  = clientRect.right - clientRect.left;
            int         clientHeight = clientRect.bottom - clientRect.top;
            myData->windowExtent.cx   = clientWidth;
            myData->windowExtent.cy   = clientHeight;
            myData->viewportExtent.cx = clientWidth;
            myData->viewportExtent.cy = clientHeight;
            float       dstX      = TOREAL(clientRect.left);
            float       dstY      = TOREAL(clientRect.top);
            float       dstWidth  = TOREAL(clientWidth);
            float       dstHeight = TOREAL(clientHeight);
            float       srcWidth  = TOREAL(pHeader->rclFrame.right -  pHeader->rclFrame.left);
            float       srcHeight = TOREAL(pHeader->rclFrame.bottom -  pHeader->rclFrame.top);

    #if 0
            if (srcHeight * dstWidth >= dstHeight * srcWidth)
            {
                float oldDstWidth = dstWidth;
                dstWidth = srcWidth * dstHeight / srcHeight;
                dstX += (oldDstWidth - dstWidth) / 2;
            }
            else
            {
                float oldDstHeight = dstHeight;
                dstHeight = srcHeight * dstWidth / srcWidth;
                dstY += (oldDstHeight - dstHeight) / 2;
            }
    #endif
            g->SetPageUnit(Gdiplus::UnitPixel);

            using Gdiplus::RectF;
            RectF       dstRect(dstX, dstY, dstWidth, dstHeight);

            int     deviceLeft   = pHeader->rclBounds.left;
            int     deviceRight  = pHeader->rclBounds.right;
            int     deviceTop    = pHeader->rclBounds.top;
            int     deviceBottom = pHeader->rclBounds.bottom;

//          if ((deviceLeft > deviceRight) ||
//              (deviceTop  > deviceBottom))
            {
                SIZEL   deviceSize = pHeader->szlDevice;
                SIZEL   mmSize     = pHeader->szlMillimeters;

                if ((deviceSize.cx <= 0) || (deviceSize.cy <= 0) ||
                    (mmSize.cx <= 0) || (mmSize.cy <= 0))
                {
                    ASSERT(0);

                    // Take a wild guess
                    deviceSize.cx = 1024;
                    deviceSize.cy = 768;
                    mmSize.cx = 320;
                    mmSize.cy = 240;
                }
                deviceLeft   = MulDiv(pHeader->rclFrame.left,   deviceSize.cx, (mmSize.cx * 100));
                deviceRight  = MulDiv(pHeader->rclFrame.right,  deviceSize.cx, (mmSize.cx * 100));
                deviceTop    = MulDiv(pHeader->rclFrame.top,    deviceSize.cy, (mmSize.cy * 100));
                deviceBottom = MulDiv(pHeader->rclFrame.bottom, deviceSize.cy, (mmSize.cy * 100));
            }

            RectF       srcRect(TOREAL(deviceLeft),
                                    TOREAL(deviceTop),
                                    TOREAL(deviceRight -  deviceLeft),
                                    TOREAL(deviceBottom -  deviceTop));
            myData->containerId = g->BeginContainer(dstRect, srcRect, Gdiplus::UnitPixel);

            g->SetPageUnit(Gdiplus::UnitPixel); // Assume MM_TEXT
        }
        break;

    case EMR_POLYBEZIER:
        {
            PEMRPOLYBEZIER     pBezier = (PEMRPOLYBEZIER)lpEMFR;

            if (pBezier->cptl > 0)
            {
                int                 i = pBezier->cptl;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];

                do
                {
                    i--;
                    points[i].X = TOREAL(pBezier->aptl[i].x);
                    points[i].Y = TOREAL(pBezier->aptl[i].y);
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawBeziers(&pen, points, pBezier->cptl);
                    }
                }
                else
                {
                    myData->path->AddBeziers(points, pBezier->cptl);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYGON:
        {
            PEMRPOLYGON     pPolygon = (PEMRPOLYGON)lpEMFR;

            if (pPolygon->cptl > 0)
            {
                int                 i = pPolygon->cptl;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];

                do
                {
                    i--;
                    points[i].X = TOREAL(pPolygon->aptl[i].x);
                    points[i].Y = TOREAL(pPolygon->aptl[i].y);
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    Gdiplus::GraphicsPath   path(myData->fillMode);
                    path.AddPolygon(points, pPolygon->cptl);

                    if (myData->curBrush != 0)
                    {
                        if (myData->curPatIndex < 0)
                        {
                            if (myData->curBrushPattern == NULL)
                            {
                                Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                                g->FillPath(&brush, &path);
                            }
                            else
                            {
                                BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                                BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                                DibBrush brush(bmi, bits);
                                g->FillPath(brush, &path);
                            }
                        }
                        else
                        {
                            BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                            BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                            bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                            bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                            bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, &path);
                        }
                    }
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawPath(&pen, &path);
                    }
                }
                else
                {
                    myData->path->AddPolygon(points, pPolygon->cptl);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYLINE:
        {
            PEMRPOLYLINE     pPolyline = (PEMRPOLYLINE)lpEMFR;

            if (pPolyline->cptl > 0)
            {
                int                 i = pPolyline->cptl;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];

                do
                {
                    i--;
                    points[i].X = TOREAL(pPolyline->aptl[i].x);
                    points[i].Y = TOREAL(pPolyline->aptl[i].y);
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawLines(&pen, points, pPolyline->cptl);
                    }
                }
                else
                {
                    myData->path->AddLines(points, pPolyline->cptl);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYBEZIERTO:
        {
            PEMRPOLYBEZIERTO     pBezier = (PEMRPOLYBEZIERTO)lpEMFR;

            if (pBezier->cptl > 0)
            {
                int                 i = pBezier->cptl;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i+1];

                do
                {
                    points[i].X = TOREAL(pBezier->aptl[i-1].x);
                    points[i].Y = TOREAL(pBezier->aptl[i-1].y);
                    i--;
                } while (i > 0);

                points[0] = myData->curPos;
                myData->curPos = points[pBezier->cptl];

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawBeziers(&pen, points, pBezier->cptl+1);
                    }
                }
                else
                {
                    myData->path->AddBeziers(points, pBezier->cptl+1);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYLINETO:
        {
            PEMRPOLYLINETO     pPolyline = (PEMRPOLYLINETO)lpEMFR;

            if (pPolyline->cptl > 0)
            {
                int                 i = pPolyline->cptl;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i+1];

                do
                {
                    points[i].X = TOREAL(pPolyline->aptl[i-1].x);
                    points[i].Y = TOREAL(pPolyline->aptl[i-1].y);
                    i--;
                } while (i > 0);

                points[0] = myData->curPos;
                myData->curPos = points[pPolyline->cptl];

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawLines(&pen, points, pPolyline->cptl+1);
                    }
                }
                else
                {
                    myData->path->AddLines(points, pPolyline->cptl+1);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYPOLYLINE:
        {
            PEMRPOLYPOLYLINE     pPolyline = (PEMRPOLYPOLYLINE)lpEMFR;

            if ((pPolyline->cptl > 0) && (pPolyline->nPolys > 0))
            {
                int                 i = pPolyline->cptl;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];
                POINTL *            metaPoints = (POINTL *)(pPolyline->aPolyCounts + pPolyline->nPolys);

                do
                {
                    i--;
                    points[i].X = TOREAL(metaPoints[i].x);
                    points[i].Y = TOREAL(metaPoints[i].y);
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        i = 0;
                        Gdiplus::PointF *   tmpPoints = points;
                        DWORD       count;
                        do
                        {
                            count = pPolyline->aPolyCounts[i];
                            g->DrawLines(&pen, tmpPoints, count);
                            tmpPoints += count;
                        } while ((UINT)++i < pPolyline->nPolys);
                    }
                }
                else
                {
                    i = 0;
                    Gdiplus::PointF *   tmpPoints = points;
                    DWORD       count;
                    do
                    {
                        count = pPolyline->aPolyCounts[i];
                        myData->path->AddLines(tmpPoints, count);
                        tmpPoints += count;
                    } while ((UINT)++i < pPolyline->nPolys);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYPOLYGON:
        {
            PEMRPOLYPOLYGON     pPolygon = (PEMRPOLYPOLYGON)lpEMFR;

            if ((pPolygon->cptl > 0) && (pPolygon->nPolys > 0))
            {
                int                 i = pPolygon->cptl;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];
                POINTL *            metaPoints = (POINTL *)(pPolygon->aPolyCounts + pPolygon->nPolys);

                do
                {
                    i--;
                    points[i].X = TOREAL(metaPoints[i].x);
                    points[i].Y = TOREAL(metaPoints[i].y);
                } while (i > 0);

                Gdiplus::GraphicsPath   path(myData->fillMode);
                Gdiplus::GraphicsPath * tmpPath = &path;

                if (myData->pathOpen)
                {
                    tmpPath = myData->path;
                }

                Gdiplus::PointF *   tmpPoints = points;
                DWORD       count;
                i = 0;
                do
                {
                    count = pPolygon->aPolyCounts[i];
                    tmpPath->StartFigure();
                    tmpPath->AddPolygon(tmpPoints, count);
                    tmpPoints += count;
                } while ((UINT)++i < pPolygon->nPolys);

                if (myData->path == NULL)
                {
                    if (myData->curBrush != 0)
                    {
                        if (myData->curPatIndex < 0)
                        {
                            if (myData->curBrushPattern == NULL)
                            {
                                Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                                g->FillPath(&brush, &path);
                            }
                            else
                            {
                                BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                                BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                                DibBrush brush(bmi, bits);
                                g->FillPath(brush, &path);
                            }
                        }
                        else
                        {
                            BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                            BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                            bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                            bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                            bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, &path);
                        }
                    }
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawPath(&pen, &path);
                    }
                }

                delete [] points;
            }
        }
        break;

    case EMR_SETWINDOWEXTEX:
        {
            PEMRSETWINDOWEXTEX     pWindowExt = (PEMRSETWINDOWEXTEX)lpEMFR;

            if (((myData->mapMode == MM_ANISOTROPIC) ||
                 (myData->mapMode == MM_ISOTROPIC)) &&
                (pWindowExt->szlExtent.cx != 0) &&  // Note: Can be < 0!!!
                (pWindowExt->szlExtent.cy != 0) &&
                (pWindowExt->szlExtent.cx != myData->windowExtent.cx) &&
                (pWindowExt->szlExtent.cy != myData->windowExtent.cy))
            {
                myData->windowExtent = pWindowExt->szlExtent;

                float   oldDx = myData->dx;
                float   oldDy = myData->dy;
                float   oldSx = myData->scaleX;
                float   oldSy = myData->scaleY;

                float   sX = (float)myData->viewportExtent.cx / myData->windowExtent.cx;
                float   sY = (float)myData->viewportExtent.cy / myData->windowExtent.cy;

                if (myData->mapMode == MM_ISOTROPIC)
                {
                    if (sX < sY)
                    {
                        sY = sX;
                    }
                    else
                    {
                        sX = sY;
                    }
                }

                myData->scaleX = sX;
                myData->scaleY = sY;
                myData->dx     = (myData->viewportOrg.x / sX) - myData->windowOrg.x;
                myData->dy     = (myData->viewportOrg.y / sY) - myData->windowOrg.y;

                Gdiplus::Matrix     matrix;

                matrix.Scale(sX, sY);
                matrix.Translate(myData->dx, myData->dy);
                matrix.Translate(-oldDx, -oldDy);
                matrix.Scale(1 / oldSx, 1 / oldSy);

                g->MultiplyTransform(&matrix, Gdiplus::MatrixOrderAppend);
            }
        }
        break;

    case EMR_SETWINDOWORGEX:
        {
            PEMRSETWINDOWORGEX     pWindowOrg = (PEMRSETWINDOWORGEX)lpEMFR;

            if ((pWindowOrg->ptlOrigin.x != myData->windowOrg.x) &&
                (pWindowOrg->ptlOrigin.y != myData->windowOrg.y))
            {
                myData->windowOrg = pWindowOrg->ptlOrigin;

                float   oldDx = myData->dx;
                float   oldDy = myData->dy;
                float   oldSx = myData->scaleX;
                float   oldSy = myData->scaleY;

                myData->dx = (myData->viewportOrg.x / oldSx) - myData->windowOrg.x;
                myData->dy = (myData->viewportOrg.y / oldSy) - myData->windowOrg.y;

                Gdiplus::Matrix     matrix;

                matrix.Scale(oldSx, oldSy);
                matrix.Translate(myData->dx, myData->dy);
                matrix.Translate(-oldDx, -oldDy);
                matrix.Scale(1 / oldSx, 1 / oldSy);

                g->MultiplyTransform(&matrix, Gdiplus::MatrixOrderAppend);
            }
        }
        break;

    case EMR_SETVIEWPORTEXTEX:
        {
            PEMRSETVIEWPORTEXTEX     pViewportExt = (PEMRSETVIEWPORTEXTEX)lpEMFR;

            if (((myData->mapMode == MM_ANISOTROPIC) ||
                 (myData->mapMode == MM_ISOTROPIC)) &&
                (pViewportExt->szlExtent.cx > 0) &&
                (pViewportExt->szlExtent.cy > 0) &&
                (pViewportExt->szlExtent.cx != myData->viewportExtent.cx) &&
                (pViewportExt->szlExtent.cy != myData->viewportExtent.cy))
            {
                myData->viewportExtent = pViewportExt->szlExtent;

                float   oldDx = myData->dx;
                float   oldDy = myData->dy;
                float   oldSx = myData->scaleX;
                float   oldSy = myData->scaleY;

                float   sX = (float)myData->viewportExtent.cx / myData->windowExtent.cx;
                float   sY = (float)myData->viewportExtent.cy / myData->windowExtent.cy;

                if (myData->mapMode == MM_ISOTROPIC)
                {
                    if (sX < sY)
                    {
                        sY = sX;
                    }
                    else
                    {
                        sX = sY;
                    }
                }

                myData->scaleX = sX;
                myData->scaleY = sY;
                myData->dx     = (myData->viewportOrg.x / sX) - myData->windowOrg.x;
                myData->dy     = (myData->viewportOrg.y / sY) - myData->windowOrg.y;

                Gdiplus::Matrix     matrix;

                matrix.Scale(sX, sY);
                matrix.Translate(myData->dx, myData->dy);
                matrix.Translate(-oldDx, -oldDy);
                matrix.Scale(1 / oldSx, 1 / oldSy);

                g->MultiplyTransform(&matrix, Gdiplus::MatrixOrderAppend);
            }
        }
        break;

    case EMR_SETVIEWPORTORGEX:
        {
            PEMRSETVIEWPORTORGEX     pViewportOrg = (PEMRSETVIEWPORTORGEX)lpEMFR;

            if ((pViewportOrg->ptlOrigin.x != myData->viewportOrg.x) &&
                (pViewportOrg->ptlOrigin.y != myData->viewportOrg.y))
            {
                myData->viewportOrg = pViewportOrg->ptlOrigin;

                float   oldDx = myData->dx;
                float   oldDy = myData->dy;
                float   oldSx = myData->scaleX;
                float   oldSy = myData->scaleY;

                myData->dx = (myData->viewportOrg.x / oldSx) - myData->windowOrg.x;
                myData->dy = (myData->viewportOrg.y / oldSy) - myData->windowOrg.y;

                Gdiplus::Matrix     matrix;

                matrix.Scale(oldSx, oldSy);
                matrix.Translate(myData->dx, myData->dy);
                matrix.Translate(-oldDx, -oldDy);
                matrix.Scale(1 / oldSx, 1 / oldSy);

                g->MultiplyTransform(&matrix, Gdiplus::MatrixOrderAppend);
            }
        }
        break;

    case EMR_SETBRUSHORGEX:
        break;

    case EMR_EOF:
        g->EndContainer(myData->containerId);
        break;

    case EMR_SETPIXELV:
        {
            PEMRSETPIXELV     pSetPixel = (PEMRSETPIXELV)lpEMFR;

            COLORREF        cRef = pSetPixel->crColor;

            ASSERT((cRef & 0x01000000) == 0);

            Gdiplus::SolidBrush brush(Gdiplus::Color(Gdiplus::Color::MakeARGB(0xff,
                                    GetRValue(cRef), GetGValue(cRef), GetBValue(cRef))));
            g->FillRectangle(&brush, TOREAL(pSetPixel->ptlPixel.x), TOREAL(pSetPixel->ptlPixel.y), TOREAL(1), TOREAL(1));
        }
        break;

    case EMR_SETMAPPERFLAGS:    // for font mapping
        break;

    case EMR_SETMAPMODE:
        {
            PEMRSETMAPMODE     pMapMode = (PEMRSETMAPMODE)lpEMFR;
            if (myData->mapMode != pMapMode->iMode)
            {
                float   sX, sY;

                myData->mapMode = pMapMode->iMode;

                switch (pMapMode->iMode)
                {
                case MM_TEXT:
                    g->SetPageUnit(Gdiplus::UnitPixel);
                    sX = sY = 1;
                    break;
                case MM_LOMETRIC:
                    g->SetPageUnit(Gdiplus::UnitMillimeter);
                    g->SetPageScale(TOREAL(.1));
                    sX = sY = 1;
                    break;
                case MM_HIMETRIC:
                    g->SetPageUnit(Gdiplus::UnitMillimeter);
                    g->SetPageScale(TOREAL(.01));
                    sX = sY = 1;
                    break;
                case MM_LOENGLISH:
                    g->SetPageUnit(Gdiplus::UnitInch);
                    g->SetPageScale(TOREAL(.01));
                    sX = sY = 1;
                    break;
                case MM_HIENGLISH:
                    g->SetPageUnit(Gdiplus::UnitInch);
                    g->SetPageScale(TOREAL(.001));
                    sX = sY = 1;
                    break;
                case MM_TWIPS:
                    g->SetPageUnit(Gdiplus::UnitPoint);
                    g->SetPageScale(TOREAL(.05));
                    sX = sY = 1;
                    break;
                case MM_ISOTROPIC:
                    g->SetPageUnit(Gdiplus::UnitPixel);
                    sX = (float)myData->viewportExtent.cx / myData->windowExtent.cx;
                    sY = (float)myData->viewportExtent.cy / myData->windowExtent.cy;
                    if (sX < sY)
                    {
                        sY = sX;
                    }
                    else
                    {
                        sX = sY;
                    }
                    break;
                case MM_ANISOTROPIC:
                    g->SetPageUnit(Gdiplus::UnitPixel);
                    sX = (float)myData->viewportExtent.cx / myData->windowExtent.cx;
                    sY = (float)myData->viewportExtent.cy / myData->windowExtent.cy;
                    break;
                }

                float   oldDx = myData->dx;
                float   oldDy = myData->dy;
                float   oldSx = myData->scaleX;
                float   oldSy = myData->scaleY;

                myData->scaleX = sX;
                myData->scaleY = sY;
                myData->dx     = (myData->viewportOrg.x / sX) - myData->windowOrg.x;
                myData->dy     = (myData->viewportOrg.y / sY) - myData->windowOrg.y;

                Gdiplus::Matrix     matrix;

                matrix.Scale(sX, sY);
                matrix.Translate(myData->dx, myData->dy);
                matrix.Translate(-oldDx, -oldDy);
                matrix.Scale(1 / oldSx, 1 / oldSy);

                g->MultiplyTransform(&matrix, Gdiplus::MatrixOrderAppend);
            }
        }
        break;

    case EMR_SETBKMODE:
        break;

    case EMR_SETPOLYFILLMODE:
        {
            PEMRSETPOLYFILLMODE     pPolyfillMode = (PEMRSETPOLYFILLMODE)lpEMFR;

            myData->fillMode = (pPolyfillMode->iMode == ALTERNATE) ? Gdiplus::FillModeAlternate : Gdiplus::FillModeWinding;
        }
        break;

    case EMR_SETROP2:
        break;

    case EMR_SETSTRETCHBLTMODE:
#ifdef _DEBUG
        {
            PEMRSETSTRETCHBLTMODE     pStretchBltMode = (PEMRSETSTRETCHBLTMODE)lpEMFR;

            int     mode;

            switch (pStretchBltMode->iMode)
            {
            case BLACKONWHITE:
                mode = 1;
                break;
            case WHITEONBLACK:
                mode = 2;
                break;
            case COLORONCOLOR:
                mode = 3;
                break;
            case HALFTONE:
                mode = 4;
                break;
            }
        }
#endif
        break;

    case EMR_SETTEXTALIGN:
        break;

    case EMR_SETCOLORADJUSTMENT:
        break;

    case EMR_SETTEXTCOLOR:
        break;

    case EMR_SETBKCOLOR:
        break;

    case EMR_OFFSETCLIPRGN:
        {
            PEMROFFSETCLIPRGN     pOffsetClipRgn = (PEMROFFSETCLIPRGN)lpEMFR;

            g->TranslateClip(TOREAL(pOffsetClipRgn->ptlOffset.x), TOREAL(pOffsetClipRgn->ptlOffset.y));
        }
        break;

    case EMR_MOVETOEX:
        {
            PEMRMOVETOEX     pMoveTo = (PEMRMOVETOEX)lpEMFR;

            myData->curPos.X = TOREAL(pMoveTo->ptl.x);
            myData->curPos.Y = TOREAL(pMoveTo->ptl.y);
        }
        break;

    case EMR_SETMETARGN:
        break;

    case EMR_EXCLUDECLIPRECT:
        {
            PEMREXCLUDECLIPRECT     pExcludeClipRect = (PEMREXCLUDECLIPRECT)lpEMFR;

            Gdiplus::RectF      clipRect(TOREAL(pExcludeClipRect->rclClip.left),
                                             TOREAL(pExcludeClipRect->rclClip.top),
                                             TOREAL(pExcludeClipRect->rclClip.right - pExcludeClipRect->rclClip.left),
                                             TOREAL(pExcludeClipRect->rclClip.bottom - pExcludeClipRect->rclClip.top));
            g->ExcludeClip(clipRect);
        }
        break;

    case EMR_INTERSECTCLIPRECT:
        {
            PEMRINTERSECTCLIPRECT     pIntersectClipRect = (PEMRINTERSECTCLIPRECT)lpEMFR;

            Gdiplus::RectF      eRect;

            eRect.X = TOREAL(pIntersectClipRect->rclClip.left);
            eRect.Y = TOREAL(pIntersectClipRect->rclClip.top);
            eRect.Width = TOREAL(pIntersectClipRect->rclClip.right - pIntersectClipRect->rclClip.left);
            eRect.Height = TOREAL(pIntersectClipRect->rclClip.bottom - pIntersectClipRect->rclClip.top);

            g->IntersectClip(eRect);
        }
        break;

    case EMR_SCALEVIEWPORTEXTEX:
        {
            PEMRSCALEVIEWPORTEXTEX     pViewportExt = (PEMRSCALEVIEWPORTEXTEX)lpEMFR;

            if (((myData->mapMode == MM_ANISOTROPIC) ||
                 (myData->mapMode == MM_ISOTROPIC)) &&
                (pViewportExt->xNum != 0) &&
                (pViewportExt->yNum != 0) &&
                (pViewportExt->xDenom != 0) &&
                (pViewportExt->yDenom != 0))
            {
                myData->viewportExtent.cx =  (myData->viewportExtent.cx * pViewportExt->xNum) / pViewportExt->xDenom;
                myData->viewportExtent.cy =  (myData->viewportExtent.cy * pViewportExt->yNum) / pViewportExt->yDenom;

                float   oldDx = myData->dx;
                float   oldDy = myData->dy;
                float   oldSx = myData->scaleX;
                float   oldSy = myData->scaleY;

                float   sX = (float)myData->viewportExtent.cx / myData->windowExtent.cx;
                float   sY = (float)myData->viewportExtent.cy / myData->windowExtent.cy;

                if (myData->mapMode == MM_ISOTROPIC)
                {
                    if (sX < sY)
                    {
                        sY = sX;
                    }
                    else
                    {
                        sX = sY;
                    }
                }

                myData->scaleX = sX;
                myData->scaleY = sY;
                myData->dx     = (myData->viewportOrg.x / sX) - myData->windowOrg.x;
                myData->dy     = (myData->viewportOrg.y / sY) - myData->windowOrg.y;

                Gdiplus::Matrix     matrix;

                matrix.Scale(sX, sY);
                matrix.Translate(myData->dx, myData->dy);
                matrix.Translate(-oldDx, -oldDy);
                matrix.Scale(1 / oldSx, 1 / oldSy);

                g->MultiplyTransform(&matrix, Gdiplus::MatrixOrderAppend);
            }
        }
        break;

    case EMR_SCALEWINDOWEXTEX:
        {
            PEMRSCALEWINDOWEXTEX     pWindowExt = (PEMRSCALEWINDOWEXTEX)lpEMFR;

            if (((myData->mapMode == MM_ANISOTROPIC) ||
                 (myData->mapMode == MM_ISOTROPIC)) &&
                (pWindowExt->xNum != 0) &&
                (pWindowExt->yNum != 0) &&
                (pWindowExt->xDenom != 0) &&
                (pWindowExt->yDenom != 0))
            {
                myData->windowExtent.cx =  (myData->windowExtent.cx * pWindowExt->xNum) / pWindowExt->xDenom;
                myData->windowExtent.cy =  (myData->windowExtent.cy * pWindowExt->yNum) / pWindowExt->yDenom;

                float   oldDx = myData->dx;
                float   oldDy = myData->dy;
                float   oldSx = myData->scaleX;
                float   oldSy = myData->scaleY;

                float   sX = (float)myData->viewportExtent.cx / myData->windowExtent.cx;
                float   sY = (float)myData->viewportExtent.cy / myData->windowExtent.cy;

                if (myData->mapMode == MM_ISOTROPIC)
                {
                    if (sX < sY)
                    {
                        sY = sX;
                    }
                    else
                    {
                        sX = sY;
                    }
                }

                myData->scaleX = sX;
                myData->scaleY = sY;
                myData->dx     = (myData->viewportOrg.x / sX) - myData->windowOrg.x;
                myData->dy     = (myData->viewportOrg.y / sY) - myData->windowOrg.y;

                Gdiplus::Matrix     matrix;

                matrix.Scale(sX, sY);
                matrix.Translate(myData->dx, myData->dy);
                matrix.Translate(-oldDx, -oldDy);
                matrix.Scale(1 / oldSx, 1 / oldSy);

                g->MultiplyTransform(&matrix, Gdiplus::MatrixOrderAppend);
            }
        }
        break;

    case EMR_SAVEDC:
        {
            myData->PushId(g->Save());
        }
        break;

    case EMR_RESTOREDC:
        {
            g->Restore(myData->PopId());
        }
        break;

    case EMR_SETWORLDTRANSFORM:
        {
            PEMRSETWORLDTRANSFORM     pXform = (PEMRSETWORLDTRANSFORM)lpEMFR;

            Gdiplus::Matrix     newMatrix(pXform->xform.eM11,
                                          pXform->xform.eM12,
                                          pXform->xform.eM21,
                                          pXform->xform.eM22,
                                          pXform->xform.eDx,
                                          pXform->xform.eDy);

            if (newMatrix.IsInvertible())
            {
                myData->matrix.Invert();
                myData->matrix.Multiply(&newMatrix);
                g->MultiplyTransform(&(myData->matrix));
                myData->matrix.SetElements(pXform->xform.eM11,
                                           pXform->xform.eM12,
                                           pXform->xform.eM21,
                                           pXform->xform.eM22,
                                           pXform->xform.eDx,
                                           pXform->xform.eDy);
            }
        }
        break;

    case EMR_MODIFYWORLDTRANSFORM:
        {
            PEMRMODIFYWORLDTRANSFORM     pXform = (PEMRMODIFYWORLDTRANSFORM)lpEMFR;

            switch (pXform->iMode)
            {
            case MWT_IDENTITY:
            default:
                {
                    myData->matrix.Invert();
                    g->MultiplyTransform(&(myData->matrix));
                    myData->matrix.Reset();
                }
                break;

            case MWT_LEFTMULTIPLY:
                {
                    Gdiplus::Matrix     newMatrix(pXform->xform.eM11,
                                                  pXform->xform.eM12,
                                                  pXform->xform.eM21,
                                                  pXform->xform.eM22,
                                                  pXform->xform.eDx,
                                                  pXform->xform.eDy);

                    if (newMatrix.IsInvertible())
                    {
                        myData->matrix.Multiply(&newMatrix);
                        g->MultiplyTransform(&newMatrix);
                    }
                }
                break;

            case MWT_RIGHTMULTIPLY:
                {
                    Gdiplus::Matrix     newMatrix(pXform->xform.eM11,
                                                  pXform->xform.eM12,
                                                  pXform->xform.eM21,
                                                  pXform->xform.eM22,
                                                  pXform->xform.eDx,
                                                  pXform->xform.eDy);

                    if (newMatrix.IsInvertible())
                    {
                        Gdiplus::Matrix *   inverse = myData->matrix.Clone();
                        inverse->Invert();

                        myData->matrix.Multiply(&newMatrix, Gdiplus::MatrixOrderAppend);
                        inverse->Multiply(&(myData->matrix));
                        g->MultiplyTransform(inverse);
                        delete inverse;
                    }
                }
                break;
            }
        }
        break;

    case EMR_SELECTOBJECT:
        {
            PEMRSELECTOBJECT     pObject = (PEMRSELECTOBJECT)lpEMFR;

            int     objectIndex = pObject->ihObject;

            if ((objectIndex & ENHMETA_STOCK_OBJECT) != 0)
            {
                switch (objectIndex & (~ENHMETA_STOCK_OBJECT))
                {
                case WHITE_BRUSH:
                    myData->curBrush = 0xFFFFFFFF;
                    break;
                case LTGRAY_BRUSH:
                    myData->curBrush = 0xFFC0C0C0;
                    break;
                case GRAY_BRUSH:
                    myData->curBrush = 0xFF808080;
                    break;
                case DKGRAY_BRUSH:
                    myData->curBrush = 0xFF404040;
                    break;
                case BLACK_BRUSH:
                    myData->curBrush = 0xFF000000;
                    break;
                case NULL_BRUSH:
                    myData->curBrush = 0x00000000;
                    break;
                case WHITE_PEN:
                    myData->curPen = 0xFFFFFFFF;
                    break;
                case BLACK_PEN:
                    myData->curPen = 0xFF000000;
                    break;
                case NULL_PEN:
                    myData->curPen = 0x00000000;
                    break;
                }
            }
            else
            {
                ASSERT(objectIndex < myData->numObjects);
                if (myData->pObjects[objectIndex].type == MYOBJECTS::PenObjectType)
                {
                    myData->curPen = myData->pObjects[objectIndex].color;
                    myData->curPenWidth = myData->pObjects[objectIndex].penWidth;
                }
                else if (myData->pObjects[objectIndex].type == MYOBJECTS::BrushObjectType)
                {
                    myData->curBrush        = myData->pObjects[objectIndex].color;
                    myData->curBrushPattern = myData->pObjects[objectIndex].brushPattern;
#if 1
                    myData->curPatIndex     = myData->pObjects[objectIndex].patIndex;

#else
static dodo = 0;
myData->curPatIndex = dodo++ % 6;
#endif
                }
            }
        }
        break;

    case EMR_CREATEPEN:
        {
            PEMRCREATEPEN       pPen = (PEMRCREATEPEN)lpEMFR;
            COLORREF            cRef = pPen->lopn.lopnColor;

            ASSERT((cRef & 0x01000000) == 0);

            ASSERT(pPen->ihPen < myData->numObjects);

            delete myData->pObjects[pPen->ihPen].brushPattern;
            myData->pObjects[pPen->ihPen].brushPattern = NULL;

            myData->pObjects[pPen->ihPen].type  = MYOBJECTS::PenObjectType;

            myData->pObjects[pPen->ihPen].color = Gdiplus::Color::MakeARGB(0xff,
                        GetRValue(cRef), GetGValue(cRef), GetBValue(cRef));

            myData->pObjects[pPen->ihPen].penWidth = pPen->lopn.lopnWidth.x;
        }
        break;

    case EMR_CREATEBRUSHINDIRECT:
        {
            PEMRCREATEBRUSHINDIRECT     pBrush = (PEMRCREATEBRUSHINDIRECT)lpEMFR;
            COLORREF                    cRef   = pBrush->lb.lbColor;

            ASSERT((cRef & 0x01000000) == 0);

            ASSERT(pBrush->ihBrush < myData->numObjects);

            myData->pObjects[pBrush->ihBrush].type  = MYOBJECTS::BrushObjectType;
            myData->pObjects[pBrush->ihBrush].patIndex = -1;
            delete myData->pObjects[pBrush->ihBrush].brushPattern;
            myData->pObjects[pBrush->ihBrush].brushPattern = NULL;
            if (pBrush->lb.lbStyle == BS_NULL)
            {
                myData->pObjects[pBrush->ihBrush].color = 0x00000000;
            }
            else
            {
                // Hatch Styles
                if (pBrush->lb.lbStyle == BS_HATCHED)
                {
                    switch (pBrush->lb.lbHatch)
                    {
                    case HS_HORIZONTAL:         /* ----- */
                    case HS_VERTICAL:           /* ||||| */
                    case HS_FDIAGONAL:          /* \\\\\ */
                    case HS_BDIAGONAL:          /* ///// */
                    case HS_CROSS:              /* +++++ */
                    case HS_DIAGCROSS:          /* xxxxx */
                        myData->pObjects[pBrush->ihBrush].patIndex = pBrush->lb.lbHatch;
                        break;
                    }
                }
                myData->pObjects[pBrush->ihBrush].color = Gdiplus::Color::MakeARGB(0xff,
                            GetRValue(cRef), GetGValue(cRef), GetBValue(cRef));
            }
        }
        break;

    case EMR_DELETEOBJECT:
        {
#if 0
            PEMRDELETEOBJECT     pObject = (PEMRDELETEOBJECT)lpEMFR;

            int     objectIndex = pObject->ihObject;

            ASSERT(objectIndex < myData->numObjects);

            if (myData->pObjects[objectIndex].type == MYOBJECTS::BrushObjectType)
            {
                if (myData->curBrushPattern != myData->pObjects[objectIndex].brushPattern)
                {
                    delete myData->pObjects[objectIndex].brushPattern;
                    myData->pObjects[objectIndex].brushPattern = NULL;
                }
            }
#endif
        }
        break;

    case EMR_ANGLEARC:
        break;

    case EMR_ELLIPSE:
        {
            PEMRELLIPSE     pEllipse = (PEMRELLIPSE)lpEMFR;

            float   x = TOREAL(pEllipse->rclBox.left);
            float   y = TOREAL(pEllipse->rclBox.top);
            float   w = TOREAL(pEllipse->rclBox.right - x);
            float   h = TOREAL(pEllipse->rclBox.bottom - y);

            if (!myData->pathOpen)
            {
                Gdiplus::GraphicsPath   path(myData->fillMode);

                path.AddEllipse(x, y, w, h);

                if (myData->curBrush != 0)
                {
                    if (myData->curPatIndex < 0)
                    {
                        if (myData->curBrushPattern == NULL)
                        {
                            Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                            g->FillPath(&brush, &path);
                        }
                        else
                        {
                            BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                            BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, &path);
                        }
                    }
                    else
                    {
                        BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                        BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                        bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                        bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                        bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                        DibBrush brush(bmi, bits);
                        g->FillPath(brush, &path);
                    }
                }
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawPath(&pen, &path);
                }
            }
            else
            {
                myData->path->AddEllipse(x, y, w, h);
            }
        }
        break;

    case EMR_RECTANGLE:
        {
            PEMRRECTANGLE     pRect = (PEMRRECTANGLE)lpEMFR;

            float   x = TOREAL(pRect->rclBox.left);
            float   y = TOREAL(pRect->rclBox.top);
            float   w = TOREAL(pRect->rclBox.right - x);
            float   h = TOREAL(pRect->rclBox.bottom - y);

            if (!myData->pathOpen)
            {
                if (myData->curBrush != 0)
                {
                    if (myData->curPatIndex < 0)
                    {
                        if (myData->curBrushPattern == NULL)
                        {
                            Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                            g->FillRectangle(&brush, x, y, w, h);
                        }
                        else
                        {
                            BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                            BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                            DibBrush brush(bmi, bits);
                            g->FillRectangle(brush, x, y, w, h);
                        }
                    }
                    else
                    {
                        BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                        BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                        bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                        bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                        bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                        DibBrush brush(bmi, bits);
                        g->FillRectangle(brush, x, y, w, h);
                    }
                }
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawRectangle(&pen, x, y, w, h);
                }
            }
            else
            {
                myData->path->AddRectangle(Gdiplus::RectF(x, y, w, h));
            }
        }
        break;

    case EMR_ROUNDRECT: // for now, ignore the szlCorner param of round corners
        {
            PEMRROUNDRECT     pRect = (PEMRROUNDRECT)lpEMFR;

            float   x = TOREAL(pRect->rclBox.left);
            float   y = TOREAL(pRect->rclBox.top);
            float   w = TOREAL(pRect->rclBox.right - x);
            float   h = TOREAL(pRect->rclBox.bottom - y);

            if (!myData->pathOpen)
            {
                if (myData->curBrush != 0)
                {
                    if (myData->curPatIndex < 0)
                    {
                        if (myData->curBrushPattern == NULL)
                        {
                            Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                            g->FillRectangle(&brush, x, y, w, h);
                        }
                        else
                        {
                            BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                            BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                            DibBrush brush(bmi, bits);
                            g->FillRectangle(brush, x, y, w, h);
                        }
                    }
                    else
                    {
                        BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                        BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                        bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                        bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                        bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                        DibBrush brush(bmi, bits);
                        g->FillRectangle(brush, x, y, w, h);
                    }
                }
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawRectangle(&pen, x, y, w, h);
                }
            }
            else
            {
                myData->path->AddRectangle(Gdiplus::RectF(x, y, w, h));
            }
        }
        break;

    case EMR_ARC:
        {
            PEMRARC     pArc = (PEMRARC)lpEMFR;

            float   x = TOREAL(pArc->rclBox.left);
            float   y = TOREAL(pArc->rclBox.top);
            float   w = TOREAL(pArc->rclBox.right - x);
            float   h = TOREAL(pArc->rclBox.bottom - y);
            float   startAngle = PointToAngle(x, y, w, h, TOREAL(pArc->ptlStart.x), TOREAL(pArc->ptlStart.y));
            float   endAngle   = PointToAngle(x, y, w, h, TOREAL(pArc->ptlEnd.x), TOREAL(pArc->ptlEnd.y));
            if (endAngle <= startAngle)
            {
                endAngle += 360;
            }
            float   sweepAngle = endAngle - startAngle;
            if ((myData->arcDirection != AD_COUNTERCLOCKWISE) && (sweepAngle < 360))
            {
                sweepAngle = 360 - sweepAngle;
            }

            if (!myData->pathOpen)
            {
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawArc(&pen, x, y, w, h, startAngle, sweepAngle);
                }
            }
            else
            {
                myData->path->AddArc(x, y, w, h, startAngle, sweepAngle);
            }
        }
        break;

    case EMR_CHORD:
        break;

    case EMR_PIE:
        {
            PEMRARC     pPie = (PEMRARC)lpEMFR;

            float   x = TOREAL(pPie->rclBox.left);
            float   y = TOREAL(pPie->rclBox.top);
            float   w = TOREAL(pPie->rclBox.right - x);
            float   h = TOREAL(pPie->rclBox.bottom - y);
            float   startAngle = PointToAngle(x, y, w, h, TOREAL(pPie->ptlStart.x), TOREAL(pPie->ptlStart.y));
            float   endAngle   = PointToAngle(x, y, w, h, TOREAL(pPie->ptlEnd.x), TOREAL(pPie->ptlEnd.y));
            if (endAngle <= startAngle)
            {
                endAngle += 360;
            }
            float   sweepAngle = endAngle - startAngle;
            if ((myData->arcDirection != AD_COUNTERCLOCKWISE) && (sweepAngle < 360))
            {
                sweepAngle = 360 - sweepAngle;
            }
            if (!myData->pathOpen)
            {
                Gdiplus::GraphicsPath   path(myData->fillMode);
                path.AddPie(x, y, w, h, startAngle, sweepAngle);

                if (myData->curBrush != 0)
                {
                    if (myData->curPatIndex < 0)
                    {
                        if (myData->curBrushPattern == NULL)
                        {
                            Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                            g->FillPath(&brush, &path);
                        }
                        else
                        {
                            BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                            BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, &path);
                        }
                    }
                    else
                    {
                        BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                        BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                        bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                        bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                        bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                        DibBrush brush(bmi, bits);
                        g->FillPath(brush, &path);
                    }
                }
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawPath(&pen, &path);
                }
            }
            else
            {
                myData->path->AddPie(x, y, w, h, startAngle, sweepAngle);
            }
        }
        break;

    case EMR_SELECTPALETTE:
        break;

    case EMR_CREATEPALETTE:
        break;

    case EMR_SETPALETTEENTRIES:
        break;

    case EMR_RESIZEPALETTE:
        break;

    case EMR_REALIZEPALETTE:
        break;

    case EMR_EXTFLOODFILL:
        break;

    case EMR_LINETO:
        {
            PEMRMOVETOEX     pLineTo = (PEMRMOVETOEX)lpEMFR;

            float   x = TOREAL(pLineTo->ptl.x);
            float   y = TOREAL(pLineTo->ptl.y);

            if (!myData->pathOpen)
            {
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawLine(&pen, (float)myData->curPos.X, (float)myData->curPos.Y, x, y);
                }
            }
            else
            {
                myData->path->AddLine((float)myData->curPos.X, (float)myData->curPos.Y, x, y);
            }

            myData->curPos.X = x;
            myData->curPos.Y = y;
        }
        break;

    case EMR_ARCTO:
        {
            // !!! Set and use current position

            PEMRARCTO     pArc = (PEMRARCTO)lpEMFR;

            float   x = TOREAL(pArc->rclBox.left);
            float   y = TOREAL(pArc->rclBox.top);
            float   w = TOREAL(pArc->rclBox.right - x);
            float   h = TOREAL(pArc->rclBox.bottom - y);
            float   startAngle = PointToAngle(x, y, w, h, TOREAL(pArc->ptlStart.x), TOREAL(pArc->ptlStart.y));
            float   endAngle   = PointToAngle(x, y, w, h, TOREAL(pArc->ptlEnd.x), TOREAL(pArc->ptlEnd.y));
            if (endAngle <= startAngle)
            {
                endAngle += 360;
            }
            float   sweepAngle = endAngle - startAngle;
            if ((myData->arcDirection != AD_COUNTERCLOCKWISE) && (sweepAngle < 360))
            {
                sweepAngle = 360 - sweepAngle;
            }

            if (!myData->pathOpen)
            {
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawArc(&pen, x, y, w, h, startAngle, sweepAngle);
                }
            }
            else
            {
                myData->path->AddArc(x, y, w, h, startAngle, sweepAngle);
            }
        }
        break;

    case EMR_POLYDRAW:
        break;

    case EMR_SETARCDIRECTION:
        {
            PEMRSETARCDIRECTION     pArcDirection = (PEMRSETARCDIRECTION)lpEMFR;

            myData->arcDirection = pArcDirection->iArcDirection;
        }
        break;

    case EMR_SETMITERLIMIT:
        {
            PEMRSETMITERLIMIT     pMiterLimit = (PEMRSETMITERLIMIT)lpEMFR;

            myData->miterLimit = pMiterLimit->eMiterLimit;
        }
        break;

    case EMR_BEGINPATH:
        {
            delete myData->path;

            myData->path = new Gdiplus::GraphicsPath (myData->fillMode);
            myData->pathOpen = (myData->path != NULL);
        }
        break;

    case EMR_ENDPATH:
        myData->pathOpen = FALSE;
        break;

    case EMR_CLOSEFIGURE:
        {
            if (myData->pathOpen)
            {
                myData->path->CloseFigure();
            }
        }
        break;

    case EMR_FILLPATH:
        {
            if (myData->path != NULL)
            {
                if (myData->curBrush != 0)
                {
                    if (myData->curPatIndex < 0)
                    {
                        if (myData->curBrushPattern == NULL)
                        {
                            Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                            g->FillPath(&brush, myData->path);
                        }
                        else
                        {
                            BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                            BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, myData->path);
                        }
                    }
                    else
                    {
                        BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                        BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                        bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                        bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                        bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                        DibBrush brush(bmi, bits);
                        g->FillPath(brush, myData->path);
                    }
                }
                delete myData->path;
                myData->path = NULL;
                myData->pathOpen = FALSE;
            }
        }
        break;

    case EMR_STROKEANDFILLPATH:
        {
            if (myData->path != NULL)
            {
                if (myData->curBrush != 0)
                {
                    if (myData->curPatIndex < 0)
                    {
                        if (myData->curBrushPattern == NULL)
                        {
                            Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                            g->FillPath(&brush, myData->path);
                        }
                        else
                        {
                            BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                            BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, myData->path);
                        }
                    }
                    else
                    {
                        BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                        BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                        bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                        bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                        bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                        DibBrush brush(bmi, bits);
                        g->FillPath(brush, myData->path);
                    }
                }
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawPath(&pen, myData->path);
                }
                delete myData->path;
                myData->path = NULL;
                myData->pathOpen = FALSE;
            }
        }
        break;

    case EMR_STROKEPATH:
        {
            if (myData->path != NULL)
            {
                if (myData->curPen != 0)
                {
                    Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                    pen.SetMiterLimit(myData->miterLimit);

                    g->DrawPath(&pen, myData->path);
                }
                delete myData->path;
                myData->path = NULL;
                myData->pathOpen = FALSE;
            }
        }
        break;

    case EMR_FLATTENPATH:
        {
            if (myData->path != NULL)
            {
                myData->path->Flatten(NULL);
            }
        }
        break;

    case EMR_WIDENPATH:
        {
            if (myData->path != NULL)
            {
                Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                pen.SetMiterLimit(myData->miterLimit);

                myData->path->Widen(&pen);
            }
        }
        break;

    case EMR_SELECTCLIPPATH:
        {
            if (myData->path != NULL)
            {
                PEMRSELECTCLIPPATH     pSetClipPath = (PEMRSELECTCLIPPATH)lpEMFR;

                switch (pSetClipPath->iMode)
                {
                case RGN_COPY:
                default:
                    g->SetClip(myData->path);
                    break;
                case RGN_AND:
                    {
                        Gdiplus::Region     region(myData->path);
                        g->IntersectClip(&region);
                    }
                    break;
                case RGN_DIFF:
                    {
                        Gdiplus::Region     region(myData->path);
                        Gdiplus::Region curClip;
                        g->GetClip(&curClip);
                        curClip.Exclude(&region);
                        g->SetClip(&curClip);
                    }
                    break;
                case RGN_OR:
                    {
                        Gdiplus::Region     region(myData->path);
                        Gdiplus::Region curClip;
                        g->GetClip(&curClip);
                        curClip.Union(&region);
                        g->SetClip(&curClip);
                    }
                    break;
                case RGN_XOR:
                    {
                        Gdiplus::Region     region(myData->path);
                        Gdiplus::Region curClip;
                        g->GetClip(&curClip);
                        curClip.Xor(&region);
                        g->SetClip(&curClip);
                    }
                    break;
                }
                delete myData->path;
                myData->path = NULL;
                myData->pathOpen = FALSE;
            }
        }
        break;

    case EMR_ABORTPATH:
        {
            if (myData->path != NULL)
            {
                delete myData->path;
                myData->path = NULL;
                myData->pathOpen = FALSE;
            }
        }
        break;

    case EMR_GDICOMMENT:
        break;

    case EMR_FILLRGN:
        break;

    case EMR_FRAMERGN:
        break;

    case EMR_INVERTRGN:
        break;

    case EMR_PAINTRGN:
        break;

    case EMR_EXTSELECTCLIPRGN:
        break;

    case EMR_BITBLT:
        {
            PEMRBITBLT     pBitBlt = (PEMRBITBLT)lpEMFR;

            switch (pBitBlt->dwRop)
            {
            case BLACKNESS:
                {
                    Gdiplus::SolidBrush brush(Gdiplus::Color(0xff000000));
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    g->FillRectangle(&brush, TOREAL(pBitBlt->xDest), TOREAL(pBitBlt->yDest), TOREAL(pBitBlt->cxDest + cx), TOREAL(pBitBlt->cyDest + cy));
                }
                return;
            case WHITENESS:
                {
                    Gdiplus::SolidBrush brush(Gdiplus::Color(0xffffffff));
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    g->FillRectangle(&brush, TOREAL(pBitBlt->xDest), TOREAL(pBitBlt->yDest), TOREAL(pBitBlt->cxDest + 1), TOREAL(pBitBlt->cyDest + 1));
                }
                return;
            default:
                if (!ISSOURCEINROP3(pBitBlt->dwRop))
                {
                    if (myData->curBrush != 0)
                    {
                        if (myData->curPatIndex < 0)
                        {
                            if (myData->curBrushPattern == NULL)
                            {
                                Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                                float cx, cy;
                                GetPixelSize (g, &cx, &cy);
                                g->FillRectangle(&brush, TOREAL(pBitBlt->xDest), TOREAL(pBitBlt->yDest), TOREAL(pBitBlt->cxDest + cx), TOREAL(pBitBlt->cyDest + cy));
                            }
                            else
                            {
                                BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                                BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                                DibBrush brush(bmi, bits);
                                float cx, cy;
                                GetPixelSize (g, &cx, &cy);
                                g->FillRectangle(brush, TOREAL(pBitBlt->xDest), TOREAL(pBitBlt->yDest), TOREAL(pBitBlt->cxDest + cx), TOREAL(pBitBlt->cyDest + cy));
                            }
                        }
                        else
                        {
                            BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                            BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                            bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                            bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                            bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                            DibBrush brush(bmi, bits);
                            float cx, cy;
                            GetPixelSize (g, &cx, &cy);
                            g->FillRectangle(brush, TOREAL(pBitBlt->xDest), TOREAL(pBitBlt->yDest), TOREAL(pBitBlt->cxDest + cx), TOREAL(pBitBlt->cyDest + cy));
                        }
                    }
                    return;
                }
                break;
            }

            // Else assume SRCCOPY
            BITMAPINFO *bmi = (BITMAPINFO *)(((BYTE *)pBitBlt) + pBitBlt->offBmiSrc);
            BYTE *bits      = ((BYTE *)pBitBlt) + pBitBlt->offBitsSrc;

            DibStream dibStream(bmi, bits);
            Gdiplus::Bitmap         gpBitmap(&dibStream);
            Gdiplus::RectF destRect(TOREAL(pBitBlt->xDest),
                                         TOREAL(pBitBlt->yDest),
                                         TOREAL(pBitBlt->cxDest),
                                         TOREAL(pBitBlt->cyDest));

            g->DrawImage(&gpBitmap, destRect,
                         TOREAL(pBitBlt->xSrc),
                         TOREAL(pBitBlt->ySrc),
                         TOREAL(pBitBlt->cxDest),
                         TOREAL(pBitBlt->cyDest),
                         Gdiplus::UnitPixel);

        }
        break;

    case EMR_STRETCHBLT:
        {
            PEMRSTRETCHBLT     pStretchBlt = (PEMRSTRETCHBLT)lpEMFR;

            switch (pStretchBlt->dwRop)
            {
            case BLACKNESS:
                {
                    Gdiplus::SolidBrush brush(Gdiplus::Color(0xff000000));
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    g->FillRectangle(&brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                }
                return;
            case WHITENESS:
                {
                    Gdiplus::SolidBrush brush(Gdiplus::Color(0xffffffff));
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    g->FillRectangle(&brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                }
                return;
            default:
                if (!ISSOURCEINROP3(pStretchBlt->dwRop))
                {
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    if (myData->curBrush != 0)
                    {
                        if (myData->curPatIndex < 0)
                        {
                            if (myData->curBrushPattern == NULL)
                            {
                                Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                                g->FillRectangle(&brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                            }
                            else
                            {
                                BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                                BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                                DibBrush brush(bmi, bits);
                                g->FillRectangle(brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                            }
                        }
                        else
                        {
                            BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                            BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                            bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                            bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                            bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                            DibBrush brush(bmi, bits);
                            g->FillRectangle(brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                        }
                    }
                    return;
                }
                break;
            }

            // Else assume SRCCOPY
            BITMAPINFO *bmi = (BITMAPINFO *)(((BYTE *)pStretchBlt) + pStretchBlt->offBmiSrc);
            BYTE *bits      = ((BYTE *)pStretchBlt) + pStretchBlt->offBitsSrc;

            DibStream dibStream(bmi, bits);
            Gdiplus::Bitmap         gpBitmap(&dibStream);
            Gdiplus::RectF destRect(TOREAL(pStretchBlt->xDest),
                                         TOREAL(pStretchBlt->yDest),
                                         TOREAL(pStretchBlt->cxDest),
                                         TOREAL(pStretchBlt->cyDest));

            g->DrawImage(&gpBitmap, destRect,
                         TOREAL(pStretchBlt->xSrc),
                         TOREAL(pStretchBlt->ySrc),
                         TOREAL(pStretchBlt->cxSrc),
                         TOREAL(pStretchBlt->cySrc),
                         Gdiplus::UnitPixel);
        }
        break;

    case EMR_MASKBLT:
        break;

    case EMR_PLGBLT:
        break;

    case EMR_SETDIBITSTODEVICE:
        break;
#if 0
typedef struct tagEMRSETDIBITSTODEVICE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    DWORD   iUsageSrc;          // Source bitmap info color table usage
    DWORD   iStartScan;
    DWORD   cScans;
} EMRSETDIBITSTODEVICE, *PEMRSETDIBITSTODEVICE;
#endif

    case EMR_STRETCHDIBITS:
        {
            PEMRSTRETCHDIBITS     pStretchBlt = (PEMRSTRETCHDIBITS)lpEMFR;

            switch (pStretchBlt->dwRop)
            {
            case BLACKNESS:
                {
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    Gdiplus::SolidBrush brush(Gdiplus::Color(0xff000000));
                    g->FillRectangle(&brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                }
                return;
            case WHITENESS:
                {
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    Gdiplus::SolidBrush brush(Gdiplus::Color(0xffffffff));
                    g->FillRectangle(&brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                }
                return;
            default:
                if (!ISSOURCEINROP3(pStretchBlt->dwRop))
                {
                    float cx, cy;
                    GetPixelSize (g, &cx, &cy);
                    if (myData->curBrush != 0)
                    {
                        if (myData->curPatIndex < 0)
                        {
                            if (myData->curBrushPattern == NULL)
                            {
                                Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                                g->FillRectangle(&brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                            }
                            else
                            {
                                BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                                BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                                DibBrush brush(bmi, bits);
                                g->FillRectangle(brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                            }
                        }
                        else
                        {
                            BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                            BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                            bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                            bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                            bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                            DibBrush brush(bmi, bits);
                            g->FillRectangle(brush, TOREAL(pStretchBlt->xDest), TOREAL(pStretchBlt->yDest), TOREAL(pStretchBlt->cxDest + cx), TOREAL(pStretchBlt->cyDest + cy));
                        }
                    }
                    return;
                }
                break;
            }

            // Else assume SRCCOPY
            BITMAPINFO *bmi = (BITMAPINFO *)(((BYTE *)pStretchBlt) + pStretchBlt->offBmiSrc);
            BYTE *bits      = ((BYTE *)pStretchBlt) + pStretchBlt->offBitsSrc;

            DibStream dibStream(bmi, bits);
            Gdiplus::Bitmap         gpBitmap(&dibStream);
            Gdiplus::RectF destRect(TOREAL(pStretchBlt->xDest),
                                         TOREAL(pStretchBlt->yDest),
                                         TOREAL(pStretchBlt->cxDest),
                                         TOREAL(pStretchBlt->cyDest));

            g->DrawImage(&gpBitmap, destRect,
                         TOREAL(pStretchBlt->xSrc),
                         TOREAL(pStretchBlt->ySrc),
                         TOREAL(pStretchBlt->cxSrc),
                         TOREAL(pStretchBlt->cySrc),
                         Gdiplus::UnitPixel);
        }
        break;

    case EMR_EXTCREATEFONTINDIRECTW:
        break;

    case EMR_EXTTEXTOUTA:
        break;

    case EMR_EXTTEXTOUTW:
        break;

    case EMR_POLYBEZIER16:
        {
            PEMRPOLYBEZIER16     pBezier = (PEMRPOLYBEZIER16)lpEMFR;

            if (pBezier->cpts > 0)
            {
                int                 i = pBezier->cpts;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];

                do
                {
                    i--;
                    points[i].X = pBezier->apts[i].x;
                    points[i].Y = pBezier->apts[i].y;
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawBeziers(&pen, points, pBezier->cpts);
                    }
                }
                else
                {
                    myData->path->AddBeziers(points, pBezier->cpts);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYGON16:
        {
            PEMRPOLYGON16     pPolygon = (PEMRPOLYGON16)lpEMFR;

            if (pPolygon->cpts > 0)
            {
                int                 i = pPolygon->cpts;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];

                do
                {
                    i--;
                    points[i].X = pPolygon->apts[i].x;
                    points[i].Y = pPolygon->apts[i].y;
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    Gdiplus::GraphicsPath   path(myData->fillMode);
                    path.AddPolygon(points, pPolygon->cpts);

                    if (myData->curBrush != 0)
                    {
                        if (myData->curPatIndex < 0)
                        {
                            if (myData->curBrushPattern == NULL)
                            {
                                Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                                g->FillPath(&brush, &path);
                            }
                            else
                            {
                                BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                                BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                                DibBrush brush(bmi, bits);
                                g->FillPath(brush, &path);
                            }
                        }
                        else
                        {
                            BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                            BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                            bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                            bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                            bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, &path);
                        }
                    }
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawPath(&pen, &path);
                    }
                }
                else
                {
                    myData->path->AddPolygon(points, pPolygon->cpts);
                }
                delete [] points;
            }
        }
        break;

    case EMR_POLYLINE16:
        {
            PEMRPOLYLINE16     pPolyline = (PEMRPOLYLINE16)lpEMFR;

            if (pPolyline->cpts > 0)
            {
                int                 i = pPolyline->cpts;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];

                do
                {
                    i--;
                    points[i].X = pPolyline->apts[i].x;
                    points[i].Y = pPolyline->apts[i].y;
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawLines(&pen, points, pPolyline->cpts);
                    }
                }
                else
                {
                    myData->path->AddLines(points, pPolyline->cpts);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYBEZIERTO16:
        {
            PEMRPOLYBEZIERTO16     pBezier = (PEMRPOLYBEZIERTO16)lpEMFR;

            if (pBezier->cpts > 0)
            {
                int                 i = pBezier->cpts;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i+1];

                do
                {
                    points[i].X = pBezier->apts[i-1].x;
                    points[i].Y = pBezier->apts[i-1].y;
                    i--;
                } while (i > 0);

                points[0] = myData->curPos;
                myData->curPos = points[pBezier->cpts];

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawBeziers(&pen, points, pBezier->cpts+1);
                    }
                }
                else
                {
                    myData->path->AddBeziers(points, pBezier->cpts+1);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYLINETO16:
        {
            PEMRPOLYLINETO16     pPolyline = (PEMRPOLYLINETO16)lpEMFR;

            if (pPolyline->cpts > 0)
            {
                int                 i = pPolyline->cpts;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i+1];

                do
                {
                    points[i].X = pPolyline->apts[i-1].x;
                    points[i].Y = pPolyline->apts[i-1].y;
                    i--;
                } while (i > 0);

                points[0] = myData->curPos;
                myData->curPos = points[pPolyline->cpts];

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawLines(&pen, points, pPolyline->cpts+1);
                    }
                }
                else
                {
                    myData->path->AddLines(points, pPolyline->cpts+1);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYPOLYLINE16:
        {
            PEMRPOLYPOLYLINE16     pPolyline = (PEMRPOLYPOLYLINE16)lpEMFR;

            if ((pPolyline->cpts > 0) && (pPolyline->nPolys > 0))
            {
                int                 i = pPolyline->cpts;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];
                POINTS *            metaPoints = (POINTS *)(pPolyline->aPolyCounts + pPolyline->nPolys);

                do
                {
                    i--;
                    points[i].X = metaPoints[i].x;
                    points[i].Y = metaPoints[i].y;
                } while (i > 0);

                if (!myData->pathOpen)
                {
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        i = 0;
                        Gdiplus::PointF *   tmpPoints = points;
                        DWORD       count;
                        do
                        {
                            count = pPolyline->aPolyCounts[i];
                            g->DrawLines(&pen, tmpPoints, count);
                            tmpPoints += count;
                        } while ((UINT)++i < pPolyline->nPolys);
                    }
                }
                else
                {
                    i = 0;
                    Gdiplus::PointF *   tmpPoints = points;
                    DWORD       count;
                    do
                    {
                        count = pPolyline->aPolyCounts[i];
                        myData->path->AddLines(tmpPoints, count);
                        tmpPoints += count;
                    } while ((UINT)++i < pPolyline->nPolys);
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYPOLYGON16:
        {
            PEMRPOLYPOLYGON16     pPolygon = (PEMRPOLYPOLYGON16)lpEMFR;

            if ((pPolygon->cpts > 0) && (pPolygon->nPolys > 0))
            {
                int                 i = pPolygon->cpts;
                Gdiplus::PointF *   points = new Gdiplus::PointF[i];
                POINTS *            metaPoints = (POINTS *)(pPolygon->aPolyCounts + pPolygon->nPolys);

                do
                {
                    i--;
                    points[i].X = metaPoints[i].x;
                    points[i].Y = metaPoints[i].y;
                } while (i > 0);

                Gdiplus::GraphicsPath   path(myData->fillMode);
                Gdiplus::GraphicsPath * tmpPath = &path;

                if (myData->pathOpen)
                {
                    tmpPath = myData->path;
                }

                Gdiplus::PointF *   tmpPoints = points;
                DWORD       count;
                i = 0;
                do
                {
                    count = pPolygon->aPolyCounts[i];
                    tmpPath->StartFigure();
                    tmpPath->AddPolygon(tmpPoints, count);
                    tmpPoints += count;
                } while ((UINT)++i < pPolygon->nPolys);

                if (!myData->pathOpen)
                {
                    if (myData->curBrush != 0)
                    {
                        if (myData->curPatIndex < 0)
                        {
                            if (myData->curBrushPattern == NULL)
                            {
                                Gdiplus::SolidBrush brush(Gdiplus::Color(myData->curBrush));
                                g->FillPath(&brush, &path);
                            }
                            else
                            {
                                BITMAPINFO *        bmi  = (BITMAPINFO *)myData->curBrushPattern->bmi;
                                BYTE *              bits = ((BYTE *)bmi) + myData->curBrushPattern->bitsOffset;

                                DibBrush brush(bmi, bits);
                                g->FillPath(brush, &path);
                            }
                        }
                        else
                        {
                            BITMAPINFO *            bmi  = (BITMAPINFO *)&hatchBrushInfo;
                            BYTE *                  bits = (BYTE *)HatchPatterns[myData->curPatIndex];

                            bmi->bmiColors[1].rgbRed   = (myData->curBrush & Gdiplus::Color::RedMask)   >> Gdiplus::Color::RedShift;
                            bmi->bmiColors[1].rgbGreen = (myData->curBrush & Gdiplus::Color::GreenMask) >> Gdiplus::Color::GreenShift;
                            bmi->bmiColors[1].rgbBlue  = (myData->curBrush & Gdiplus::Color::BlueMask)  >> Gdiplus::Color::BlueShift;

                            DibBrush brush(bmi, bits);
                            g->FillPath(brush, &path);
                        }
                    }
                    if (myData->curPen != 0)
                    {
                        Gdiplus::Pen    pen(Gdiplus::Color(myData->curPen), TOREAL(myData->curPenWidth));
                        pen.SetMiterLimit(myData->miterLimit);

                        g->DrawPath(&pen, &path);
                    }
                }

                delete [] points;
            }
        }
        break;

    case EMR_POLYDRAW16:
        break;

    case EMR_CREATEMONOBRUSH:
        break;

    case EMR_CREATEDIBPATTERNBRUSHPT:
        {
            PEMRCREATEDIBPATTERNBRUSHPT     pBrush = (PEMRCREATEDIBPATTERNBRUSHPT)lpEMFR;

            ASSERT(pBrush->ihBrush < myData->numObjects);

            myData->pObjects[pBrush->ihBrush].type  = MYOBJECTS::BrushObjectType;
            myData->pObjects[pBrush->ihBrush].color  = 0xFF808080;
            myData->pObjects[pBrush->ihBrush].patIndex = -1;
            delete myData->pObjects[pBrush->ihBrush].brushPattern;
            myData->pObjects[pBrush->ihBrush].brushPattern = new MYPATTERNBRUSH();

            if (myData->pObjects[pBrush->ihBrush].brushPattern != NULL)
            {
                BYTE *  data = new BYTE[pBrush->cbBmi + pBrush->cbBits];

                if (data != NULL)
                {
                    memcpy(data, ((BYTE *)pBrush) + pBrush->offBmi, pBrush->cbBmi);
                    memcpy(data + pBrush->cbBmi, ((BYTE *)pBrush) + pBrush->offBits, pBrush->cbBits);
                    myData->pObjects[pBrush->ihBrush].brushPattern->bmi = (BITMAPINFO *)data;
                    myData->pObjects[pBrush->ihBrush].brushPattern->bitsOffset = pBrush->cbBmi;
                }
                else
                {
                    delete myData->pObjects[pBrush->ihBrush].brushPattern;
                    myData->pObjects[pBrush->ihBrush].brushPattern = NULL;
                }
            }
        }
        break;

    case EMR_EXTCREATEPEN:
        {
            PEMREXTCREATEPEN        pPen = (PEMREXTCREATEPEN)lpEMFR;
            COLORREF                cRef = pPen->elp.elpColor;

            ASSERT((cRef & 0x01000000) == 0);

            ASSERT(pPen->ihPen < myData->numObjects);

            delete myData->pObjects[pPen->ihPen].brushPattern;
            myData->pObjects[pPen->ihPen].brushPattern = NULL;

            myData->pObjects[pPen->ihPen].type  = MYOBJECTS::PenObjectType;
            myData->pObjects[pPen->ihPen].color = Gdiplus::Color::MakeARGB(0xff,
                        GetRValue(cRef), GetGValue(cRef), GetBValue(cRef));

            myData->pObjects[pPen->ihPen].penWidth = pPen->elp.elpWidth;
        }
        break;

    case EMR_POLYTEXTOUTA:
        break;

    case EMR_POLYTEXTOUTW:
        break;

    case EMR_SETICMMODE:
    case EMR_CREATECOLORSPACE:
    case EMR_SETCOLORSPACE:
    case EMR_DELETECOLORSPACE:
    case EMR_GLSRECORD:
    case EMR_GLSBOUNDEDRECORD:
    case EMR_PIXELFORMAT:
        break;

    case EMR_DRAWESCAPE:
    case EMR_EXTESCAPE:
    case EMR_STARTDOC:
    case EMR_SMALLTEXTOUT:
    case EMR_FORCEUFIMAPPING:
    case EMR_NAMEDESCAPE:
    case EMR_COLORCORRECTPALETTE:
    case EMR_SETICMPROFILEA:
    case EMR_SETICMPROFILEW:
    case EMR_ALPHABLEND:
    case EMR_SETLAYOUT:
    case EMR_TRANSPARENTBLT:
    case EMR_GRADIENTFILL:
    case EMR_SETLINKEDUFIS:
    case EMR_SETTEXTJUSTIFICATION:
    case EMR_COLORMATCHTOTARGETW:
    case EMR_CREATECOLORSPACEW:
        break;
    }
}

BOOL StepRecord(
    Gdiplus::EmfPlusRecordType      recordType,
    UINT                            recordFlags,
    UINT                            recordDataSize,
    const BYTE *                    recordData,
    VOID *                          callbackData,
    HDC                             hDC = NULL,
    LPHANDLETABLE                   lpHTable = NULL,
    LPMETARECORD                    lpMFR = NULL,
    LPENHMETARECORD                 lpEMFR = NULL,
    int                             nObj = 0
    );

VOID ListRecord(
    Gdiplus::EmfPlusRecordType      recordType
    );

/***********************************************************************

  FUNCTION   : EnumMFIndirect

  PARAMETERS : HDC             hDC
               LPHANDLETABLE   lpHTable
               LPMETARECORD    lpMFR
               LPENHMETARECORD lpEMFR
               int             nObj
               LPARAM          lpData


  PURPOSE    : called by EnumMetaFile and EnumEnhMetaFile.  Handles the stepping of
               each metafile record.

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   : ENUMMFSTEP is used whenever records are to be played,
               regardless of whether you are playing records from the
               list, stepping all, or stepping a range.

               ENUMMFLIST is used when you need to add strings to a listbox
               that describe the type of reocrd.

  HISTORY    : created 7/1/93 - denniscr

************************************************************************/
using Gdiplus::EmfPlusRecordType;

int EnumMFIndirect(HDC hDC, LPHANDLETABLE lpHTable,
                            LPMETARECORD lpMFR,
                            LPENHMETARECORD lpEMFR,
                            int nObj, LPARAM lpData)
{
  BOOL DlgRet = TRUE;
  //
  // what is the enumeration action that we are taking?
  //
  switch (iEnumAction)
  {
    //
    //if the enumeration was entered ala the step metafile menu selection
    //
    case ENUMMFSTEP:
        if (bEnhMeta)
        {
            return StepRecord((EmfPlusRecordType)(lpEMFR->iType),
                              0, lpEMFR->nSize - sizeof(EMR),
                              (BYTE *)lpEMFR->dParm, (VOID *)lpData,
                              hDC, lpHTable, lpMFR, lpEMFR, nObj);
        }
        else
        {
            return StepRecord(GDIP_WMF_RECORD_TO_EMFPLUS(lpMFR->rdFunction),
                              0, ((LONG)lpMFR->rdSize * 2) - 6,
                              ((BYTE *)lpMFR) + 6, (VOID *)lpData,
                              hDC, lpHTable, lpMFR, lpEMFR, nObj);
        }

    case ENUMMFLIST:
        if (bEnhMeta)
        {
            ListRecord((Gdiplus::EmfPlusRecordType)lpEMFR->iType);
        }
        else
        {
            ListRecord(GDIP_WMF_RECORD_TO_EMFPLUS(lpMFR->rdFunction));
        }
        //
        //keep enumerating
        //
        return(1);
  }
  return 0;
}

/***********************************************************************

  FUNCTION   : ConvertEMFtoWMF

  PARAMETERS : HENHMETAFILE hEMF - handle to enhanced metafile
               LPSTR lpszFileName - filename of disked based metafile


  PURPOSE    : Convert an Windows metafile to an enhanced metafile

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   :

  HISTORY    : created 7/22/93 - denniscr

************************************************************************/

BOOL ConvertWMFtoEMF(HMETAFILE hmf, LPSTR lpszFileName)
{
  LPSTR        lpWinMFBits;
  UINT         uiSizeBuf;
  HENHMETAFILE hEnhMF;
  BOOL         bRet = TRUE;
  //
  //get the size of the Windows metafile associated with hMF
  //
  if ((uiSizeBuf = GetMetaFileBitsEx((HMETAFILE)hMF, 0, NULL)))
  {
    //
    //allocate enough memory to hold metafile bits
    //
    lpWinMFBits = (char *)GlobalAllocPtr(GHND, uiSizeBuf);
    //
    //get the bits of the Windows metafile associated with hMF
    //
    if (lpWinMFBits && GetMetaFileBitsEx((HMETAFILE)hMF, uiSizeBuf, (LPVOID)lpWinMFBits))
    {
      //
      //copy the bits into a memory based enhanced metafile
      //
      hEnhMF = SetWinMetaFileBits(uiSizeBuf, (LPBYTE)lpWinMFBits, NULL, NULL);
      //
      //copy the enhanced metafile to a disk based enhanced metafile
      //
      CopyEnhMetaFile(hEnhMF, lpszFileName);
      //
      //done with the memory base enhanced metafile so get rid of it
      //
      DeleteEnhMetaFile(hEnhMF);
      //
      //done with the actual memory used to store bits so nuke it
      //
      GlobalFreePtr(lpWinMFBits);
    }
    else
      bRet = FALSE;
  }
  else
    bRet = FALSE;
  return (bRet);
}

/***********************************************************************

  FUNCTION   : ConvertEMFtoWMF

  PARAMETERS : HENHMETAFILE hEMF - handle to enhanced metafile
               LPSTR lpszFileName - filename of disked based metafile


  PURPOSE    : Convert an enhanced metafile to an Windows metafile

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   :

  HISTORY    : created 7/22/93 - denniscr

************************************************************************/

BOOL ConvertEMFtoWMF(HDC hrefDC, HENHMETAFILE hEMF, LPSTR lpszFileName)
{
  LPSTR        lpEMFBits;
  UINT         uiSizeBuf;
  HMETAFILE    hWMF;
  BOOL         bRet = TRUE;
  DWORD        dwBytesWritten ;
  //
  //get the size of the Windows metafile associated with hMF
  //

  if ((uiSizeBuf = Gdiplus::Metafile::EmfToWmfBits(hemf, 0, NULL, MM_ANISOTROPIC,
        Gdiplus::EmfToWmfBitsFlagsIncludePlaceable)))
  {
    //
    //allocate enough memory to hold metafile bits
    //
    lpEMFBits = (LPSTR)GlobalAllocPtr(GHND, uiSizeBuf);
    //
    //get the bits of the enhanced metafile associated with hEMF
    //
    if (lpEMFBits && Gdiplus::Metafile::EmfToWmfBits(hEMF, uiSizeBuf,(LPBYTE)lpEMFBits,
         MM_ANISOTROPIC, Gdiplus::EmfToWmfBitsFlagsIncludePlaceable))

    {
        // Create a file and dump the metafile bits into it
        HANDLE hFile = CreateFile(lpszFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
        if(hFile != INVALID_HANDLE_VALUE)
        {
            WriteFile( hFile, (LPCVOID) lpEMFBits, uiSizeBuf, &dwBytesWritten, NULL ) ;
            CloseHandle(hFile);
        }

/*
        //
        //copy the bits into a memory based Windows metafile
        //
        hWMF = SetMetaFileBitsEx(uiSizeBuf, (LPBYTE)lpEMFBits);
        //
        //copy the Windows metafile to a disk based Windows metafile
        //
        CopyMetaFile(hWMF, lpszFileName);
        //
        //done with the memory base enhanced metafile so get rid of it
        //
        DeleteMetaFile((HMETAFILE)hMF);
*/
        //
        //done with the actual memory used to store bits so nuke it
        //
        GlobalFreePtr(lpEMFBits);
    }
    else
      bRet = FALSE;
  }
  else
    bRet = FALSE;
  return (bRet);
}

BOOL StepRecord(
    Gdiplus::EmfPlusRecordType      recordType,
    UINT                            recordFlags,
    UINT                            recordDataSize,
    const BYTE *                    recordData,
    VOID *                          callbackData,
    HDC                             hDC,
    LPHANDLETABLE                   lpHTable,
    LPMETARECORD                    lpMFR,
    LPENHMETARECORD                 lpEMFR,
    int                             nObj
    )
{
    //
    //keep track of the current metafile record number
    //
    iRecNum++;

    //
    //allocate memory for the record.  this memory will be used by
    //other functions that need to use the contents of the record
    //
    hMem = GlobalAlloc(GPTR /*GHND*/, (bEnhMeta) ? sizeof(EMR) + recordDataSize :
                                                   6 + recordDataSize);
    //
    //if the memory was successfully allocated
    //
    if (hMem)
    {
        BOOL DlgRet = TRUE;

        if (bEnhMeta)
        {
            //
            //obtain a long pointer to this memory
            //
            if ((lpEMFParams = (LPEMFPARAMETERS)GlobalLock(hMem)) == NULL)
            {
                //
                //we were unable to allocate memory for the record
                //
                MessageBox(hWndMain, "Memory allocation failed",
                            NULL, MB_OK | MB_ICONHAND);
            }
            else
            {
                //
                //copy the contents of the record to the global memory
                //
                emfMetaRec.nSize = sizeof(EMR) + recordDataSize;
                emfMetaRec.iType = recordType;
                unsigned long i;
                for (i = 0;(DWORD)i < recordDataSize / sizeof(DWORD); i++)
                {
                    *lpEMFParams++ = ((DWORD *)recordData)[i];
                }
            }
        }
        else
        {
            /* obtain a long pointer to this memory */
            lpMFParams = (LPPARAMETERS)GlobalLock(hMem);

            /* copy the contents of the record to the global memory */
            MetaRec.rdSize = (6 + recordDataSize) / 2;
            MetaRec.rdFunction = GDIP_EMFPLUS_RECORD_TO_WMF(recordType);
            DWORD i;
            for (i = 0; (DWORD)i < (recordDataSize / 2); i++)
            {
                *lpMFParams++ = ((WORD *)recordData)[i];
            }
        }
        GlobalUnlock(hMem);
        //
        //if STEPPING through metafile records that have been selected
        //by selecting the menu options Play - Step - All, Play - Step -
        //Range, or selecting records from the View - List listbox
        //
        if ( !bPlayItAll
            || ( bEnumRange && iRecNum >= (WORD)iStartRange && iRecNum <= (WORD)iEndRange )
            || ( bPlayList && !bPlayItAll ) )
        {
            //
            //if playing records selected from the View - List
            //listbox of records
            if (bPlayList)
            {
                //
                //if playing the selected records
                //
                if (bPlaySelList)
                {
                    //
                    //if done playing the selected records then stop the enumeration
                    //
                    if (iCount == iNumSel)
                    {
                        return(0);
                    }

                    //
                    //if this is a selected record then play it
                    //
                    if ((WORD)lpSelMem[iCount] == iRecNum - 1)
                    {
                        //
                        //initialize flag
                        //
                        bPlayRec = FALSE;
                        //
                        //increment the count
                        //
                        iCount = (iCount < iLBItemsInBuf) ? ++iCount : iCount;
                        //
                        //call the dialog box that lets you play or ignore this record */
                        //
                        DlgRet = (BOOL) DialogBox((HINSTANCE)hInst, (LPSTR)"WMFDLG", hWndMain, WMFRecDlgProc);
                    }
                    else
                    {
                        //
                        //initialize flag and do nothing else
                        //
                        bPlayRec = FALSE;
                    }
                }
                //
                //playing the unselected records
                //
                else
                {
                    //
                    //if this is one of the selected records then increment
                    //the record count and init a flag but do nothing else
                    //
                    if ((WORD)lpSelMem[iCount] == iRecNum - 1)
                    {
                        //
                        //set count to next selected record in listbox
                        //
                        iCount = (iCount < iLBItemsInBuf) ? ++iCount : iCount;
                        bPlayRec = FALSE;
                    }
                    //
                    //this is not one of the selected records which is what we
                    //want in this case.  So, init a flag give the user the
                    //opportunity to play the record
                    //
                    else
                    {
                        bPlayRec = FALSE;
                        DlgRet = (BOOL) DialogBox((HINSTANCE)hInst, (LPSTR)"WMFDLG", hWndMain, WMFRecDlgProc);
                    }
                }

            } //bPlayList
            //
            //stepping records from the Play - Step menu option
            //
            else
            {
                //
                //init a flag and show the record contents
                //
                bPlayRec = FALSE;
                iCount = (iCount < iLBItemsInBuf) ? ++iCount : iCount;
                DlgRet = (BOOL) DialogBox((HINSTANCE)hInst, (LPSTR)"WMFDLG", hWndMain, WMFRecDlgProc);
            }
        } //end of STEPPING the metafile
        //
        //bPlayItAll is TRUE.  This is set when the user either
        //selects the menu option Play - All or pushes the GO button
        //in the view record dialog box
        //
        else
        {
            //
            //we were stepping records selected from the listbox and
            //the user pressed the GO button
            //
            //Don't bother returning 0 to stop enumeration.  We need to
            //play to the end of the metafile in this case anyway
            //
            if (bPlayList)
            {
                //
                //we were playing the selected records
                //
                if (bPlaySelList)
                {
                    //
                    //if all of the selected records have been played then
                    //stop the enumeration
                    //
                    if (iCount == iNumSel)
                    {
                        return(0);
                    }
                    //
                    //set bPlayRec so the record will be played without user
                    //interation and then update the record counter
                    //
                    if ((WORD)lpSelMem[iCount] == iRecNum - 1)
                    {
                        bPlayRec = TRUE;
                        iCount = (iCount < iLBItemsInBuf) ? ++iCount : iCount;
                    }
                    else
                    //
                    //it wasn't one of the selected records so don't play
                    //
                    {
                        bPlayRec = FALSE;
                    }
                }
                //
                //we were playing the unselected records
                //
                else
                {
                    //
                    //if it is a selected record then set bPlayRec to FALSE
                    //so the record is not played
                    //
                    if ((WORD)lpSelMem[iCount] == iRecNum - 1)
                    {
                        bPlayRec = FALSE;
                        iCount = (iCount < iLBItemsInBuf) ? ++iCount : iCount;
                    }
                    else
                    {
                        //
                        //play the record
                        //
                        bPlayRec = TRUE;
                    }
                }
            } //bPlayList
        } //GO button pushed
        //
        //Stop the enumeration if you were stepping a range and have
        //finished playing that range OR the user selected pushed
        //the STOP button in the view record dialog box
        //
        if ( ((bEnumRange) && (iRecNum > (WORD)iEndRange)) || (!DlgRet) )
        {
            bPlayRec = FALSE;
            //
            //stop enumeration
            //
            return(0);
        }

    } //if (hMem)
    else
    //
    //we were unable to allocate memory for the record
    //
    {
        MessageBox(hWndMain, "Memory allocation failed",
                        NULL, MB_OK | MB_ICONHAND);
    }
    //
    //Regardless of the method the user elected to play the
    //records, check the flag.  If it is set then play the
    //record
    //
    if (bPlayRec)
    {
        if (bUseGdiPlusToPlay)
        {
            ((MYDATA *)callbackData)->metafile->PlayRecord(recordType, recordFlags, recordDataSize, recordData);
        }
        else if (bEnhMeta)
        {
            if (bConvertToGdiPlus)
            {
                GpPlayEnhMetaFileRecord(hDC, lpHTable, lpEMFR, (UINT)nObj, (LPARAM)callbackData);
            }
            else
            {
                PlayEnhMetaFileRecord(hDC, lpHTable, lpEMFR, (UINT)nObj);
            }
        }
        else if(!PlayMetaFileRecord(hDC, lpHTable, lpMFR, (UINT)nObj))
        {
            ASSERT(FALSE);
        }
    }
    //
    //done with the record so get rid of it
    //
    GlobalFree(hMem);
    //
    //if we made it this far then continue the enumeration
    //
    return(1);
}


VOID ListRecord(
    Gdiplus::EmfPlusRecordType      recordType
    )
{
  char szMetaFunction[100];

   iRecNum++;
   //
   //format the listbox string
   //
   wsprintf((LPSTR)szMetaFunction, (LPSTR)"%d - ", iRecNum);
   //
   //get the function number contained in the record
   //
   if (bEnhMeta)
     emfMetaRec.iType = recordType;
   else
     MetaRec.rdFunction = GDIP_EMFPLUS_RECORD_TO_WMF(recordType);

   //
   //lookup the function number in the structure MetaFunctions
   //
   int i;
   if (bEnhMeta)
   {
       for (i = NUMMETAFUNCTIONS; i < NUMENHMETARECORDS; i++)
       {
           if (recordType == (INT)emfMetaRecords[i].iType)
             break;
       }
   }
   else // WMF
   {
       for (i = 0; i < NUMMETAFUNCTIONS; i++)
       {
           if (recordType == (INT)emfMetaRecords[i].iType)
             break;
       }
   }

   //
   //if the function number is not found then describe this record
   //as an "Unknown" type otherwise use the corresponding name
   //found in the lookup
   //
   if (recordType != (INT)emfMetaRecords[i].iType)
     lstrcat((LPSTR)szMetaFunction, (LPSTR)"Unknown");
   else
     lstrcat((LPSTR)szMetaFunction,(LPSTR)emfMetaRecords[i].szRecordName);
   //
   //add the string to the listbox
   //
   SendDlgItemMessage((HWND)CurrenthDlg, IDL_LBREC, LB_ADDSTRING, 0,
                      (LPARAM)(LPSTR)szMetaFunction);
}

extern "C"
BOOL CALLBACK
PlayGdipMetafileRecordCallback(
    Gdiplus::EmfPlusRecordType      recordType,
    UINT                            recordFlags,
    UINT                            recordDataSize,
    const BYTE *                    recordData,
    VOID *                          callbackData
    )
{
    switch (iEnumAction)
    {
    case ENUMMFSTEP:
        return StepRecord(recordType, recordFlags, recordDataSize, recordData, callbackData);

    case ENUMMFLIST:
        ListRecord(recordType);
        break;
    }
    return TRUE;
}

/***********************************************************************

  FUNCTION   : GetMetaFileAndEnum

  PARAMETERS : HDC hDC

  PURPOSE    : load the metafile if it has not already been loaded and
               begin enumerating it

  CALLS      : WINDOWS
                 GetMetaFile
                 MakeProcInstance
                 EnumMetaFile
                 FreeProcInstance
                 DeleteMetaFile
                 MessageBox

  MESSAGES   : none

  RETURNS    : void

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc
               7/1/93 - modified to work with EMFs - denniscr

************************************************************************/
extern "C"
void GetMetaFileAndEnum(
HWND hwnd,
HDC hDC,
int iAction)
{
   MYDATA  myData(hwnd);

   iEnumAction = iAction;
   //
   //if this is an enhanced metafile (emf)
   //
   RECT rc;
   GetClientRect(hWndMain, &rc);

   HPALETTE hpal = NULL;

   if (bEnhMeta)
   {

     if (hemf)
     {
       LPLOGPALETTE lpLogPal;
       HPALETTE hPal;
       int i;
       //
       //allocate memory for the logical palette including the array of
       //palette entries
       //
       lpLogPal = (LPLOGPALETTE) GlobalAllocPtr( GHND,  sizeof(LOGPALETTE) +
                                               (sizeof (PALETTEENTRY) * EmfPtr.palNumEntries));
       if (lpLogPal)
       {
         //
         //proceed only if there is a valid ptr to logical palette
         //and a palette array obtained from the emf
         //
         if (EmfPtr.lpPal)
         {
           lpLogPal->palVersion = 0x300;
           lpLogPal->palNumEntries = EmfPtr.palNumEntries;
           //
           //copy palette entries into palentry array
           //
           for (i = 0; i < EmfPtr.palNumEntries; i++)
             lpLogPal->palPalEntry[i] = *EmfPtr.lpPal++;
           //
           //reposition the ptr back to the beginning should we call this
           //code again
           //
           EmfPtr.lpPal -= EmfPtr.palNumEntries;
           //
           //create, select and realize the palette
           //
           if ((hPal = CreatePalette((LPLOGPALETTE)lpLogPal)))
           {
             SelectPalette(hDC, hPal, FALSE);
             RealizePalette(hDC);
           }
         }

        if (bUseGdiPlusToPlay)
        {
            // Select in the halftone palette for 256-color display mode testing
            hpal = Gdiplus::Graphics::GetHalftonePalette();
            SelectPalette(hDC, hpal, FALSE);
            RealizePalette(hDC);

            // Need to delete this before returning;
            myData.g = Gdiplus::Graphics::FromHDC(hDC);
myData.g->SetPixelOffsetMode(Gdiplus::PixelOffsetModeHalf);
myData.g->SetInterpolationMode(Gdiplus::InterpolationModeNearestNeighbor);
        }

         //
         //enumerate the EMF.  this is a bit odd simply because PlayEnhMetaFile
         //really obviates the need for doing this (this cannot be said for WMFs).
         //this app does it simply because it may be stepping the metafile records.
         //Most apps are generally not concerned about doing this.
         //
        if (bUseGdiPlusToPlay && (myData.g != NULL))
        {
            Gdiplus::Metafile m1(hemf);
            Gdiplus::Rect r1(rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top);
            myData.metafile = &m1;
            if(myData.g->EnumerateMetafile(&m1, r1, PlayGdipMetafileRecordCallback, &myData) != Gdiplus::Ok)
                MessageBox(NULL, "An Error Occured while playing this metafile", "Error", MB_OK | MB_ICONERROR);
            myData.metafile = NULL;
        }
        else
        {
            // the rect needs to be inclusive-inclusive!!!
            rc.right--;
            rc.bottom--;
            if(!EnumEnhMetaFile(hDC, hemf, (ENHMFENUMPROC)EnhMetaFileEnumProc, (void*)&myData, &rc))
                MessageBox(NULL, "Error", "An Error Occured while playing this metafile", MB_OK | MB_ICONERROR);
        }

         //
         //free palette memory
         //
         GlobalFreePtr(lpLogPal);
       }
     }
   }
   else
   {
     //
     //if there is a valid handle to a metafile begin enumerating it
     //
     if (hMF)
     {
        if (bUseGdiPlusToPlay)
        {
            // Select in the halftone palette for 256-color display mode testing
            hpal = Gdiplus::Graphics::GetHalftonePalette();
            SelectPalette(hDC, hpal, FALSE);
            RealizePalette(hDC);

            // Need to delete this before returning;
            myData.g = Gdiplus::Graphics::FromHDC(hDC);
        }

        if (bUseGdiPlusToPlay && (myData.g != NULL))
        {
            Gdiplus::WmfPlaceableFileHeader * wmfPlaceableFileHeader = NULL;

            if (bPlaceableMeta)
            {
                wmfPlaceableFileHeader = (Gdiplus::WmfPlaceableFileHeader *)&placeableWMFHeader;
            }

            Gdiplus::Metafile m1((HMETAFILE)hMF, wmfPlaceableFileHeader);
            Gdiplus::Rect r1(rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top);
            myData.metafile = &m1;
            if (myData.g->EnumerateMetafile(&m1, r1, PlayGdipMetafileRecordCallback, &myData) != Gdiplus::Ok)
                MessageBox(NULL, "An Error Occured while playing this metafile", "Error", MB_OK | MB_ICONERROR);
            myData.metafile = NULL;
        }
        else
        {
            if (!EnumMetaFile(hDC, (HMETAFILE)hMF, (MFENUMPROC) MetaEnumProc, (LPARAM) 0))
                MessageBox(NULL, "An Error Occured while playing this metafile", "Error", MB_OK | MB_ICONERROR);
        }
     }
     else
       MessageBox(hWndMain, "Invalid metafile handle",
                  NULL, MB_OK | MB_ICONHAND);
   }

    if (myData.g != NULL )
    {
        SelectObject(hDC, GetStockObject(DEFAULT_PALETTE));
        DeleteObject(hpal);
        myData.g->Flush();
        delete myData.g;
        myData.g = NULL;
    }

   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\fonttest\precomp.hpp ===
#include <windows.h>
#include <objbase.h>
#include <math.h>             // sin & cos

//
// Where is IStream included from?
//

#define IStream int

#include "gdiplus.h"
using namespace Gdiplus;

#define DG_NOGDI            4

#define MAX_GLYPH_COUNT       100

//copy from winddi.h

typedef ULONG       HGLYPH;
typedef LONG        FIX;

// point in the 32.32 bit precission

typedef struct _POINTQF    // ptq
{
    LARGE_INTEGER x;
    LARGE_INTEGER y;
} POINTQF, *PPOINTQF;

typedef struct _GLYPHBITS
{
    POINTL      ptlOrigin;
    SIZEL       sizlBitmap;
    BYTE        aj[1];
} GLYPHBITS;

typedef union _GLYPHDEF
{
    GLYPHBITS  *pgb;
//    PATHOBJ    *ppo;
    PVOID       *ppo;
} GLYPHDEF;

typedef struct _GLYPHDATA {
        GLYPHDEF gdf;
        HGLYPH   hg;
        FIX      fxD;
        FIX      fxA;
        FIX      fxAB;
        FIX      fxInkTop;
        FIX      fxInkBottom;
        RECTL    rclInk;
        POINTQF  ptqD;
} GLYPHDATA;

typedef GpStatus (*FN_GDIPDRAWGLYPHS)(GpGraphics*, UINT16*, INT, GpFont*, GpBrush*, INT*, INT*, INT);
typedef GpStatus (*FN_GDIPPATHADDGLYPHS)(GpPath*, UINT16*, INT, GpFont*, REAL*, REAL*, INT);
typedef GpStatus (*FN_GDIPSETTEXTRENDERINGHINT)(GpGraphics *graphics, TextRenderingHint mode);


enum AddFontFlag
{
	AddFontFlagPublic = 0,
	AddFontFlagNotEnumerate = 1
};


// globals
extern HINSTANCE ghInst;
extern HWND ghWndMain;
extern HWND ghWndList;
extern HBRUSH ghbrWhite;
extern HINSTANCE ghGdiplus;
extern Font *gFont;
extern FN_GDIPDRAWGLYPHS gfnGdipDrawGlyphs;
extern FN_GDIPPATHADDGLYPHS gfnGdipPathAddGlyphs;
extern FN_GDIPSETTEXTRENDERINGHINT gfnGdipSetTextRenderingHint;

void Dbgprintf(PCH msg, ...);
void CreateNewFont(char*, FLOAT, FontStyle, Unit);
void TestDrawGlyphs(HWND hwnd, UINT16 *glyphIndices, INT count, INT *px, INT *py, INT flags);
void TestPathGlyphs(HWND hwnd, UINT16 *glyphIndices, INT count, REAL *px, REAL *py, INT flags);

void TestAddFontFile(CHAR* fileName, INT flag, BOOL loasAsImage);
void TestRemoveFontFile(char* fileName);
void TestTextAntiAliasOn();
void TestTextAntiAliasOff();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\emfdcode\wmfprint.cpp ===
/***********************************************************************

  MODULE     : WMFPRINT.C

  FUNCTIONS  : PrintWMF
               GetPrinterDC
               AbortProc
               AbortDlg

  COMMENTS   :

************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <objbase.h>
extern "C" {
#include "mfdcod32.h"
}
extern "C" {
  extern BOOL bConvertToGdiPlus;
  extern BOOL bUseGdiPlusToPlay;
}

#include "GdiPlus.h"

int PrintToGdiPlus(HDC hdc, RECT * rc)
{
    // 'rc' is device co-ordinates of rectangle.
    // Convert to world space.

    if (bEnhMeta) 
    {
        Gdiplus::Metafile m1(hemf);
        Gdiplus::Rect r1(rc->left, rc->top, rc->right - rc->left, rc->bottom - rc->top);
        Gdiplus::Graphics g(hdc);
        g.SetPageUnit(Gdiplus::UnitPixel);
    
        if(g.DrawImage(&m1, r1) != Gdiplus::Ok)
            MessageBox(NULL, "An Error Occured while printing metafile with GDI+", "Error", MB_OK | MB_ICONERROR);
    }
    else
    {
        Gdiplus::Metafile m1((HMETAFILE)hMF, NULL);
        Gdiplus::Rect r1(rc->left, rc->top, rc->right - rc->left, rc->bottom - rc->top);
        Gdiplus::Graphics g(hdc);
        g.SetPageUnit(Gdiplus::UnitPixel);
    
        if(g.DrawImage(&m1, r1) != Gdiplus::Ok)
            MessageBox(NULL, "An Error Occured while printing metafile with GDI+", "Error", MB_OK | MB_ICONERROR);
    }

    return 1;
}

extern BOOL bUseGdiPlusToPlay;

PRINTDLG pd;

/***********************************************************************

  FUNCTION   : PrintWMF

  PARAMETERS : void

  PURPOSE    : draw the metafile on a printer dc

  CALLS      : WINDOWS
                 wsprintf
                 MessageBox
                 MakeProcInstance
                 Escape
                 CreateDialog
                 SetMapMode
                 SetViewportOrg
                 SetViewportExt
                 EnableWindow
                 PlayMetaFile
                 DestroyWindow
                 DeleteDC

               APP
                 WaitCursor
                 GetPrinterDC
                 SetPlaceableExts
                 SetClipMetaExts

  MESSAGES   : none

  RETURNS    : BOOL - 0 if unable to print 1 if successful

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc
               7/9/93 - modified for win32 and emf

************************************************************************/

BOOL PrintWMF(BOOL Dialog)
{
    char str[50];
    POINT lpPT;
    SIZE  lpSize;
    DOCINFO di;
    RECT rc;

    memset(&di, 0, sizeof(di));
    
    //
    //display the hourglass cursor
    //
    
    WaitCursor(TRUE);
    
    //
    //get a DC for the printer
    //
    
    hPr = (HDC)GetPrinterDC(Dialog);
    
    //
    //if a DC could not be created then report the error and return
    //
    
    if (!hPr)
    {
        WaitCursor(FALSE);
        wsprintf((LPSTR)str, "Cannot print %s", (LPSTR)fnameext);
        MessageBox(hWndMain, (LPSTR)str, NULL, MB_OK | MB_ICONHAND);
        return (FALSE);
    }
    
    //
    //define the abort function
    //
    
    SetAbortProc(hPr, AbortProc);
    
    //
    //Initialize the members of a DOCINFO structure.
    //
    
    di.cbSize = sizeof(DOCINFO);
    di.lpszDocName = (bEnhMeta) ? "Print EMF" : "Print WMF";
    di.lpszOutput = (LPTSTR) NULL;
    
    //
    //Begin a print job by calling the StartDoc
    //function.
    //
    
    if (SP_ERROR == (StartDoc(hPr, &di)))
    {
        //if (Escape(hPr, STARTDOC, 4, "Metafile", (LPSTR) NULL) < 0)  {
        MessageBox(hWndMain, "Unable to start print job",
                   NULL, MB_OK | MB_ICONHAND);
        DeleteDC(hPr);
        return (FALSE);
    }
    
    //
    //clear the abort flag
    //
    
    bAbort = FALSE;
    
    //
    //Create the Abort dialog box (modeless)
    //
    
    hAbortDlgWnd = CreateDialog((HINSTANCE)hInst, "AbortDlg", hWndMain, AbortDlg);
    
    //
    //if the dialog was not created report the error
    //
    
    if (!hAbortDlgWnd)
    {
        WaitCursor(FALSE);
        MessageBox(hWndMain, "NULL Abort window handle",
                   NULL, MB_OK | MB_ICONHAND);
        return (FALSE);
    }
    
    //
    //show Abort dialog
    //
    
    ShowWindow (hAbortDlgWnd, SW_NORMAL);
    
    //
    //disable the main window to avoid reentrancy problems
    //
    
    EnableWindow(hWndMain, FALSE);
    WaitCursor(FALSE);
    
    //
    //if we are still committed to printing
    //

    if (!bAbort)
    {
        if (!bUseGdiPlusToPlay) 
        {
            //
            //if this is a placeable metafile then set its origins and extents
            //
            
            if (bPlaceableMeta)
                SetPlaceableExts(hPr, placeableMFHeader, WMFPRINTER);
            
            //
            //if this is a metafile contained within a clipboard file then set
            //its origins and extents accordingly
            //
            
            if ( (bMetaInRam) && (!bplaceableMeta) )
                SetClipMetaExts(hPr, lpMFP, lpOldMFP, WMFPRINTER);
        }
      
      //
      //if this is a "traditional" windows metafile
      //
      rc.left = 0;
      rc.top = 0;
      rc.right = GetDeviceCaps(hPr, HORZRES);
      rc.bottom = GetDeviceCaps(hPr, VERTRES);

      if (!bMetaInRam)
      {
          SetMapMode(hPr, MM_TEXT);
          SetViewportOrgEx(hPr, 0, 0, &lpPT);
          
          //
          //set the extents to the driver supplied values for horizontal
          //and vertical resolution
          //
          
          SetViewportExtEx(hPr, rc.right, rc.bottom, &lpSize );
      }

      //
      //play the metafile directly to the printer.
      //No enumeration involved here
      //

      if (bUseGdiPlusToPlay) 
      {
          PrintToGdiPlus(hPr, &rc);
      }
      else
      {
          if (bEnhMeta)
          {
              DPtoLP(hPr, (LPPOINT)&rc, 2);
              PlayEnhMetaFile(hPr, hemf, &rc);
          }
          else
              PlayMetaFile(hPr, (HMETAFILE)hMF);
      }
    }
    
    //
    //eject page and end the print job
    //
    Escape(hPr, NEWFRAME, 0, 0L, 0L);

    EndDoc(hPr);

    EnableWindow(hWndMain, TRUE);
    
    //
    //destroy the Abort dialog box
    //
    DestroyWindow(hAbortDlgWnd);

    DeleteDC(hPr);

    return(TRUE);
}

/***********************************************************************

  FUNCTION   : GetPrinterDC

  PARAMETERS : BOOL: Do we want to show a print DLG?

  PURPOSE    : Get hDc for current device on current output port according
               to info in WIN.INI.

  CALLS      : WINDOWS
                 GetProfileString
                 AnsiNext
                 CreateDC

  MESSAGES   : none

  RETURNS    : HANDLE - hDC > 0 if success  hDC = 0 if failure

  COMMENTS   : Searches WIN.INI for information about what printer is
               connected, and if found, creates a DC for the printer.

  HISTORY    : 1/16/91 - created - denniscr

************************************************************************/

HANDLE GetPrinterDC(BOOL Dialog)
{

  memset(&pd, 0, sizeof(PRINTDLG));
  pd.lStructSize = sizeof(PRINTDLG);
  pd.Flags = PD_RETURNDC | (Dialog?0:PD_RETURNDEFAULT);
  pd.hwndOwner = hWndMain ;
  return ((PrintDlg(&pd) != 0) ? pd.hDC : NULL);
}

/***********************************************************************

  FUNCTION   : AbortProc

  PARAMETERS : HDC hPr - printer DC
               int Code - printing status

  PURPOSE    : process messages for the abort dialog box

  CALLS      : WINDOWS
                 PeekMessage
                 IsDialogMessage
                 TranslateMessage
                 DispatchMessage

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   :

  HISTORY    : 1/16/91 - created - denniscr

************************************************************************/

BOOL CALLBACK AbortProc(HDC hPr, int Code)
{
  MSG msg;
  //
  //Process messages intended for the abort dialog box
  //
  while (!bAbort && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
      if (!IsDialogMessage(hAbortDlgWnd, &msg))
      {
          TranslateMessage(&msg);
          DispatchMessage(&msg);
      }
  //
  //bAbort is TRUE (return is FALSE) if the user has aborted
  //
  return (!bAbort);
}

/***********************************************************************

  FUNCTION   : AbortDlg

  PARAMETERS : HWND hDlg;
               unsigned msg;
               WORD wParam;
               LONG lParam;

  PURPOSE    : Processes messages for printer abort dialog box

  CALLS      : WINDOWS
                 SetFocus

  MESSAGES   : WM_INITDIALOG - initialize dialog box
               WM_COMMAND    - Input received

  RETURNS    : BOOL

  COMMENTS   : This dialog box is created while the program is printing,
               and allows the user to cancel the printing process.

  HISTORY    : 1/16/91 - created - denniscr

************************************************************************/

INT_PTR CALLBACK AbortDlg(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        //
        //Watch for Cancel button, RETURN key, ESCAPE key, or SPACE BAR
        //
        case WM_INITDIALOG:
            //
            //Set the focus to the Cancel box of the dialog
            //
            SetFocus(GetDlgItem(hDlg, IDCANCEL));
            return (TRUE);

        case WM_COMMAND:
            return (bAbort = TRUE);

        }
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\emfdcode\wmfprint.c ===
/***********************************************************************

  MODULE     : WMFPRINT.C

  FUNCTIONS  : PrintWMF
               GetPrinterDC
               AbortProc
               AbortDlg

  COMMENTS   :

************************************************************************/

#include "windows.h"
#include "mfdcod32.h"

PRINTDLG pd;

/***********************************************************************

  FUNCTION   : PrintWMF

  PARAMETERS : void

  PURPOSE    : draw the metafile on a printer dc

  CALLS      : WINDOWS
                 wsprintf
                 MessageBox
                 MakeProcInstance
                 Escape
                 CreateDialog
                 SetMapMode
                 SetViewportOrg
                 SetViewportExt
                 EnableWindow
                 PlayMetaFile
                 DestroyWindow
                 DeleteDC

               APP
                 WaitCursor
                 GetPrinterDC
                 SetPlaceableExts
                 SetClipMetaExts

  MESSAGES   : none

  RETURNS    : BOOL - 0 if unable to print 1 if successful

  COMMENTS   :

  HISTORY    : 1/16/91 - created - drc
               7/9/93 - modified for win32 and emf

************************************************************************/

BOOL PrintWMF(BOOL Dialog)
{
  char str[50];
  POINT lpPT;
  SIZE  lpSize;
  DOCINFO di;
  RECT rc;
  //
  //display the hourglass cursor
  //
  WaitCursor(TRUE);
  //
  //get a DC for the printer
  //
  hPr = GetPrinterDC(Dialog);
  //
  //if a DC could not be created then report the error and return
  //
  if (!hPr)
  {
    WaitCursor(FALSE);
    wsprintf((LPSTR)str, "Cannot print %s", (LPSTR)fnameext);
    MessageBox(hWndMain, (LPSTR)str, NULL, MB_OK | MB_ICONHAND);
    return (FALSE);
  }
  //
  //define the abort function
  //
  SetAbortProc(hPr, AbortProc);
  //
  //Initialize the members of a DOCINFO structure.
  //
  memset(&di, 0, sizeof(di));
  di.cbSize = sizeof(DOCINFO);
  di.lpszDocName = (bEnhMeta) ? "Print EMF" : "Print WMF";
  di.lpszOutput = (LPTSTR) NULL;
  //
  //Begin a print job by calling the StartDoc
  //function.
  //
  if (SP_ERROR == (StartDoc(hPr, &di)))
  {
  //if (Escape(hPr, STARTDOC, 4, "Metafile", (LPSTR) NULL) < 0)  {
    MessageBox(hWndMain, "Unable to start print job",
               NULL, MB_OK | MB_ICONHAND);
    DeleteDC(hPr);
  }
  //
  //clear the abort flag
  //
  bAbort = FALSE;
  //
  //Create the Abort dialog box (modeless)
  //
  hAbortDlgWnd = CreateDialog(hInst, "AbortDlg", hWndMain, AbortDlg);
  //
  //if the dialog was not created report the error
  //
  if (!hAbortDlgWnd)
  {
    WaitCursor(FALSE);
    MessageBox(hWndMain, "NULL Abort window handle",
               NULL, MB_OK | MB_ICONHAND);
    return (FALSE);
  }
  //
  //show Abort dialog
  //
  ShowWindow (hAbortDlgWnd, SW_NORMAL);
  //
  //disable the main window to avoid reentrancy problems
  //
  EnableWindow(hWndMain, FALSE);
  WaitCursor(FALSE);
  //
  //if we are still committed to printing
  //
  if (!bAbort)
  {
    //
    //if this is a placeable metafile then set its origins and extents
    //
    if (bPlaceableMeta)
        SetPlaceableExts(hPr, placeableWMFHeader, WMFPRINTER);
    //
    //if this is a metafile contained within a clipboard file then set
    //its origins and extents accordingly
    //
    if ( (bMetaInRam) && (!bPlaceableMeta) )
    SetClipMetaExts(hPr, lpMFP, lpOldMFP, WMFPRINTER);
    //
    //if this is a "traditional" windows metafile
    //
    rc.left = 0;
    rc.top = 0;
    rc.right = GetDeviceCaps(hPr, HORZRES);
    rc.bottom = GetDeviceCaps(hPr, VERTRES);

    if (!bMetaInRam)
    {
      SetMapMode(hPr, MM_TEXT);
      SetViewportOrgEx(hPr, 0, 0, &lpPT);
      //
      //set the extents to the driver supplied values for horizontal
      //and vertical resolution
      //
      SetViewportExtEx(hPr, rc.right, rc.bottom, &lpSize );
    }
    //
    //play the metafile directly to the printer.
    //No enumeration involved here
    //
    if (bEnhMeta)
    {
      DPtoLP(hPr, (LPPOINT)&rc, 2);
      PlayEnhMetaFile(hPr, hemf, &rc);
    }
    else
      PlayMetaFile(hPr, hMF);
  }
  //
  //eject page and end the print job
  //
  Escape(hPr, NEWFRAME, 0, 0L, 0L);

  EndDoc(hPr);

  EnableWindow(hWndMain, TRUE);
  //
  //destroy the Abort dialog box
  //
  DestroyWindow(hAbortDlgWnd);

  DeleteDC(hPr);

  return(TRUE);
}

/***********************************************************************

  FUNCTION   : GetPrinterDC

  PARAMETERS : BOOL: Do we want to show a print DLG?

  PURPOSE    : Get hDc for current device on current output port according
               to info in WIN.INI.

  CALLS      : WINDOWS
                 GetProfileString
                 AnsiNext
                 CreateDC

  MESSAGES   : none

  RETURNS    : HANDLE - hDC > 0 if success  hDC = 0 if failure

  COMMENTS   : Searches WIN.INI for information about what printer is
               connected, and if found, creates a DC for the printer.

  HISTORY    : 1/16/91 - created - denniscr

************************************************************************/

HANDLE GetPrinterDC(BOOL Dialog)
{

  memset(&pd, 0, sizeof(PRINTDLG));
  pd.lStructSize = sizeof(PRINTDLG);
  pd.Flags = PD_RETURNDC | (Dialog?0:PD_RETURNDEFAULT);
  pd.hwndOwner = hWndMain ;
  return ((PrintDlg(&pd) != 0) ? pd.hDC : NULL);
}

/***********************************************************************

  FUNCTION   : AbortProc

  PARAMETERS : HDC hPr - printer DC
               int Code - printing status

  PURPOSE    : process messages for the abort dialog box

  CALLS      : WINDOWS
                 PeekMessage
                 IsDialogMessage
                 TranslateMessage
                 DispatchMessage

  MESSAGES   : none

  RETURNS    : int

  COMMENTS   :

  HISTORY    : 1/16/91 - created - denniscr

************************************************************************/

BOOL CALLBACK AbortProc(HDC hPr, int Code)
{
  MSG msg;
  //
  //Process messages intended for the abort dialog box
  //
  while (!bAbort && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
      if (!IsDialogMessage(hAbortDlgWnd, &msg))
      {
          TranslateMessage(&msg);
          DispatchMessage(&msg);
      }
  //
  //bAbort is TRUE (return is FALSE) if the user has aborted
  //
  return (!bAbort);
}

/***********************************************************************

  FUNCTION   : AbortDlg

  PARAMETERS : HWND hDlg;
               unsigned msg;
               WORD wParam;
               LONG lParam;

  PURPOSE    : Processes messages for printer abort dialog box

  CALLS      : WINDOWS
                 SetFocus

  MESSAGES   : WM_INITDIALOG - initialize dialog box
               WM_COMMAND    - Input received

  RETURNS    : BOOL

  COMMENTS   : This dialog box is created while the program is printing,
               and allows the user to cancel the printing process.

  HISTORY    : 1/16/91 - created - denniscr

************************************************************************/

INT_PTR CALLBACK AbortDlg(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        //
        //Watch for Cancel button, RETURN key, ESCAPE key, or SPACE BAR
        //
        case WM_INITDIALOG:
            //
            //Set the focus to the Cancel box of the dialog
            //
            SetFocus(GetDlgItem(hDlg, IDCANCEL));
            return (TRUE);

        case WM_COMMAND:
            return (bAbort = TRUE);

        }
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\fonttest\fonttest.cpp ===
/******************************Module*Header*******************************\
* Module Name: test.c
*
* Created: 09-Dec-1992 10:51:46
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
* Contains the test
*
\**************************************************************************/

#include "precomp.hpp"

// globals

Font    *gFont = NULL;
BOOL    gTextAntiAlias = FALSE;
InstalledFontCollection gInstalledFontCollection;
PrivateFontCollection gPrivateFontCollection;


///////////////////////////////////////////////////////////////////////////////
//  Test function prototypes

VOID    TestFonts(VOID);
GraphicsPath* CreateHeartPath(const RectF& rect);
VOID    TestGradients(Graphics *g);


///////////////////////////////////////////////////////////////////////////////

VOID Test(HWND hwnd)
{
    Graphics *g = Graphics::FromHWND(hwnd);
    TestGradients(g);
    TestFonts();
    delete g;
}


///////////////////////////////////////////////////////////////////////////////
//  Font test functions

VOID TestFonts(VOID)
{
    //  Test font family enumeration
    INT numFamilies = gInstalledFontCollection.GetFamilyCount();
    Dbgprintf("%d installed font families loaded.", numFamilies);
    Dbgprintf("");

    FontFamily* families = new FontFamily[numFamilies];
    INT numFound;
    gInstalledFontCollection.GetFamilies(numFamilies, families, &numFound);

    Dbgprintf("Enumerated font families:");
    for (int f = 0; f < numFound; f++)
    {
        WCHAR faceName[LF_FACESIZE];
        families[f].GetFamilyName(faceName);
        Dbgprintf("  %ws", faceName);
    }
    Dbgprintf("");
    delete [] families;

    // Enumerate the private font families
    numFamilies = gPrivateFontCollection.GetFamilyCount();
    Dbgprintf("%d private font families loaded.", numFamilies);
    Dbgprintf("");

    if (numFamilies != 0)
    {
        families = new FontFamily[numFamilies];
        gPrivateFontCollection.GetFamilies(numFamilies, families, &numFound);

        Dbgprintf("PRIVATE enumerated font families:");
        for (int f = 0; f < numFound; f++)
        {
            WCHAR faceName[LF_FACESIZE];
            families[f].GetFamilyName(faceName);
            Dbgprintf("  %ws", faceName);
        }
        Dbgprintf("");
        delete [] families;
    }


    //HFONT hfont = NULL;
    //Font* font = new Font(hfont);//10, "Arial");

    Font* font = new Font(&FontFamily(L"Arial"), 10);

    //  Test text output
    Color blue(0, 0, 255, 255);
    SolidBrush blueBrush(blue);

#if 0
    g->DrawStringI(
           L"Hi",
           NULL,
           0, 0,           // x,y
           NULL, 0,        // pdx, flags
           &blueBrush      // GpBrush*
           );
#endif

    if (font != NULL)
    {
        delete font;
    }

}


///////////////////////////////////////////////////////////////////////////////

GraphicsPath* CreateHeartPath(const RectF& rect)
{
    GpPointF points[7];
    points[0].X = 0;
    points[0].Y = 0;
    points[1].X = 1.00;
    points[1].Y = -1.00;
    points[2].X = 2.00;
    points[2].Y = 1.00;
    points[3].X = 0;
    points[3].Y = 2.00;
    points[4].X = -2.00;
    points[4].Y = 1.00;
    points[5].X = -1.00;
    points[5].Y = -1.00;
    points[6].X = 0;
    points[6].Y = 0;

    Matrix matrix;

    matrix.Scale(rect.Width/2, rect.Height/3, MatrixOrderAppend);
    matrix.Translate(3*rect.Width/2, 4*rect.Height/3, MatrixOrderAppend);
    matrix.TransformPoints(&points[0], 7);

    GraphicsPath* path = new GraphicsPath();

    if(path)
    {
        path->AddBeziers(&points[0], 7);
        path->CloseFigure();
    }

    return path;
}


/**************************************************************************\
* TestGradients
*
* A test for rectangle and radial gradients.
*
\**************************************************************************/

VOID TestGradients(Graphics* g)
{
    REAL width = 4; // Pen width

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 32, 32);

    Color colors[5] = {
        Color(255, 255, 255, 255),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 0, 0, 0)
    };


    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);

    g->DrawRectangle(&blackPen, brushRect);

    // Create a radial gradient brush.

    Color centerColor(255, 255, 255, 255);
    Color boundaryColor(255, 0, 0, 0);
    brushRect.X = 380;
    brushRect.Y = 130;
    brushRect.Width = 60;
    brushRect.Height = 32;
    PointF center;
    center.X = brushRect.X + brushRect.Width/2;
    center.Y = brushRect.Y + brushRect.Height/2;

    // Triangle gradient.

    PointF points[7];
    points[0].X = 50;
    points[0].Y = 10;
    points[1].X = 200;
    points[1].Y = 20;
    points[2].X = 100;
    points[2].Y = 100;
    points[3].X = 30;
    points[3].Y = 120;

    Color colors1[5] = {
        Color(255, 255, 255, 0),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 0, 0, 0)
    };

    points[0].X = 200;
    points[0].Y = 300;
    points[1].X = 280;
    points[1].Y = 350;
    points[2].X = 220;
    points[2].Y = 420;
    points[3].X = 160;
    points[3].Y = 440;
    points[4].X = 120;
    points[4].Y = 370;

    PathGradientBrush polyGrad(points, 5);

    REAL blend[10];
    Color presetColors[10];
    REAL positions[10];
    INT count;
    INT i;

    count = 3;
    blend[0] = (REAL) 0;
    blend[1] = (REAL) 0;
    blend[2] = (REAL) 1;
    positions[0] = (REAL) 0;
    positions[1] = (REAL) 0.4;
    positions[2] = (REAL) 1;

    // Test for blending factors.

    polyGrad.SetBlend(&blend[0], &positions[0], count);

    polyGrad.SetCenterColor(centerColor);
    INT colorset = 5;
    polyGrad.SetSurroundColors(&colors1[0], &colorset);
    
//    g->FillPolygon(&polyGrad, points, 5);
    RectF polyRect;
    polyGrad.GetRectangle(&polyRect);
    g->FillRectangle(&polyGrad, polyRect);

    // Create a heart shaped path.

    RectF rect;
    rect.X = 300;
    rect.Y = 300;
    rect.Width = 150;
    rect.Height = 150;
    GraphicsPath *path = CreateHeartPath(rect);

    // Create a gradient from a path.

    PathGradientBrush pathGrad(path);
    delete path;
    pathGrad.SetCenterColor(centerColor);
    INT colorsset = 5;
    colors1[0] = Color(255, 255, 0, 0);
    pathGrad.SetSurroundColors(&colors1[0], &colorsset);
    pathGrad.GetRectangle(&polyRect);

    // Test for LineGradientBrush.

    RectF lineRect(120, -20, 200, 60);
    Color color1(200, 255, 255, 0);
    Color color2(200, 0, 0, 255);

}

/////////////////////////////////////////////////////////////////////////////
//  CreateNewFont
//
//  History
//  Aug-1999    -by-    Xudong Wu [tessiew]
/////////////////////////////////////////////////////////////////////////////

void CreateNewFont(char *name, FLOAT size, FontStyle style, Unit unit)
{
    Dbgprintf("Calling CreateNewFont");

    // convert ansi to unicode

    WCHAR wcname[MAX_PATH];

    memset(wcname, 0, sizeof(wcname));
    MultiByteToWideChar(CP_ACP, 0, name, strlen(name), wcname, MAX_PATH);

    // for now ignore all other unit than UnitWorld

    FontFamily *  pFamily;

	pFamily = new FontFamily(wcname);

	if (pFamily->GetLastStatus() != Ok)
	{
		pFamily = new FontFamily(wcname, &gPrivateFontCollection);
	}

    if (gFont != NULL)
    {
        delete gFont;
    }

    gFont = (Font*) new Font(pFamily, size, style, unit);

    if (gFont == NULL)
    {
        Dbgprintf("failed to create a new font");
    }
    else
    {
        if (gFont->IsAvailable())
        {
            Dbgprintf("new font created");
        }
        else
        {
            Dbgprintf("can't create font");
            delete gFont;
            gFont = NULL;
        }
    }

    if (pFamily != NULL)
    {
        delete pFamily;
    }
    
	Dbgprintf("");
}

///////////////////////////////////////////////////////////////////////////////
//  TestDrawGlyphs
//
//  History
//  Aug-1999    -by-    Xudong Wu [tessiew]
//////////////////////////////////////////////////////////////////////////////

VOID TestDrawGlyphs(
    HWND hwnd,
    UINT16 *glyphIndices,
    INT count,
    INT *px,
    INT *py,
    INT flags)
{
    FontFamily family;
    INT        style;
    REAL size;
    Unit unit;

    if (gFont)
    {
        Status status;
        status = gFont->GetFamily(&family);
        style = gFont->GetStyle();
        size = gFont->GetSize();
        unit = gFont->GetUnit();

        SolidBrush redBrush(Color(255,0,0));
        //HatchBrush hatBrush(HatchStyleDiagonalCross, Color(255,0,0), Color(128,128,128));

        Graphics *g = Graphics::FromHWND(hwnd);

        Dbgprintf("Graphics.DrawGlyphs");
        Dbgprintf("Font:: size  %f   style  %d  unit  %d", size, style, unit);

        Dbgprintf("glyphIndices px  py");
        for (INT i=0; i<count; i++)
        {
                Dbgprintf("%d  %d  %d", glyphIndices[i], px[i], py[i]);
        }
        Dbgprintf("");

            

        //g->DrawGlyphs(glyphIndices, count, gFont, &redBrush, px, py, flags);

        //  Gradient brush
        RectF gradRect(0, 0, 32, 32);
        Color colors[5] = {
            Color(255, 255, 255, 255),
            Color(255, 255, 0, 0),
            Color(255, 0, 255, 0),
            Color(255, 0, 0, 255),
            Color(255, 0, 0, 0)
        };

        PVOID Gpg = (PVOID)(g);
        PVOID font = (PVOID)gFont;
        PVOID brush = (PVOID)&redBrush;
        GpGraphics* gpg = *((GpGraphics**)Gpg);
        
        GpFont* gpfont = *((GpFont**)font);
        GpBrush* gpbrush = ((GpBrush**)brush)[1];
        //GpBrush* gpbrushHat = ((GpBrush**)&hatBrush)[1];

        if (gTextAntiAlias)
            (*gfnGdipSetTextRenderingHint)(gpg, TextRenderingHintAntiAlias);
        else
            (*gfnGdipSetTextRenderingHint)(gpg, TextRenderingHintSingleBitPerPixelGridFit);

        if (gfnGdipDrawGlyphs)
        {
            (*gfnGdipDrawGlyphs)(gpg, glyphIndices, count, gpfont, gpbrush, px, py, flags);
            
            /*
            if (flags & DG_XCONSTANT)
                px[0] += 1600;
            else if (flags & DG_YCONSTANT)
                py[0] += 1600;
            
            (*gfnGdipDrawGlyphs)(gpg, glyphIndices, count, gpfont, gpbrushHat, px, py, flags);
            */
        } else 
		{
			PointF *origins;
			origins = new PointF[count];

			for (INT i=0; i<count; i++)
			{
				origins[i].X = (float)px[i] / (float)16.0;
				origins[i].Y = (float)py[i] / (float)16.0;
			}

			g->DrawDriverString(
				glyphIndices,
				count,
				gFont,
				&redBrush,
				origins,
				0, //g_DriverOptions,
				NULL //&g_DriverTransform
        );
		}

        g->Flush();
        delete g;
    }
}


///////////////////////////////////////////////////////////////////////////////
//  TestPathGlyphs
//
//  History
//  Aug-1999    -by-    Xudong Wu [tessiew]
//////////////////////////////////////////////////////////////////////////////

VOID TestPathGlyphs(
    HWND hwnd,
    UINT16 *glyphIndices,
    INT count,
    REAL *px,
    REAL *py,
    INT flags)
{
    INT  style;
    REAL size;
    Unit unit;

    if (gFont)
    {
        style = gFont->GetStyle();
        size = gFont->GetSize();
        unit = gFont->GetUnit();

        SolidBrush redBrush(Color(255,0,0));
        SolidBrush blkBrush(Color(0,0,0));
        Pen blkPen(&blkBrush, (REAL)1);

        Graphics *g = Graphics::FromHWND(hwnd);

        Dbgprintf("Add Glyphs To Path");
        Dbgprintf("Font:: size  %f   style  %d  unit  %d", size, style, unit);

        Dbgprintf("glyphIndices px  py");
        for (INT i=0; i<count; i++)
        {
                Dbgprintf("%d  %d  %d", glyphIndices[i], INT(px[i]), INT(py[i]));
        }
        Dbgprintf("");

        GraphicsPath pathRed;
        GraphicsPath pathBlk;

        PVOID ptrv = (PVOID)gFont;
        GpFont* gpfont = *((GpFont**)ptrv);
        ptrv = (PVOID)&pathRed;
        GpPath* gpPathRed = *((GpPath**)ptrv);
        ptrv = (PVOID)&pathBlk;
        GpPath* gpPathBlk = *((GpPath**)ptrv);

        if (gfnGdipPathAddGlyphs)
        {
            (*gfnGdipPathAddGlyphs)(gpPathRed, glyphIndices, count, gpfont, px, py, flags);
            g->FillPath(&redBrush, &pathRed);

            for (INT i=0; i<count; i++)
            {
                    py[i] += 50.0;
            }

            (*gfnGdipPathAddGlyphs)(gpPathBlk, glyphIndices, count, gpfont, px, py, flags);
            g->DrawPath(&blkPen, &pathBlk);
        }

        delete g;
    }
}


/////////////////////////////////////////////////////////////////////////////
//  AddFontFile
//
//  History
//  Nov-1999    -by-    Xudong Wu [tessiew]
/////////////////////////////////////////////////////////////////////////////

void TestAddFontFile(char *fileName, INT flag, BOOL loadAsImage)
{
    Dbgprintf("Calling AddFontFile");
    Dbgprintf("filename %s  flag  %d  loadAsImage  %d", fileName, flag, loadAsImage);

    if ((flag == AddFontFlagPublic) && loadAsImage)
    {
        Dbgprintf("Cannot load a memory image in the installed font collection");
        return;
    }

    if (loadAsImage)
    {
        HANDLE hFile, hFileMapping;

        hFile = CreateFileA(fileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            0,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            0);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD   cjSize;
            PVOID   pFontFile;

            cjSize = GetFileSize(hFile, NULL);

            if (cjSize == -1)
                Dbgprintf("GetFileSize() failed\n");
            else
            {
                hFileMapping = CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, NULL);
    
                if (hFileMapping)
                {
                    pFontFile = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
    
                    if(pFontFile)
                    {
                        if (gPrivateFontCollection.AddMemoryFont((BYTE*)pFontFile,
                                                                 cjSize) == Ok)
                            Dbgprintf("AddMemoryFont to private font collection");
                        else
                            Dbgprintf("AddMemoryFont to private font collection failed");

                        UnmapViewOfFile(pFontFile);
                    }
                    else
                        Dbgprintf("MapViewOfFile() failed");
                    
                    CloseHandle(hFileMapping);
                }
                else
                    Dbgprintf("CreateFileMapping() failed");
            }
            CloseHandle(hFile);            
        }
        else
            Dbgprintf("CreateFileA failed");
    }
    else
    {
        WCHAR wcname[MAX_PATH];    
        memset(wcname, 0, sizeof(wcname));
        MultiByteToWideChar(CP_ACP, 0, fileName, strlen(fileName), wcname, MAX_PATH);

        if (flag == AddFontFlagPublic)
        {
            /* // add this code in version 2 (when InstallFontFile is exposed)
            if (gInstalledFontCollection.InstallFontFile(wcname) == Ok)
            {
                Dbgprintf("InstallFontFile to installed font collection");
            }
            else
            {
                Dbgprintf("InstallFontFile to installed font collection failed");
            }
            */
            Dbgprintf("InstallFontFile to installed font collection failed (API not yet exposed)");
        }
        else
        {
            if (gPrivateFontCollection.AddFontFile(wcname) == Ok)
            {
                Dbgprintf("AddFontFile to private font collection");
            }
            else
            {
                Dbgprintf("AddFontFile to private font collection failed");
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
//  RemoveFontFile
//
//  History
//  Nov-1999    -by-    Xudong Wu [tessiew]
/////////////////////////////////////////////////////////////////////////////

void TestRemoveFontFile(char* fileName)
{
    WCHAR wcname[MAX_PATH];

    memset(wcname, 0, sizeof(wcname));
    MultiByteToWideChar(CP_ACP, 0, fileName, strlen(fileName), wcname, MAX_PATH);
    /* // add this code in version 2 (when UninstallFontFile is exposed)
    if (gInstalledFontCollection.UninstallFontFile(wcname) == Ok)
    {
        Dbgprintf("UninstallFontFile from installed font collection");
    }
    else
    {
        Dbgprintf("UninstallFontFile from installed font collection failed");
    }
    */
    Dbgprintf("UninstallFontFile from installed font collection failed (API not yet exposed)");
}

void TestTextAntiAliasOn()
{
    gTextAntiAlias = TRUE;
}

void TestTextAntiAliasOff()
{
    gTextAntiAlias = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\fonttest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wndstuff.rc
//
#define MAINMENU                        101
#define IDM_MAINMENU                    101
#define IDD_DIALOG1                     102
#define ID_DLG_CREATEFONT               102
#define IDD_CREATEFONT                  102
#define IDD_DRAWGLYPHS                  103
#define IDD_GETGLYPHMETRICS             104
#define IDD_PATHGLYPHS                  105
#define IDD_ADDFONTFILE                 106
#define IDD_REMOVEFONT                  107
#define IDC_FAMILYNAME                  1000
#define IDC_FONT_FAMILYNAME             1000
#define ID_FONTSIZE                     1001
#define IDC_FONT_SIZE                   1002
#define ID_FONTUNIT                     1003
#define IDC_FONT_UNIT                   1004
#define ID_FONTSTYLE                    1005
#define IDC_FONT_REGULAR                1006
#define IDC_FONT_BOLD                   1007
#define IDC_FONT_BOLDITALIC             1008
#define IDC_FONT_ITALIC                 1009
#define IDC_UNITWORLD                   1010
#define IDC_UNITDISPLAY                 1011
#define IDC_UNITPIXEL                   1012
#define IDC_UNITINCH                    1013
#define IDC_UNITPT                      1014
#define IDC_UNITDOC                     1015
#define IDC_UNITMM                      1016
#define IDC_DG_GLYPHINDICES             1017
#define IDC_PX                          1018
#define IDC_DG_PX                       1019
#define IDC_PY                          1020
#define IDC_DG_PY                       1021
#define IDC_FLAGS                       1023
#define IDC_GGM_FL_DEFAULT              1025
#define IDC_GGM_FL_VMTX                 1026
#define IDC_GGM_FL_SIMBOLD              1027
#define IDC_GGM_FL_SIMITALIC            1028
#define ID_GGM_GLYPHINDICES             1029
#define IDC_GGM_GLYPHINDICES            1030
#define IDC_EDIT1                       1031
#define IDC_FONTFILENAME                1031
#define IDC_FILEPATH                    1031
#define IDC_ADDFONTFLAG                 1033
#define IDC_PUBLIC                      1034
#define IDC_PRIVATE                     1035
#define IDC_NOTENUM                     1035
#define IDD_LOADASIMAGE                 1036
#define IDC_DG_GDIPLUS                  1037
#define IDM_TEST                        40001
#define IDM_CREATEFONT                  40002
#define IDM_DRAWGLYPHS                  40003
#define IDM_PATHGLYPHS                  40005
#define ID_ADDFONTFILE                  40006
#define ID_REMOVEFONTFILE               40007
#define ID_ANTIALIAS_ON                 40012
#define ID_ANTIALIAS_OFF                40013
#define ID_FAMILY                       -1
#define IDC_GLYPHINDEX                  -1
#define IDC_GGM_FLAGS                   -1
#define IDC_FILENAME                    -1
#define IDC_REMOVEFONT                  -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        108
#define _APS_NEXT_COMMAND_VALUE         40013
#define _APS_NEXT_CONTROL_VALUE         1038
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\fonttest\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/
#include <tchar.h>
#include <stdio.h>

#include "precomp.hpp"
#include "wndstuff.h"

#include "../gpinit.inc"

// globals
HINSTANCE ghInst;
HWND ghWndMain;
HWND ghwndDebug;
HBRUSH ghbrWhite;

HINSTANCE  ghGdiplus = NULL;
FN_GDIPDRAWGLYPHS gfnGdipDrawGlyphs = NULL;
FN_GDIPPATHADDGLYPHS gfnGdipPathAddGlyphs = NULL;
FN_GDIPSETTEXTRENDERINGHINT gfnGdipSetTextRenderingHint = NULL;

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {
    case WM_CREATE:

        if (ghGdiplus || (ghGdiplus = LoadLibrary("gdiplus.dll")))
        {
            gfnGdipDrawGlyphs =(FN_GDIPDRAWGLYPHS) GetProcAddress(ghGdiplus, "GdipDrawGlyphs");
            gfnGdipPathAddGlyphs = (FN_GDIPPATHADDGLYPHS) GetProcAddress(ghGdiplus, "GdipPathAddGlyphs");
            gfnGdipSetTextRenderingHint =(FN_GDIPSETTEXTRENDERINGHINT) GetProcAddress(ghGdiplus, "GdipSetTextRenderingHint");
        }

//        if (gfnGdipDrawGlyphs == NULL)
//            EnableMenuItem(GetMenu(hwnd), IDM_DRAWGLYPHS, MF_GRAYED);

        if (gfnGdipPathAddGlyphs == NULL)
            EnableMenuItem(GetMenu(hwnd), IDM_PATHGLYPHS, MF_GRAYED);

        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDM_TEST:
            Test(hwnd);
            break;

        case IDM_CREATEFONT:
            ShowDialogBox(CreateFontDlgProc, IDD_CREATEFONT);
            break;

        case IDM_DRAWGLYPHS:
            ShowDialogBox(DrawGlyphsDlgProc, IDD_DRAWGLYPHS);
            break;

        case IDM_PATHGLYPHS:
            ShowDialogBox(PathGlyphsDlgProc, IDD_DRAWGLYPHS);
            break;

        case ID_ADDFONTFILE:
            ShowDialogBox(AddFontFileDlgProc, IDD_ADDFONTFILE);
            break;

        case ID_REMOVEFONTFILE:
            ShowDialogBox(RemoveFontDlgProc, IDD_REMOVEFONT);
            break;
        case ID_ANTIALIAS_ON:
            TestTextAntiAliasOn();
            break;
        case ID_ANTIALIAS_OFF:
            TestTextAntiAliasOff();
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
        DeleteObject(ghbrWhite);
        if (gFont)
            delete gFont;
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(VOID)
{
    WNDCLASS wc;
    
    if (!gGdiplusInitHelper.IsValid())
    {
        return(FALSE);
    }

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInst;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1);
    wc.lpszMenuName     = MAKEINTRESOURCE(IDM_MAINMENU);
    wc.lpszClassName    = _T("TestClass");
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghWndMain =
      CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Gdiplus Font Test"),
        WS_OVERLAPPED   |
        WS_CAPTION      |
        WS_BORDER       |
        WS_THICKFRAME   |
        WS_MAXIMIZEBOX  |
        WS_MINIMIZEBOX  |
        WS_CLIPCHILDREN |
        WS_VISIBLE      |
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInst,
        NULL);
    if (ghWndMain == NULL)
    {
        return(FALSE);
    }
    SetFocus(ghWndMain);

    ghwndDebug = CreateWindow(
            "LISTBOX",
            "GdiplusFontTest Debugging",
            WS_VISIBLE | WS_SYSMENU | WS_VSCROLL | WS_THICKFRAME | WS_MINIMIZEBOX,
            600, 70, 400, 700,
            NULL,
            NULL,
            ghInst,
            NULL);

    if (ghwndDebug)
    {
        SendMessage(ghwndDebug, WM_SETFONT, (WPARAM)GetStockObject(ANSI_FIXED_FONT), (LPARAM)FALSE);
        SendMessage(ghwndDebug, LB_RESETCONTENT, (WPARAM) FALSE, (LPARAM) 0);

        ShowWindow(ghwndDebug, SW_NORMAL);
        UpdateWindow(ghwndDebug);
    }

    return(TRUE);
}


INT_PTR ShowDialogBox(DLGPROC DialogProc, int iResource)
{
    INT_PTR rc = -1;
    DLGPROC lpProc;

    if (lpProc = MakeProcInstance(DialogProc, ghInst))
    {
        rc = DialogBox(ghInst,
                MAKEINTRESOURCE(iResource),
                ghWndMain,
                (DLGPROC) lpProc);
    }

    FreeProcInstance( lpProc );

    return rc;
}


/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    ghInst = GetModuleHandle(NULL);

    if (!bInitApp())
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInst, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }
    return(1);
}

//*****************************************************************************
//*******************   G E T   D L G   I T E M   F L O A T *******************
//*****************************************************************************

FLOAT
GetDlgItemFLOAT(
      HWND  hdlg
    , int   id
    )
{
    char ach[50];

    memset(ach,0,sizeof(ach));
    return((FLOAT)(GetDlgItemText(hdlg,id,ach,sizeof(ach))?atof(ach):0.0));
}

//*****************************************************************************
//*******************   S E T   D L G   I T E M   F L O A T *******************
//*****************************************************************************

void
SetDlgItemFLOAT(
      HWND    hdlg
    , int     id
    , FLOAT   e
    )
{
  static char ach[25];

  ach[0] = '\0';
  sprintf(ach, "%f", e);
  SetDlgItemText(hdlg, id, ach);
}


///////////////////////////////////////////////////////////////////////////////
// CreateFontDlgProc()
//
// History:
//
//  Aug-1999 Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK CreateFontDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    static char szName[MAX_PATH];
    LPSTR name;
    FLOAT  size;
    FontStyle style;
    Unit unit;

    switch(msg)
    {
    case WM_INITDIALOG:
        SetDlgItemText(hdlg, IDC_FONT_FAMILYNAME, "Arial");
        SendDlgItemMessage(hdlg, IDC_FONT_FAMILYNAME, EM_LIMITTEXT, sizeof(szName), 0);

        SetDlgItemFLOAT(hdlg, IDC_FONT_SIZE, 30);
        CheckRadioButton(hdlg, IDC_FONT_REGULAR, IDC_FONT_ITALIC, IDC_FONT_REGULAR);
        CheckRadioButton(hdlg, IDC_UNITWORLD, IDC_UNITMM, IDC_UNITWORLD);

        return TRUE;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            szName[0] = 0;
            GetDlgItemText(hdlg, IDC_FONT_FAMILYNAME, szName, sizeof(szName));

            if (lstrlen(szName))
            {
                size = GetDlgItemFLOAT(hdlg, IDC_FONT_SIZE);
                if (size)
                {
                    if (IsDlgButtonChecked(hdlg, IDC_FONT_REGULAR))
                        style = FontStyleRegular;
                    else if (IsDlgButtonChecked(hdlg, IDC_FONT_BOLD))
                        style = FontStyleBold;
                    else if (IsDlgButtonChecked(hdlg, IDC_FONT_ITALIC))
                        style = FontStyleItalic;
                    else if (IsDlgButtonChecked(hdlg, IDC_FONT_BOLDITALIC))
                        style = FontStyleBoldItalic;

                    if (IsDlgButtonChecked(hdlg, IDC_UNITWORLD))
                        unit = UnitWorld;
                    else if (IsDlgButtonChecked(hdlg, IDC_UNITDISPLAY))
                    {
//                        ASSERT(0);  // UnitDisplay not valid !!!
                        unit = UnitPixel;
                    }
                    else if (IsDlgButtonChecked(hdlg, IDC_UNITPIXEL))
                        unit = UnitPixel;
                    else if (IsDlgButtonChecked(hdlg, IDC_UNITPT))
                        unit = UnitPoint;
                    else if (IsDlgButtonChecked(hdlg, IDC_UNITINCH))
                        unit = UnitInch;
                    else if (IsDlgButtonChecked(hdlg, IDC_UNITDOC))
                        unit = UnitDocument;
                    else if (IsDlgButtonChecked(hdlg, IDC_UNITMM))
                        unit = UnitMillimeter;

                    CreateNewFont(szName, size, style, unit);
                }
            }

            EndDialog(hdlg, TRUE);
            return TRUE;

        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        EndDialog(hdlg, FALSE);
        return TRUE;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// GetNumber
//
// History:
//
//  Aug-1999 Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////////////////////

BOOL GetNumber(char* numstr, PVOID out, INT* count, INT flag)
{
    char  *pchar = numstr;
    INT   i, num = 0;
    FLOAT numf = 0, *pf;
    UINT16  *puint16;
    INT     *pint;

    if (*pchar != 0)
    {
        num = atoi(numstr);
        numf = (FLOAT)atof(numstr);

        if (num == 0 || numf == 0)
        {
            return FALSE;
        }

        if (flag == CONVERTTOUINT16)
        {
            puint16 = (UINT16*) out;
            puint16 += *count;
            *puint16 = (UINT16)num;
        }
        else if (flag == CONVERTTOINT)
        {
            pint = (INT*) out;
            pint += *count;
            *pint = num;
        }
        else
        {
            pf = (FLOAT*) out;
            pf += *count;
            *pf = numf;
        }

        *count = *count + 1;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// ParseStrToNumbers
//
// History:
//
//  Aug-1999 Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////////////////////

BOOL ParseStrToNumbers(char* str, PVOID out, INT* count, INT flag)
{
    char    *pchar = str, *pnum;
    char    anum[30];
    BOOL    bRet = TRUE;

    *count = 0;
    pnum = anum;
    *pnum = 0;

    while (*pchar)
    {
        if (*pchar == ' ' || *pchar == ',')
        {
            *pnum = 0;
            if (!GetNumber(anum, out, count, flag))
                return FALSE;
            pnum = anum;
            *pnum = 0;
            pchar++;
        }
        else if (*str < '0' || *str > '9')
        {
            return FALSE;
        }
        else
        {
            *pnum ++ = *pchar ++;
        }
    }

    *pnum = 0;
    if (!GetNumber(anum, out, count, flag))
        bRet = FALSE;;

    return bRet;
}


///////////////////////////////////////////////////////////////////////////////
// DrawGlyphsDlgProc
//
// History:
//
//  Aug-1999  -by- Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK DrawGlyphsDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    UINT16  glyphIndices[MAX_GLYPH_COUNT];
    INT     count, xycount;
    INT     px[MAX_GLYPH_COUNT];
    INT     py[MAX_GLYPH_COUNT];
    INT     flags;
    char    glyphStr[4*MAX_GLYPH_COUNT];

    switch(msg)
    {
    case WM_INITDIALOG:
        SetDlgItemText(hdlg, IDC_DG_GLYPHINDICES, "55, 72, 86, 87");
        SetDlgItemText(hdlg, IDC_DG_PX, "1600, 1920, 2240, 2560");
        SetDlgItemText(hdlg, IDC_DG_PY, "1600, 1600, 1600, 1600");
        return TRUE;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            glyphStr[0] = 0;

            GetDlgItemText(hdlg, IDC_DG_GLYPHINDICES, glyphStr, sizeof(glyphStr));

            if (ParseStrToNumbers(glyphStr, (PVOID)glyphIndices, &count, CONVERTTOUINT16))
            {
                glyphStr[0] = 0;
                GetDlgItemText(hdlg, IDC_DG_PX, glyphStr, sizeof(glyphStr));

                if (ParseStrToNumbers(glyphStr, (PVOID)px, &xycount, CONVERTTOINT))
                {
                    glyphStr[0] = 0;
                    GetDlgItemText(hdlg, IDC_DG_PY, glyphStr, sizeof(glyphStr));

                    if (ParseStrToNumbers(glyphStr, (PVOID)py, &xycount, CONVERTTOINT))
                    {

                        if (IsDlgButtonChecked(hdlg, IDC_DG_GDIPLUS))
                            flags |= DG_NOGDI;

                        TestDrawGlyphs(ghWndMain, glyphIndices, count, px, py, flags);
                    }
                }
            }

            EndDialog(hdlg, TRUE);
            return TRUE;

        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        EndDialog(hdlg, FALSE);
        return TRUE;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// PathGlyphsDlgProc
//
// History:
//
//  Aug-1999  -by- Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK PathGlyphsDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
   UINT16  glyphIndices[MAX_GLYPH_COUNT];
    INT     count, xycount;
    INT     px[MAX_GLYPH_COUNT];
    INT     py[MAX_GLYPH_COUNT];
    INT     flags;
    char    glyphStr[4*MAX_GLYPH_COUNT];
    REAL    prx[MAX_GLYPH_COUNT];
    REAL    pry[MAX_GLYPH_COUNT];

    switch(msg)
    {
    case WM_INITDIALOG:
        SetDlgItemText(hdlg, IDC_DG_GLYPHINDICES, "55, 72, 86, 87");
        SetDlgItemText(hdlg, IDC_DG_PX, "100, 120, 140, 160");
        SetDlgItemText(hdlg, IDC_DG_PY, "100, 100, 100, 100");
        return TRUE;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            glyphStr[0] = 0;

            GetDlgItemText(hdlg, IDC_DG_GLYPHINDICES, glyphStr, sizeof(glyphStr));

            if (ParseStrToNumbers(glyphStr, (PVOID)glyphIndices, &count, CONVERTTOUINT16))
            {
                glyphStr[0] = 0;
                GetDlgItemText(hdlg, IDC_DG_PX, glyphStr, sizeof(glyphStr));

                if (ParseStrToNumbers(glyphStr, (PVOID)px, &xycount, CONVERTTOINT))
                {
                    glyphStr[0] = 0;
                    GetDlgItemText(hdlg, IDC_DG_PY, glyphStr, sizeof(glyphStr));

                    if (ParseStrToNumbers(glyphStr, (PVOID)py, &xycount, CONVERTTOINT))
                    {

                        // Generate REAL glyph psitions
                        for (INT i=0; i<count; i++)
                        {
                            prx[i] = REAL(px[i]);
                            pry[i] = REAL(py[i]);
                        }
                        flags = 0;

                        TestPathGlyphs(ghWndMain, glyphIndices, count, prx, pry, flags);
                    }
                }
            }

            EndDialog(hdlg, TRUE);
            return TRUE;

        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        EndDialog(hdlg, FALSE);
        return TRUE;
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////
// GetGlyphMetricsDlgProc
//
// History:
//
//  Aug-18-1999  -by- Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////

INT_PTR CALLBACK GetGlyphMetricsDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    UINT16  glyphIndices[MAX_GLYPH_COUNT];
    INT     count, xycount;
    INT     px[MAX_GLYPH_COUNT];
    INT     py[MAX_GLYPH_COUNT];
    INT     flags;
    char    glyphStr[4*MAX_GLYPH_COUNT];

    switch(msg)
    {
    case WM_INITDIALOG:
        SetDlgItemText(hdlg, IDC_GGM_GLYPHINDICES, "55, 72, 86, 87");
        CheckRadioButton(hdlg, IDC_GGM_FL_DEFAULT, IDC_GGM_FL_SIMITALIC, IDC_GGM_FL_DEFAULT);
        return TRUE;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            glyphStr[0] = 0;

            GetDlgItemText(hdlg, IDC_GGM_GLYPHINDICES, glyphStr, sizeof(glyphStr));

            if (ParseStrToNumbers(glyphStr, (PVOID)glyphIndices, &count, CONVERTTOUINT16))
            {
                if (IsDlgButtonChecked(hdlg, IDC_GGM_FL_DEFAULT))
                    flags = 0;
                else if (IsDlgButtonChecked(hdlg, IDC_GGM_FL_VMTX))
                    flags = 1;
                else if (IsDlgButtonChecked(hdlg, IDC_GGM_FL_SIMBOLD))
                    flags = 2;
                else if (IsDlgButtonChecked(hdlg, IDC_GGM_FL_SIMITALIC))
                    flags = 3;

            }

            EndDialog(hdlg, TRUE);
            return TRUE;

        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        EndDialog(hdlg, FALSE);
        return TRUE;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// CreateFontDlgProc()
//
// History:
//
//  Nov-1999 Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK AddFontFileDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    static char szName[MAX_PATH];
    LPSTR name;
    INT flag;
    BOOL loadAsImage = FALSE;

    switch(msg)
    {
    case WM_INITDIALOG:
        CheckRadioButton(hdlg, IDC_PUBLIC, IDC_NOTENUM, IDC_PUBLIC);
        return TRUE;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            szName[0] = 0;

            GetDlgItemText(hdlg, IDC_FONTFILENAME, szName, sizeof(szName));
            if (IsDlgButtonChecked(hdlg, IDC_PUBLIC))
                flag = AddFontFlagPublic;
            else
                flag = AddFontFlagNotEnumerate;
            if (IsDlgButtonChecked(hdlg, IDD_LOADASIMAGE))
                loadAsImage = TRUE;

            if (lstrlen(szName))
            {
                TestAddFontFile(szName, flag, loadAsImage);
            }

            EndDialog(hdlg, TRUE);
            return TRUE;

        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        EndDialog(hdlg, FALSE);
        return TRUE;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// RemoveFontDlgProc()
//
// History:
//
//  Dec-1999 Xudong Wu [tessiew]
// Wrote it.
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK RemoveFontDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    char ach[50];

    switch(msg)
    {
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            GetDlgItemText(hdlg, IDC_FILEPATH, ach, sizeof(ach));
            TestRemoveFontFile(ach);
            EndDialog(hdlg, TRUE);
            return TRUE;
        
        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        EndDialog(hdlg, FALSE);
        return TRUE;
    }
    return FALSE;
}

/******************************Public*Routine******************************\
* Dbgprintf
*
* ListBox printf implementation.
*
* History:
*  Aug-18-1999 -by- Xudong Wu [tessiew]
* Wrote it.
\**************************************************************************/

void Dbgprintf(PCH msg, ...)
{
    va_list ap;
    char buffer[256];

    va_start(ap, msg);

    vsprintf(buffer, msg, ap);

    if (ghwndDebug)
    {
        SendMessage(ghwndDebug, LB_ADDSTRING, (WPARAM) 0, (LPARAM) buffer);
        SendMessage(ghwndDebug, WM_SETREDRAW, (WPARAM) TRUE, (LPARAM) 0);
        InvalidateRect(ghwndDebug, NULL, TRUE);
        UpdateWindow(ghwndDebug);
    }

    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\fonttest\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#include "resource.h"

#define CONVERTTOUINT16     0
#define CONVERTTOINT        1
#define CONVERTTOFLOAT      2

void Test(HWND hwnd);
INT_PTR ShowDialogBox(DLGPROC, int);

INT_PTR CALLBACK CreateFontDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DrawGlyphsDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK PathGlyphsDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK GetGlyphMetricsDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AddFontFileDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK RemoveFontDlgProc(HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\fractal\gdipscsave.h ===
#ifndef __GDIPSCSAVE_H
#define __GDIPSCSAVE_H

#include <windows.h>
#include <objbase.h>
#include <scrnsave.h>
#include "resource.h"
//#include <imaging.h>
#include <gdiplus.h>

using namespace Gdiplus;

//#include <stdio.h>

#define MINVEL  1                             /* minimum number of fractals    */ 
#define MAXVEL  10                            /* maximum number of fractals    */ 
#define DEFVEL  3                             /* default number of fractals    */ 
 
#define REDRAWTIME  2000                      /* number of milliseconds between redraws */

#define MAXHEIGHWAYLEVEL  14                  /* Maximum number of levels for heighway dragon */
#define MINHEIGHWAYLEVEL  7                   /* Minimum number of levels for heighway dragon */

DWORD   nNumFracts = DEFVEL;                   /* number of fractals variable   */ 
DWORD   nFractType = 0;                        /* Type of fractal to draw       */
WCHAR   szAppName[APPNAMEBUFFERLEN];           /* .ini section name             */ 
WCHAR   szTemp[20];                            /* temporary array of characters */ 
BOOL    fMandelbrot = FALSE;                   /* TRUE if mandelbrot sets used */

#define HKEY_PREFERENCES TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ScreenSaver\\Preferences")

//FILE *stream;

VOID FillSierpinski(Graphics *g, PointF one, PointF two, PointF three, int level, Brush *pBrush, Pen *pPen);
VOID DrawSierpinski(HDC hDC, HWND hwnd, RECT rc, int iColor);
VOID DrawHieghway(HDC hDC, HWND hwnd, RECT rc, int iColor);
VOID IterateHieghway(PointF *points, PointF *newpoints, int *iSize);
VOID DrawTree(HDC hDC, HWND hwnd, RECT rc, int iColor);
VOID DrawBranch(HWND hwnd, Graphics *g, GraphicsPath *path, int iLevel, 
              PointF *scale, REAL *rotate, PointF *translate, 
              int iBranches, int iColor);
VOID DrawJulia(HDC hDC, HWND hwnd, RECT rc, int iColor, BOOL fMandelbrot);
ARGB IndexToSpectrum(INT index);
INT SpectrumToIndex(ARGB argb);
INT MakeColor(INT c1, INT c2, INT deltamax);
INT MakeColor(INT c1, INT c2, INT c3, INT c4, INT deltamax);
BYTE MakeAlpha(BYTE a1, BYTE a2, INT deltamax);
BYTE MakeAlpha(BYTE a1, BYTE a2, BYTE a3, BYTE a4, INT deltamax);
BOOL HalfPlasma(HWND& hwnd, Graphics& g,BitmapData &bmpd, INT x0, INT y0, INT x1, INT y1,REAL scale);
VOID DrawPlasma(HDC hDC, HWND hwnd, RECT rc, int iColor);
VOID GetFractalConfig (DWORD *nType, DWORD *nSize);
VOID SetFractalConfig (DWORD nType, DWORD nSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\fractal\gdipscsave.cpp ===
/**************************************************************************
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdipscsave.cpp
*
* Abstract:
*
*   Demonstration GDI+ based screen saver with several different
*   fractal patterns
*
* Revision History:
*
*   8/17/2000  peterost - Created it.
*
***************************************************************************/

#include "gdipscsave.h"
#include <math.h>
#include "../gpinit.inc"

extern HINSTANCE hMainInstance; /* screen saver instance handle  */ 
 
/**********************************************************************
*
*  Handle configuration dialog
*
***********************************************************************/

BOOL WINAPI ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{ 
    static HWND hNumber; /* handle to number of fractals scroll bar */ 
    static HWND hOK;     /* handle to OK push button */ 
 
    switch(message) 
    { 
        case WM_INITDIALOG: 
 
			/* Retrieve the application name from the .rc file. */
			LoadString(hMainInstance,idsAppName,szAppName,40);
 
            /* Retrieve any redraw speed data from the registry. */ 
            GetFractalConfig (&nFractType, &nNumFracts);
  
            /* Initialize the number of fractals scroll bar control. */ 
            hNumber = GetDlgItem(hDlg, ID_SPEED); 
            SetScrollRange(hNumber, SB_CTL, MINVEL, MAXVEL, FALSE); 
            SetScrollPos(hNumber, SB_CTL, nNumFracts, TRUE); 

            /* Initialize the type of fractals radio buttons */
            CheckRadioButton(hDlg, IDC_RADIOTYPE1, IDC_RADIOTYPE5, IDC_RADIOTYPE1+nFractType);

            /* Retrieve a handle to the OK push button control. */ 
            hOK = GetDlgItem(hDlg, IDOK); 
 
            return TRUE; 
 
        case WM_HSCROLL: 
 
            /* 
             * Process scroll bar input, adjusting the nNumFracts 
             * value as appropriate. 
             */ 
 
            switch (LOWORD(wParam)) 
                { 
                    case SB_PAGEUP: 
                        --nNumFracts; 
                    break; 
 
                    case SB_LINEUP: 
                        --nNumFracts; 
                    break; 
 
                    case SB_PAGEDOWN: 
                        ++nNumFracts; 
                    break; 
 
                    case SB_LINEDOWN: 
                        ++nNumFracts; 
                    break; 
 
                    case SB_THUMBPOSITION: 
                        nNumFracts = HIWORD(wParam); 
                    break; 
 
                    case SB_BOTTOM: 
                        nNumFracts = MINVEL; 
                    break; 
 
                    case SB_TOP: 
                        nNumFracts = MAXVEL; 
                    break; 
 
                    case SB_THUMBTRACK: 
                    case SB_ENDSCROLL: 
                        return TRUE; 
                    break; 
                } 
                if ((int) nNumFracts <= MINVEL) 
                    nNumFracts = MINVEL; 
                if ((int) nNumFracts >= MAXVEL) 
                    nNumFracts = MAXVEL; 
 
                SetScrollPos((HWND) lParam, SB_CTL, nNumFracts, TRUE); 
            break; 
 
        case WM_COMMAND: 
            switch(LOWORD(wParam)) 
            { 
                case ID_OK: 
                    if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE1))
                        nFractType = 0;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE2))
                        nFractType = 1;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE3))
                        nFractType = 2;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE4))
                        nFractType = 3;
                    else
                        nFractType = 4;
                    SetFractalConfig(nFractType, nNumFracts);
 
                case ID_CANCEL: 
                    EndDialog(hDlg, LOWORD(wParam) == IDOK); 
                return TRUE; 
            } 
    } 
    return FALSE; 
} 
 
BOOL WINAPI RegisterDialogClasses(
    HANDLE  hInst
    )
{ 
    return TRUE; 
} 

LRESULT WINAPI ScreenSaverProcW (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{ 
static HDC          hdc;    /* device-context handle */ 
static RECT         rc;     /* RECT structure */ 
static UINT         uTimer; /* timer identifier */ 
static DWORD        dwNumDrawn = -1;
 
    switch(message) 
    { 
        case WM_CREATE: 
 
            // Retrieve the application name from the .rc file. 
            LoadString(hMainInstance, idsAppName, szAppName, 40); 
  
            // Retrieve any configuration data from the registry.
            GetFractalConfig (&nFractType, &nNumFracts); 

            // Set a timer for the screen saver window 
            uTimer = SetTimer(hwnd, 1, 1000, NULL); 

            srand( (unsigned)GetTickCount() );
            fMandelbrot = rand()%2;

//            stream = fopen( "fprintf.out", "w" );
//            fprintf(stream, "initialized\n");

            break; 
 
        case WM_ERASEBKGND: 
 
           /* 
            * The WM_ERASEBKGND message is issued before the 
            * WM_TIMER message, allowing the screen saver to 
            * paint the background as appropriate. 
            */ 
 
            hdc = GetDC(hwnd); 
            GetClientRect (hwnd, &rc); 
            FillRect (hdc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH)); 
            ReleaseDC(hwnd,hdc); 
            break; 
 
        case WM_TIMER: 
 
           /* 
            * The WM_TIMER message is issued at REDRAWTIME. This 
            * code repaints the entire desktop with black brush every time
            * nNumFracts fractals have been drawn, and calls the appropriate
            * fractal rendering function based on nFractType
            */ 
 
            if (uTimer)
                KillTimer(hwnd, uTimer);

            hdc = GetDC(hwnd); 
            GetClientRect(hwnd, &rc); 
            if (++dwNumDrawn >= nNumFracts) 
            {
                dwNumDrawn = 0;
                
                FillRect(hdc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH));
            }

            switch (nFractType)
            {
                case 0:
                    DrawSierpinski(hdc, hwnd, rc, dwNumDrawn);
                    break;
                case 1:
                    DrawHieghway(hdc, hwnd, rc, dwNumDrawn);
                    break;
                case 2:
                    DrawTree(hdc, hwnd, rc, dwNumDrawn);
                    break;
                case 3:
                    DrawPlasma(hdc, hwnd, rc, dwNumDrawn);
                    break;
                case 4:
                    DrawJulia(hdc, hwnd, rc, dwNumDrawn, fMandelbrot);
                    break;
            }

            uTimer = SetTimer(hwnd, 1, REDRAWTIME, NULL); 

            ReleaseDC(hwnd,hdc); 
            break; 
 
        case WM_DESTROY: 
 
           /* 
            * When the WM_DESTROY message is issued, the screen saver 
            * must destroy any of the timers that were set at WM_CREATE 
            * time. 
            */ 
//            fclose(stream);
            if (uTimer) 
                KillTimer(hwnd, uTimer); 
            break; 
    } 
 
    // DefScreenSaverProc processes any messages ignored by ScreenSaverProc. 
    return DefScreenSaverProc(hwnd, message, wParam, lParam); 
} 
 
VOID FillSierpinski(HWND hwnd, Graphics *g, PointF one, PointF two, PointF three, int level, Brush *pBrush, Pen *pPen)
{
    MSG msg;

    if (level == 4 &&
         PeekMessage(&msg, hwnd, WM_KEYFIRST, WM_MOUSELAST, PM_NOREMOVE))
    {
        return;
    }
       
   g->DrawLine(pPen, one, two);
   g->DrawLine(pPen, two, three);
   g->DrawLine(pPen, three, one);

   PointF midpoints[3];
   midpoints[0].X = (two.X + one.X) / 2;
   midpoints[0].Y = (two.Y + one.Y) / 2;
   midpoints[1].X = (three.X + two.X) / 2;
   midpoints[1].Y = (three.Y + two.Y) / 2;
   midpoints[2].X = (one.X + three.X) / 2;
   midpoints[2].Y = (one.Y + three.Y) / 2;

   GraphicsPath triangle;
   triangle.AddPolygon(midpoints, 3); 
   g->FillPath(pBrush, &triangle);

   if (level-- > 0)
   {
       FillSierpinski(hwnd, g, two, midpoints[0], midpoints[1], level, pBrush, pPen);
       FillSierpinski(hwnd, g, three, midpoints[1], midpoints[2], level, pBrush, pPen);
       FillSierpinski(hwnd, g, one, midpoints[0], midpoints[2], level, pBrush, pPen);
   }

}

VOID DrawSierpinski(HDC hDC, HWND hwnd, RECT rc, int iColor)
{
    Graphics g(hDC);
    PointF points[3];
    Color  colors[3] = {
            Color(160,255,0,0),
            Color(130,0,255,0),
            Color(110,0,0,255)};
    int nColors = 3, iMinLen = 6;

    // Get some good random points.  Limit angles to be > 20 degrees, so
    // there are no skinny triangles
    for (int j = 0; j <= 20; j++)
    {
        for (int i = 0; i<= 2; i++)
        {
            points[i].X = (REAL)(rand() % (rc.right - rc.left));
            points[i].Y = (REAL)(rand() % (rc.bottom - rc.top));
        }

        double a,b,c,cosa,cosb,cosc;

        a = sqrt(pow(points[0].X - points[1].X, 2) + pow(points[0].Y - points[1].Y, 2));
        b = sqrt(pow(points[2].X - points[1].X, 2) + pow(points[2].Y - points[1].Y, 2));
        c = sqrt(pow(points[0].X - points[2].X, 2) + pow(points[0].Y - points[2].Y, 2));
        iMinLen = (int)min(a,min(b,c));
//fprintf(stream, " %6f  %6f  %6f   %d\n", a, b, c, j);

        cosa = (pow(a,2) - pow(b,2) - pow(c,2)) / (-2 * b * c);
        cosb = (pow(b,2) - pow(a,2) - pow(c,2)) / (-2 * a * c);
        cosc = (pow(c,2) - pow(a,2) - pow(b,2)) / (-2 * a * b);
//fprintf(stream, " %6f  %6f  %6f   %d\n", cosa, cosb, cosc, j);
        if ((fabs(cosa) < 0.939) && 
            (fabs(cosb) < 0.939) && 
            (fabs(cosc) < 0.939) &&
            (a > 35))
        {
//            fprintf(stream, "broke\n");
            break;
        }       
    }
            
    PathGradientBrush brush(points, nColors);
    brush.SetSurroundColors(colors, &nColors);

    Pen pen(Color(90, (255-iColor*90)%256, 0, (iColor*60)%256));

    g.SetSmoothingMode(SmoothingModeAntiAlias);

    FillSierpinski(hwnd, &g, points[0], points[1], points[2], min(6,max(3,iMinLen/70)), &brush, &pen);
}

VOID DrawHieghway(HDC hDC, HWND hwnd, RECT rc, int iColor)
{
   static PointF p1[16390], p2[16390];

   int iSize = 2, iLen, iPad = (rc.bottom - rc.top) / 4;
   PointF *parr1, *parr2, *ptemp;


   // Calculate a starting line that is not too close to the edges of the screen
   p1[0].X = (REAL)(iPad + (rand() % (rc.right - rc.left - iPad*2)));
   p1[0].Y = (REAL)(iPad + (rand() % (rc.bottom - rc.top - iPad*2)));
   iLen = (rand() % (min(rc.right - rc.left, rc.bottom - rc.top) / 2)) + iPad/2;
   
   if (rand() & 1)
   {
       p1[1].X = p1[0].X;
       if (p1[0].Y > (rc.bottom - rc.top)/2)
           p1[1].Y = p1[0].Y - iLen;
       else
           p1[1].Y = p1[0].Y + iLen;
   }
   else
   {
       if (p1[0].X > (rc.right - rc.left)/2)
           p1[1].X = p1[0].X - iLen;
       else
           p1[1].X = p1[0].X + iLen;
       p1[1].Y = p1[0].Y;
   }

  PointF pgrad1(p1[0].X, p1[0].Y), pgrad2(p1[1].X, p1[1].Y);
//fprintf(stream, " %6f  %6f  %6f  %6f\n", p1[0].X, p1[0].Y, p1[1].X, p1[1].Y);

   parr1 = p1;
   parr2 = p2;

   // Create dragon pattern to a level which is more or less dependent on the
   // overall size of the pattern.
   for (int i=0; i<max(MINHEIGHWAYLEVEL,min(sqrt(iLen/2), MAXHEIGHWAYLEVEL)); i++)
   {
      IterateHieghway(parr1, parr2, &iSize);
      ptemp = parr1;
      parr1 = parr2;
      parr2 = ptemp;
   }

   // Draw the resultant pattern with a gradient pen with random colors.
   Graphics g(hDC);
   LinearGradientBrush brush(pgrad1, pgrad2, 
        Color(230, (rand()%200)+55, (rand()%128)+55, rand()%256),
        Color(180, (rand()%100)+155, rand()%256, (rand()%200)+55));
   brush.SetWrapMode(WrapModeTileFlipXY);
   Pen pen(&brush);

// fprintf(stream, " %d  %d \n", iLen, iSize);

   MSG msg;

   for (int j=0; j<(iSize-1); j++)
   {
      g.DrawLine(&pen, parr1[j], parr1[j+1]);

      // Drawing takes a long time, so check for queued message periodically
      if (j%1000 == 0 &&
          PeekMessage(&msg, hwnd, WM_KEYFIRST, WM_MOUSELAST, PM_NOREMOVE))
      {
          break;
      }

   }

}

VOID IterateHieghway(PointF *points, PointF *newpoints, int *iSize)
{
   int j = 0;
   REAL x1,x2,y1,y2;
   BOOL right = TRUE;
   
   for (int i = 0; i < (*iSize - 1); i++)
   {
       x1 = points[i].X;
       x2 = points[i+1].X;
       y1 = points[i].Y;
       y2 = points[i+1].Y;

      newpoints[j].X = x1;
      newpoints[j++].Y = y1;

       if (y1 == y2)
       {
          newpoints[j].X = (x2 + x1) / 2;
          if (x2 > x1)
              if (right)
                 newpoints[j++].Y = y1 + (x2-x1)/2;
              else
                 newpoints[j++].Y = y1 - (x2-x1)/2;
          else // if (x1 > x2)
              if (right)
                 newpoints[j++].Y = y1 - (x1-x2)/2;
              else
                 newpoints[j++].Y = y1 + (x1-x2)/2;
      }
      else if (x1 == x2)
      {
          newpoints[j].Y = (y2 + y1) / 2;
          if (y2 > y1)
              if (right)
                  newpoints[j++].X = x1 - (y2-y1)/2;
              else
                  newpoints[j++].X = x1 + (y2-y1)/2;
          else  // if (y1 > y2)
              if (right)
                  newpoints[j++].X = x1 + (y1-y2)/2;
              else
                  newpoints[j++].X = x1 - (y1-y2)/2;
      }
      else
      {
          if ((x1 > x2 && y1 > y2) ||
              (x2 > x1 && y2 > y1))
          {
              if (right)
              {
                  newpoints[j].X = x1;
                  newpoints[j++].Y = y2;
              }
              else
              {
                  newpoints[j].X = x2;
                  newpoints[j++].Y = y1;
              }
          }
          else // if ((x2 > x1 && y1 > y2) ||
               //     (x1 > x2 && y2 > y1))
          {
              if (right)
              {
                  newpoints[j].X = x2;
                  newpoints[j++].Y = y1;
              }
              else
              {
                  newpoints[j].X = x1;
                  newpoints[j++].Y = y2;
              }
          }
      }

      right = !right;
  }

  newpoints[j].X = x2;
  newpoints[j++].Y = y2;
  
  *iSize = j;
}

VOID DrawTree(HDC hDC, HWND hwnd, RECT rc, int iColor)
{
/*    PointF points[] = {PointF(50,100),
                       PointF(70,100),
                       PointF(68,70),
                       PointF(58,56),
                       PointF(80,47),
                       PointF(65,24),
                       PointF(58,27),
                       PointF(68,43),
                       PointF(47,52),
                       PointF(55,70),
                       PointF(50,100)};
    PointF  scale[] = {PointF((REAL)0.7, (REAL)0.7), 
                       PointF((REAL)0.7, (REAL)0.7), 
                       PointF((REAL)0.7, (REAL)0.7)};
    REAL    rotate[] = {-65, -10, 65};
    PointF  translate[] = {PointF(-100,2), PointF(20,-45), PointF(35,-167)};
*/
    PointF points[3][11] = {PointF(50,100),
                            PointF(65,100),
                            PointF(62,30),
                            PointF(53,30),
                            PointF(50,100),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0),
                       
                            PointF(50,100),
                            PointF(70,100),
                            PointF(68,70),
                            PointF(58,56),
                            PointF(80,47),
                            PointF(65,24),
                            PointF(58,27),
                            PointF(68,43),
                            PointF(47,52),
                            PointF(55,70),
                            PointF(50,100),
    
                            PointF(0,100),
                            PointF(15,100),
                            PointF(12,30),
                            PointF(3,30),
                            PointF(0,100),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0),
                            PointF(0,0)};
    int     numPoints[3] = {5,11,5};
    int     numBranches[3] = {3,4,3};
    int     numLevels[3] = {7,7,9};
    PointF  scale[3][4] = {PointF((REAL)0.7, (REAL)0.7), 
                           PointF((REAL)0.7, (REAL)0.7), 
                           PointF((REAL)0.7, (REAL)0.7),
                           PointF(0,0),
                       
                           PointF((REAL)0.75, (REAL)0.75), 
                           PointF((REAL)0.6, (REAL)0.6), 
                           PointF((REAL)0.8, (REAL)0.8),
                           PointF((REAL)0.35, (REAL)0.35),
    
                           PointF((REAL)0.65, (REAL)0.65), 
                           PointF((REAL)0.6, (REAL)0.6), 
                           PointF((REAL)0.6, (REAL)0.6),
                           PointF(0,0)};
    REAL    rotate[3][4] = {1, -35, 27, 0,
                            -65, -10, 65, 20,
                            0, -55, 55, 0};
    PointF  translate[3][4] = {PointF(24,-50), 
                               PointF(-33,10), 
                               PointF(50,-67),
                               PointF(0,0),
                                
                               PointF(-100,2), 
                               PointF(25,-40), 
                               PointF(25,-160),
                               PointF(180,25),
    
                               PointF(4,-55), 
                               PointF(-95,-30), 
                               PointF(95,-50),
                               PointF(0,0)};
//fprintf(stream, "%f  %f  %f  %f \n", points[0][0].X, points[0][1].X, points[0][2].X, points[0][3].X);
    Graphics g(hDC);
    GraphicsPath path;
    REAL  rScale = (REAL)(rand() % (rc.bottom - rc.top)) / 350;
    if (rScale < 0.2)
        rScale = 0.2f;
    REAL xTrans = (REAL)(rand() % ((rc.right - rc.left) * 2/3)) + ((rc.right - rc.left) * 1/6);
    REAL yTrans = (REAL)(rand() % ((rc.bottom - rc.top) * 2/3)) + ((rc.bottom - rc.top) * 1/6);
    REAL rRotate = (REAL)(rand() % 360);
    int iTree = rand() % 3;

//fprintf(stream, " %6f  %6f  %6f  %6f\n", rScale, xTrans, yTrans, rRotate);

    path.AddPolygon(points[iTree],numPoints[iTree]);
    g.TranslateTransform(xTrans, yTrans);
    g.ScaleTransform(rScale, rScale);
    g.RotateTransform(rRotate);
    DrawBranch(hwnd, &g, &path,  rScale < 1 ? numLevels[iTree]-1 : numLevels[iTree], 
                scale[iTree], rotate[iTree], translate[iTree], numBranches[iTree], 
                iColor);
}

VOID DrawBranch(HWND hwnd, Graphics *g, GraphicsPath *path, int iLevel, 
              PointF *scale, REAL *rotate, PointF *translate, 
              int iBranches, int iColor)
{
    MSG   msg;

    if (iLevel == 0 ||
        (iLevel == 6 &&
         PeekMessage(&msg, hwnd, WM_KEYFIRST, WM_MOUSELAST, PM_NOREMOVE)))
    {
        return;
    }
        
    SolidBrush brush(Color(200, rand()%256,(255-iLevel*20)%256,(iColor*125)%200 + rand()%50));
    g->FillPath(&brush, path);

    for (int i = 0; i<iBranches; i++)
    {
        GraphicsState state = g->Save();

        g->ScaleTransform(scale[i].X, scale[i].Y);
        g->RotateTransform(rotate[i]);
        g->TranslateTransform(translate[i].X, translate[i].Y);

        DrawBranch(hwnd, g, path,iLevel-1,scale,rotate,translate,iBranches,iColor);

        g->Restore(state);
    }
}

VOID DrawJulia(HDC hDC, HWND hwnd, RECT rc, int iColor, BOOL fMandelbrot)
{
    Graphics g(hDC);
    REAL cx=(REAL)0.3,cy=(REAL)0.588888;
    REAL x0,y0=-1.25,xI,yI=1.25;
    REAL xCenter, yCenter, delta=(REAL)(0.2/pow(2.5,iColor));
    REAL scrnx=(REAL)(rc.right-rc.left), scrny=(REAL)(rc.bottom-rc.top);
    REAL nx=scrnx,ny=scrny;
    int niter=45+8*(iColor+1),i,ncolors=28;
    Bitmap bitmap((int)nx, (int)ny, PixelFormat32bppARGB);

    if (fMandelbrot)
    {
        xCenter=(REAL)-0.561;
        yCenter=(REAL)-0.6432;
        x0 = (REAL)-1.75;
        xI = (REAL)1.0;
    }
    else
    {
        x0 = (REAL)-1.25;
        xI = (REAL)1.25;
        xCenter=(REAL)-0.11014;
        yCenter=(REAL)-0.509;
    }
    if (iColor > 0)
    {
       x0=(REAL)(xCenter-delta); 
       xI=(REAL)(xCenter+delta);
       y0=(REAL)(yCenter-delta); 
        yI=(REAL)(yCenter+delta);
    }

//    bitmap.LockBits

/*    SolidBrush brushs[] =
        {SolidBrush(Color(255,128,0,0)),
         SolidBrush(Color(255,255,0,0)),
         SolidBrush(Color(255,0,128,0)),
         SolidBrush(Color(255,0,255,0)),
         SolidBrush(Color(255,0,0,128)),
         SolidBrush(Color(255,0,0,255)),
         SolidBrush(Color(255,128,128,0)),
         SolidBrush(Color(255,255,255,0)),
         SolidBrush(Color(255,0,128,128)),
         SolidBrush(Color(255,0,255,255)),
         SolidBrush(Color(255,128,0,128)),
         SolidBrush(Color(255,255,0,255))};
    SolidBrush brushs[] =
        {SolidBrush(Color(255,248,40,18)),
         SolidBrush(Color(255,245,117,21)),
         SolidBrush(Color(255,255,171,18)),
         SolidBrush(Color(255,246,235,20)),
         SolidBrush(Color(255,213,255,13)),
         SolidBrush(Color(255,93,253,13)),
         SolidBrush(Color(255,13,253,218)),
         SolidBrush(Color(255,14,190,252)),
         SolidBrush(Color(255,15,116,255)),
         SolidBrush(Color(255,15,15,255)),
         SolidBrush(Color(255,207,15,250)),
         SolidBrush(Color(255,255,80,245))};
    Color colors[] =
        {Color(255,248,40,18),
         Color(255,245,117,21),
         Color(255,255,171,18),
         Color(255,246,235,20),
         Color(255,213,255,13),
         Color(255,93,253,13),
         Color(255,13,253,218),
         Color(255,14,190,252),
         Color(255,15,116,255),
         Color(255,15,15,255),
         Color(255,207,15,250),
         Color(255,255,80,245)};
     Color colors[] =
        {Color(255,0,0,0),
         Color(255,0,0,180),
         Color(255,0,30,150),
         Color(255,0,60,120),
         Color(255,0,90,90),
         Color(255,0,120,60),
         Color(255,0,150,30),
         Color(255,0,180,0),
         Color(255,30,150,0),
         Color(255,60,120,0),
         Color(255,90,90,0),
         Color(255,120,60,0),
         Color(255,150,30,0),
         Color(255,180,0,0),
         Color(255,150,0,30),
         Color(255,120,0,60),
         Color(255,90,0,90),
         Color(255,60,0,120),
         Color(255,30,0,150)};
*/     Color colors[] =
        {Color(255,0,0,0),
         Color(255,0,0,180),
         Color(255,0,20,160),
         Color(255,0,40,140),
         Color(255,0,60,120),
         Color(255,0,80,100),
         Color(255,0,100,80),
         Color(255,0,120,60),
         Color(255,0,140,40),
         Color(255,0,160,20),
         Color(255,0,180,0),
         Color(255,20,160,0),
         Color(255,40,140,0),
         Color(255,60,120,0),
         Color(255,80,100,0),
         Color(255,100,80,0),
         Color(255,120,60,0),
         Color(255,140,40,0),
         Color(255,160,20,0),
         Color(255,180,0,0),
         Color(255,160,0,20),
         Color(255,140,0,40),
         Color(255,120,0,60),
         Color(255,100,0,80),
         Color(255,80,0,100),
         Color(255,60,0,120),
         Color(255,40,0,140),
         Color(255,20,0,160),
        };
/*    Color colors[] =
        {Color(255,0,0,0),
         Color(255,0,89,186),
         Color(255,0,155,186),
         Color(255,0,186,155),
         Color(255,0,186,27),
         Color(255,186,186,0),
         Color(255,186,155,0),
         Color(255,186,118,0),
         Color(255,186,60,0),
         Color(255,186,0,0),
         Color(255,186,0,186),
         Color(255,97,0,186),
         Color(255,0,4,186)};

    Color colors[2];
    colors[0]=Color(255,rand()%256,rand()%256,rand()%256);
*/
    REAL dx,dy,px,py,x,y;
    REAL xx,yy,xsquared,ysquared;

        dx=(xI-x0)/nx;
        dy=(yI-y0)/ny;
        
        for (py=0; py<ny; py++)
        {
            MSG msg;

            if ((int)py % 50 == 0 &&
                PeekMessage(&msg, hwnd, WM_KEYFIRST, WM_MOUSELAST, PM_NOREMOVE))
                return;

            for (px=0; px<nx; px++)
            {
                x=x0+(px*dx);
                y=y0+(py*dy);

                if (fMandelbrot)
                {
                     cx=x;
                     cy=y;
                     x=0;
                     y=0;
                }
            
                xsquared=0;
                ysquared=0;

                for(i=0; (i<niter)&&(xsquared+ysquared < 4); i++)
                {
                    xsquared= x*x;
                    ysquared= y*y;
                    xx=xsquared - ysquared + cx;
                    yy = x * y * 2 + cy;
                    x = xx;
                    y = yy;
                }

                if (i==niter) 
                    i = 0;
                else
                    i = (i % (ncolors-1)) + 1;

                bitmap.SetPixel((int)px, (int)py, colors[i]);

//            g->FillRectangle((Brush*)&(brushs[i]), (int)px,(int)py,(int)1,(int)1);

            }
        }

        g.DrawImage(&bitmap, 0,0);
}

//index must be in range 0...5f9 (length 5fa)

//#define PLASMA_INDEX_MOD 0x5fa
//#define PLASMA_INDEX_MOD 0x2fd
INT PLASMA_TYPE;
INT PLASMA_INDEX_MOD;
ARGB IndexToSpectrum(INT index)
{
    //index = (index + PLASMA_INDEX_MOD) % PLASMA_INDEX_MOD;

    if ((index < 0) || (index >= PLASMA_INDEX_MOD))
        DebugBreak();
    
    INT r,g,b;

    switch (PLASMA_TYPE)
    {
    case 0:

        r = max(0, min(0xff, (0x1fe - abs(0x2fd - ((index+0x2fd) % PLASMA_INDEX_MOD)))));
        g = max(0, min(0xff, (0x1fe - abs(0x2fd - ((index+0xff) % PLASMA_INDEX_MOD)))));
        b = max(0, min(0xff, (0x1fe - abs(0x2fd - ((index+0x4fb) % PLASMA_INDEX_MOD)))));

        if (!((r == 0xff) || (g == 0xff) || (b == 0xff)))
            DebugBreak();

        if ((r == 0xff) && (g == 0) && (b == 0) && (index != 0))
            DebugBreak();
        break;
    case 1:
        r = 0;
        g = 0;
        b = 0;

        if (index < 0xff)
        {
            r = 0xff - index;
            g = index;
        }
        else if (index < 0x1fe)
        {
            g = 0xff - (index - 0xff);
            b = index - 0xff;
        }
        else
        {
            b = 0xff - (index - 0x1fe);
            r = index - 0x1fe;
        }
        break;
    case 2:
        r = 0xff;
        b = 0xff;
        g = 0xff;

        if (index < 0xff)
        {
            r = index;
            g = 0xff - index;
        }
        else if (index < 0x1fe)
        {
            g = index - 0xff;
            b = 0xff - (index - 0xff);
        }
        else
        {
            b = index - 0x1fe;
            r = 0xff - (index - 0x1fe);
        }
        break;
    }
/*
    return (0xff000000    |
            (BYTE)r << 16 |
            (BYTE)g << 8  |
            (BYTE)b);
*/
    
    return (((rand() % 255) + 1) << 24    |
            (BYTE)r << 16 |
            (BYTE)g << 8  |
            (BYTE)b);

}

INT SpectrumToIndex(ARGB argb)
{

    BYTE r = (BYTE)((argb & 0x00ff0000) >> 16);
    BYTE g = (BYTE)((argb & 0x0000ff00) >> 8);
    BYTE b = (BYTE)(argb & 0x000000ff);

    switch(PLASMA_TYPE)
    {
    case 0:
        //Is red high?
        if (0xff == r)
        {
            //...and is blue present?
            if (b > 0)
            {
                return PLASMA_INDEX_MOD - b;
            }
            else
            {
                return g;
            }
        }
        //how 'bout green?
        if (0xff == g)
        {
            if (r > 0)
            {
                return 0x1fe - r;
            }
            else
            {
                return 0x1fe + b;
            }
        }
        //else blue
        if (0xff == b)
        {
            if (g > 0)
            {
                return 0x3fc - g;
            }
            else
            {
                return 0x3fc + r;
            }
        }

        //WTH?
        DebugBreak();

        break;
    case 1:

        if (r == 0xff)
        {
            return 0;
        }
        if (g != 0)
        {
            if (r > 0)
            {
                return g;
            }
            else
            {
                return 0xff + b;
            }
        }
        if (b != 0)
        {
            return 0x1fe + r;
        }
        break;
    case 2:
        if (b == 0xff)
        {
            return r;
        }
        if (r == 0xff)
        {
            return 0xff + g;
        }
        if (g == 0xff)
        {
            return 0x1fe + b;
        }
        break;
    }
    
    DebugBreak();
    return -1;
}

INT MakeColor(INT c1, INT c2, INT deltamax)
{
    INT c = ((c1 + c2) >> 1) + ((deltamax > 0) ? ((rand() % (2*deltamax)) - deltamax) : 0);

    if (c < 0)
        c = 0;

    if (c > (PLASMA_INDEX_MOD - 1))
        c = PLASMA_INDEX_MOD - 1;

    if ((c < 0) || (c > PLASMA_INDEX_MOD - 1))
        DebugBreak();

    return c;
}

INT MakeColor(INT c1, INT c2, INT c3, INT c4, INT deltamax)
{
    INT c = ((c1 + c2 + c3 + c4) >> 2) + ((deltamax > 0) ? ((rand() % (2*deltamax)) - deltamax) : 0);

    if (c < 0)
        c = 0;

    if (c > (PLASMA_INDEX_MOD - 1))
        c = PLASMA_INDEX_MOD - 1;


    if ((c < 0) || (c > PLASMA_INDEX_MOD - 1))
        DebugBreak();

    return c;
}

BYTE MakeAlpha(BYTE a1, BYTE a2, INT deltamax)
{
    deltamax = (deltamax * 0xff) / PLASMA_INDEX_MOD;

    BYTE a = (((int)a1 + (int)a2) >> 1) + ((deltamax > 0) ? ((rand() % (2*deltamax)) - deltamax) : 0);

    if (a < 1)
        a = 1;

    if (a > 0xff)
        a = 0xff;

    return a;
}

BYTE MakeAlpha(BYTE a1, BYTE a2, BYTE a3, BYTE a4, INT deltamax)
{
    deltamax = (deltamax * 0xff) / PLASMA_INDEX_MOD;

    BYTE a = (((int)a1 + (int)a2 + (int)a3 + (int)a4) >> 2) + ((deltamax > 0) ? ((rand() % (2*deltamax)) - deltamax) : 0);

    if (a < 1)
        a = 1;

    if (a > 0xff)
        a = 0xff;

    return a;
}

//Note that this only works on squares! You want something else? Scale the graphics.
//BOOL HalfPlasma(HWND& hwnd, Graphics& g,BitmapData &bmpd, INT x0, INT y0, INT x1, INT y1, const Color& c00, const Color& c10, const Color& c01, const Color& c11,REAL scale)
BOOL HalfPlasma(HWND& hwnd, Graphics& g,BitmapData &bmpd, INT x0, INT y0, INT x1, INT y1,REAL scale)
{
    MSG msg;

    // Drawing takes a long time, so check for queued message periodically
    if (PeekMessage(&msg, hwnd, WM_KEYFIRST, WM_MOUSELAST, PM_NOREMOVE))
        return FALSE;

    if (((x0 + 1) >= x1) &&
        ((y0 + 1) >= y1))
    {
        return TRUE;
    }

    INT c00 = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x0));
    INT c10 = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x1));
    INT c01 = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x0));
    INT c11 = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x1));
    INT ch0, c0h, c1h, ch1, chh;

    BYTE a00 = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x0) & 0xff000000) >> 24);
    BYTE a10 = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x1) & 0xff000000) >> 24);
    BYTE a01 = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x0) & 0xff000000) >> 24);
    BYTE a11 = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x1) & 0xff000000) >> 24);
    BYTE ah0, a0h, a1h, ah1, ahh;

    INT deltamax = (INT)((x1 - x0)/scale);
    INT half = (x1 + 1 - x0) >> 1;
    INT xh = x0 + half;
    INT yh = y0 + half;

    if (0 == (*((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + xh) & 0xff000000))
    {
        ch0 = MakeColor(c00,c10,deltamax);
        ah0 = MakeAlpha(a00,a10,deltamax);
        *((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + xh) = (IndexToSpectrum(ch0) & 0x00ffffff) | (ah0 << 24);
    }
    else
    {
        ch0 = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + xh));
        ah0 = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + xh) & 0xff000000) >> 24);
    }

    if (0 == (*((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x0) & 0xff000000))
    {
        c0h = MakeColor(c00, c01, deltamax);
        a0h = MakeAlpha(a00, a01, deltamax);
        *((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x0) = (IndexToSpectrum(c0h) & 0x00ffffff) | (a0h << 24);
    }
    else
    {
        c0h = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x0));
        a0h = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x0) & 0xff000000) >> 24);
    }

    if (0 == (*((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x1) & 0xff000000))
    {
        c1h = MakeColor(c10,c11,deltamax);
        a1h = MakeAlpha(a10,a11,deltamax);
        *((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x1) = (IndexToSpectrum(c1h) & 0x00ffffff) | (a1h << 24);
    }
    else
    {
        c1h = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x1));
        a1h = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + x1) & 0xff000000) >> 24);
    }

    if (0 == (*((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + xh) & 0xff000000))
    {
        ch1 = MakeColor(c01,c11,deltamax);
        ah1 = MakeAlpha(a01,a11,deltamax);
        *((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + xh) = (IndexToSpectrum(ch1) & 0x00ffffff) | (ah1 << 24);
    }
    else
    {
        ch1 = SpectrumToIndex(*((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + xh));
        ah1 = (BYTE)((*((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + xh) & 0xff000000) >> 24);
    }

    if (0 == (*((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + xh) & 0xff000000))
    {
        chh = MakeColor(ch0,c0h,c1h,ch1,deltamax);
        ahh = MakeAlpha(ah0,a0h,a1h,ah1,deltamax);
        *((ARGB*)((BYTE*)bmpd.Scan0 + yh*bmpd.Stride) + xh) = (IndexToSpectrum(chh) & 0x00ffffff) | (ahh << 24);
    }

    if (!HalfPlasma(hwnd, g, bmpd,x0,y0,xh,yh,scale)) return FALSE;
    if (!HalfPlasma(hwnd, g, bmpd,xh,y0,x1,yh,scale)) return FALSE;
    if (!HalfPlasma(hwnd, g, bmpd,x0,yh,xh,y1,scale)) return FALSE;
    if (!HalfPlasma(hwnd, g, bmpd,xh,yh,x1,y1,scale)) return FALSE;

    return TRUE;
}

INT fx = 0;
INT fy = 0;

VOID DrawPlasma(HDC hDC, HWND hwnd, RECT rc, int iColor)
{
    Graphics g(hDC);
    INT x0,y0,x1,y1;
    REAL scale;
    BYTE alpha = 255;
    BOOL abort = FALSE;

    INT w = 1;
    INT size = min((rc.right - rc.left), (rc.bottom-rc.top));

    while(size > 0)
    {
        size >>= 1;
        w <<= 1;
    }

    if (rand() % 2)
    {
        w = min(w,1 << ((rand() % 5) + 4));
    }
    else
    {
        w = min(w,32);
    }


    Bitmap bmp(w,w,PixelFormat32bppARGB);
    Rect rect(0,0,w,w);
    BitmapData bmpd;
    bmp.LockBits(rect,0,PixelFormat32bppARGB,&bmpd);

    for (INT x = 0; x < w; x++)
    {
        for (INT y = 0; y < w; y++)
        {
            *((ARGB*)((BYTE*)bmpd.Scan0 + y*bmpd.Stride) + x) = Color::MakeARGB(0,0,0,0);
        }
    }

    x0 = 0;
    y0 = 0;
    x1 = x0 + w - 1;
    y1 = y0 + w - 1;

    switch(PLASMA_TYPE = (rand() % 3))
    {
    case 0:
        PLASMA_INDEX_MOD = 0x5fa;
        break;
    case 1:
    case 2:
        PLASMA_INDEX_MOD = 0x2fd;
        break;
    }

    scale = ((REAL)(w))/((REAL)PLASMA_INDEX_MOD);
    REAL sx = ((REAL)(rc.right-rc.left))/((REAL)(x1 - x0 + 1));
    REAL sy = ((REAL)(rc.bottom-rc.top))/((REAL)(y1 - y0 + 1));
            
    g.SetSmoothingMode(SmoothingModeAntiAlias);

    BYTE intMode = rand() % 3;

    switch(intMode)
    {
    case 2:
        g.SetInterpolationMode(InterpolationModeHighQualityBicubic);
        break;
    case 1:
        g.SetInterpolationMode(InterpolationModeHighQualityBilinear);
        break;
    case 0:
        g.SetInterpolationMode(InterpolationModeNearestNeighbor);
        break;
    }

    /*
    *((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x0) = IndexToSpectrum(rand() % PLASMA_INDEX_MOD) ;
    *((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x1) = IndexToSpectrum(rand() % PLASMA_INDEX_MOD);
    *((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x0) = IndexToSpectrum(rand() % PLASMA_INDEX_MOD);
    *((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x1) = IndexToSpectrum(rand() % PLASMA_INDEX_MOD);
*/

    *((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x0) = (IndexToSpectrum(rand() % PLASMA_INDEX_MOD) & 0x00ffffff) | ((rand() % 255) << 24);
    *((ARGB*)((BYTE*)bmpd.Scan0 + y0*bmpd.Stride) + x1) = (IndexToSpectrum(rand() % PLASMA_INDEX_MOD) & 0x00ffffff) | ((rand() % 255) << 24);;
    *((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x0) = (IndexToSpectrum(rand() % PLASMA_INDEX_MOD) & 0x00ffffff) | ((rand() % 255) << 24);;
    *((ARGB*)((BYTE*)bmpd.Scan0 + y1*bmpd.Stride) + x1) = (IndexToSpectrum(rand() % PLASMA_INDEX_MOD) & 0x00ffffff) | ((rand() % 255) << 24);;

    abort = !HalfPlasma(hwnd,g,bmpd,x0,y0,x1,y1,scale);

    bmp.UnlockBits(&bmpd);

    PointF points[3];

    if (!abort)
    {       

        // Get some good random points.  Limit angles to be > 20 degrees, so
        // there are no skinny rects
        for (int j = 0; j <= 20; j++)
        {
            for (int i = 0; i<= 2; i++)
            {
                points[i].X = (REAL)(rand() % (rc.right - rc.left));
                points[i].Y = (REAL)(rand() % (rc.bottom - rc.top));
            }

            double a,b,c,cosa,cosb,cosc;

            a = sqrt(pow(points[0].X - points[1].X, 2) + pow(points[0].Y - points[1].Y, 2));
            b = sqrt(pow(points[2].X - points[1].X, 2) + pow(points[2].Y - points[1].Y, 2));
            c = sqrt(pow(points[0].X - points[2].X, 2) + pow(points[0].Y - points[2].Y, 2));
            int iMinLen = (int)min(a,min(b,c));

            cosa = (pow(a,2) - pow(b,2) - pow(c,2)) / (-2 * b * c);
            cosb = (pow(b,2) - pow(a,2) - pow(c,2)) / (-2 * a * c);
            cosc = (pow(c,2) - pow(a,2) - pow(b,2)) / (-2 * a * b);
            if ((fabs(cosa) < 0.939) && 
                (fabs(cosb) < 0.939) && 
                (fabs(cosc) < 0.939) &&
                (a > 35))
            {
                break;
            }    
        }

        //g.DrawImage(&bmp,points,3); 
        INT halfKernel = intMode;
        g.DrawImage(&bmp, points, 3, (REAL)-halfKernel, (REAL)-halfKernel, 
                    (REAL)(w+halfKernel), (REAL)(w+halfKernel), UnitPixel, NULL, NULL, NULL); 
    }
}

VOID GetFractalConfig (DWORD *nType, DWORD *nSize)
{

        #define MYBUFFSIZE  32

        HKEY    hKey;
        HRESULT hr;
        DWORD   dwType;
        DWORD   dwBuffLen = sizeof(DWORD);
        
        hr = RegCreateKeyEx(HKEY_CURRENT_USER,
                            HKEY_PREFERENCES,
                            NULL,NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_READ | KEY_WRITE,NULL,&hKey, NULL);
    
        if (ERROR_SUCCESS != hr)
        {
            *nSize = 4;
            *nType = 0;
            goto Done;
        }
    
        hr =  RegQueryValueEx(hKey, TEXT("FractalScnSvrType"),NULL,&dwType,
                              (LPBYTE)nType, &dwBuffLen);
    
        if (ERROR_SUCCESS != hr || dwType != REG_DWORD)
        {
            *nSize = 4;
            *nType = 0;
            goto Done;
        }

        dwBuffLen = MYBUFFSIZE;

        hr =  RegQueryValueEx(hKey, TEXT("FractalScnSvrNumber"),NULL,&dwType,
                              (LPBYTE)nSize, &dwBuffLen);
    
        if (ERROR_SUCCESS != hr || dwType != REG_DWORD)
        {
            *nSize = 4;
        }
Done:
        RegCloseKey(hKey);
    
}

VOID SetFractalConfig (DWORD nType, DWORD nSize)
{
        HKEY    hKey;
        HRESULT hr;
        DWORD   dwType = REG_DWORD;
        
        hr = RegCreateKeyEx(HKEY_CURRENT_USER,
                            HKEY_PREFERENCES,
                            NULL,NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_READ | KEY_WRITE,NULL,&hKey, NULL);
    
        if (ERROR_SUCCESS != hr)
        {
            goto Done;
        }
    
        hr =  RegSetValueEx(hKey, TEXT("FractalScnSvrType"),NULL,dwType,
                              (LPBYTE)&nType, sizeof(DWORD));
    
        if (ERROR_SUCCESS != hr || dwType != REG_DWORD)
        {
            goto Done;
        }

        hr =  RegSetValueEx(hKey, TEXT("FractalScnSvrNumber"),NULL,dwType,
                              (LPBYTE)&nSize, sizeof(DWORD));
    
Done:
        RegCloseKey(hKey);
    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\fractal\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by gdipscsv.rc
//
#define IDS_DESCRIPTION                 1
#define ID_OK                           1001
#define ID_CANCEL                       1002
#define IDC_RADIOTYPE1                  1003
#define IDC_RADIOTYPE2                  1004
#define IDC_RADIOTYPE3                  1005
#define IDC_RADIOTYPE4                  1006
#define IDC_RADIOTYPE5                  1007
#define DLG_SCRNSAVECONFIGURE           2003
#define ID_SPEED                        2004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2009
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           2007
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\fractal\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCEA(240)
#define RT_TOOLBAR  MAKEINTRESOURCEA(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\frametest\frametest.cpp ===
//
// Sample code for using GDI+
//
// Revision History:
//
//   10/01/1999 Min Liu (minliu)
//       Created it.
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <commctrl.h>
#include <objbase.h>
#include <commdlg.h>

#include <initguid.h>
#include "imaging.h"
#include <gdiplus.h>
#include <gdiplusflat.h>
#include "frametest.h"

using namespace Gdiplus;

#include "../gpinit.inc"

#define MYWNDCLASSNAME      "FrameTest"
#define K_DEFAULT_X         0
#define K_DEFAULT_Y         0
#define K_DEFAULT_WIDTH     300
#define K_DEFAULT_HEIGHT    300
#define MAX_FILENAME_LENGTH 1024
#define K_DEFAULT_DELAY     20

CHAR*               g_pcAppName;            // Application name
HINSTANCE           g_hAppInstance;         // Handle of the app instance
CHAR                g_acImageName[MAX_PATH];// Current image filename
INT                 g_iCurrentPageIndex;    // Current page/frame index (0 base)
UINT                g_uiTotalPages = 0;     // Total pages in current image
HWND                g_hwndMain;             // Handle to app's main window
HWND                g_hwndStatus;           // Handle to status window
HWND                g_hwndDecoderDlg;       // Handle to set color key dialog
HWND                g_hwndColorMapDlg;      // Handle to set color map dialog
HWND                g_hwndAnnotationDlg;    // Handle to annotation dialog
HWND                g_hwndJpegSaveDlg;      // Handle to JPEG save dialog
HWND                g_hwndTiffSaveDlg;      // Handle to TIFF save dialog
EncoderParameters*  g_pEncoderParams = NULL;// Encoder parameters

//
// User preferred window size and initial position
//
INT                 g_iWinWidth = K_DEFAULT_WIDTH;
INT                 g_iWinHeight = K_DEFAULT_HEIGHT;
INT                 g_iWinX = K_DEFAULT_X;
INT                 g_iWinY = K_DEFAULT_Y;

//
// Image info
//
UINT                g_ImageWidth;           // Image width
UINT                g_ImageHeight;          // Image height
UINT                g_ImageFlags;           // Image flag
PixelFormat         g_ImagePixelFormat;     // Image pixel format
double              g_ImageXDpi;            // DPI info in X
double              g_ImageYDpi;            // DPI info in Y
GUID                g_ImageRawDataFormat;   // RAW data format

UINT                g_uiDelay = K_DEFAULT_DELAY;
                                            // Delay between frames for anima.
Image*              g_pImage = NULL;        // Pointer to current Image object
ImageAttributes*    g_pDrawAttrib = NULL;   // Pointer to draw attributes
PointF*             g_pDestPoints = NULL;   // Transformation points
INT                 g_DestPointCount = 0;   // number of transformation points
REAL                g_SourceX = NULL;       // current image X offset
REAL                g_SourceY = NULL;       // current image Y offset
REAL                g_SourceWidth = NULL;   // current image width
REAL                g_SourceHeight = NULL;  // current image height
BOOL                g_LoadImageWithICM = TRUE;
                                            // Flag for loading image with ICM
                                            // convertion or not
BOOL                g_bRotated = FALSE;

REAL                g_dScale = 1;

BOOL                g_fFitToWindow_w = FALSE;
BOOL                g_fFitToWindow_h = FALSE;
InterpolationMode   g_InterpolationMode = InterpolationModeHighQualityBicubic;
WrapMode            g_WrapMode = WrapModeTileFlipXY;

void
ValidateArguments(int   argc,
                  char* argv[])
{
    g_pcAppName = *argv++;
    argc--;

    while ( argc > 0 )
    {
        if ( strcmp(*argv, "-w") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_iWinWidth = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-h") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_iWinHeight = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-x") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_iWinX = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-y") == 0 )
        {
            argc--;
            argv++;

            if ( argc == 0 )
            {
                // Not enough parameters

                USAGE();
                exit(1);
            }
            
            g_iWinY = atoi(*argv++);
            argc--;
        }
        else if ( strcmp(*argv, "-?") == 0 )
        {
            USAGE();
            exit(1);
        }
        else
        {
            // Get the image name

            strcpy(g_acImageName, *argv++);
            VERBOSE(("Image file name %s\n",g_acImageName));
            argc--;
        }
    }// while ( argc > 0 )
}// ValidateArguments()

// Update image info

BOOL
UpdateImageInfo()
{
    SizeF sizeF;

    g_ImageWidth = g_pImage->GetWidth();
    g_ImageHeight = g_pImage->GetHeight();
    g_ImageXDpi = g_pImage->GetVerticalResolution();
    g_ImageYDpi = g_pImage->GetHorizontalResolution();    
    g_ImagePixelFormat = g_pImage->GetPixelFormat();
    g_ImageFlags = g_pImage->GetFlags();
    g_pImage->GetRawFormat(&g_ImageRawDataFormat);

    return TRUE;
}// UpdateImageInfo()

//
// Force a refresh of the image window
//
inline VOID
RefreshImageDisplay()
{
    SendMessage(g_hwndMain, WM_ERASEBKGND, WPARAM(GetDC(g_hwndMain)), NULL);

    InvalidateRect(g_hwndMain, NULL, FALSE);

    // Update window title

    CHAR    title[2 * MAX_PATH];
    CHAR*   p = title;

    CHAR myChar = '%';
    sprintf(p, "(%d%c) Page %d of image %s", (INT)(g_dScale * 100), myChar,
            g_iCurrentPageIndex + 1, g_acImageName);

    SetWindowText(g_hwndMain, title);
}// RefreshImageDisplay()

inline void
ResetImageAttribute()
{
    if ( g_pDrawAttrib != NULL )
    {
        delete g_pDrawAttrib;
        g_pDrawAttrib = NULL;
    }

    g_pDrawAttrib = new ImageAttributes();

    g_pDrawAttrib->SetWrapMode(g_WrapMode, Color(0), FALSE);
}// ResetImageAttribute()

//
// Sets up the current page for decompressing in a multi-page image
//
VOID
SetCurrentPage()
{
    // QueryFrame dimension info

    UINT    uiDimCount = g_pImage->GetFrameDimensionsCount();

    GUID*   pMyGuid = (GUID*)malloc(uiDimCount * sizeof(GUID));
    if ( pMyGuid == NULL )
    {
        return;
    }

    Status rCode = g_pImage->GetFrameDimensionsList(pMyGuid, uiDimCount);

    if ( (rCode != Ok) && (rCode != NotImplemented) )
    {
        return;
    }
    // Set current frame

    rCode = g_pImage->SelectActiveFrame(pMyGuid, g_iCurrentPageIndex);

    if ( (rCode != Ok) && (rCode != NotImplemented) )
    {
        VERBOSE(("SelectActiveFrame() failed\n"));
        free(pMyGuid);
        return;
    }

    free(pMyGuid);

    // Get image info for current frame

    if ( UpdateImageInfo() == FALSE )
    {
        VERBOSE(("UpdateImageInfo() failed\n"));
        return;
    }

    // Check if we need to set 'Fit window width"
    // We will do a fit to window iff the "Scale factor is not set" and "Image
    // is bigger than current window"

    HMENU hMenu = GetMenu(g_hwndMain);

    if ( ((INT)g_ImageWidth > g_iWinWidth)
       ||((INT)g_ImageHeight > g_iWinHeight) )
    {
        g_fFitToWindow_w = TRUE;
        g_dScale = (REAL)g_iWinWidth / g_ImageWidth;
        
        CheckMenuItem(hMenu, IDM_VIEW_ZOOM_FITWINDOW_W,
                      MF_BYCOMMAND | MF_CHECKED);
    }
    else
    {
        g_dScale = 1;
        g_fFitToWindow_w = FALSE;
        g_fFitToWindow_h = FALSE;
        CheckMenuItem(hMenu, IDM_VIEW_ZOOM_FITWINDOW_W,
                      MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_VIEW_ZOOM_FITWINDOW_H,
                      MF_BYCOMMAND | MF_UNCHECKED);
    }

    RefreshImageDisplay();
}// SetCurrentPage()

//
// Create an image object from a file
//
BOOL
OpenImageFile(
    const CHAR* filename
    )
{
    if ( (NULL == filename) || (strlen(filename) < 1) )
    {
        return FALSE;
    }

    // We need to free the previous image resource and clean the draw attrib

    if ( g_pImage != NULL )
    {
        delete g_pImage;
    }

    ResetImageAttribute();

    if ( g_pDestPoints != NULL )
    {
        delete g_pDestPoints;
        g_pDestPoints = NULL;
    }

    // Convert filename to a WCHAR

    WCHAR namestr[MAX_FILENAME_LENGTH];

    if ( !AnsiToUnicodeStr(filename, namestr, MAX_FILENAME_LENGTH) )
    {
        VERBOSE(("OpenImageFile:Convert %s to a WCHAR failed\n", filename));
        return FALSE;
    }

    if ( g_LoadImageWithICM == TRUE )
    {
        g_pImage = new Image(namestr, g_LoadImageWithICM);
    }
    else
    {
        g_pImage = new Image(namestr);
    }

    UINT    uiDimCount = g_pImage->GetFrameDimensionsCount();

    GUID*   pMyGuid = (GUID*)malloc(uiDimCount * sizeof(GUID));
    if ( pMyGuid == NULL )
    {
        return FALSE;
    }

    Status rCode = g_pImage->GetFrameDimensionsList(pMyGuid, uiDimCount);

    if ( (rCode != Ok) && (rCode != NotImplemented) )
    {
        return FALSE;
    }
    
    // Get total number of pages in this image
    // !!!Todo need a for() loop here

    g_uiTotalPages = g_pImage->GetFrameCount(pMyGuid);
    if ( g_uiTotalPages == 0 )
    {
        // If the decoder doesn't support frame count query, we can just
        // assume it has only 1 image. For example, gif decoder will fail
        // if the query GUID is FRAMEDIM_PAGE

        g_uiTotalPages = 1;
    }
    g_iCurrentPageIndex = 0;

    if ( pMyGuid != NULL )
    {
        free(pMyGuid);
    }

    SetCurrentPage();

    return TRUE;
}// OpenImageFile()

//
// Open image file
//
VOID
DoOpen(
    HWND hwnd
    )
{
    OPENFILENAME    ofn;

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = g_hAppInstance;
    ofn.lpstrFile = g_acImageName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Open Image File";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_FILEMUSTEXIST;
    g_acImageName[0] = '\0';

    // Make up the file type filter string

    ImageCodecInfo* codecs;
    UINT            count;
    if ( g_pDestPoints != NULL )
    {
        free(g_pDestPoints);
    }
    g_DestPointCount = 0;
    GpStatus status;
    UINT cbCodecs = 0;
    GetImageDecodersSize(&count, &cbCodecs);
    codecs = static_cast<ImageCodecInfo *>(malloc (cbCodecs));
    if (codecs == NULL)
    {
        return;
    }
    status = GetImageDecoders(count, cbCodecs, codecs);
    if (status != Ok)
    {
        return;
    }

    CHAR* filter = MakeFilterFromCodecs(count, codecs, TRUE);

    if (codecs)
    {
        free(codecs);
    }

    if ( !filter )
    {
        VERBOSE(("DoOpen--MakeFilterFromCodecs() failed\n"));
        return;
    }

    ofn.lpstrFilter = filter;

    // Present the file/open dialog

    if ( GetOpenFileName(&ofn) )
    {
        OpenImageFile(g_acImageName);
    }

    free(filter);
}// DoOpen()

//
// Open image file
//
VOID
DoOpenAudioFile(
    HWND hwnd
    )
{
    OPENFILENAME    ofn;
    char    audioFileName[256];

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = g_hAppInstance;
    ofn.lpstrFile = audioFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Attach Audio File To Image";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_FILEMUSTEXIST;
    g_acImageName[0] = '\0';

    // Make up the file type filter string

    ofn.lpstrFilter = ".wav";

    // Present the file/open dialog

    if ( GetOpenFileName(&ofn) )
    {
        UINT    uiTextLength = strlen(audioFileName);
        
        PropertyItem myItem;
        myItem.id = PropertyTagExifRelatedWav;
        myItem.length = uiTextLength;
        myItem.type = TAG_TYPE_ASCII;

        myItem.value = malloc(uiTextLength);
        if ( myItem.value != NULL )
        {
            strcpy((char*)myItem.value, audioFileName);
        
            Status rCode = g_pImage->SetPropertyItem(&myItem);
            if ( (rCode != Ok) && (rCode != NotImplemented) )
            {
                VERBOSE(("SetPropertyItem() failed\n"));
            }
        }
    }
}// DoOpenAudioFile()

#define STEPS 100

VOID
CreateBackgroundBitmap()
{
    BitmapData bmpData;

    Bitmap* myBmp = new Bitmap(g_iWinWidth, g_iWinHeight, PIXFMT_32BPP_ARGB);

    Rect rect(0, 0, g_iWinWidth, g_iWinHeight);
    Status status = myBmp->LockBits(&rect,
                                    ImageLockModeWrite,
                                    PIXFMT_32BPP_ARGB,
                                    &bmpData);

    // Make a horizontal blue gradient

    UINT x, y;
    ARGB colors[STEPS];

    for (x=0; x < STEPS; x++)
    {
        colors[x] = MAKEARGB(128, 0, 0, x * 255 / (STEPS-1));
    }

    for (y=0; y < STEPS; y++)
    {
        ARGB* p = (ARGB*)((BYTE*)bmpData.Scan0 + y * bmpData.Stride);

        for (x=0; x < STEPS; x++)
        {
            *p++ = colors[(x+y) % STEPS];
        }
    }

    status = myBmp->UnlockBits(&bmpData);

    if ( g_pImage != NULL )
    {
        delete g_pImage;
        g_pImage = NULL;
    }

    g_pImage = myBmp;

    UpdateImageInfo();

    return;
}// CreateBackgroundBitmap()

//
// Handle window repaint event
//
VOID
DoPaint(
    HWND hwnd,
    HDC *phdc = NULL
    )
{
    if ( g_pImage == NULL )
    {
        return;
    }
    else
    {
        HDC         hdc;
        PAINTSTRUCT ps;
        RECT        rect;
        ImageInfo   imageInfo;

        if (!phdc)
        {
            hdc = BeginPaint(hwnd, &ps);
        }
        else
        {
            hdc = *phdc;
        }

        // Get current window's client area. Used for paint later

        GetClientRect(hwnd, &rect);

        ULONG   ulWinWidth = (ULONG)(rect.right - rect.left);
        ULONG   ulWinHeight = (ULONG)(rect.bottom - rect.top);

        // Make up a dest rect that we need image to draw to

        REAL    dDestImageWidth = g_ImageWidth * g_dScale;
        REAL    dDestImageHeight = g_ImageHeight * g_dScale;
        
        Rect    dstRect(rect.left, rect.top, (UINT)(dDestImageWidth),
                        (UINT)(dDestImageHeight));

        RectF srcRect;
        Unit  srcUnit;

        g_pImage->GetBounds(&srcRect, &srcUnit);

        Graphics* pGraphics = new Graphics(hdc);
        if ( pGraphics == NULL )
        {
            VERBOSE(("DoPaint--new Graphics() failed"));
            return;
        }

        pGraphics->SetInterpolationMode(g_InterpolationMode);

        // Width and height, in pixel, of the src image need to be drawn

        UINT    uiImageWidth = g_ImageWidth;
        UINT    uiImageHeight = g_ImageHeight;

        // Adjust the src image region need to be drawn.
        // If the image is bigger than the viewable area, we just need to
        // paint partial image, the viewable size
#if 0
        if ( ulWinWidth < dDestImageWidth )
        {
            uiImageWidth = (UINT)(ulWinWidth / g_dScale);
        }

        if ( ulWinHeight < uiImageHeight )
        {
            uiImageHeight = (UINT)(ulWinHeight / g_dScale);
        }
#endif

        if ( (g_DestPointCount == 0) && (g_SourceWidth == 0) )
        {
            // Simple case, draw to destRect

            pGraphics->DrawImage(g_pImage,
                                 dstRect,
                                 (UINT)srcRect.GetLeft(),
                                 (UINT)srcRect.GetTop(),
                                 uiImageWidth,
                                 uiImageHeight,
                                 UnitPixel,
                                 g_pDrawAttrib,
                                 NULL,
                                 NULL);
        }
        else if ( (g_DestPointCount == 0) && (g_SourceWidth != 0) )
        {
            // This case will allow cropping, etc.

            pGraphics->DrawImage(g_pImage,
                                 dstRect,
                                 (int)g_SourceX,
                                 (int)g_SourceY,
                                 (int)g_SourceWidth,
                                 (int)g_SourceHeight,
                                 UnitPixel,
                                 g_pDrawAttrib,
                                 NULL,
                                 NULL);
        }
        else if ( (g_DestPointCount != 0) && (g_SourceWidth == 0) )
        {
            // This case will allow cropping, etc.

            if ( g_DestPointCount == 4 )
            {
                // Hack until draw image support 4 transform points

                pGraphics->DrawImage(g_pImage,
                                     g_pDestPoints,
                                     3,
                                     0,
                                     0,
                                     (float)uiImageWidth,
                                     (float)uiImageHeight,
                                     UnitPixel,
                                     g_pDrawAttrib,
                                     NULL,
                                     NULL);
            }
            else
            {
                pGraphics->DrawImage(g_pImage,
                                     g_pDestPoints,
                                     g_DestPointCount,
                                     0,
                                     0,
                                     (float)uiImageWidth,
                                     (float)uiImageHeight,
                                     UnitPixel,
                                     g_pDrawAttrib,
                                     NULL,
                                     NULL);
            }
        }
        else
        {
            // This case will allow both cropping and rotation

            if ( g_DestPointCount == 4 )
            {
                // Hack until DrawImage supports 4 transform points

                pGraphics->DrawImage(g_pImage,
                                     g_pDestPoints,
                                     3,
                                     g_SourceX,
                                     g_SourceY,
                                     g_SourceWidth,
                                     g_SourceHeight,
                                     UnitPixel,
                                     g_pDrawAttrib,
                                     NULL,
                                     NULL);
            }
            else
            {
                pGraphics->DrawImage(g_pImage,
                                     g_pDestPoints,
                                     g_DestPointCount,
                                     g_SourceX,
                                     g_SourceY,
                                     g_SourceWidth,
                                     g_SourceHeight,
                                     UnitPixel,
                                     g_pDrawAttrib,
                                     NULL,
                                     NULL);
            }
        }

        delete pGraphics;

//        FillRect(hdc, &rect, (HBRUSH)GetStockObject(BLACK_BRUSH));

        if (!phdc)
            EndPaint(hwnd, &ps);
    }
}// DoPaint()

VOID
DoPrint(HWND hwnd)
{
    PRINTDLG printdlg;
    memset(&printdlg, 0, sizeof(PRINTDLG));
    printdlg.lStructSize = sizeof(PRINTDLG);
    printdlg.hwndOwner = hwnd;
    DEVMODE dm;
    memset(&dm, 0, sizeof(DEVMODE));
    dm.dmICMMethod = DMICMMETHOD_SYSTEM;
    printdlg.hDevMode = &dm;
    printdlg.hDevNames = NULL;
    printdlg.hDC = NULL;
    printdlg.Flags = PD_RETURNDC;
    if (PrintDlg(&printdlg))
    {        
        DOCINFO di;
        memset(&di, 0, sizeof(DOCINFO));
        di.cbSize = sizeof(DOCINFO);
        di.lpszDocName = g_acImageName;
        di.lpszOutput = (LPTSTR)NULL;
        di.lpszDatatype = (LPTSTR)NULL;
        di.fwType = 0;
        StartDoc(printdlg.hDC, &di);
        StartPage(printdlg.hDC);

        // Use GDI+ printing code to do the real print job

        DoPaint(hwnd, &printdlg.hDC);
        
        EndPage(printdlg.hDC);
        EndDoc(printdlg.hDC);
    }
    else
    {
        DWORD error = CommDlgExtendedError();
        if (error)
        {
            char errormessage[100];
            sprintf(errormessage, "PrintDlg error: %d", error);
            MessageBox(hwnd, errormessage, "PrintDlg error", MB_OK);
        }
    }
}// DoPrint()

BOOL
SetJpegDefaultParameters()
{
    // Set default quality level as 100, unsigned value

    SetDlgItemInt(g_hwndJpegSaveDlg, IDC_SAVEJPEG_QEFIELD, 100, FALSE);
    
    // Set No transform as default

    CheckRadioButton(g_hwndJpegSaveDlg,
                     IDC_SAVEJPEG_R90,
                     IDC_SAVEJPEG_NOTRANSFORM,
                     IDC_SAVEJPEG_NOTRANSFORM);
    
    return TRUE;
}// SetJpegDefaultParameters()

BOOL
SetTiffDefaultParameters()
{
    // Set default color depth and compression method as the same as current
    // image

    CheckRadioButton(g_hwndTiffSaveDlg,
                     IDC_SAVETIFF_1BPP,
                     IDC_SAVETIFF_ASSOURCE,
                     IDC_SAVETIFF_ASSOURCE);
    
    CheckRadioButton(g_hwndTiffSaveDlg,
                     IDC_SAVETIFF_CCITT4,
                     IDC_SAVETIFF_COMPASSOURCE,
                     IDC_SAVETIFF_COMPASSOURCE);

    // If the source image is multi-frame, check "save as multi-frame" on

    if ( g_uiTotalPages > 1 )
    {
        SendDlgItemMessage(g_hwndTiffSaveDlg, IDC_SAVETIFF_MULTIFRAME,
                           BM_SETCHECK, 0, 0);
    }
    
    return TRUE;
}// SetTiffDefaultParameters()

/*****************************************************************************\
*
*  FUNCTION   : DecoderParamDlgProc(hDlg, uiMessage, wParam, lParam)
*
*  PURPOSE    : Dialog function for the Decoder Parameter settings dialog
*
\*****************************************************************************/
BOOL APIENTRY
DecoderParamDlgProc(
    HWND         hDlg,
    UINT         uiMessage,
    UINT         wParam,
    LONG         lParam
    )
{
    switch ( uiMessage )
    {
    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDC_COLORKEY_CANCEL:
            // End the dialog and return FALSE. So we won't do anything

            EndDialog(hDlg, FALSE);

            break;

        case IDC_COLORKEY_OK:
            // User hit the OK button. First, we need to get the values user
            // entered

            char    acTemp[20];
            UINT    uiTempLow;
            UINT    uiTempHigh;

            UINT    TransKeyLow = 0x0;
            UINT    TransKeyHigh = 0x0;

            // Get the RED key

            uiTempLow = GetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_RFIELD,
                                      NULL, FALSE);
            uiTempHigh = GetDlgItemInt(g_hwndDecoderDlg,
                                       IDC_TRANS_HIGHER_RFIELD, NULL, FALSE);

            if ( (uiTempLow > 255) || (uiTempHigh > 255)
               ||(uiTempLow > uiTempHigh) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));
                VERBOSE(("Lower key should be smaller or equal to higher key"));
                
                break;
            }

            TransKeyLow = ((uiTempLow & 0xff) << 16);
            TransKeyHigh = ((uiTempHigh & 0xff) << 16);

            // Get the Green key

            uiTempLow = GetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_GFIELD,
                                      NULL, FALSE);
            uiTempHigh = GetDlgItemInt(g_hwndDecoderDlg,
                                       IDC_TRANS_HIGHER_GFIELD, NULL, FALSE);

            if ( (uiTempLow > 255)
               ||(uiTempHigh > 255)
               ||(uiTempLow > uiTempHigh) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));
                VERBOSE(("Lower key should be smaller or equal to higher key"));
                
                break;
            }

            TransKeyLow |= ((uiTempLow & 0xff) << 8);
            TransKeyHigh |= ((uiTempHigh & 0xff) << 8);
            
            // Get the Blue key

            uiTempLow = GetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_BFIELD,
                                      NULL, FALSE);
            uiTempHigh = GetDlgItemInt(g_hwndDecoderDlg,
                                       IDC_TRANS_HIGHER_BFIELD, NULL, FALSE);

            if ( (uiTempLow > 255)
               ||(uiTempHigh > 255)
               ||(uiTempLow > uiTempHigh) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));
                VERBOSE(("Lower key should be smaller or equal to higher key"));
                
                break;
            }

            TransKeyLow |= (uiTempLow & 0xff);
            TransKeyHigh |= (uiTempHigh & 0xff);
            
            // Get the C key

            uiTempLow = GetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_CFIELD,
                                      NULL, FALSE);
            uiTempHigh = GetDlgItemInt(g_hwndDecoderDlg,
                                       IDC_TRANS_HIGHER_CFIELD, NULL, FALSE);

            if ( (uiTempLow > 255)
               ||(uiTempHigh > 255)
               ||(uiTempLow > uiTempHigh) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));
                VERBOSE(("Lower key should be smaller or equal to higher key"));
                
                break;
            }

            TransKeyLow |= ((uiTempLow & 0xff) << 24);
            TransKeyHigh |= ((uiTempHigh & 0xff) << 24);
            
            // Up to this point, the TRANSKEY, lower and higher, should be in
            // the format of 0x00RRGGBB for RGB image or 0xCCMMYYKK for CMYK
            // image
            
            // Set draw attributes

            if ( g_pDrawAttrib != NULL )
            {
                delete g_pDrawAttrib;
            }

            g_pDrawAttrib = new ImageAttributes();
                
            Color   lowKey(TransKeyLow);
            Color   highKey(TransKeyHigh);
                    
            g_pDrawAttrib->SetColorKey(lowKey, highKey);

            RefreshImageDisplay();

            EndDialog(hDlg, TRUE);
            
            break;
        }// switch on WM_COMMAND

        break;

    case WM_INITDIALOG:
        // Remember the dialog handle so that we can use it to deal with items
        // in this dialog

        g_hwndDecoderDlg = hDlg;

        // Set initial values

        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_RFIELD, 250, FALSE);
        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_GFIELD, 250, FALSE);
        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_BFIELD, 250, FALSE);
        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_LOWER_CFIELD, 250, FALSE);
        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_HIGHER_RFIELD, 255, FALSE);
        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_HIGHER_GFIELD, 255, FALSE);
        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_HIGHER_BFIELD, 255, FALSE);
        SetDlgItemInt(g_hwndDecoderDlg, IDC_TRANS_HIGHER_CFIELD, 255, FALSE);

        return TRUE;
    }

    return FALSE;
}// DecoderParamDlgProc()

BOOL APIENTRY
ColorMapDlgProc(
    HWND         hDlg,
    UINT         uiMessage,
    UINT         wParam,
    LONG         lParam
    )
{
    switch ( uiMessage )
    {
    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDC_COLORMAP_CANCEL:
            // End the dialog and return FALSE. So we won't do anything

            EndDialog(hDlg, FALSE);

            break;

        case IDC_COLORMAP_OK:
            // User hit the OK button. First, we need to get the values user
            // entered
            
            if ( NULL == g_pImage )
            {
                // If there is no image, just close the dialog

                EndDialog(hDlg, TRUE);

                break;
            }

            char    acTemp[20];
            UINT    uiOldR;
            UINT    uiNewR;
            UINT    uiOldG;
            UINT    uiNewG;
            UINT    uiOldB;
            UINT    uiNewB;
            UINT    uiOldA;
            UINT    uiNewA;

            // Get the RED key

            uiOldR = GetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_RFIELD,
                                   NULL, FALSE);
            uiNewR = GetDlgItemInt(g_hwndColorMapDlg,
                                   IDC_MAP_NEW_RFIELD, NULL, FALSE);

            if ( (uiOldR > 255) || (uiNewR > 255) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));                
                break;
            }

            // Get the Green key

            uiOldG = GetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_GFIELD,
                                   NULL, FALSE);
            uiNewG = GetDlgItemInt(g_hwndColorMapDlg,
                                   IDC_MAP_NEW_GFIELD, NULL, FALSE);

            if ( (uiOldG > 255) || (uiNewG > 255) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));                
                break;
            }

            // Get the Blue key

            uiOldB = GetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_BFIELD,
                                   NULL, FALSE);
            uiNewB = GetDlgItemInt(g_hwndColorMapDlg,
                                   IDC_MAP_NEW_BFIELD, NULL, FALSE);

            if ( (uiOldB > 255) || (uiNewB > 255) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));                
                break;
            }

            // Get the A key

            uiOldA = GetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_AFIELD,
                                   NULL, FALSE);
            uiNewA = GetDlgItemInt(g_hwndColorMapDlg,
                                   IDC_MAP_NEW_AFIELD, NULL, FALSE);

            if ( (uiOldA > 255) || (uiNewA > 255) )
            {
                VERBOSE(("Input key value should be within 0 to 255"));                
                break;
            }

            // Set draw attributes
            
            if ( g_pDrawAttrib == NULL )
            {
                g_pDrawAttrib = new ImageAttributes();
                if ( g_pDrawAttrib == NULL )
                {
                    return FALSE;
                }
            }

            ColorMap myColorMap;
            Color   oldColor((BYTE)uiOldA, (BYTE)uiOldR, (BYTE)uiOldG,
                             (BYTE)uiOldB);
            Color   newColor((BYTE)uiNewA, (BYTE)uiNewR, (BYTE)uiNewG,
                             (BYTE)uiNewB);

            myColorMap.oldColor = oldColor;
            myColorMap.newColor = newColor;

            g_pDrawAttrib->SetRemapTable(1, &myColorMap, ColorAdjustTypeBitmap);
                                    
            RefreshImageDisplay();
            EndDialog(hDlg, TRUE);
            
            break;
        }// switch()

        break;

    case WM_INITDIALOG:
        // Remember the dialog handle so that we can use it to deal with items
        // in this dialog

        g_hwndColorMapDlg = hDlg;

        // Set initial values

        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_RFIELD, 255, FALSE);
        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_GFIELD, 0, FALSE);
        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_BFIELD, 0, FALSE);
        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_OLD_AFIELD, 255, FALSE);
        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_NEW_RFIELD, 0, FALSE);
        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_NEW_GFIELD, 255, FALSE);
        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_NEW_BFIELD, 0, FALSE);
        SetDlgItemInt(g_hwndColorMapDlg, IDC_MAP_NEW_AFIELD, 255, FALSE);

        return TRUE;
    }// switch ( uiMessage )

    return FALSE;
}// ColorMapDlgProc()

BOOL APIENTRY
AnnotationDlgProc(
    HWND         hDlg,
    UINT         uiMessage,
    UINT         wParam,
    LONG         lParam
    )
{
    switch ( uiMessage )
    {
    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDC_ANNOTATION_CANCEL:
            // End the dialog and return FALSE. So we won't do anything

            EndDialog(hDlg, FALSE);

            break;

        case IDC_ANNOTATION_OK:
            // User hit the OK button. First, we need to get the values user
            // entered
            
            if ( NULL == g_pImage )
            {
                // If there is no image, just close the dialog

                EndDialog(hDlg, TRUE);

                break;
            }

            char    acTemp[200];
            UINT    uiTextLength = 0;

            uiTextLength = GetDlgItemText(g_hwndAnnotationDlg,
                                          IDC_ANNOTATION_EDITOR, acTemp, 200);
            
            if ( uiTextLength > 0 )
            {
                // Add 1 for the NULL terminator

                uiTextLength++;

                PropertyItem myItem;
                myItem.id = PropertyTagExifUserComment;
                myItem.length = uiTextLength;
                myItem.type = TAG_TYPE_ASCII;

                myItem.value = malloc(uiTextLength);
                if ( myItem.value != NULL )
                {
                    strcpy((char*)myItem.value, acTemp);

                    Status rCode = g_pImage->SetPropertyItem(&myItem);
                    if ( (rCode != Ok) && (rCode != NotImplemented) )
                    {
                        VERBOSE(("SetPropertyItem() failed\n"));
                    }
                    
                    free(myItem.value);
                }
            }

            EndDialog(hDlg, TRUE);
            
            break;
        }// switch()

        break;

    case WM_INITDIALOG:
        // Remember the dialog handle so that we can use it to deal with items
        // in this dialog

        g_hwndAnnotationDlg = hDlg;

        // Check to see if the image has annotation in it

        // Check the size for this property item

        if ( g_pImage != NULL )
        {
            UINT uiItemSize = g_pImage->GetPropertyItemSize(
                                                    PropertyTagExifUserComment);

            if ( uiItemSize != 0 )
            {
                // Allocate memory and get this property item

                PropertyItem* pBuffer = (PropertyItem*)malloc(uiItemSize);
                if ( pBuffer == NULL )
                {
                    return FALSE;
                }

                if ( g_pImage->GetPropertyItem(PropertyTagExifUserComment,
                                               uiItemSize, pBuffer) == Ok )
                {        
                    // Set initial values

                    SetDlgItemText(g_hwndAnnotationDlg, IDC_ANNOTATION_EDITOR,
                                  (char*)pBuffer->value);
                    return TRUE;
                }
                else
                {
                    // Can't get property item. Something wrong

                    return FALSE;
                }
            }
            else
            {
                // No this property item, just initialize it with NULL

                SetDlgItemText(g_hwndAnnotationDlg, IDC_ANNOTATION_EDITOR, "");
            }
        }
        
        return TRUE;
    }// switch ( uiMessage )

    return FALSE;
}// AnnotationDlgProc()

#define  NO_TRANSFORM 9999

/*****************************************************************************\
*
*  FUNCTION   : JpegSaveDlgProc(hDlg, uiMessage, wParam, lParam)
*
*  PURPOSE    : Dialog function for the Encoder Parameter settings dialog
*
\*****************************************************************************/
BOOL APIENTRY
JpegSaveDlgProc(
    HWND         hDlg,
    UINT         uiMessage,
    UINT         wParam,
    LONG         lParam
    )
{
    static ULONG   flagValueTransform = NO_TRANSFORM; // No transform at all

    switch ( uiMessage )
    {
    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDC_SAVEJPEG_CANCEL:
            // End the dialog and return FALSE. So we won't save this image

            EndDialog(hDlg, FALSE);

            break;

        case IDC_SAVEJPEG_OK:
            // User hit the OK button. First, we need to set the EncoderParam
            // based on user selection

            if ( g_pImage == NULL )
            {
                VERBOSE(("EncoderParamDlgProc: No image avail\n"));
                EndDialog(hDlg, FALSE);
            }
            else
            {
                if ( g_pEncoderParams != NULL )
                {
                    free(g_pEncoderParams);
                    g_pEncoderParams = NULL;
                }
                
                if ( flagValueTransform != NO_TRANSFORM )
                {
                    // User has set lossless transform, so we need set encoder
                    // parameter

                    g_pEncoderParams =
                         (EncoderParameters*)malloc(sizeof(EncoderParameters));

                    g_pEncoderParams->Parameter[0].Guid = EncoderTransformation;
                    g_pEncoderParams->Parameter[0].Type =
                                                EncoderParameterValueTypeLong;
                    g_pEncoderParams->Parameter[0].NumberOfValues = 1;
                    g_pEncoderParams->Parameter[0].Value =
                                                (VOID*)&flagValueTransform;
                    g_pEncoderParams->Count = 1;
                }

                EndDialog(hDlg, TRUE);
            }
            
            break;

        case IDC_SAVEJPEG_R90:
            flagValueTransform = EncoderValueTransformRotate90;
            break;

        case IDC_SAVEJPEG_R180:
            flagValueTransform = EncoderValueTransformRotate180;
            break;
        
        case IDC_SAVEJPEG_R270:
            flagValueTransform = EncoderValueTransformRotate270;
            break;
        
        case IDC_SAVEJPEG_HFLIP:
            flagValueTransform = EncoderValueTransformFlipHorizontal;
            break;
        
        case IDC_SAVEJPEG_VFLIP:
            flagValueTransform = EncoderValueTransformFlipVertical;
            break;
        
        default:
            break;
        }

        break;

    case WM_INITDIALOG:
        // Remember the dialog handle so that we can use it to deal with items
        // in this dialog

        g_hwndJpegSaveDlg = hDlg;
        flagValueTransform = NO_TRANSFORM;

        SetJpegDefaultParameters();

        return TRUE;
    }

    return FALSE;
}// JpegSaveDlgProc()

/*****************************************************************************\
*
*  FUNCTION   : TiffSaveDlgProc(hDlg, uiMessage, wParam, lParam)
*
*  PURPOSE    : Dialog function for the Encoder Parameter settings dialog
*
\*****************************************************************************/
BOOL APIENTRY
TiffSaveDlgProc(
    HWND         hDlg,
    UINT         uiMessage,
    UINT         wParam,
    LONG         lParam
    )
{
    static PixelFormat   flagColorDepth = g_ImagePixelFormat; // Default color depth
    static compressMethod = 0;
    static ULONG   colorTemp = 0;

    switch ( uiMessage )
    {
    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDC_SAVETIFFDLG_CANCEL:
            // End the dialog and return FALSE. So we won't save this image

            EndDialog(hDlg, FALSE);

            break;

        case IDC_SAVETIFFDLG_OK:
        {
            // User hit the OK button. First, we need to set the EncoderParam
            // based on user selection

            if ( g_pImage == NULL )
            {
                VERBOSE(("EncoderParamDlgProc: No image avail\n"));
                EndDialog(hDlg, FALSE);
            }
            else
            {
                if ( g_pEncoderParams != NULL )
                {
                    free(g_pEncoderParams);
                    g_pEncoderParams = NULL;
                }
                
                UINT    numOfParamSet = 0;

                if ( flagColorDepth != g_ImagePixelFormat )
                {
                    numOfParamSet++;
                }

                if ( compressMethod != 0 )
                {
                    numOfParamSet++;
                }

                if ( numOfParamSet > 0 )
                {
                    int iTemp = 0;

                    // User has set new color depth, so we need set encoder
                    // parameter for it

                    g_pEncoderParams =
                        (EncoderParameters*)malloc(sizeof(EncoderParameters) +
                                     numOfParamSet * sizeof(EncoderParameter));

                    if ( compressMethod != 0 )
                    {
                        // Set compression method

                        g_pEncoderParams->Parameter[iTemp].Guid =
                                                EncoderCompression;
                        g_pEncoderParams->Parameter[iTemp].Type =
                                                EncoderParameterValueTypeLong;
                        g_pEncoderParams->Parameter[iTemp].NumberOfValues = 1;
                        g_pEncoderParams->Parameter[iTemp].Value =
                                                (VOID*)&compressMethod;

                        iTemp++;
                        g_pEncoderParams->Count = iTemp;
                    }

                    if ( flagColorDepth != g_ImagePixelFormat )
                    {
                        // Set color depth

                        g_pEncoderParams->Parameter[iTemp].Guid =
                                                EncoderColorDepth;
                        g_pEncoderParams->Parameter[iTemp].Type =
                                                EncoderParameterValueTypeLong;
                        g_pEncoderParams->Parameter[iTemp].NumberOfValues = 1;
                        g_pEncoderParams->Parameter[iTemp].Value =
                                                (VOID*)&colorTemp;

                        iTemp++;
                        g_pEncoderParams->Count = iTemp;
                    }                    
                }// if ( numOfParamSet > 0 )
                
                EndDialog(hDlg, TRUE);
            }
        }
            
            break;

        case IDC_SAVETIFF_1BPP:
            flagColorDepth = PIXFMT_1BPP_INDEXED;
            colorTemp = 1;
            break;

        case IDC_SAVETIFF_4BPP:
            flagColorDepth = PIXFMT_4BPP_INDEXED;
            colorTemp = 4;
            break;
        
        case IDC_SAVETIFF_8BPP:
            flagColorDepth = PIXFMT_8BPP_INDEXED;
            colorTemp = 8;
            break;
        
        case IDC_SAVETIFF_24BPP:
            flagColorDepth = PIXFMT_24BPP_RGB;
            colorTemp = 24;
            break;
        
        case IDC_SAVETIFF_32ARGB:
            flagColorDepth = PIXFMT_32BPP_ARGB;
            colorTemp = 32;
            break;
        
        case IDC_SAVETIFF_CCITT3:
            compressMethod = EncoderValueCompressionCCITT3;
            break;

        case IDC_SAVETIFF_CCITT4:
            compressMethod = EncoderValueCompressionCCITT4;
            break;
        
        case IDC_SAVETIFF_RLE:
            compressMethod = EncoderValueCompressionRle;
            break;

        case IDC_SAVETIFF_LZW:
            compressMethod = EncoderValueCompressionLZW;
            break;

        case IDC_SAVETIFF_UNCOMPRESSED:
            compressMethod = EncoderValueCompressionNone;
            break;

        case IDC_SAVETIFF_COMPASSOURCE:
            compressMethod = 0;
            break;

        default:
            break;
        }

        break;

    case WM_INITDIALOG:
        // Remember the dialog handle so that we can use it to deal with items
        // in this dialog

        g_hwndTiffSaveDlg = hDlg;
        flagColorDepth = g_ImagePixelFormat; // Default color depth
        compressMethod = 0;
        colorTemp = 0;

        SetTiffDefaultParameters();

        return TRUE;
    }

    return FALSE;
}// TiffSaveDlgProc()

BOOL
StartSaveImage(
    const CHAR*     filename,
    const CLSID*    clsid
    )
{
    // Convert filename to a WCHAR

    WCHAR namestr[MAX_FILENAME_LENGTH];

    if ( !AnsiToUnicodeStr(filename, namestr, MAX_FILENAME_LENGTH) )
    {
        VERBOSE(("StartSaveImage: Convert %s to a WCHAR failed\n", filename));

        return FALSE;
    }

    if ( g_pImage != NULL )
    {
        CLSID tempClsID = *clsid;
        Status rCode = Ok;

        // Popup a dialog to let user set up the encoder parameters

        if ( tempClsID == K_JPEGCLSID )
        {
            if ( ShowMyDialog((INT)IDD_SAVEJPEGDLG, g_hwndMain,
                              (FARPROC)JpegSaveDlgProc) == FALSE )
            {
                return FALSE;
            }
        }
        else if ( tempClsID == K_TIFFCLSID )
        {
            if ( ShowMyDialog((INT)IDD_SAVETIFFDLG, g_hwndMain,
                              (FARPROC)TiffSaveDlgProc) == FALSE )
            {
                return FALSE;
            }
        }

        // Note: during the save dialog, the g_pEncoderParams will be set
        // depends on the user selection. Default is NULL

        rCode = g_pImage->Save(namestr, &tempClsID, g_pEncoderParams);

        free(g_pEncoderParams);
        g_pEncoderParams = NULL;

        if ( (rCode != Ok) && (rCode != NotImplemented) )
        {
            VERBOSE(("StartSaveImage--SaveToFile() failed\n"));
            return FALSE;
        }

        return TRUE;
    }
    else
    {
        VERBOSE(("StartSaveImage(): No image to save\n"));
        return FALSE;
    }
}// StartSaveImage()

BOOL
SaveCurrentFrame()
{
    GUID    guid = FRAMEDIM_PAGE;
    
    if ( NULL == g_pImage )
    {
        VERBOSE(("SaveCurrentFrame(): No image available\n"));
        return FALSE;
    }

    Status rCode = Ok;
        
        // Append the current frame

        ULONG  flagValueLastFrame = EncoderValueLastFrame;
        ULONG  flagValueDim = EncoderValueFrameDimensionPage;

        EncoderParameters*  pMyEncoderParams = (EncoderParameters*)malloc
                                               (2 * sizeof(EncoderParameters));

        pMyEncoderParams->Parameter[0].Guid = EncoderSaveFlag;
        pMyEncoderParams->Parameter[0].Type = EncoderParameterValueTypeLong;
        pMyEncoderParams->Parameter[0].NumberOfValues = 1;
        pMyEncoderParams->Parameter[0].Value = (VOID*)&flagValueDim;
        
#if 0
        pMyEncoderParams->Parameter[1].Guid = EncoderSaveFlag;
        pMyEncoderParams->Parameter[1].Type = EncoderParameterValueTypeLong;
        pMyEncoderParams->Parameter[1].NumberOfValues = 1;
        pMyEncoderParams->Parameter[1].Value = (VOID*)& flagValueLastFrame;

        pMyEncoderParams->Count = 2;
#endif
        pMyEncoderParams->Count = 1;
        
#if 1
        rCode = g_pImage->SaveAdd(pMyEncoderParams);
        
        free(pMyEncoderParams);
        if ( (rCode != Ok) && (rCode != NotImplemented) )
        {
            VERBOSE(("SaveAdd() failed\n"));
            return FALSE;
        }

#else   // Save append testing        
        WCHAR *filename = L"x:/foo.jpg";

        Image* newImage = new Image(filename);
        rCode = g_pImage->SaveAdd(newImage, pMyEncoderParams);
        delete newImage;
        if ( (rCode != Ok) && (rCode != NotImplemented) )
        {
            VERBOSE(("SaveAppend() failed\n"));
            return FALSE;
        }
#endif

    return TRUE;
}// SaveCurrentFrame()

VOID
CleanUp()
{
    // Clean up before quit

    if ( NULL != g_pImage )
    {
        delete g_pImage;
        g_pImage = NULL;
    }

    if ( NULL != g_pDrawAttrib )
    {
        delete g_pDrawAttrib;
        g_pDrawAttrib = NULL;
    }
    
    if ( NULL != g_pDestPoints )
    {
        delete g_pDestPoints;
        g_pDestPoints = NULL;
    }
}// CleanUp()

VOID
DoNextPage()
{
    g_iCurrentPageIndex++;

    // Check if we already at the last page of the image
    // Note: g_iCurrentPageIndex is 0 based. So the max page index we can reach
    // is g_uiTotalPages - 1

    if ( g_iCurrentPageIndex >= (INT)g_uiTotalPages )
    {
        g_iCurrentPageIndex = g_uiTotalPages - 1;
    }

    // Display current page

    SetCurrentPage();
}// DoNextPage()

VOID
DoPreviousPage()
{
    g_iCurrentPageIndex--;

    if ( g_iCurrentPageIndex < 0 )
    {
        g_iCurrentPageIndex = 0;
    }

    // Display current page

    SetCurrentPage();
}// DoPreviousPage()

VOID
DoAnimated()
{
    if ( g_uiTotalPages < 2 )
    {
        return;
    }

    // Reset the page to the first page

    g_iCurrentPageIndex = 0;

    // Display current page

    SetCurrentPage();

    SetTimer(g_hwndMain, 0, g_uiDelay * 10, NULL);
}// DoNextPage()

VOID
DoSave(
    HWND hwnd
    )
{
    OPENFILENAME    ofn;
    CHAR            filename[MAX_PATH];

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = g_hAppInstance;
    ofn.lpstrFile = filename;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Save Image File";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_CREATEPROMPT | OFN_OVERWRITEPROMPT;
    filename[0] = '\0';

    // Make up the file type filter string

    ImageCodecInfo* codecs;
    UINT            count;

    GpStatus status;
    UINT cbCodecs = 0;
    GetImageEncodersSize(&count, &cbCodecs);
    codecs = static_cast<ImageCodecInfo *>(malloc (cbCodecs));
    if (codecs == NULL)
    {
        return;
    }
    
    status = GetImageEncoders(count, cbCodecs, codecs);
    if (status != Ok)
    {
        return;
    }
    
    CHAR* filter = MakeFilterFromCodecs(count, codecs, FALSE);

    if ( !filter )
    {
        VERBOSE(("DoSave---MakeFilterFromCodecs() failed\n"));
    }
    else
    {
        ofn.lpstrFilter = filter;

        // Present the file/save dialog

        if ( GetSaveFileName(&ofn) )
        {
            INT iIndex = ofn.nFilterIndex;

            if ( (iIndex < 0) || (iIndex > (INT)count) )
            {
                iIndex = 0;
            }
            else
            {
                iIndex--;
            }

            // Get the image encoder

            if ( StartSaveImage(filename, &codecs[iIndex].Clsid) == FALSE )
            {
                // Fail to get an image encoder

                return;
            }
        }   

        free(filter);
    }// Filter != NULL 

    if (codecs)
    {
        free(codecs);
    }

}// DoSave()

//
// Flip or rotate the image in memory
//
VOID
DoTransFlipRotate(
    HWND hwnd,
    INT menuCmd
    )
{
    switch ( menuCmd )
    {
    case IDM_TRANSFORM_HORIZONTALFLIP:
        g_pImage->RotateFlip(RotateNoneFlipX);

        break;

    case IDM_TRANSFORM_VERTICALFLIP:
        g_pImage->RotateFlip(RotateNoneFlipY);

        break;

    case IDM_TRANSFORM_ROTATE90:
        g_pImage->RotateFlip(Rotate90FlipNone);

        break;

    case IDM_TRANSFORM_ROTATE180:
        g_pImage->RotateFlip(Rotate180FlipNone);

        break;

    case IDM_TRANSFORM_ROTATE270:
        g_pImage->RotateFlip(Rotate270FlipNone);

        break;

    default:
        break;
    }
    
    UpdateImageInfo();
    RefreshImageDisplay();
}

//
// Flip or rotate the image, just for effect. No change to the source image
//
VOID
DoFlipRotate(
    HWND hwnd,
    INT menuCmd
    )
{
    Matrix mat;
    REAL tmpX, tmpY;
    int i;

    if ( g_pImage == NULL )
    {
        return;
    }

    Graphics* pGraphics = Graphics::FromHWND(hwnd);

    if ( (g_DestPointCount != 4) && (g_pDestPoints != NULL) )
    {
        free(g_pDestPoints);
    }

    g_DestPointCount = 4;
    if ( g_pDestPoints == NULL )
    {
        g_pDestPoints = (PointF*)malloc(g_DestPointCount * sizeof(PointF));
        if ( g_pDestPoints == NULL )
        {
            return;
        }

        g_pDestPoints[0].X = 0;                       // top left
        g_pDestPoints[0].Y = 0;
        g_pDestPoints[1].X = (float)g_ImageWidth - 1;  // top right
        g_pDestPoints[1].Y = 0;
        g_pDestPoints[2].X = 0;                       // bottom left
        g_pDestPoints[2].Y = (float)g_ImageHeight - 1;
        g_pDestPoints[3].X = (float)g_ImageWidth - 1;  // bottom right
        g_pDestPoints[3].Y = (float)g_ImageHeight - 1;

    }

    switch ( menuCmd )
    {
    case IDM_VIEW_HORIZONTALFLIP:
        if ( ((g_pDestPoints[1].X - g_pDestPoints[0].X)
              == (float)g_ImageWidth)
             ||((g_pDestPoints[0].X - g_pDestPoints[1].X)
                == (float)g_ImageWidth) )
        {
            tmpX = g_pDestPoints[0].X;
            tmpY = g_pDestPoints[0].Y;
            g_pDestPoints[0].X = g_pDestPoints[1].X;
            g_pDestPoints[0].Y = g_pDestPoints[1].Y;
            g_pDestPoints[1].X = tmpX;
            g_pDestPoints[1].Y = tmpY;
            tmpX = g_pDestPoints[3].X;
            tmpY = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[2].X;
            g_pDestPoints[3].Y = g_pDestPoints[2].Y; 
            g_pDestPoints[2].X = tmpX;
            g_pDestPoints[2].Y = tmpY;
        }
        else
        {
            tmpX = g_pDestPoints[0].X;
            tmpY = g_pDestPoints[0].Y;
            g_pDestPoints[0].X = g_pDestPoints[2].X;
            g_pDestPoints[0].Y = g_pDestPoints[2].Y;
            g_pDestPoints[2].X = tmpX;
            g_pDestPoints[2].Y = tmpY;
            tmpX = g_pDestPoints[3].X;
            tmpY = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[1].X;
            g_pDestPoints[3].Y = g_pDestPoints[1].Y; 
            g_pDestPoints[1].X = tmpX;
            g_pDestPoints[1].Y = tmpY;
        }

        break;

    case IDM_VIEW_VERTICALFLIP:
        if (((g_pDestPoints[1].X - g_pDestPoints[0].X) == (float)g_ImageWidth) ||
            ((g_pDestPoints[0].X - g_pDestPoints[1].X) == (float)g_ImageWidth))
        {
            tmpX = g_pDestPoints[0].X;
            tmpY = g_pDestPoints[0].Y;
            g_pDestPoints[0].X = g_pDestPoints[2].X;
            g_pDestPoints[0].Y = g_pDestPoints[2].Y;
            g_pDestPoints[2].X = tmpX;
            g_pDestPoints[2].Y = tmpY;
            tmpX = g_pDestPoints[3].X;
            tmpY = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[1].X;
            g_pDestPoints[3].Y = g_pDestPoints[1].Y; 
            g_pDestPoints[1].X = tmpX;
            g_pDestPoints[1].Y = tmpY;
        }
        else
        {
            tmpX = g_pDestPoints[0].X;
            tmpY = g_pDestPoints[0].Y;
            g_pDestPoints[0].X = g_pDestPoints[1].X;
            g_pDestPoints[0].Y = g_pDestPoints[1].Y;
            g_pDestPoints[1].X = tmpX;
            g_pDestPoints[1].Y = tmpY;
            tmpX = g_pDestPoints[3].X;
            tmpY = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[2].X;
            g_pDestPoints[3].Y = g_pDestPoints[2].Y; 
            g_pDestPoints[2].X = tmpX;
            g_pDestPoints[2].Y = tmpY;
        }

        break;

    case IDM_VIEW_ROTATE90:
        if (((g_pDestPoints[1].X - g_pDestPoints[0].X) == (float)g_ImageWidth - 1) ||
            ((g_pDestPoints[0].X - g_pDestPoints[1].X) == (float)g_ImageWidth - 1))
        {
            tmpX = g_pDestPoints[0].X;
            tmpY = g_pDestPoints[0].Y;
            g_pDestPoints[0].X = g_pDestPoints[1].X;
            g_pDestPoints[0].Y = g_pDestPoints[1].Y;
            g_pDestPoints[1].X = g_pDestPoints[3].X;
            g_pDestPoints[1].Y = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[2].X;
            g_pDestPoints[3].Y = g_pDestPoints[2].Y; 
            g_pDestPoints[2].X = tmpX;
            g_pDestPoints[2].Y = tmpY;
            for (i=0;i<4;i++)
            {
                if (g_pDestPoints[i].X == (float)g_ImageWidth - 1)
                {
                    g_pDestPoints[i].X = (float)g_ImageHeight - 1;
                }
                else if (g_pDestPoints[i].X == (float)g_ImageHeight - 1)
                {
                    g_pDestPoints[i].X = (float)g_ImageWidth - 1;
                }
                if (g_pDestPoints[i].Y == (float)g_ImageWidth - 1)
                {
                    g_pDestPoints[i].Y = (float)g_ImageHeight - 1;
                }
                else if (g_pDestPoints[i].Y == (float)g_ImageHeight - 1)
                {
                    g_pDestPoints[i].Y = (float)g_ImageWidth - 1;
                }
            }
        }
        else
        {
            tmpX = g_pDestPoints[0].X;
            tmpY = g_pDestPoints[0].Y;
            g_pDestPoints[0].X = g_pDestPoints[1].X;
            g_pDestPoints[0].Y = g_pDestPoints[1].Y;
            g_pDestPoints[1].X = g_pDestPoints[3].X;
            g_pDestPoints[1].Y = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[2].X;
            g_pDestPoints[3].Y = g_pDestPoints[2].Y; 
            g_pDestPoints[2].X = tmpX;
            g_pDestPoints[2].Y = tmpY;
            for (i=0;i<4;i++)
            {
                if (g_pDestPoints[i].X == (float)g_ImageWidth - 1)
                {
                    g_pDestPoints[i].X = (float)g_ImageHeight - 1;
                }
                else if (g_pDestPoints[i].X == (float)g_ImageHeight - 1)
                {
                    g_pDestPoints[i].X = (float)g_ImageWidth - 1;
                }
                if (g_pDestPoints[i].Y == (float)g_ImageWidth - 1)
                {
                    g_pDestPoints[i].Y = (float)g_ImageHeight - 1;
                }
                else if (g_pDestPoints[i].Y == (float)g_ImageHeight - 1)
                {
                    g_pDestPoints[i].Y = (float)g_ImageWidth - 1;
                }
            }
        }

        g_bRotated = !g_bRotated;

        break;

    case IDM_VIEW_ROTATE270:
        if (((g_pDestPoints[1].X - g_pDestPoints[0].X) == (float)g_ImageWidth) ||
            ((g_pDestPoints[0].X - g_pDestPoints[1].X) == (float)g_ImageWidth))
        {
            tmpX = g_pDestPoints[2].X;
            tmpY = g_pDestPoints[2].Y;
            g_pDestPoints[2].X = g_pDestPoints[3].X;
            g_pDestPoints[2].Y = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[1].X;
            g_pDestPoints[3].Y = g_pDestPoints[1].Y;
            g_pDestPoints[1].X = g_pDestPoints[0].X;
            g_pDestPoints[1].Y = g_pDestPoints[0].Y; 
            g_pDestPoints[0].X = tmpX;
            g_pDestPoints[0].Y = tmpY;
            for (i=0;i<4;i++)
            {
                if (g_pDestPoints[i].X == (float)g_ImageWidth)
                {
                    g_pDestPoints[i].X = (float)g_ImageHeight;
                }
                else if (g_pDestPoints[i].X == (float)g_ImageHeight)
                {
                    g_pDestPoints[i].X = (float)g_ImageWidth;
                }
                if (g_pDestPoints[i].Y == (float)g_ImageWidth)
                {
                    g_pDestPoints[i].Y = (float)g_ImageHeight;
                }
                else if (g_pDestPoints[i].Y == (float)g_ImageHeight)
                {
                    g_pDestPoints[i].Y = (float)g_ImageWidth;
                }
            }
        }
        else
        {
            tmpX = g_pDestPoints[2].X;
            tmpY = g_pDestPoints[2].Y;
            g_pDestPoints[2].X = g_pDestPoints[3].X;
            g_pDestPoints[2].Y = g_pDestPoints[3].Y;
            g_pDestPoints[3].X = g_pDestPoints[1].X;
            g_pDestPoints[3].Y = g_pDestPoints[1].Y;
            g_pDestPoints[1].X = g_pDestPoints[0].X;
            g_pDestPoints[1].Y = g_pDestPoints[0].Y; 
            g_pDestPoints[0].X = tmpX;
            g_pDestPoints[0].Y = tmpY;
            for (i=0;i<4;i++)
            {
                if (g_pDestPoints[i].X == (float)g_ImageWidth)
                {
                    g_pDestPoints[i].X = (float)g_ImageHeight;
                }
                else if (g_pDestPoints[i].X == (float)g_ImageHeight)
                {
                    g_pDestPoints[i].X = (float)g_ImageWidth;
                }
                if (g_pDestPoints[i].Y == (float)g_ImageWidth)
                {
                    g_pDestPoints[i].Y = (float)g_ImageHeight;
                }
                else if (g_pDestPoints[i].Y == (float)g_ImageHeight)
                {
                    g_pDestPoints[i].Y = (float)g_ImageWidth;
                }
            }
        }

        g_bRotated = !g_bRotated;

        break;
    }// switch ( menuCmd )
    mat.TransformPoints(g_pDestPoints, g_DestPointCount);

    RefreshImageDisplay();

    delete pGraphics;

    RefreshImageDisplay();
}// DoFlipRotate()

VOID
DoGetProperties(
    VOID
    )
{
    UINT    numOfProperty;
    UINT    itemSize;
    PropertyItem*   pBuffer = NULL;
    PropertyItem*   pTotalBuffer = NULL;

    // Check how many property items in this image

    numOfProperty = g_pImage->GetPropertyCount();

    VERBOSE(("There are %d property items in image %s\n", numOfProperty,
             g_acImageName));
    // Get all the property ID list from the image

    PROPID* pList = (PROPID*)malloc(numOfProperty * sizeof(PROPID));
    if ( pList == NULL )
    {
        return;
    }

    Status rCode = g_pImage->GetPropertyIdList(numOfProperty, pList);
    if ( (rCode != Ok) && (rCode != NotImplemented) )
    {
        VERBOSE(("GetPropertyIdList() failed\n"));
        return;
    }

//#define UNITTEST 0

#if defined(UNITTEST)
    for ( int i = 0; i < (int)numOfProperty; ++i )
    {
        // Show Property ID

        VERBOSE(("ID[%d] = 0x%x, (%d) ", i, pList[i], pList[i]));

        // Check the size for this property item

        itemSize = g_pImage->GetPropertyItemSize(pList[i]);

        VERBOSE(("size = %d, ", itemSize));

        // Allocate memory and get this property item

        pBuffer = (PropertyItem*)malloc(itemSize);
        if ( pBuffer == NULL )
        {
            return;
        }

        rCode = g_pImage->GetPropertyItem(pList[i], itemSize, pBuffer);
        if ( (rCode != Ok) && (rCode != NotImplemented) )
        {
            VERBOSE(("GetPropertyItem() failed\n"));
            return;
        }

        DisplayPropertyItem(pBuffer);

        free(pBuffer);

        // Test RemovePropertyItem()

        rCode = g_pImage->RemovePropertyItem(pList[i]);
        if ( (rCode != Ok) && (rCode != NotImplemented) )
        {
            VERBOSE(("RemovePropertyItem() failed\n"));
            return;
        }
    }// Loop through the list

    free(pList);
#endif

    rCode = g_pImage->GetPropertySize(&itemSize, &numOfProperty);
    if ( (rCode != Ok) && (rCode != NotImplemented) )
    {
        VERBOSE(("GetPropertySize() failed\n"));
        return;
    }

    pTotalBuffer = (PropertyItem*)malloc(itemSize);
    rCode = g_pImage->GetAllPropertyItems(itemSize, numOfProperty,
                                          pTotalBuffer);
    if ( (rCode != Ok) && (rCode != NotImplemented) )
    {
        VERBOSE(("GetAllPropertyItems() failed\n"));
        return;
    }

    PropertyItem*   pTemp = pTotalBuffer;
    for ( int j = 0; j < (int)numOfProperty; ++j )
    {
        DisplayPropertyItem(pTemp);

        pTemp++;
    }

    free(pTotalBuffer);
}// DoGetProperties()

VOID
DoViewThumbnail()
{
    // Get build in thumbnail

    Image* pThumbImage = g_pImage->GetThumbnailImage(0, 0);

    if ( pThumbImage == NULL )
    {
        VERBOSE(("Image %s doesn't have a thumbnail\n", g_acImageName));
        return;
    }

    if ( NULL != g_pImage )
    {
        delete g_pImage;
    }

    g_pImage = pThumbImage;

    UpdateImageInfo();
    g_dScale = 1;
    RefreshImageDisplay();
}// DoViewThumbnail()

VOID
DoChannelView(
    INT menuCmd
    )
{
    if ( g_pDrawAttrib != NULL )
    {
        delete g_pDrawAttrib;
    }

    g_pDrawAttrib = new ImageAttributes();

    switch ( menuCmd )
    {
    case IDM_VIEW_CHANNEL_C:
        g_pDrawAttrib->SetOutputChannel(ColorChannelFlagsC);

        break;

    case IDM_VIEW_CHANNEL_M:
        g_pDrawAttrib->SetOutputChannel(ColorChannelFlagsM);

        break;

    case IDM_VIEW_CHANNEL_Y:
        g_pDrawAttrib->SetOutputChannel(ColorChannelFlagsY);

        break;

    case IDM_VIEW_CHANNEL_K:
        g_pDrawAttrib->SetOutputChannel(ColorChannelFlagsK);

        break;

    default:
        return;
    }

    RefreshImageDisplay();

    return;
}// DoChannelView()

VOID
DisplayImageInfo()
{
    VERBOSE(("\nInformation for frame %d of Image %s\n",
             g_iCurrentPageIndex + 1, g_acImageName));
    VERBOSE(("--------------------------------\n"));
    VERBOSE(("Width = %d\n", g_ImageWidth));
    VERBOSE(("Height = %d\n", g_ImageHeight));

    if ( g_ImageFlags & IMGFLAG_HASREALPIXELSIZE )
    {
        VERBOSE(("---The pixel size info is from the original image\n"));
    }
    else
    {
        VERBOSE(("---The pixel size info is NOT from the original image\n"));
    }
    
    switch ( g_ImagePixelFormat )
    {
    case PIXFMT_1BPP_INDEXED:
        VERBOSE(("Color depth: 1 BPP INDEXED\n"));
        
        break;

    case PIXFMT_4BPP_INDEXED:
        VERBOSE(("Color depth: 4 BPP INDEXED\n"));
        
        break;

    case PIXFMT_8BPP_INDEXED:
        VERBOSE(("Color depth: 8 BPP INDEXED\n"));
        
        break;

    case PIXFMT_16BPP_GRAYSCALE:
        VERBOSE(("Color depth: 16 BPP GRAY SCALE\n"));
        
        break;

    case PIXFMT_16BPP_RGB555:
        VERBOSE(("Color depth: 16 BPP RGB 555\n"));
        
        break;

    case PIXFMT_16BPP_RGB565:
        VERBOSE(("Color depth: 16 BPP RGB 565\n"));
        
        break;

    case PIXFMT_16BPP_ARGB1555:
        VERBOSE(("Color depth: 16 BPP ARGB 1555\n"));
        
        break;

    case PIXFMT_24BPP_RGB:
        VERBOSE(("Color depth: 24 BPP RGB\n"));
        
        break;

    case PIXFMT_32BPP_RGB:
        VERBOSE(("Color depth: 32 BPP RGB\n"));
        
        break;

    case PIXFMT_32BPP_ARGB:
        VERBOSE(("Color depth: 32 BPP ARGB\n"));
        
        break;

    case PIXFMT_32BPP_PARGB:
        VERBOSE(("Color depth: 32 BPP PARGB\n"));
        
        break;

    case PIXFMT_48BPP_RGB:
        VERBOSE(("Color depth: 48 BPP PARGB\n"));
        
        break;

    case PIXFMT_64BPP_ARGB:
        VERBOSE(("Color depth: 64 BPP ARGB\n"));
        
        break;

    case PIXFMT_64BPP_PARGB:
        VERBOSE(("Color depth: 64 BPP PARGB\n"));
        
        break;

    default:
        break;
    }// Color format

    VERBOSE(("X DPI (dots per inch) = %f\n", g_ImageXDpi));
    VERBOSE(("Y DPI (dots per inch) = %f\n", g_ImageYDpi));

    if ( g_ImageFlags & IMGFLAG_HASREALDPI )
    {
        VERBOSE(("---The DPI info is from the original image\n"));
    }
    else
    {
        VERBOSE(("---The DPI info is NOT from the original image\n"));
    }

    // Parse image info flags

    if ( g_ImageFlags & SINKFLAG_HASALPHA )
    {
        VERBOSE(("This image contains alpha pixels\n"));
        
        if ( g_ImageFlags & IMGFLAG_HASTRANSLUCENT )
        {
            VERBOSE(("---It has non-0 and 1 alpha pixels (TRANSLUCENT)\n"));
        }
    }
    else
    {
        VERBOSE(("This image does not contain alpha pixels\n"));
    }

    // Figure out origianl file format

    if ( g_ImageRawDataFormat == IMGFMT_MEMORYBMP )
    {
        VERBOSE(("RawDataFormat is MEMORYBMP\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_BMP )
    {
        VERBOSE(("RawDataFormat is BMP\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_EMF )
    {
        VERBOSE(("RawDataFormat is EMF\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_WMF )
    {
        VERBOSE(("RawDataFormat is WMF\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_JPEG )
    {
        VERBOSE(("RawDataFormat is JPEG\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_PNG )
    {
        VERBOSE(("RawDataFormat is PNG\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_GIF )
    {
        VERBOSE(("RawDataFormat is GIF\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_TIFF )
    {
        VERBOSE(("RawDataFormat is TIFF\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_EXIF )
    {
        VERBOSE(("RawDataFormat is EXIF\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_ICO )
    {
        VERBOSE(("RawDataFormat is ICO\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_PHOTOCD )
    {
        VERBOSE(("RawDataFormat is PHOTOCD\n"));
    }
    else if ( g_ImageRawDataFormat == IMGFMT_FLASHPIX )
    {
        VERBOSE(("RawDataFormat is FLASHPIX\n"));
    }
    else
    {
        VERBOSE(("RawDataFormat is UNDEFINED\n"));
    }
    
    // Figure out origianl color space

    if ( g_ImageFlags & IMGFLAG_COLORSPACE_RGB )
    {
        VERBOSE(("This image is in RGB color space\n"));
    }
    else if ( g_ImageFlags & IMGFLAG_COLORSPACE_CMYK )
    {
        VERBOSE(("This image is in CMYK color space\n"));
    }
    else if ( g_ImageFlags & IMGFLAG_COLORSPACE_GRAY )
    {
        VERBOSE(("This image is a gray scale image\n"));
    }
    else if ( g_ImageFlags & IMGFLAG_COLORSPACE_YCCK )
    {
        VERBOSE(("This image is in YCCK color space\n"));
    }
    else if ( g_ImageFlags & IMGFLAG_COLORSPACE_YCBCR )
    {
        VERBOSE(("This image is in YCBCR color space\n"));
    }
}// DisplayImageInfo()

//
// Convert the current image to a bitmap
//

VOID
DoConvertToBitmap(
    HWND    hwnd,
    INT     menuCmd
    )
{
    // Map menu selection to its corresponding pixel format

    PixelFormatID pixfmt;

    switch (menuCmd)
    {
    case IDM_CONVERT_8BIT:
        pixfmt = PIXFMT_8BPP_INDEXED;

        break;

    case IDM_CONVERT_16BITRGB555:
        pixfmt = PIXFMT_16BPP_RGB555;

        break;

    case IDM_CONVERT_16BITRGB565:
        pixfmt = PIXFMT_16BPP_RGB565;

        break;

    case IDM_CONVERT_24BITRGB:
        pixfmt = PIXFMT_24BPP_RGB;

        break;

    case IDM_CONVERT_32BITRGB:
        pixfmt = PIXFMT_32BPP_RGB;

        break;

    case IDM_CONVERT_32BITARGB:
    default:
        pixfmt = PIXFMT_32BPP_ARGB;

        break;
    }

    // Convert the current image to a bitmap image

    if ( g_pImage != NULL )
    {
        Bitmap* pNewBmp = ((Bitmap*)g_pImage)->Clone(0, 0, g_ImageWidth,
                                                     g_ImageHeight, pixfmt);
        if ( pNewBmp == NULL )
        {
            VERBOSE(("Clone failed in DoConvertToBitmap()\n"));
            return;
        }

        //Release the old one

        if ( g_pImage != NULL )
        {
            delete g_pImage;
        }

        g_pImage = (Image*)pNewBmp;
    }

    RefreshImageDisplay();
}// DoConvertToBitmap()

//
// Crop the image
//
// NOTE: We're not spending time here to do a fancy UI.
//  So we'll just inset the image by 5 pixels each time.
//

VOID
DoCrop(
    HWND hwnd
    )
{
    if ( g_SourceWidth == 0 )
    {
        // initialize global source width and height if not previously
        // initialized

        if ( g_pImage == NULL )
        {
            return;
        }

        g_SourceWidth = (REAL)g_ImageWidth;
        g_SourceHeight = (REAL)g_ImageHeight;
    }

    // check to make sure source image is still at least one pixel big
    if ( (g_SourceWidth - g_SourceX) > 11 )
    {
        g_SourceX += 10;
    }

    if ( (g_SourceHeight - g_SourceY) > 11 )
    {
        g_SourceY += 10;
    }

    if ( (g_SourceWidth - g_SourceX) > 6 )
    {
        g_SourceWidth -= 5;
    }

    if ( (g_SourceHeight - g_SourceY) > 6 )
    {
        g_SourceHeight -= 5;
    }

    RefreshImageDisplay();
}// DoCrop()

void
DoRender()
{
    // Check if we have anything special for drawing

    if ( (g_pDrawAttrib == NULL) && (g_pDestPoints == NULL) )
    {
        // Nothing special, we don't need "render"

        return;
    }

    Bitmap* pNewBitmap = NULL;

    // Create a Graphics object from this memory DC and draw onto it

    if ( g_bRotated == TRUE )
    {
        pNewBitmap = new Bitmap(g_ImageHeight,
                                g_ImageWidth,
                                PIXFMT_32BPP_ARGB);
    }
    else
    {
        pNewBitmap = new Bitmap(g_ImageWidth,
                                g_ImageHeight,
                                PIXFMT_32BPP_ARGB);
    }
    
    if ( pNewBitmap == NULL )
    {
        return;
    }

    Graphics* pGraphics = new Graphics(pNewBitmap);

    REAL rWidth = (REAL)g_ImageWidth;
    REAL rHeight = (REAL)g_ImageHeight;
    
    if ( g_SourceWidth != 0 )
    {
        rWidth = g_SourceWidth;
    }

    if ( g_SourceHeight != 0 )
    {
        rHeight = g_SourceHeight;
    }

    if ( g_pDestPoints != NULL )
    {
        pGraphics->DrawImage(g_pImage,
                            g_pDestPoints,
                            3,                 // Should use g_DestPointCount,
                            g_SourceX,
                            g_SourceY,
                            rWidth,
                            rHeight,
                            UnitPixel,
                            g_pDrawAttrib,
                            NULL,
                            NULL);
    }
    else
    {
        Rect dstRect(0, 0, g_ImageWidth, g_ImageHeight);
        
        pGraphics->DrawImage(g_pImage,
                             dstRect,
                             (INT)g_SourceX,
                             (INT)g_SourceY,
                             (INT)rWidth,
                             (INT)rHeight,
                             UnitPixel,
                             g_pDrawAttrib,
                             NULL,
                             NULL);
    }

    if ( g_pImage != NULL )
    {
        delete g_pImage;
    }

    g_pImage = (Image*)pNewBitmap;

    delete pGraphics;

    // Clear up all the drawing special attributes since we have already done
    // the render

    if ( g_pDrawAttrib != NULL )
    {
        delete g_pDrawAttrib;
        g_pDrawAttrib = NULL;
    }

    if ( g_pDestPoints != NULL )
    {
        delete g_pDestPoints;
        g_pDestPoints = NULL;
        g_DestPointCount = 0;
    }
    
    RefreshImageDisplay();
}// DoRender()

VOID
DoICM()
{
    HMENU hMenu = GetMenu(g_hwndMain);
    UINT ulRC = GetMenuState(hMenu, IDM_EFFECT_ICC, MF_BYCOMMAND);

    if ( ulRC == MF_CHECKED )
    {
        // Turn ICM off

        CheckMenuItem(hMenu, IDM_EFFECT_ICC, MF_BYCOMMAND | MF_UNCHECKED);

        // Check if we loaded the image with ICM on or off

        if ( g_LoadImageWithICM == TRUE )
        {
            // The image we loaded is ICM converted. We need to through it
            // away and load a new one without the convertion

            g_LoadImageWithICM = FALSE;
            OpenImageFile(g_acImageName);
        }
    }
    else
    {
        // Turn ICM on

        CheckMenuItem(hMenu, IDM_EFFECT_ICC, MF_BYCOMMAND | MF_CHECKED);

        // Check if we loaded the image with ICM on or off

        if ( g_LoadImageWithICM == FALSE )
        {
            // The image we loaded without ICM converted. We need to through
            // it away and load a new one with the convertion

            g_LoadImageWithICM = TRUE;
            OpenImageFile(g_acImageName);
        }
    }
}// DoICM()

VOID
DoGamma()
{
    // Set gamma

    if ( g_pDrawAttrib == NULL )
    {
        g_pDrawAttrib = new ImageAttributes();
    }

    REAL    rGamma = 1.5;

    g_pDrawAttrib->SetGamma(rGamma);
}

VOID
DoMenuCommand(
    HWND    hwnd,
    INT     menuCmd
    )
{
    HMENU hMenu = GetMenu(g_hwndMain);

    switch ( menuCmd )
    {
    case IDM_FILE_OPEN:
        // Before we open a new image. We need be sure we have done the save
        // for previous image

        CleanUp();

        // Now open a new image

        DoOpen(hwnd);
        
        break;

    case IDM_FILE_SAVE:
        DoSave(hwnd);
        
        break;
                          
    case IDM_FILE_SAVEFRAME:
        // Save the current frame

        SaveCurrentFrame();

        break;

    case IDM_FILE_PRINT:
        DoPrint(hwnd);

        break;

    case IDM_VIEW_NEXTPAGE:
        DoNextPage();

        break;

    case IDM_VIEW_PREVIOUSPAGE:
        DoPreviousPage();

        break;

    case IDM_VIEW_ANIMATED:
        DoAnimated();
        break;

    case IDM_VIEW_THUMBNAIL:
        DoViewThumbnail();

        break;

    case IDM_VIEW_CHANNEL_C:
    case IDM_VIEW_CHANNEL_M:
    case IDM_VIEW_CHANNEL_Y:
    case IDM_VIEW_CHANNEL_K:
    case IDM_VIEW_CHANNEL_R:
    case IDM_VIEW_CHANNEL_G:
    case IDM_VIEW_CHANNEL_B:
    case IDM_VIEW_CHANNEL_L:
        DoChannelView(menuCmd);

        break;

    case IDM_VIEW_ZOOM_IN:
        g_dScale = g_dScale * 2;
        g_fFitToWindow_w = FALSE;
        g_fFitToWindow_h = FALSE;

        RefreshImageDisplay();
        
        break;

    case IDM_VIEW_ZOOM_OUT:
        g_dScale = g_dScale / 2;
        g_fFitToWindow_w = FALSE;
        g_fFitToWindow_h = FALSE;

        CheckMenuItem(hMenu, IDM_VIEW_ZOOM_FITWINDOW_W,
                      MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_VIEW_ZOOM_FITWINDOW_H,
                      MF_BYCOMMAND | MF_UNCHECKED);
        
        RefreshImageDisplay();
        
        break;

    case IDM_VIEW_ZOOM_FITWINDOW_W:
        g_dScale = (REAL)g_iWinWidth / g_ImageWidth;

        g_fFitToWindow_w = TRUE;
        g_fFitToWindow_h = FALSE;

        ToggleScaleFactorMenu(IDM_VIEW_ZOOM_FITWINDOW_W, GetMenu(g_hwndMain));

        RefreshImageDisplay();
        
        break;
    
    case IDM_VIEW_ZOOM_FITWINDOW_H:
        g_dScale = (REAL)g_iWinHeight / g_ImageHeight;

        g_fFitToWindow_h = TRUE;
        g_fFitToWindow_w = FALSE;

        ToggleScaleFactorMenu(IDM_VIEW_ZOOM_FITWINDOW_H, GetMenu(g_hwndMain));

        RefreshImageDisplay();
        
        break;
    
    case IDM_VIEW_ZOOM_REALSIZE:
        g_dScale = 1.0;

        g_fFitToWindow_w = FALSE;
        g_fFitToWindow_h = FALSE;

        ToggleScaleFactorMenu(IDM_VIEW_ZOOM_REALSIZE, GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;

    case IDM_VIEW_OPTION_BILINEAR:
        g_InterpolationMode = InterpolationModeBilinear;
        ToggleScaleOptionMenu(IDM_VIEW_OPTION_BILINEAR, GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;

    case IDM_VIEW_OPTION_BICUBIC:
        g_InterpolationMode = InterpolationModeBicubic;
        ToggleScaleOptionMenu(IDM_VIEW_OPTION_BICUBIC, GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;
    
    case IDM_VIEW_OPTION_NEARESTNEIGHBOR:
        g_InterpolationMode = InterpolationModeNearestNeighbor;
        ToggleScaleOptionMenu(IDM_VIEW_OPTION_NEARESTNEIGHBOR,
                              GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;
    
    case IDM_VIEW_OPTION_HIGHLINEAR:
        g_InterpolationMode = InterpolationModeHighQualityBilinear;
        ToggleScaleOptionMenu(IDM_VIEW_OPTION_HIGHLINEAR, GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;
    
    case IDM_VIEW_OPTION_HIGHCUBIC:
        g_InterpolationMode = InterpolationModeHighQualityBicubic;
        ToggleScaleOptionMenu(IDM_VIEW_OPTION_HIGHCUBIC, GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;
    
    case IDM_VIEW_OPTION_WRAPMODETILE:
        g_WrapMode = WrapModeTile;
        g_pDrawAttrib->SetWrapMode(g_WrapMode, Color(0), FALSE);
        ToggleWrapModeOptionMenu(IDM_VIEW_OPTION_WRAPMODETILE,
                                 GetMenu(g_hwndMain));
        RefreshImageDisplay();
        
        break;

    case IDM_VIEW_OPTION_WRAPMODEFLIPX:
        g_WrapMode = WrapModeTileFlipX;
        g_pDrawAttrib->SetWrapMode(g_WrapMode, Color(0), FALSE);
        ToggleWrapModeOptionMenu(IDM_VIEW_OPTION_WRAPMODEFLIPX,
                                 GetMenu(g_hwndMain));
        RefreshImageDisplay();
        
        break;
    
    case IDM_VIEW_OPTION_WRAPMODEFLIPY:
        g_WrapMode = WrapModeTileFlipY;
        g_pDrawAttrib->SetWrapMode(g_WrapMode, Color(0), FALSE);
        ToggleWrapModeOptionMenu(IDM_VIEW_OPTION_WRAPMODEFLIPY,
                                 GetMenu(g_hwndMain));
        RefreshImageDisplay();
        
        break;

    case IDM_VIEW_OPTION_WRAPMODEFLIPXY:
        g_WrapMode = WrapModeTileFlipXY;
        g_pDrawAttrib->SetWrapMode(g_WrapMode, Color(0), FALSE);
        ToggleWrapModeOptionMenu(IDM_VIEW_OPTION_WRAPMODEFLIPXY,
                                 GetMenu(g_hwndMain));
        RefreshImageDisplay();
        
        break;

    case IDM_VIEW_OPTION_WRAPMODECLAMP0:
        g_WrapMode = WrapModeClamp;
        g_pDrawAttrib->SetWrapMode(g_WrapMode, Color(0), FALSE);
        ToggleWrapModeOptionMenu(IDM_VIEW_OPTION_WRAPMODECLAMP0,
                                 GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;

    case IDM_VIEW_OPTION_WRAPMODECLAMPFF:
        g_WrapMode = WrapModeClamp;
        g_pDrawAttrib->SetWrapMode(g_WrapMode, Color(0xffff0000), FALSE);
        ToggleWrapModeOptionMenu(IDM_VIEW_OPTION_WRAPMODECLAMPFF,
                                 GetMenu(g_hwndMain));
        RefreshImageDisplay();

        break;

    case IDM_VIEW_CROP:
        DoCrop(hwnd);
        break;

    case IDM_VIEW_HORIZONTALFLIP:
    case IDM_VIEW_VERTICALFLIP:
    case IDM_VIEW_ROTATE90:
    case IDM_VIEW_ROTATE270:
        DoFlipRotate(hwnd, menuCmd);

        break;

    case IDM_TRANSFORM_HORIZONTALFLIP:
    case IDM_TRANSFORM_VERTICALFLIP:
    case IDM_TRANSFORM_ROTATE90:
    case IDM_TRANSFORM_ROTATE180:
    case IDM_TRANSFORM_ROTATE270:
        DoTransFlipRotate(hwnd, menuCmd);

        break;
    
    case IDM_VIEW_ATTR_PROPERTY:
        DoGetProperties();
        break;
    
    case IDM_VIEW_ATTR_INFO:
        DisplayImageInfo();
        break;
    
    case IDM_FILE_RENDER:
        DoRender();

        break;

    case IDM_FILE_QUIT:
        CleanUp();

        PostQuitMessage(0);
        
        break;

    case IDM_CONVERT_8BIT:
    case IDM_CONVERT_16BITRGB555:
    case IDM_CONVERT_16BITRGB565:
    case IDM_CONVERT_24BITRGB:
    case IDM_CONVERT_32BITRGB:
    case IDM_CONVERT_32BITARGB:
        DoConvertToBitmap(hwnd, menuCmd);
        
        break;
    
    case IDM_EFFECT_TRANSKEY:
        // Popup a dialog to let user set up the transparent key

        if ( ShowMyDialog((INT)IDD_COLORKEYDLG, g_hwndMain,
                          (FARPROC)DecoderParamDlgProc) == FALSE )

        {
            return;
        }

        break;

    case IDM_EFFECT_COLORMAP:
        // Popup a dialog to let user set up the color map value

        if ( ShowMyDialog((INT)IDD_COLORMAPDLG, g_hwndMain,
                          (FARPROC)ColorMapDlgProc) == FALSE )

        {
            return;
        }
        
        break;

    case IDM_EFFECT_ICC:
        DoICM();        
        break;

    case IDM_EFFECT_GAMMA:
        DoGamma();
        break;
    
    case IDM_ANNOTATION_ANNOTATION:
        // Popup a dialog to let user modify/add annotation

        if ( ShowMyDialog((INT)IDD_ANNOTATIONDLG, g_hwndMain,
                          (FARPROC)AnnotationDlgProc) == FALSE )

        {
            return;
        }

        break;

    case IDM_ANNOTATION_SOFTWARE:
        break;

    case IDM_ANNOTATION_AUDIOFILE:
        DoOpenAudioFile(hwnd);
    }
}// DoMenuCommand()

void
DoMouseMove(
    WPARAM  wParam,
    LPARAM lParam
    )
{
    if ( (wParam & MK_LBUTTON) && (g_pImage != NULL)
       &&(g_ImageRawDataFormat != IMGFMT_EMF)
       &&(g_ImageRawDataFormat != IMGFMT_WMF) )
    {
        int x = LOWORD(lParam);
        int y = HIWORD(lParam);
        char szAnsiMessage[256];

        if ( (x >= 0) && (y >= 0)
          && (x < (INT)g_ImageWidth) && ( y < (INT)g_ImageHeight) )
        {
            Color    color;
            ((Bitmap*)g_pImage)->GetPixel(x, y, &color);
        
            sprintf(szAnsiMessage, "(%d, %d) (%d, %d, %d, %d)", x, y,
                    color.GetAlpha(), color.GetRed(), color.GetGreen(),
                    color.GetBlue());
        }
        else
        {
            sprintf(szAnsiMessage, "Out of image bounds");
        }

        SetWindowText(g_hwndStatus, szAnsiMessage);
    }

    return;
}// DoMouseMove()

//
// Window callback procedure
//
LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    iMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch ( iMsg )
    {
    case WM_COMMAND:
        DoMenuCommand(hwnd, LOWORD(wParam));

        break;

    case WM_KEYDOWN:
        switch ( wParam )
        {
        case VK_NEXT:

            // Page Down
            
            DoNextPage();
            
            break;

        case VK_PRIOR:

            // Page Up

            DoPreviousPage();
            
            break;

        case VK_F1:

            // F1 key for image info

            UpdateImageInfo();
            DisplayImageInfo();
            break;

        case VK_F2:
            // F2 for property items

            DoGetProperties();
            
            break;

        case VK_F3:
            
            // F3 key for animation

            DoAnimated();

            break;

        case VK_F4:
            // F4 for ICM

            DoICM();
            
            break;

        default:
            return DefWindowProc(hwnd, iMsg, wParam, lParam);
        }
        
        break;
    
    case WM_PAINT:
        DoPaint(hwnd);
        break;

    case WM_SIZE:
        g_iWinWidth = LOWORD(lParam);
        g_iWinHeight = HIWORD(lParam);

        if ( g_fFitToWindow_w == TRUE )
        {
            g_dScale = (REAL)g_iWinWidth / g_ImageWidth;
        }
        else if ( g_fFitToWindow_h == TRUE )
        {
            g_dScale = (REAL)g_iWinHeight / g_ImageHeight;
        }

        // Resize the status window

        int x;
        int y;
        int cx;
        int cy;

        RECT rWindow;

        // Keep status window height the same

        GetWindowRect(g_hwndStatus, &rWindow);
        cy = rWindow.bottom - rWindow.top;

        x = 0;
        y = g_iWinHeight - cy;
        cx = g_iWinWidth;
        MoveWindow(g_hwndStatus, x, y, cx, cy, TRUE);
        SetWindowText(g_hwndStatus, "");

        RefreshImageDisplay();
        break;

    case WM_MOUSEMOVE:
        DoMouseMove(wParam, lParam);

        break;

    case WM_TIMER:
        KillTimer(g_hwndMain, 0);
        
        DoNextPage();
        
        if ( (UINT)g_iCurrentPageIndex < (g_uiTotalPages - 1) )
        {
            // View the next frame

            SetTimer(g_hwndMain, 0, g_uiDelay * 10, NULL);
        }

        break;

    case WM_DESTROY:
        CleanUp();
        
        PostQuitMessage(0);
        
        break;

    default:
        return DefWindowProc(hwnd, iMsg, wParam, lParam);
    }

    return 0;
}// MyWindowProc()

//
// Create main application window
//
VOID
CreateMainWindow(
    int iX,
    int iY,
    int iWidth,
    int iHeight
    )
{
    HBRUSH hBrush = CreateHatchBrush(HS_HORIZONTAL,
                                     RGB(0, 200, 0));

    // Register window class

    WNDCLASS wndClass =
    {
        CS_HREDRAW|CS_VREDRAW,
        MyWindowProc,
        0,
        0,
        g_hAppInstance,
        LoadIcon(NULL, IDI_APPLICATION),
        LoadCursor(NULL, IDC_ARROW),
        hBrush,
        MAKEINTRESOURCE(IDR_MAINMENU),
        MYWNDCLASSNAME
    };

    RegisterClass(&wndClass);

    g_hwndMain = CreateWindow(MYWNDCLASSNAME,
                              MYWNDCLASSNAME,
                              WS_OVERLAPPEDWINDOW,
                              iX,
                              iY,
                              iWidth,
                              iHeight,
                              NULL,
                              NULL,
                              g_hAppInstance,
                              NULL);

    g_hwndStatus = CreateStatusWindow(WS_CHILD | WS_VISIBLE,
                                     (LPCSTR)"Ready", 
                                     g_hwndMain, 
                                     2);

    if ( !g_hwndMain || (!g_hwndStatus) )
    {
        VERBOSE(("CreateMainWindow---CreateStatusWindow() failed"));
        exit(-1);
    }
}// CreateMainWindow()

//
// Main program entrypoint
//
INT _cdecl
main(
    int     argc,
    char*   argv[]
    )
{
    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }

    // Parse input parameters

    ValidateArguments(argc, argv);

    g_hAppInstance = GetModuleHandle(NULL);

    g_iCurrentPageIndex = 0;
    
    // Create the main application window

    CreateMainWindow(g_iWinX, g_iWinY, g_iWinWidth, g_iWinHeight);

    // Open an image

    if ( OpenImageFile(g_acImageName) == FALSE )
    {
        // The user probably didn't give us image name or a wrong image name
        // Create our own background image now

        CreateBackgroundBitmap();
    }

    // After OpenImageFile() and CreateBackgroundBitmap(), we
    // should have an IImage obj which points to the current frame/page. If not,
    // end application

    ShowWindow(g_hwndMain, SW_SHOW);
    HMENU hMenu = GetMenu(g_hwndMain);

    CheckMenuItem(hMenu, IDM_VIEW_OPTION_HIGHCUBIC, MF_BYCOMMAND | MF_CHECKED);

    ResetImageAttribute();
    CheckMenuItem(hMenu, IDM_VIEW_OPTION_WRAPMODEFLIPXY,
                  MF_BYCOMMAND | MF_CHECKED);
    
    // Turn ICM on

    CheckMenuItem(hMenu, IDM_EFFECT_ICC, MF_BYCOMMAND | MF_CHECKED);
    
    // Main message loop

    MSG     msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (INT)(msg.wParam);
}// main()

#if 0   // Set quality test
        UINT  uiSize = g_pImage->GetEncoderParameterListSize(&tempClsID);
        EncoderParameters*  pBuffer = (EncoderParameters*)malloc(uiSize);
        rCode = g_pImage->GetEncoderParameterList(&tempClsID, uiSize,
                                                  pBuffer);
            UINT qualityLevel = 50;
            pMyEncoderParams->Parameter[0].Guid = EncoderQuality;
            pMyEncoderParams->Parameter[0].Type = EncoderParameterValueTypeLong;
            pMyEncoderParams->Parameter[0].NumberOfValues = 1;
            pMyEncoderParams->Parameter[0].Value = (VOID*)&qualityLevel;
#endif

#if 0 // Save quantization table test
            static const unsigned short luminance_tbl[64] = {
              16,  11,  10,  16,  24,  40,  51,  61,
              12,  12,  14,  19,  26,  58,  60,  55,
              14,  13,  16,  24,  40,  57,  69,  56,
              14,  17,  22,  29,  51,  87,  80,  62,
              18,  22,  37,  56,  68, 109, 103,  77,
              24,  35,  55,  64,  81, 104, 113,  92,
              49,  64,  78,  87, 103, 121, 120, 101,
              72,  92,  95,  98, 112, 100, 103,  99
            };
            static const unsigned short chrominance_tbl[64] = {
              17,  18,  24,  47,  99,  99,  99,  99,
              18,  21,  26,  66,  99,  99,  99,  99,
              24,  26,  56,  99,  99,  99,  99,  99,
              47,  66,  99,  99,  99,  99,  99,  99,
              99,  99,  99,  99,  99,  99,  99,  99,
              99,  99,  99,  99,  99,  99,  99,  99,
              99,  99,  99,  99,  99,  99,  99,  99,
              99,  99,  99,  99,  99,  99,  99,  99
            };

            pMyEncoderParams = (EncoderParameters*)malloc
                               (2 * sizeof(EncoderParameters));

            pMyEncoderParams->Parameter[0].Guid = ENCODER_LUMINANCE_TABLE;
            pMyEncoderParams->Parameter[0].Type = EncoderParameterValueTypeShort;
            pMyEncoderParams->Parameter[0].NumberOfValues = 64;
            pMyEncoderParams->Parameter[0].Value = (VOID*)luminance_tbl;
            pMyEncoderParams->Parameter[1].Guid = ENCODER_CHROMINANCE_TABLE;
            pMyEncoderParams->Parameter[1].Type = EncoderParameterValueTypeShort;
            pMyEncoderParams->Parameter[1].NumberOfValues = 64;
            pMyEncoderParams->Parameter[1].Value = (VOID*)chrominance_tbl;
            pMyEncoderParams->Count = 2;
#endif // UNITTEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\frametest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by frametest.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1001
#define _APS_NEXT_COMMAND_VALUE         40005
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           1001
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\frametest\frametest.h ===
#ifndef _FRAMETEST_H_
#define _FRAMETEST_H_

#define IDR_MAINMENU                100
#define IDR_ACCELTABLE              101

#define IDM_FILE_OPEN               200
#define IDM_FILE_SAVE               201
#define IDM_FILE_SAVEFRAME          202
#define IDM_FILE_RENDER             203
#define IDM_FILE_PRINT              204
#define IDM_FILE_QUIT               205

#define IDM_VIEW_NEXTPAGE           300
#define IDM_VIEW_PREVIOUSPAGE       301
#define IDM_VIEW_THUMBNAIL          302
#define IDM_VIEW_CHANNEL_C          303
#define IDM_VIEW_CHANNEL_M          304
#define IDM_VIEW_CHANNEL_Y          305
#define IDM_VIEW_CHANNEL_K          306
#define IDM_VIEW_CHANNEL_R          307
#define IDM_VIEW_CHANNEL_G          308
#define IDM_VIEW_CHANNEL_B          309
#define IDM_VIEW_CHANNEL_L          310
#define IDM_VIEW_CHANNEL_A          311
#define IDM_VIEW_ATTR_INFO          312
#define IDM_VIEW_ATTR_PROPERTY      313
#define IDM_VIEW_ANIMATED           314
#define IDM_VIEW_ZOOM_IN            315
#define IDM_VIEW_ZOOM_OUT           316
#define IDM_VIEW_ZOOM_FITWINDOW_W   317
#define IDM_VIEW_ZOOM_FITWINDOW_H   318
#define IDM_VIEW_ZOOM_REALSIZE      319
#define IDM_VIEW_OPTION_BILINEAR    320
#define IDM_VIEW_OPTION_BICUBIC     321
#define IDM_VIEW_OPTION_NEARESTNEIGHBOR 322
#define IDM_VIEW_OPTION_HIGHLINEAR  323
#define IDM_VIEW_OPTION_HIGHCUBIC   324
#define IDM_VIEW_OPTION_PIXELMODE   325
#define IDM_VIEW_OPTION_WRAPMODETILE 326
#define IDM_VIEW_OPTION_WRAPMODEFLIPX 327
#define IDM_VIEW_OPTION_WRAPMODEFLIPY 328
#define IDM_VIEW_OPTION_WRAPMODEFLIPXY 329
#define IDM_VIEW_OPTION_WRAPMODECLAMP0 330
#define IDM_VIEW_OPTION_WRAPMODECLAMPFF 331
#define IDM_VIEW_CROP               332
#define IDM_VIEW_ROTATE90           333
#define IDM_VIEW_ROTATE270          334
#define IDM_VIEW_HORIZONTALFLIP     335
#define IDM_VIEW_VERTICALFLIP       336

#define IDM_EFFECT_TRANSKEY         400
#define IDM_EFFECT_COLORMAP         401
#define IDM_EFFECT_ICC              402
#define IDM_EFFECT_GAMMA            403

#define IDM_TRANSFORM_ROTATE90      430
#define IDM_TRANSFORM_ROTATE180     431
#define IDM_TRANSFORM_ROTATE270     432
#define IDM_TRANSFORM_HORIZONTALFLIP 433
#define IDM_TRANSFORM_VERTICALFLIP  434

#define IDM_CONVERT_8BIT            500
#define IDM_CONVERT_16BITRGB555     501
#define IDM_CONVERT_16BITRGB565     502
#define IDM_CONVERT_24BITRGB        503
#define IDM_CONVERT_32BITRGB        504
#define IDM_CONVERT_32BITARGB       505

#define IDM_ANNOTATION_ANNOTATION   520
#define IDM_ANNOTATION_SOFTWARE     521
#define IDM_ANNOTATION_AUDIOFILE    522

// Set color key dialog

#define IDD_COLORKEYDLG             700
#define IDC_COLORKEY_OK             701
#define IDC_COLORKEY_CANCEL         702

#define IDC_TRANS_R                 710
#define IDC_TRANS_G                 711
#define IDC_TRANS_B                 712
#define IDC_TRANS_C                 713
#define IDC_TRANS_LOWER_RFIELD      714
#define IDC_TRANS_LOWER_GFIELD      715
#define IDC_TRANS_LOWER_BFIELD      716
#define IDC_TRANS_LOWER_CFIELD      717
#define IDC_TRANS_HIGHER_RFIELD     718
#define IDC_TRANS_HIGHER_CFIELD     719
#define IDC_TRANS_HIGHER_GFIELD     720
#define IDC_TRANS_HIGHER_BFIELD     721
#define IDC_TRANS_LOWERCOLOR        722
#define IDC_TRANS_HIGHERCOLOR       723

// Color map dialog

#define IDD_COLORMAPDLG             800
#define IDC_COLORMAP_OK             801
#define IDC_COLORMAP_CANCEL         802

#define IDC_MAP_OLDCOLOR            810
#define IDC_MAP_NEWCOLOR            811
#define IDC_MAP_R                   812
#define IDC_MAP_G                   813
#define IDC_MAP_B                   814
#define IDC_MAP_A                   815
#define IDC_MAP_OLD_RFIELD          816
#define IDC_MAP_OLD_GFIELD          817
#define IDC_MAP_OLD_BFIELD          818
#define IDC_MAP_OLD_AFIELD          819
#define IDC_MAP_NEW_RFIELD          820
#define IDC_MAP_NEW_GFIELD          821
#define IDC_MAP_NEW_BFIELD          822
#define IDC_MAP_NEW_AFIELD          823

// Annotation dialog

#define IDD_ANNOTATIONDLG           900
#define IDC_ANNOTATION_OK           901
#define IDC_ANNOTATION_CANCEL       902

#define IDC_ANNOTATION_EDITOR       910

// JPEG save dialog

#define IDD_SAVEJPEGDLG             1000
#define IDC_SAVEJPEG_OK             1001
#define IDC_SAVEJPEG_CANCEL         1002
#define IDC_SAVEJPEG_QEFIELD        1003
#define IDC_SAVEJPEG_QSLIDER        1004
#define IDC_SAVEJPEG_QUALITY        1005
#define IDC_SAVEJPEG_R90            1006
#define IDC_SAVEJPEG_R180           1007
#define IDC_SAVEJPEG_R270           1008
#define IDC_SAVEJPEG_HFLIP          1009
#define IDC_SAVEJPEG_VFLIP          1010
#define IDC_SAVEJPEG_NOTRANSFORM    1011
#define IDC_SAVEJPEG_LOSSLESSTEXT   1012

// TIFF save dialog

#define IDD_SAVETIFFDLG             1100
#define IDC_SAVETIFFDLG_OK          1101
#define IDC_SAVETIFFDLG_CANCEL      1102
#define IDC_SAVETIFF_COLORDEPTH     1103
#define IDC_SAVETIFF_1BPP           1104
#define IDC_SAVETIFF_4BPP           1105
#define IDC_SAVETIFF_8BPP           1106
#define IDC_SAVETIFF_24BPP          1107
#define IDC_SAVETIFF_32ARGB         1108
#define IDC_SAVETIFF_ASSOURCE       1109
#define IDC_SAVETIFF_COMPRESSMETHOD 1110
#define IDC_SAVETIFF_CCITT3         1111
#define IDC_SAVETIFF_CCITT4         1112
#define IDC_SAVETIFF_RLE            1113
#define IDC_SAVETIFF_LZW            1114
#define IDC_SAVETIFF_UNCOMPRESSED   1115
#define IDC_SAVETIFF_COMPASSOURCE   1116
#define IDC_SAVETIFF_MULTIFRAME     1117

const CLSID K_JPEGCLSID =
{
    0x557cf401,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

const CLSID K_TIFFCLSID =
{
    0x557cf405,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

void    USAGE();
BOOL    AnsiToUnicodeStr(const CHAR* ansiStr,
                         WCHAR* unicodeStr,
                         INT unicodeSize);
BOOL    UnicodeToAnsiStr(const WCHAR* unicodeStr,
                         CHAR* ansiStr,
                         INT ansiSize);
CHAR*   MakeFilterFromCodecs(UINT count,
                             const ImageCodecInfo* codecs,
                             BOOL open);
BOOL    ShowMyDialog(INT     id,
                     HWND    hwnd,
                     FARPROC fpfn);
VOID    FileTimeToDosTime(FILETIME fileTime);
VOID    DisplayTagName(PROPID id);
VOID    DisplayPropertyItem(PropertyItem* pItem);
VOID    ToggleWrapModeOptionMenu(UINT uiMenuItem,
                                 HMENU   hMenu);
VOID    ToggleScaleOptionMenu(UINT    uiMenuItem,
                                 HMENU   hMenu);
VOID    ToggleScaleFactorMenu(UINT    uiMenuItem,
                              HMENU   hMenu);

#if DBG
#define VERBOSE(args) printf args
#else
#define VERBOSE(args)
#endif

#endif // _FRAMETEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\frametest\winutil.cpp ===
//-----------------------------------------------------------------------------
//
// Common utility functions
//
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include "imaging.h"
#include "gdiplusimaging.h"
#include "frametest.h"

BOOL
AnsiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
    )
{
    return MultiByteToWideChar(CP_ACP,
                               0,
                               ansiStr,
                               -1,
                               unicodeStr,
                               unicodeSize) > 0;
}

BOOL
UnicodeToAnsiStr(
    const WCHAR* unicodeStr,
    CHAR* ansiStr,
    INT ansiSize
    )
{
    return WideCharToMultiByte(
                CP_ACP,
                0,
                unicodeStr,
                -1,
                ansiStr,
                ansiSize,
                NULL,
                NULL) > 0;
}

void
USAGE()
{
    printf("******************************************************\n");
    printf("Usage: frametest [-?] [-w width] [-h height] [-x x] [-y y] Img\n");
    printf("-w-----------Specify the window width. Default is 300\n");
    printf("-h-----------Specify the window height. Default is 300\n");
    printf("-x-----------Specify the window X position. Default is 0\n");
    printf("-y-----------Specify the window Y position. Default is 0\n");
    printf("-?-----------Print this usage message\n");
    printf("ImageFile----File to be opened\n");
    printf("Use PageDown and PageUp to goto next/previous page\n");
}// USAGE()

#define SizeofWSTR(s) (sizeof(WCHAR) * (wcslen(s) + 1))
#define SizeofSTR(s) (strlen(s) + 1)

//
// Compose a file type filter string given an array of
// ImageCodecInfo structures
//

CHAR*
MakeFilterFromCodecs(
    UINT count,
    const ImageCodecInfo* codecs,
    BOOL open
    )
{
    static const CHAR allFiles[] = "All Files\0*.*";

    // Figure out the total size of the filter string

    UINT    index;
    UINT    size;

    for ( index = size = 0; index < count; ++index )
    {
        size += SizeofWSTR(codecs[index].FormatDescription)
              + SizeofWSTR(codecs[index].FilenameExtension);
    }

    if ( open )
    {
        size += sizeof(allFiles);
    }
    
    size += sizeof(CHAR);

    // Allocate memory

    CHAR *filter = (CHAR*)malloc(size);
    CHAR* p = filter;
    const WCHAR* ws;

    if ( !filter )
    {
        return NULL;
    }

    if ( open )
    {
        memcpy(p, allFiles, sizeof(allFiles));
        p += sizeof(allFiles);
    }

    for ( index = 0; index < count; ++index )
    {
        ws = codecs[index].FormatDescription;
        size = SizeofWSTR(ws);

        if ( UnicodeToAnsiStr(ws, p, size) )
        {
            p += SizeofSTR(p);
        }
        else
        {
            break;
        }

        ws = codecs[index].FilenameExtension;
        size = SizeofWSTR(ws);

        if ( UnicodeToAnsiStr(ws, p, size) )
        {
            p += SizeofSTR(p);
        }
        else
        {
            break;
        }
    }

    if ( index < count )
    {
        free(filter);
        return NULL;
    }

    *((CHAR*)p) = '\0';

    return filter;
}// MakeFilterFromCodecs()

/****************************************************************************\
*
*  FUNCTION   : ShowMyDialog(int id,HWND hwnd,FARPROC fpfn)
*
*  PURPOSE    : This function displays a dialog box
*
*  RETURNS    : The exit code.
*
\****************************************************************************/
BOOL
ShowMyDialog(
    INT     id,
    HWND    hwnd,
    FARPROC fpfn
    )
{
    BOOL        fRC;
    HINSTANCE   hInst;

    hInst = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
    fRC = (BOOL)DialogBox(hInst, MAKEINTRESOURCE(id), hwnd,
                  (DLGPROC)fpfn);
    FreeProcInstance(fpfn);

    return fRC;
}// ShowMyDialog()

typedef struct _SFFS
{
    // Search Find File Structure

    unsigned char buff[21]; // dos search info
    unsigned char wAttr;
    union
    {
        unsigned short timeVariable;    // RPC47
        unsigned int time:16;
        struct
        {
            unsigned int sec : 5;
            unsigned int mint: 6;
            unsigned int hr  : 5;
        };
    };
    union
    {
        unsigned short dateVariable;
        unsigned int date:16;
        struct
        {
            unsigned int dom : 5;
            unsigned int mon : 4;
            unsigned int yr  : 7;
        };
    };
    unsigned long cbFile;
    unsigned char szFileName[13];
} SFFS;

VOID
FileTimeToDosTime(
    FILETIME fileTime
    )
{
    SFFS sffs;
    INT yr, mo, dy, sc;

    if ( CoFileTimeToDosDateTime(&fileTime,
         &sffs.dateVariable, &sffs.timeVariable))
    {
        yr = sffs.yr + 1980;
        mo = sffs.mon;
        dy = sffs.dom;
//        sc = (DWORD)sffs.hr * 3600 + sffs.mint * 60 + sffs.sec * 2;

        printf("%d:%d:%d %d:%d:%d\n", yr, mo, dy, sffs.hr, sffs.mint,sffs.sec);
    }
}

VOID
DisplayTagName(PROPID id)
{
    VERBOSE(("ID=%d [0x%x] ", id, id));

    // Print the TAG name according to its ID

    switch ( id )
    {
    case TAG_EXIF_IFD:
        VERBOSE(("EXIF IFD: "));
        break;

    case TAG_GPS_IFD:
        VERBOSE(("GPS IFD: "));
        break;

    case TAG_NEW_SUBFILE_TYPE:
        VERBOSE(("New Subfile Type: "));
        break;

    case TAG_SUBFILE_TYPE:
        VERBOSE(("Subfile Type: "));
        break;

    case TAG_IMAGE_WIDTH:
        VERBOSE(("Image Width: "));
        break;

    case TAG_IMAGE_HEIGHT:
        VERBOSE(("Image Height: "));
        break;

    case TAG_BITS_PER_SAMPLE:
        VERBOSE(("Bits Per Sample: "));
        break;

    case TAG_COMPRESSION:
        VERBOSE(("Compression: "));
        break;

    case TAG_THUMBNAIL_COMPRESSION:
        VERBOSE(("Thumbnail Compression: "));
        break;

    case TAG_THUMBNAIL_RESOLUTION_X:
        VERBOSE(("Thumbnail X resolution: "));
        break;

    case TAG_THUMBNAIL_RESOLUTION_Y:
        VERBOSE(("Thumbnail Y resolution: "));
        break;
    
    case TAG_THUMBNAIL_RESOLUTION_UNIT:
        VERBOSE(("Thumbnail resolution unit: "));
        break;
    
    case TAG_PHOTOMETRIC_INTERP:
        VERBOSE(("Photometric Interpolation: "));
        break;

    case TAG_THRESH_HOLDING:
        VERBOSE(("Photometric Interpolation: "));
        break;
    
    case TAG_CELL_WIDTH:
        VERBOSE(("Cell Width: "));
        break;

    case TAG_CELL_HEIGHT:
        VERBOSE(("Cell Height: "));
        break;

    case TAG_FILL_ORDER:
        VERBOSE(("Fill Order: "));
        break;

    case TAG_DOCUMENT_NAME:
        VERBOSE(("Document name: "));
        break;

    case TAG_ORIENTATION:
        VERBOSE(("Orientation: "));
        break;

    case TAG_SAMPLES_PER_PIXEL:
        VERBOSE(("Sample Per Pixel: "));
        break;

    case TAG_PLANAR_CONFIG:
        VERBOSE(("Planar Configuration: "));
        break;

    case TAG_PAGE_NAME:
        VERBOSE(("Page Name: "));
        break;

    case TAG_X_POSITION:
        VERBOSE(("X Position: "));
        break;

    case TAG_Y_POSITION:
        VERBOSE(("Y Position: "));
        break;

    case TAG_FREE_OFFSET:
        VERBOSE(("Free Offset: "));
        break;

    case TAG_FREE_BYTE_COUNTS:
        VERBOSE(("Free Byte Count: "));
        break;

    case TAG_GRAY_RESPONSE_UNIT:
        VERBOSE(("Gray Response Unit: "));
        break;

    case TAG_GRAY_RESPONSE_CURVE:
        VERBOSE(("Gray Response Curve: "));
        break;

    case TAG_T4_OPTION:
        VERBOSE(("T4 Option: "));
        break;

    case TAG_T6_OPTION:
        VERBOSE(("T6 Option: "));
        break;

    case TAG_YCbCr_SUBSAMPLING:
        VERBOSE(("YCbCr Subsampling: "));
        break;

    case TAG_YCbCr_POSITIONING:
        VERBOSE(("YCbCr position: "));
        break;

    case TAG_MIN_SAMPLE_VALUE:
        VERBOSE(("Min sample value: "));
        break;
    
    case TAG_MAX_SAMPLE_VALUE:
        VERBOSE(("Max sample value: "));
        break;

    case TAG_X_RESOLUTION:
        VERBOSE(("X Resolution: "));
        break;

    case TAG_Y_RESOLUTION:
        VERBOSE(("Y Resolution: "));
        break;

    case TAG_RESOLUTION_UNIT:
        VERBOSE(("Resolution UNIT: "));
        break;

    case TAG_PAGE_NUMBER:
        VERBOSE(("Page Number: "));
        break;

    case TAG_HOST_COMPUTER:
        VERBOSE(("Host Computer: "));
        break;
    
    case TAG_PREDICTOR:
        VERBOSE(("Predictor: "));
        break;

    case TAG_RESOLUTION_X_UNIT:
        VERBOSE(("X Resolution UNIT: "));
        break;

    case TAG_RESOLUTION_Y_UNIT:
        VERBOSE(("Y Resolution UNIT: "));
        break;

    case TAG_RESOLUTION_X_LENGTH_UNIT:
        VERBOSE(("X Resolution UNIT LENGTH: "));
        break;

    case TAG_RESOLUTION_Y_LENGTH_UNIT:
        VERBOSE(("Y Resolution UNIT LENGTH: "));
        break;

    case TAG_STRIP_OFFSETS:
        VERBOSE(("Strip Offsets: "));
        break;

    case TAG_ROWS_PER_STRIP:
        VERBOSE(("Rows Per Strip: "));
        break;

    case TAG_STRIP_BYTES_COUNT:
        VERBOSE(("Strip Bytes Count: "));
        break;

    case TAG_JPEG_INTER_FORMAT:
        VERBOSE(("JPEG thumbnail offset: "));
        break;

    case TAG_JPEG_INTER_LENGTH:
        VERBOSE(("JPEG thumbnail Length: "));
        break;

    case TAG_TRANSFER_FUNCTION:
        VERBOSE(("Transfer Function: "));
        break;

    case TAG_WHITE_POINT:
        VERBOSE(("White Point: "));
        break;

    case TAG_PRIMAY_CHROMATICS:
        VERBOSE(("Primay_Chromatics: "));
        break;

    case TAG_COLOR_MAP:
        VERBOSE(("Color Map: "));
        break;

    case TAG_HALFTONE_HINTS:
        VERBOSE(("HalfTone Hints: "));
        break;

    case TAG_TILE_WIDTH:
        VERBOSE(("Tile Width: "));
        break;

    case TAG_TILE_LENGTH:
        VERBOSE(("Tile Height: "));
        break;

    case TAG_TILE_OFFSET:
        VERBOSE(("Tile Offset: "));
        break;

    case TAG_TILE_BYTE_COUNTS:
        VERBOSE(("Tile Byte Count: "));
        break;

    case TAG_INK_SET:
        VERBOSE(("Ink Set: "));
        break;

    case TAG_INK_NAMES:
        VERBOSE(("Ink Names: "));
        break;

    case TAG_NUMBER_OF_INKS:
        VERBOSE(("Number of Inks: "));
        break;

    case TAG_DOT_RANGE:
        VERBOSE(("Dot Range: "));
        break;

    case TAG_TARGET_PRINTER:
        VERBOSE(("Target Printer: "));
        break;

    case TAG_EXTRA_SAMPLES:
        VERBOSE(("Extra Samples: "));
        break;

    case TAG_SAMPLE_FORMAT:
        VERBOSE(("Sample Format: "));
        break;

    case TAG_SMIN_SAMPLE_VALUE:
        VERBOSE(("SMin Sample Value: "));
        break;

    case TAG_SMAX_SAMPLE_VALUE:
        VERBOSE(("SMax Sample Value: "));
        break;

    case TAG_TRANSFER_RANGE:
        VERBOSE(("Transfer Range: "));
        break;

    case TAG_JPEG_PROC:
        VERBOSE(("JPEG Proc: "));
        break;

    case TAG_JPEG_RESTART_INTERVAL:
        VERBOSE(("JPEG Restart Interval: "));
        break;

    case TAG_JPEG_LOSSLESS_PREDICTORS:
        VERBOSE(("JPEG Lossless Predictors: "));
        break;

    case TAG_JPEG_POINT_TRANSFORMS:
        VERBOSE(("JPEG Point Transforms: "));
        break;

    case TAG_JPEG_Q_TABLES:
        VERBOSE(("JPEG Q Tables: "));
        break;

    case TAG_JPEG_DC_TABLES:
        VERBOSE(("JPEG DC Tables: "));
        break;

    case TAG_JPEG_AC_TABLES:
        VERBOSE(("JPEG AC Tables: "));
        break;

    case TAG_YCbCr_COEFFICIENTS:
        VERBOSE(("YCbCr Coefficients: "));
        break;

    case TAG_REF_BLACK_WHITE:
        VERBOSE(("ReferenceBlackWhite: "));
        break;

    case TAG_DATE_TIME:
        VERBOSE(("Date Time: "));
        break;

    case TAG_IMAGE_DESCRIPTION:
        VERBOSE(("Description: "));
        break;

    case TAG_EQUIP_MAKE:
        VERBOSE(("Equipment Make "));
        break;

    case TAG_EQUIP_MODEL:
        VERBOSE(("Equipment Model "));
        break;

    case TAG_SOFTWARE_USED:
        VERBOSE(("Software Used: "));
        break;

    case TAG_ARTIST:
        VERBOSE(("Artist: "));
        break;

    case TAG_COPYRIGHT:
        VERBOSE(("Copyright: "));
        break;

    case TAG_PRINT_FLAGS:
        VERBOSE(("Print flags: "));
        break;

    case TAG_PRINT_FLAGS_VERSION:
        VERBOSE(("Print flags information---Version: "));
        break;

    case TAG_PRINT_FLAGS_CROP:
        VERBOSE(("Print flags information---Crop: "));
        break;

    case TAG_PRINT_FLAGS_BLEEDWIDTH:
        VERBOSE(("Print flags information---Bleed Width: "));
        break;

    case TAG_PRINT_FLAGS_BLEEDWIDTHSCALE:
        VERBOSE(("Print flags information---Bleed Width Scale: "));
        break;

    case TAG_COLORTRANSFER_FUNCTION:
        VERBOSE(("Color transfer function--"));
        break;

    case TAG_PIXEL_UNIT:
        VERBOSE(("Pixel UNIT: "));
        break;

    case TAG_PIXEL_PER_UNIT_X:
        VERBOSE(("Pixels Per UNIT in X: "));
        break;

    case TAG_PIXEL_PER_UNIT_Y:
        VERBOSE(("Pixels Per UNIT in Y: "));
        break;

    case TAG_PALETTE_HISTOGRAM:
        VERBOSE(("Palette histogram: "));
        break;

    case TAG_HALFTONE_LPI:
        VERBOSE(("Color halftoning information LPI:"));
        break;

    case TAG_HALFTONE_LPI_UNIT:
        VERBOSE(("Color halftoning information LPI UNIT:"));
        break;

    case TAG_HALFTONE_DEGREE:
        VERBOSE(("Color halftoning information Degree:"));
        break;

    case TAG_HALFTONE_SHAPE:
        VERBOSE(("Color halftoning information Shape:"));
        break;

    case TAG_HALFTONE_MISC:
        VERBOSE(("Color halftoning information Misc:"));
        break;

    case TAG_HALFTONE_SCREEN:
        VERBOSE(("Color halftoning information Screen:"));
        break;

    case TAG_JPEG_QUALITY:
        VERBOSE(("JPEG quality: "));
        break;

    case TAG_GRID_SIZE:
        VERBOSE(("Grid and guides: "));
        break;

    case TAG_THUMBNAIL_FORMAT:
        VERBOSE(("Thumbnail Data Format: "));
        break;

    case TAG_THUMBNAIL_WIDTH:
    case TAG_THUMBNAIL_IMAGE_WIDTH:
        VERBOSE(("Thumbnail Width: "));
        break;

    case TAG_THUMBNAIL_HEIGHT:
    case TAG_THUMBNAIL_IMAGE_HEIGHT:
        VERBOSE(("Thumbnail Height: "));
        break;

    case TAG_THUMBNAIL_COLORDEPTH:
        VERBOSE(("Thumbnail Color depth: "));
        break;

    case TAG_THUMBNAIL_PLANES:
        VERBOSE(("Thumbnail Number of plane: "));
        break;

    case TAG_THUMBNAIL_RAWBYTES:
        VERBOSE(("Thumbnail Raw bytes (bytes): "));
        break;

    case TAG_THUMBNAIL_SIZE:
        VERBOSE(("Thumbnail Data Size (bytes): "));
        break;

    case TAG_THUMBNAIL_COMPRESSED_SIZE:
        VERBOSE(("Thumbnail Compressed Size (bytes): "));
        break;

    case TAG_THUMBNAIL_DATA:
        VERBOSE(("Thumbnail data bits: "));
        break;
        
    case TAG_LUMINANCE_TABLE:
        VERBOSE(("Luminance table "));
        break;

    case TAG_CHROMINANCE_TABLE:
        VERBOSE(("Chrominance table "));
        break;

    case TAG_IMAGE_TITLE:
        VERBOSE(("Image title: "));
        break;

    case TAG_ICC_PROFILE:
        VERBOSE(("ICC PROFILE "));
        break;

    case TAG_ICC_PROFILE_DESCRIPTOR:
        VERBOSE(("ICC PROFILE descriptor: "));
        break;
    
    case TAG_SRGB_RENDERING_INTENT:
        VERBOSE(("sRGB rendering intent: "));
        break;

    case TAG_GAMMA:
        VERBOSE(("GAMMA "));
        break;

    case TAG_FRAMEDELAY:
        VERBOSE(("Frame delay "));
        break;

    case TAG_LOOPCOUNT:
        VERBOSE(("Loop count "));
        break;

    case EXIF_TAG_VER:
        VERBOSE(("EXIF Version: "));
        break;

    case EXIF_TAG_FPX_VER:
        VERBOSE(("FlashPixVersion Version: "));
        break;

    case EXIF_TAG_COLOR_SPACE:
        VERBOSE(("Color Space: "));
        break;

    case EXIF_TAG_COMP_CONFIG:
        VERBOSE(("Components Configuration: "));
        break;

    case EXIF_TAG_COMP_BPP:
        VERBOSE(("Components Bits Per Pixel: "));
        break;

    case EXIF_TAG_PIX_X_DIM:
        VERBOSE(("Pixel X Dimension: "));
        break;

    case EXIF_TAG_PIX_Y_DIM:
        VERBOSE(("Pixel Y Dimension: "));
        break;

    case EXIF_TAG_MAKER_NOTE:
        VERBOSE(("Maker Note: "));
        break;

    case EXIF_TAG_USER_COMMENT:
        VERBOSE(("User Comments: "));
        break;

    case EXIF_TAG_RELATED_WAV:
        VERBOSE(("Related WAV File: "));
        break;

    case EXIF_TAG_D_T_ORIG:
        VERBOSE(("Date Time Original: "));
        break;

    case EXIF_TAG_D_T_DIGITIZED:
        VERBOSE(("Date Time Digitized: "));
        break;

    case EXIF_TAG_D_T_SUBSEC:
        VERBOSE(("Date & Time subseconds: "));
        break;

    case EXIF_TAG_D_T_ORIG_SS:
        VERBOSE(("Date & Time original subseconds: "));
        break;

    case EXIF_TAG_D_T_DIG_SS:
        VERBOSE(("Date & Time digitized subseconds: "));
        break;

    case EXIF_TAG_EXPOSURE_TIME:
        VERBOSE(("Exposure Time: "));
        break;

    case EXIF_TAG_F_NUMBER:
        VERBOSE(("F Number: "));
        break;

    case EXIF_TAG_EXPOSURE_PROG:
        VERBOSE(("Exposure Program: "));
        break;

    case EXIF_TAG_SPECTRAL_SENSE:
        VERBOSE(("Spectral Sense: "));
        break;

    case EXIF_TAG_ISO_SPEED:
        VERBOSE(("ISO Speed: "));
        break;

    case EXIF_TAG_OECF:
        VERBOSE(("Opto-Electric Conversion Function values: "));
        break;

    case EXIF_TAG_SHUTTER_SPEED:
        VERBOSE(("Shutter Speed: "));
        break;

    case EXIF_TAG_APERATURE:
        VERBOSE(("Aperature: "));
        break;

    case EXIF_TAG_BRIGHTNESS:
        VERBOSE(("Brightness: "));
        break;

    case EXIF_TAG_EXPOSURE_BIAS:
        VERBOSE(("Exposure Bias: "));
        break;

    case EXIF_TAG_MAX_APERATURE:
        VERBOSE(("Max Aperature: "));
        break;

    case EXIF_TAG_SUBJECT_DIST:
        VERBOSE(("Subject Distance: "));
        break;

    case EXIF_TAG_METERING_MODE:
        VERBOSE(("Metering Mode: "));
        break;

    case EXIF_TAG_LIGHT_SOURCE:
        VERBOSE(("Light Source: "));
        break;

    case EXIF_TAG_FLASH:
        VERBOSE(("Flash: "));
        break;

    case EXIF_TAG_FOCAL_LENGTH:
        VERBOSE(("Focal Length: "));
        break;

    case EXIF_TAG_FLASH_ENERGY:
        VERBOSE(("Flash Energy: "));
        break;

    case EXIF_TAG_SPATIAL_FR:
        VERBOSE(("Spacial Frequency Response: "));
        break;

    case EXIF_TAG_FOCAL_X_RES:
        VERBOSE(("Focal Plane X Resolution: "));
        break;

    case EXIF_TAG_FOCAL_Y_RES:
        VERBOSE(("Focal Plane Y Resolution: "));
        break;

    case EXIF_TAG_FOCAL_RES_UNIT:
        VERBOSE(("Focal Plane Resolution Unit: "));
        break;

    case EXIF_TAG_SUBJECT_LOC:
        VERBOSE(("Subject Location: "));
        break;

    case EXIF_TAG_EXPOSURE_INDEX:
        VERBOSE(("Exposure Index: "));
        break;

    case EXIF_TAG_SENSING_METHOD:
        VERBOSE(("Sensing Method: "));
        break;

    case EXIF_TAG_FILE_SOURCE:
        VERBOSE(("File Source: "));
        break;

    case EXIF_TAG_SCENE_TYPE:
        VERBOSE(("Scene Type: "));
        break;

    case EXIF_TAG_CFA_PATTERN:
        VERBOSE(("CFA Pattern: "));
        break;

    case EXIF_TAG_INTEROP:
        VERBOSE(("Interoperability Unit: "));
        break;

    case GPS_TAG_VER:
        VERBOSE(("GPS Version: "));
        break;

    case GPS_TAG_LATTITUDE_REF:
        VERBOSE(("GPS Lattitude Reference: "));
        break;

    case GPS_TAG_LATTITUDE:
        VERBOSE(("GPS Lattitude: "));
        break;

    case GPS_TAG_LONGITUDE_REF:
        VERBOSE(("GPS Longitude Reference: "));
        break;

    case GPS_TAG_LONGITUDE:
        VERBOSE(("GPS Longitude: "));
        break;

    case GPS_TAG_ALTITUDE_REF:
        VERBOSE(("GPS Altitude Reference: "));
        break;

    case GPS_TAG_ALTITUDE:
        VERBOSE(("GPS Altitude: "));
        break;

    case GPS_TAG_GPS_TIME:
        VERBOSE(("GPS Time: "));
        break;

    case GPS_TAG_GPS_SATELLITES:
        VERBOSE(("GPS Satellites: "));
        break;

    case GPS_TAG_GPS_STATUS:
        VERBOSE(("GPS Status: "));
        break;

    case GPS_TAG_GPS_MEASURE_MODE:
        VERBOSE(("GPS Measure Mode: "));
        break;

    case GPS_TAG_GPS_DOP:
        VERBOSE(("GPS Measurement precision: "));
        break;

    case GPS_TAG_SPEED_REF:
        VERBOSE(("GPS Speed Reference: "));
        break;

    case GPS_TAG_SPEED:
        VERBOSE(("GPS Speed: "));
        break;

    case GPS_TAG_TRACK_REF:
        VERBOSE(("GPS Track Reference: "));
        break;

    case GPS_TAG_TRACK:
        VERBOSE(("GPS Track: "));
        break;

    case GPS_TAG_IMG_DIR_REF:
        VERBOSE(("GPS Image Direction Reference: "));
        break;

    case GPS_TAG_IMG_DIR:
        VERBOSE(("GPS Image Direction: "));
        break;

    case GPS_TAG_MAP_DATUM:
        VERBOSE(("GPS Map Datum: "));
        break;

    case GPS_TAG_DEST_LAT_REF:
        VERBOSE(("GPS Destination Latitude Reference: "));
        break;

    case GPS_TAG_DEST_LAT:
        VERBOSE(("GPS Destination Latitude: "));
        break;

    case GPS_TAG_DEST_LONG_REF:
        VERBOSE(("GPS Longitude Reference: "));
        break;

    case GPS_TAG_DEST_LONG:
        VERBOSE(("GPS Longitude: "));
        break;

    case GPS_TAG_DEST_BEAR_REF:
        VERBOSE(("GPS Destination Bear Reference: "));
        break;

    case GPS_TAG_DEST_BEAR:
        VERBOSE(("GPS Destination Bear: "));
        break;

    case GPS_TAG_DEST_DIST_REF:
        VERBOSE(("GPS Destination Distance Reference: "));
        break;

    case GPS_TAG_DEST_DIST:
        VERBOSE(("GPS Destination Distance: "));
        break;

    default:
        VERBOSE(("Unknown Tag "));
        break;
    }
}// DisplayTagName()

VOID
DisplayPropertyItem(
    PropertyItem* pItem
    )
{
    // Print out the name first

    DisplayTagName(pItem->id);

    switch ( pItem->type )
    {
    case TAG_TYPE_BYTE:
    {
        // Print pItem->length bytes of information

        BYTE* pcTemp = (BYTE*)pItem->value;

        for ( int i = 0; i < (int)pItem->length; ++i )
        {
            VERBOSE(("%2.2x", *pcTemp++));
        }
        VERBOSE(("\n"));

#if 0 //(THUMBNAIL DATA testing)
        if ( pItem->id == TAG_THUMBNAIL_DATA )
        {
            FILE* fHandle = fopen("foo.jpg", "w");
            fwrite(pItem->value, 1, pItem->length, fHandle);
            fclose(fHandle);
        }
#endif
        break;
    }

    case TAG_TYPE_ASCII:
        VERBOSE(("%s\n", pItem->value));
        break;

    case TAG_TYPE_SHORT:
    {
        int iTotalItems = pItem->length / sizeof(SHORT);
        
        unsigned short* pusTemp = (unsigned short*)pItem->value;
        
        for ( int i = 0; i < iTotalItems; ++i )
        {
            VERBOSE(("%d ", *pusTemp));
            pusTemp++;
        }

        VERBOSE(("\n"));
        break;
    }

    case TAG_TYPE_LONG:
    {
        int iTotalItems = pItem->length / sizeof(LONG);

        long* plTemp = (long*)pItem->value;
        
        for ( int i = 0; i < iTotalItems; ++i )
        {
            VERBOSE(("%ld ", *plTemp));
            plTemp++;
        }

        VERBOSE(("\n"));

        break;
    }

    case TAG_TYPE_RATIONAL:
    case TAG_TYPE_SRATIONAL:
    {
        // Each RATIONAL/SRATIONAL contains 2 LONGs

        INT     iNumOfValue = pItem->length / ( 2 * sizeof(LONG) );
        LONG*   pLong = (LONG*)pItem->value;

        for ( int i = 0; i < iNumOfValue; ++i )
        {
            LONG    lNum = *pLong;
            LONG    lDen = *(pLong + 1);
        
            VERBOSE(("%f ", (float)lNum/lDen));
            pLong += 2;
        }
        VERBOSE(("\n"));

        break;
    }

    case TAG_TYPE_UNDEFINED:
    {
        // Print pItem->length bytes of information

        BYTE* pcTemp = (BYTE*)pItem->value;

        for ( int i = 0; i < (int)pItem->length; ++i )
        {
            VERBOSE(("%2.2x ", *pcTemp++));
        }

        VERBOSE(("\n"));
        break;
    }

    case TAG_TYPE_SLONG:
        VERBOSE(("%p\n", pItem->value));
        break;

    default:
        VERBOSE(("Unknown VT type\n"));
        break;
    }
}// DisplayPropertyItem()

VOID
ToggleScaleFactorMenu(
    UINT    uiMenuItem,
    HMENU   hMenu
    )
{
    for ( UINT uiTemp = IDM_VIEW_ZOOM_FITWINDOW_W;
         uiTemp <= IDM_VIEW_ZOOM_REALSIZE; uiTemp++ )
    {
        if ( uiTemp == uiMenuItem )
        {
            CheckMenuItem(hMenu, uiMenuItem, MF_BYCOMMAND | MF_CHECKED);
        }
        else
        {
            CheckMenuItem(hMenu, uiTemp, MF_BYCOMMAND | MF_UNCHECKED);
        }
    }
}// ToggleScaleFactorMenu()

VOID
ToggleScaleOptionMenu(
    UINT    uiMenuItem,
    HMENU   hMenu
    )
{
    for ( UINT uiTemp = IDM_VIEW_OPTION_BILINEAR;
         uiTemp <= IDM_VIEW_OPTION_HIGHCUBIC; uiTemp++ )
    {
        if ( uiTemp == uiMenuItem )
        {
            CheckMenuItem(hMenu, uiMenuItem, MF_BYCOMMAND | MF_CHECKED);
        }
        else
        {
            CheckMenuItem(hMenu, uiTemp, MF_BYCOMMAND | MF_UNCHECKED);
        }
    }
}// ToggleScaleOptionMenu()

VOID
ToggleWrapModeOptionMenu(
    UINT    uiMenuItem,
    HMENU   hMenu
    )
{
    for ( UINT uiTemp = IDM_VIEW_OPTION_WRAPMODETILE;
         uiTemp <= IDM_VIEW_OPTION_WRAPMODECLAMPFF; uiTemp++ )
    {
        if ( uiTemp == uiMenuItem )
        {
            CheckMenuItem(hMenu, uiMenuItem, MF_BYCOMMAND | MF_CHECKED);
        }
        else
        {
            CheckMenuItem(hMenu, uiTemp, MF_BYCOMMAND | MF_UNCHECKED);
        }
    }
}// ToggleWrapModeOptionMenu()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCEA(240)
#define RT_TOOLBAR  MAKEINTRESOURCEA(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cantialias.cpp ===
/******************************Module*Header*******************************\
* Module Name: CAntialias.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CAntialias.h"

CAntialias::CAntialias(BOOL bRegression)
{
	strcpy(m_szName,"Antialias");
	m_bRegression=bRegression;
}

CAntialias::~CAntialias()
{

}

void CAntialias::Set(Graphics *g)
{
	g->SetSmoothingMode(m_bUseSetting ? SmoothingModeAntiAlias : SmoothingModeNone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cantialias.h ===
/******************************Module*Header*******************************\
* Module Name: CAntialias.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CANTIALIAS_H
#define __CANTIALIAS_H

#include "CSetting.h"

class CAntialias : public CSetting  
{
public:
	CAntialias(BOOL bRegression);
	virtual ~CAntialias();

	void Set(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cbitmap.h ===
/******************************Module*Header*******************************\
* Module Name: CBitmap.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  08-08-2000 - asecchia
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CBITMAP_H
#define __CBITMAP_H

#include "COutput.h"



class CBitmap : public COutput  
{
public:
	CBitmap(BOOL bRegression, PixelFormat pixelFormat);
	virtual ~CBitmap();

	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	BOOL WriteBitmap(char *szTitle, HBITMAP hbitmap, INT width, INT height);
	void InitPalettes();									// Initialize palettes

    Bitmap *m_bmp;

	PixelFormat m_PixelFormat;											// # of bits to use
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cbitmaps.cpp ===
/******************************Module*Header*******************************\
* Module Name: CBitmaps.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CBitmaps.h"

CBitmaps::CBitmaps(BOOL bRegression)
{
	strcpy(m_szName,"Image : Filters");
	m_bRegression=bRegression;
}

CBitmaps::~CBitmaps()
{
}

void CBitmaps::Draw(Graphics *g)
{
    Bitmap *bitmap = new Bitmap(L"..\\data\\3x3.bmp");

    PointF dest[3]; 

    for(int i=0; i<=InterpolationModeHighQualityBicubic; i++)
    {
        // for all the interpolation modes 

        g->SetInterpolationMode((InterpolationMode)i);

        // simple scale

        dest[0].X = (float)0/1024.0f*TESTAREAWIDTH;
        dest[0].Y = (float)i*100.0f/768.0f*TESTAREAHEIGHT;
        dest[1].X = (float)100/1024.0f*TESTAREAWIDTH;
        dest[1].Y = (float)i*100.0f/768.0f*TESTAREAHEIGHT;
        dest[2].X = (float)0/1024.0f*TESTAREAWIDTH;
        dest[2].Y = (float)(100+i*100.0f)/768.0f*TESTAREAHEIGHT;
        g->DrawImage(bitmap, dest, 3, 0, 0, 3, 3, UnitPixel);

        // rotate 90

        dest[0].X = (float)200/1024.0f*TESTAREAWIDTH;
        dest[0].Y = (float)i*100.0f/768.0f*TESTAREAHEIGHT;
        dest[1].X = (float)200/1024.0f*TESTAREAWIDTH;
        dest[1].Y = (float)(100+i*100.0f)/768.0f*TESTAREAHEIGHT;
        dest[2].X = (float)100/1024.0f*TESTAREAWIDTH;
        dest[2].Y = (float)i*100.0f/768.0f*TESTAREAHEIGHT;
        g->DrawImage(bitmap, dest, 3, 0, 0, 3, 3, UnitPixel);
    
        // rotate 180

        dest[0].X = (float)300/1024.0f*TESTAREAWIDTH;
        dest[0].Y = (float)(100+i*100.0f)/768.0f*TESTAREAHEIGHT;
        dest[1].X = (float)200/1024.0f*TESTAREAWIDTH;
        dest[1].Y = (float)(100+i*100.0f)/768.0f*TESTAREAHEIGHT;
        dest[2].X = (float)300/1024.0f*TESTAREAWIDTH;
        dest[2].Y = (float)i*100.0f/768.0f*TESTAREAHEIGHT;
        g->DrawImage(bitmap, dest, 3, 0, 0, 3, 3, UnitPixel);
        
        // rotate 270

        dest[0].X = (float)300/1024.0f*TESTAREAWIDTH;
        dest[0].Y = (float)(100+i*100.0f)/768.0f*TESTAREAHEIGHT;
        dest[1].X = (float)300/1024.0f*TESTAREAWIDTH;
        dest[1].Y = (float)i*100.0f/768.0f*TESTAREAHEIGHT;
        dest[2].X = (float)400/1024.0f*TESTAREAWIDTH;
        dest[2].Y = (float)(100+i*100.0f)/768.0f*TESTAREAHEIGHT;
        g->DrawImage(bitmap, dest, 3, 0, 0, 3, 3, UnitPixel);
    }

    delete bitmap;

    WCHAR *filename = L"..\\data\\winnt256.bmp";
    bitmap = new Bitmap(filename);

    dest[0].X = (int)(300.0f/450.0f*TESTAREAWIDTH);
    dest[0].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    dest[1].X = (int)(450.0f/450.0f*TESTAREAWIDTH);
    dest[1].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    dest[2].X = (int)(240.0f/450.0f*TESTAREAWIDTH);
    dest[2].Y = (int)(200.0f/450.0f*TESTAREAHEIGHT);
    g->DrawImage(bitmap, &dest[0], 3);

    Image *imageThumb = bitmap->GetThumbnailImage(32, 32);
    RectF thumbRect(
        (int)(220.0f/450.0f*TESTAREAWIDTH), 
        (int)(50.0f/450.0f*TESTAREAHEIGHT), 
        (REAL) imageThumb->GetWidth(), 
        (REAL) imageThumb->GetHeight()
    );
    g->DrawImage(imageThumb, thumbRect);
    delete imageThumb;
    

    g->SetInterpolationMode(InterpolationModeHighQualityBicubic);

    dest[0].X = (int)(300.0f/450.0f*TESTAREAWIDTH);
    dest[0].Y = (int)(250.0f/450.0f*TESTAREAHEIGHT);
    dest[1].X = (int)(450.0f/450.0f*TESTAREAWIDTH);
    dest[1].Y = (int)(250.0f/450.0f*TESTAREAHEIGHT);
    dest[2].X = (int)(300.0f/450.0f*TESTAREAWIDTH);
    dest[2].Y = (int)(400.0f/450.0f*TESTAREAHEIGHT);
    g->DrawImage(bitmap, &dest[0], 3);
    
    delete bitmap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cbitmap.cpp ===
/******************************Module*Header*******************************\
* Module Name: CBitmap.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  08-08-2000 - asecchia
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CBitmap.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CBitmap::CBitmap(BOOL bRegression, PixelFormat pixelFormat)
{
    switch(pixelFormat) {
    case PixelFormat1bppIndexed:
    sprintf(m_szName,"Bitmap %s ", "1bppIndexed");
    break;
    case PixelFormat4bppIndexed:    	
    sprintf(m_szName,"Bitmap %s ", "4bppIndexed");
    break;
    case PixelFormat8bppIndexed:        
    sprintf(m_szName,"Bitmap %s ", "8bppIndexed");
    break;
    case PixelFormat16bppGrayScale:     
    sprintf(m_szName,"Bitmap %s ", "16bppGrayScale");
    break;
    case PixelFormat16bppRGB555:        
    sprintf(m_szName,"Bitmap %s ", "16bppRGB555");
    break;
    case PixelFormat16bppRGB565:        
    sprintf(m_szName,"Bitmap %s ", "16bppRGB565");
    break;
    case PixelFormat16bppARGB1555:      
    sprintf(m_szName,"Bitmap %s ", "16bppARGB1555");
    break;
    case PixelFormat24bppRGB:           
    sprintf(m_szName,"Bitmap %s ", "24bppRGB");
    break;
    case PixelFormat32bppRGB:           
    sprintf(m_szName,"Bitmap %s ", "32bppRGB");
    break;
    case PixelFormat32bppARGB:          
    sprintf(m_szName,"Bitmap %s ", "32bppARGB");
    break;
    case PixelFormat32bppPARGB:         
    sprintf(m_szName,"Bitmap %s ", "32bppPARGB");
    break;
    case PixelFormat48bppRGB:           
    sprintf(m_szName,"Bitmap %s ", "48bppRGB");
    break;
    case PixelFormat64bppARGB:          
    sprintf(m_szName,"Bitmap %s ", "64bppARGB");
    break;
    case PixelFormat64bppPARGB:         
    sprintf(m_szName,"Bitmap %s ", "64bppPARGB");
    break;
    }
	m_PixelFormat=pixelFormat;
	m_bRegression=bRegression;
}

CBitmap::~CBitmap()
{
}

Graphics *CBitmap::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;
    m_bmp = new Bitmap((INT)TESTAREAWIDTH, (INT)TESTAREAHEIGHT, m_PixelFormat);

    g = new Graphics(m_bmp);

	// Since we are doing the test on another surface
	nOffsetX=0;
	nOffsetY=0;

	return g;
}

void CBitmap::PostDraw(RECT rTestArea)
{
    HDC hdcOrig = GetDC(g_FuncTest.m_hWndMain);
    Graphics *g = new Graphics(hdcOrig);
    g->DrawImage(m_bmp, rTestArea.left, rTestArea.top, 0, 0, (INT)TESTAREAWIDTH, (INT)TESTAREAHEIGHT, UnitPixel);

    delete m_bmp;
    delete g;
    m_bmp = NULL;
	ReleaseDC(g_FuncTest.m_hWndMain,hdcOrig);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cbitmaps.h ===
/******************************Module*Header*******************************\
* Module Name: CBitmaps.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CBITMAPS_H
#define __CBITMAPS_H

#include "CPrimitive.h"

class CBitmaps : public CPrimitive  
{
public:
	CBitmaps(BOOL bRegression);
	virtual ~CBitmaps();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cbkgradient.h ===
/******************************Module*Header*******************************\
* Module Name: CBKGradient.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CBKGRADIENT_H
#define __CBKGRADIENT_H

#include "CSetting.h"

class CBKGradient : public CSetting  
{
public:
	CBKGradient(BOOL bRegression);
	virtual ~CBKGradient();

	void Set(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\ccachedbitmap.h ===
/******************************Module*Header*******************************\
* Module Name: CCachedBitmap.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  06-01-2000 - Adrian Secchia [asecchia]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CCACHEDBITMAP_H
#define __CCACHEDBITMAP_H

#include "CPrimitive.h"

class CCachedBitmap : public CPrimitive  
{
public:
	CCachedBitmap(BOOL bRegression);
	virtual ~CCachedBitmap();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\ccachedbitmap.cpp ===
/******************************Module*Header*******************************\
* Module Name: CCachedBitmap.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  06-01-2000 - Adrian Secchia [asecchia]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CCachedBitmap.h"

int PrimeNumbers[1000] = {
      2,     3,     5,     7,    11,    13,    17,    19,    23,    29,
     31,    37,    41,    43,    47,    53,    59,    61,    67,    71,
     73,    79,    83,    89,    97,   101,   103,   107,   109,   113,
    127,   131,   137,   139,   149,   151,   157,   163,   167,   173,
    179,   181,   191,   193,   197,   199,   211,   223,   227,   229,
    233,   239,   241,   251,   257,   263,   269,   271,   277,   281,
    283,   293,   307,   311,   313,   317,   331,   337,   347,   349,
    353,   359,   367,   373,   379,   383,   389,   397,   401,   409,
    419,   421,   431,   433,   439,   443,   449,   457,   461,   463,
    467,   479,   487,   491,   499,   503,   509,   521,   523,   541,
    547,   557,   563,   569,   571,   577,   587,   593,   599,   601,
    607,   613,   617,   619,   631,   641,   643,   647,   653,   659,
    661,   673,   677,   683,   691,   701,   709,   719,   727,   733,
    739,   743,   751,   757,   761,   769,   773,   787,   797,   809,
    811,   821,   823,   827,   829,   839,   853,   857,   859,   863,
    877,   881,   883,   887,   907,   911,   919,   929,   937,   941,
    947,   953,   967,   971,   977,   983,   991,   997,  1009,  1013,
   1019,  1021,  1031,  1033,  1039,  1049,  1051,  1061,  1063,  1069,
   1087,  1091,  1093,  1097,  1103,  1109,  1117,  1123,  1129,  1151,
   1153,  1163,  1171,  1181,  1187,  1193,  1201,  1213,  1217,  1223,
   1229,  1231,  1237,  1249,  1259,  1277,  1279,  1283,  1289,  1291,
   1297,  1301,  1303,  1307,  1319,  1321,  1327,  1361,  1367,  1373,
   1381,  1399,  1409,  1423,  1427,  1429,  1433,  1439,  1447,  1451,
   1453,  1459,  1471,  1481,  1483,  1487,  1489,  1493,  1499,  1511,
   1523,  1531,  1543,  1549,  1553,  1559,  1567,  1571,  1579,  1583,
   1597,  1601,  1607,  1609,  1613,  1619,  1621,  1627,  1637,  1657,
   1663,  1667,  1669,  1693,  1697,  1699,  1709,  1721,  1723,  1733,
   1741,  1747,  1753,  1759,  1777,  1783,  1787,  1789,  1801,  1811,
   1823,  1831,  1847,  1861,  1867,  1871,  1873,  1877,  1879,  1889,
   1901,  1907,  1913,  1931,  1933,  1949,  1951,  1973,  1979,  1987,
   1993,  1997,  1999,  2003,  2011,  2017,  2027,  2029,  2039,  2053,
   2063,  2069,  2081,  2083,  2087,  2089,  2099,  2111,  2113,  2129,
   2131,  2137,  2141,  2143,  2153,  2161,  2179,  2203,  2207,  2213,
   2221,  2237,  2239,  2243,  2251,  2267,  2269,  2273,  2281,  2287,
   2293,  2297,  2309,  2311,  2333,  2339,  2341,  2347,  2351,  2357,
   2371,  2377,  2381,  2383,  2389,  2393,  2399,  2411,  2417,  2423,
   2437,  2441,  2447,  2459,  2467,  2473,  2477,  2503,  2521,  2531,
   2539,  2543,  2549,  2551,  2557,  2579,  2591,  2593,  2609,  2617,
   2621,  2633,  2647,  2657,  2659,  2663,  2671,  2677,  2683,  2687,
   2689,  2693,  2699,  2707,  2711,  2713,  2719,  2729,  2731,  2741,
   2749,  2753,  2767,  2777,  2789,  2791,  2797,  2801,  2803,  2819,
   2833,  2837,  2843,  2851,  2857,  2861,  2879,  2887,  2897,  2903,
   2909,  2917,  2927,  2939,  2953,  2957,  2963,  2969,  2971,  2999,
   3001,  3011,  3019,  3023,  3037,  3041,  3049,  3061,  3067,  3079,
   3083,  3089,  3109,  3119,  3121,  3137,  3163,  3167,  3169,  3181,
   3187,  3191,  3203,  3209,  3217,  3221,  3229,  3251,  3253,  3257,
   3259,  3271,  3299,  3301,  3307,  3313,  3319,  3323,  3329,  3331,
   3343,  3347,  3359,  3361,  3371,  3373,  3389,  3391,  3407,  3413,
   3433,  3449,  3457,  3461,  3463,  3467,  3469,  3491,  3499,  3511,
   3517,  3527,  3529,  3533,  3539,  3541,  3547,  3557,  3559,  3571,
   3581,  3583,  3593,  3607,  3613,  3617,  3623,  3631,  3637,  3643,
   3659,  3671,  3673,  3677,  3691,  3697,  3701,  3709,  3719,  3727,
   3733,  3739,  3761,  3767,  3769,  3779,  3793,  3797,  3803,  3821,
   3823,  3833,  3847,  3851,  3853,  3863,  3877,  3881,  3889,  3907,
   3911,  3917,  3919,  3923,  3929,  3931,  3943,  3947,  3967,  3989,
   4001,  4003,  4007,  4013,  4019,  4021,  4027,  4049,  4051,  4057,
   4073,  4079,  4091,  4093,  4099,  4111,  4127,  4129,  4133,  4139,
   4153,  4157,  4159,  4177,  4201,  4211,  4217,  4219,  4229,  4231,
   4241,  4243,  4253,  4259,  4261,  4271,  4273,  4283,  4289,  4297,
   4327,  4337,  4339,  4349,  4357,  4363,  4373,  4391,  4397,  4409,
   4421,  4423,  4441,  4447,  4451,  4457,  4463,  4481,  4483,  4493,
   4507,  4513,  4517,  4519,  4523,  4547,  4549,  4561,  4567,  4583,
   4591,  4597,  4603,  4621,  4637,  4639,  4643,  4649,  4651,  4657,
   4663,  4673,  4679,  4691,  4703,  4721,  4723,  4729,  4733,  4751,
   4759,  4783,  4787,  4789,  4793,  4799,  4801,  4813,  4817,  4831,
   4861,  4871,  4877,  4889,  4903,  4909,  4919,  4931,  4933,  4937,
   4943,  4951,  4957,  4967,  4969,  4973,  4987,  4993,  4999,  5003,
   5009,  5011,  5021,  5023,  5039,  5051,  5059,  5077,  5081,  5087,
   5099,  5101,  5107,  5113,  5119,  5147,  5153,  5167,  5171,  5179,
   5189,  5197,  5209,  5227,  5231,  5233,  5237,  5261,  5273,  5279,
   5281,  5297,  5303,  5309,  5323,  5333,  5347,  5351,  5381,  5387,
   5393,  5399,  5407,  5413,  5417,  5419,  5431,  5437,  5441,  5443,
   5449,  5471,  5477,  5479,  5483,  5501,  5503,  5507,  5519,  5521,
   5527,  5531,  5557,  5563,  5569,  5573,  5581,  5591,  5623,  5639,
   5641,  5647,  5651,  5653,  5657,  5659,  5669,  5683,  5689,  5693,
   5701,  5711,  5717,  5737,  5741,  5743,  5749,  5779,  5783,  5791,
   5801,  5807,  5813,  5821,  5827,  5839,  5843,  5849,  5851,  5857,
   5861,  5867,  5869,  5879,  5881,  5897,  5903,  5923,  5927,  5939,
   5953,  5981,  5987,  6007,  6011,  6029,  6037,  6043,  6047,  6053,
   6067,  6073,  6079,  6089,  6091,  6101,  6113,  6121,  6131,  6133,
   6143,  6151,  6163,  6173,  6197,  6199,  6203,  6211,  6217,  6221,
   6229,  6247,  6257,  6263,  6269,  6271,  6277,  6287,  6299,  6301,
   6311,  6317,  6323,  6329,  6337,  6343,  6353,  6359,  6361,  6367,
   6373,  6379,  6389,  6397,  6421,  6427,  6449,  6451,  6469,  6473,
   6481,  6491,  6521,  6529,  6547,  6551,  6553,  6563,  6569,  6571,
   6577,  6581,  6599,  6607,  6619,  6637,  6653,  6659,  6661,  6673,
   6679,  6689,  6691,  6701,  6703,  6709,  6719,  6733,  6737,  6761,
   6763,  6779,  6781,  6791,  6793,  6803,  6823,  6827,  6829,  6833,
   6841,  6857,  6863,  6869,  6871,  6883,  6899,  6907,  6911,  6917,
   6947,  6949,  6959,  6961,  6967,  6971,  6977,  6983,  6991,  6997,
   7001,  7013,  7019,  7027,  7039,  7043,  7057,  7069,  7079,  7103,
   7109,  7121,  7127,  7129,  7151,  7159,  7177,  7187,  7193,  7207,
   7211,  7213,  7219,  7229,  7237,  7243,  7247,  7253,  7283,  7297,
   7307,  7309,  7321,  7331,  7333,  7349,  7351,  7369,  7393,  7411,
   7417,  7433,  7451,  7457,  7459,  7477,  7481,  7487,  7489,  7499,
   7507,  7517,  7523,  7529,  7537,  7541,  7547,  7549,  7559,  7561,
   7573,  7577,  7583,  7589,  7591,  7603,  7607,  7621,  7639,  7643,
   7649,  7669,  7673,  7681,  7687,  7691,  7699,  7703,  7717,  7723,
   7727,  7741,  7753,  7757,  7759,  7789,  7793,  7817,  7823,  7829,
   7841,  7853,  7867,  7873,  7877,  7879,  7883,  7901,  7907,  7919
};


//
// Greatest Common Factor
// Example: 24=2.2.2.3 20=2.2.5 gcf(24,20)=4=2.2
//

int gcf(int a, int b) {
  int gcftot=1;
  int minab = min(a,b);
  int limit = (int) sqrt((float)minab);
  int pf;

  int i=0;
  pf = PrimeNumbers[i];
  do {
    if( (a % pf == 0) &&                 //does this prime number divide into
        (b % pf == 0) ) {                //what we have left?
      a /= pf;                           //remove this common factor
      b /= pf;
      gcftot *= pf;                      //remember this common factor
    } else {
      pf = PrimeNumbers[++i];            //start on the next prime number
    }
  } while ((i<1000) && (pf<=limit));

  return gcftot;
}


CCachedBitmap::CCachedBitmap(BOOL bRegression)
{
	strcpy(m_szName,"Image : CachedBitmap");
	m_bRegression=bRegression;
}

CCachedBitmap::~CCachedBitmap()
{
}

void CCachedBitmap::Draw(Graphics *g)
{
    Bitmap *image = new Bitmap(L"..\\Data\\winnt256.bmp");

    // Create a 32bpp premultiplied surface to composite drawing
    // so we can initialize the CachedBitmap.

    Bitmap *bmp = new Bitmap(
        (INT)(TESTAREAWIDTH/4), 
        (INT)(TESTAREAHEIGHT/4), 
        PixelFormat32bppPARGB
    );
    
    // Compute the size of the source image.

    Unit u;
    RectF s;
    image->GetBounds(&s, &u);
    
    // Size of the destination image (compositing buffer).

    RectF d(
        0, 0, 
        (INT)(TESTAREAWIDTH/4), 
        (INT)(TESTAREAHEIGHT/4)
    );

    PointF dp[3];
    dp[0].X = 0;
    dp[0].Y = d.Height/2;
    dp[1].X = d.Width/2;
    dp[1].Y = 0;
    dp[2].X = d.Width/2;
    dp[2].Y = d.Height;

    // Wrap a graphics around our compositing buffer image and set
    // the interpolation mode.

    Graphics *gbmp = new Graphics(bmp);
    gbmp->SetInterpolationMode(InterpolationModeHighQualityBicubic);

    // Initialize the bits in the compositing buffer.

    gbmp->DrawImage(
        image, 
        dp, 3, s.X, s.Y, 
        s.Width, s.Height,
        UnitPixel
    );

    // Initialize the CachedBitmap with the compositing buffer.

    CachedBitmap *cb = new CachedBitmap(bmp, g);
    
    delete gbmp;
    delete bmp;
    
    #define _2PI 2*3.141592653689
    

    // These are the a and b coefficients for the hypocycloid

    int a = 52;
    int b = 42;

    // Compute the center point for the cycle.

    float fXo=(TESTAREAWIDTH-d.Width)/2;
    float fYo=(TESTAREAHEIGHT-d.Height)/2;
    
    float ScaleX = fXo/( (a>b)?a:a+b );
    float ScaleY = fYo/( (a>b)?a:a+b );


    int cycle=b/gcf(a,b);    //number of times round the outer circle
    int Num = cycle*10;

    // Draw the bitmaps tracking the cycloid path.

    for(int i=0; i<Num; i++) {
      float t = (float)(cycle*_2PI*i/Num);
      g->DrawCachedBitmap(
          cb,
          (INT)(fXo+ScaleX*((a-b)*cos(t)+b*cos((a-b)*t/b))),
          (INT)(fYo+ScaleY*((a-b)*sin(t)-b*sin((a-b)*t/b)))
      );
    }

    #undef _2PI

    delete cb;
    delete image;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cbkgradient.cpp ===
/******************************Module*Header*******************************\
* Module Name: CBKGradient.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CBKGradient.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CBKGradient::CBKGradient(BOOL bRegression)
{
	strcpy(m_szName,"BKGradient");
	m_bRegression=bRegression;
}

CBKGradient::~CBKGradient()
{

}

void CBKGradient::Set(Graphics *g)
{
    Color color1b(255, 255, 0, 0);
    Color color2b(128, 0, 0, 255);
	RectF Rect;

	if (!m_bUseSetting)
		return;

	Rect.X=0.0f;
	Rect.Y=0.0f;
	Rect.Width=TESTAREAWIDTH;
	Rect.Height=TESTAREAHEIGHT;

	LinearGradientBrush LinearGrad(Rect, color1b, color2b,//color1b,color1b
                        LinearGradientModeForwardDiagonal);

	g->FillRectangle(&LinearGrad,Rect);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cchecker.h ===
/******************************Module*Header*******************************\
* Module Name: CChecker.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CCHECKER_H
#define __CCHECKER_H

#include "CSetting.h"

class CChecker : public CSetting  
{
public:
	CChecker(BOOL bRegression);
	virtual ~CChecker();

	BOOL Init();
	void Set(Graphics *g);

	Region *m_paRegion;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\ccompoundlines.h ===
/******************************Module*Header*******************************\
* Module Name: CCompoundLines.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CCOMPOUNDLINES_H
#define __CCOMPOUNDLINES_H

#include "CPrimitive.h"

class CCompoundLines : public CPrimitive  
{
public:
	CCompoundLines(BOOL bRegression);
	virtual ~CCompoundLines();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cchecker.cpp ===
/******************************Module*Header*******************************\
* Module Name: CChecker.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CChecker.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CChecker::CChecker(BOOL bRegression)
{
	strcpy(m_szName,"Checker");
	m_bRegression=bRegression;
	m_paRegion=NULL;
}

CChecker::~CChecker()
{
	if (m_paRegion!=NULL) {
		delete m_paRegion;
		m_paRegion=NULL;
	}
}

BOOL CChecker::Init()
{
    // Create clip region pattern
    m_paRegion=new Region();

	return CSetting::Init();
}

void CChecker::Set(Graphics *g)
{
	int cCheckerMax=0;
	int nCheckerSize=64;
	Matrix mat;

	g->ResetClip();
	if (!m_bUseSetting)
		return;

    m_paRegion->MakeInfinite();

    Rect horzRect(0, 0, (int)TESTAREAWIDTH, nCheckerSize);
    Rect vertRect(0, 0, nCheckerSize, (int)TESTAREAHEIGHT);
    Region *horzRegion = new Region(horzRect);
    Region *vertRegion = new Region(vertRect);

	if (TESTAREAWIDTH>TESTAREAHEIGHT)
		cCheckerMax=(int)TESTAREAWIDTH/nCheckerSize*2+1;
	else
		cCheckerMax=(int)TESTAREAHEIGHT/nCheckerSize*2+1;

    for (INT i = 0; i < 5; i++)
    {   
        m_paRegion->Xor(horzRegion);
        m_paRegion->Xor(vertRegion);
        horzRegion->Translate(0, nCheckerSize*2);
        vertRegion->Translate(nCheckerSize*2, 0);
    }
    delete horzRegion;
    delete vertRegion;

	g->SetClip(m_paRegion);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\ccontainer.cpp ===
/******************************Module*Header*******************************\
* Module Name: CContainer.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CContainer.h"

#define ROOT    0
#define LEFT    1
#define RIGHT   2
#define TOP     3
#define BOTTOM  4

CContainer::CContainer(BOOL bRegression)
{
	strcpy(m_szName,"Container");
	m_circlePath=NULL;
	m_circleRect.X=0;
	m_circleRect.Y=0;
	m_circleRect.Width=(int)(TESTAREAWIDTH/4.0f);
	m_circleRect.Height=(int)(TESTAREAHEIGHT/4.0f);
	m_bRegression=bRegression;
}

CContainer::~CContainer()
{
}

void CContainer::Draw(Graphics *g)
{
    m_circlePath = new GraphicsPath;
    m_circlePath->AddEllipse(m_circleRect);

    // !!! [agodfrey] Question: If I add the next line, why do I get no output?
    // m_circlePath->AddEllipse(m_circleRect);
    
    INT id = g->Save();
    g->TranslateTransform((int)(TESTAREAWIDTH/4.0f), (int)(TESTAREAHEIGHT/4.0f));
    DrawFractal(g, 245, ROOT, 8);
    g->Restore(id);
    delete m_circlePath;
}

void CContainer::DrawFractal(Graphics * g, BYTE gray, INT side, INT count)
{
    ARGB        argb;

    switch (count % 3)
    {
    case 0:
        argb = Color::MakeARGB(255, 0, 0, gray);
        break;
    case 1:
        argb = Color::MakeARGB(255, 0, gray, 0);
        break;
    case 2:
        argb = Color::MakeARGB(255, gray, 0, 0);
        gray -= 60;
        break;
    }
    Color   color(argb);
    SolidBrush contBrush(color);
    g->SetPageUnit(UnitPixel);
    g->FillPath(&contBrush, m_circlePath);
    
    if (--count == 0)
    {
        return;
    }

    Rect               destRect;
    GraphicsContainer  cstate;

    if (side != LEFT)
    {
        destRect = Rect((int)(TESTAREAWIDTH/4.0f), (int)(TESTAREAHEIGHT/16.0f), (int)(TESTAREAWIDTH/8.0f), (int)(TESTAREAHEIGHT/8.0f));
        cstate = g->BeginContainer(destRect, m_circleRect, UnitPixel);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, RIGHT, count);
        g->EndContainer(cstate);
    }
    if (side != TOP)
    {
        destRect = Rect((int)(TESTAREAWIDTH/16.0f), (int)(TESTAREAHEIGHT/4.0f), (int)(TESTAREAWIDTH/8.0f), (int)(TESTAREAHEIGHT/8.0f));
        cstate = g->BeginContainer(destRect, m_circleRect, UnitPixel);
        g->SetSmoothingMode(SmoothingModeNone);
        DrawFractal(g, gray, BOTTOM, count);
        g->EndContainer(cstate);
    }
    if (side != RIGHT)
    {
        destRect = Rect(-(int)(TESTAREAWIDTH/8.0f), (int)(TESTAREAHEIGHT/16.0f), (int)(TESTAREAWIDTH/8.0f), (int)(TESTAREAHEIGHT/8.0f));
        cstate = g->BeginContainer(destRect, m_circleRect, UnitPixel);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, LEFT, count);
        g->EndContainer(cstate);
    }
    if (side != BOTTOM)
    {
        destRect = Rect((int)(TESTAREAWIDTH/16.0f), -(int)(TESTAREAHEIGHT/8.0f), (int)(TESTAREAWIDTH/8.0f), (int)(TESTAREAHEIGHT/8.0f));
        cstate = g->BeginContainer(destRect, m_circleRect, UnitPixel);
        g->SetSmoothingMode(SmoothingModeNone);
        DrawFractal(g, gray, TOP, count);
        g->EndContainer(cstate);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\ccontainer.h ===
/******************************Module*Header*******************************\
* Module Name: CContainer.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CCONTAINER_H
#define __CCONTAINER_H

#include "CPrimitive.h"

class CContainer : public CPrimitive  
{
public:
	CContainer(BOOL bRegression);
	virtual ~CContainer();

	void Draw(Graphics *g);
	void DrawFractal(Graphics * g, BYTE gray, INT side, INT count);

	GraphicsPath *m_circlePath;
	Rect m_circleRect;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\ccompoundlines.cpp ===
/******************************Module*Header*******************************\
* Module Name: CCompoundLines.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CCompoundLines.h"

CCompoundLines::CCompoundLines(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Compound");
	m_bRegression=bRegression;
}

CCompoundLines::~CCompoundLines()
{
}

void CCompoundLines::Draw(Graphics *g)
{
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100.0f/280.0f*TESTAREAWIDTH;
    points[0].Y = 50.0f/280.0f*TESTAREAHEIGHT;
    points[1].X = -50.0f/280.0f*TESTAREAWIDTH;
    points[1].Y = 190.0f/280.0f*TESTAREAHEIGHT;
    points[2].X = 150.0f/280.0f*TESTAREAWIDTH;
    points[2].Y = 320.0f/280.0f*TESTAREAHEIGHT;
    points[3].X = 200.0f/280.0f*TESTAREAWIDTH;
    points[3].Y = 110.0f/280.0f*TESTAREAHEIGHT;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);

    points[0].X = 260.0f/280.0f*TESTAREAWIDTH;
    points[0].Y = 20.0f/280.0f*TESTAREAHEIGHT;
    path->AddLines(points, 1);
    Matrix matrix;
//    matrix.Scale(1.25, 1.25);
//    matrix.Translate(30.0f/1024.0f*TESTAREAWIDTH, 30.0f/768.0f*TESTAREAHEIGHT);

    // If you wanto to flatten the path before rendering,
    // Flatten() can be called.

    BOOL flattenFirst = FALSE;

    if(!flattenFirst)
    {
        // Don't flatten and keep the original path.
        // FillPath or DrawPath will flatten the path automatically
        // without modifying the original path.

        path->Transform(&matrix);
    }
    else
    {
        // Flatten this path.  The resultant path is made of line
        // segments.  The original path information is lost.

        path->Flatten(&matrix);
    }

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    width = 3;
    Pen blackPen(&blackBrush, width);

    REAL* compoundArray = new REAL[6];
    compoundArray[0] = 0.0f;
    compoundArray[1] = 0.2f;
    compoundArray[2] = 0.4f;
    compoundArray[3] = 0.6f;
    compoundArray[4] = 0.8f;
    compoundArray[5] = 1.0f;
    blackPen.SetCompoundArray(&compoundArray[0], 6);
    blackPen.SetDashStyle(DashStyleDash);

    blackPen.SetStartCap(LineCapDiamondAnchor);    
    blackPen.SetEndCap(LineCapArrowAnchor);

    g->FillPath(&yellowBrush, path);
    g->DrawPath(&blackPen, path);
    delete path;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\ccontainerclip.h ===
/******************************Module*Header*******************************\
* Module Name: CContainerClip.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CCONTAINERCLIP_H
#define __CCONTAINERCLIP_H

#include "CPrimitive.h"

class CContainerClip : public CPrimitive  
{
public:
	CContainerClip(BOOL bRegression);
	virtual ~CContainerClip();

	void Draw(Graphics *g);

	void DrawContainer(Graphics * g, ARGB * argb, INT count);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\ccontainerclip.cpp ===
/******************************Module*Header*******************************\
* Module Name: CContainerClip.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CContainerClip.h"

CContainerClip::CContainerClip(BOOL bRegression)
{
	strcpy(m_szName,"ContainerClip");
	m_bRegression=bRegression;
}

CContainerClip::~CContainerClip()
{
}

void CContainerClip::Draw(Graphics *g)
{
    ARGB     colors[5];
    
    colors[0] = Color::MakeARGB(255, 255, 0, 0);
    colors[1] = Color::MakeARGB(255, 0, 255, 0);
    colors[2] = Color::MakeARGB(255, 0, 0, 255);
    colors[3] = Color::MakeARGB(255, 255, 255, 0);
    colors[4] = Color::MakeARGB(255, 0, 255, 255);

    GraphicsState s = g->Save();
    DrawContainer(g, colors, 5);
    g->Restore(s);
}

VOID CContainerClip::DrawContainer(Graphics * g, ARGB * argb, INT count)
{
    Matrix    mymatrix;
	int nX;
	int nY;

    g->SetPageUnit(UnitPixel);

	g->GetTransform(&mymatrix);
	nX=(int)mymatrix.OffsetX();
	nY=(int)mymatrix.OffsetY();

    Rect clipRect(0,0,(int)TESTAREAWIDTH, (int)TESTAREAHEIGHT);
    g->SetClip(clipRect);

    mymatrix.Translate((int)(TESTAREAWIDTH/2.0f), (int)(TESTAREAHEIGHT/2.0f));
    mymatrix.Rotate(15);
    mymatrix.Translate(-(int)(TESTAREAWIDTH/2.0f), -(int)(TESTAREAHEIGHT/2.0f));
    g->SetTransform(&mymatrix);

    Color   color(*argb++); 
    SolidBrush contBrush(color);
    g->FillRectangle(&contBrush, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT);
    if (--count == 0)
    {
        return;
    }
    RectF     destRect((int)(TESTAREAWIDTH/10.0f), (int)(TESTAREAHEIGHT/10.0f), (int)(TESTAREAWIDTH/1.25f), (int)(TESTAREAHEIGHT/1.25f));
    RectF     srcRect(0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT);
    INT id = g->BeginContainer(destRect, srcRect, UnitPixel);
    g->ResetClip();
    DrawContainer (g, argb, count);
    g->EndContainer(id);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cdash.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   <an unabbreviated name for the module (not the filename)>
*
* Abstract:
*
*   <Description of what this module does>
*
* Notes:
*
*   <optional>
*
* Created:
*
*   08/28/2000 asecchia
*      Created it.
*
**************************************************************************/

/**************************************************************************
*
* Function Description:
*
*   <Description of what the function does>
*
* Arguments:
*
*   [<blank> | OUT | IN/OUT] argument-name - description of argument
*   ......
*
* Return Value:
*
*   return-value - description of return value
*   or NONE
*
* Created:
*
*   08/28/2000 asecchia
*      Created it.
*
**************************************************************************/
#include "CDash.hpp"
#include <limits.h>
CDash::CDash(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Dash Offset");
	m_bRegression=bRegression;
}

void CDash::Draw(Graphics *g)
{
   RectF d(
        0, 
        0, 
        (INT)(TESTAREAWIDTH), 
        (INT)(TESTAREAHEIGHT)
    );

    Pen pen(Color(0xff7f7fff), 10.0f);
    Pen thinPen(Color(0xff000000), 0.0f);

    float dashArray[4] = {
        2.0f, 3.0f
    };

    pen.SetDashPattern(dashArray, 2);

    GraphicsPath *gp;
    
    pen.SetEndCap(LineCapRoundAnchor);
    
    GraphicsPath fez(FillModeWinding);
    fez.AddLine(0, 0, -2, -2);
    fez.AddLine(-2, -2, 2, -2);
    fez.AddLine(2, -2, 0, 0);
    fez.CloseFigure();
    
    CustomLineCap cap(&fez, NULL);
    Status status = cap.GetLastStatus();
    cap.SetBaseInset(1.0f);
    
    pen.SetCustomStartCap(&cap);

    INT i;
    for(i=0;i<20; i++)
    {
        pen.SetDashOffset((float)(i)/4.0f);
        gp = new GraphicsPath();
        gp->AddLine(0, 20+i*11, 199, 20+i*11);    
        
        g->DrawPath(&pen, gp);
        
        gp->Widen(&pen, NULL, FALSE);
        
        g->DrawPath(&thinPen, gp);
        delete gp;
    }
}


CDash2::CDash2(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Dash Cap Round");
	m_bRegression=bRegression;
}

void CDash2::Draw(Graphics *g)
{
    Pen pen(Color(0xff000000), 20.0f);

    pen.SetDashStyle(DashStyleDot);
    pen.SetDashCap(DashCapRound);

    GraphicsPath gp;    
    
    gp.AddBezier(20,10, 30, 10, 120, 100, 70, 150); 
    
    g->DrawPath(&pen, &gp);
}

CDash3::CDash3(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Dash, Caps");
	m_bRegression=bRegression;
}

void CDash3::Draw(Graphics *g)
{
   RectF d(
        0, 
        0, 
        (INT)(TESTAREAWIDTH), 
        (INT)(TESTAREAHEIGHT)
    );

    Pen pen(Color(0xff0000ff), 12.0f);

    float dashArray[4] = {
        3.0f, 3.0f
    };

    pen.SetDashPattern(dashArray, 2);

    LineCap CapArray[9] = {
        LineCapFlat         ,
        LineCapSquare       ,
        LineCapRound        ,
        LineCapTriangle     ,
        LineCapNoAnchor     ,
        LineCapSquareAnchor ,
        LineCapRoundAnchor  ,
        LineCapDiamondAnchor,
        LineCapArrowAnchor  
    };
    
    DashCap DashCapArray[3] = {
        DashCapFlat         ,
        DashCapRound        ,
        DashCapTriangle
    };
    
    Color Rainbow[8] = {
        Color(0xff000000),  //infra-dead? ultra-violent?
        Color(0xffff0000),  //red
        Color(0xffff7f00),  //orange
        Color(0xffffff00),  //yellow
        Color(0xff00ff00),  //green
        Color(0xff0000ff),  //blue
        Color(0xff7f00ff),  //indigo?
        Color(0xffff00ff)   //violet?
    };
    
    GraphicsPath *gp;
    
    INT i;
    for(i=0;i<20; i++)
    {
        pen.SetDashOffset((float)(i)/4.0f);
        pen.SetDashCap(DashCapArray[i%3]);
        pen.SetColor(Rainbow[i%8]);
        gp = new GraphicsPath();
        gp->AddLine(20, 20+i*20, 210, 20+(i+1)*20);    
        g->DrawPath(&pen, gp);
        delete gp;
    }
}

CDash4::CDash4(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Dash, Clone Pen");
	m_bRegression=bRegression;
}


void CDash4::Draw(Graphics *g)
{
    Pen pen(Color(0xff000000), 20.0f);

    pen.SetDashStyle(DashStyleDot);
    pen.SetDashCap(DashCapRound);
    pen.SetStartCap(LineCapRound);
    pen.SetEndCap(LineCapArrowAnchor);
    
    Pen *cpen = pen.Clone();
    
    GraphicsPath gp1;    
    GraphicsPath gp2;    
    
    gp1.AddBezier(20,30, 30, 30, 120, 130, 70, 180); 
    g->DrawPath(&pen, &gp1);
    
    gp2.AddBezier(60,30, 70, 30, 160, 130, 110, 180); 
    g->DrawPath(cpen, &gp2);
    
    delete cpen;
}

CDash5::CDash5(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Linear Gradient Pen");
	m_bRegression=bRegression;
}


void CDash5::Draw(Graphics *g)
{
    Color presetColors[10];
    REAL positions[10];
    INT count;
    count = 3;
    positions[0] = (REAL) 0;
    positions[1] = (REAL) 0.4;
    positions[2] = (REAL) 1;
    RectF lineRect(50, 50, 100, 100);
    RectF lineRect1(10, 10, 200, 200);
    Color color1(0xff00ff00);
    Color color2(0xff00ffff);

    LinearGradientBrush lineGrad(
        lineRect, 
        color1, 
        color2,
        LinearGradientModeVertical
    );

    // Test for preset colors

    presetColors[0] = Color(0xffff0000);
    presetColors[1] = Color(0xffffff00);
    presetColors[2] = Color(0xff0000ff);
    lineGrad.SetInterpolationColors(&presetColors[0], &positions[0], count);
    lineGrad.SetWrapMode(WrapModeTileFlipXY);

    g->FillRectangle(&lineGrad, lineRect);

    Pen gradpen(&lineGrad, 45);
    g->DrawRectangle(&gradpen, lineRect1);
}


CDash6::CDash6(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Caps");
	m_bRegression=bRegression;
}

void CDash6::Draw(Graphics *g)
{
   RectF d(
        0, 
        0, 
        (INT)(TESTAREAWIDTH), 
        (INT)(TESTAREAHEIGHT)
    );

    Pen pen(Color(0x7f7f7fff), 15.0f);

    float dashArray[4] = {
        3.0f, 1.0f
    };

    pen.SetDashPattern(dashArray, 2);
    pen.SetDashCap(DashCapRound);
    
    float carray[4] = { 0.0f, 0.3f, 0.5f, 1.0f };
    pen.SetCompoundArray(carray, 4);

    pen.SetEndCap(LineCapRoundAnchor);
    
    GraphicsPath someCap(FillModeWinding);
    someCap.AddLine(0, 0, -2, -2);
    someCap.AddLine(-2, -2, 2, -2);
    someCap.AddLine(2, -2, 0, 0);
    someCap.CloseFigure();
    
    CustomLineCap cap(&someCap, NULL);
    cap.SetBaseInset(1.0f);
    
    pen.SetCustomStartCap(&cap);

    Point points[6];
    points[0].X = 100;
    points[0].Y = 100;
    points[1].X = 15;
    points[1].Y = 100;
    points[2].X = 15;
    points[2].Y = 15;
    points[3].X = 200;
    points[3].Y = 15;
    points[4].X = 200;
    points[4].Y = 100;
    points[5].X = 100;
    points[5].Y = 150;
    
    GraphicsPath gp;
    gp.AddLines(points, 6);    
    
    g->DrawPath(&pen, &gp);
    
    for(int i=0; i<6; i++) { points[i].Y += 30; points[i].X += 15; }
    
    pen.SetEndCap(LineCapArrowAnchor);
    pen.SetStartCap(LineCapDiamondAnchor);
    pen.SetColor(Color(0x7fff7f7f));
    
    GraphicsPath gp1;
    gp1.AddLines(points, 6);
    
    gp1.StartFigure();
    gp1.AddLine(100, 200, 115, 202);
    
    g->DrawPath(&pen, &gp1);

    pen.SetStartCap(LineCapArrowAnchor);
    
    pen.SetColor(Color(0x7f7fff7f));
    GraphicsPath gp2;
    gp2.AddLine(100, 100, 115, 102);
    g->DrawPath(&pen, &gp2);

    // inset stroke capped line
    GraphicsPath cappath;
    PointF cappnts[] = {PointF(2.0f,-2.0f), PointF(0,0), PointF(-2.0f,-2.0f)};
    cappath.AddLines(cappnts, 3);
    CustomLineCap strokecap(NULL,&cappath);
    strokecap.SetStrokeCaps(LineCapRound, LineCapTriangle);
    Pen leftPen(Color(180,255,128,0), 13.0f);
    leftPen.SetAlignment(PenAlignmentInset);
    leftPen.SetCustomEndCap(&strokecap);
    leftPen.SetCustomStartCap(&strokecap);
    GraphicsPath gp3;
    gp3.AddBezier(35,241, 10,150, 110,160, 140,220);
    g->DrawPath(&leftPen, &gp3);
    
}


CDash7::CDash7(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Clipping");
	m_bRegression=bRegression;
}

void CDash7::Draw(Graphics *g)
{
    PointF points[8];
    
    points[0].X = -64.0f+304.0f;
    points[0].Y = -45.0f+206.0f;
    points[1].X = -64.0f+242.669f;
    points[1].Y = -45.0f+192.624f;
    points[2].X = -64.0f+229.5f;
    points[2].Y = -45.0f+128.0f;
    points[3].X = -64.0f+216.331f;
    points[3].Y = -45.0f+192.624f;
    points[4].X = -64.0f+155.05f;
    points[4].Y = -45.0f+206.5f;
    points[5].X = -64.0f+216.331f;
    points[5].Y = -45.0f+220.376f;
    points[6].X = -64.0f+229.5f;
    points[6].Y = -45.0f+285.0f;
    points[7].X = -64.0f+242.669f;
    points[7].Y = -45.0f+220.376f;
    
    Pen pen(Color(0xff000000), 0.0f);
    Pen fatpen(Color(0xff0000ff), 20.0f);
    
    GraphicsPath gp;
    gp.AddPolygon(points, 8);
    
    RectF bounds;
    gp.GetBounds(&bounds, NULL, &fatpen); 
    
    g->DrawPath(&fatpen, &gp);
    g->DrawPath(&pen, &gp);
    
    g->DrawRectangle(&pen, bounds);

    points[0].X = 304.0f;
    points[0].Y = 206.0f;
    points[1].X = 242.669f;
    points[1].Y = 192.624f;
    points[2].X = 229.5f;
    points[2].Y = 128.0f;
    points[3].X = 216.331f;
    points[3].Y = 192.624f;
    points[4].X = 155.05f;
    points[4].Y = 206.5f;
    points[5].X = 216.331f;
    points[5].Y = 220.376f;
    points[6].X = 229.5f;
    points[6].Y = 285.0f;
    points[7].X = 242.669f;
    points[7].Y = 220.376f;
    
    GraphicsPath gp1;
    gp1.AddPolygon(points, 8);
    
    g->DrawPath(&pen, &gp1);
}    


CDash8::CDash8(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Unit Sizes");
	m_bRegression=bRegression;
}

void CDash8::Draw(Graphics *g)
{
/*
    UnitWorld,      // 0 -- World coordinate (non-physical unit)
    UnitDisplay,    // 1 -- Variable -- for PageTransform only
    UnitPixel,      // 2 -- Each unit is one device pixel.
    UnitPoint,      // 3 -- Each unit is a printer's point, or 1/72 inch.
    UnitInch,       // 4 -- Each unit is 1 inch.
    UnitDocument,   // 5 -- Each unit is 1/300 inch.
    UnitMillimeter  // 6 -- Each unit is 1 millimeter.
*/

    Pen pen(Color(0x3f0000ff), 0.0f);
    pen.SetStartCap(LineCapArrowAnchor);
    pen.SetDashStyle(DashStyleDot);
    pen.SetDashCap(DashCapRound);
    
    Unit unit = g->GetPageUnit();
    Matrix transform;
    REAL elements[6];
    g->GetTransform(&transform);
  
    pen.SetColor(0xff0000ff);
    pen.SetWidth(0.0f);
    g->DrawLine(&pen, 20, 40, 200, 20);
    pen.SetColor(0x3f0000ff);
    pen.SetWidth(19.2f);
    g->DrawLine(&pen, 20, 20, 200, 75);

    g->ResetTransform();
    g->SetPageUnit(UnitInch);  
    transform.GetElements(elements);    
    Matrix inch;
    elements[4] *= 1.0f/96.0f;
    elements[5] *= 1.0f/96.0f;
    inch.SetElements(
        elements[0],
        elements[1],
        elements[2],
        elements[3],
        elements[4],
        elements[5]
    );
    g->SetTransform(&inch);
    
    pen.SetColor(Color(0xffff0000));
    pen.SetWidth(0.0f);
    g->DrawLine(&pen, 0.0f, 2.5f, 2.0f, 0.1f);
    pen.SetColor(Color(0x3fff0000));
    pen.SetWidth(0.2f);
    g->DrawLine(&pen, 0.0f, 0.1f, 2.0f, 2.5f);

    
    g->ResetTransform();
    g->SetPageUnit(UnitMillimeter);  
    
    transform.GetElements(elements);    
    Matrix millimeter;
    elements[4] *= 0.26458333f;
    elements[5] *= 0.26458333f;
    millimeter.SetElements(
        elements[0],
        elements[1],
        elements[2],
        elements[3],
        elements[4],
        elements[5]
    );
    g->SetTransform(&millimeter);
    
    pen.SetColor(Color(0xff00ff00));
    pen.SetWidth(0.0f);
    g->DrawLine(&pen, 0, 55, 55, 10);
    pen.SetColor(Color(0x3f00ff00));
    pen.SetWidth(5.08f);
    g->DrawLine(&pen, 0, 10, 55, 55);
    
    
    g->SetPageUnit(unit);
    g->SetTransform(&transform);
}    



CDash9::CDash9(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Dash, multiple subpaths");
	m_bRegression=bRegression;
}

void CDash9::Draw(Graphics *g)
{
    GraphicsPath gp;
    
    for(int i=0; i<10; i++)
    {
        gp.AddLine(50+i*10, 50, 50+i*10, 200);
        gp.StartFigure();
    }
    
    Pen pen(Color(0xff000000), 3.0f);
    
    float dash[] = {8.0f, 4.0f};
    pen.SetDashPattern(dash, 2);
    pen.SetDashCap(DashCapRound);
    
    g->DrawPath(&pen, &gp);
}



extern int gcf(int a, int b);

PointF *ComputeHypocycloid(
    INT a,      // These are the a and b coefficients for the hypocycloid
    INT b,
    float r,    // pen radius
    RectF rect,
    INT size,
    INT *count  // out parameter
)
{
    #define _2PI 2*3.141592653689
    
    // Compute the center point for the cycle.

    float fXo = rect.X + rect.Width/2.0f;
    float fYo = rect.Y + rect.Height/2.0f;
    
    float ScaleX = 0.5f*rect.Width/( (a>b)?a:a+b );
    float ScaleY = 0.5f*rect.Height/( (a>b)?a:a+b );


    int cycle=b/gcf(a,b);    //number of times round the outer circle
    *count = cycle*size;

    PointF *points = new PointF[*count];
    
    // ... tracking the cycloid path.

    for(int i=0; i<*count; i++) {
      
      float t = (float)(cycle*_2PI*i/(*count));  // parametric parameter...
      
      points[i].X = (float)(fXo+ScaleX*((a-b)*cos(t)+r*cos((a-b)*t/b)));
      points[i].Y = (float)(fYo+ScaleY*((a-b)*sin(t)-r*sin((a-b)*t/b)));
    }

    #undef _2PI
    return points;
}


CWiden::CWiden(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Widen");
	m_bRegression=bRegression;
}

void CWiden::Draw(Graphics *g)
{
    PointF starpoints[5];
    REAL s, c, theta;
    PointF orig((int)(TESTAREAWIDTH/2.0f), (int)(TESTAREAHEIGHT/2.0f));

    theta = (float)-M_PI/2;

    // Create a star shape.
    for(INT i = 0; i < 5; i++)
    {
        s = sinf(theta);
        c = cosf(theta);
        starpoints[i].X = (int)(80.0f/250.0f*TESTAREAWIDTH)*c + orig.X;
        starpoints[i].Y = (int)(80.0f/250.0f*TESTAREAHEIGHT)*s + orig.Y;
        theta += (float)(0.8f*M_PI);
    }
    SolidBrush starbrush(Color(0x3fff00ff));
    Pen penwide(Color(0x7f0000ff), 20.0f);
    Pen linepen(Color(0xff000000), 0.0f);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    
    path->AddPolygon(starpoints, 5);
    path->Widen(&penwide);
    g->FillPath(&starbrush, path);
    g->DrawPath(&linepen, path);

    delete path;
    
    
    
    float marginX = 20;
    float marginY = 20;
    INT count;
    PointF *points = ComputeHypocycloid(
        52, 12, 7.0f, 
        RectF(
            marginX, marginY, 
            TESTAREAWIDTH-2.0f*marginX, 
            TESTAREAHEIGHT-2.0f*marginY
        ),
        50,
        &count
    );
    
    GraphicsPath gp;
    gp.AddPolygon(points, count);
    Pen pen(Color(0xff000000), 12.0f);
    gp.Widen(&pen);
    SolidBrush brush(Color(0x3f0000ff));
    g->FillPath(&brush, &gp);
    Pen thinPen(Color(0xff000000), 0.0f);
    g->DrawPath(&thinPen, &gp);
}    

CWidenO::CWidenO(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Widen, Outline");
	m_bRegression=bRegression;
}

void CWidenO::Draw(Graphics *g)
{
    PointF starpoints[5];
    REAL s, c, theta;
    PointF orig((int)(TESTAREAWIDTH/2.0f), (int)(TESTAREAHEIGHT/2.0f));

    theta = (float)-M_PI/2;

    // Create a star shape.
    for(INT i = 0; i < 5; i++)
    {
        s = sinf(theta);
        c = cosf(theta);
        starpoints[i].X = (int)(80.0f/250.0f*TESTAREAWIDTH)*c + orig.X;
        starpoints[i].Y = (int)(80.0f/250.0f*TESTAREAHEIGHT)*s + orig.Y;
        theta += (float)(0.8f*M_PI);
    }
    SolidBrush starbrush(Color(0x7f7f00ff));
    Pen penwide(Color(0x7f000000), 20.0f);
    Pen linepen(Color(0xff000000), 0.0f);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    
    path->AddPolygon(starpoints, 5);
    path->Widen(&penwide);
    path->Outline();
    g->FillPath(&starbrush, path);
    g->DrawPath(&linepen, path);

    delete path;


    float marginX = 20;
    float marginY = 20;
    INT count;
    PointF *points = ComputeHypocycloid(
        52, 12, 7.0f, 
        RectF(
            marginX, marginY, 
            TESTAREAWIDTH-2.0f*marginX, 
            TESTAREAHEIGHT-2.0f*marginY
        ),
        50,
        &count
    );
    
    GraphicsPath gp;
    gp.AddPolygon(points, count);
    Pen pen(Color(0xff000000), 12.0f);
    Pen strokePen(Color(0xff0000ff), 0.0f);
    g->DrawPath(&strokePen, &gp);
    gp.Widen(&pen);
    gp.Outline();
    SolidBrush brush(Color(0x3f0000ff));
    g->FillPath(&brush, &gp);
    Pen thinPen(Color(0xff000000), 0.0f);
    g->DrawPath(&thinPen, &gp);
}    

CWidenOO::CWidenOO(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Widen, Outline twice");
	m_bRegression=bRegression;
}

void CWidenOO::Draw(Graphics *g)
{
    PointF starpoints[5];
    REAL s, c, theta;
    PointF orig((int)(TESTAREAWIDTH/2.0f), (int)(TESTAREAHEIGHT/2.0f));

    theta = (float)-M_PI/2;

    // Create a star shape.
    for(INT i = 0; i < 5; i++)
    {
        s = sinf(theta);
        c = cosf(theta);
        starpoints[i].X = (int)(80.0f/250.0f*TESTAREAWIDTH)*c + orig.X;
        starpoints[i].Y = (int)(80.0f/250.0f*TESTAREAHEIGHT)*s + orig.Y;
        theta += (float)(0.8f*M_PI);
    }
    SolidBrush starbrush(Color(0x3f7f00ff));
    Pen penwide(Color(0x7f000000), 20.0f);
    Pen linepen(Color(0xff000000), 0.0f);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    
    path->AddPolygon(starpoints, 5);
    path->Outline();
    path->Widen(&penwide);
    path->Outline();
    g->FillPath(&starbrush, path);
    g->DrawPath(&linepen, path);

    delete path;
    
    
    float marginX = 20;
    float marginY = 20;
    INT count;
    PointF *points = ComputeHypocycloid(
        52, 12, 7.0f, 
        RectF(
            marginX, marginY, 
            TESTAREAWIDTH-2.0f*marginX, 
            TESTAREAHEIGHT-2.0f*marginY
        ),
        50,
        &count
    );
    
    GraphicsPath gp;
    gp.AddPolygon(points, count);
    Pen pen(Color(0xff000000), 12.0f);
    gp.Outline();
    gp.Widen(&pen);
    gp.Outline();
    SolidBrush brush(Color(0x3f0000ff));
    g->FillPath(&brush, &gp);
    Pen thinPen(Color(0xff000000), 0.0f);
    g->DrawPath(&thinPen, &gp);
}    


CFlatten::CFlatten(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Flatten Limits");
	m_bRegression=bRegression;
}

void CFlatten::Draw(Graphics *g)
{
    LinearGradientBrush lbrush(
        PointF(0.0f, 0.0f),
        PointF(0.0f, TESTAREAHEIGHT),
        Color(0xff0000ff),
        Color(0xff00ff00)
    );
    
    lbrush.SetGammaCorrection(FALSE);

    // Bad flatness.
    
    GraphicsPath gp;
    gp.AddEllipse(20.0f, 40.0f, TESTAREAWIDTH-40.0f, TESTAREAHEIGHT-80.0f);
    gp.Flatten(NULL, 6.0f);
    
    Pen blackPen(Color(0xff000000), 0.0f);
    
    Pen linePen(&lbrush, 25.0f);
    g->DrawPath(&linePen, &gp);
    
    // Good flatness.
    
    gp.Reset();
    gp.AddEllipse(20.0f, 40.0f, TESTAREAWIDTH-40.0f, TESTAREAHEIGHT-80.0f);
    gp.Flatten(NULL, 0.25f);
    
    Pen redPen(Color(0x7fff0000), 5.0f);
    g->DrawPath(&redPen, &gp);
    gp.Widen(&redPen);
    g->DrawPath(&blackPen, &gp);
    
    
    // Add a curve with a bazillion points to see what an ideal flattened curve
    // should look like at our device flattening default.
    
    float marginX = 30;
    float marginY = 50;
    INT count;
    PointF *points = ComputeHypocycloid(
        52, 24, 20.0f, 
        RectF(
            marginX, marginY, 
            TESTAREAWIDTH-2.0f*marginX, 
            TESTAREAHEIGHT-2.0f*marginY
        ),
        100,
        &count
    );
    
    LinearGradientBrush lbrush2(
        PointF(0.0f, 0.0f),
        PointF(0.0f, TESTAREAHEIGHT),
        Color(0xffffff00),
        Color(0xffff002f)
    );
    
    lbrush2.SetGammaCorrection(FALSE);
    
    gp.Reset();
    gp.AddClosedCurve(points, count);
    Pen lpen(&lbrush2, 2.0f);
    g->DrawPath(&lpen, &gp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cdash.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   <an unabbreviated name for the module (not the filename)>
*
* Abstract:
*
*   <Description of what this module does>
*
* Notes:
*
*   <optional>
*
* Created:
*
*   08/28/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _CDASH_HPP
#define _CDASH_HPP


#include "CPrimitive.h"

class CDash : public CPrimitive
{
public:
	CDash(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash2 : public CPrimitive
{
public:
	CDash2(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash3 : public CPrimitive
{
public:
	CDash3(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash4 : public CPrimitive
{
public:
	CDash4(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash5 : public CPrimitive
{
public:
	CDash5(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash6 : public CPrimitive
{
public:
	CDash6(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash7 : public CPrimitive
{
public:
	CDash7(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash8 : public CPrimitive
{
public:
	CDash8(BOOL bRegression);
	void Draw(Graphics *g);
};

class CDash9 : public CPrimitive
{
public:
	CDash9(BOOL bRegression);
	void Draw(Graphics *g);
};

class CWiden : public CPrimitive
{
public:
	CWiden(BOOL bRegression);
	void Draw(Graphics *g);
};

class CWidenO : public CPrimitive
{
public:
	CWidenO(BOOL bRegression);
	void Draw(Graphics *g);
};

class CWidenOO : public CPrimitive
{
public:
	CWidenOO(BOOL bRegression);
	void Draw(Graphics *g);
};

class CFlatten : public CPrimitive
{
public:
	CFlatten(BOOL bRegression);
	void Draw(Graphics *g);
};



#define DASH_GLOBALS \
CWiden g_Widen(true);\
CWidenO g_WidenO(true);\
CWidenOO g_WidenOO(true);\
CFlatten g_Flatten(true);\
CDash g_Dash(true);\
CDash2 g_Dash2(true);\
CDash3 g_Dash3(true);\
CDash4 g_Dash4(true);\
CDash5 g_Dash5(true);\
CDash6 g_Dash6(true);\
CDash7 g_Dash7(true);\
CDash8 g_Dash8(true);\
CDash9 g_Dash9(true);

#define DASH_INIT \
g_Widen.Init();\
g_WidenO.Init();\
g_WidenOO.Init();\
g_Flatten.Init();\
g_Dash.Init();\
g_Dash2.Init();\
g_Dash3.Init();\
g_Dash4.Init();\
g_Dash5.Init();\
g_Dash6.Init();\
g_Dash7.Init();\
g_Dash8.Init();\
g_Dash9.Init();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cdashes.cpp ===
/******************************Module*Header*******************************\
* Module Name: CDashes.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CDashes.h"

CDashes::CDashes(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Dash, Misc");
	m_bRegression=bRegression;
}

CDashes::~CDashes()
{
}

void CDashes::Draw(Graphics *g)
{
/*
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    path->Transform(&matrix);

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    
    // Set the pen width in inch.
    width = (REAL) 0.2;
    Pen pen1(&blackBrush, width, UnitInch);
    pen1.SetDashStyle(DashStyleDashDotDot);
    pen1.SetDashCap(LineCapRound);
    g->DrawPath(&pen1, path);

    // Create a multiple segment with a closed segment.
    points[0].X = 50;
    points[0].Y = 50;
    points[1].X = 100;
    points[1].Y = 50;
    points[2].X = 120;
    points[2].Y = 120;
    points[3].X = 50;
    points[3].Y = 100;    

    path->Reset();
    path->AddLines(points, 4);
    path->CloseFigure();

    points[0].X = 150;
    points[0].Y = 60;
    points[1].X = 200;
    points[1].Y = 150;
    path->AddLines(points, 2);
    path->Transform(&matrix);

    Color blueColor(128, 0, 0, 255);

    SolidBrush blueBrush(blueColor);

    width = 5;
    Pen pen2(&blueBrush, width);
    pen2.SetDashStyle(DashStyleDashDotDot);
    g->DrawPath(&pen2, path);

    delete path;
*/
    float factor = 100.0f/g->GetDpiX(); //g->GetDpiX()/100.0f;
  
    // Test GDI punting on pen drawing.
    Color col0(0xff,0x80,0x80,0x80);
    Color col1(0xff,0x80,0,0);
    Color col2(0xff,0,0x80,0);
    Color col3(0xff,0,0,0x80);

    Pen pen0a(col0, factor*1.0f);   // Basic PS_COSMETIC, solid pen
    Pen pen0b(col0, 2.0f);   // Basic PS_GEOMETRIC, solid pen

    // PS_COSMETIC with LINE CAP + MITER JOIN + DASH STYLE
    Pen pen1a(col1, factor*1.0f);
    pen1a.SetLineCap(LineCapFlat, LineCapFlat, DashCapFlat);
    pen1a.SetLineJoin(LineJoinMiter); 
    pen1a.SetMiterLimit(4.0f);
    pen1a.SetDashStyle(DashStyleDot);
    
    // PS_GEOMETRIC with LINE CAP + MITER JOIN + DASH STYLE
    Pen pen1b(col1, 2.0f);
    pen1b.SetLineCap(LineCapRound, LineCapRound, DashCapRound);
    pen1b.SetLineJoin(LineJoinMiter);
    pen1b.SetMiterLimit(4.0f);
    pen1b.SetDashStyle(DashStyleDashDotDot);

    // PS_COSMETIC + LINE CAP + BEVEL JOIN + DASH STYLE
    Pen pen2a(col2, factor*1.0f);
    pen2a.SetLineCap(LineCapArrowAnchor, LineCapArrowAnchor, DashCapFlat);
    pen2a.SetLineJoin(LineJoinBevel);
    pen2a.SetDashStyle(DashStyleDash);

    // PS_GEOMETRIC + LINE CAP + BEVEL JOIN + DASH STYLE
    Pen pen2b(col2, 2.0f);
    pen2b.SetLineCap(LineCapSquare, LineCapSquare, DashCapFlat);
    pen2b.SetLineJoin(LineJoinRound);
//    pen2b.SetDashStyle(DashStyleDot);
    pen2b.SetDashStyle(DashStyleDashDot);

    // PS_GEOMETRIC + SOLID LINE + FLAT CAP + BEVEL JOIN
    Pen pen3(col1, 2.0f);
    pen3.SetLineCap(LineCapFlat, LineCapFlat, DashCapFlat);
    pen3.SetLineJoin(LineJoinBevel);

    // PS_GEOMETRIC + SOLID LINE + SQUARE CAP + MITER JOIN (LIMIT 10 - NON RECTANGLE)
    Pen pen3b(col1, 2.0f);
    pen3b.SetLineCap(LineCapSquare, LineCapSquare, DashCapFlat);
    pen3b.SetLineJoin(LineJoinMiter);
    pen3b.SetMiterLimit(4.4f);

    // PS_GEOMETRIC + SOLID LINE + ROUND CAP + MITER JOIN (NON RECTANGLE)
    Pen pen3c(col1, 2.0f);
    pen3c.SetLineCap(LineCapRound, LineCapRound, DashCapRound);
    pen3c.SetLineJoin(LineJoinMiter);
    pen3c.SetMiterLimit(0.75f);

    g->SetPageScale(1.0f);

//    Matrix m;
//    m.Reset();
//    g->SetTransform(&m);

    g->DrawRectangle(&pen0a, (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT), (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT));
    g->DrawRectangle(&pen0b, (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(250.0f/600.0f*TESTAREAHEIGHT), (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT));
    g->DrawRectangle(&pen1a, (int)(250.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT), (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT));
    g->DrawRectangle(&pen1b, (int)(250.0f/600.0f*TESTAREAWIDTH), (int)(250.0f/600.0f*TESTAREAHEIGHT), (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT));
    g->DrawRectangle(&pen2a, (int)(400.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT), (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT));
    g->DrawRectangle(&pen2b, (int)(400.0f/600.0f*TESTAREAWIDTH), (int)(250.0f/600.0f*TESTAREAHEIGHT), (int)(100.0f/600.0f*TESTAREAWIDTH), (int)(100.0f/600.0f*TESTAREAHEIGHT));
    
    // Alter pens, PS_GEOMETRIC + DOT + ROUND CAP + ROUND JOIN
    pen2b.SetDashStyle(DashStyleDot);
    g->DrawRectangle(&pen2b, (int)(425.0f/600.0f*TESTAREAWIDTH), (int)(275.0f/600.0f*TESTAREAHEIGHT), (int)(50.0f/600.0f*TESTAREAWIDTH), (int)(50.0f/600.0f*TESTAREAHEIGHT));

    INT i;
    Point newPts[4];
    newPts[0].X = (int)(175.0f/600.0f*TESTAREAWIDTH); newPts[0].Y = (int)(400.0f/600.0f*TESTAREAHEIGHT);
    newPts[1].X = (int)(250.0f/600.0f*TESTAREAWIDTH); newPts[1].Y = (int)(450.0f/600.0f*TESTAREAHEIGHT);
    newPts[2].X = (int)(175.0f/600.0f*TESTAREAWIDTH); newPts[2].Y = (int)(500.0f/600.0f*TESTAREAHEIGHT);
    newPts[3].X = (int)(100.0f/600.0f*TESTAREAWIDTH); newPts[3].Y = (int)(450.0f/600.0f*TESTAREAHEIGHT);

    g->DrawPolygon(&pen3, &newPts[0], 4);

    newPts[0].X = (int)(175.0f/600.0f*TESTAREAWIDTH); newPts[0].Y = (int)(400.0f/600.0f*TESTAREAHEIGHT);
    newPts[1].X = (int)(175.0f/600.0f*TESTAREAWIDTH); newPts[1].Y = (int)(500.0f/600.0f*TESTAREAHEIGHT);
    newPts[2].X = (int)(100.0f/600.0f*TESTAREAWIDTH); newPts[2].Y = (int)(425.0f/600.0f*TESTAREAHEIGHT);
    for (i=0; i<3; i++) newPts[i].X += (int)(150.0f/600.0f*TESTAREAWIDTH);
    g->DrawLines(&pen3b, &newPts[0], 3);

    for (i=0; i<3; i++) newPts[i].X += (int)(150.0f/600.0f*TESTAREAWIDTH);
    g->DrawLines(&pen3c, &newPts[0], 3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cextra.h ===
VOID ExtraInitializations();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cdib.h ===
/******************************Module*Header*******************************\
* Module Name: CDIB.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CDIB_H
#define __CDIB_H

#include "COutput.h"

typedef RGBQUAD RGBQUAD1[2];
typedef RGBQUAD RGBQUAD2[4];
typedef RGBQUAD RGBQUAD4[16];
typedef RGBQUAD RGBQUAD8[256];
typedef RGBQUAD RGBQUAD16[3];
typedef RGBQUAD RGBQUAD24[3];
typedef RGBQUAD RGBQUAD32[3];

class CDIB : public COutput  
{
public:
    CDIB(BOOL bRegression,int nBits);
    virtual ~CDIB();

    Graphics *PreDraw(int &nOffsetX,int &nOffsetY);         // Set up graphics at the given X,Y offset
    void PostDraw(RECT rTestArea);                          // Finish off graphics at rTestArea

    void InitPalettes();                                    // Initialize palettes

    HDC m_hDC;                                              // DC of DIB
    HBITMAP m_hBM;                                          // Bitmap of DIB
    HBITMAP m_hBMOld;                                       // Bitmap of old drawing surface
    HPALETTE m_hpal;
    HPALETTE m_hpalOld;

    RGBQUAD1 m_rgbQuad1;                                    // 1 bit palette
    RGBQUAD2 m_rgbQuad2;                                    // 2 bit palette
    RGBQUAD4 m_rgbQuad4;                                    // 4 bit palette
    RGBQUAD8 m_rgbQuad8;                                    // 8 bit palette
    RGBQUAD16 m_rgbQuad16;                                  // 16 bit palette
    RGBQUAD24 m_rgbQuad24;                                  // 24 bit palette
    RGBQUAD32 m_rgbQuad32;                                  // 32 bit palette
    int m_nBits;                                            // # of bits to use
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cdib.cpp ===
/******************************Module*Header*******************************\
* Module Name: CDIB.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CDIB.h"
#include "CFuncTest.h"
#include "CHalftone.h"

extern CHalftone g_Halftone;
extern CFuncTest g_FuncTest;

CDIB::CDIB(BOOL bRegression,int nBits)
{
    sprintf(m_szName,"DIB %d bit",nBits);
    if (nBits>1)
        strcat(m_szName,"s");

    m_nBits=nBits;
    m_hDC=NULL;
    m_hBM=NULL;
    m_hBMOld=NULL;
    m_hpal=NULL;
    m_hpalOld=NULL;

    InitPalettes();
    m_bRegression=bRegression;
}

CDIB::~CDIB()
{
}

Graphics *CDIB::PreDraw(int &nOffsetX,int &nOffsetY)
{
    Graphics *g=NULL;
    PVOID pvBits = NULL;
    HDC hdcWnd=GetDC(g_FuncTest.m_hWndMain);

    // these combined give BITMAPINFO structure.
    struct {
        BITMAPINFOHEADER bmih;
        union {
            RGBQUAD1 rgbquad1;
            RGBQUAD2 rgbquad2;
            RGBQUAD4 rgbquad4;
            RGBQUAD8 rgbquad8;
            RGBQUAD16 rgbquad16;
            RGBQUAD24 rgbquad24;
            RGBQUAD32 rgbquad32;
        };
    } bmi;

    bmi.bmih.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmih.biWidth = (int)TESTAREAWIDTH;
    bmi.bmih.biHeight = (int)TESTAREAHEIGHT;
    bmi.bmih.biPlanes = 1;
    bmi.bmih.biBitCount = (WORD)m_nBits;
    bmi.bmih.biCompression = BI_RGB;
    bmi.bmih.biSizeImage = 0;
    bmi.bmih.biXPelsPerMeter = 0;
    bmi.bmih.biYPelsPerMeter = 0;
    bmi.bmih.biClrUsed = 0;             // only used for <= 16bpp
    bmi.bmih.biClrImportant = 0;

    // create appropriate rgb table.
    switch (m_nBits)
    {
    case 1: memcpy(bmi.rgbquad1, m_rgbQuad1, sizeof(m_rgbQuad1));
            break;
    
    case 2: memcpy(bmi.rgbquad2, m_rgbQuad2, sizeof(m_rgbQuad2));
            break;
    
    case 4: memcpy(bmi.rgbquad4, m_rgbQuad4, sizeof(m_rgbQuad4));
            break;
    
    case 8: memcpy(bmi.rgbquad8, m_rgbQuad8, sizeof(m_rgbQuad8));
            break;
    
    case 16: memcpy(bmi.rgbquad16, m_rgbQuad16, sizeof(m_rgbQuad16));
            break;
    
    case 24: memcpy(bmi.rgbquad24, m_rgbQuad24, sizeof(m_rgbQuad24));
            break;
    
    case 32: memcpy(bmi.rgbquad32, m_rgbQuad32, sizeof(m_rgbQuad32));
            break;
    }

    if ((m_nBits == 8) && g_Halftone.m_bUseSetting)
    {
        m_hpal = DllExports::GdipCreateHalftonePalette();
        
        BYTE aj[sizeof(PALETTEENTRY) * 256];
        LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
        RGBQUAD *prgb = (RGBQUAD *) &bmi.rgbquad8;
        ULONG i;
    
        if (GetPaletteEntries(m_hpal, 0, 256, lppe))
        {
            UINT i;

            for (i = 0; i < 256; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }
        }
        
    }

    m_hBM=CreateDIBSection(hdcWnd,(BITMAPINFO*)&bmi,DIB_RGB_COLORS,&pvBits,NULL,0);
    if (!m_hBM)
    {
        MessageBoxA(NULL,"Can't create DIB Section.","",MB_OK);
        return NULL;
    }

    // create DC for our DIB
    m_hDC=CreateCompatibleDC(hdcWnd);
    m_hBMOld=(HBITMAP)SelectObject(m_hDC,m_hBM);
    
    if (m_hpal)
    {
        m_hpalOld = SelectPalette(m_hDC, m_hpal, FALSE);
    }

    // Set the background to main window background
    BitBlt(m_hDC, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, hdcWnd, nOffsetX, nOffsetY, SRCCOPY);
//  PatBlt(m_hDC, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, WHITENESS);           

//  if (m_nBits == 32)
//      g = Graphics::FromDib32(pvBits, rClient.right, rClient.bottom);
//  else
        g = Graphics::FromHDC(m_hDC);

    // Since we are doing the test on another surface
    nOffsetX=0;
    nOffsetY=0;

    ReleaseDC(g_FuncTest.m_hWndMain,hdcWnd);

    return g;
}

void CDIB::PostDraw(RECT rTestArea)
{
    // blit from the DIB to screen so we see the results, we use
    // GDI for this.
    HDC hdcOrig = GetDC(g_FuncTest.m_hWndMain);

    HPALETTE hpalScreenOld = NULL;
    if (m_hpal)
    {
        hpalScreenOld = SelectPalette(hdcOrig, m_hpal, FALSE);
        RealizePalette(hdcOrig);
    }
    BitBlt(hdcOrig, rTestArea.left, rTestArea.top, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, m_hDC, 0, 0, SRCCOPY);
    if (m_hpal)
    {
        SelectPalette(hdcOrig, hpalScreenOld, FALSE);
    }

    ReleaseDC(g_FuncTest.m_hWndMain,hdcOrig);
    
    SelectObject(m_hDC,m_hBMOld);
    if (m_hpal)
    {
        SelectPalette(m_hDC, m_hpalOld, FALSE);
        DeleteObject(m_hpal);
        m_hpal=NULL;
    }
    DeleteDC(m_hDC);
    DeleteObject(m_hBM);
}

void CDIB::InitPalettes()
{
    BYTE red=0,green=0,blue=0;
    RGBQUAD1 rgbQuad1 = { { 0, 0, 0, 0 }, 
                          { 0xff, 0xff, 0xff, 0 } };
    RGBQUAD2 rgbQuad2 = { { 0x80, 0x80, 0x80, 0 },
                          { 0x80, 0, 0, 0 },
                          { 0, 0x80, 0, 0 },
                          { 0, 0, 0x80, 0 } };
    RGBQUAD4 rgbQuad4 = {  // B    G    R
                            { 0,   0,   0,   0 },       // 0
                            { 0,   0,   0x80,0 },       // 1
                            { 0,   0x80,0,   0 },       // 2
                            { 0,   0x80,0x80,0 },       // 3
                            { 0x80,0,   0,   0 },       // 4
                            { 0x80,0,   0x80,0 },       // 5
                            { 0x80,0x80,0,   0 },       // 6
                            { 0x80,0x80,0x80,0 },       // 7
                            { 0xC0,0xC0,0xC0,0 },       // 8
                            { 0,   0,   0xFF,0 },       // 9
                            { 0,   0xFF,0,   0 },       // 10
                            { 0,   0xFF,0xFF,0 },       // 11
                            { 0xFF,0,   0,   0 },       // 12
                            { 0xFF,0,   0xFF,0 },       // 13
                            { 0xFF,0xFF,0,   0 },       // 14
                            { 0xFF,0xFF,0xFF,0 } };     // 15
    RGBQUAD16 rgbQuad16 = { { 0, 0x7c, 0, 0 }, { 0xe0, 03, 0, 0 }, { 0x1f, 0, 0, 0 } };
    RGBQUAD24 rgbQuad24 = { { 0, 0, 0xff, 0 }, { 0, 0xff, 0, 0 }, { 0xff, 0, 0, 0 } };
    RGBQUAD32 rgbQuad32 = { { 0, 0, 0xff, 0 }, { 0, 0xff, 0, 0 }, { 0xff, 0, 0 ,0 } };

    memcpy(m_rgbQuad1,rgbQuad1,sizeof(rgbQuad1));
    memcpy(m_rgbQuad2,rgbQuad2,sizeof(rgbQuad2));
    memcpy(m_rgbQuad4,rgbQuad4,sizeof(rgbQuad4));
    memcpy(m_rgbQuad16,rgbQuad16,sizeof(rgbQuad16));
    memcpy(m_rgbQuad24,rgbQuad24,sizeof(rgbQuad24));
    memcpy(m_rgbQuad32,rgbQuad32,sizeof(rgbQuad32));

    // This is a very arbitrary palette. Anyhoo, it's not the GDI+ halftone
    // palette, which I guess is all we want to test. It is kinda lucky that
    // the VGA colors are present, but that's all we need.

    ZeroMemory(m_rgbQuad8,sizeof(m_rgbQuad8));
    for (INT i=0; i<256; i++)
    {
        m_rgbQuad8[i].rgbRed=red;
        m_rgbQuad8[i].rgbGreen=green;
        m_rgbQuad8[i].rgbBlue=blue;

        if (!(red+=32))
        {
            if (!(green+=32))
            {
                blue+=64;
            }
        }
    }

    // for system colors (last 20), use those from 4 bpp palette table.
    for (INT j=248; j<256; j++)
    {
        m_rgbQuad8[j].rgbRed=m_rgbQuad4[j-240].rgbRed;
        m_rgbQuad8[j].rgbGreen=m_rgbQuad4[j-240].rgbGreen;
        m_rgbQuad8[j].rgbBlue=m_rgbQuad4[j-240].rgbBlue;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cdashes.h ===
/******************************Module*Header*******************************\
* Module Name: CDashes.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CDASHES_H
#define __CDASHES_H

#include "CPrimitive.h"

class CDashes : public CPrimitive  
{
public:
	CDashes(BOOL bRegression);
	virtual ~CDashes();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cdirect3d.cpp ===
/******************************Module*Header*******************************\
* Module Name: CDirect3D.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CDirect3D.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CDirect3D::CDirect3D(BOOL bRegression)
{
	strcpy(m_szName,"Direct3D");
	m_paDD7=NULL;
	m_paDDSurf7=NULL;
	m_bRegression=bRegression;
}

CDirect3D::~CDirect3D()
{
	if (m_paDD7!=NULL)
	{
		m_paDD7->Release();
		m_paDD7=NULL;
	}
}

BOOL CDirect3D::Init()
{
#if HW_ACCELERATION_SUPPORT
	if (DirectDrawCreateEx(NULL,(void **)&m_paDD7,IID_IDirectDraw7,NULL)!=DD_OK)
		return false;

	if (gDD->SetCooperativeLevel(m_hWnd,DDSCL_NORMAL)!=DD_OK)
		return false;
#endif

	return COutput::Init();
}

Graphics *CDirect3D::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;

#if HW_ACCELERATION_SUPPORT
	DDSURFACEDESC2 ddsd;

	ZeroMemory(&ddsd, sizeof(ddsd));
	ddsd.dwSize = sizeof(ddsd);

	ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
	ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_3DDEVICE;
	ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
	
	switch(depth)
	{
	case 32:
		ddsd.dwFlags |= DDSD_PIXELFORMAT;
		ddsd.ddpfPixelFormat.dwSize = sizeof(ddsd.ddpfPixelFormat);
		ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;
		ddsd.ddpfPixelFormat.dwRGBBitCount = 32;
		ddsd.ddpfPixelFormat.dwRBitMask = 0xFF0000;
		ddsd.ddpfPixelFormat.dwGBitMask = 0xFF00;
		ddsd.ddpfPixelFormat.dwBBitMask = 0xFF;
		break;
	case 16:
		ddsd.dwFlags |= DDSD_PIXELFORMAT;
		ddsd.ddpfPixelFormat.dwSize = sizeof(ddsd.ddpfPixelFormat);
		ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;
		ddsd.ddpfPixelFormat.dwRGBBitCount = 16;
		ddsd.ddpfPixelFormat.dwRBitMask = 0xEC00;
		ddsd.ddpfPixelFormat.dwGBitMask = 0x3E0;
		ddsd.ddpfPixelFormat.dwBBitMask = 0x1F;
		break;
	default:
		MessageBoxA(NULL,
					"Unsupprted depth for D3D", 
					"", 
					MB_OK);
		return;
	}

	ddsd.dwWidth = (int)TESTAREAWIDTH;
	ddsd.dwHeight = (int)TESTAREAHEIGHT;
	
	HRESULT err;
	
	err = m_paDD7->CreateSurface(&ddsd, &dds, NULL);
	if(err != DD_OK)
	{
	    MessageBoxA(NULL,
	               "Unable to create surface", 
	               "", 
	               MB_OK);
	    return;
	}
	
	HDC hdc;
	 
	err = m_paDDSurf7->GetDC(&hdc);
	
#if 0
	if(err != DD_OK)
	{
	    MessageBoxA(NULL,
	               "Unable to get DC from DDraw surface", 
	               "", 
	               MB_OK);
	    m_paDDSurf7->Release();
	    return;
	}
	
	g = Graphics::GetFromHdc(hdc);
	
	BitBlt(hdc, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, NULL, 0, 0, WHITENESS);
	
	m_paDDSurf7->ReleaseDC(hdc);
#else
	BitBlt(hdc, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, NULL, 0, 0, WHITENESS);
	
	m_paDDSurf7->ReleaseDC(hdc);
	
	bitmap = new Bitmap(dds);
	
	g = new Graphics(bitmap);
#endif

	// Since we are doing the test on another surface
	nOffsetX=0;
	nOffsetY=0;
#endif

	return g;
}

void CDirect3D::PostDraw(RECT rTestArea)
{
#if HW_ACCELERATION_SUPPORT
	delete bitmap;

	HRESULT err;
	HDC hdc;
	HDC hdcOrig = GetDC(g_FuncTest.m_hWndMain);

	err = m_paDDSurf7->GetDC(&hdc);
	if(err == DD_OK)
	{
	    BitBlt(hdcOrig, rTestArea.left, rTestArea.top, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, hdc, 0, 0, SRCCOPY);
	}
	m_paDDSurf7->ReleaseDC(hdc);
	m_paDDSurf7->Release();
	ReleaseDC(g_FuncTest.m_hWndMain, hdcOrig);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cextra.cpp ===
// Include all the primitives (classes derived from CPrimitive)
#include "CPolygons.h"
#include "CCachedBitmap.h"
#include "CBitmaps.h"
#include "CCompoundLines.h"
#include "CContainer.h"
#include "CContainerClip.h"
#include "CDashes.h"
#include "CPathGradient.hpp"
#include "CGradients.h"
#include "CImaging.h"
#include "CRecolor.h"
#include "CSystemColor.h"
#include "CInsetLines.h"
#include "CMixedObjects.h"
#include "CPaths.h"
#include "CDash.hpp"
#include "CLines.hpp"
#include "CPrimitives.h"
#include "CRegions.h"
#include "CText.h"
#include "printtest\CPrinting.h"
#include "CRegression.h"
#include "CSourceCopy.h"
#include "CExtra.h"
#include "CReadWrite.h"
#include "CFillMode.h"

// Create global objects for each individual primitive
//   First constructor param is the regression flag
//   If true, the test will take part of the regression suite
CPolygons g_Polygons(true);
CBitmaps g_Bitmaps(true);
CCachedBitmap g_CachedBitmap(true);
CCompoundLines g_CompoundLines(true);
CContainer g_Container(true);
CContainerClip g_ContainerClip(true);
CDashes g_Dashes(true);

DASH_GLOBALS
INSET_GLOBALS
GRADIENT_GLOBALS
PATHGRADIENT_GLOBALS
LINES_GLOBALS

CImaging g_Imaging(true);
CRecolor g_Recolor(true);
CSystemColor g_SystemColor(false);
CMixedObjects g_MixedObjects(true);
CPaths g_Paths(true);
CJoins g_Joins(true);
CPrimitives g_Primitives(true);
CRegions g_Regions(true);
CText g_Text(true);
CSourceCopy g_SourceCopy(true);
CReadWrite g_ReadWrite(false);
CFillMode g_FillMode(true);

void ExtraInitializations()
{
    g_Polygons.Init();
    g_Bitmaps.Init();
    g_CachedBitmap.Init();
    g_CompoundLines.Init();
    g_Container.Init();
    g_ContainerClip.Init();
    g_Dashes.Init();
    DASH_INIT;
    INSET_INIT;
    GRADIENT_INIT;
    PATHGRADIENT_INIT;
    LINES_INIT;
    g_Imaging.Init();
    g_Recolor.Init();
    g_SystemColor.Init();
    g_MixedObjects.Init();
    g_Paths.Init();
    g_Joins.Init();
    g_Primitives.Init();
    g_Regions.Init();
    g_Text.Init();
    g_SourceCopy.Init();
    g_ReadWrite.Init();
    g_FillMode.Init();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cfillmode.h ===
/******************************Module*Header*******************************\
* Module Name: CFillMode.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CFILLMODE_H
#define __CFILLMODE_H

#include "CPrimitive.h"

class CFillMode : public CPrimitive  
{
public:
	CFillMode(BOOL bRegression);
	virtual ~CFillMode();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cfile.cpp ===
/******************************Module*Header*******************************\
* Module Name: CFile.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CFile.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CFile::CFile(BOOL bRegression,int nBits)
{
	sprintf(m_szName,"File %d bits",nBits);
	m_nBits=nBits;
	m_hDC=NULL;
	m_hBM=NULL;
	m_hBMOld=NULL;

	InitPalettes();
	m_bRegression=bRegression;
}

CFile::~CFile()
{
}

Graphics *CFile::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;
	PVOID pvBits = NULL;
	HDC hdcWnd=GetDC(g_FuncTest.m_hWndMain);

	// these combined give BITMAPINFO structure.
	struct {
	    BITMAPINFOHEADER bmih;
	    union {
	        RGBQUAD1 rgbquad1;
	        RGBQUAD2 rgbquad2;
	        RGBQUAD4 rgbquad4;
	        RGBQUAD8 rgbquad8;
	        RGBQUAD16 rgbquad16;
	        RGBQUAD24 rgbquad24;
	        RGBQUAD32 rgbquad32;
	    };
	} bmi;

	bmi.bmih.biSize = sizeof(BITMAPINFOHEADER);
	bmi.bmih.biWidth = (int)TESTAREAWIDTH;
	bmi.bmih.biHeight = (int)TESTAREAHEIGHT;
	bmi.bmih.biPlanes = 1;
	bmi.bmih.biBitCount = (WORD)m_nBits;
	bmi.bmih.biCompression = BI_RGB;
	bmi.bmih.biSizeImage = 0;
	bmi.bmih.biXPelsPerMeter = 0;
	bmi.bmih.biYPelsPerMeter = 0;
	bmi.bmih.biClrUsed = 0;             // only used for <= 16bpp
	bmi.bmih.biClrImportant = 0;

	// create appropriate rgb table.
	switch (m_nBits)
	{
	case 1: memcpy(bmi.rgbquad1, m_rgbQuad1, sizeof(m_rgbQuad1));
	        break;

	case 2: memcpy(bmi.rgbquad2, m_rgbQuad2, sizeof(m_rgbQuad2));
	        break;

	case 4: memcpy(bmi.rgbquad4, m_rgbQuad4, sizeof(m_rgbQuad4));
	        break;

	case 8: memcpy(bmi.rgbquad8, m_rgbQuad8, sizeof(m_rgbQuad8));
	        break;

	case 16: memcpy(bmi.rgbquad16, m_rgbQuad16, sizeof(m_rgbQuad16));
	        break;

	case 24: memcpy(bmi.rgbquad24, m_rgbQuad24, sizeof(m_rgbQuad24));
	        break;

	case 32: memcpy(bmi.rgbquad32, m_rgbQuad32, sizeof(m_rgbQuad32));
	        break;
	}

	m_hBM=CreateDIBSection(hdcWnd,(BITMAPINFO*)&bmi,DIB_RGB_COLORS,&pvBits,NULL,0);
	if (!m_hBM)
	{
	    MessageBoxA(NULL,"Can't create DIB Section.","",MB_OK);
	    return NULL;
	}

	// create DC for our DIB
	m_hDC=CreateCompatibleDC(hdcWnd);
	m_hBMOld=(HBITMAP)SelectObject(m_hDC,m_hBM);

	// Set the background to main window background
	BitBlt(m_hDC, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, hdcWnd, nOffsetX, nOffsetY, SRCCOPY);
//	PatBlt(m_hDC, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, WHITENESS);           

//	if (m_nBits == 32)
//		g = Graphics::FromDib32(pvBits, rClient.right, rClient.bottom);
//	else
		g = Graphics::FromHDC(m_hDC);

	// Since we are doing the test on another surface
	nOffsetX=0;
	nOffsetY=0;

	ReleaseDC(g_FuncTest.m_hWndMain,hdcWnd);

	return g;
}

void CFile::PostDraw(RECT rTestArea)
{
	char *szTitle="TestDIB.bmp";
	HDC hdcOrig = GetDC(g_FuncTest.m_hWndMain);

	// blit from the DIB to screen so we see the results, we use
	// GDI for this.

	BitBlt(hdcOrig, rTestArea.left, rTestArea.top, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, m_hDC, 0, 0, SRCCOPY);

    BOOL success = WriteBitmap(szTitle, m_hBM, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT);

	ReleaseDC(g_FuncTest.m_hWndMain,hdcOrig);
	SelectObject(m_hDC,m_hBMOld);
	DeleteDC(m_hDC);
	DeleteObject(m_hBM);
}

void CFile::InitPalettes()
{
	BYTE red=0,green=0,blue=0;
	RGBQUAD1 rgbQuad1 = { { 0, 0, 0, 0 }, 
		                  { 0xff, 0xff, 0xff, 0 } };
	RGBQUAD2 rgbQuad2 = { { 0x80, 0x80, 0x80, 0 },
		                  { 0x80, 0, 0, 0 },
			              { 0, 0x80, 0, 0 },
				          { 0, 0, 0x80, 0 } };
	RGBQUAD4 rgbQuad4 =	{  // B    G    R
							{ 0,   0,   0,   0 },       // 0
							{ 0,   0,   0x80,0 },       // 1
							{ 0,   0x80,0,   0 },       // 2
							{ 0,   0x80,0x80,0 },       // 3
							{ 0x80,0,   0,   0 },       // 4
							{ 0x80,0,   0x80,0 },       // 5
							{ 0x80,0x80,0,   0 },       // 6
							{ 0x80,0x80,0x80,0 },       // 7
							{ 0xC0,0xC0,0xC0,0 },       // 8
							{ 0,   0,   0xFF,0 },       // 9
							{ 0,   0xFF,0,   0 },       // 10
							{ 0,   0xFF,0xFF,0 },       // 11
							{ 0xFF,0,   0,   0 },       // 12
							{ 0xFF,0,   0xFF,0 },       // 13
							{ 0xFF,0xFF,0,   0 },       // 14
							{ 0xFF,0xFF,0xFF,0 } };     // 15
	RGBQUAD16 rgbQuad16 = { { 0, 0x7c, 0, 0 }, { 0xe0, 03, 0, 0 }, { 0x1f, 0, 0, 0 } };
	RGBQUAD24 rgbQuad24 = { { 0, 0, 0xff, 0 }, { 0, 0xff, 0, 0 }, { 0xff, 0, 0, 0 } };
	RGBQUAD32 rgbQuad32 = { { 0, 0, 0xff, 0 }, { 0, 0xff, 0, 0 }, { 0xff, 0, 0 ,0 } };

	memcpy(m_rgbQuad1,rgbQuad1,sizeof(rgbQuad1));
	memcpy(m_rgbQuad2,rgbQuad2,sizeof(rgbQuad2));
	memcpy(m_rgbQuad4,rgbQuad4,sizeof(rgbQuad4));
	memcpy(m_rgbQuad16,rgbQuad16,sizeof(rgbQuad16));
	memcpy(m_rgbQuad24,rgbQuad24,sizeof(rgbQuad24));
	memcpy(m_rgbQuad32,rgbQuad32,sizeof(rgbQuad32));

	ZeroMemory(m_rgbQuad8,sizeof(m_rgbQuad8));
	for (INT i=0; i<256; i++)
	{
		m_rgbQuad8[i].rgbRed=red;
		m_rgbQuad8[i].rgbGreen=green;
		m_rgbQuad8[i].rgbBlue=blue;

		if (!(red+=32))
		{
			if (!(green+=32))
			{
				blue+=64;
			}
		}
	}

	// for system colors (last 20), use those from 4 bpp palette table.
	for (INT j=248; j<256; j++)
	{
		m_rgbQuad8[j].rgbRed=m_rgbQuad4[j-240].rgbRed;
		m_rgbQuad8[j].rgbGreen=m_rgbQuad4[j-240].rgbGreen;
		m_rgbQuad8[j].rgbBlue=m_rgbQuad4[j-240].rgbBlue;
	}
}

BOOL CFile::WriteBitmap(char *szTitle, HBITMAP hbitmap, INT width, INT height)
{
    BITMAPFILEHEADER    fileHeader;
    BITMAPINFOHEADER    infoHeader;

    memset(&fileHeader, 0, sizeof(fileHeader));
    memset(&infoHeader, 0, sizeof(infoHeader));

    fileHeader.bfType = 0x4d42;
    fileHeader.bfOffBits = sizeof(fileHeader) + sizeof(infoHeader);

    infoHeader.biSize = sizeof(infoHeader);
    infoHeader.biPlanes = 1;
    infoHeader.biWidth = width;
    infoHeader.biHeight = height;
    infoHeader.biBitCount = 24;
    infoHeader.biXPelsPerMeter = 3780;
    infoHeader.biYPelsPerMeter = 3780;

    BITMAPINFO bmInfo;
    bmInfo.bmiHeader = infoHeader;
    VOID* bits = malloc(infoHeader.biWidth*infoHeader.biHeight*3);

    BOOL success = FALSE;

    if(bits)
    {
        HDC hdc = CreateCompatibleDC(NULL);
        INT n = GetDIBits(hdc, hbitmap, 0, height,
            bits, &bmInfo, DIB_RGB_COLORS);

        infoHeader.biHeight = n;
        INT bitsSize = infoHeader.biHeight*infoHeader.biWidth*3;
        fileHeader.bfSize = sizeof(fileHeader) + sizeof(infoHeader)
            + bitsSize;

        DeleteDC(hdc);

        HANDLE hFile = CreateFileA(szTitle,
            GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        BOOL deleteFile = FALSE;
        DWORD dwPtr;
        DWORD dwError;

        if(hFile == INVALID_HANDLE_VALUE)
            goto cleanUp2;

        dwPtr = SetFilePointer (hFile, 0, NULL, FILE_BEGIN) ; 

        dwError;

        if(dwPtr == 0xFFFFFFFF && (dwError = GetLastError()) != NO_ERROR)
        {
            deleteFile = TRUE;
            goto cleanUp1;
        }

        DWORD bytesToWrite;
        DWORD bytesWritten;

        bytesToWrite = sizeof(fileHeader);
        success = WriteFile(
                hFile,
                &fileHeader,
                bytesToWrite,
                &bytesWritten,
                NULL);

        if(!success || bytesWritten != bytesToWrite)
        {
            success = FALSE;
            deleteFile = TRUE;
            goto cleanUp1;
        }

        bytesToWrite = sizeof(infoHeader);
        success = WriteFile(
                hFile,
                &infoHeader,
                bytesToWrite,
                &bytesWritten,
                NULL);

        if(!success || bytesWritten != bytesToWrite)
        {
            success = FALSE;
            deleteFile = TRUE;
            goto cleanUp1;
        }

        bytesToWrite = bitsSize;
        success = WriteFile(
                hFile,
                bits,
                bytesToWrite,
                &bytesWritten,
                NULL);

        if(!success || bytesWritten != bytesToWrite)
        {
            success = FALSE;
            deleteFile = TRUE;
            goto cleanUp1;
        }

        success = TRUE;

cleanUp1:
        CloseHandle(hFile);
        if(deleteFile)
            DeleteFileA(szTitle);

cleanUp2:
        free(bits);
    }

    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cdirect3d.h ===
/******************************Module*Header*******************************\
* Module Name: CDirect3D.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CDIRECT3D_H
#define __CDIRECT3D_H

#include "COutput.h"

class CDirect3D : public COutput  
{
public:
	CDirect3D(BOOL bRegression);
	virtual ~CDirect3D();

	BOOL Init();
	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	LPDIRECTDRAW7 m_paDD7;									// DirectDraw 7
	LPDIRECTDRAWSURFACE7 m_paDDSurf7;						// DirectDraw surface 7
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cfillmode.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPaths.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CFillMode.h"
#include <limits.h>

CFillMode::CFillMode(BOOL bRegression)
{
	strcpy(m_szName,"Test Winding Fill Mode");
	m_bRegression=bRegression;
}

CFillMode::~CFillMode()
{
}

VOID TestEscherNewPath(Graphics* g);

void CFillMode::Draw(Graphics *g)
{
    // Create an ALTERNATE non-zero winding fill mode path.

    GraphicsPath p1(FillModeAlternate);

    p1.AddEllipse(0, 0, 100, 100);
    p1.CloseFigure();


    GraphicsPath p2(FillModeAlternate);
    
    p2.AddEllipse(10, 10, 80, 80);
    p2.CloseFigure();
   
    // Both paths should be same direction.  Filling with even-odd rule
    // gives a donut while non-zero gives a filled circle.

    p1.AddPath(&p2, FALSE);

    LinearGradientBrush brush(Point(0,0), Point(100,100), Color(0xFF,0,0xFF,0), Color(0xFF, 0xFF, 0, 0));

    g->FillPath(&brush, &p1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cfile.h ===
/******************************Module*Header*******************************\
* Module Name: CFile.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CFILE_H
#define __CFILE_H

#include "COutput.h"

typedef RGBQUAD RGBQUAD1[2];
typedef RGBQUAD RGBQUAD2[4];
typedef RGBQUAD RGBQUAD4[16];
typedef RGBQUAD RGBQUAD8[256];
typedef RGBQUAD RGBQUAD16[3];
typedef RGBQUAD RGBQUAD24[3];
typedef RGBQUAD RGBQUAD32[3];

class CFile : public COutput  
{
public:
	CFile(BOOL bRegression,int nBits);
	virtual ~CFile();

	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	BOOL WriteBitmap(char *szTitle, HBITMAP hbitmap, INT width, INT height);
	void InitPalettes();									// Initialize palettes

	HDC m_hDC;												// DC of DIB
	HBITMAP m_hBM;											// Bitmap of DIB
	HBITMAP m_hBMOld;										// Bitmap of old drawing surface

	RGBQUAD1 m_rgbQuad1;									// 1 bit palette
	RGBQUAD2 m_rgbQuad2;									// 2 bit palette
	RGBQUAD4 m_rgbQuad4;									// 4 bit palette
	RGBQUAD8 m_rgbQuad8;									// 8 bit palette
	RGBQUAD16 m_rgbQuad16;									// 16 bit palette
	RGBQUAD24 m_rgbQuad24;									// 24 bit palette
	RGBQUAD32 m_rgbQuad32;									// 32 bit palette
	int m_nBits;											// # of bits to use
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cfunctest.cpp ===
/******************************Module*Header*******************************\
* Module Name: CFuncTest.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#undef UNICODE
#undef _UNICODE

#include "CFuncTest.h"
#include "Resource.h"
#include "CRegression.h"
#include "CHDC.h"

extern CFuncTest g_FuncTest;        // Initialized in Main.cpp
extern HBRUSH g_hbrBackground;      // Initialized in Main.cpp
extern CRegression g_Regression;    // Initialized in Main.cpp
extern CHDC g_HDC;                  // Initialized in Main.cpp
extern int g_nResult;               // Initialized in Main.cpp

CFuncTest::CFuncTest()
{
    m_hWndDlg=NULL;
    m_hWndMain=NULL;
    m_bUsePageDelay=true;           // Default use page delay or page pause
    m_bEraseBkgd=true;              // Default erace background
    m_bAppendTest=false;            // Default append test
    m_nPageDelay=1000;              // Default page delay
    m_nPageRow=0;
    m_nPageCol=0;
}

CFuncTest::~CFuncTest()
{
    EndDialog(m_hWndDlg,0);
    m_hWndDlg=NULL;
    m_hWndMain=NULL;
}

BOOL CFuncTest::Init(HWND hWndParent)
// Initializes functest
{
    HWND hWnd;
    char szDelay[10];

    m_hWndMain=hWndParent;

    // Create options dialog box
    m_hWndDlg=CreateDialogA(GetModuleHandleA(NULL),MAKEINTRESOURCEA(IDD_FUNCTEST),hWndParent,&DlgProc);
    if (m_hWndDlg==NULL)
        return false;

    // Set default options in dialog box using defaults in constructor
    if (m_bUsePageDelay)
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_PAGEDELAY);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
    }
    else
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_PAGEPAUSE);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
    }
    hWnd=GetDlgItem(m_hWndDlg,IDC_DELAY);
    SendMessageA(hWnd,WM_SETTEXT,0,(LPARAM)_itoa(m_nPageDelay,szDelay,10));
    if (m_bEraseBkgd)
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_ERASEBKGD);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
    }
    if (m_bAppendTest)
    {
        hWnd=GetDlgItem(m_hWndDlg,IDC_APPENDTEST);
        SendMessageA(hWnd,BM_SETCHECK,(WPARAM)BST_CHECKED,0);
    }

    return true;
}

void CFuncTest::RunOptions()
// Toggle options dialog box
{
    if (m_hWndDlg!=NULL)
    {
        if (!IsWindowVisible(m_hWndDlg))
            ShowWindow(m_hWndDlg,SW_SHOW);
        else
            ShowWindow(m_hWndDlg,SW_HIDE);
    }
}

BOOL CFuncTest::AddPrimitive(CPrimitive *pPrimitive)
// Adds a primitive to the primitive test list in options dialog box
{
    HWND hWnd;
    LRESULT iItem;

    hWnd=GetDlgItem(m_hWndDlg,IDC_PRIMITIVES);

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)false,0);    // Reset selection

    iItem=SendMessageA(hWnd,LB_ADDSTRING,0,(LPARAM)pPrimitive->m_szName);
    if (iItem<0)
        return false;

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)true,0);     // Pick top element as selection

    // Data is a pointer to the primitive base class
    SendMessageA(hWnd,LB_SETITEMDATA,(WPARAM)iItem,(LPARAM)pPrimitive);

    return true;
}

BOOL CFuncTest::AddOutput(COutput *pOutput)
// Adds an output to the output list in options dialog box
{
    HWND hWnd;
    LRESULT iItem;

    hWnd=GetDlgItem(m_hWndDlg,IDC_OUTPUTS);

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)false,0);    // Reset selection

    iItem=SendMessageA(hWnd,LB_ADDSTRING,0,(LPARAM)pOutput->m_szName);
    if (iItem<0)
        return false;

    SendMessageA(hWnd,LB_SETSEL,(WPARAM)true,0);     // Pick top element as selection

    // Data is a pointer to the output base class
    SendMessageA(hWnd,LB_SETITEMDATA,(WPARAM)iItem,(LPARAM)pOutput);

    return true;
}

BOOL CFuncTest::AddSetting(CSetting *pSetting)
// Adds a setting to the settings list in options dialog box
{
    HWND hWnd;
    LRESULT iItem;

    hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
    iItem=SendMessageA(hWnd,LB_ADDSTRING,0,(LPARAM)pSetting->m_szName);
    if (iItem<0)
        return false;

    // Data is a pointer to the setting base class
    SendMessageA(hWnd,LB_SETITEMDATA,(WPARAM)iItem,(LPARAM)pSetting);

    return true;
}

RECT CFuncTest::GetTestRect(int nCol,int nRow)
{
    RECT Rect;

    // Create test area rect
    Rect.top=nRow*(int)TESTAREAHEIGHT;
    Rect.left=nCol*(int)TESTAREAWIDTH;
    Rect.right=Rect.left+(int)TESTAREAWIDTH;
    Rect.bottom=Rect.top+(int)TESTAREAHEIGHT;

    return Rect;
}

void CFuncTest::RunTest(COutput *pOutput,CPrimitive *pPrimitive)
// Runs one test using the given output, primitive, and settings that have m_bUseSetting=true
{
    char szBuffer[256];
    MSG Msg;
    Graphics *g=NULL;
    CSetting *pSetting;
    RECT Rect;
    HDC hDC;
    HWND hWnd;
    int iItem;
    LRESULT cItemMax;
    int nX;
    int nY;
    BOOL bFirstSetting=true;

    __try
    {
        sprintf(szBuffer,"%s on %s",pPrimitive->m_szName,pOutput->m_szName);

        Rect=GetTestRect(m_nPageCol,m_nPageRow);    // Get test area

        // Clear test area
        if (m_bEraseBkgd)
        {
            hDC=GetDC(m_hWndMain);
            FillRect(hDC,&Rect,g_hbrBackground);
            ReleaseDC(m_hWndMain,hDC);
        }

        // Initialize output and get graphics pointer
        // Let pOutput modify the nX,nY in case we are drawing to a dib, we do not
        //   want to be translating.
        nX=Rect.left;
        nY=Rect.top;
        g=pOutput->PreDraw(nX,nY);
        if (g==NULL)
            return;

        // Move test to test area
        g->TranslateTransform((float)nX,(float)nY);

        // Set each setting in the list box
        hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
        cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
        for (iItem=0;iItem<cItemMax;iItem++) {
            pSetting=(CSetting*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);
            pSetting->Set(g);
            if (pSetting->m_bUseSetting)
            {
                if (bFirstSetting)
                {
                    strcat(szBuffer," (");
                    bFirstSetting=false;
                }
                else
                {
                    strcat(szBuffer,", ");
                }
                strcat(szBuffer,pSetting->m_szName);
            }
        }
        if (!bFirstSetting)
            strcat(szBuffer,")");

        // We do have some primitives (CachedBitmap) which don't respect the 
        // world transform so we need some way to access the offset to the
        // test rectangle.

        pPrimitive->SetOffset(nX, nY);

        // Draw primitive test
        pPrimitive->Draw(g);

        // Destroy graphics pointer
        delete g;

        // Finish off the output
        pOutput->PostDraw(Rect);

        // Write description of test
        hDC=GetDC(m_hWndMain);
        SetBkMode(hDC,TRANSPARENT);
        DrawTextA(hDC,szBuffer,-1,&Rect,DT_CENTER|DT_WORDBREAK);
        ReleaseDC(m_hWndMain,hDC);

        // Determine page col/row where next test will be drawn
        GetClientRect(m_hWndMain,&Rect);
        m_nPageCol++;
        if (m_nPageCol*TESTAREAWIDTH+TESTAREAWIDTH>Rect.right)
        {
            m_nPageCol=0;
            m_nPageRow++;
            if (m_nPageRow*TESTAREAHEIGHT+TESTAREAHEIGHT>Rect.bottom)
            // If graphics page is full, wait or pause
            {
                m_nPageRow=0;
                if (m_bUsePageDelay)
                    Sleep(m_nPageDelay);        // Wait
                else
                {                               // Pause for next input message
                    // Clear old input messages
                    while (GetInputState())
                        PeekMessageA(&Msg,NULL,0,0,PM_REMOVE);

                    // Wait for new input message
                    while (!GetInputState())
                        Sleep(100);
                }
            }
        }
    }__except(EXCEPTION_ACCESS_VIOLATION,1){
        printf("%s caused AV\n",szBuffer);
        g_nResult=1;                       // Return 1 if there was an AV
    }
}

void CFuncTest::InitRun()
// Initialise test run, grabs all info from the options dialog box
{
    HWND hWnd;
    char szDelay[10];
    RECT Rect;
    HDC hDC;

    // Hide options dialog
//  ShowWindow(m_hWndDlg,SW_HIDE);

    // Grab options
    hWnd=GetDlgItem(m_hWndDlg,IDC_PAGEDELAY);
    if (SendMessageA(hWnd,BM_GETCHECK,0,0)==BST_CHECKED)
        m_bUsePageDelay=true;
    else
        m_bUsePageDelay=false;

    hWnd=GetDlgItem(m_hWndDlg,IDC_DELAY);
    SendMessageA(hWnd,WM_GETTEXT,(WPARAM)10,(LPARAM)szDelay);
    m_nPageDelay=atoi(szDelay);

    hWnd=GetDlgItem(m_hWndDlg,IDC_ERASEBKGD);
    if (SendMessageA(hWnd,BM_GETCHECK,0,0)==BST_CHECKED)
        m_bEraseBkgd=true;
    else
        m_bEraseBkgd=false;

    hWnd=GetDlgItem(m_hWndDlg,IDC_APPENDTEST);
    if (SendMessageA(hWnd,BM_GETCHECK,0,0)==BST_CHECKED)
        m_bAppendTest=true;
    else
        m_bAppendTest=false;

    // Erase entire main window
    if (!m_bAppendTest && m_bEraseBkgd)
    {
        GetClientRect(m_hWndMain,&Rect);
        hDC=GetDC(m_hWndMain);
        FillRect(hDC,&Rect,g_hbrBackground);
        ReleaseDC(m_hWndMain,hDC);
    }

    if (!m_bAppendTest)
    {
        // Reset page row/col
        m_nPageRow=0;
        m_nPageCol=0;
    }
}

void CFuncTest::EndRun()
{
    int nX;
    int nY;
    RECT rTestArea;
    RECT rWindow;
    HDC hDC;

    hDC=GetDC(m_hWndMain);
    GetClientRect(m_hWndMain,&rWindow);

    // Draw lines on bottom right corner of last test
    // Figure out what was the last m_nPageCol and m_nPageRow
    nX=m_nPageCol-1;
    nY=m_nPageRow;
    if (nX<0) {
        nX=(rWindow.right/(int)TESTAREAWIDTH)-1;
        nY--;
        if (nY<0) {
            nY=(rWindow.bottom/(int)TESTAREAHEIGHT)-1;
        }
    }
    // Get the x,y coordinates
    nX=nX*(int)TESTAREAWIDTH;
    nY=nY*(int)TESTAREAHEIGHT;
    // Draw both lines
    Rectangle(hDC,nX+(int)TESTAREAWIDTH-3,nY,nX+(int)TESTAREAWIDTH,nY+(int)TESTAREAHEIGHT);
    Rectangle(hDC,nX,nY+(int)TESTAREAHEIGHT-3,nX+(int)TESTAREAWIDTH,nY+(int)TESTAREAWIDTH);

    // Clear the rest of the test areas on page
    if (m_bEraseBkgd)
    {
        nX=m_nPageCol;
        nY=m_nPageRow;
        while ((nX>0) || (nY>0))
        {
            rTestArea=GetTestRect(nX,nY);
            FillRect(hDC,&rTestArea,g_hbrBackground);
            nX++;
            if (nX*TESTAREAWIDTH+TESTAREAWIDTH>rWindow.right)
            {
                nX=0;
                nY++;
                if (nY*TESTAREAHEIGHT+TESTAREAHEIGHT>rWindow.bottom)
                // If graphics page is full
                {
                    nY=0;
                }
            }
        }
    }

    ReleaseDC(m_hWndMain,hDC);
}

void CFuncTest::Run()
// Runs all selected tests
{
    COutput *pOutput;
    CPrimitive *pPrimitive;
    CSetting *pSetting;
    HWND hWnd;
    HWND hWndOutput;
    int iOutput;
    LRESULT cOutputMax;
    int iItem;
    LRESULT cItemMax;

    InitRun();      // Init test run

    // Do the selected output loop
    hWndOutput=GetDlgItem(m_hWndDlg,IDC_OUTPUTS);
    cOutputMax=SendMessageA(hWndOutput,LB_GETCOUNT,0,0);
    for (iOutput=0;iOutput<cOutputMax;iOutput++) {
        pOutput=(COutput*)SendMessageA(hWndOutput,LB_GETITEMDATA,(WPARAM)iOutput,0);
        if (SendMessageA(hWndOutput,LB_GETSEL,(WPARAM)iOutput,0)<=0)
            continue;

        // Set each setting according to what is selected in the list box
        hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
        cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
        for (iItem=0;iItem<cItemMax;iItem++) {
            pSetting=(CSetting*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);

            if (SendMessageA(hWnd,LB_GETSEL,(WPARAM)iItem,0)>0)
                pSetting->m_bUseSetting=true;
            else
                pSetting->m_bUseSetting=false;
        }

        // Draw each primitive selected in the list box
        hWnd=GetDlgItem(m_hWndDlg,IDC_PRIMITIVES);
        cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
        for (iItem=0;iItem<cItemMax;iItem++) {
            pPrimitive=(CPrimitive*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);

            if (SendMessageA(hWnd,LB_GETSEL,(WPARAM)iItem,0)>0)
                RunTest(pOutput,pPrimitive);
        }
    }

    EndRun();
}

void CFuncTest::RunRegression()
// Runs regression test suite
{
    COutput *pOutput;
    CPrimitive *pPrimitive;
    CSetting *pSetting;
    HWND hWnd;
    HWND hWndOutput;
    int iOutput;
    LRESULT cOutputMax;
    int iItem;
    LRESULT cItemMax;

    InitRun();      // Init test run

    // Do the output regression loop
    hWndOutput=GetDlgItem(m_hWndDlg,IDC_OUTPUTS);
    cOutputMax=SendMessageA(hWndOutput,LB_GETCOUNT,0,0);
    for (iOutput=0;iOutput<cOutputMax;iOutput++) {
        pOutput=(COutput*)SendMessageA(hWndOutput,LB_GETITEMDATA,(WPARAM)iOutput,0);
        if (!pOutput->m_bRegression)
            continue;

        ClearAllSettings();
        RunTest(pOutput,&g_Regression);
    }

    // Do the primitive regression loop
    hWnd=GetDlgItem(m_hWndDlg,IDC_PRIMITIVES);
    cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
    for (iItem=0;iItem<cItemMax;iItem++) {
        pPrimitive=(CPrimitive*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);
        if (!pPrimitive->m_bRegression)
            continue;

        ClearAllSettings();
        RunTest(&g_HDC,pPrimitive);
    }

    // Do the settings regression loop
    hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
    cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
    for (iItem=0;iItem<cItemMax;iItem++) {
        pSetting=(CSetting*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);
        if (!pSetting->m_bRegression)
            continue;

        ClearAllSettings();
        pSetting->m_bUseSetting=true;
        RunTest(&g_HDC,&g_Regression);
    }

    EndRun();
}

void CFuncTest::ClearAllSettings()
// Clear all settings to m_bUseSetting=false
{
    CSetting *pSetting;
    HWND hWnd;
    LRESULT cItemMax;
    int iItem;

    // Set all settings off
    hWnd=GetDlgItem(m_hWndDlg,IDC_SETTINGS);
    cItemMax=SendMessageA(hWnd,LB_GETCOUNT,0,0);
    for (iItem=0;iItem<cItemMax;iItem++) {
        pSetting=(CSetting*)SendMessageA(hWnd,LB_GETITEMDATA,(WPARAM)iItem,0);
        pSetting->m_bUseSetting=false;
    }
}

INT_PTR CALLBACK CFuncTest::DlgProc(HWND hWndDlg,UINT Msg,WPARAM wParam,LPARAM lParam)
// Options dialog proc
{
    switch (Msg)
    {
        case WM_INITDIALOG:
            return true;
        case WM_COMMAND:
            if (HIWORD(wParam)==BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_RUN:
                        g_FuncTest.Run();
                        return true;
                    case IDC_REGRESSION:
                        g_FuncTest.RunRegression();
                        return true;
                }
            }
            else if (HIWORD(wParam)==LBN_DBLCLK)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_PRIMITIVES:
                        g_FuncTest.Run();
                        return true;
                }
            }
            break;
        case WM_CLOSE:
            ShowWindow(hWndDlg,SW_HIDE);
            return true;
    }

    return false;
}

#define UNICODE
#define _UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cgradients.cpp ===
/******************************Module*Header*******************************\
* Module Name: CGradients.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CGradients.h"

GraphicsPath *CreateHeartPath(const RectF& rect)
{
    GpPointF points[7];
    points[0].X = 0;
    points[0].Y = 0;
    points[1].X = 1.00;
    points[1].Y = -1.00;
    points[2].X = 2.00;
    points[2].Y = 1.00;
    points[3].X = 0;
    points[3].Y = 2.00;
    points[4].X = -2.00;
    points[4].Y = 1.00;
    points[5].X = -1.00;
    points[5].Y = -1.00;
    points[6].X = 0;
    points[6].Y = 0;

    Matrix matrix;

    matrix.Scale(rect.Width/2, rect.Height/3, MatrixOrderAppend);
    matrix.Translate(3*rect.Width/2, 4*rect.Height/3, MatrixOrderAppend);
    matrix.TransformPoints(&points[0], 7);

    GraphicsPath* path = new GraphicsPath();
    
    if(path)
    {
        path->AddBeziers(&points[0], 7);
        path->CloseFigure();
    }

    return path;
}

CScaledGradients::CScaledGradients(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Path,Scaled,Tiled");
	m_bRegression=bRegression;
}

void CScaledGradients::Draw(Graphics *g)
{
    Status st;

    RectF heartRect(-100,0,500,500);
    GraphicsPath *heartPath = CreateHeartPath(heartRect);
    Matrix matrix;
    matrix.Translate(-460, -480);
    st = heartPath->Flatten(&matrix);
    
    Bitmap bitmap(250,250);

    Graphics *bg = Graphics::FromImage(&bitmap);

    PathGradientBrush pathGrad(heartPath);

    INT count = 3;
    REAL blend[3];
    blend[0] = (REAL) 0;
    blend[1] = (REAL) 0.5;
    blend[2] = (REAL) 1;
    REAL positions[3];
    positions[0] = (REAL) 0;
    positions[1] = (REAL) 0.4;
    positions[2] = (REAL) 1;
    
    st = pathGrad.SetBlend(&blend[0], &positions[0], count);
    st = pathGrad.SetCenterColor(Color(128,0,128,80));
    st = pathGrad.SetWrapMode(WrapModeTileFlipXY);

    count = heartPath->GetPointCount();
    Color* surColors = (Color*)new Color[count];
    INT iColor = 255/count;
    for (INT i=0; i<count; i++)
    {
        float pos = (float)i/(count-1);
        surColors[i].SetValue(
            (((INT)(255.0f-i))   << 24) | 
            (((INT)(255.0f*pos)) << 16) | 
            ((INT)(255.0f*(1.0f-pos)))
        );
    }
    st = pathGrad.SetSurroundColors(surColors, &count);

    GraphicsPath r1, r2;
    RectF sqrect(0,140,600,1000);
    r1.AddRectangle(sqrect);
    sqrect.Width *= 2.3f;
    r2.AddRectangle(sqrect);

    st = bg->ScaleTransform(0.2f, 0.2f);
    
    st = bg->FillPath(&pathGrad, &r1);
    st = bg->TranslateTransform(400, 0);
    st = bg->ScaleTransform(0.66f, 1.33f);
    st = bg->FillPath(&pathGrad, &r2);

    st = g->DrawImage(&bitmap,0,0,0,0,250,250,UnitPixel);

    delete heartPath;
    delete surColors;
    delete bg;
}

CGradients::CGradients(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Misc");
	m_bRegression=bRegression;
}

void CGradients::Draw(Graphics *g)
{
    // Test FillRectangle call
    Color rc1(0xFF,0xFF,0,0);       // red
    Color rc2(0xFF,0xFF,0,0); 
    Color rc3(0x80,0xFF,0,0); 
    Color rc4(0x80,0,0xff,0);
    Color rc5(0x40,0,0,0xff); 
    Color rc6(0x40,0x80,0x80,0);

    SolidBrush rcb1(rc1);
    SolidBrush rcb2(rc2);
    SolidBrush rcb3(rc3);
    SolidBrush rcb4(rc4);
    SolidBrush rcb5(rc5);
    SolidBrush rcb6(rc6);

    g->FillRectangle(&rcb1, RectF((int)(0.0f/360.0f*TESTAREAWIDTH), (int)(0.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)));
    g->FillRectangle(&rcb2, RectF((int)(50.0f/360.0f*TESTAREAWIDTH), (int)(0.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)));
    g->FillRectangle(&rcb3, RectF((int)(100.0f/360.0f*TESTAREAWIDTH), (int)(0.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)));
    g->FillRectangle(&rcb4, RectF((int)(150.0f/360.0f*TESTAREAWIDTH), (int)(0.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)));
    g->FillRectangle(&rcb5, RectF((int)(200.0f/360.0f*TESTAREAWIDTH), (int)(0.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)));
    g->FillRectangle(&rcb6, RectF((int)(250.0f/360.0f*TESTAREAWIDTH), (int)(0.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)));

    RectF rf[6] = {
        RectF((int)(0.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)),
        RectF((int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)),
        RectF((int)(100.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)),
        RectF((int)(150.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)),
        RectF((int)(200.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT)),
        RectF((int)(250.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT), (int)(50.0f/360.0f*TESTAREAWIDTH), (int)(50.0f/360.0f*TESTAREAHEIGHT))
    };

    RectF polyRect;
    Color centerColor(255, 255, 255, 255);
    Color boundaryColor(255, 0, 0, 0);

    REAL width = 4; // Pen width

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 3, 3);

    Color colors[5] = {
        Color(255, 255, 255, 255),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 0, 0, 0)
    };
    PointF points[7];


    // Rotate a brush.
    GpMatrix xForm;
    xForm.Rotate(155);

    // Change the wrapping mode and fill.

    REAL blend[10];
    Color presetColors[10];
    Color presetColorsb[10];
    REAL positions[10];
    INT count;

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);

    g->DrawRectangle(&blackPen, brushRect);

    // Create a radial gradient brush.

    brushRect.X = (int)(380.0f/360.0f*TESTAREAWIDTH);
    brushRect.Y = (int)(130.0f/360.0f*TESTAREAHEIGHT);
    brushRect.Width = (int)(60.0f/360.0f*TESTAREAWIDTH);
    brushRect.Height = (int)(32.0f/360.0f*TESTAREAHEIGHT);
    PointF center;
    center.X = brushRect.X + brushRect.Width/2;
    center.Y = brushRect.Y + brushRect.Height/2;
    xForm.Reset();
    xForm.RotateAt(-30, center, MatrixOrderAppend);
    
    // Triangle Gradient Brush no longer supported.
    
    points[0].X = (int)(200.0f/360.0f*TESTAREAWIDTH);
    points[0].Y = (int)(300.0f/360.0f*TESTAREAHEIGHT);
    points[1].X = (int)(280.0f/360.0f*TESTAREAWIDTH);
    points[1].Y = (int)(350.0f/360.0f*TESTAREAHEIGHT);
    points[2].X = (int)(220.0f/360.0f*TESTAREAWIDTH);
    points[2].Y = (int)(420.0f/360.0f*TESTAREAHEIGHT);
    points[3].X = (int)(160.0f/360.0f*TESTAREAWIDTH);
    points[3].Y = (int)(440.0f/360.0f*TESTAREAHEIGHT);
    points[4].X = (int)(120.0f/360.0f*TESTAREAWIDTH);
    points[4].Y = (int)(370.0f/360.0f*TESTAREAHEIGHT);

    Matrix matrix;
    matrix.Translate((int)(20.0f/360.0f*TESTAREAWIDTH), -(int)(160.0f/360.0f*TESTAREAHEIGHT));

    matrix.TransformPoints(points, 5);

    PathGradientBrush polyGrad(points, 5, WrapModeTile);

    count = 3;
    blend[0] = (REAL) 0;
    blend[1] = (REAL) 0;
    blend[2] = (REAL) 1;
    positions[0] = (REAL) 0;
    positions[1] = (REAL) 0.4;
    positions[2] = (REAL) 1;

    // Test for blending factors.

    polyGrad.SetBlend(&blend[0], &positions[0], count);

    polyGrad.SetCenterColor(centerColor);
    count = 5;
    polyGrad.SetSurroundColors(colors, &count);
    polyRect.X = 0;
    polyRect.Y = 0;
    polyRect.Width = (int) TESTAREAWIDTH;
    polyRect.Height = (int) TESTAREAHEIGHT;
    g->FillRectangle(&polyGrad, polyRect);

    // Create a heart shaped path.

    RectF rect;
    rect.X = (int)(300.0f/360.0f*TESTAREAWIDTH);
    rect.Y = (int)(300.0f/360.0f*TESTAREAHEIGHT);
    rect.Width = (int)(150.0f/360.0f*TESTAREAWIDTH);
    rect.Height = (int)(150.0f/360.0f*TESTAREAHEIGHT);
    GraphicsPath *path = CreateHeartPath(rect);

    // Create a gradient from a path.

    PathGradientBrush pathGrad(path);
    delete path;

    pathGrad.SetCenterColor(centerColor);
    count = pathGrad.GetSurroundColorCount();
    Color* surColors = (Color*)new Color[count];
    pathGrad.GetSurroundColors(surColors, &count);
    surColors[0] = Color(255, 255, 0, 0);
    count = 1;
    pathGrad.SetSurroundColors(surColors, &count);

    pathGrad.GetRectangle(&polyRect);

    // Set the rect focus.

    PointF centerPt;

    pathGrad.GetCenterPoint(&centerPt);
    centerPt.X -= 3;
    centerPt.Y += 6;
    pathGrad.SetCenterPoint(centerPt);
    REAL xScale, yScale;
    pathGrad.GetFocusScales(&xScale, &yScale);
    xScale = 0.4f;
    yScale = 0.3f;
    pathGrad.SetFocusScales(xScale, yScale);

    g->FillRectangle(&pathGrad, polyRect);

    RectF lineRect((int)(120.0f/360.0f*TESTAREAWIDTH), (int)(0.0f/360.0f*TESTAREAHEIGHT), (int)(200.0f/360.0f*TESTAREAWIDTH), (int)(60.0f/360.0f*TESTAREAHEIGHT));
    Color color1(200, 255, 255, 0);
    Color color2(200, 0, 0, 255);

    LinearGradientBrush LinearGrad(lineRect, color1, color1,
                        LinearGradientModeForwardDiagonal);

    RectF lineRectb((int)(120.0f/360.0f*TESTAREAWIDTH), (int)(300.0f/360.0f*TESTAREAHEIGHT), (int)(200.0f/360.0f*TESTAREAWIDTH), (int)(60.0f/360.0f*TESTAREAHEIGHT));
    Color color1b(20, 255, 255, 0);
    Color color2b(20, 0, 0, 255);

    LinearGradientBrush LinearGradb(lineRectb, color1b, color1b,
                        LinearGradientModeForwardDiagonal);

    // Test for preset colors

    presetColors[0] = Color(200, 0, 255, 255);
    presetColors[1] = Color(200, 255, 255, 0);
    presetColors[2] = Color(200, 0, 255, 0);
    presetColorsb[0] = Color(20, 0, 255, 255);
    presetColorsb[1] = Color(20, 255, 255, 0);
    presetColorsb[2] = Color(20, 0, 255, 0);
    count = 3;

    count = 3;
    blend[0] = (REAL) 0;
    blend[1] = (REAL) 0;
    blend[2] = (REAL) 1;
    positions[0] = (REAL) 0;
    positions[1] = (REAL) 0.4;
    positions[2] = (REAL) 1;

    LinearGrad.SetInterpolationColors(&presetColors[0], &positions[0], count);
    LinearGradb.SetInterpolationColors(&presetColorsb[0], &positions[0], count);

    g->FillRectangle(&LinearGrad, lineRect);
    g->FillRectangle(&LinearGradb, lineRectb);
    
    RectF rectl(90.0f/360.0f*TESTAREAWIDTH, 120.0f/360.0f*TESTAREAHEIGHT, 120.0f/360.0f*TESTAREAWIDTH, 120.0f/360.0f*TESTAREAHEIGHT);
    PointF pt1(rectl.X+rectl.Width/2.0f, rectl.Y);
    PointF pt2(rectl.X+rectl.Width/2.0f, rectl.Y+rectl.Height);

    LinearGradientBrush linbrush(pt1, pt2,
                                 Color(0xFF, 0xFF, 0, 0), 
                                 Color(0xFF, 0, 0xFF, 0));

    GraphicsPath pathl;
    pathl.AddRectangle(rectl);

    SolidBrush sbrush(Color(0xFF,0xFF,0,0));

    g->FillRectangle(&sbrush, rectl);
    g->FillPath(&linbrush, &pathl);
}


CAlphaGradient::CAlphaGradient(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Premultiplied Interpolation");
	m_bRegression=bRegression;
}

void CAlphaGradient::Draw(Graphics *g)
{
    GraphicsPath gp;
    
    PointF points[3];
    
    points[0].X = (int)(0.5f*TESTAREAWIDTH);
    points[0].Y = (int)(0.0f*TESTAREAHEIGHT);
    points[1].X = (int)(1.0f*TESTAREAWIDTH);
    points[1].Y = (int)(0.7f*TESTAREAHEIGHT);
    points[2].X = (int)(0.0f*TESTAREAWIDTH);
    points[2].Y = (int)(0.4f*TESTAREAHEIGHT);
    
    gp.AddPolygon(points, 3);
    
    Color colors[3] = { 0xffff0000, 0xff00ff00, 0x00000000 };
    int count = 3; 
    
    PathGradientBrush brush(&gp);
    brush.SetSurroundColors(colors, &count);
    
    brush.SetCenterColor(0xaa555500);
    brush.SetCenterPoint(PointF(
        (points[0].X+points[1].X+points[2].X)/3.0f,
        (points[0].Y+points[1].Y+points[2].Y)/3.0f
    ));
    
    g->FillPath(&brush, &gp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cgradients.h ===
/******************************Module*Header*******************************\
* Module Name: CGradients.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CGRADIENTS_H
#define __CGRADIENTS_H

#include "CPrimitive.h"

GraphicsPath *CreateHeartPath(const RectF& rect);

class CGradients : public CPrimitive  
{
public:
	CGradients(BOOL bRegression);
	void Draw(Graphics *g);
};

class CScaledGradients : public CPrimitive  
{
public:
	CScaledGradients(BOOL bRegression);
	void Draw(Graphics *g);
};

class CAlphaGradient : public CPrimitive  
{
public:
	CAlphaGradient(BOOL bRegression);
	void Draw(Graphics *g);
};


#define GRADIENT_GLOBALS \
CGradients g_Gradients(true); \
CScaledGradients g_ScaledGradients(true); \
CAlphaGradient g_AlphaGradient(true);

#define GRADIENT_INIT \
g_Gradients.Init();\
g_ScaledGradients.Init();\
g_AlphaGradient.Init();



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\chalfpixel.h ===
/******************************Module*Header*******************************\
* Module Name: CAntialias.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CHALFPIXEL_H
#define __CHALFPIXEL_H

#include "CSetting.h"

class CHalfPixel : public CSetting  
{
public:
	CHalfPixel(BOOL bRegression);
	virtual ~CHalfPixel();

	void Set(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cfunctest.h ===
/******************************Module*Header*******************************\
* Module Name: CFuncTest.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CFUNCTEST_H
#define __CFUNCTEST_H

#include "Global.h"
#include "CPrimitive.h"
#include "CSetting.h"
#include "COutput.h"

class CFuncTest  
{
public:
	CFuncTest();
	~CFuncTest();

	BOOL Init(HWND hWndParent);								// Initializes functest
	void RunOptions();										// Toggles option dialog
	static INT_PTR CALLBACK DlgProc(HWND hWndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);

	BOOL AddPrimitive(CPrimitive *pPrimitive);				// Add a primitive to test list
	BOOL AddOutput(COutput *pOutput);						// Add a graphics output to test list
	BOOL AddSetting(CSetting *pSetting);					// Add a graphics setting to test list

	RECT GetTestRect(int nCol,int nRow);					// Gets the test area located at nCol/nRow
	void RunTest(COutput *pOutput,CPrimitive *pPrimitive);	// Runs a specific test on a specific output
	void InitRun();											// Must be called before running a series of tests
	void EndRun();											// Must be called after running a series of tests
	void Run();												// Run the selected tests
	void RunRegression();									// Run regression tests

	void ClearAllSettings();								// Sets all settings in the list box to m_bUseSetting=false

	HWND m_hWndMain;										// Main window
	HWND m_hWndDlg;											// Dialog window
	BOOL m_bUsePageDelay;									// Use page delay or page pause
	BOOL m_bEraseBkgd;										// Erase old test background
	BOOL m_bAppendTest;										// Appends test to previous tests
	int m_nPageDelay;										// Delay after each graphics page
	int m_nPageRow;											// Row to draw next test
	int m_nPageCol;											// Column to draw next test
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\chdc.h ===
/******************************Module*Header*******************************\
* Module Name: CHDC.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CHDC_H
#define __CHDC_H

#include "COutput.h"

class CHDC : public COutput  
{
public:
	CHDC(BOOL bRegression);
	virtual ~CHDC();

	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	HPALETTE m_hPal;
	HPALETTE m_hOldPal;
	HDC m_hDC;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\chalftone.cpp ===
/******************************Module*Header*******************************\
* Module Name: CHalftone.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CHalftone.h"

CHalftone::CHalftone(BOOL bRegression)
{
	strcpy(m_szName,"Halftone");
	m_bRegression=bRegression;
}

CHalftone::~CHalftone()
{

}

void CHalftone::Set(Graphics *g)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\chalfpixel.cpp ===
/******************************Module*Header*******************************\
* Module Name: CAntialias.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CHalfPixel.h"

CHalfPixel::CHalfPixel(BOOL bRegression)
{
	strcpy(m_szName,"Half Pixel Offset");
	m_bRegression=bRegression;
}

CHalfPixel::~CHalfPixel()
{
}

void CHalfPixel::Set(Graphics *g)
{
    g->SetPixelOffsetMode(
        m_bUseSetting ? PixelOffsetModeHalf : PixelOffsetModeNone
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\chwnd.h ===
/******************************Module*Header*******************************\
* Module Name: CHWND.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CHWND_H
#define __CHWND_H

#include "COutput.h"

class CHWND : public COutput  
{
public:
	CHWND(BOOL bRegression);
	virtual ~CHWND();

	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\chalftone.h ===
/******************************Module*Header*******************************\
* Module Name: CHalftone.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CHALFTONE_H
#define __CHALFTONE_H

#include "CSetting.h"

class CHalftone : public CSetting  
{
public:
	CHalftone(BOOL bRegression);
	virtual ~CHalftone();

	void Set(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\chatch.h ===
/******************************Module*Header*******************************\
* Module Name: CHatch.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CHATCH_H
#define __CHATCH_H

#include "CSetting.h"

class CHatch : public CSetting
{
public:
	CHatch(BOOL bRegression);
	virtual ~CHatch();

	void Set(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\chatch.cpp ===
/******************************Module*Header*******************************\
* Module Name: CHatch.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CHatch.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CHatch::CHatch(BOOL bRegression)
{
	strcpy(m_szName,"Hatch");
	m_bRegression=bRegression;
}

CHatch::~CHatch()
{
}

void CHatch::Set(Graphics *g)
{
    if (!m_bUseSetting)
    return;

    Color foreColor(50, 0 , 0, 0);
    Color backColor(128, 255, 255, 255);

    HatchBrush hatch(
        HatchStyleDiagonalCross, 
        foreColor, 
        backColor
    );

    g->FillRectangle(
        &hatch, 
        0, 0, 
        (int)TESTAREAWIDTH, 
        (int)TESTAREAHEIGHT
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\chdc.cpp ===
/******************************Module*Header*******************************\
* Module Name: CHDC.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CHDC.h"
#include "CFuncTest.h"
#include "CHalftone.h"

extern CFuncTest g_FuncTest;
extern CHalftone g_Halftone;

CHDC::CHDC(BOOL bRegression)
{
	strcpy(m_szName,"HDC");
	m_hPal=NULL;
	m_hOldPal=NULL;
	m_hDC=NULL;
	m_bRegression=bRegression;
}

CHDC::~CHDC()
{
}

Graphics *CHDC::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;

	m_hDC=GetDC(g_FuncTest.m_hWndMain);
	if (g_Halftone.m_bUseSetting)
	{
		m_hPal=DllExports::GdipCreateHalftonePalette();
		m_hOldPal=SelectPalette(m_hDC,m_hPal,FALSE);
		RealizePalette(m_hDC);
	}
	g=Graphics::FromHDC(m_hDC);

	return g;
}

void CHDC::PostDraw(RECT rTestArea)
{
	if (m_hOldPal)
		SelectPalette(m_hDC,m_hOldPal,FALSE);

	ReleaseDC(g_FuncTest.m_hWndMain,m_hDC);
	DeleteObject(m_hPal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\chwnd.cpp ===
/******************************Module*Header*******************************\
* Module Name: CHWND.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CHWND.h"
#include "CFuncTest.h"
#include "CHalftone.h"

extern CFuncTest g_FuncTest;
extern CHalftone g_Halftone;

CHWND::CHWND(BOOL bRegression)
{
	strcpy(m_szName,"HWND");
	m_bRegression=bRegression;
}

CHWND::~CHWND()
{
}

Graphics *CHWND::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *g=NULL;

	g=Graphics::FromHWND(g_FuncTest.m_hWndMain);

	return g;
}

void CHWND::PostDraw(RECT rTestArea)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cimaging.cpp ===
/******************************Module*Header*******************************\
* Module Name: CImaging.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CImaging.h"

CImaging::CImaging(BOOL bRegression)
{
	strcpy(m_szName,"Image : Misc");
	m_bRegression=bRegression;
}

CImaging::~CImaging()
{
}

BOOL CALLBACK CImaging::MyDrawImageAbort(VOID* data)
{
    UINT *count = (UINT*) data;

    *count += 1;

    return FALSE;
}

void CImaging::Draw(Graphics *g)
{

    Point points[4];
    REAL width = 4;     // Pen width

    WCHAR filename[256];
	wcscpy(filename,L"..\\data\\4x5_trans_Q60_cropped_1k.jpg");

    // Open the image with the appropriate ICM mode.

    Bitmap *bitmap = new Bitmap(filename, TRUE);

    // Create a texture brush.

    Unit u;
    RectF copyRect;
    bitmap->GetBounds(&copyRect, &u);

    // Choose an interesting portion of the source image to display
    // in the texture brush.

    copyRect.X = copyRect.Width/2-1;
    copyRect.Width = copyRect.Width/4-1;
    copyRect.X += copyRect.Width;
    copyRect.Height = copyRect.Height/2-1;
  
    // Our ICM profile is hacked to flip the red and blue color channels
    // Apply a recolor matrix to flip them back so that if something breaks
    // ICM, the picture will look blue instead of the familiar colors.

    ImageAttributes *img = new ImageAttributes();
    img->SetWrapMode(WrapModeTile, Color(0xffff0000), FALSE);
    ColorMatrix flipRedBlue = 
       {0, 0, 1, 0, 0,
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1};
    img->SetColorMatrix(&flipRedBlue);
    img->SetWrapMode(WrapModeTile, Color(0xffff0000), FALSE);

    // Create a texture brush.                      
    TextureBrush textureBrush(bitmap, copyRect, img);

    // Create a radial gradient pen.

    Color redColor(255, 0, 0);

    SolidBrush redBrush(redColor);
    Pen redPen(&redBrush, width);

    GraphicsPath *path;

    points[0].X = (int)((float)(100*3+300)/1024.0f*TESTAREAWIDTH);
    points[0].Y = (int)((float)(60*3-100)/768.0f*TESTAREAHEIGHT);
    points[1].X = (int)((float)(-50*3+300)/1024.0f*TESTAREAWIDTH);
    points[1].Y = (int)((float)(60*3-100)/768.0f*TESTAREAHEIGHT);
    points[2].X = (int)((float)(150*3+300)/1024.0f*TESTAREAWIDTH);
    points[2].Y = (int)((float)(250*3-100)/768.0f*TESTAREAHEIGHT);
    points[3].X = (int)((float)(200*3+300)/1024.0f*TESTAREAWIDTH);
    points[3].Y = (int)((float)(120*3-100)/768.0f*TESTAREAHEIGHT);
    path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);    
    g->FillPath(&textureBrush, path);
    g->DrawPath(&redPen, path);

    delete img;
    delete path;
    delete bitmap;


    // Draw the apple png

    PointF destPoints[3];

    destPoints[0].X = (float)300/1024.0f*TESTAREAWIDTH;
    destPoints[0].Y = (float)50/768.0f*TESTAREAHEIGHT;
    destPoints[1].X = (float)450/1024.0f*TESTAREAWIDTH;
    destPoints[1].Y = (float)50/768.0f*TESTAREAHEIGHT;
    destPoints[2].X = (float)240/1024.0f*TESTAREAWIDTH;
    destPoints[2].Y = (float)200/768.0f*TESTAREAHEIGHT;
 
    Matrix mat;
    mat.Translate(0, 100);
    mat.TransformPoints(&destPoints[0], 3);
    wcscpy(filename, L"../data/apple1.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);
 
    delete bitmap;


    // Draw the dog png

    destPoints[0].X = (float)30/1024.0f*TESTAREAWIDTH;
    destPoints[0].Y = (float)200/768.0f*TESTAREAHEIGHT;
    destPoints[1].X = (float)200/1024.0f*TESTAREAWIDTH;
    destPoints[1].Y = (float)200/768.0f*TESTAREAHEIGHT;
    destPoints[2].X = (float)200/1024.0f*TESTAREAWIDTH;
    destPoints[2].Y = (float)420/768.0f*TESTAREAHEIGHT;

    wcscpy(filename, L"..\\data\\dog2.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);
    delete bitmap;
    
    // Draw the Balmer jpeg

    wcscpy(filename, L"..\\data\\ballmer.jpg");    
    bitmap = new Bitmap(filename);

    RectF destRect(
        TESTAREAWIDTH/2.0f, 
        TESTAREAHEIGHT/2.0f, 
        TESTAREAWIDTH/2.0f, 
        TESTAREAHEIGHT/2.0f
    );
    
    RectF srcRect;
    srcRect.X = 100;
    srcRect.Y = 40;
    srcRect.Width = 200;
    srcRect.Height = 200;

    g->DrawImage(
        bitmap, 
        destRect, 
        srcRect.X, 
        srcRect.Y,
        srcRect.Width, 
        srcRect.Height, 
        UnitPixel
    );

    delete bitmap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cimaging.h ===
/******************************Module*Header*******************************\
* Module Name: CImaging.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CIMAGING_H
#define __CIMAGING_H

#include "CPrimitive.h"

class CImaging : public CPrimitive  
{
public:
	CImaging(BOOL bRegression);
	virtual ~CImaging();

	void Draw(Graphics *g);

	static BOOL CALLBACK MyDrawImageAbort(VOID* data);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cinsetlines.cpp ===
/******************************Module*Header*******************************\
* Module Name: CInsetLines.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CInsetLines.h"

CInsetLines::CInsetLines(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Inset Pen");
	m_bRegression=bRegression;
}

void CInsetLines::Draw(Graphics *g)
{
    INT count = 5;
    BYTE t[] = {0x00, 0x01, 0x01, 0x01, 0x81};

    PointF p[5];

    p[0].X = 104.0f/450.0f*TESTAREAWIDTH;  p[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p[1].X = 379.0f/450.0f*TESTAREAWIDTH;  p[1].Y = 97.0f/450.0f*TESTAREAHEIGHT;
    p[2].X = 385.0f/450.0f*TESTAREAWIDTH;  p[2].Y = 355.0f/450.0f*TESTAREAHEIGHT;
    p[3].X = 249.0f/450.0f*TESTAREAWIDTH;  p[3].Y = 47.0f/450.0f*TESTAREAHEIGHT;
    p[4].X = 109.0f/450.0f*TESTAREAWIDTH;  p[4].Y = 350.0f/450.0f*TESTAREAHEIGHT;

    PointF p1[5];
    p1[0].X = 120.0f/450.0f*TESTAREAWIDTH;	p1[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p1[1].X = 362.0f/450.0f*TESTAREAWIDTH;	p1[1].Y = 64.0f/450.0f*TESTAREAHEIGHT;
    p1[2].X = 383.0f/450.0f*TESTAREAWIDTH;	p1[2].Y = 395.0f/450.0f*TESTAREAHEIGHT;
    p1[3].X = 92.0f/450.0f*TESTAREAWIDTH;	p1[3].Y = 394.0f/450.0f*TESTAREAHEIGHT;
    p1[4].X = 447.0f/450.0f*TESTAREAWIDTH;	p1[4].Y = 243.0f/450.0f*TESTAREAHEIGHT;

    GraphicsPath* path = new GraphicsPath(p1, t, count);
    path->CloseFigure();
    path->AddLine(50, 100, 150, 150);

    Color blackColor(0, 0, 0);

    SolidBrush brush(blackColor);

    REAL width = 10;
    Pen pen(&brush, width);
    pen.SetAlignment(PenAlignmentInset);
        
    g->DrawPath(&pen, path);

    delete path;
}

CInset2::CInset2(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Inset Pen, Dash");
	m_bRegression=bRegression;
}

void CInset2::Draw(Graphics *g)
{
    INT count = 5;
    BYTE t[] = {0x00, 0x01, 0x01, 0x01, 0x81};

    PointF p[5];

    p[0].X = 104.0f/450.0f*TESTAREAWIDTH;  p[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p[1].X = 379.0f/450.0f*TESTAREAWIDTH;  p[1].Y = 97.0f/450.0f*TESTAREAHEIGHT;
    p[2].X = 385.0f/450.0f*TESTAREAWIDTH;  p[2].Y = 355.0f/450.0f*TESTAREAHEIGHT;
    p[3].X = 249.0f/450.0f*TESTAREAWIDTH;  p[3].Y = 47.0f/450.0f*TESTAREAHEIGHT;
    p[4].X = 109.0f/450.0f*TESTAREAWIDTH;  p[4].Y = 350.0f/450.0f*TESTAREAHEIGHT;

    PointF p1[5];
    p1[0].X = 120.0f/450.0f*TESTAREAWIDTH;	p1[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p1[1].X = 362.0f/450.0f*TESTAREAWIDTH;	p1[1].Y = 64.0f/450.0f*TESTAREAHEIGHT;
    p1[2].X = 383.0f/450.0f*TESTAREAWIDTH;	p1[2].Y = 395.0f/450.0f*TESTAREAHEIGHT;
    p1[3].X = 92.0f/450.0f*TESTAREAWIDTH;	p1[3].Y = 394.0f/450.0f*TESTAREAHEIGHT;
    p1[4].X = 447.0f/450.0f*TESTAREAWIDTH;	p1[4].Y = 243.0f/450.0f*TESTAREAHEIGHT;

    GraphicsPath* path = new GraphicsPath(p1, t, count);
    path->CloseFigure();
    path->AddLine(50, 100, 150, 150);

    Color blackColor(0, 0, 0);

    SolidBrush brush(blackColor);

    REAL width = 10.0f;
    Pen pen(&brush, width);
    pen.SetAlignment(PenAlignmentInset);
    pen.SetDashStyle(DashStyleDashDot);
    pen.SetDashCap(DashCapRound);
        
    g->DrawPath(&pen, path);

    delete path;
}


CInset3::CInset3(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Inset Pen, Compound");
	m_bRegression=bRegression;
}

void CInset3::Draw(Graphics *g)
{
    INT count = 5;
    BYTE t[] = {0x00, 0x01, 0x01, 0x01, 0x81};

    PointF p[5];

    p[0].X = 104.0f/450.0f*TESTAREAWIDTH;  p[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p[1].X = 379.0f/450.0f*TESTAREAWIDTH;  p[1].Y = 97.0f/450.0f*TESTAREAHEIGHT;
    p[2].X = 385.0f/450.0f*TESTAREAWIDTH;  p[2].Y = 355.0f/450.0f*TESTAREAHEIGHT;
    p[3].X = 249.0f/450.0f*TESTAREAWIDTH;  p[3].Y = 47.0f/450.0f*TESTAREAHEIGHT;
    p[4].X = 109.0f/450.0f*TESTAREAWIDTH;  p[4].Y = 350.0f/450.0f*TESTAREAHEIGHT;

    PointF p1[5];
    p1[0].X = 120.0f/450.0f*TESTAREAWIDTH;	p1[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p1[1].X = 362.0f/450.0f*TESTAREAWIDTH;	p1[1].Y = 64.0f/450.0f*TESTAREAHEIGHT;
    p1[2].X = 383.0f/450.0f*TESTAREAWIDTH;	p1[2].Y = 395.0f/450.0f*TESTAREAHEIGHT;
    p1[3].X = 92.0f/450.0f*TESTAREAWIDTH;	p1[3].Y = 394.0f/450.0f*TESTAREAHEIGHT;
    p1[4].X = 447.0f/450.0f*TESTAREAWIDTH;	p1[4].Y = 243.0f/450.0f*TESTAREAHEIGHT;

    GraphicsPath* path = new GraphicsPath(p1, t, count);
    path->CloseFigure();
    path->AddLine(50, 100, 150, 150);

    Color blackColor(0, 0, 0);

    SolidBrush brush(blackColor);

    REAL width = 10.0f;
    Pen pen(&brush, width);
    pen.SetAlignment(PenAlignmentInset);
    
    float carray[4] = { 0.0f, 0.3f, 0.5f, 1.0f };
    pen.SetCompoundArray(carray, 4);
        
    g->DrawPath(&pen, path);

    delete path;
}

CInset4::CInset4(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Compound, Dash");
	m_bRegression=bRegression;
}

void CInset4::Draw(Graphics *g)
{
    INT count = 5;
    BYTE t[] = {0x00, 0x01, 0x01, 0x01, 0x81};

    PointF p[5];

    p[0].X = 104.0f/450.0f*TESTAREAWIDTH;  p[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p[1].X = 379.0f/450.0f*TESTAREAWIDTH;  p[1].Y = 97.0f/450.0f*TESTAREAHEIGHT;
    p[2].X = 385.0f/450.0f*TESTAREAWIDTH;  p[2].Y = 355.0f/450.0f*TESTAREAHEIGHT;
    p[3].X = 249.0f/450.0f*TESTAREAWIDTH;  p[3].Y = 47.0f/450.0f*TESTAREAHEIGHT;
    p[4].X = 109.0f/450.0f*TESTAREAWIDTH;  p[4].Y = 350.0f/450.0f*TESTAREAHEIGHT;

    PointF p1[5];
    p1[0].X = 120.0f/450.0f*TESTAREAWIDTH;	p1[0].Y = 98.0f/450.0f*TESTAREAHEIGHT;
    p1[1].X = 362.0f/450.0f*TESTAREAWIDTH;	p1[1].Y = 64.0f/450.0f*TESTAREAHEIGHT;
    p1[2].X = 383.0f/450.0f*TESTAREAWIDTH;	p1[2].Y = 395.0f/450.0f*TESTAREAHEIGHT;
    p1[3].X = 92.0f/450.0f*TESTAREAWIDTH;	p1[3].Y = 394.0f/450.0f*TESTAREAHEIGHT;
    p1[4].X = 447.0f/450.0f*TESTAREAWIDTH;	p1[4].Y = 243.0f/450.0f*TESTAREAHEIGHT;

    GraphicsPath* path = new GraphicsPath(p1, t, count);
    path->CloseFigure();
    path->AddLine(50, 100, 150, 150);

    Color blackColor(0, 0, 0);

    SolidBrush brush(blackColor);

    REAL width = 10.0f;
    Pen pen(&brush, width);
    
    pen.SetDashCap(DashCapRound);
    pen.SetDashStyle(DashStyleDashDot);
    float carray[8] = { 0.0f, 0.15f, 0.25f, 0.5f, 0.5f, 0.75f, 0.85f, 1.0f };
//    pen.SetCompoundArray(carray, 8);
        
    g->DrawPath(&pen, path);

    delete path;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cinsetlines.h ===
/******************************Module*Header*******************************\
* Module Name: CInsetLines.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CINSETLINES_H
#define __CINSETLINES_H

#include "CPrimitive.h"

class CInsetLines : public CPrimitive  
{
public:
	CInsetLines(BOOL bRegression);
	void Draw(Graphics *g);
};

class CInset2 : public CPrimitive  
{
public:
	CInset2(BOOL bRegression);
	void Draw(Graphics *g);
};

class CInset3 : public CPrimitive  
{
public:
	CInset3(BOOL bRegression);
	void Draw(Graphics *g);
};

class CInset4 : public CPrimitive  
{
public:
	CInset4(BOOL bRegression);
	void Draw(Graphics *g);
};


#define INSET_GLOBALS \
CInsetLines g_Inset(true);\
CInset2 g_Inset2(true);\
CInset3 g_Inset3(true);\
CInset4 g_Inset4(true);

#define INSET_INIT \
g_Inset.Init();\
g_Inset2.Init();\
g_Inset3.Init();\
g_Inset4.Init();



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\coutput.cpp ===
/******************************Module*Header*******************************\
* Module Name: COutput.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "COutput.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

COutput::COutput()
{
	strcpy(m_szName,"No name assigned");
	m_bRegression=false;
}

COutput::~COutput()
{

}

BOOL COutput::Init()
{
	return g_FuncTest.AddOutput(this);
}

void COutput::PostDraw(RECT rTestArea)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\coutput.h ===
/******************************Module*Header*******************************\
* Module Name: COutput.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __COUTPUT_H
#define __COUTPUT_H

#include "Global.h"

class COutput  
{
public:
	COutput();
	virtual ~COutput();

	virtual BOOL Init();										// Add output to output list in functest dialog
	virtual Graphics *PreDraw(int &nOffsetX,int &nOffsetY)=0;	// Set up graphics at the given X,Y offset
	virtual void PostDraw(RECT rTestArea);						// Finish off graphics at rTestArea

	char m_szName[256];
	BOOL m_bRegression;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cmetafile.cpp ===
/******************************Module*Header*******************************\
* Module Name: CMetafile.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  
*
* Created:  14-Sep-2000 - DCurtis
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CMetafile.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CMetafile::CMetafile(BOOL bRegression,MetafileType metafileType,BOOL recordFile)
{
	m_bRegression = bRegression;

    switch (metafileType)
    {
#if 0   // not yet implemented
    case MetafileTypeWmf:                // Standard WMF
	    sprintf(m_szName,"Metafile WMF");
        RecordType = EmfTypeEmfOnly;
        break;
        
    case MetafileTypeWmfPlaceable:      // Placeable Metafile format
	    sprintf(m_szName,"Metafile WMF Placeable");
        RecordType = EmfTypeEmfOnly;
        break;
#endif        
    case MetafileTypeEmf:                // EMF (not EMF+)
	    sprintf(m_szName,"Metafile EMF");
        RecordType = EmfTypeEmfOnly;
        break;
        
    case MetafileTypeEmfPlusOnly:        // EMF+ without dual, down-level records
	    sprintf(m_szName,"Metafile EMF+");
        RecordType = EmfTypeEmfPlusOnly;
        break;
        
    case MetafileTypeEmfPlusDual:        // EMF+ with dual, down-level records
    default:
	    sprintf(m_szName,"Metafile EMF+ Dual");
        RecordType = EmfTypeEmfPlusDual;
        break;
    }  

    if (recordFile) 
    {
        strcat(m_szName, "(File)");
    }
    RecordFile = recordFile;
    FinalType = metafileType;
}

CMetafile::~CMetafile()
{
    delete GdipMetafile;
}

Graphics *
CMetafile::PreDraw(int &nOffsetX,int &nOffsetY)
{
	Graphics *      g = NULL;
	HDC             referenceHdc = ::GetDC(g_FuncTest.m_hWndMain);
    RectF           frameRect;
    
    if (referenceHdc != NULL)
    {
        frameRect.X = frameRect.Y = 0;
        frameRect.Width  = (int)TESTAREAWIDTH;
        frameRect.Height = (int)TESTAREAHEIGHT;

        if (RecordFile) 
        {
            GdipMetafile = new Metafile(L"test.emf",
                                        referenceHdc,
                                        RecordType,
                                        NULL);
        }
        else
        {
            GdipMetafile = new Metafile(referenceHdc,
                                        frameRect,
                                        MetafileFrameUnitPixel,
                                        RecordType,
                                        NULL);
        }
        g = new Graphics(GdipMetafile);
    }

	// Since we are doing the test on another surface
	nOffsetX = 0;
	nOffsetY = 0;

	ReleaseDC(g_FuncTest.m_hWndMain, referenceHdc);

	return g;
}

void CMetafile::PostDraw(RECT rTestArea)
{
	// play from the Metafile to screen so we see the results
	
    if (RecordFile) 
    {
        delete GdipMetafile;
        // close file

        GdipMetafile = new Metafile(L"test.emf");
        // read from file
    }

    HDC hdcOrig = GetDC(g_FuncTest.m_hWndMain);
    {
        Graphics    g(hdcOrig);

        RectF       destRect((REAL)rTestArea.left, (REAL)rTestArea.top, TESTAREAWIDTH, TESTAREAHEIGHT);

        g.DrawImage(GdipMetafile, destRect, 0, 0, TESTAREAWIDTH, TESTAREAHEIGHT, UnitPixel);
    }

	ReleaseDC(g_FuncTest.m_hWndMain, hdcOrig);

    delete GdipMetafile;
    GdipMetafile = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\clines.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   <an unabbreviated name for the module (not the filename)>
*
* Abstract:
*
*   <Description of what this module does>
*
* Notes:
*
*   <optional>
*
* Created:
*
*   08/28/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _CLINES_HPP
#define _CLINES_HPP


#include "CPrimitive.h"

class CLinesNominal : public CPrimitive
{
public:
	CLinesNominal(BOOL bRegression);
	void Draw(Graphics *g);
};

class CLinesFat : public CPrimitive
{
public:
	CLinesFat(BOOL bRegression);
	void Draw(Graphics *g);
};

class CLinesMirrorPen : public CPrimitive
{
public:
	CLinesMirrorPen(BOOL bRegression);
	void Draw(Graphics *g);
};


#define LINES_GLOBALS \
CLinesNominal g_LinesNominal(true);\
CLinesFat g_LinesFat(true);\
CLinesMirrorPen g_LinesMirrorPen(true);

#define LINES_INIT \
g_LinesNominal.Init();\
g_LinesFat.Init();\
g_LinesMirrorPen.Init();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cmetafile.h ===
/******************************Module*Header*******************************\
* Module Name: CMetafile.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  
*
* Created:  14-Sep-2000 - DCurtis
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CMETAFILE_H
#define __CMETAFILE_H

#include "COutput.h"

class CMetafile : public COutput  
{
public:
   // CMetafile(BOOL bRegression, MetafileType metafileType)
   // : CMetafile(bRegression, metafileType, FALSE) {};

	CMetafile(BOOL bRegression, MetafileType metafileType, BOOL recordFile = FALSE);
	virtual ~CMetafile();

	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	Gdiplus::Metafile *		GdipMetafile;
    EmfType                 RecordType;
    MetafileType            FinalType;
    BOOL                    RecordFile;
};

#endif	// __CMETAFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\clines.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   <an unabbreviated name for the module (not the filename)>
*
* Abstract:
*
*   <Description of what this module does>
*
* Notes:
*
*   <optional>
*
* Created:
*
*   08/28/2000 asecchia
*      Created it.
*
**************************************************************************/

/**************************************************************************
*
* Function Description:
*
*   <Description of what the function does>
*
* Arguments:
*
*   [<blank> | OUT | IN/OUT] argument-name - description of argument
*   ......
*
* Return Value:
*
*   return-value - description of return value
*   or NONE
*
* Created:
*
*   08/28/2000 asecchia
*      Created it.
*
**************************************************************************/
#include "CLines.hpp"

CLinesNominal::CLinesNominal(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Slope, Nominal");
	m_bRegression=bRegression;
}

void CLinesNominal::Draw(Graphics *g)
{
    RectF rect(0, 0, TESTAREAWIDTH, TESTAREAHEIGHT);
    Pen pen(Color(0xff000000), 0.0f);
    
    // control the center ring size.
    
    const double center_r = 0.82;
    
    // control the total size of the object.
    
    const double scale = 0.44;
    
    // number of lines.
    
    const int n_lines = 40;
    
    for(int i = 0; i<n_lines; i++)
    {
        double angle = (double)2.0*M_PI*i/n_lines;  // radians
        
        float x1 = (float)((0.5+scale*cos(angle))*rect.Width);
        float y1 = (float)((0.5+scale*sin(angle))*rect.Height);
        
        float x2 = (float)((0.5+scale*cos(angle+M_PI*center_r))*rect.Width);
        float y2 = (float)((0.5+scale*sin(angle+M_PI*center_r))*rect.Height);
        
        g->DrawLine(&pen, x1, y1, x2, y2);
    }
}

CLinesFat::CLinesFat(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Slope, 3 pixel wide");
	m_bRegression=bRegression;
}

void CLinesFat::Draw(Graphics *g)
{
    RectF rect(0, 0, TESTAREAWIDTH, TESTAREAHEIGHT);
    Pen pen(Color(0xff000000), 3.0f);
    
    // control the center ring size.
    
    const double center_r = 0.82;
    
    // control the total size of the object.
    
    const double scale = 0.44;
    
    // number of lines.
    
    const int n_lines = 40;
    
    for(int i = 0; i<n_lines; i++)
    {
        double angle = (double)2.0*M_PI*i/n_lines;  // radians
        
        float x1 = (float)((0.5+scale*cos(angle))*rect.Width);
        float y1 = (float)((0.5+scale*sin(angle))*rect.Height);
        
        float x2 = (float)((0.5+scale*cos(angle+M_PI*center_r))*rect.Width);
        float y2 = (float)((0.5+scale*sin(angle+M_PI*center_r))*rect.Height);
        
        g->DrawLine(&pen, x1, y1, x2, y2);
    }
}


CLinesMirrorPen::CLinesMirrorPen(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Pen, Mirror Transform");
	m_bRegression=bRegression;
}

void CLinesMirrorPen::Draw(Graphics *g)
{
  const int endpt = 220;

  Matrix m;
  g->GetTransform(&m);

  GraphicsPath gp;
  gp.AddLine(10, 10, endpt, endpt);
  GraphicsPath gp2;
  gp2.AddLine(10, endpt, endpt, 10);
  
  Pen pen(Color(0x8f0000ff), 20);
  pen.SetEndCap(LineCapArrowAnchor);
  
  g->DrawPath(&pen, &gp);
  
  // Pen mirror transform.
  
  pen.ScaleTransform(1.0f, -1.0f);
  
  g->DrawPath(&pen, &gp2);
  
  // Mirror the world to device transform.
  
  g->ScaleTransform(1.0f, -1.0f);
  g->TranslateTransform(0.0f, (float)-endpt);
  
  pen.SetColor(0x3fff0000);
  
  g->DrawPath(&pen, &gp);
  
  // Combination pen and world to device mirror transform.
  
  pen.ScaleTransform(1.0f, -1.0f);
  
  g->DrawPath(&pen, &gp2);

  // Mirror the world to device transform.

  g->SetTransform(&m);
  g->ScaleTransform(-1.0f, 1.0f);
  g->TranslateTransform((float)-endpt, 20.0f);
  
  pen.SetColor(0x3f00ff00);
  
  g->DrawPath(&pen, &gp);
  
  // Combination pen and world to device mirror transform.
  
  pen.ScaleTransform(1.0f, -1.0f);
  
  g->DrawPath(&pen, &gp2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cmixedobjects.h ===
/******************************Module*Header*******************************\
* Module Name: CMixedObjects.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CMIXEDOBJECTS_H
#define __CMIXEDOBJECTS_H

#include "CPrimitive.h"

class CMixedObjects : public CPrimitive  
{
public:
	CMixedObjects(BOOL bRegression);
	virtual ~CMixedObjects();

	void Draw(Graphics *g);

	VOID TestTexts(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cprimitive.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrimitive.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrimitive.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CPrimitive::CPrimitive()
{
	strcpy(m_szName,"No name assigned");
	m_bRegression=false;
}

CPrimitive::~CPrimitive()
{

}

BOOL CPrimitive::Init()
{
	g_FuncTest.AddPrimitive(this);
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cprimitive.h ===
/******************************Module*Header*******************************\
* Module Name: CPrimitive.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRIMITIVE_H
#define __CPRIMITIVE_H

#include "Global.h"

class CPrimitive  
{
public:
	CPrimitive();
	virtual ~CPrimitive();

	virtual BOOL Init();
	virtual void Draw(Graphics *g)=0;
    void SetOffset(int x, int y)
    {
        m_ix = x;
        m_iy = y;
    }

	char m_szName[256];
	BOOL m_bRegression;

    // Offset for this test.

    INT m_ix;
    INT m_iy;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cmixedobjects.cpp ===
/******************************Module*Header*******************************\
* Module Name: CMixedObjects.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CMixedObjects.h"

class RectI
{
public:
    INT X;
    INT Y; 
    INT Width;
    INT Height;
};

CMixedObjects::CMixedObjects(BOOL bRegression)
{
	strcpy(m_szName,"MixedObjects");
	m_bRegression=bRegression;
}

CMixedObjects::~CMixedObjects()
{
}

void CMixedObjects::Draw(Graphics *g)
{
    Point points[10];
    REAL width = 4;     // Pen width

    // Load bmp files.

    WCHAR *filename = L"..\\data\\winnt256.bmp";
    Bitmap *bitmap = new Bitmap(filename);

    // Create a texture brush.

    RectI copyRect;
    copyRect.X = 60;
    copyRect.Y = 60;
    copyRect.Width = 80;
    copyRect.Height = 60;
    Bitmap *copiedBitmap = bitmap->Clone(copyRect.X, copyRect.Y,
                                         copyRect.Width, copyRect.Height,
                                         PixelFormat32bppARGB);

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 10, 10);
    Color colors[4] = {
       Color(255, 255, 255, 255),
       Color(255, 255, 0, 0),
       Color(255, 0, 255, 0),
       Color(255, 0, 0, 255)
    };

//    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors, WrapModeTile);
    width = 8;
//    Pen gradPen(&rectGrad, width);

    if(copiedBitmap)
    {
        // Create a texture brush.

        TextureBrush textureBrush(copiedBitmap, WrapModeTile);

        delete copiedBitmap;

        // Create a radial gradient pen.

        points[3].X = (int)(50.0f/400.0f*TESTAREAWIDTH);
        points[3].Y = (int)(80.0f/400.0f*TESTAREAHEIGHT);
        points[2].X = (int)(200.0f/400.0f*TESTAREAWIDTH);
        points[2].Y = (int)(200.0f/400.0f*TESTAREAHEIGHT);
        points[1].X = (int)(220.0f/400.0f*TESTAREAWIDTH);
        points[1].Y = (int)(340.0f/400.0f*TESTAREAHEIGHT);
        points[0].X = (int)(50.0f/400.0f*TESTAREAWIDTH);
        points[0].Y = (int)(250.0f/400.0f*TESTAREAHEIGHT);

        Matrix mat;
        mat.Rotate(30);
        textureBrush.SetTransform(&mat);
//        gradPen.SetLineJoin(LineJoinMiter);
//        g->FillPolygon(&textureBrush, points, 4);
        Pen pen(&textureBrush, 30);
        g->DrawPolygon(&pen, points, 4);
    }

    delete bitmap;
}

/**************************************************************************\
* TestTexts
*
* A test for drawing texts.
*
\**************************************************************************/

VOID CMixedObjects::TestTexts(Graphics *g)
{
    //Font font(L"Arial", 60);

    FontFamily  ff(L"Arial");
    RectF	  rectf(20, 0, 300, 200);
    GraphicsPath  path;

    // Solid color text.

    Color color(128, 100, 0, 200);
    SolidBrush brush(color);
    path.AddString(L"Color", 5, &ff, 0, 60,  rectf, NULL);
    g->FillPath(&brush, &path);

    // Texture text.

    WCHAR filename[256];
    wcscpy(filename, L"..\\data\\marble1.jpg");
    Bitmap *bitmap = new Bitmap(filename);                          
    TextureBrush textureBrush(bitmap, WrapModeTile);
    path.Reset();
    rectf.X = 200;
    rectf.Y = 20;
    path.AddString(L"Texture", 7, &ff, 0, 60, rectf, NULL);
    g->FillPath(&textureBrush, &path);
    delete bitmap;

    // Gradient text.

    rectf.X = 40;
    rectf.Y = 80;
    path.Reset();
    path.AddString(L"Gradient", 8, &ff, 0, 60, rectf, NULL);
    Color color1(255, 255, 0, 0);
    Color color2(255, 0, 255, 0);
    LinearGradientBrush lineGrad(rectf, color1, color2, 0.0f);
    g->FillPath(&lineGrad, &path);

    // Shadow test

    REAL charHeight = 60;
	REAL topMargin = - 5;
    rectf.X = 0;
    rectf.Y = - charHeight - topMargin; // Make y-coord of the base line
										// of the characters to be 0.

    path.Reset();
    path.AddString(L"Shadow", 6, &ff, 0, charHeight, rectf, NULL);
    GraphicsPath* clonePath = path.Clone();

    Color redColor(255, 0, 0);
    Color grayColor(128, 0, 0, 0);
    SolidBrush redBrush(redColor);
    SolidBrush grayBrush(grayColor);

    // Shadow part.

	REAL tx = 180, ty = 200;
    Matrix skew;
    skew.Scale(1.0, 0.5);
    skew.Shear(-2.0, 0, MatrixOrderAppend);
    skew.Translate(tx, ty, MatrixOrderAppend);
    clonePath->Transform(&skew);
    g->FillPath(&grayBrush, clonePath);
    delete clonePath;

    // Front part.

	Matrix trans1;
    trans1.Translate(tx, ty);
    path.Transform(&trans1);
    g->FillPath(&redBrush, &path);


    return;
/*
    REAL x = 200, y = 150;

    RectF brushRect(x, y, 150, 32);
    Color colors[4] = {
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0),
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0)
    };
//    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors, WrapModeTile);

//    g->DrawString(L"GDI+", &font, &rectGrad, x, y);


    // And now with DrawText

    RectF rect(400, 200, 400, 400);

    g->DrawText(
        DrawTextDisplay,
        L"A few words powered by GDI+: \
\x3c3\x3bb\x3b1\x3b4 \
\x627\x644\x633\x644\x627\x645 \
\x5e9\x5dc\x5d5\x5dd \
\xe2d\xe4d\xe01\xe29\xe23\xe44\xe17\xe22 \
\x110\x068\x0ea\x300\x103",
       &font,           // Initial font
       &rectGrad,       // Initial brush (ignored for the time being)
        LANG_NEUTRAL,   // Initial language
       &rect            // Formatting rectangle
    );
*/

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cpathgradient.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   <an unabbreviated name for the module (not the filename)>
*
* Abstract:
*
*   <Description of what this module does>
*
* Notes:
*
*   <optional>
*
* Created:
*
*   08/30/2000 asecchia
*      Created it.
*
**************************************************************************/

/**************************************************************************
*
* Function Description:
*
*   <Description of what the function does>
*
* Arguments:
*
*   [<blank> | OUT | IN/OUT] argument-name - description of argument
*   ......
*
* Return Value:
*
*   return-value - description of return value
*   or NONE
*
* Created:
*
*   08/30/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "CPathGradient.hpp"

CPathGradient::CPathGradient(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Path");
	m_bRegression=bRegression;
}

void CPathGradient::Draw(Graphics *g)
{
    PointF points[7];
    points[0].X = 0.0f;
    points[0].Y = 0.0f;
    points[1].X = TESTAREAWIDTH;
    points[1].Y = 0.0f;
    points[2].X = TESTAREAWIDTH;
    points[2].Y = TESTAREAHEIGHT;
    points[3].X = 0.0f;
    points[3].Y = TESTAREAHEIGHT;
    points[4].X = 50.0f;
    points[4].Y = 100.0f;
    points[5].X = -1.00;
    points[5].Y = -1.00;
    points[6].X = 0;
    points[6].Y = 0;


    Color colors[6];
    colors[0] = Color(0xff000000);
    colors[1] = Color(0xffff0000);
    colors[2] = Color(0xff00ff00);
    colors[3] = Color(0xffff00ff);
    colors[4] = Color(0xffffff00);
    colors[5] = Color(0xff00ffff);
    
    
    float blend[6] = {0.0f, 0.1f, 0.3f, 0.5f, 0.7f, 1.0f};

    Pen pen(Color(0xff000000), 10.0f);


    GraphicsPath gp;
    gp.AddPolygon(points, 4);
    
    PathGradientBrush brush(points, 4);
    brush.SetCenterPoint(points[4]);
    brush.SetCenterColor(Color(0xff0000ff));

    Status status;
    INT count = 4;
    status = brush.SetSurroundColors(colors, &count);
    
    status = brush.SetInterpolationColors(colors, blend, 6);
    
    
    status = g->FillPath(&brush, &gp);
}


CPathGradient2::CPathGradient2(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Path, 1D, Gamma Corrected");
	m_bRegression=bRegression;
}

void CPathGradient2::Draw(Graphics *g)
{
    PointF points[7];
    points[0].X = 0.0f;
    points[0].Y = 0.0f;
    points[1].X = TESTAREAWIDTH;
    points[1].Y = 0.0f;
    points[2].X = TESTAREAWIDTH;
    points[2].Y = TESTAREAHEIGHT;
    points[3].X = 0.0f;
    points[3].Y = TESTAREAHEIGHT;
    points[4].X = 50.0f;
    points[4].Y = 100.0f;
    points[5].X = -1.00;
    points[5].Y = -1.00;
    points[6].X = 0;
    points[6].Y = 0;


    Color colors[6];
    colors[0] = Color(0xff0000ff);
    colors[1] = Color(0xff0000ff);
    colors[2] = Color(0xff0000ff);
    colors[3] = Color(0xff0000ff);
    colors[4] = Color(0xffffff00);
    colors[5] = Color(0xff00ffff);
    
    
    GraphicsPath gp;
    gp.AddPolygon(points, 4);
    
    PathGradientBrush brush(points, 4);
    brush.SetCenterPoint(points[4]);
    brush.SetCenterColor(Color(0x3f00ff00));

    Status status;
    INT count = 4;
    status = brush.SetSurroundColors(colors, &count);
    status = g->FillPath(&brush, &gp);
}



CPathGradient3::CPathGradient3(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Path, Gamma Corrected");
	m_bRegression=bRegression;
}

void CPathGradient3::Draw(Graphics *g)
{
    // width and height of our test rectangle.
    
    float width = TESTAREAWIDTH;
    float height = TESTAREAHEIGHT;
    
    // center point.
    
    float cx = width/2.0f;
    float cy = height/2.0f;
    
    PointF *points = new PointF[100];
    Color *colors = new Color[100];
    
    // Create the path and some random list of repeating colors.
    
    for(INT i=0;i<100;i++)
    {
        float angle = ((2.0f*(float)M_PI)*i)/100.0f;
        points[i].X = cx*(1.0f + (float)cos(angle));
        points[i].Y = cy*(1.0f + (float)sin(angle));
        colors[i] = Color(
            (i%10>0)?0xff:0x3f,
            (i%4>0)?0xff:0x00,
            (i%4==1)?0xff:0x3f,
            (i%6==2)?0xff:0x00
        );
    }

    // make the path.
    
    GraphicsPath gp;
    gp.AddPolygon(points, 100);
    
    // make the brush.
    
    INT count = 100;
    PathGradientBrush brush(points, 100);
    brush.SetCenterPoint(PointF(cx, cy));
    brush.SetCenterColor(Color(0x00000000));
    brush.SetSurroundColors(colors, &count);
    
    // Fill it.
    
    g->FillPath(&brush, &gp);
}



CLinearGradient::CLinearGradient(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Linear");
	m_bRegression=bRegression;
}

void CLinearGradient::Draw(Graphics *g)
{
    PointF points[4];
    points[0].X = 0.0f;
    points[0].Y = 0.0f;
    points[1].X = TESTAREAWIDTH;
    points[1].Y = 0.0f;
    points[2].X = TESTAREAWIDTH;
    points[2].Y = TESTAREAHEIGHT;
    points[3].X = 0.0f;
    points[3].Y = TESTAREAHEIGHT;
    
    GraphicsPath gp;
    gp.AddPolygon(points, 4);
    
    LinearGradientBrush brush(
        PointF(0.0f, 0.0f),
        PointF(TESTAREAWIDTH, TESTAREAHEIGHT),
        Color(0xffff0000),
        Color(0xff0000ff)
    );
    
    brush.SetGammaCorrection(FALSE);
    Status status = g->FillPath(&brush, &gp);
}

CLinearGradient2::CLinearGradient2(BOOL bRegression)
{
	strcpy(m_szName,"Gradient : Linear, Gamma Corrected");
	m_bRegression=bRegression;
}

void CLinearGradient2::Draw(Graphics *g)
{
    PointF points[4];
    points[0].X = 0.0f;
    points[0].Y = 0.0f;
    points[1].X = TESTAREAWIDTH;
    points[1].Y = 0.0f;
    points[2].X = TESTAREAWIDTH;
    points[2].Y = TESTAREAHEIGHT;
    points[3].X = 0.0f;
    points[3].Y = TESTAREAHEIGHT;
    
    GraphicsPath gp;
    gp.AddPolygon(points, 4);
    
    LinearGradientBrush brush(
        PointF(0.0f, 0.0f),
        PointF(TESTAREAWIDTH, TESTAREAHEIGHT),
        Color(0xffff0000),
        Color(0xff0000ff)
    );
    
    brush.SetGammaCorrection(TRUE);
    Status status = g->FillPath(&brush, &gp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cpolygons.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPolygons.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPolygons.h"

CPolygons::CPolygons(BOOL bRegression)
{
	strcpy(m_szName,"Polygons");
	m_bRegression=bRegression;
}

CPolygons::~CPolygons()
{
}

void CPolygons::Draw(Graphics *g)
{
    REAL width = 4; // Pen width

    Color redColor(255, 0, 0);

    SolidBrush redBrush(redColor);
    g->FillRectangle(&redBrush, (int)(20.0f/150.0f*TESTAREAWIDTH), (int)(20.0f/150.0f*TESTAREAHEIGHT), (int)(50.0f/150.0f*TESTAREAWIDTH), (int)(50.0f/150.0f*TESTAREAHEIGHT));

    Color alphaColor(128, 0, 255, 0);

    SolidBrush alphaBrush(alphaColor);
    g->FillRectangle(&alphaBrush, (int)(10.0f/150.0f*TESTAREAWIDTH), (int)(10.0f/150.0f*TESTAREAHEIGHT), (int)(40.0f/150.0f*TESTAREAWIDTH), (int)(40.0f/150.0f*TESTAREAHEIGHT));

    Point points[4];
    points[0].X = (int)(50.0f/150.0f*TESTAREAWIDTH);
    points[0].Y = (int)(50.0f/150.0f*TESTAREAHEIGHT);
    points[1].X = (int)(100.0f/150.0f*TESTAREAWIDTH);
    points[1].Y = (int)(50.0f/150.0f*TESTAREAHEIGHT);
    points[2].X = (int)(120.0f/150.0f*TESTAREAWIDTH);
    points[2].Y = (int)(120.0f/150.0f*TESTAREAHEIGHT);
    points[3].X = (int)(50.0f/150.0f*TESTAREAWIDTH);
    points[3].Y = (int)(100.0f/150.0f*TESTAREAHEIGHT);

    Color blueColor(128, 0, 0, 255);

    SolidBrush blueBrush(blueColor);
    g->FillPolygon(&blueBrush, points, 4);

    // Currently only Geometric pen works for lines. - ikkof 1/6/99.

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    width = 16;
    Pen blackPen(&blackBrush, width);
    blackPen.SetLineJoin(LineJoinRound);
//    blackPen.SetLineJoin(LineJoinBevel);
    g->DrawPolygon(&blackPen, points, 4);
//    g->DrawLines(&blackPen, points, 4, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cpaths.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPaths.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPaths.h"
#include <limits.h>

CJoins::CJoins(BOOL bRegression)
{
	strcpy(m_szName,"Lines : Joins");
	m_bRegression=bRegression;
}

CJoins::~CJoins()
{
}

void CJoins::Draw(Graphics *g)
{
    Pen pen(Color(128,0,0), 8.5f);
    pen.SetMiterLimit(4.0f);

    g->TranslateTransform(20,30);
    for (INT j = 0; j<4; j++)
    {
        pen.SetLineJoin((LineJoin)j);
        INT x=0, y=0;
        for (INT x=0, y=-5; x<40; x+=8, y+=15)
        {
            Point points[] = {Point(0,0), Point(36,0), Point(x,y)};
            GraphicsPath corner;
            corner.AddPolygon(points,3);
            g->DrawPath(&pen,&corner);
            g->TranslateTransform(0,(REAL)(y+15));
        }
        g->TranslateTransform(60,-200);
    }
    g->TranslateTransform(-260,-30);
}       	

CPaths::CPaths(BOOL bRegression)
{
	strcpy(m_szName,"Paths");
	m_bRegression=bRegression;
}

CPaths::~CPaths()
{
}

VOID TestEscherNewPath(Graphics* g);

void CPaths::Draw(Graphics *g)
{
    TestBezierPath(g);
	TestSinglePixelWidePath(g);
	TestTextAlongPath(g);

	TestFreeFormPath2(g);
	TestLeakPath(g);
	TestExcelCurvePath(g);
        TestPie(g);

//	  TestDegenerateBezierPath(g);
//    TestEscherNewPath(g);
}

VOID CPaths::TestBezierPath(Graphics *g)
{
    REAL width = 4;         // Pen width
    Point points[4];

    points[0].X = (int)(100.0f/450.0f*TESTAREAWIDTH);
    points[0].Y = (int)(10.0f/450.0f*TESTAREAHEIGHT);
    points[1].X = (int)(-50.0f/450.0f*TESTAREAWIDTH);
    points[1].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    points[2].X = (int)(150.0f/450.0f*TESTAREAWIDTH);
    points[2].Y = (int)(200.0f/450.0f*TESTAREAHEIGHT);
    points[3].X = (int)(200.0f/450.0f*TESTAREAWIDTH);
    points[3].Y = (int)(70.0f/450.0f*TESTAREAHEIGHT);

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);

    path->SetMarker();

    RectF rect;

    rect.X = (int)(150.0f/450.0f*TESTAREAWIDTH);
    rect.Y = (int)(150.0f/450.0f*TESTAREAHEIGHT);
    rect.Width = (int)(100.0f/450.0f*TESTAREAWIDTH);
    rect.Height = (int)(100.0f/450.0f*TESTAREAHEIGHT);

    path->AddRectangle(rect);
    
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    Color colors[2];
    colors[0].SetValue(Color::MakeARGB(128, 0, 255, 0));
    colors[1].SetValue(Color::MakeARGB(128, 0, 0, 255));

    SolidBrush brush1(colors[0]);
    GraphicsPath path1;

    GraphicsPathIterator iter(path);

    INT i = 0;

    while(iter.NextMarker(&path1) > 0)
    {
        // Change the brush color.

        brush1.SetColor(colors[(i & 0x01)]);

        // Fill each marker path.

//        g->FillPath(&brush1, &path1);
        i++;
    }

    // If you wanto to flatten the path before rendering,
    // Flatten() can be called.

    BOOL flattenFirst = FALSE;

    if(!flattenFirst)
    {
        // Don't flatten and keep the original path.
        // FillPath or DrawPath will flatten the path automatically
        // without modifying the original path.

        path->Transform(&matrix);
    }
    else
    {
        // Flatten this path.  The resultant path is made of line
        // segments.  The original path information is lost.

        path->Flatten(&matrix);
    }
    
    Color blackColor(128, 0, 0, 0);

    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = 6;
    Pen blackPen(&blackBrush, width);
    Matrix mat;
    mat.Scale(1.0f, 0.6f);
//    blackPen.SetTransform(&mat);
    blackPen.SetStartCap(LineCapTriangle);
//    blackPen.SetStartCap(LineCapRoundAnchor);
//    blackPen.SetEndCap(LineCapSquare);
//    blackPen.SetEndCap(LineCapArrowAnchor);
    blackPen.SetEndCap(LineCapTriangle);
//    blackPen.SetEndCap(LineCapDiamondAnchor);
//	blackPen.SetAlignment(PenAlignmentRight);
    blackPen.SetLineJoin(LineJoinRound);

    GraphicsPath fillPath, strokePath;

    rect.X = -2;
    rect.Y = -2;
    rect.Width = 4;
    rect.Height = 4;
    fillPath.AddRectangle(rect);

    CustomLineCap customCap(NULL, &fillPath);
    customCap.SetBaseInset(1.0f);
    blackPen.SetCustomEndCap(&customCap);

    AdjustableArrowCap arrowCap(4, 4, FALSE);
    arrowCap.SetMiddleInset(1);
    arrowCap.SetStrokeCaps(LineCapRound, LineCapRound);
    arrowCap.SetStrokeJoin(LineJoinRound);
    blackPen.SetCustomStartCap(&arrowCap);

    path->Reverse();

    Region * region = new Region(path);
    g->FillPath(&yellowBrush, path);
    g->DrawPath(&blackPen, path);
    delete path;
    delete region;

    Pen pen2(&blackBrush, 10);
    path = new GraphicsPath(FillModeWinding);
    points[0].X = (int)(100.0f/450.0f*TESTAREAWIDTH);  points[0].Y = (int)(20.0f/450.0f*TESTAREAHEIGHT);
    points[1].X = (int)(0.0f/450.0f*TESTAREAWIDTH);    points[1].Y = (int)(20.0f/450.0f*TESTAREAHEIGHT);
    points[2].X = (int)(250.0f/450.0f*TESTAREAWIDTH);  points[2].Y = (int)(20.0f/450.0f*TESTAREAHEIGHT);
    points[3].X = (int)(150.0f/450.0f*TESTAREAWIDTH);  points[3].Y = (int)(20.0f/450.0f*TESTAREAHEIGHT);
    path->AddBeziers(points, 4);
//    path->AddLines(points, 4);
    g->DrawPath(&pen2, path);
    delete path;

    path = new GraphicsPath();
    rect.X = (int)(100.0f/450.0f*TESTAREAWIDTH);
    rect.Y = (int)(40.0f/450.0f*TESTAREAHEIGHT);
    rect.Width = (int)(50.0f/450.0f*TESTAREAWIDTH);
    rect.Height = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    path->AddRectangle(rect);
    g->DrawPath(&pen2, path);
    delete path;

    Point pts[10];
    INT count = 4;

    pts[0].X = (int)(200.0f/450.0f*TESTAREAWIDTH);
    pts[0].Y = (int)(160.0f/450.0f*TESTAREAHEIGHT);
    pts[1].X = (int)(150.0f/450.0f*TESTAREAWIDTH);
    pts[1].Y = (int)(230.0f/450.0f*TESTAREAHEIGHT);
    pts[2].X = (int)(200.0f/450.0f*TESTAREAWIDTH);
    pts[2].Y = (int)(260.0f/450.0f*TESTAREAHEIGHT);
    pts[3].X = (int)(300.0f/450.0f*TESTAREAWIDTH);
    pts[3].Y = (int)(200.0f/450.0f*TESTAREAHEIGHT);

//    g->FillClosedCurve(&brush, pts, count);

    pts[0].X = (int)(100.0f/450.0f*TESTAREAWIDTH); pts[0].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    pts[1].X = (int)(50.0f/450.0f*TESTAREAWIDTH);  pts[1].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    pts[2].X = (int)(200.0f/450.0f*TESTAREAWIDTH); pts[2].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    pts[3].X = (int)(150.0f/450.0f*TESTAREAWIDTH); pts[3].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);

    count = 4;
//    g->DrawClosedCurve(&pen2, pts, count);
    g->DrawCurve(&pen2, pts, count);

    pts[0].X = (int)(65.0f/450.0f*TESTAREAWIDTH);
    pts[0].Y = (int)(20.0f/450.0f*TESTAREAHEIGHT);
    pts[1].X = (int)(20.0f/450.0f*TESTAREAWIDTH);
    pts[1].Y = (int)(110.0f/450.0f*TESTAREAHEIGHT);
    pts[2].X = (int)(110.0f/450.0f*TESTAREAWIDTH);
    pts[2].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    pts[3].X = (int)(20.0f/450.0f*TESTAREAWIDTH);
    pts[3].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    path = new GraphicsPath();
    pen2.SetWidth(1);
    path->AddBeziers(pts, 4);
    g->DrawPath(&pen2, path);
    delete path;
}

VOID CPaths::TestSinglePixelWidePath(Graphics *g)
{
    Point points[4];

    points[0].X = (int)(30.0f/450.0f*TESTAREAWIDTH);
    points[0].Y = (int)(30.0f/450.0f*TESTAREAHEIGHT);
    points[1].X = points[0].X + (int)(100.0f/450.0f*TESTAREAWIDTH);
    points[1].Y = points[0].Y + (int)(3.0f/450.0f*TESTAREAHEIGHT);
    points[2].X = points[1].X - (int)(3.0f/450.0f*TESTAREAWIDTH);
    points[2].Y = points[1].Y + (int)(100.0f/450.0f*TESTAREAHEIGHT);
    points[3].X = points[2].X - (int)(45.0f/450.0f*TESTAREAWIDTH);
    points[3].Y = points[2].Y - (int)(45.0f/450.0f*TESTAREAHEIGHT);

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, 1.0);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddLines(points, 4);

    // Set the pen width in inch.
    g->DrawPath(&blackPen, path);

    delete path;
}

VOID CPaths::TestTextAlongPath(Graphics *g)
{
    Point points[4];

    points[3].X = (int)(100.0f/450.0f*TESTAREAWIDTH);
    points[3].Y = (int)(10.0f/450.0f*TESTAREAHEIGHT);
    points[2].X = (int)(-50.0f/450.0f*TESTAREAWIDTH);
    points[2].Y = (int)(50.0f/450.0f*TESTAREAHEIGHT);
    points[1].X = (int)(150.0f/450.0f*TESTAREAWIDTH);
    points[1].Y = (int)(200.0f/450.0f*TESTAREAHEIGHT);
    points[0].X = (int)(200.0f/450.0f*TESTAREAWIDTH);
    points[0].Y = (int)(70.0f/450.0f*TESTAREAHEIGHT);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    path->Transform(&matrix);

    Color textColor(180, 200, 0, 200);
    SolidBrush textBrush(textColor);

    WCHAR szText[]=L"Windows 2000";

    REAL offset=60;

//    g->DrawString(text, 12, NULL, path, NULL, &textBrush, offset);

    delete path;
}

VOID CPaths::TestFreeFormPath1(Graphics* g)
{
    INT count = 55;
    GpPointF pts[60];

    pts[ 0].X = 4.879999e+002f/600.0f*TESTAREAWIDTH; pts[ 0].Y =  3.059999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 1].X = 4.772343e+002f/600.0f*TESTAREAWIDTH; pts[ 1].Y =  3.024114e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 2].X = 4.573341e+002f/600.0f*TESTAREAWIDTH; pts[ 2].Y =  3.019402e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 3].X = 4.476240e+002f/600.0f*TESTAREAWIDTH; pts[ 3].Y =  3.019402e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 4].X = 4.419999e+002f/600.0f*TESTAREAWIDTH; pts[ 4].Y =  3.019999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 5].X = 4.379999e+002f/600.0f*TESTAREAWIDTH; pts[ 5].Y =  3.013333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 6].X = 4.335999e+002f/600.0f*TESTAREAWIDTH; pts[ 6].Y =  3.018000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 7].X = 4.299999e+002f/600.0f*TESTAREAWIDTH; pts[ 7].Y =  2.999999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 8].X = 4.266666e+002f/600.0f*TESTAREAWIDTH; pts[ 8].Y =  2.983333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 9].X = 4.236666e+002f/600.0f*TESTAREAWIDTH; pts[ 9].Y =  2.955333e+002f/600.0f*TESTAREAHEIGHT;
    pts[10].X = 4.199999e+002f/600.0f*TESTAREAWIDTH; pts[10].Y =  2.949999e+002f/600.0f*TESTAREAHEIGHT;
    pts[11].X = 4.059999e+002f/600.0f*TESTAREAWIDTH; pts[11].Y =  2.929999e+002f/600.0f*TESTAREAHEIGHT;
    pts[12].X = 4.059999e+002f/600.0f*TESTAREAWIDTH; pts[12].Y =  2.929999e+002f/600.0f*TESTAREAHEIGHT;
    pts[13].X = 3.965333e+002f/600.0f*TESTAREAWIDTH; pts[13].Y =  2.873333e+002f/600.0f*TESTAREAHEIGHT;
    pts[14].X = 3.802666e+002f/600.0f*TESTAREAWIDTH; pts[14].Y =  2.774000e+002f/600.0f*TESTAREAHEIGHT;
    pts[15].X = 3.739999e+002f/600.0f*TESTAREAWIDTH; pts[15].Y =  2.680000e+002f/600.0f*TESTAREAHEIGHT;
    pts[16].X = 3.965333e+002f/600.0f*TESTAREAWIDTH; pts[16].Y =  2.873333e+002f/600.0f*TESTAREAHEIGHT;
    pts[17].X = 3.802666e+002f/600.0f*TESTAREAWIDTH; pts[17].Y =  2.774000e+002f/600.0f*TESTAREAHEIGHT;
    pts[18].X = 3.739999e+002f/600.0f*TESTAREAWIDTH; pts[18].Y =  2.680000e+002f/600.0f*TESTAREAHEIGHT;
    pts[19].X = 3.725333e+002f/600.0f*TESTAREAWIDTH; pts[19].Y =  2.658000e+002f/600.0f*TESTAREAHEIGHT;
    pts[20].X = 3.708666e+002f/600.0f*TESTAREAWIDTH; pts[20].Y =  2.635333e+002f/600.0f*TESTAREAHEIGHT;
    pts[21].X = 3.699999e+002f/600.0f*TESTAREAWIDTH; pts[21].Y =  2.610000e+002f/600.0f*TESTAREAHEIGHT;
    pts[22].X = 3.725333e+002f/600.0f*TESTAREAWIDTH; pts[22].Y =  2.658000e+002f/600.0f*TESTAREAHEIGHT;
    pts[23].X = 3.708666e+002f/600.0f*TESTAREAWIDTH; pts[23].Y =  2.635333e+002f/600.0f*TESTAREAHEIGHT;
    pts[24].X = 3.699999e+002f/600.0f*TESTAREAWIDTH; pts[24].Y =  2.610000e+002f/600.0f*TESTAREAHEIGHT;
    pts[25].X = 3.691333e+002f/600.0f*TESTAREAWIDTH; pts[25].Y =  2.584000e+002f/600.0f*TESTAREAHEIGHT;
    pts[26].X = 3.679999e+002f/600.0f*TESTAREAWIDTH; pts[26].Y =  2.530000e+002f/600.0f*TESTAREAHEIGHT;
    pts[27].X = 3.679999e+002f/600.0f*TESTAREAWIDTH; pts[27].Y =  2.530000e+002f/600.0f*TESTAREAHEIGHT;
    pts[28].X = 3.679999e+002f/600.0f*TESTAREAWIDTH; pts[28].Y =  2.530000e+002f/600.0f*TESTAREAHEIGHT;
    pts[29].X = 3.658666e+002f/600.0f*TESTAREAWIDTH; pts[29].Y =  2.318666e+002f/600.0f*TESTAREAHEIGHT;
    pts[30].X = 3.691333e+002f/600.0f*TESTAREAWIDTH; pts[30].Y =  2.203333e+002f/600.0f*TESTAREAHEIGHT;
    pts[31].X = 3.839999e+002f/600.0f*TESTAREAWIDTH; pts[31].Y =  2.070000e+002f/600.0f*TESTAREAHEIGHT;
    pts[32].X = 3.893333e+002f/600.0f*TESTAREAWIDTH; pts[32].Y =  2.022000e+002f/600.0f*TESTAREAHEIGHT;
    pts[33].X = 3.931999e+002f/600.0f*TESTAREAWIDTH; pts[33].Y =  1.964000e+002f/600.0f*TESTAREAHEIGHT;
    pts[34].X = 3.999999e+002f/600.0f*TESTAREAWIDTH; pts[34].Y =  1.930000e+002f/600.0f*TESTAREAHEIGHT;
    pts[35].X = 4.053327e+002f/600.0f*TESTAREAWIDTH; pts[35].Y =  1.903467e+002f/600.0f*TESTAREAHEIGHT;
    pts[36].X = 4.059866e+002f/600.0f*TESTAREAWIDTH; pts[36].Y =  1.899501e+002f/600.0f*TESTAREAHEIGHT;
    pts[37].X = 4.062323e+002f/600.0f*TESTAREAWIDTH; pts[37].Y =  1.899501e+002f/600.0f*TESTAREAHEIGHT;
    pts[38].X = 4.063370e+002f/600.0f*TESTAREAWIDTH; pts[38].Y =  1.899501e+002f/600.0f*TESTAREAHEIGHT;
    pts[39].X = 4.063676e+002f/600.0f*TESTAREAWIDTH; pts[39].Y =  1.900222e+002f/600.0f*TESTAREAHEIGHT;
    pts[40].X = 4.066551e+002f/600.0f*TESTAREAWIDTH; pts[40].Y =  1.900222e+002f/600.0f*TESTAREAHEIGHT;
    pts[41].X = 4.074044e+002f/600.0f*TESTAREAWIDTH; pts[41].Y =  1.900222e+002f/600.0f*TESTAREAHEIGHT;
    pts[42].X = 4.098989e+002f/600.0f*TESTAREAWIDTH; pts[42].Y =  1.895324e+002f/600.0f*TESTAREAHEIGHT;
    pts[43].X = 4.199999e+002f/600.0f*TESTAREAWIDTH; pts[43].Y =  1.860000e+002f/600.0f*TESTAREAHEIGHT;
    pts[44].X = 4.269999e+002f/600.0f*TESTAREAWIDTH; pts[44].Y =  1.835333e+002f/600.0f*TESTAREAHEIGHT;
    pts[45].X = 4.337999e+002f/600.0f*TESTAREAWIDTH; pts[45].Y =  1.789333e+002f/600.0f*TESTAREAHEIGHT;
    pts[46].X = 4.409999e+002f/600.0f*TESTAREAWIDTH; pts[46].Y =  1.770000e+002f/600.0f*TESTAREAHEIGHT;
    pts[47].X = 4.475333e+002f/600.0f*TESTAREAWIDTH; pts[47].Y =  1.752000e+002f/600.0f*TESTAREAHEIGHT;
    pts[48].X = 4.543333e+002f/600.0f*TESTAREAWIDTH; pts[48].Y =  1.751333e+002f/600.0f*TESTAREAHEIGHT;
    pts[49].X = 4.609999e+002f/600.0f*TESTAREAWIDTH; pts[49].Y =  1.740000e+002f/600.0f*TESTAREAHEIGHT;
    pts[50].X = 4.643333e+002f/600.0f*TESTAREAWIDTH; pts[50].Y =  1.734666e+002f/600.0f*TESTAREAHEIGHT;
    pts[51].X = 4.675999e+002f/600.0f*TESTAREAWIDTH; pts[51].Y =  1.720000e+002f/600.0f*TESTAREAHEIGHT;
    pts[52].X = 4.709999e+002f/600.0f*TESTAREAWIDTH; pts[52].Y =  1.720000e+002f/600.0f*TESTAREAHEIGHT;
    pts[53].X = 5.279999e+002f/600.0f*TESTAREAWIDTH; pts[53].Y =  1.720000e+002f/600.0f*TESTAREAHEIGHT;
    pts[54].X = 5.279999e+002f/600.0f*TESTAREAWIDTH; pts[54].Y =  1.720000e+002f/600.0f*TESTAREAHEIGHT;


    BYTE typs[] = {
        00, 03, 03, 03, //  0 -  3
        01, 03, 03, 03, //  4 -  7
        03, 03, 03, 01, //  8 - 11
        01, 03, 03, 03, // 12 - 15
        03, 03, 03, 03, // 16 - 19
        03, 03, 03, 03, // 20 - 23
        03, 03, 03, 03, // 24 - 27
        01, 03, 03, 03, // 28 - 31
        03, 03, 03, 03, // 32 - 35
        03, 03, 03, 03, // 36 - 39
        03, 03, 03, 03, // 40 - 43
        03, 03, 03, 03, // 44 - 47
        03, 03, 03, 03, // 48 - 51
        03, 01, 01      // 52 - 54
    };

    PointF pts2[4];
    pts2[0].X = 3.739999e+002f/600.0f*TESTAREAWIDTH; pts2[0].Y =  2.680000e+002f/600.0f*TESTAREAHEIGHT;
    pts2[1].X = 3.965333e+002f/600.0f*TESTAREAWIDTH; pts2[1].Y =  2.873333e+002f/600.0f*TESTAREAHEIGHT;
    pts2[2].X = 3.802666e+002f/600.0f*TESTAREAWIDTH; pts2[2].Y =  2.774000e+002f/600.0f*TESTAREAHEIGHT;
    pts2[3].X = 3.739999e+002f/600.0f*TESTAREAWIDTH; pts2[3].Y =  2.680000e+002f/600.0f*TESTAREAHEIGHT;
    pts2[4].X = 3.739999e+002f/600.0f*TESTAREAWIDTH; pts2[4].Y =  2.680000e+002f/600.0f*TESTAREAHEIGHT;

    BYTE typs2[] = {0, 3, 3, 3, 1};

    INT count1 = count;
    INT offset1 = 0;
//    offset1 = 15;
//    count1 = 19;
    count1 -= offset1;
    GpPointF* pts1 = &pts[0] + offset1;
    BYTE* typs1 = &typs[0] + offset1;

    GraphicsPath* path
        = new GraphicsPath(pts1, typs1, count1);
//        = new GraphicsPath(&pts2[0], &typs2[0], 4);

    Matrix mat;
    mat.Translate((int)(-300.0f/600.0f*TESTAREAWIDTH), (int)(-200.0f/600.0f*TESTAREAHEIGHT));
    path->Transform(&mat);
    Matrix mat1;
//    mat1.Scale(5, 5);
//    path->Transform(&mat1);

    REAL width = 20;
    Color color(128, 0, 0, 0);
    SolidBrush brush(color);
    Pen pen(&brush, width);
    pen.SetLineJoin(LineJoinRound);

    g->DrawPath(&pen, path);

    delete path;
}

VOID CPaths::TestFreeFormPath2(Graphics* g)
{
    INT count = 118;
    GpPointF pts[118];

    pts[  0].X = 1.680000e+002f/600.0f*TESTAREAWIDTH; pts[  0].Y = 2.120000e+002f/600.0f*TESTAREAHEIGHT;
    pts[  1].X = 1.686667e+002f/600.0f*TESTAREAWIDTH; pts[  1].Y = 2.016666e+002f/600.0f*TESTAREAHEIGHT;
    pts[  2].X = 1.688667e+002f/600.0f*TESTAREAWIDTH; pts[  2].Y = 1.912666e+002f/600.0f*TESTAREAHEIGHT;
    pts[  3].X = 1.700000e+002f/600.0f*TESTAREAWIDTH; pts[  3].Y = 1.810000e+002f/600.0f*TESTAREAHEIGHT;
    pts[  4].X = 1.686667e+002f/600.0f*TESTAREAWIDTH; pts[  4].Y = 2.016666e+002f/600.0f*TESTAREAHEIGHT;
    pts[  5].X = 1.688667e+002f/600.0f*TESTAREAWIDTH; pts[  5].Y = 1.912666e+002f/600.0f*TESTAREAHEIGHT;
    pts[  6].X = 1.700000e+002f/600.0f*TESTAREAWIDTH; pts[  6].Y = 1.810000e+002f/600.0f*TESTAREAHEIGHT;
    pts[  7].X = 1.703333e+002f/600.0f*TESTAREAWIDTH; pts[  7].Y = 1.780666e+002f/600.0f*TESTAREAHEIGHT;
    pts[  8].X = 1.754666e+002f/600.0f*TESTAREAWIDTH; pts[  8].Y = 1.652000e+002f/600.0f*TESTAREAHEIGHT;
    pts[  9].X = 1.760000e+002f/600.0f*TESTAREAWIDTH; pts[  9].Y = 1.630000e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 10].X = 1.703333e+002f/600.0f*TESTAREAWIDTH; pts[ 10].Y = 1.780666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 11].X = 1.754666e+002f/600.0f*TESTAREAWIDTH; pts[ 11].Y = 1.652000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 12].X = 1.760000e+002f/600.0f*TESTAREAWIDTH; pts[ 12].Y = 1.630000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 13].X = 1.763333e+002f/600.0f*TESTAREAWIDTH; pts[ 13].Y = 1.617333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 14].X = 1.772666e+002f/600.0f*TESTAREAWIDTH; pts[ 14].Y = 1.574666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 15].X = 1.780000e+002f/600.0f*TESTAREAWIDTH; pts[ 15].Y = 1.560000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 16].X = 1.763333e+002f/600.0f*TESTAREAWIDTH; pts[ 16].Y = 1.617333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 17].X = 1.772666e+002f/600.0f*TESTAREAWIDTH; pts[ 17].Y = 1.574666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 18].X = 1.780000e+002f/600.0f*TESTAREAWIDTH; pts[ 18].Y = 1.560000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 19].X = 1.826666e+002f/600.0f*TESTAREAWIDTH; pts[ 19].Y = 1.467333e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 20].X = 1.880000e+002f/600.0f*TESTAREAWIDTH; pts[ 20].Y = 1.452666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 21].X = 1.950000e+002f/600.0f*TESTAREAWIDTH; pts[ 21].Y = 1.390000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 22].X = 1.993333e+002f/600.0f*TESTAREAWIDTH; pts[ 22].Y = 1.351333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 23].X = 2.037333e+002f/600.0f*TESTAREAWIDTH; pts[ 23].Y = 1.306667e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 24].X = 2.090000e+002f/600.0f*TESTAREAWIDTH; pts[ 24].Y = 1.280000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 25].X = 1.993333e+002f/600.0f*TESTAREAWIDTH; pts[ 25].Y = 1.351333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 26].X = 2.037333e+002f/600.0f*TESTAREAWIDTH; pts[ 26].Y = 1.306667e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 27].X = 2.090000e+002f/600.0f*TESTAREAWIDTH; pts[ 27].Y = 1.280000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 28].X = 2.206000e+002f/600.0f*TESTAREAWIDTH; pts[ 28].Y = 1.222000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 29].X = 2.332666e+002f/600.0f*TESTAREAWIDTH; pts[ 29].Y = 1.208667e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 30].X = 2.460000e+002f/600.0f*TESTAREAWIDTH; pts[ 30].Y = 1.200000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 31].X = 2.206000e+002f/600.0f*TESTAREAWIDTH; pts[ 31].Y = 1.222000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 32].X = 2.332666e+002f/600.0f*TESTAREAWIDTH; pts[ 32].Y = 1.208667e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 33].X = 2.460000e+002f/600.0f*TESTAREAWIDTH; pts[ 33].Y = 1.200000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 34].X = 2.531333e+002f/600.0f*TESTAREAWIDTH; pts[ 34].Y = 1.206000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 35].X = 2.632000e+002f/600.0f*TESTAREAWIDTH; pts[ 35].Y = 1.206000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 36].X = 2.700000e+002f/600.0f*TESTAREAWIDTH; pts[ 36].Y = 1.240000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 37].X = 2.734666e+002f/600.0f*TESTAREAWIDTH; pts[ 37].Y = 1.257333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 38].X = 2.763333e+002f/600.0f*TESTAREAWIDTH; pts[ 38].Y = 1.288000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 39].X = 2.799999e+002f/600.0f*TESTAREAWIDTH; pts[ 39].Y = 1.300000e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 40].X = 2.858000e+002f/600.0f*TESTAREAWIDTH; pts[ 40].Y = 1.319333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 41].X = 2.889333e+002f/600.0f*TESTAREAWIDTH; pts[ 41].Y = 1.338667e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 42].X = 2.939999e+002f/600.0f*TESTAREAWIDTH; pts[ 42].Y = 1.370000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 43].X = 2.858000e+002f/600.0f*TESTAREAWIDTH; pts[ 43].Y = 1.319333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 44].X = 2.889333e+002f/600.0f*TESTAREAWIDTH; pts[ 44].Y = 1.338667e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 45].X = 2.939999e+002f/600.0f*TESTAREAWIDTH; pts[ 45].Y = 1.370000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 46].X = 3.058666e+002f/600.0f*TESTAREAWIDTH; pts[ 46].Y = 1.443333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 47].X = 3.215333e+002f/600.0f*TESTAREAWIDTH; pts[ 47].Y = 1.503333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 48].X = 3.299999e+002f/600.0f*TESTAREAWIDTH; pts[ 48].Y = 1.620000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 49].X = 3.332666e+002f/600.0f*TESTAREAWIDTH; pts[ 49].Y = 1.664666e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 50].X = 3.385999e+002f/600.0f*TESTAREAWIDTH; pts[ 50].Y = 1.723333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 51].X = 3.399999e+002f/600.0f*TESTAREAWIDTH; pts[ 51].Y = 1.780000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 52].X = 3.411333e+002f/600.0f*TESTAREAWIDTH; pts[ 52].Y = 1.826666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 53].X = 3.418666e+002f/600.0f*TESTAREAWIDTH; pts[ 53].Y = 1.873333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 54].X = 3.429999e+002f/600.0f*TESTAREAWIDTH; pts[ 54].Y = 1.920000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 55].X = 3.428666e+002f/600.0f*TESTAREAWIDTH; pts[ 55].Y = 1.949333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 56].X = 3.430666e+002f/600.0f*TESTAREAWIDTH; pts[ 56].Y = 2.178666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 57].X = 3.399999e+002f/600.0f*TESTAREAWIDTH; pts[ 57].Y = 2.250000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 58].X = 3.428666e+002f/600.0f*TESTAREAWIDTH; pts[ 58].Y = 1.949333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 59].X = 3.430666e+002f/600.0f*TESTAREAWIDTH; pts[ 59].Y = 2.178666e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 60].X = 3.399999e+002f/600.0f*TESTAREAWIDTH; pts[ 60].Y = 2.250000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 61].X = 3.363333e+002f/600.0f*TESTAREAWIDTH; pts[ 61].Y = 2.334666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 62].X = 3.344666e+002f/600.0f*TESTAREAWIDTH; pts[ 62].Y = 2.390000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 63].X = 3.279999e+002f/600.0f*TESTAREAWIDTH; pts[ 63].Y = 2.460000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 64].X = 3.363333e+002f/600.0f*TESTAREAWIDTH; pts[ 64].Y = 2.334666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 65].X = 3.344666e+002f/600.0f*TESTAREAWIDTH; pts[ 65].Y = 2.390000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 66].X = 3.279999e+002f/600.0f*TESTAREAWIDTH; pts[ 66].Y = 2.460000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 67].X = 3.257333e+002f/600.0f*TESTAREAWIDTH; pts[ 67].Y = 2.484000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 68].X = 3.233333e+002f/600.0f*TESTAREAWIDTH; pts[ 68].Y = 2.506666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 69].X = 3.209999e+002f/600.0f*TESTAREAWIDTH; pts[ 69].Y = 2.530000e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 70].X = 3.257333e+002f/600.0f*TESTAREAWIDTH; pts[ 70].Y = 2.484000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 71].X = 3.233333e+002f/600.0f*TESTAREAWIDTH; pts[ 71].Y = 2.506666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 72].X = 3.209999e+002f/600.0f*TESTAREAWIDTH; pts[ 72].Y = 2.530000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 73].X = 3.193333e+002f/600.0f*TESTAREAWIDTH; pts[ 73].Y = 2.546666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 74].X = 3.170666e+002f/600.0f*TESTAREAWIDTH; pts[ 74].Y = 2.558666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 75].X = 3.159999e+002f/600.0f*TESTAREAWIDTH; pts[ 75].Y = 2.579999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 76].X = 3.115999e+002f/600.0f*TESTAREAWIDTH; pts[ 76].Y = 2.668000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 77].X = 3.043999e+002f/600.0f*TESTAREAWIDTH; pts[ 77].Y = 2.708000e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 78].X = 2.969999e+002f/600.0f*TESTAREAWIDTH; pts[ 78].Y = 2.769999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 79].X = 2.905999e+002f/600.0f*TESTAREAWIDTH; pts[ 79].Y = 2.823333e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 80].X = 2.981333e+002f/600.0f*TESTAREAWIDTH; pts[ 80].Y = 2.784666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 81].X = 2.869999e+002f/600.0f*TESTAREAWIDTH; pts[ 81].Y = 2.839999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 82].X = 2.905999e+002f/600.0f*TESTAREAWIDTH; pts[ 82].Y = 2.823333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 83].X = 2.981333e+002f/600.0f*TESTAREAWIDTH; pts[ 83].Y = 2.784666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 84].X = 2.869999e+002f/600.0f*TESTAREAWIDTH; pts[ 84].Y = 2.839999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 85].X = 2.815333e+002f/600.0f*TESTAREAWIDTH; pts[ 85].Y = 2.867333e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 86].X = 2.755333e+002f/600.0f*TESTAREAWIDTH; pts[ 86].Y = 2.874666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 87].X = 2.700000e+002f/600.0f*TESTAREAWIDTH; pts[ 87].Y = 2.899999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 88].X = 2.655213e+002f/600.0f*TESTAREAWIDTH; pts[ 88].Y = 2.920783e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 89].X = 2.649243e+002f/600.0f*TESTAREAWIDTH; pts[ 89].Y = 2.926785e+002f/600.0f*TESTAREAHEIGHT;

    pts[ 90].X = 2.649243e+002f/600.0f*TESTAREAWIDTH; pts[ 90].Y = 2.928842e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 91].X = 2.649243e+002f/600.0f*TESTAREAWIDTH; pts[ 91].Y = 2.929590e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 92].X = 2.650032e+002f/600.0f*TESTAREAWIDTH; pts[ 92].Y = 2.929816e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 93].X = 2.650032e+002f/600.0f*TESTAREAWIDTH; pts[ 93].Y = 2.930042e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 94].X = 2.650032e+002f/600.0f*TESTAREAWIDTH; pts[ 94].Y = 2.930609e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 95].X = 2.645045e+002f/600.0f*TESTAREAWIDTH; pts[ 95].Y = 2.931171e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 96].X = 2.610000e+002f/600.0f*TESTAREAWIDTH; pts[ 96].Y = 2.939999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 97].X = 2.543333e+002f/600.0f*TESTAREAWIDTH; pts[ 97].Y = 2.936666e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 98].X = 2.476666e+002f/600.0f*TESTAREAWIDTH; pts[ 98].Y = 2.935999e+002f/600.0f*TESTAREAHEIGHT;
    pts[ 99].X = 2.410000e+002f/600.0f*TESTAREAWIDTH; pts[ 99].Y = 2.929999e+002f/600.0f*TESTAREAHEIGHT;

    pts[100].X = 2.543333e+002f/600.0f*TESTAREAWIDTH; pts[100].Y = 2.936666e+002f/600.0f*TESTAREAHEIGHT;
    pts[101].X = 2.476666e+002f/600.0f*TESTAREAWIDTH; pts[101].Y = 2.935999e+002f/600.0f*TESTAREAHEIGHT;
    pts[102].X = 2.410000e+002f/600.0f*TESTAREAWIDTH; pts[102].Y = 2.929999e+002f/600.0f*TESTAREAHEIGHT;
    pts[103].X = 2.379333e+002f/600.0f*TESTAREAWIDTH; pts[103].Y = 2.927333e+002f/600.0f*TESTAREAHEIGHT;
    pts[104].X = 2.376000e+002f/600.0f*TESTAREAWIDTH; pts[104].Y = 2.913333e+002f/600.0f*TESTAREAHEIGHT;
    pts[105].X = 2.350000e+002f/600.0f*TESTAREAWIDTH; pts[105].Y = 2.899999e+002f/600.0f*TESTAREAHEIGHT;
    pts[106].X = 2.300000e+002f/600.0f*TESTAREAWIDTH; pts[106].Y = 2.875333e+002f/600.0f*TESTAREAHEIGHT;
    pts[107].X = 2.252000e+002f/600.0f*TESTAREAWIDTH; pts[107].Y = 2.857333e+002f/600.0f*TESTAREAHEIGHT;
    pts[108].X = 2.210000e+002f/600.0f*TESTAREAWIDTH; pts[108].Y = 2.819999e+002f/600.0f*TESTAREAHEIGHT;
    pts[109].X = 2.158666e+002f/600.0f*TESTAREAWIDTH; pts[109].Y = 2.774666e+002f/600.0f*TESTAREAHEIGHT;

    pts[110].X = 2.125333e+002f/600.0f*TESTAREAWIDTH; pts[110].Y = 2.706666e+002f/600.0f*TESTAREAHEIGHT;
    pts[111].X = 2.070000e+002f/600.0f*TESTAREAWIDTH; pts[111].Y = 2.669999e+002f/600.0f*TESTAREAHEIGHT;
    pts[112].X = 2.047333e+002f/600.0f*TESTAREAWIDTH; pts[112].Y = 2.635999e+002f/600.0f*TESTAREAHEIGHT;
    pts[113].X = 2.058666e+002f/600.0f*TESTAREAWIDTH; pts[113].Y = 2.648666e+002f/600.0f*TESTAREAHEIGHT;
    pts[114].X = 2.040000e+002f/600.0f*TESTAREAWIDTH; pts[114].Y = 2.629999e+002f/600.0f*TESTAREAHEIGHT;
    pts[115].X = 2.047333e+002f/600.0f*TESTAREAWIDTH; pts[115].Y = 2.635999e+002f/600.0f*TESTAREAHEIGHT;
    pts[116].X = 2.058666e+002f/600.0f*TESTAREAWIDTH; pts[116].Y = 2.648666e+002f/600.0f*TESTAREAHEIGHT;
    pts[117].X = 2.040000e+002f/600.0f*TESTAREAWIDTH; pts[117].Y = 2.629999e+002f/600.0f*TESTAREAHEIGHT;


    BYTE typs[] = {
        00, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03, 03, 03,
        03, 03, 03, 03, 03, 03, 03, 03
    };


    INT count1 = count;
    INT offset1 = 0;
//    offset1 = 15;
//    count1 = 19;
    count1 -= offset1;
    GpPointF* pts1 = &pts[0] + offset1;
    BYTE* typs1 = &typs[0] + offset1;

    GraphicsPath* path
        = new GraphicsPath(pts1, typs1, count1);

    Matrix mat;
//    mat.Translate(-300, - 200);
//    path->Transform(&mat);
    Matrix mat1;
//    mat1.Scale(5, 5);
//    path->Transform(&mat1);

    REAL width = 20;
    Color color(128, 0, 0, 0);
    SolidBrush brush(color);
    Pen pen(&brush, width);
    pen.SetLineJoin(LineJoinRound);

    g->DrawPath(&pen, path);

    delete path;
}

VOID CPaths::TestLeakPath(Graphics* g)
{
    INT count = 83;
    GpPointF p[83];
    BYTE t[83];

    t[0] = 0;   p[0].X = 1106.0f/600.0f*TESTAREAWIDTH;  p[0].Y = 1751.0f/600.0f*TESTAREAHEIGHT;

    t[1] = 3;   p[1].X = 1083.0f/600.0f*TESTAREAWIDTH;  p[1].Y = 1733.0f/600.0f*TESTAREAHEIGHT;
    t[2] = 3;   p[2].X = 1050.0f/600.0f*TESTAREAWIDTH;  p[2].Y = 1735.0f/600.0f*TESTAREAHEIGHT;
    t[3] = 3;   p[3].X = 1029.0f/600.0f*TESTAREAWIDTH;  p[3].Y = 1756.0f/600.0f*TESTAREAHEIGHT;
    t[4] = 3;   p[4].X = 1014.0f/600.0f*TESTAREAWIDTH;  p[4].Y = 1771.0f/600.0f*TESTAREAHEIGHT;
    t[5] = 3;   p[5].X = 1009.0f/600.0f*TESTAREAWIDTH;  p[5].Y = 1792.0f/600.0f*TESTAREAHEIGHT;
    t[6] = 3;   p[6].X = 1013.0f/600.0f*TESTAREAWIDTH;  p[6].Y = 1811.0f/600.0f*TESTAREAHEIGHT;

    t[7] = 1;   p[7].X = 1014.0f/600.0f*TESTAREAWIDTH;  p[7].Y = 1811.0f/600.0f*TESTAREAHEIGHT;

    t[8] = 3;   p[8].X = 999.0f/600.0f*TESTAREAWIDTH;   p[8].Y = 1811.0f/600.0f*TESTAREAHEIGHT;
    t[9] = 3;   p[9].X = 985.0f/600.0f*TESTAREAWIDTH;   p[9].Y = 1817.0f/600.0f*TESTAREAHEIGHT;
    t[10] = 3;  p[10].X = 975.0f/600.0f*TESTAREAWIDTH;  p[10].Y = 1828.0f/600.0f*TESTAREAHEIGHT;
    t[11] = 3;  p[11].X = 952.0f/600.0f*TESTAREAWIDTH;  p[11].Y = 1850.0f/600.0f*TESTAREAHEIGHT;
    t[12] = 3;  p[12].X = 952.0f/600.0f*TESTAREAWIDTH;  p[12].Y = 1887.0f/600.0f*TESTAREAHEIGHT;
    t[13] = 3;  p[13].X = 974.0f/600.0f*TESTAREAWIDTH;  p[13].Y = 1909.0f/600.0f*TESTAREAHEIGHT;
    t[14] = 3;  p[14].X = 976.0f/600.0f*TESTAREAWIDTH;  p[14].Y = 1910.0f/600.0f*TESTAREAHEIGHT;
    t[15] = 3;  p[15].X = 977.0f/600.0f*TESTAREAWIDTH;  p[15].Y = 1912.0f/600.0f*TESTAREAHEIGHT;
    t[16] = 3;  p[16].X = 979.0f/600.0f*TESTAREAWIDTH;  p[16].Y = 1913.0f/600.0f*TESTAREAHEIGHT;

    t[17] = 1;  p[17].X = 979.0f/600.0f*TESTAREAWIDTH;  p[17].Y = 1913.0f/600.0f*TESTAREAHEIGHT;

    t[18] = 3;  p[18].X = 969.0f/600.0f*TESTAREAWIDTH;  p[18].Y = 1948.0f/600.0f*TESTAREAHEIGHT;
    t[19] = 3;  p[19].X = 978.0f/600.0f*TESTAREAWIDTH;  p[19].Y = 1986.0f/600.0f*TESTAREAHEIGHT;
    t[20] = 3;  p[20].X = 1004.0f/600.0f*TESTAREAWIDTH; p[20].Y = 2011.0f/600.0f*TESTAREAHEIGHT;
    t[21] = 3;  p[21].X = 1017.0f/600.0f*TESTAREAWIDTH; p[21].Y = 2024.0f/600.0f*TESTAREAHEIGHT;
    t[22] = 3;  p[22].X = 1033.0f/600.0f*TESTAREAWIDTH; p[22].Y = 2033.0f/600.0f*TESTAREAHEIGHT;
    t[23] = 3;  p[23].X = 1051.0f/600.0f*TESTAREAWIDTH; p[23].Y = 2038.0f/600.0f*TESTAREAHEIGHT;

    t[24] = 1;  p[24].X = 1051.0f/600.0f*TESTAREAWIDTH; p[24].Y = 2038.0f/600.0f*TESTAREAHEIGHT;

    t[25] = 3;  p[25].X = 1044.0f/600.0f*TESTAREAWIDTH; p[25].Y = 2067.0f/600.0f*TESTAREAHEIGHT;
    t[26] = 3;  p[26].X = 1053.0f/600.0f*TESTAREAWIDTH; p[26].Y = 2097.0f/600.0f*TESTAREAHEIGHT;
    t[27] = 3;  p[27].X = 1074.0f/600.0f*TESTAREAWIDTH; p[27].Y = 2118.0f/600.0f*TESTAREAHEIGHT;
    t[28] = 3;  p[28].X = 1101.0f/600.0f*TESTAREAWIDTH; p[28].Y = 2145.0f/600.0f*TESTAREAHEIGHT;
    t[29] = 3;  p[29].X = 1114.0f/600.0f*TESTAREAWIDTH; p[29].Y = 2151.0f/600.0f*TESTAREAHEIGHT;
    t[30] = 3;  p[30].X = 1179.0f/600.0f*TESTAREAWIDTH; p[30].Y = 2132.0f/600.0f*TESTAREAHEIGHT;


    t[31] = 1;  p[31].X = 1178.0f/600.0f*TESTAREAWIDTH; p[31].Y = 2132.0f/600.0f*TESTAREAHEIGHT;

    t[32] = 3;  p[32].X = 1181.0f/600.0f*TESTAREAWIDTH; p[32].Y = 2146.0f/600.0f*TESTAREAHEIGHT;
    t[33] = 3;  p[33].X = 1188.0f/600.0f*TESTAREAWIDTH; p[33].Y = 2159.0f/600.0f*TESTAREAHEIGHT;
    t[34] = 3;  p[34].X = 1198.0f/600.0f*TESTAREAWIDTH; p[34].Y = 2169.0f/600.0f*TESTAREAHEIGHT;
    t[35] = 3;  p[35].X = 1228.0f/600.0f*TESTAREAWIDTH; p[35].Y = 2198.0f/600.0f*TESTAREAHEIGHT;
    t[36] = 3;  p[36].X = 1275.0f/600.0f*TESTAREAWIDTH; p[36].Y = 2198.0f/600.0f*TESTAREAHEIGHT;
    t[37] = 3;  p[37].X = 1305.0f/600.0f*TESTAREAWIDTH; p[37].Y = 2168.0f/600.0f*TESTAREAHEIGHT;

    t[38] = 1;  p[38].X = 1306.0f/600.0f*TESTAREAWIDTH; p[38].Y = 2168.0f/600.0f*TESTAREAHEIGHT;

    t[39] = 3;  p[39].X = 1341.0f/600.0f*TESTAREAWIDTH; p[39].Y = 2194.0f/600.0f*TESTAREAHEIGHT;
    t[40] = 3;  p[40].X = 1390.0f/600.0f*TESTAREAWIDTH; p[40].Y = 2190.0f/600.0f*TESTAREAHEIGHT;
    t[41] = 3;  p[41].X = 1422.0f/600.0f*TESTAREAWIDTH; p[41].Y = 2158.0f/600.0f*TESTAREAHEIGHT;
    t[42] = 3;  p[42].X = 1436.0f/600.0f*TESTAREAWIDTH; p[42].Y = 2144.0f/600.0f*TESTAREAHEIGHT;
    t[43] = 3;  p[43].X = 1445.0f/600.0f*TESTAREAWIDTH; p[43].Y = 2126.0f/600.0f*TESTAREAHEIGHT;
    t[44] = 3;  p[44].X = 1448.0f/600.0f*TESTAREAWIDTH; p[44].Y = 2107.0f/600.0f*TESTAREAHEIGHT;

    t[45] = 1;  p[45].X = 1448.0f/600.0f*TESTAREAWIDTH; p[45].Y = 2106.0f/600.0f*TESTAREAHEIGHT;

    t[46] = 3;  p[46].X = 1457.0f/600.0f*TESTAREAWIDTH; p[46].Y = 2103.0f/600.0f*TESTAREAHEIGHT;
    t[47] = 3;  p[47].X = 1465.0f/600.0f*TESTAREAWIDTH; p[47].Y = 2097.0f/600.0f*TESTAREAHEIGHT;
    t[48] = 3;  p[48].X = 1472.0f/600.0f*TESTAREAWIDTH; p[48].Y = 2091.0f/600.0f*TESTAREAHEIGHT;
    t[49] = 3;  p[49].X = 1494.0f/600.0f*TESTAREAWIDTH; p[49].Y = 2068.0f/600.0f*TESTAREAHEIGHT;
    t[50] = 3;  p[50].X = 1499.0f/600.0f*TESTAREAWIDTH; p[50].Y = 2033.0f/600.0f*TESTAREAHEIGHT;
    t[51] = 3;  p[51].X = 1484.0f/600.0f*TESTAREAWIDTH; p[51].Y = 2006.0f/600.0f*TESTAREAHEIGHT;

    t[52] = 1;  p[52].X = 1489.0f/600.0f*TESTAREAWIDTH; p[52].Y = 2006.0f/600.0f*TESTAREAHEIGHT;

    t[53] = 3;  p[53].X = 1502.0f/600.0f*TESTAREAWIDTH; p[53].Y = 1981.0f/600.0f*TESTAREAHEIGHT;
    t[54] = 3;  p[54].X = 1499.0f/600.0f*TESTAREAWIDTH; p[54].Y = 1946.0f/600.0f*TESTAREAHEIGHT;
    t[55] = 3;  p[55].X = 1478.0f/600.0f*TESTAREAWIDTH; p[55].Y = 1925.0f/600.0f*TESTAREAHEIGHT;
    t[56] = 3;  p[56].X = 1464.0f/600.0f*TESTAREAWIDTH; p[56].Y = 1911.0f/600.0f*TESTAREAHEIGHT;
    t[57] = 3;  p[57].X = 1446.0f/600.0f*TESTAREAWIDTH; p[57].Y = 1905.0f/600.0f*TESTAREAHEIGHT;
    t[58] = 3;  p[58].X = 1427.0f/600.0f*TESTAREAWIDTH; p[58].Y = 1907.0f/600.0f*TESTAREAHEIGHT;

    t[59] = 1;  p[59].X = 1429.0f/600.0f*TESTAREAWIDTH; p[59].Y = 1907.0f/600.0f*TESTAREAHEIGHT;

    t[60] = 3;  p[60].X = 1430.0f/600.0f*TESTAREAWIDTH; p[60].Y = 1889.0f/600.0f*TESTAREAHEIGHT;
    t[61] = 3;  p[61].X = 1424.0f/600.0f*TESTAREAWIDTH; p[61].Y = 1871.0f/600.0f*TESTAREAHEIGHT;
    t[62] = 3;  p[62].X = 1412.0f/600.0f*TESTAREAWIDTH; p[62].Y = 1859.0f/600.0f*TESTAREAHEIGHT;
    t[63] = 3;  p[63].X = 1396.0f/600.0f*TESTAREAWIDTH; p[63].Y = 1843.0f/600.0f*TESTAREAHEIGHT;
    t[64] = 3;  p[64].X = 1374.0f/600.0f*TESTAREAWIDTH; p[64].Y = 1838.0f/600.0f*TESTAREAHEIGHT;
    t[65] = 3;  p[65].X = 1353.0f/600.0f*TESTAREAWIDTH; p[65].Y = 1845.0f/600.0f*TESTAREAHEIGHT;

    t[66] = 1;  p[66].X = 1352.0f/600.0f*TESTAREAWIDTH; p[66].Y = 1846.0f/600.0f*TESTAREAHEIGHT;

    t[67] = 3;  p[67].X = 1352.0f/600.0f*TESTAREAWIDTH; p[67].Y = 1828.0f/600.0f*TESTAREAHEIGHT;
    t[68] = 3;  p[68].X = 1345.0f/600.0f*TESTAREAWIDTH; p[68].Y = 1810.0f/600.0f*TESTAREAHEIGHT;
    t[69] = 3;  p[69].X = 1332.0f/600.0f*TESTAREAWIDTH; p[69].Y = 1797.0f/600.0f*TESTAREAHEIGHT;
    t[70] = 3;  p[70].X = 1314.0f/600.0f*TESTAREAWIDTH; p[70].Y = 1779.0f/600.0f*TESTAREAHEIGHT;
    t[71] = 3;  p[71].X = 1287.0f/600.0f*TESTAREAWIDTH; p[71].Y = 1773.0f/600.0f*TESTAREAHEIGHT;
    t[72] = 3;  p[72].X = 1262.0f/600.0f*TESTAREAWIDTH; p[72].Y = 1781.0f/600.0f*TESTAREAHEIGHT;

    t[73] = 1;  p[73].X = 1262.0f/600.0f*TESTAREAWIDTH; p[73].Y = 1781.0f/600.0f*TESTAREAHEIGHT;

    t[74] = 3;  p[74].X = 1258.0f/600.0f*TESTAREAWIDTH; p[74].Y = 1766.0f/600.0f*TESTAREAHEIGHT;
    t[75] = 3;  p[75].X = 1250.0f/600.0f*TESTAREAWIDTH; p[75].Y = 1752.0f/600.0f*TESTAREAHEIGHT;
    t[76] = 3;  p[76].X = 1239.0f/600.0f*TESTAREAWIDTH; p[76].Y = 1741.0f/600.0f*TESTAREAHEIGHT;
    t[77] = 3;  p[77].X = 1205.0f/600.0f*TESTAREAWIDTH; p[77].Y = 1706.0f/600.0f*TESTAREAHEIGHT;
    t[78] = 3;  p[78].X = 1149.0f/600.0f*TESTAREAWIDTH; p[78].Y = 1707.0f/600.0f*TESTAREAHEIGHT;
    t[79] = 3;  p[79].X = 1114.0f/600.0f*TESTAREAWIDTH; p[79].Y = 1742.0f/600.0f*TESTAREAHEIGHT;
    t[80] = 3;  p[80].X = 1111.0f/600.0f*TESTAREAWIDTH; p[80].Y = 1745.0f/600.0f*TESTAREAHEIGHT;
    t[81] = 3;  p[81].X = 1108.0f/600.0f*TESTAREAWIDTH; p[81].Y = 1748.0f/600.0f*TESTAREAHEIGHT;
    t[82] = 0x83;  p[82].X = 1106.0f/600.0f*TESTAREAWIDTH; p[82].Y = 1751.0f/600.0f*TESTAREAHEIGHT;


    INT count1 = count;
    INT offset1 = 0;
    count1 -= offset1;
    GpPointF* pts1 = &p[0] + offset1;
    BYTE* typs1 = &t[0] + offset1;

    GraphicsPath* path
        = new GraphicsPath(pts1, typs1, count1);

    RectF rect;
    path->GetBounds(&rect);
    
    Matrix m;
    m.Scale(0.8f, 0.8f);
    m.Scale(TESTAREAWIDTH/rect.Width, TESTAREAHEIGHT/rect.Height);
    m.Translate(-rect.X, -rect.Y);
    path->Transform(&m);

    REAL width = 6;
    Color color(128, 0, 0, 0);
    SolidBrush brush(color);
    Pen pen(&brush, width);
    pen.SetLineJoin(LineJoinRound);

    g->DrawPath(&pen, path);

    delete path;
}


VOID CPaths::TestExcelCurvePath(Graphics *g)
{
    INT count = 9;
    PointF p[9];
    BYTE t[] = {00, 01, 03, 03, 03, 03, 03, 03, 01};

    p[0].X = 4.070000e+002f/600.0f*TESTAREAWIDTH; p[0].Y = 8.400000e+001f/600.0f*TESTAREAHEIGHT;
    p[1].X = 1.324267e+002f/600.0f*TESTAREAWIDTH; p[1].Y = 1.177392e+002f/600.0f*TESTAREAHEIGHT;
    p[2].X = 1.324267e+002f/600.0f*TESTAREAWIDTH; p[2].Y = 1.196965e+002f/600.0f*TESTAREAHEIGHT;
    p[3].X = 1.332627e+002f/600.0f*TESTAREAWIDTH; p[3].Y = 1.217801e+002f/600.0f*TESTAREAHEIGHT;
    p[4].X = 1.350000e+002f/600.0f*TESTAREAWIDTH; p[4].Y = 1.240000e+002f/600.0f*TESTAREAHEIGHT;
    p[5].X = 1.590000e+002f/600.0f*TESTAREAWIDTH; p[5].Y = 1.546667e+002f/600.0f*TESTAREAHEIGHT;
    p[6].X = 3.550000e+002f/600.0f*TESTAREAWIDTH; p[6].Y = 2.113333e+002f/600.0f*TESTAREAHEIGHT;
    p[7].X = 5.510000e+002f/600.0f*TESTAREAWIDTH; p[7].Y = 2.680000e+002f/600.0f*TESTAREAHEIGHT;
    p[8].X = 5.510000e+002f/600.0f*TESTAREAWIDTH; p[8].Y = 2.680000e+002f/600.0f*TESTAREAHEIGHT;

    GraphicsPath* path
        = new GraphicsPath(p, t, count);

    REAL width = 1;
    Color color(128, 0, 0, 0);
    SolidBrush brush(color);
    Pen pen(&brush, width);

    g->DrawPath(&pen, path);

    delete path;
}

VOID CPaths::TestDegenerateBezierPath(Graphics *g)
{
    REAL width = 4;         // Pen width
    Point points[4];
    
    GraphicsPath* path = new GraphicsPath(FillModeWinding);
    points[0].X = INT_MIN;  points[0].Y = INT_MAX;
    points[1].X = INT_MIN;  points[1].Y = INT_MIN;
    points[2].X = INT_MIN;  points[2].Y = INT_MIN;
    points[3].X = INT_MIN;  points[3].Y = INT_MIN;
    path->AddBeziers(points, 4);

    Color blackColor(128, 0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    width = 6;
    Pen blackPen(&blackBrush, width);

    g->FillPath(&yellowBrush, path);
//    g->DrawPath(&blackPen, path);
    g->DrawBezier(&blackPen, points[0], points[1], points[2], points[3]);
    delete path;
}

VOID TestEscherNewPath(Graphics* g)
{
    INT count = 0x2b;
    PointF p[0x2b];
    BYTE t[0x2b];
    
    memset(&t[0], 3, count);
    t[0] = 0;

    p[0x00].X =  0.0000f; p[0x00].Y = 118.667f;
    p[0x01].X = 96.9648f; p[0x01].Y = 161.683f;
    p[0x02].X = 193.482f; p[0x02].Y = 204.793f;
    p[0x03].X = 232.976f; p[0x03].Y = 205.164f;
    p[0x04].X = 96.9648f; p[0x04].Y = 161.683f;
    p[0x05].X = 193.482f; p[0x05].Y = 204.793f;
    p[0x06].X = 232.976f; p[0x06].Y = 205.164f;
    p[0x07].X = 272.470f; p[0x07].Y = 205.534f;
    p[0x08].X = 233.440f; p[0x08].Y = 132.202f;
    p[0x09].X = 236.777f; p[0x09].Y = 120.799f;
    p[0x0a].X = 240.115f; p[0x0a].Y = 109.396f;
    p[0x0b].X = 246.233f; p[0x0b].Y = 126.083f;
    p[0x0c].X = 252.908f; p[0x0c].Y = 136.467f;
    p[0x0d].X = 259.583f; p[0x0d].Y = 146.850f;
    p[0x0e].X = 276.456f; p[0x0e].Y = 182.357f;
    p[0x0f].X = 276.827f; p[0x0f].Y = 182.914f;

    p[0x10].X = 259.583f; p[0x10].Y = 146.850f;
    p[0x11].X = 276.456f; p[0x11].Y = 182.357f;
    p[0x12].X = 276.827f; p[0x12].Y = 182.914f;
    p[0x13].X = 276.829f; p[0x13].Y = 182.917f;
    p[0x14].X = 276.831f; p[0x14].Y = 182.918f;
    p[0x15].X = 276.831f; p[0x15].Y = 182.918f;
    p[0x16].X = 276.832f; p[0x16].Y = 182.918f;
    p[0x17].X = 276.832f; p[0x17].Y = 182.917f;
    p[0x18].X = 276.832f; p[0x18].Y = 182.916f;
    p[0x19].X = 276.832f; p[0x19].Y = 182.546f;
    p[0x1a].X = 260.180f; p[0x1a].Y = 139.438f;
    p[0x1b].X = 255.890f; p[0x1b].Y = 139.438f;
    p[0x1c].X = 255.616f; p[0x1c].Y = 139.438f;
    p[0x1d].X = 255.392f; p[0x1d].Y = 139.614f;
    p[0x1e].X = 255.226f; p[0x1e].Y = 139.990f;
    p[0x1f].X = 252.445f; p[0x1f].Y = 146.294f;

    p[0x20].X = 256.524f; p[0x20].Y = 210.077f;
    p[0x21].X = 259.861f; p[0x21].Y = 220.831f;
    p[0x22].X = 263.199f; p[0x22].Y = 231.585f;
    p[0x23].X = 270.523f; p[0x23].Y = 207.296f;
    p[0x24].X = 275.066f; p[0x24].Y = 204.422f;
    p[0x25].X = 277.365f; p[0x25].Y = 202.967f;
    p[0x26].X = 279.427f; p[0x26].Y = 202.486f;
    p[0x27].X = 281.383f; p[0x27].Y = 202.486f;
    p[0x28].X = 283.292f; p[0x28].Y = 202.486f;
    p[0x29].X = 285.101f; p[0x29].Y = 202.944f;
    p[0x2a].X = 286.932f; p[0x2a].Y = 203.402f;


    GraphicsPath* path
        = new GraphicsPath(p, t, count);

    REAL width = 0.555903f;
    Color color(128, 0, 0, 0);
    SolidBrush brush(color);
    Pen pen(&brush, width);

    path->Widen(&pen);
    g->FillPath(&brush, path);

//    g->DrawPath(&pen, path);

    delete path;
}

VOID CPaths::TestPie(Graphics *g)
{
    // Provided by good old Nolan

    Color c(0xff, 0xff, 0, 0);
    SolidBrush b(c);
    Pen p(&b, 10.0f);

    Status status = g->DrawPie(&p, 75, 350, 800, 110, 180, 0);
//    ASSERT(status == Ok);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cprinter.h ===
/******************************Module*Header*******************************\
* Module Name: CPrinter.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRINTER_H
#define __CPRINTER_H

#include "COutput.h"

class CPrinter : public COutput  
{
public:
	CPrinter(BOOL bRegression);
	virtual ~CPrinter();

	BOOL Init();
	Graphics *PreDraw(int &nOffsetX,int &nOffsetY);			// Set up graphics at the given X,Y offset
	void PostDraw(RECT rTestArea);							// Finish off graphics at rTestArea

	HDC m_hDC;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cpathgradient.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   <an unabbreviated name for the module (not the filename)>
*
* Abstract:
*
*   <Description of what this module does>
*
* Notes:
*
*   <optional>
*
* Created:
*
*   08/30/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _CPATHGRADIENT_HPP
#define _CPATHGRADIENT_HPP

#include "CPrimitive.h"

class CPathGradient : public CPrimitive
{
public:
	CPathGradient(BOOL bRegression);
	void Draw(Graphics *g);
};

class CPathGradient2 : public CPrimitive
{
public:
	CPathGradient2(BOOL bRegression);
	void Draw(Graphics *g);
};

class CPathGradient3 : public CPrimitive
{
public:
	CPathGradient3(BOOL bRegression);
	void Draw(Graphics *g);
};


class CLinearGradient : public CPrimitive
{
public:
	CLinearGradient(BOOL bRegression);
	void Draw(Graphics *g);
};

class CLinearGradient2 : public CPrimitive
{
public:
	CLinearGradient2(BOOL bRegression);
	void Draw(Graphics *g);
};


#define PATHGRADIENT_GLOBALS \
CPathGradient g_PathGradient(true);\
CPathGradient2 g_PathGradient2(true);\
CPathGradient3 g_PathGradient3(true);\
CLinearGradient g_LinearGradient(true);\
CLinearGradient2 g_LinearGradient2(true);

#define PATHGRADIENT_INIT \
g_PathGradient.Init();\
g_PathGradient2.Init();\
g_PathGradient3.Init();\
g_LinearGradient.Init();\
g_LinearGradient2.Init();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cpaths.h ===
/******************************Module*Header*******************************\
* Module Name: CPaths.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPATHS_H
#define __CPATHS_H

#include "CPrimitive.h"

class CJoins : public CPrimitive  
{
public:
	CJoins(BOOL bRegression);
	virtual ~CJoins();

	void Draw(Graphics *g);
};

class CPaths : public CPrimitive  
{
public:
	CPaths(BOOL bRegression);
	virtual ~CPaths();

	void Draw(Graphics *g);

	VOID TestBezierPath(Graphics* g);
	VOID TestSinglePixelWidePath(Graphics* g);
	VOID TestTextAlongPath(Graphics* g);
	VOID TestFreeFormPath1(Graphics* g);
	VOID TestFreeFormPath2(Graphics* g);
	VOID TestLeakPath(Graphics* g);
	VOID TestExcelCurvePath(Graphics* g);
	VOID TestDegenerateBezierPath(Graphics* g);
        VOID TestPie(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cprinting.h ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRINTING_H
#define __CPRINTING_H

#include "..\CPrimitive.h"

class CPrinting : public CPrimitive  
{
public:
	CPrinting(BOOL bRegression);
	virtual ~CPrinting();

	void Draw(Graphics *g);

	VOID TestPerfPrinting(Graphics *g);
	VOID TestTextPrinting(Graphics *g);
        
        VOID TestNolan1(Graphics *g);
        VOID TestNolan2(Graphics *g);

        VOID TestBug104604(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cpolygons.h ===
/******************************Module*Header*******************************\
* Module Name: CPolygons.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPOLYGONS_H
#define __CPOLYGONS_H

#include "CPrimitive.h"

class CPolygons : public CPrimitive  
{
public:
	CPolygons(BOOL bRegression);
	virtual ~CPolygons();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cprimitives.h ===
/******************************Module*Header*******************************\
* Module Name: CPrimitives.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRIMITIVES_H
#define __CPRIMITIVES_H

#include "CPrimitive.h"

class CPrimitives : public CPrimitive  
{
public:
	CPrimitives(BOOL bRegression);
	virtual ~CPrimitives();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cprimitives.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrimitives.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrimitives.h"

CPrimitives::CPrimitives(BOOL bRegression)
{
	strcpy(m_szName,"Primitives");
	m_bRegression=bRegression;
}

CPrimitives::~CPrimitives()
{
}

void CPrimitives::Draw(Graphics *g)
{
    Rect rect;

    rect.X = (int)(100.0f/400.0f*TESTAREAWIDTH);
    rect.Y = (int)(160.0f/400.0f*TESTAREAHEIGHT);
    rect.Width = (int)(230.0f/400.0f*TESTAREAWIDTH);
    rect.Height = (int)(180.0f/400.0f*TESTAREAHEIGHT);

    Color color(128, 128, 255, 0);

    SolidBrush brush(color);

    REAL width = 1;

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen pen(&blackBrush, width);

//    g->FillEllipse(&brush, rect);
//    g->DrawEllipse(&pen, rect);
    REAL startAngle = 0;
    REAL sweepAngle = 240;
    g->FillPie(&brush, rect, startAngle, sweepAngle);
    g->DrawPie(&pen, rect, startAngle, sweepAngle);

    Point pts[10];
    INT count = 4;

    pts[0].X = (int)(100.0f/400.0f*TESTAREAWIDTH);
    pts[0].Y = (int)(60.0f/400.0f*TESTAREAHEIGHT);
    pts[1].X = (int)(50.0f/400.0f*TESTAREAWIDTH);
    pts[1].Y = (int)(130.0f/400.0f*TESTAREAHEIGHT);
    pts[2].X = (int)(200.0f/400.0f*TESTAREAWIDTH);
    pts[2].Y = (int)(260.0f/400.0f*TESTAREAHEIGHT);
    pts[3].X = (int)(300.0f/400.0f*TESTAREAWIDTH);
    pts[3].Y = (int)(80.0f/400.0f*TESTAREAHEIGHT);

    g->FillClosedCurve(&brush, pts, count);
    g->DrawClosedCurve(&pen, pts, count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cprinter.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrinter.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrinter.h"

CPrinter::CPrinter(BOOL bRegression)
{
    m_hDC=NULL;
    strcpy(m_szName,"Printer");
    m_bRegression=bRegression;
}

CPrinter::~CPrinter()
{
}

BOOL CPrinter::Init()
{
    return COutput::Init();
}

Graphics *CPrinter::PreDraw(int &nOffsetX,int &nOffsetY)
{
    Graphics *g=NULL;

    PRINTDLGA pd =
    {
       sizeof(PRINTDLG),
       NULL,            // hwndOwner
       NULL,            // hDevMode
       NULL,            // hDevNames
       NULL,            // hDC
       PD_RETURNDC,
       1,
       1,
       1,
       1,
       1,
       GetModuleHandleA(NULL),
       NULL,
       NULL,            // print hook
       NULL,            // setup hook
       NULL,            // print template name
       NULL,            // setup template name
       NULL,            // hPrintTemplate
       NULL             // hSetupTemplate
    };

    if (!PrintDlgA(&pd))
    {
       MessageBoxA(NULL, "No printer selected.", NULL, MB_OK);
       return NULL;
    }

    DOCINFOA docinfo;
    docinfo.cbSize        = sizeof(DOCINFO);
    docinfo.lpszDocName   = "GDI+ Print Test";
    docinfo.lpszOutput    = NULL;         // put name here to output to file
    docinfo.lpszDatatype  = NULL;         // data type 'emf' or 'raw'
    docinfo.fwType        = 0;

    m_hDC = pd.hDC;
    INT printJobID = StartDocA(m_hDC, &docinfo);
    StartPage(m_hDC);

    SetStretchBltMode(m_hDC, HALFTONE);
    SetBrushOrgEx(m_hDC, 0, 0, NULL);

    g = Graphics::FromHDC(m_hDC);

    return g;
}

void CPrinter::PostDraw(RECT rTestArea)
{
    EndPage(m_hDC);
    EndDoc(m_hDC);
    DeleteDC(m_hDC);

    MessageBoxA(NULL, "Print Functionality Test Complete.", NULL, MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cquality.cpp ===
/******************************Module*Header*******************************\
* Module Name: CQuality.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CQuality.h"

CQuality::CQuality(BOOL bRegression)
{
	strcpy(m_szName,"Quality");
	m_bRegression=bRegression;
}

CQuality::~CQuality()
{
}

void CQuality::Set(Graphics *g)
{
	g->SetCompositingQuality(m_bUseSetting ? CompositingQualityHighQuality : CompositingQualityHighSpeed);
}

CCompositingMode::CCompositingMode(BOOL bRegression)
{
	strcpy(m_szName,"Source Copy");
	m_bRegression=bRegression;
}

CCompositingMode::~CCompositingMode()
{
}

void CCompositingMode::Set(Graphics *g)
{
	g->SetCompositingMode(m_bUseSetting ? CompositingModeSourceCopy : CompositingModeSourceOver);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\creadwrite.h ===
/******************************Module*Header*******************************\
* Module Name: CReadWrite.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CREADWRITE_H
#define __CREADWRITE_H

#include "CPrimitive.h"

class CReadWrite : public CPrimitive  
{
public:
	CReadWrite(BOOL bRegression);
	virtual ~CReadWrite();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\creadwrite.cpp ===
/******************************Module*Header*******************************\
* Module Name: CReadWrite.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CReadWrite.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CReadWrite::CReadWrite(BOOL bRegression)
{
	strcpy(m_szName,"ReadWrite");
	m_bRegression=bRegression;
}

CReadWrite::~CReadWrite()
{
}

void CReadWrite::Draw(Graphics *g)
{
	Bitmap *paBmTest=new Bitmap((int)TESTAREAWIDTH,(int)TESTAREAHEIGHT,PixelFormat32bppARGB);
	Graphics *gTest;
	HDC hdcBkgBitmap;
	HDC hdcScreen;

	gTest=new Graphics(paBmTest);
	gTest->Clear(Color(255,206,206,206));
	delete gTest;
	g->DrawImage(paBmTest,0,0,0,0,(int)TESTAREAWIDTH,(int)TESTAREAHEIGHT,UnitPixel);

	for (int i=0;i<20;i++) {
		hdcScreen=g->GetHDC();

		gTest=new Graphics(paBmTest);
		hdcBkgBitmap=gTest->GetHDC();
		StretchBlt(hdcBkgBitmap,0,0,(int)TESTAREAWIDTH,(int)TESTAREAHEIGHT,hdcScreen,m_ix,m_iy,(int)TESTAREAWIDTH,(int)TESTAREAHEIGHT,SRCCOPY);
		gTest->ReleaseHDC(hdcBkgBitmap);
		delete gTest;

		g->ReleaseHDC(hdcScreen);

		g->DrawImage(paBmTest,0,0,0,0,(int)TESTAREAWIDTH,(int)TESTAREAHEIGHT,UnitPixel);
	}

	delete paBmTest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cquality.h ===
/******************************Module*Header*******************************\
* Module Name: CQuality.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CQUALITY_H
#define __CQUALITY_H

#include "CSetting.h"

class CQuality : public CSetting  
{
public:
	CQuality(BOOL bRegression);
	virtual ~CQuality();

	void Set(Graphics *g);
};

class CCompositingMode : public CSetting  
{
public:
	CCompositingMode(BOOL bRegression);
	virtual ~CCompositingMode();

	void Set(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cprinting.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrinting.h"

CPrinting::CPrinting(BOOL bRegression)
{
	strcpy(m_szName,"Printing");
	m_bRegression=bRegression;
}

CPrinting::~CPrinting()
{
}

VOID CPrinting::TestTextPrinting(Graphics *g)
{
    Font f(L"Arial", 60);

    FontFamily  ff(L"Arial");
    RectF	  rectf1( 20,   0, 300, 200);
    RectF	  rectf2( 20, 300, 300, 200);
    RectF	  rectf3(220,   0, 300, 200);
    RectF	  rectf4(220, 300, 300, 200);


    Color color1(0xff, 100, 0, 200);
    Color color2(128, 100, 0, 200);
    Color color3(0xff, 0, 100, 200);
    Color color4(128, 0, 100, 0);
    SolidBrush brush1(color1);
    SolidBrush brush2(color2);
    LinearGradientBrush brush3(rectf3, color3, color4, LinearGradientModeForwardDiagonal);

    g->DrawString(L"Color1", 6, &f, rectf1, NULL, &brush1);
    g->DrawString(L"Color2", 6, &f, rectf2, NULL, &brush2);
    g->DrawString(L"Color3", 6, &f, rectf3, NULL, &brush3);
}

VOID CPrinting::TestPerfPrinting(Graphics *g)
{
/*
   Analyze file size based on output of StretchDIBits.  The claim by DonC is that when we StretchDIBits a
   subrectangle of a large DIB, it sends the large DIB to the printer and then clips to the subrectangle.
   How stupid, but it apparently does on Win98 postscript.

   So this is the results of my test:  1000x1000 DIB (32bpp).  I blitted two chunks:

   This is 200x200 source rectangle (part of a band):

04/27/2000  03:00p              22,198 nt5pcl
04/27/2000  03:02p             268,860 nt5ps			// Level 1 ps
04/27/2000  02:47p              17,488 w98pcl
04/27/2000  02:47p           6,207,459 w98ps			// Level 1 ps

   This is 1000x200 source rectangle (an entire band):

04/27/2000  03:06p              80,291 nt5pcl
04/27/2000  03:06p           1,266,123 nt5ps			// Level 1 ps
04/27/2000  02:51p              60,210 w98pcl
04/27/2000  02:52p           6,207,457 w98ps			// Level 1 ps

   Also compared 32bpp vs. 24bpp DIB.  The results were contradictary:

  04/27/2000  03:59p      <DIR>          ..
  04/27/2000  03:06p              80,291 nt5pcl
  04/27/2000  03:51p             122,881 nt5pcl24
  04/27/2000  03:06p           1,266,123 nt5ps
  04/27/2000  03:51p           1,262,332 nt5ps24
  04/27/2000  02:51p              60,210 w98pcl
  04/27/2000  03:39p             101,216 w98pcl24
  04/27/2000  02:52p           6,207,457 w98ps
  04/27/2000  03:39p           6,207,457 w98ps24

*/
    if (1) 
    {
        BITMAPINFO bi;
        ZeroMemory(&bi, sizeof(BITMAPINFO));

        bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biSizeImage = 0;

        bi.bmiHeader.biWidth = 1000;
        bi.bmiHeader.biHeight = 1000;
        bi.bmiHeader.biBitCount = 32;

        ARGB* Bits = (ARGB*)malloc(bi.bmiHeader.biWidth *
                              bi.bmiHeader.biHeight *
                              sizeof(ARGB));

        ARGB* Ptr = Bits;

        // To eliminate RLE/ASCII85 encoding, set to random bits
        for (INT i=0; i<bi.bmiHeader.biHeight; i++)
            for (INT j=0; j<bi.bmiHeader.biWidth; j++) 
            {
                *Ptr++ = (ARGB)(i | (j<<16));
            }

        HDC hdc = g->GetHDC();

        StretchDIBits(hdc, 0, 0, 1000, 200, 
                      0, 700, 1000, 200, Bits, &bi,
                      DIB_RGB_COLORS, SRCCOPY);

        g->ReleaseHDC(hdc);

        free(Bits);

    }
}

void CPrinting::Draw(Graphics *g)
{
// TestPerfPrinting(g);
// TestTextPrinting(g);
TestBug104604(g);

if (0)
    {

#if 1
    HDC hdc = g->GetHDC();

    HDC bufHdc = CreateCompatibleDC(hdc);

    HBITMAP BufDIB = NULL;
    ARGB* argb;

    struct {
       BITMAPINFO bitmapInfo;
       RGBQUAD rgbQuad[4];
    } bmi;

    INT width=100;
    INT height=100;

    ZeroMemory(&bmi.bitmapInfo, sizeof(bmi.bitmapInfo));

    bmi.bitmapInfo.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bitmapInfo.bmiHeader.biWidth       = width;
    bmi.bitmapInfo.bmiHeader.biHeight      = -height;
    bmi.bitmapInfo.bmiHeader.biPlanes      = 1;
    bmi.bitmapInfo.bmiHeader.biBitCount    = 24;
    bmi.bitmapInfo.bmiHeader.biCompression = BI_RGB;
	
    RGBQUAD red = { 0, 0, 0xFF, 0}; // red
    RGBQUAD green = { 0, 0xFF, 0, 0}; // green
    RGBQUAD blue = { 0xFF, 0, 0, 0}; // blue

    bmi.bitmapInfo.bmiColors[0] = red;
    bmi.bitmapInfo.bmiColors[1] = green;
    bmi.bitmapInfo.bmiColors[2] = blue;

    // if assert fails, then we didn't clean up properly by calling End()
//    ASSERT(BufDIB == NULL);

    BufDIB = CreateDIBSection(bufHdc,
                 &bmi.bitmapInfo,
                 DIB_RGB_COLORS,
                 (VOID**) &argb,
                 NULL,
                 0);
//    ASSERT(BufDIB != NULL);

    memset(argb, 0, 3*width*height);

    INT i,j;
    BYTE* tempptr = (BYTE*)argb;
    for (i=0; i<height; i++)
    {
        for (j=0; j<width; j++)
        {
            if (i==j)
            {
                *tempptr++ = 0xFF;
                *tempptr++ = 0x80;
                *tempptr++ = 0x40;
            }
            else
                tempptr += 3;    
        }
        if ((((ULONG_PTR)tempptr) % 4) != 0) tempptr += 4-(((ULONG_PTR)tempptr) % 4);
    }

    INT mode = GetMapMode(bufHdc);
//    WARNING(("MapMode printing = %08x\n", mode));

    SelectObject(bufHdc, BufDIB);
/*
for (i=0; i<100; i++)
{
    int result = StretchBlt(hdc, 0, i*2, 2*width, 2, bufHdc, 0, i, width, 0, SRCCOPY);
    INT joke = GetLastError();
	joke++;
}
 */
//	int result = StretchBlt(hdc, 0, 0, 50, 50, bufHdc, 0, 0, 50, 50, SRCCOPY);
	
	for (i=0; i<50; i++)
	{
		int result = StretchBlt(hdc, 0, 100+i*2, 100, 1, bufHdc, 0, i*2, 100, 1, SRCCOPY);
    }
//   int result = StretchBlt(hdc, 0, 0, 200, 200, bufHdc, 0, 0, 100, 100, SRCCOPY);

//    ASSERT(result != 0);

    g->ReleaseHDC(hdc);

    DeleteDC(bufHdc);
    DeleteObject(BufDIB);

#endif

#if 1
    REAL widthF = 4; // Pen width

    Color redColor(255, 0, 0);

    SolidBrush brush1(Color(0xFF,0xFF,0,0));
    SolidBrush brush2(Color(0x80,0x80,0,0));

    SolidBrush brush3(Color(0xFF,0xFF,0,0));
    SolidBrush brush4(Color(0x80,0x80,0,0));

    Color colors1[] = { Color(0xFF,0xFF,0,0),
                        Color(0xFF,0,0xFF,0),
                        Color(0xFF,0,0,0xFF),
                        Color(0xFF,0x80,0x80,0x80) };
    Color colors2[] = { Color(0x80,0xFF,0,0),
                        Color(0x80,0,0xFF,0),
                        Color(0x80,0,0,0xFF),
                        Color(0x80,0x80,0x80,0x80) };

    //SolidBrush brush3(colors1[2]);
    //SolidBrush brush4(colors2[2]);

    // Default Wrap: Clamp to small rectangle 
//    RectangleGradientBrush brush3(Rect(125,275,50,50),
//                                  &colors1[0]);//,
                                  //WrapModeClamp);
    // Default Wrap: Clamp to 
//    RectangleGradientBrush brush4(Rect(250,250,100,100),
//                                  &colors2[0]);//,
                                  //WrapModeClamp);

    g->SetPageScale(1.2f);

    // no path clip
    g->FillRectangle(&brush1, Rect(0,25,500,50));

    // tests solid + opaque combinations + path clip only
    g->FillEllipse(&brush1, Rect(100,100,100,100));
    g->FillEllipse(&brush2, Rect(300,100,100,100));
    g->FillEllipse(&brush3, Rect(100,250,100,100));
    g->FillEllipse(&brush4, Rect(300,250,100,100));

    // tests visible clip + path clip
    Region origRegion;
    g->GetClip(&origRegion);
    Region *newRegion = new Region();
    newRegion->MakeInfinite();

    //Rect horzRect(150, 600, 500, 25);
    //Rect vertRect(150, 600, 25, 500);
    Rect horzRect(100, 400, 500, 25);
    Rect vertRect(100, 400, 25, 500);
    Region *horzRegion = new Region(horzRect);
    Region *vertRegion = new Region(vertRect);

    for (i = 0; i < 10; i++)
    {   
        newRegion->Xor(horzRegion);
        newRegion->Xor(vertRegion);
        horzRegion->Translate(0, 50);
        vertRegion->Translate(50, 0);
    }
    delete horzRegion;
    delete vertRegion;

    // Set grid clipping
    g->SetClip(newRegion);

    // set wrap mode from Clamp to Tile    
//    brush3.SetWrapMode(WrapModeTile);
//    brush4.SetWrapMode(WrapModeTile);

    // tests solid + opaque combinations + visible clip +  path clip only

    g->FillEllipse(&brush1, Rect(100,400,100,100));
    g->FillEllipse(&brush2, Rect(300,400,100,100));
    g->FillEllipse(&brush3, Rect(100,550,100,100));
    g->FillEllipse(&brush4, Rect(300,550,100,100));

    // restore original clip region
    g->SetClip(&origRegion);
    delete newRegion;

    // Test case which stretches beyond GetTightBounds() DrawBounds API

    PointF pts[8];

    pts[0].X = 2150.0f; pts[0].Y = 2928.03f;
    pts[1].X = 1950.0f; pts[1].Y = 3205.47f;
    pts[2].X = 1750.0f; pts[2].Y = 2650.58f;
    pts[3].X = 1550.0f; pts[3].Y = 2928.03f;
    pts[4].X = 1550.0f; pts[4].Y = 3371.97f;
    pts[5].X = 1750.0f; pts[5].Y = 3094.53f;
    pts[6].X = 1950.0f; pts[6].Y = 3649.42f;
    pts[7].X = 2150.0f; pts[7].Y = 3371.97f;

    BYTE types[8] = { 1, 3, 3, 3, 1, 3, 3, 0x83 };


    Bitmap *bitmap = new Bitmap(L"winnt256.bmp");

    // Test g->DrawImage
    if (bitmap && bitmap->GetLastStatus() == Ok) 
    {

        int i;

        for (i=0; i<8; i++) 
        {
            pts[i].X = pts[i].X / 8.0f;
            pts[i].Y = pts[i].Y / 8.0f;
        }

        TextureBrush textureBrush(bitmap, WrapModeTile);

        GraphicsPath path(&pts[0], &types[0], 8);

        g->FillPath(&textureBrush, &path);

        // Text using WrapModeClamp
        for (i=0; i<8; i++)
           pts[i].X += 200.0f;

        TextureBrush textureBrush2(bitmap, WrapModeClamp);

        GraphicsPath path2(&pts[0], &types[0], 8);

        g->FillPath(&textureBrush2, &path2);

        delete bitmap;
    }

/*
    Font font(50.0f * g->GetDpiY() / 72.0f, // emSize
              FontFamily(L"Arial"), // faceName,
              0,
              (Unit)g->GetPageUnit()
              );

    // will fail on Win9x
    LPWSTR str = L"Printing Support is COOL";
    GpRectF layoutRect1(200, 200, 300, 100);
    GpRectF layoutRect2(200, 400, 300, 100);
    GpRectF layoutRect3(200, 600, 300, 100);
    GpRectF layoutRect4(200, 800, 300, 100);

    INT len = 0;
    LPWSTR strPtr = str;
    while (*str != '\0') { len++; str++; }

    StringFormat format1 = StringFormatDirectionRightToLeft;
    StringFormat format2 = StringFormatDirectionVertical;
    StringFormat format3 = StringFormatDirectionRightToLeft;
    StringFormat format4 = StringFormatDirectionVertical;

    // Test DDI: SolidText (Brush 1 or 2)
    g->DrawString(strPtr, len, &font, &layoutRect1, &format1, &brush1);
    g->DrawString(strPtr, len, &font, &layoutRect2, &format2, &brush2);   

    // Test DDI: BrushText (Brush 3 or 4)
    g->DrawString(strPtr, len, &font, &layoutRect3, &format3, &brush3);
    g->DrawString(strPtr, len, &font, &layoutRect4, &format4, &brush4);   

    // Test DDI: StrokePath
    // Test DDI: FillRegion
*/
#endif
    }

}

// Try this from Nolan Lettelier
VOID CPrinting::TestNolan1(Graphics *g)
{
/*	TestInit(hdc);

	Graphics *pg = Graphics::FromHDC(hdc);
	if (pg == NULL)
	{
		assert(0);
		return false;
	}

	int sts;
	int alpha = 255, red = 255, green = 0, blue = 255;
	Color c1(alpha,red,green,blue);
	Point p1(150,150), p2(300,300);
	Color c2(255, 255-red, 255-green, 255-blue);
	LineGradientBrush gb(p1, p2, c1, c2);

	Pen p(&gb, 50.0);

	sts = pg->DrawLine(&p,0, 0, 500, 500);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,100, 500, 100);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,350, 500, 350);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,500, 500, 0);
	assert(sts == Ok);
	delete pg;
	return true;
        */
}

VOID CPrinting::TestNolan2(Graphics *g)
{
    /*
        CString lineText("NolanRules");
        
	Graphics *pg = g;
        if (pg == NULL)
	{
		assert(0);
		return false;
	}
        Unit origUnit = pg->GetPageUnit();
        Matrix origXform;
        pg->GetTransform(&origXform);

        pg->SetPageUnit(UnitInch);
        pg->ScaleTransform(8.0f/1000.0f, 8.0f/1000.0f);

	Status sts;
	int alpha = 255, red = 255, green = 0, blue = 255;
	RectF rg(150,150,300,175);
	Color c1(alpha,red,green,blue);
	Color c2(255, 255-red, 255-green, 255-blue);
	LineGradientBrush gb(rg, c1, c2, LineGradientModeVertical);

	WCHAR *famName[] = {
		L"Comic Sans MS"
		, L"Courier New"
		, L"Times New Roman"
		, L"Tahoma"
		, L"Arial"
		, L"Lucida Console"
		, L"Garamond"
		, L"Palatino"
		, L"Univers"
		, L"Marigold"
		, L"Albertus"
		, L"Antique Olive"
	};

	int famCount = sizeof(famName) / sizeof(WCHAR *);

	WCHAR *s = L"GDI+ GradientFill";
	
	RectF r(30,30,0,0);
	StringFormat sf(0);
	FontFamily *pFontFamily;

	float lineHeight = 60;
	int i;
	for (i = 0, r.Y = 30 ; r.Y < 800 ; r.Y += lineHeight, ++i)
	{
		pFontFamily = new FontFamily(famName[i % famCount]);
		while (pFontFamily == NULL || pFontFamily->GetLastStatus()
!= Ok)
		{
			delete pFontFamily;
			++i;
			pFontFamily = new FontFamily(famName[i % famCount]);
		}
			
		Font f(*pFontFamily, lineHeight * 5 / 6, 0, UnitPoint);
		sts = pg->DrawString(s, wcslen(s), &f, &r, &sf, &gb);
//		CHECK_RESULT(sts, "TestGradientLinearVertical2 DrawString");
		delete pFontFamily;
	}

	delete pg;
	
        pg->SetPageUnit(origUnit);
        pg->SetTransform(&origXform);
        return true;
*/

} // TestGradientLinearVertical2

VOID CPrinting::TestBug104604(Graphics *g)
{
    BYTE* memory = new BYTE[8*8*3];
    // checkerboard pattern
    for (INT i=0; i<8*8; i += 3)
    {
        if (i%2)
        {
            memory[i] = 0xff;
            memory[i+1] = 0;
            memory[i+2] = 0;
        }
        else
        {
            memory[i] = 0;
            memory[i+1] = 0;
            memory[i+2] = 0xff;
        }
    }
    
    Bitmap bitmap(8,8, 8*3, PixelFormat24bppRGB, memory);
    
    TextureBrush brush(&bitmap);

    g->SetCompositingMode(CompositingModeSourceCopy);
    g->FillRectangle(&brush, 0, 0, 100, 100);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\crecolor.h ===
/******************************Module*Header*******************************\
* Module Name: CRecolor.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  06-06-2000 Adrian Secchia [asecchia]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CRECOLOR_H
#define __CRECOLOR_H

#include "CPrimitive.h"

class CRecolor : public CPrimitive  
{
public:
	CRecolor(BOOL bRegression);
	virtual ~CRecolor();

	void Draw(Graphics *g);

	static BOOL CALLBACK MyDrawImageAbort(VOID* data);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\crecolor.cpp ===
/******************************Module*Header*******************************\
* Module Name: CRecolor.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  06-06-2000 Adrian Secchia [asecchia]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CRecolor.h"

CRecolor::CRecolor(BOOL bRegression)
{
	strcpy(m_szName,"Image : Recolor");
	m_bRegression=bRegression;
}

CRecolor::~CRecolor()
{
}

BOOL CALLBACK CRecolor::MyDrawImageAbort(VOID* data)
{
    UINT *count = (UINT*) data;

    *count += 1;

    return FALSE;
}

void CRecolor::Draw(Graphics *g)
{
    // Load bmp files.

    WCHAR *filename = L"..\\data\\winnt256.bmp";
    Image *image = new Image(filename);
    
    UINT abortCount = 0;

    ImageAttributes imgAttrib;

    Point destTopLeft(2, 2);

    Rect destRect(
        destTopLeft.X,
        destTopLeft.Y,
        (int)(TESTAREAWIDTH/3)-2, 
        (int)(TESTAREAHEIGHT/3)-2
    );

    // Make near-white to white transparent

    Color c1(200, 200, 200);
    Color c2(255, 255, 255);
    imgAttrib.SetColorKey(c1, c2);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    ColorMatrix darkMatrix = {.75, 0, 0, 0, 0,
                              0, .75, 0, 0, 0,
                              0, 0, .75, 0, 0,
                              0, 0, 0, 1, 0,
                              0, 0, 0, 0, 1};

    ColorMatrix greyMatrix = {.25, .25, .25, 0, 0,
                              .25, .25, .25, 0, 0,
                              .25, .25, .25, 0, 0,
                              0, 0, 0, 1, 0,
                              (REAL).1, (REAL).1, (REAL).1, 0, 1};

    ColorMatrix pinkMatrix = {(REAL).33, .25, .25, 0, 0,
                              (REAL).33, .25, .25, 0, 0,
                              (REAL).33, .25, .25, 0, 0,
                              0, 0, 0, 1, 0,
                              0, 0, 0, 0, 1};

    // red->blue, green->red, blue->green, alpha = 0.75
    ColorMatrix swapMatrix = {0, 0, 1, 0, 0,
                              1, 0, 0, 0, 0,
                              0, 1, 0, 0, 0,
                              0, 0, 0, .75, 0,
                              0, 0, 0, 0, 1};

    // red->blue, green->red, blue->green, alpha = 0.9
    ColorMatrix swapMatrix2 = {0, 0, 1, 0, 0,
                               1, 0, 0, 0, 0,
                               0, 1, 0, 0, 0,
                               0, 0, 0, 0, 0,
                               0, 0, 0, (REAL).9, 1};

    imgAttrib.ClearColorKey();
    imgAttrib.SetColorMatrix(&greyMatrix);

    destRect.Y += destRect.Height;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    imgAttrib.SetColorMatrix(&pinkMatrix, ColorMatrixFlagsSkipGrays);

    destRect.Y += destRect.Height;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    imgAttrib.SetColorMatrix(&darkMatrix);

    destRect.X += destRect.Width;
    destRect.Y = destTopLeft.Y;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    destRect.Y += destRect.Height;

    imgAttrib.ClearColorMatrix();
    imgAttrib.SetGamma(3.0);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    destRect.Y += destRect.Height;

    imgAttrib.SetThreshold(0.5);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    imgAttrib.SetColorMatrix(&swapMatrix);
    imgAttrib.ClearGamma();
    imgAttrib.ClearThreshold();

    destRect.X += destRect.Width;
    destRect.Y = destTopLeft.Y;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    destRect.Y += destRect.Height;

    imgAttrib.SetNoOp();
    imgAttrib.SetColorMatrix(&swapMatrix2);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    destRect.Y += destRect.Height;

    imgAttrib.ClearNoOp();

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    delete image;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cregions.cpp ===
/******************************Module*Header*******************************\
* Module Name: CRegions.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CRegions.h"
#include <math.h>

CRegions::CRegions(BOOL bRegression)
{
	strcpy(m_szName,"Regions");
	m_bRegression=bRegression;
}

CRegions::~CRegions()
{
}

void CRegions::Draw(Graphics *g)
{
    REAL width = 2;     // Pen width
    PointF points[5];
    
    REAL s, c, theta;
    REAL pi = 3.1415926535897932f;
    PointF orig((int)(TESTAREAWIDTH/2.0f), (int)(TESTAREAHEIGHT/2.0f));

    theta = -pi/2;

    // Create a star shape.
    for(INT i = 0; i < 5; i++)
    {
        s = sinf(theta);
        c = cosf(theta);
        points[i].X = (int)(125.0f/250.0f*TESTAREAWIDTH)*c + orig.X;
        points[i].Y = (int)(125.0f/250.0f*TESTAREAHEIGHT)*s + orig.Y;
        theta += 0.8f*pi;
    }

    Color orangeColor(128, 255, 180, 0);

    SolidBrush orangeBrush(orangeColor);
    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
//    Path* path = new GraphicsPath(Winding);
    path->AddPolygon(points, 5);
    
    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);
    Region * region = new Region(path);

    g->FillRegion(&orangeBrush, region);  // There is a BUG!
//    g->FillGraphicsPath(&orangeBrush, path);  // Fill path works fine.
    
    blackPen.SetLineJoin(LineJoinMiter);
    g->DrawPath(&blackPen, path);
    delete path;
    delete region;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\csetting.cpp ===
/******************************Module*Header*******************************\
* Module Name: CSetting.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CSetting.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CSetting::CSetting()
{
	strcpy(m_szName,"No name assigned");
	m_bUseSetting=false;
	m_bRegression=false;
}

CSetting::~CSetting()
{

}

BOOL CSetting::Init()
{
	g_FuncTest.AddSetting(this);
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cregression.h ===
/******************************Module*Header*******************************\
* Module Name: CRegression.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CREGRESSION_H
#define __CREGRESSION_H

#include "CPrimitive.h"

class CRegression : public CPrimitive  
{
public:
	CRegression(BOOL bRegression);
	virtual ~CRegression();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cregression.cpp ===
/******************************Module*Header*******************************\
* Module Name: CRegression.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CRegression.h"

CRegression::CRegression(BOOL bRegression)
{
	strcpy(m_szName,"Regression");
	m_bRegression=bRegression;
}

CRegression::~CRegression()
{
}

void CRegression::Draw(Graphics *g)
{
    REAL width = 4; // Pen width

    Color redColor(255, 0, 0);

    SolidBrush redBrush(redColor);
    g->FillRectangle(&redBrush, (int)(20.0f/150.0f*TESTAREAWIDTH), (int)(20.0f/150.0f*TESTAREAHEIGHT), (int)(50.0f/150.0f*TESTAREAWIDTH), (int)(50.0f/150.0f*TESTAREAHEIGHT));

    Color alphaColor(128, 0, 255, 0);

    SolidBrush alphaBrush(alphaColor);
    g->FillRectangle(&alphaBrush, (int)(10.0f/150.0f*TESTAREAWIDTH), (int)(10.0f/150.0f*TESTAREAHEIGHT), (int)(40.0f/150.0f*TESTAREAWIDTH), (int)(40.0f/150.0f*TESTAREAHEIGHT));

    Point points[4];
    points[0].X = (int)(50.0f/150.0f*TESTAREAWIDTH);
    points[0].Y = (int)(50.0f/150.0f*TESTAREAHEIGHT);
    points[1].X = (int)(100.0f/150.0f*TESTAREAWIDTH);
    points[1].Y = (int)(50.0f/150.0f*TESTAREAHEIGHT);
    points[2].X = (int)(120.0f/150.0f*TESTAREAWIDTH);
    points[2].Y = (int)(120.0f/150.0f*TESTAREAHEIGHT);
    points[3].X = (int)(50.0f/150.0f*TESTAREAWIDTH);
    points[3].Y = (int)(100.0f/150.0f*TESTAREAHEIGHT);

    Color blueColor(128, 0, 0, 255);

    SolidBrush blueBrush(blueColor);
    g->FillPolygon(&blueBrush, points, 4);

    // Currently only Geometric pen works for lines. - ikkof 1/6/99.

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    width = 16;
    Pen blackPen(&blackBrush, width);
    blackPen.SetLineJoin(LineJoinRound);
//    blackPen.SetLineJoin(LineJoinBevel);
    g->DrawPolygon(&blackPen, points, 4);
//    g->DrawLines(&blackPen, points, 4, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\csetting.h ===
/******************************Module*Header*******************************\
* Module Name: CSetting.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CSETTING_H
#define __CSETTING_H

#include "Global.h"

class CSetting  
{
public:
	CSetting();
	virtual ~CSetting();

	virtual BOOL Init();
	virtual void Set(Graphics *g)=0;

	char m_szName[256];
	BOOL m_bUseSetting;
	BOOL m_bRegression;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\cregions.h ===
/******************************Module*Header*******************************\
* Module Name: CRegions.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CREGIONS_H
#define __CREGIONS_H

#include "CPrimitive.h"

class CRegions : public CPrimitive  
{
public:
	CRegions(BOOL bRegression);
	virtual ~CRegions();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\crotate.h ===
/******************************Module*Header*******************************\
* Module Name: CRotate.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CROTATE_H
#define __CROTATE_H

#include "CSetting.h"

class CRotate : public CSetting  
{
public:
	CRotate(BOOL bRegression,int nAngle);
	virtual ~CRotate();

	void Set(Graphics *g);

	int m_nAngle;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\debug.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*   Debugging routines
*
* Revision History:
*
*   09/07/1999 agodfrey
*       Created it.
*
\**************************************************************************/
#include "global.h"

// Optional callback function for reporting a debug event.

enum GpAltDebugEventLevel
{
    GpAltDebugFatal,
    GpAltDebugWarning
};

#define GpAltDebugEventFunction 0
//DEBUGEVENTFUNCTION GpAltDebugEventFunction = NULL;

#if DBG

// GpDebugLevel is used to control the amount/severity of debugging messages
// that are actually output.

int GpDebugLevel = DBG_TERSE;

/**************************************************************************\
*
* Function Description:
*
*   Removes the path portion of a pathname
*
* Arguments:
*
*   [IN] str - pathname to strip
*
* Return Value:
*
*   A pointer to the filename portion of the pathname
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

const char*
StripDirPrefix(
    const char* str
    )

{
    const char* p;

    p = strrchr(str, '\\');
    return p ? p+1 : str;
}

const int maxInputStringSize = 1024;

/**************************************************************************\
*
* Function Description:
*
*   Outputs to the debugger
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   Zero. This is to conform to NTDLL's definition of DbgPrint.
*
* Notes:
*
*   There will be no output if a debugger is not connected.
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

ULONG _cdecl
DbgPrint(
    char* format,
    ...
    )

{
    va_list arglist;
    va_start(arglist, format);
    
    char buf[maxInputStringSize];
    
    _vsnprintf(buf, maxInputStringSize, format, arglist);
    buf[maxInputStringSize-1]=0;
        
    OutputDebugStringA(buf);
    
    va_end(arglist);
    return 0;
}

// If we can't allocate memory for the debug string, we'll use this buffer
// in desperation. It's not thread-safe. I *did* say 'desperation'.

static char desperationBuffer[maxInputStringSize];

/**************************************************************************\
*
* Function Description:
*
*   Creates a new string, and sprintf's to it.
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   The probably-newly-allocated string result.
*
* Notes:
*
*   This function is not intended for general use. It guards against memory
*   failure by using a global buffer. So, while the caller is responsible
*   for freeing the memory, the caller must also check for that buffer.
*   i.e. we only want DbgEmitMessage to call this.
*
*   It's also only mostly thread-safe, because if we run out of memory,
*   we'll use that global buffer in a non-protected way.
*
*   This is the only solution I could find so that I could move most of the
*   implementation details out of the header file. The root cause is that
*   macros don't handle multiple arguments natively, so we have to pass
*   the printf arguments as a single macro argument (in parentheses).
*   Which means, the function that consumes those arguments can have no
*   other arguments.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it. Finally, I've found a way to get debug implementation
*       details out of the headers.
*
\**************************************************************************/

char * _cdecl
GpParseDebugString(
    char* format,
    ...
    )
{
    va_list arglist;
    va_start(arglist, format);
    
    // Don't use GpMalloc here so that we can use ASSERT and WARNING in 
    // our memory allocation routines.

    char *newBuf = static_cast<char *>(LocalAlloc(LMEM_FIXED, maxInputStringSize));
    if (!newBuf)
    {
        newBuf = desperationBuffer;
    }
    
    _vsnprintf(newBuf, maxInputStringSize, format, arglist);
    
    // Nuke the last byte, because MSDN isn't clear on what _vsnprintf does
    // in that case.
    
    newBuf[maxInputStringSize-1]=0;
        
    va_end(arglist);
    return newBuf;
}

/**************************************************************************\
*
* Function Description:
*
*   Processes a debug event. Frees the message string.
*
* Arguments:
*
* level   - The debug level of the event 
* file    - Should be __FILE__
* line    - Should be __LINE__
* message - The debug message.
*
* Notes:
*
*   You don't want to call this directly. That would be error-prone. 
*   Use ASSERT, WARNING, etc.
*
*   In Office, it will raise an 'assert' dialog if necessary.
*
*   Depending on the debug level, an identifying prefix will be output.
*
*   If the debug level is DBG_RIP, will suspend execution (e.g. by
*   hitting a breakpoint.)
*
* Note on Office interop:
*
*   Under Office, we'll pass WARNINGs and ASSERTs to a reporting function
*   they provide. Their function will breakpoint on ASSERTs.
*   Lesser events will just be sent to the debugger.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it.
*
\**************************************************************************/

void _cdecl 
GpLogDebugEvent(
    int level, 
    char *file, 
    unsigned int line,
    char *message
    )
{
    // We may want to add things to the passed-in message. So we need
    // a temporary buffer
    
    const int maxOutputStringSize = maxInputStringSize + 100;
    char tempBuffer[maxOutputStringSize+1];
    
    // MSDN's _vsnprintf doc isn't clear on this, so just in case:
    tempBuffer[maxOutputStringSize] = 0;
    int altDebugLevel = -1;
    
    char *prefix = "";
    
    if (GpDebugLevel <= (level))
    {
        switch (level)
        {
        case DBG_WARNING:
            prefix = "WRN ";
            if (GpAltDebugEventFunction)
            {
                altDebugLevel = GpAltDebugWarning;
            }    
            break;
            
        case DBG_RIP:
            prefix = "RIP ";
            if (GpAltDebugEventFunction)
            {
                altDebugLevel = GpAltDebugFatal;
            }    
            break;
        }
        
        // The convention is that we append the trailing \n, not the caller.
        // Two reasons:
        // 1) Callers tend to forget it.
        // 2) More importantly, it encourages the caller to think of each
        //    call as a separate event. This is important in some cases - e.g.
        //    when Office produces a popup for each event.

        _snprintf(
            tempBuffer, 
            maxOutputStringSize, 
            "%s%s(%d): %s\n",
            prefix,
            StripDirPrefix(file),
            line,
            message
            );
        
        if (altDebugLevel >= 0)
        {
            //GpAltDebugEventFunction(altDebugLevel, tempBuffer);
        }
        else
        {
            OutputDebugStringA(tempBuffer);
        }
    }
    
    // Free the message buffer
    
    if (message != desperationBuffer)
    {
        LocalFree(message);
    }
    
    // Force a breakpoint, if it's warranted.
    
    if ((GpDebugLevel <= DBG_RIP) && (level == DBG_RIP) && (altDebugLevel < 0))
    {
        DebugBreak();
    }
}
    
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\debug.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   Debugging macros
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   09/07/1999 agodfrey
*       Moved from Engine\Common
*   02/07/2000 agodfrey
*       Made more of it private (for bug #35561).
*       Changed the output function to add "\n" automatically.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

// ONCE(code block)
//  Use this to make a code block execute only once per run.
//  Useful for cutting down on spew.
//  e.g.:
//      ONCE(WARNING(("Invalid arguments")));

#define ONCE(codeblock)      \
    {                        \
        static int doneOnce; \
        if (!doneOnce)       \
        {                    \
            { codeblock ; }  \
            doneOnce=1;      \
        }                    \
    }

#if DBG

// Global debug level

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_RIP     4

extern int GpDebugLevel;

///////////////////////////// DEPRECATED STUFF ///////////////////////////////

// Raw output function. Emits debug messages. Its direct use is depracated.
// It's useful for private debugging, though.

unsigned long _cdecl DbgPrint(char*, ...);

// Strip the directory prefix from a filename

const char*
StripDirPrefix(
    const char* filename
    );

// Use of DBGMSG is depracated - it's supplied only because driverd3d.cpp uses
// it.

#define DBGMSG(level, prefix, msg)       \
        {                                \
            if (GpDebugLevel <= (level)) \
            {                            \
                DbgPrint("%s %s (%d): ", prefix, StripDirPrefix(__FILE__), __LINE__); \
                DbgPrint msg;            \
            }                            \
        }

///////////////////////////// PRIVATE STUFF //////////////////////////////////

// Just leave this function alone. You don't want to call it yourself. Trust me.
char * _cdecl GpParseDebugString(char* format, ...);

// Ditto for this one.
void _cdecl GpLogDebugEvent(int level, char *file, unsigned int line, char *message);

#define LOG_DEBUG_EVENT(level, msg)                                  \
    {                                                                \
        if (GpDebugLevel <= (level))                                 \
        {                                                            \
            char *debugOutput = GpParseDebugString msg;              \
            GpLogDebugEvent(level, __FILE__, __LINE__, debugOutput); \
        }                                                            \
    }

//////////////////////////////// THE GOOD STUFF //////////////////////////////

// These macros are used for debugging. They expand to
// whitespace on a free build.
//
// GpDebugLevel
//  Global variable which holds the current debug level. You can use it to
//  control the quantity of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ASSERT(cond)
//  Verify that a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify that a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//
//  These macros require extra parentheses for the msg argument
//  for example:
//      WARNING(("App passed NULL pointer; ignoring it."));
//      ASSERTMSG(x > 0, ("x is less than 0"));
//
//  Each call to an output function is treated as a separate event -
//  if you want to build up a message, e.g. in a loop, build it up in a
//  string, and then call the output function.
//
//  This is because we don't always just output the string to the debugger -
//  when we link statically, we may send the output to a user-defined handler.
//
//  Don't put a trailing \n on the message. If the output is sent to the
//  debugger, the output function will add the \n itself.

#define VERBOSE(msg) LOG_DEBUG_EVENT(DBG_VERBOSE, msg)
#define TERSE(msg) LOG_DEBUG_EVENT(DBG_TERSE, msg)
#define WARNING(msg) LOG_DEBUG_EVENT(DBG_WARNING, msg)
#define RIP(msg) LOG_DEBUG_EVENT(DBG_RIP, msg)

#define ASSERT(cond)   \
    {                  \
        if (! (cond))  \
        {              \
            RIP(("Assertion failure: %s", #cond)); \
        }              \
    }

#define ASSERTMSG(cond, msg) \
    {                        \
        if (! (cond))        \
        {                    \
            RIP(msg);        \
        }                    \
    }

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define DBGMSG(level, prefix, msg) {}
#define VERBOSE(msg) {}
#define TERSE(msg) {}
#define WARNING(msg) {}

#define RIP(msg) {}
#define ASSERT(cond) {}
#define ASSERTMSG(cond, msg) {}

#endif // !DBG

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\crotate.cpp ===
/******************************Module*Header*******************************\
* Module Name: CRotate.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CRotate.h"
#include "CFuncTest.h"

extern CFuncTest g_FuncTest;

CRotate::CRotate(BOOL bRegression,int nAngle)
{
	sprintf(m_szName,"Rotate %d",nAngle);
	m_bRegression=bRegression;
	m_nAngle=nAngle;
}

CRotate::~CRotate()
{

}

void CRotate::Set(Graphics *g)
{
	if (m_bUseSetting)
	{
		g->TranslateTransform(TESTAREAWIDTH/2.0f,TESTAREAHEIGHT/2.0f);
		g->RotateTransform((float)m_nAngle);
		g->TranslateTransform(-TESTAREAWIDTH/2.0f,-TESTAREAHEIGHT/2.0f);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\guid.c ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   GUID definition file
*
*   GUIDs that are needed by functest are defined here.
*
* Revision History:
*
*   10/22/1999 bhouse
*       Created it.
*
\**************************************************************************/

// NOTE: Since we use C++ precompiled headers this C file will not use
//       the precompiled header allowing us to define INITGUID and include
//       directdraw and d3d headers to generate the GUIDs defined by these
//       headers.

#define INITGUID
#include <ddraw.h>
#include <d3d.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\global.h ===
/******************************Module*Header*******************************\
* Module Name: Global.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __GLOBAL_H
#define __GLOBAL_H

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <objbase.h>
#include <math.h>
#include <winspool.h>
#include <commdlg.h>
#include <wingdi.h>
#include <ddraw.h>

#include "debug.h"

#define IStream int
#include <gdiplus.h>
using namespace Gdiplus;

#define TESTAREAWIDTH  256.0f
#define TESTAREAHEIGHT 256.0f

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\csourcecopy.h ===
/******************************Module*Header*******************************\
* Module Name: CSourceCopy.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CSOURCECOPY_H
#define __CSOURCECOPY_H

#include "CPrimitive.h"

class CSourceCopy : public CPrimitive  
{
public:
	CSourceCopy(BOOL bRegression);
	virtual ~CSourceCopy();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\ctext.h ===
/******************************Module*Header*******************************\
* Module Name: CText.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CTEXT_H
#define __CTEXT_H

#include "CPrimitive.h"

class CText : public CPrimitive  
{
public:
	CText(BOOL bRegression);
	virtual ~CText();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\ctext.cpp ===
/******************************Module*Header*******************************\
* Module Name: CText.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CText.h"

CText::CText(BOOL bRegression)
{
	strcpy(m_szName,"Text");
	m_bRegression=bRegression;
}

CText::~CText()
{
}

void CText::Draw(Graphics *g)
{
    //Font font(L"Arial", 60);

    FontFamily  ff(L"Arial");
    RectF	  rectf(20.0f/500.0f*TESTAREAWIDTH, 0.0f/500.0f*TESTAREAHEIGHT, 500.0f/500.0f*TESTAREAWIDTH, 300.0f/500.0f*TESTAREAHEIGHT);
    GraphicsPath  path;

    // Solid color text.
    Color color(128, 100, 0, 200);
    SolidBrush brush(color);
    path.AddString(L"Color", 5, &ff, 0, 100.0f/500.0f*TESTAREAWIDTH,  rectf, NULL);
    g->FillPath(&brush, &path);

    // Texture text.
    WCHAR filename[256];
    wcscpy(filename, L"../data/marble1.jpg");
    Bitmap *bitmap = new Bitmap(filename);                          
    TextureBrush textureBrush(bitmap, WrapModeTile);
    path.Reset();
    rectf.Y = 100.0f/500.0f*TESTAREAWIDTH;
    path.AddString(L"Texture", 7, &ff, 0, 100.0f/500.0f*TESTAREAWIDTH, rectf, NULL);
    g->FillPath(&textureBrush, &path);
    delete bitmap;

    // Gradient text.
    rectf.Y = 200.0f/500.0f*TESTAREAWIDTH;
    path.Reset();
    path.AddString(L"Gradient", 8, &ff, 0, 100.0f/500.0f*TESTAREAWIDTH, rectf, NULL);
    Color color1(255, 255, 0, 0);
    Color color2(255, 0, 255, 0);
    LinearGradientBrush lineGrad(rectf, color1, color2, 0.0f);
    g->FillPath(&lineGrad, &path);

    // Shadow test
    REAL charHeight = 100.0f/500.0f*TESTAREAWIDTH;
	REAL topMargin = - 5;
    rectf.Y = - charHeight - topMargin; // Make y-coord of the base line
										// of the characters to be 0.

    path.Reset();
    path.AddString(L"Shadow", 6, &ff, 0, charHeight, rectf, NULL);
    GraphicsPath* clonePath = path.Clone();

    Color redColor(255, 0, 0);
    Color grayColor(128, 0, 0, 0);
    SolidBrush redBrush(redColor);
    SolidBrush grayBrush(grayColor);

    // Shadow part.
	REAL tx = 0.0f/500.0f*TESTAREAWIDTH, ty = 400.0f/500.0f*TESTAREAHEIGHT;
    Matrix skew;
    skew.Scale(1.0, 0.5);
    skew.Shear(-2.0, 0, MatrixOrderAppend);
    skew.Translate(tx, ty, MatrixOrderAppend);
    clonePath->Transform(&skew);
    g->FillPath(&grayBrush, clonePath);
    delete clonePath;

    // Front part.
	Matrix trans1;
    trans1.Translate(tx, ty);
    path.Transform(&trans1);
    g->FillPath(&redBrush, &path);


    return;
/*
    REAL x = 200, y = 150;

    RectF brushRect(x, y, 150, 32);
    Color colors[4] = {
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0),
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0)
    };
//    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors, WrapModeTile);

//    g->DrawString(L"GDI+", &font, &rectGrad, x, y);


    // And now with DrawText

    RectF rect(400, 200, 400, 400);

    g->DrawText(
        DrawTextDisplay,
        L"A few words powered by GDI+: \
\x3c3\x3bb\x3b1\x3b4 \
\x627\x644\x633\x644\x627\x645 \
\x5e9\x5dc\x5d5\x5dd \
\xe2d\xe4d\xe01\xe29\xe23\xe44\xe17\xe22 \
\x110\x068\x0ea\x300\x103",
       &font,           // Initial font
       &rectGrad,       // Initial brush (ignored for the time being)
        LANG_NEUTRAL,   // Initial language
       &rect            // Formatting rectangle
    );
*/
}


/*
int CALLBACK TestSpecificFont(CONST LOGFONT *lplf,CONST TEXTMETRIC *lptm,DWORD dwType,LPARAM lpData)
{
    static REAL x = 50, y = 50;

    HFONT hf = CreateFontIndirect(lplf);
 
    Graphics *g = (Graphics*) lpData;

    Color red(0x80FF0000); 
    Brush *brush = new SolidBrush(red);

//    g->DrawString(L"This is a test.", (VOID*)hf, brush, x, y);

    delete brush;

    x = x + lplf->lfWidth * 2;
    y = y + lplf->lfHeight + 5;

    DeleteObject(hf);

    return 1;
}

VOID TestText(Graphics *g, HWND hwnd)
{
    HDC hdc = GetDC(hwnd);

    // enumerate the fonts in the system
    EnumFonts(hdc, NULL, &TestSpecificFont, (LPARAM)g); 

    ReleaseDC(hwnd, hdc); 
}

void CText::Draw(Graphics *g)
{
    Point points[4];
    REAL width = 4;     // Pen width
    WCHAR filename[]=L"../data/4x5_trans_Q60_cropped_1k.jpg";

    // Open the image with the appropriate ICM mode.
    Bitmap *bitmap = new Bitmap(filename, TRUE);

    // Create a texture brush.

    Unit u;
    RectF copyRect;
    bitmap->GetBounds(&copyRect, &u);
    
    copyRect.X = copyRect.Width/2-1;
    copyRect.Width = copyRect.Width/4-1;
    copyRect.X += copyRect.Width;
    copyRect.Height = copyRect.Height/2-1;
  
    // Our ICM profile is hacked to flip the red and blue color channels
    // Apply a recolor matrix to flip them back so that if something breaks
    // ICM, the picture will look blue instead of the familiar colors.
    ImageAttributes *img = new ImageAttributes();
    img->SetWrapMode(WrapModeTile, Color(0xffff0000), FALSE);
    ColorMatrix flipRedBlue = 
       {0, 0, 1, 0, 0,
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1};
    img->SetColorMatrix(&flipRedBlue);
    img->SetICMMode(TRUE);
    img->SetWrapMode(WrapModeTile, Color(0xffff0000), FALSE);

    // Create a texture brush.                      
    TextureBrush textureBrush(bitmap, copyRect, img);

    // Create a radial gradient pen.

    Color redColor(255, 0, 0);

    SolidBrush redBrush(redColor);
    Pen redPen(&redBrush, width);

    GraphicsPath *path;

    points[0].X = 100*3+300;
    points[0].Y = 60*3-100;
    points[1].X = -50*3+300;
    points[1].Y = 60*3-100;
    points[2].X = 150*3+300;
    points[2].Y = 250*3-100;
    points[3].X = 200*3+300;
    points[3].Y = 120*3-100;
    path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);    
    g->FillPath(&textureBrush, path);
    g->DrawPath(&redPen, path);

    delete img;
    delete path;
    delete bitmap;

    PointF destPoints[3];

    destPoints[0].X = 300;
    destPoints[0].Y = 50;
    destPoints[1].X = 450;
    destPoints[1].Y = 50;
    destPoints[2].X = 240;
    destPoints[2].Y = 200;
 
    Matrix mat;
    mat.Translate(0, 100);
    mat.TransformPoints(&destPoints[0], 3);
    wcscpy(filename, L"../data/apple1.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);
 
    delete bitmap;

    destPoints[0].X = 30;
    destPoints[0].Y = 200;
    destPoints[1].X = 200;
    destPoints[1].Y = 200;
    destPoints[2].X = 200;
    destPoints[2].Y = 420;

    wcscpy(filename, L"../data/dog2.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);
 
    delete bitmap;

    Color color(100, 128, 255, 0);

    SolidBrush brush(color);

    Point pts[10];
    INT count = 4;

    pts[0].X = 150;
    pts[0].Y = 60;
    pts[1].X = 100;
    pts[1].Y = 230;
    pts[2].X = 250;
    pts[2].Y = 260;
    pts[3].X = 350;
    pts[3].Y = 100;

    g->FillClosedCurve(&brush, pts, count);

    wcscpy(filename, L"../data/ballmer.jpg");
    bitmap = new Bitmap(filename);
    RectF destRect(220, 50, 180, 120);
    RectF srcRect;
    srcRect.X = 100;
    srcRect.Y = 40;
    srcRect.Width = 200;
    srcRect.Height = 200;
    g->DrawImage(bitmap, destRect, srcRect.X, srcRect.Y,
        srcRect.Width, srcRect.Height, UnitPixel);
    delete bitmap;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\csystemcolor.h ===
/******************************Module*Header*******************************\
* Module Name: CSystemColor.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  03-14-2001 agodfrey
*
* Copyright (c) 2001 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CSYSTEMCOLOR_H
#define __CSYSTEMCOLOR_H

#include "CPrimitive.h"

class CSystemColor : public CPrimitive  
{
public:
    CSystemColor(BOOL bRegression);
    virtual ~CSystemColor();

    void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\csourcecopy.cpp ===
/******************************Module*Header*******************************\
* Module Name: CSourceCopy.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CSourceCopy.h"

CSourceCopy::CSourceCopy(BOOL bRegression)
{
	strcpy(m_szName,"SourceCopy");
	m_bRegression=bRegression;
}

CSourceCopy::~CSourceCopy()
{
}

void CSourceCopy::Draw(Graphics *g)
{
    // This test demonstrates SetCompositingMode by drawing two overlapping
    // rectangles, using SourceCopy, into a temporary bitmap, then drawing
    // the bitmap (using SourceOver), onto the screen over a background.

    // Make a temporary surface
    Bitmap bmTemp((int)(300.0f/150.0f*TESTAREAWIDTH), (int)(300.0f/150.0f*TESTAREAHEIGHT), PixelFormat32bppPARGB);
    Graphics gTemp(&bmTemp);
    Graphics *gt=&gTemp;
    
    // First, draw a blue checkerboard pattern on the output Graphics
    SolidBrush blueBrush(Color::Blue);
    int i,j;
    for (i=0;i<3;i++)
	{
        for (j=0;j<3;j++)
        {
            if ((i+j) & 1)
            {
                g->FillRectangle(
                    &blueBrush, 
                    (int)((100.0f+i*30.0f)/200.0f*TESTAREAWIDTH), 
                    (int)((100.0f+j*30.0f)/200.0f*TESTAREAHEIGHT), 
                    (int)(30.0f/200.0f*TESTAREAHEIGHT),
                    (int)(30.0f/200.0f*TESTAREAHEIGHT));
            }        
        }
	}

    gt->SetCompositingMode(CompositingModeSourceCopy);
    gt->SetSmoothingMode(g->GetSmoothingMode());

    // Clear the bitmap to the transparent color
    gt->Clear(Color(0,0,0,0));

    // Draw two overlapping rectangles to the temporary surface
    SolidBrush halfRedBrush(Color(128, 255, 0, 0));
    gt->FillRectangle(&halfRedBrush, (int)(28.0f/150.0f*TESTAREAWIDTH), (int)(84.0f/150.0f*TESTAREAHEIGHT), (int)(90.0f/150.0f*TESTAREAWIDTH), (int)(50.0f/150.0f*TESTAREAHEIGHT));

    SolidBrush halfGreenBrush(Color(128, 0, 255, 0));
    gt->FillRectangle(&halfGreenBrush, (int)(40.0f/150.0f*TESTAREAWIDTH), (int)(40.0f/150.0f*TESTAREAHEIGHT), (int)(100.0f/150.0f*TESTAREAWIDTH), (int)(60.0f/150.0f*TESTAREAHEIGHT));
    
    // SourceOver the result to the output Graphics
    g->DrawImage(&bmTemp, 0, 0, 0, 0, (int)TESTAREAWIDTH, (int)TESTAREAHEIGHT, UnitPixel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\csystemcolor.cpp ===
/******************************Module*Header*******************************\
* Module Name: CSystemColor.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* SystemColor test. This test isn't much use as a part of the regression suite.
* It's intended to test drawing using the 4 "magic" system colors in 8bpp.
* Solid fills using these colors should look solid, not be dithered to some
* nearby colors.
*
* I made this to repro #308874 (system colors being dithered when rendering to
* an 8bpp DIBSection - note, NOT the Terminal Server issue).
* To repro, be in 8bpp mode, select "Output: DIB 8 bits", this Primitive, and
* "Settings: Halftone".
*
* Created:  03-14-2001 agodfrey
*
* Copyright (c) 2001 Microsoft Corporation
*
\**************************************************************************/
#include "CSystemColor.h"

CSystemColor::CSystemColor(BOOL bRegression)
{
    strcpy(m_szName,"SystemColors");
    m_bRegression=bRegression;
}

CSystemColor::~CSystemColor()
{
}

static int sysColorNum[4] = {
    COLOR_3DSHADOW,
    COLOR_3DFACE,
    COLOR_3DHIGHLIGHT,
    COLOR_DESKTOP
};

void CSystemColor::Draw(Graphics *g)
{
    int i;
    
    for (i=0; i<4; i++) {
        int x = (i % 2) * (int) (TESTAREAWIDTH/2);
        int y = (i / 2) * (int) (TESTAREAHEIGHT/2);
        
        DWORD sysColor = ::GetSysColor(sysColorNum[i]);
        
        Color color;
        color.SetFromCOLORREF(sysColor);
        
        SolidBrush solidBrush1(color);
        
        // GetNearestColor shouldn't modify the color at all
        g->GetNearestColor(&color);
        SolidBrush solidBrush2(color);

        Rect rect1(
            x, 
            y, 
            (int) (TESTAREAWIDTH/2),
            (int) (TESTAREAHEIGHT/4)
        );
        Rect rect2(
            x, 
            y + (int) (TESTAREAHEIGHT/4), 
            (int) (TESTAREAWIDTH/2),
            (int) (TESTAREAHEIGHT/4)
        );
        g->FillRectangle(&solidBrush1, rect1);
        g->FillRectangle(&solidBrush2, rect2);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\printtest\cbackprinting.h ===
/******************************Module*Header*******************************\
* Module Name: CBackPrinting.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CBACKPRINTING_H
#define __CBACKPRINTING_H

#include "..\CPrimitive.h"

class CBackPrinting : public CPrimitive  
{
public:
	CBackPrinting(BOOL bRegression);
	virtual ~CBackPrinting();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Functest.rc
//
#define IDR_MENU1                       101
#define IDD_FUNCTEST                    102
#define ID_APP                          103
#define IDC_COMBINATION                 1000
#define IDC_REGRESSION                  1001
#define IDC_RUN                         1002
#define IDC_PRIMITIVES                  1003
#define IDC_OUTPUTS                     1004
#define IDC_SETTINGS                    1005
#define IDC_PAGEPAUSE                   1008
#define IDC_PAGEDELAY                   1009
#define IDC_DELAY                       1010
#define IDC_ERASEBKGD                   1011
#define IDC_APPENDTEST                  1012
#define IDM_ALL                         40000
#define IDM_POLYGONS                    40001
#define IDM_PATHS                       40002
#define IDM_REGIONS                     40003
#define IDM_GRADIENTS                   40004
#define IDM_BITMAPS                     40005
#define IDM_IMAGING                     40006
#define IDM_PRIMITIVES                  40007
#define IDM_MIXED                       40008
#define IDM_TEXT                        40009
#define IDM_CONTAINERS                  40010
#define IDM_CONTAINERCLIP               40011
#define IDM_HATCH                       40012
#define IDM_DASHES                      40013
#define IDM_SOURCECOPY                  40014
#define IDM_COMPOUNDLINES               40015
#define IDM_PRINTING                    40016
#define IDM_BACKPRINTING                40017
#define IDM_INSETLINES                  40018
#define IDM_HWND                        40100
#define IDM_DIB                         40101
#define IDM_PRINTER                     40102
#define IDM_D3D                         40103
#define IDM_DIB_FILE                    40104
#define IDM_1BPP                        40200
#define IDM_2BPP                        40201
#define IDM_4BPP                        40202
#define IDM_8BPP                        40203
#define IDM_16BPP                       40204
#define IDM_24BPP                       40205
#define IDM_32BPP                       40206
#define IDM_TEST1                       40300
#define IDM_TEST10                      40301
#define IDM_TEST100                     40302
#define IDM_TEST1000                    40303
#define IDM_TESTREGRESS                 40304
#define IDM_HALFTONE                    40305
#define IDM_ANTIALIAS                   40306
#define IDM_TESTHDC                     40307
#define IDM_NEWPRINT                    40308
#define IDM_CACHEBACK                   40309
#define IDM_HIGHCOMPOSITINGQUALITY      40310
#define IDM_QUIT                        40500
#define IDM_ROT0                        40600
#define IDM_ROT10                       40601
#define IDM_ROT30                       40602
#define IDM_ROT45                       40603
#define IDM_ROT60                       40604
#define IDM_ROT90                       40605
#define IDM_RUN                         41000
#define IDM_COMBINATION                 41001
#define IDM_REGRESSION                  41002
#define IDM_OPTIONS                     65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         41003
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\printtest\cprinting.h ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRINTING_H
#define __CPRINTING_H

#include "..\CPrimitive.h"

class CPrinting : public CPrimitive  
{
public:
	CPrinting(BOOL bRegression);
	virtual ~CPrinting();

	void Draw(Graphics *g);

	VOID TestPerfPrinting(Graphics *g);
	VOID TestTextPrinting(Graphics *g);
        
        VOID TestNolan1(Graphics *g);
        VOID TestNolan2(Graphics *g);

        VOID TestBug104604(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\main.cpp ===
/******************************Module*Header*******************************\
* Module Name: Main.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  28-Apr-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <commctrl.h>
#include <objbase.h>
#include <gdiplus.h>
#include "CFuncTest.h"
#include "resource.h"

CFuncTest g_FuncTest;                                   // FuncTest (handles test runs)
HBRUSH g_hbrBackground=NULL;                            // Main window background color
HWND g_hWndMain=NULL;                                   // Main window
int g_nResult=0;                                        // Result of test run

// Include all the outputs (classes derived from COutput)
#include "CHWND.h"
#include "CHDC.h"
#include "CFile.h"
#include "CBitmap.h"
#include "CDIB.h"
#include "CDirect3D.h"
#include "CPrinter.h"
#include "CMetafile.h"

// Include all the primitives (classes derived from CPrimitive)
#include "CPolygons.h"
#include "CBitmaps.h"
#include "CCachedBitmap.h"
#include "CCompoundLines.h"
#include "CContainer.h"
#include "CContainerClip.h"
#include "CDashes.h"
#include "CPathGradient.hpp"
#include "CDash.hpp"
#include "CLines.hpp"
#include "CGradients.h"
#include "CHatch.h"
#include "CImaging.h"
#include "CRecolor.h"
#include "CInsetLines.h"
#include "CMixedObjects.h"
#include "CPaths.h"
#include "CPrimitives.h"
#include "CRegions.h"
#include "CText.h"
#include "CRegression.h"
#include "CSourceCopy.h"
#include "CExtra.h"

// Include all the settings (classes derived from CSetting)
#include "CAntialias.h"
#include "CHalfPixel.h"
#include "CQuality.h"
#include "CHalftone.h"
#include "CChecker.h"
#include "CRotate.h"
#include "CBKGradient.h"
#include "CHatch.h"

#include "../gpinit.inc"

// Create global objects for each individual output
//   First constructor param is the regression flag
//   If true, the test will take part of the regression suite
CHWND g_HWND(true);
CHDC g_HDC(true);
CDirect3D g_Direct3D(false);
CPrinter g_Printer(false);
CDIB g_DIB1(true,1);
CDIB g_DIB2(false,2);
CDIB g_DIB4(true,4);
CDIB g_DIB8(true,8);
CDIB g_DIB16(true,16);
CDIB g_DIB24(true,24);
CDIB g_DIB32(true,32);
CFile g_File1(false,1);
CFile g_File2(false,2);
CFile g_File4(false,4);
CFile g_File8(false,8);
CFile g_File16(false,16);
CFile g_File24(false,24);
CFile g_File32(false,32);

CBitmap g_Bitmap1(false, PixelFormat1bppIndexed);
CBitmap g_Bitmap4(false, PixelFormat4bppIndexed);
CBitmap g_Bitmap8(false, PixelFormat8bppIndexed);
CBitmap g_Bitmap16Gray(false, PixelFormat16bppGrayScale);
CBitmap g_Bitmap16555(false, PixelFormat16bppRGB555);
CBitmap g_Bitmap16565(false, PixelFormat16bppRGB565);
CBitmap g_Bitmap161555(false, PixelFormat16bppARGB1555);
CBitmap g_Bitmap24(false, PixelFormat24bppRGB);
CBitmap g_Bitmap32RGB(false, PixelFormat32bppRGB);
CBitmap g_Bitmap32ARGB(false, PixelFormat32bppARGB);
CBitmap g_Bitmap32PARGB(false, PixelFormat32bppPARGB);
CBitmap g_Bitmap48RGB(false, PixelFormat48bppRGB);
CBitmap g_Bitmap64ARGB(false, PixelFormat64bppARGB);
CBitmap g_Bitmap64PARGB(false, PixelFormat64bppPARGB);

CMetafile g_MetafileEMF(false, MetafileTypeEmf);
CMetafile g_MetafileEMFPlus(false, MetafileTypeEmfPlusOnly);
CMetafile g_MetafileEMFPlusDual(true, MetafileTypeEmfPlusDual);

CMetafile g_MetafileEMFF(false, MetafileTypeEmf, true);
CMetafile g_MetafileEMFPlusF(false, MetafileTypeEmfPlusOnly, true);
CMetafile g_MetafileEMFPlusDualF(true, MetafileTypeEmfPlusDual, true);

CRegression g_Regression(true);

// Create global objects for each individual setting
//   First constructor param is the regression flag
//   If true, the test will take part of the regression suite
CAntialias g_Antialias(true);
CHalfPixel g_HalfPixel(true);
CQuality g_Quality(true);
CCompositingMode g_CompositingMode(true);
CHalftone g_Halftone(true);
CChecker g_Checker(true);
CRotate g_Rotate13(true,13);
CRotate g_Rotate45(true,45);
CBKGradient g_BKGradient(true);
CHatch g_Hatch(true);

LRESULT CALLBACK WndProc(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam)
// Main window proc
{
    switch (Msg)
    {
        case WM_COMMAND:                // Process menu buttons
            switch(LOWORD(wParam))
            {
                case IDM_RUN:
                    g_FuncTest.Run();
                    break;
                case IDM_REGRESSION:
                    g_FuncTest.RunRegression();
                    break;
                case IDM_OPTIONS:
                    g_FuncTest.RunOptions();
                    break;
                case IDM_QUIT:
                    {
                        HWND hwnd = g_hWndMain;
                        g_hWndMain = NULL;
                        DestroyWindow(hwnd);
                    }
                    break;
            }
            break;
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
    }

    return DefWindowProcA(hWnd,Msg,wParam,lParam);
}

void WindowUninit()
// Uninitializes window
{
    if (g_hbrBackground!=NULL)      // Destroy background brush
    {
        DeleteObject((HGDIOBJ)g_hbrBackground);
        g_hbrBackground=NULL;
    }
    if (g_hWndMain!=NULL)           // Destroy main window
    {
        DestroyWindow(g_hWndMain);
        g_hWndMain=NULL;
    }
}

BOOL WindowInit()
// Creates window and starts up app
{
    WNDCLASSA wc;
    HINSTANCE hInst=GetModuleHandleA(NULL);

    // Create white background brush
    g_hbrBackground=CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = WndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInst;
    wc.hIcon            = LoadIconA(GetModuleHandle(NULL),MAKEINTRESOURCEA(ID_APP));
    wc.hCursor          = LoadCursorA(NULL,MAKEINTRESOURCEA(32512));
    wc.hbrBackground    = g_hbrBackground;
    wc.lpszMenuName     = MAKEINTRESOURCEA(IDR_MENU1);
    wc.lpszClassName    = "Functest";
    if (!RegisterClassA(&wc))
        return false;

    g_hWndMain=CreateWindowExA(
        0,
        "Functest",
        "GDI+ Functionality Test",
        WS_OVERLAPPED|WS_CAPTION|WS_BORDER|WS_THICKFRAME|WS_MAXIMIZEBOX|
        WS_MINIMIZEBOX|WS_CLIPCHILDREN|WS_VISIBLE|WS_MAXIMIZE|WS_SYSMENU,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        800,
        600,
        NULL,
        NULL,
        hInst,
        NULL
    );
    HRESULT h=GetLastError();

    if (g_hWndMain==NULL)
        return false;

    UpdateWindow(g_hWndMain);
    ShowWindow(g_hWndMain,SW_SHOW);

    return true;
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 - Created  - KentD
*  04-28-00 - Modified - Jeff Vezina (t-jfvez)
*
\***************************************************************************/
__cdecl main(int argc,PCHAR argv[])
{
    MSG msg;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
    
    CoInitialize(NULL);

    if (!WindowInit())
        return 0;
    if (!g_FuncTest.Init(g_hWndMain))
        return 0;

    // Init all primitives, graphics types, and graphics settings
    g_HWND.Init();
    g_HDC.Init();
    g_Direct3D.Init();
    g_Printer.Init();
    g_DIB1.Init();
    g_DIB2.Init();
    g_DIB4.Init();
    g_DIB8.Init();
    g_DIB16.Init();
    g_DIB24.Init();
    g_DIB32.Init();
    g_File1.Init();
    g_File2.Init();
    g_File4.Init();
    g_File8.Init();
    g_File16.Init();
    g_File24.Init();
    g_File32.Init();

    g_Bitmap1.Init();
    g_Bitmap4.Init();
    g_Bitmap8.Init();
    g_Bitmap16Gray.Init();
    g_Bitmap16555.Init();
    g_Bitmap16565.Init();
    g_Bitmap161555.Init();
    g_Bitmap24.Init();
    g_Bitmap32RGB.Init();
    g_Bitmap32ARGB.Init();
    g_Bitmap32PARGB.Init();
    g_Bitmap48RGB.Init();
    g_Bitmap64ARGB.Init();
    g_Bitmap64PARGB.Init();

    g_MetafileEMF.Init();
    g_MetafileEMFPlus.Init();
    g_MetafileEMFPlusDual.Init();
    
    g_MetafileEMFF.Init();
    g_MetafileEMFPlusF.Init();
    g_MetafileEMFPlusDualF.Init();




    g_Regression.Init();

    g_Antialias.Init();
    g_Quality.Init();
    g_CompositingMode.Init();
    g_HalfPixel.Init();
    g_Halftone.Init();
    g_Checker.Init();
    g_Rotate13.Init();
    g_Rotate45.Init();
    g_BKGradient.Init();
    g_Hatch.Init();

    // Put initializations into cextra.cpp, so that individual
    // developers can implement their own file for private usage.
    ExtraInitializations();

    for (int i=1;i<argc;i++)
    {
        if ((_stricmp(argv[i],"/?")==0) || (_stricmp(argv[i],"?")==0) || (_stricmp(argv[i],"-?")==0))
        {
            printf("Functest command line parameters:\n");
            printf("/? - Show the command line parameters\n");
            printf("/regression - Run the regression test immediately\n");
            return 1;
        }
        else if (_stricmp(argv[i],"/regression")==0)
        {
            g_FuncTest.RunRegression();
            SendMessageA(g_FuncTest.m_hWndMain,WM_CLOSE,0,0);
            return g_nResult;
        }
    }

    while (GetMessageA(&msg,NULL,0,0)) {
        TranslateMessage(&msg);
        DispatchMessageA(&msg);
    }

    WindowUninit();

    CoUninitialize();

    return g_nResult;
}

#define UNICODE
#define _UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\printtest\cextra.cpp ===
// Include all the primitives (classes derived from CPrimitive)
#if 0
#include "..\CPolygons.h"
#include "..\CBitmaps.h"
#include "..\CCompoundLines.h"
#include "..\CContainer.h"
#include "..\CContainerClip.h"
#include "..\CDashes.h"
#include "..\CGradients.h"
#include "..\CHatch.h"
#include "..\CImaging.h"
#include "..\CInsetLines.h"
#include "..\CMixedObjects.h"
#include "..\CPaths.h"
#include "..\CPrimitives.h"
#include "..\CRegions.h"
#include "..\CRegression.h"
#include "..\CSourceCopy.h"
#include "..\CExtra.h"
#endif

#include "CPrinting.h"
#include "cbackprinting.h"
#include "cprivateprinting.h"
#include "cprinttext.h"
#include "..\CText.h"
#include "CPrintBitmap.h"
#include "CGradients.h"

// Create global objects for each individual primitive
//   First constructor param is the regression flag
//   If true, the test will take part of the regression suite
#if 0
CPolygons g_Polygons(true);
CBitmaps g_Bitmaps(true);
CCompoundLines g_CompoundLines(true);
CContainer g_Container(true);
CContainerClip g_ContainerClip(true);
CDashes g_Dashes(true);
CGradients g_Gradients(true);
CHatch g_Hatch(true);
CImaging g_Imaging(true);
CInsetLines g_InsetLines(true);
CMixedObjects g_MixedObjects(true);
CPaths g_Paths(true);
CPrimitives g_Primitives(true);
CRegions g_Regions(true);
CText g_Text(true);
CRegression g_Regression(true);
CSourceCopy g_SourceCopy(true);
#endif

CPrinting g_Printing(false);
CBackPrinting g_cbackPrint(false);
CPrivatePrinting g_privPrint(false);
CText g_Text(true);
CPrintText g_PrintText(false);
CPrintBitmap g_PrintBitmap(false);
CGradients g_Gradients(false);

void ExtraInitializations()
{
#if 0
    g_Polygons.Init();
    g_Bitmaps.Init();
    g_CompoundLines.Init();
    g_Container.Init();
    g_ContainerClip.Init();
    g_Dashes.Init();
    g_Gradients.Init();
    g_Hatch.Init();
    g_Imaging.Init();
    g_InsetLines.Init();
    g_MixedObjects.Init();
    g_Paths.Init();
    g_Primitives.Init();
    g_Regions.Init();
    g_Text.Init();
    g_Regression.Init();
    g_SourceCopy.Init();
#endif

    g_Text.Init();
    g_Printing.Init();
    g_cbackPrint.Init();
    g_privPrint.Init();
    g_PrintText.Init();
    g_PrintBitmap.Init();
    g_Gradients.Init();

//Gdiplus::DllExports::GdipDisplayPaletteWindowNotify(WindowNotifyEnumDisable);
//exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\printtest\cbackprinting.cpp ===
/******************************Module*Header*******************************\
* Module Name: CBackPrinting.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CBackPrinting.h"

CBackPrinting::CBackPrinting(BOOL bRegression)
{
        strcpy(m_szName,"Background Printing");
	m_bRegression=bRegression;
}

CBackPrinting::~CBackPrinting()
{
}

void CBackPrinting::Draw(Graphics *g)
{
    Bitmap *bitmap = new Bitmap(L"..\\data\\winnt256.bmp");

    // Test g->DrawImage
    if (bitmap && bitmap->GetLastStatus() == Ok) 
    {
        ImageAttributes imageAttributes;
#if 0
        if (CacheBack) 
           imageAttributes.SetCachedBackgroundImage();
        else
           imageAttributes.ClearCachedBackgroundImage();
#endif
        RectF rect(0.0f,0.0f,TESTAREAWIDTH,TESTAREAHEIGHT);

        // Page #1 should use VDP
        g->DrawImage(bitmap, 
                     rect, rect.X, rect.Y, rect.Width, rect.Height, 
                     UnitPixel,
                     &imageAttributes, NULL, NULL);

        HDC hdc = g->GetHDC();
        EndPage(hdc);
        g->ReleaseHDC(hdc);

        // Page #2 should use VDP form
        g->DrawImage(bitmap, 
                     rect, rect.X, rect.Y, rect.Width, rect.Height, 
                     UnitPixel,
                     &imageAttributes, NULL, NULL);

        delete bitmap;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\printtest\cprintbitmap.h ===
/******************************Module*Header*******************************\
* Module Name: CBitmaps.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRINTBITMAPS_H
#define __CPRINTBITMAPS_H

#include "..\CPrimitive.h"

class CPrintBitmap : public CPrimitive  
{
public:
	CPrintBitmap(BOOL bRegression);
	virtual ~CPrintBitmap();

	void Draw(Graphics *g);
        void Draw2(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\printtest\cprintbitmap.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrintBitmap.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrintBitmap.h"
#include <gdiplus.h>
CPrintBitmap::CPrintBitmap(BOOL bRegression)
{
        strcpy(m_szName,"Bitmaps");
        m_bRegression=bRegression;
}

CPrintBitmap::~CPrintBitmap()
{
}

void CPrintBitmap::Draw(Graphics *g)
{
Bitmap bm4bpp(L"4bpp.bmp");
Bitmap bmpng(L"upsidedown.png");
Bitmap bmpgif(L"upsidedown.bmp");

Rect rect1(0,0,100,100);
Rect rect2(100,50,100,100);
Rect rect3(250,50,100,100);

g->DrawImage(&bm4bpp, rect1);
g->DrawImage(&bmpng, rect2);
g->DrawImage(&bmpgif, rect3);

#if 0
    //Draw2(g);

    Bitmap arrowBmp(L"DataGridRow.star.bmp");
    Size size;
    size.Width = arrowBmp.GetWidth();
    size.Height = arrowBmp.GetHeight();
    Rect rect(40, 40, size.Width, size.Height);
#if 1
    ColorMap colorMap;
    colorMap.oldColor = Color(0xFF,0,0,0);
    colorMap.newColor = Color(0xFF,0,0xFF,0);
    ImageAttributes imgattr;
    imgattr.SetRemapTable(1, &colorMap, ColorAdjustTypeBitmap);
    g->DrawImage(&arrowBmp, 
                 rect, 
                 0, 0, rect.Width, rect.Height, 
                 UnitPixel,
                 &imgattr);
#endif 
    g->DrawImage(&arrowBmp, rect);
#endif
}

void CPrintBitmap::Draw2(Graphics *g)
{
#if 0
    WCHAR filename[256];
    wcscpy(filename, L"035.tif");

    // Open the image with the appropriate ICM mode.
    Bitmap *bitmap = new Bitmap(filename, TRUE);

    Region region;

    region.MakeInfinite();

    REAL sizeF = 500.0f;
    INT size = 500;

    Matrix m;
    m.RotateAt(180.0f, PointF(sizeF/2.0f, sizeF/2.0f));
    
    g->SetTransform(&m);
    g->SetClip(&region);
    g->SetPageUnit(UnitWorld);

    BitmapData bitmapData;
/*
    SizeF szF;
    bitmap->GetPhysicalDimension(&szF);
    Size sz;
    sz.Width = (INT)szF.Width;
    sz.Height = (INT)szF.Height;
*/

    Size sz;
    sz.Width = bitmap->GetWidth();
    sz.Height = bitmap->GetHeight();

    Rect rect(0, 0, sz.Width, sz.Height);

    bitmap->LockBits(rect, ImageLockModeRead, PixelFormat32bppARGB, &bitmapData);

    HDC hdc = g->GetHDC();

    struct {
        BITMAPINFO bi;
        RGBQUAD rgbQuad[2];
    } b;

    memset(&b, 0, sizeof(BITMAPINFO));
        
    sz.Width = bitmapData.Width;
    sz.Height = bitmapData.Height;

    b.bi.bmiHeader.biSize = sizeof(BITMAPINFO);
    b.bi.bmiHeader.biWidth = sz.Width;
    b.bi.bmiHeader.biHeight = sz.Height/2;
    b.bi.bmiHeader.biPlanes = 1;
    b.bi.bmiHeader.biBitCount = 32;        // try 24 also
    b.bi.bmiHeader.biCompression = BI_RGB;
    b.bi.bmiHeader.biSizeImage = 0;
    b.bi.bmiHeader.biClrUsed = 0;

    b.bi.bmiColors[0].rgbBlue = 0;
    b.bi.bmiColors[0].rgbGreen = 0;
    b.bi.bmiColors[0].rgbRed = 0xFF;
    b.bi.bmiColors[0].rgbReserved = 0;

    b.bi.bmiColors[1].rgbBlue = 0;
    b.bi.bmiColors[1].rgbGreen = 0xFF;
    b.bi.bmiColors[1].rgbRed = 0;
    b.bi.bmiColors[1].rgbReserved = 0;

    b.bi.bmiColors[2].rgbBlue = 0xFF;
    b.bi.bmiColors[2].rgbGreen = 0;
    b.bi.bmiColors[2].rgbRed = 0;
    b.bi.bmiColors[2].rgbReserved = 0;

    BYTE* ptr = (BYTE*)bitmapData.Scan0 + (sizeof(ARGB)*sz.Width)*(sz.Height-1);
#if 0
    int factor = 3;

    int result1 = 
    StretchDIBits(hdc,
                  0, 
                  0,
                  factor*sz.Width,
                  factor*sz.Height/2,
                  0,
                  0,
                  sz.Width,
                  sz.Height/2,
                  (BYTE*)bitmapData.Scan0,
                  (BITMAPINFO*)&b.bi,
                  DIB_RGB_COLORS,
                  SRCCOPY);
    
    int result2 = 
    StretchDIBits(hdc,
              0, 
              factor*sz.Height/2,
              factor*sz.Width,
              factor*sz.Height/2,
              0,
              0,
              sz.Width,
              sz.Height/2,
              ((BYTE*)bitmapData.Scan0) - (bitmapData.Stride*(sz.Height/2)),
              (BITMAPINFO*)&b.bi,
              DIB_RGB_COLORS,
              SRCCOPY);
    
    int error = GetLastError();
#endif

    g->ReleaseHDC(hdc);
    bitmap->UnlockBits(&bitmapData);

    g->DrawImage(bitmap, Rect(0, 0, size, size));
    delete bitmap;
    
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\printtest\cprinttext.h ===
/******************************Module*Header*******************************\
* Module Name: CPrintText.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRINTTEXT_H
#define __CPRINTTEXT_H

#include "..\CPrimitive.h"

class CPrintText : public CPrimitive  
{
public:
	CPrintText(BOOL bRegression);
	virtual ~CPrintText();

	void Draw(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\printtest\cprivateprinting.h ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.h
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#ifndef __CPRIVATEPRINTING_H
#define __CPRIVATEPRINTING_H

#include "..\CPrimitive.h"

class CPrivatePrinting : public CPrimitive  
{
public:
	CPrivatePrinting(BOOL bRegression);
	virtual ~CPrivatePrinting();

	void Draw(Graphics *g);
    
        // Pattern fill using GDI TextureBrush
        VOID TestBug104604(Graphics *g);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\printtest\cprinting.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrinting.h"

CPrinting::CPrinting(BOOL bRegression)
{
        strcpy(m_szName,"Printing");
        m_bRegression=bRegression;
}

CPrinting::~CPrinting()
{
}

VOID CPrinting::TestTextPrinting(Graphics *g)
{
    Font f(L"Arial", 60);

    FontFamily  ff(L"Arial");
    RectF	  rectf1( 20,   0, 300, 200);
    RectF	  rectf2( 20, 300, 300, 200);
    RectF	  rectf3(220,   0, 300, 200);
    RectF	  rectf4(220, 300, 300, 200);


    Color color1(0xff, 100, 0, 200);
    Color color2(128, 100, 0, 200);
    Color color3(0xff, 0, 100, 200);
    Color color4(128, 0, 100, 0);
    SolidBrush brush1(color1);
    SolidBrush brush2(color2);
    LinearGradientBrush brush3(rectf3, color3, color4, LinearGradientModeForwardDiagonal);

    g->DrawString(L"Color1", 6, &f, rectf1, NULL, &brush1);
    g->DrawString(L"Color2", 6, &f, rectf2, NULL, &brush2);
    g->DrawString(L"Color3", 6, &f, rectf3, NULL, &brush3);
}

VOID CPrinting::TestPerfPrinting(Graphics *g)
{
/*
   Analyze file size based on output of StretchDIBits.  The claim by DonC is that when we StretchDIBits a
   subrectangle of a large DIB, it sends the large DIB to the printer and then clips to the subrectangle.
   but it apparently does on Win98 postscript.

   So this is the results of my test:  1000x1000 DIB (32bpp).  I blitted two chunks:

   This is 200x200 source rectangle (part of a band):

04/27/2000  03:00p              22,198 nt5pcl
04/27/2000  03:02p             268,860 nt5ps			// Level 1 ps
04/27/2000  02:47p              17,488 w98pcl
04/27/2000  02:47p           6,207,459 w98ps			// Level 1 ps

   This is 1000x200 source rectangle (an entire band):

04/27/2000  03:06p              80,291 nt5pcl
04/27/2000  03:06p           1,266,123 nt5ps			// Level 1 ps
04/27/2000  02:51p              60,210 w98pcl
04/27/2000  02:52p           6,207,457 w98ps			// Level 1 ps

   Also compared 32bpp vs. 24bpp DIB.  The results were contradictary:

  04/27/2000  03:59p      <DIR>          ..
  04/27/2000  03:06p              80,291 nt5pcl
  04/27/2000  03:51p             122,881 nt5pcl24
  04/27/2000  03:06p           1,266,123 nt5ps
  04/27/2000  03:51p           1,262,332 nt5ps24
  04/27/2000  02:51p              60,210 w98pcl
  04/27/2000  03:39p             101,216 w98pcl24
  04/27/2000  02:52p           6,207,457 w98ps
  04/27/2000  03:39p           6,207,457 w98ps24

*/
    if (1) 
    {
        BITMAPINFO bi;
        ZeroMemory(&bi, sizeof(BITMAPINFO));

        bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biSizeImage = 0;

        bi.bmiHeader.biWidth = 1000;
        bi.bmiHeader.biHeight = 1000;
        bi.bmiHeader.biBitCount = 32;

        ARGB* Bits = (ARGB*)malloc(bi.bmiHeader.biWidth *
                              bi.bmiHeader.biHeight *
                              sizeof(ARGB));

        ARGB* Ptr = Bits;

        // To eliminate RLE/ASCII85 encoding, set to random bits
        for (INT i=0; i<bi.bmiHeader.biHeight; i++)
            for (INT j=0; j<bi.bmiHeader.biWidth; j++) 
            {
                *Ptr++ = (ARGB)(i | (j<<16));
            }

        HDC hdc = g->GetHDC();

        StretchDIBits(hdc, 0, 0, 1000, 200, 
                      0, 700, 1000, 200, Bits, &bi,
                      DIB_RGB_COLORS, SRCCOPY);

        g->ReleaseHDC(hdc);

        free(Bits);

    }
}

void CPrinting::Draw(Graphics *g)
{
// TestPerfPrinting(g);
// TestTextPrinting(g);
TestBug104604(g);

if (0)
    {

#if 1
    HDC hdc = g->GetHDC();

    HDC bufHdc = CreateCompatibleDC(hdc);

    HBITMAP BufDIB = NULL;
    ARGB* argb;

    struct {
       BITMAPINFO bitmapInfo;
       RGBQUAD rgbQuad[4];
    } bmi;

    INT width=100;
    INT height=100;

    ZeroMemory(&bmi.bitmapInfo, sizeof(bmi.bitmapInfo));

    bmi.bitmapInfo.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bitmapInfo.bmiHeader.biWidth       = width;
    bmi.bitmapInfo.bmiHeader.biHeight      = -height;
    bmi.bitmapInfo.bmiHeader.biPlanes      = 1;
    bmi.bitmapInfo.bmiHeader.biBitCount    = 24;
    bmi.bitmapInfo.bmiHeader.biCompression = BI_RGB;
	
    RGBQUAD red = { 0, 0, 0xFF, 0}; // red
    RGBQUAD green = { 0, 0xFF, 0, 0}; // green
    RGBQUAD blue = { 0xFF, 0, 0, 0}; // blue

    bmi.bitmapInfo.bmiColors[0] = red;
    bmi.bitmapInfo.bmiColors[1] = green;
    bmi.bitmapInfo.bmiColors[2] = blue;

    // if assert fails, then we didn't clean up properly by calling End()
//    ASSERT(BufDIB == NULL);

    BufDIB = CreateDIBSection(bufHdc,
                 &bmi.bitmapInfo,
                 DIB_RGB_COLORS,
                 (VOID**) &argb,
                 NULL,
                 0);
//    ASSERT(BufDIB != NULL);

    memset(argb, 0, 3*width*height);

    INT i,j;
    BYTE* tempptr = (BYTE*)argb;
    for (i=0; i<height; i++)
    {
        for (j=0; j<width; j++)
        {
            if (i==j)
            {
                *tempptr++ = 0xFF;
                *tempptr++ = 0x80;
                *tempptr++ = 0x40;
            }
            else
                tempptr += 3;    
        }
        if ((((ULONG_PTR)tempptr) % 4) != 0) tempptr += 4-(((ULONG_PTR)tempptr) % 4);
    }

    INT mode = GetMapMode(bufHdc);
//    WARNING(("MapMode printing = %08x\n", mode));

    SelectObject(bufHdc, BufDIB);
/*
for (i=0; i<100; i++)
{
    int result = StretchBlt(hdc, 0, i*2, 2*width, 2, bufHdc, 0, i, width, 0, SRCCOPY);
    INT joke = GetLastError();
	joke++;
}
 */
//	int result = StretchBlt(hdc, 0, 0, 50, 50, bufHdc, 0, 0, 50, 50, SRCCOPY);
	
	for (i=0; i<50; i++)
	{
		int result = StretchBlt(hdc, 0, 100+i*2, 100, 1, bufHdc, 0, i*2, 100, 1, SRCCOPY);
    }
//   int result = StretchBlt(hdc, 0, 0, 200, 200, bufHdc, 0, 0, 100, 100, SRCCOPY);

//    ASSERT(result != 0);

    g->ReleaseHDC(hdc);

    DeleteDC(bufHdc);
    DeleteObject(BufDIB);

#endif

#if 1
    REAL widthF = 4; // Pen width

    Color redColor(255, 0, 0);

    SolidBrush brush1(Color(0xFF,0xFF,0,0));
    SolidBrush brush2(Color(0x80,0x80,0,0));

    SolidBrush brush3(Color(0xFF,0xFF,0,0));
    SolidBrush brush4(Color(0x80,0x80,0,0));

    Color colors1[] = { Color(0xFF,0xFF,0,0),
                        Color(0xFF,0,0xFF,0),
                        Color(0xFF,0,0,0xFF),
                        Color(0xFF,0x80,0x80,0x80) };
    Color colors2[] = { Color(0x80,0xFF,0,0),
                        Color(0x80,0,0xFF,0),
                        Color(0x80,0,0,0xFF),
                        Color(0x80,0x80,0x80,0x80) };

    //SolidBrush brush3(colors1[2]);
    //SolidBrush brush4(colors2[2]);

    // Default Wrap: Clamp to small rectangle 
//    RectangleGradientBrush brush3(Rect(125,275,50,50),
//                                  &colors1[0]);//,
                                  //WrapModeClamp);
    // Default Wrap: Clamp to 
//    RectangleGradientBrush brush4(Rect(250,250,100,100),
//                                  &colors2[0]);//,
                                  //WrapModeClamp);

    g->SetPageScale(1.2f);

    // no path clip
    g->FillRectangle(&brush1, Rect(0,25,500,50));

    // tests solid + opaque combinations + path clip only
    g->FillEllipse(&brush1, Rect(100,100,100,100));
    g->FillEllipse(&brush2, Rect(300,100,100,100));
    g->FillEllipse(&brush3, Rect(100,250,100,100));
    g->FillEllipse(&brush4, Rect(300,250,100,100));

    // tests visible clip + path clip
    Region origRegion;
    g->GetClip(&origRegion);
    Region *newRegion = new Region();
    newRegion->MakeInfinite();

    //Rect horzRect(150, 600, 500, 25);
    //Rect vertRect(150, 600, 25, 500);
    Rect horzRect(100, 400, 500, 25);
    Rect vertRect(100, 400, 25, 500);
    Region *horzRegion = new Region(horzRect);
    Region *vertRegion = new Region(vertRect);

    for (i = 0; i < 10; i++)
    {   
        newRegion->Xor(horzRegion);
        newRegion->Xor(vertRegion);
        horzRegion->Translate(0, 50);
        vertRegion->Translate(50, 0);
    }
    delete horzRegion;
    delete vertRegion;

    // Set grid clipping
    g->SetClip(newRegion);

    // set wrap mode from Clamp to Tile    
//    brush3.SetWrapMode(WrapModeTile);
//    brush4.SetWrapMode(WrapModeTile);

    // tests solid + opaque combinations + visible clip +  path clip only

    g->FillEllipse(&brush1, Rect(100,400,100,100));
    g->FillEllipse(&brush2, Rect(300,400,100,100));
    g->FillEllipse(&brush3, Rect(100,550,100,100));
    g->FillEllipse(&brush4, Rect(300,550,100,100));

    // restore original clip region
    g->SetClip(&origRegion);
    delete newRegion;

    // Test case which stretches beyond GetTightBounds() DrawBounds API

    PointF pts[8];

    pts[0].X = 2150.0f; pts[0].Y = 2928.03f;
    pts[1].X = 1950.0f; pts[1].Y = 3205.47f;
    pts[2].X = 1750.0f; pts[2].Y = 2650.58f;
    pts[3].X = 1550.0f; pts[3].Y = 2928.03f;
    pts[4].X = 1550.0f; pts[4].Y = 3371.97f;
    pts[5].X = 1750.0f; pts[5].Y = 3094.53f;
    pts[6].X = 1950.0f; pts[6].Y = 3649.42f;
    pts[7].X = 2150.0f; pts[7].Y = 3371.97f;

    BYTE types[8] = { 1, 3, 3, 3, 1, 3, 3, 0x83 };


    Bitmap *bitmap = new Bitmap(L"winnt256.bmp");

    // Test g->DrawImage
    if (bitmap && bitmap->GetLastStatus() == Ok) 
    {

        int i;

        for (i=0; i<8; i++) 
        {
            pts[i].X = pts[i].X / 8.0f;
            pts[i].Y = pts[i].Y / 8.0f;
        }

        TextureBrush textureBrush(bitmap, WrapModeTile);

        GraphicsPath path(&pts[0], &types[0], 8);

        g->FillPath(&textureBrush, &path);

        // Text using WrapModeClamp
        for (i=0; i<8; i++)
           pts[i].X += 200.0f;

        TextureBrush textureBrush2(bitmap, WrapModeClamp);

        GraphicsPath path2(&pts[0], &types[0], 8);

        g->FillPath(&textureBrush2, &path2);

        delete bitmap;
    }

/*
    Font font(50.0f * g->GetDpiY() / 72.0f, // emSize
              FontFamily(L"Arial"), // faceName,
              0,
              (Unit)g->GetPageUnit()
              );

    // will fail on Win9x
    LPWSTR str = L"Printing Support is COOL";
    GpRectF layoutRect1(200, 200, 300, 100);
    GpRectF layoutRect2(200, 400, 300, 100);
    GpRectF layoutRect3(200, 600, 300, 100);
    GpRectF layoutRect4(200, 800, 300, 100);

    INT len = 0;
    LPWSTR strPtr = str;
    while (*str != '\0') { len++; str++; }

    StringFormat format1 = StringFormatDirectionRightToLeft;
    StringFormat format2 = StringFormatDirectionVertical;
    StringFormat format3 = StringFormatDirectionRightToLeft;
    StringFormat format4 = StringFormatDirectionVertical;

    // Test DDI: SolidText (Brush 1 or 2)
    g->DrawString(strPtr, len, &font, &layoutRect1, &format1, &brush1);
    g->DrawString(strPtr, len, &font, &layoutRect2, &format2, &brush2);   

    // Test DDI: BrushText (Brush 3 or 4)
    g->DrawString(strPtr, len, &font, &layoutRect3, &format3, &brush3);
    g->DrawString(strPtr, len, &font, &layoutRect4, &format4, &brush4);   

    // Test DDI: StrokePath
    // Test DDI: FillRegion
*/
#endif
    }

}

// Try this from Nolan Lettelier
VOID CPrinting::TestNolan1(Graphics *g)
{
/*	TestInit(hdc);

	Graphics *pg = Graphics::FromHDC(hdc);
	if (pg == NULL)
	{
		assert(0);
		return false;
	}

	int sts;
	int alpha = 255, red = 255, green = 0, blue = 255;
	Color c1(alpha,red,green,blue);
	Point p1(150,150), p2(300,300);
	Color c2(255, 255-red, 255-green, 255-blue);
	LineGradientBrush gb(p1, p2, c1, c2);

	Pen p(&gb, 50.0);

	sts = pg->DrawLine(&p,0, 0, 500, 500);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,100, 500, 100);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,350, 500, 350);
	assert(sts == Ok);

	sts = pg->DrawLine(&p,0,500, 500, 0);
	assert(sts == Ok);
	delete pg;
	return true;
        */
}

VOID CPrinting::TestNolan2(Graphics *g)
{
    /*
        CString lineText("NolanRules");
        
	Graphics *pg = g;
        if (pg == NULL)
	{
		assert(0);
		return false;
	}
        Unit origUnit = pg->GetPageUnit();
        Matrix origXform;
        pg->GetTransform(&origXform);

        pg->SetPageUnit(UnitInch);
        pg->ScaleTransform(8.0f/1000.0f, 8.0f/1000.0f);

	Status sts;
	int alpha = 255, red = 255, green = 0, blue = 255;
	RectF rg(150,150,300,175);
	Color c1(alpha,red,green,blue);
	Color c2(255, 255-red, 255-green, 255-blue);
	LineGradientBrush gb(rg, c1, c2, LineGradientModeVertical);

	WCHAR *famName[] = {
		L"Comic Sans MS"
		, L"Courier New"
		, L"Times New Roman"
		, L"Tahoma"
		, L"Arial"
		, L"Lucida Console"
		, L"Garamond"
		, L"Palatino"
		, L"Univers"
		, L"Marigold"
		, L"Albertus"
		, L"Antique Olive"
	};

	int famCount = sizeof(famName) / sizeof(WCHAR *);

	WCHAR *s = L"GDI+ GradientFill";
	
	RectF r(30,30,0,0);
	StringFormat sf(0);
	FontFamily *pFontFamily;

	float lineHeight = 60;
	int i;
	for (i = 0, r.Y = 30 ; r.Y < 800 ; r.Y += lineHeight, ++i)
	{
		pFontFamily = new FontFamily(famName[i % famCount]);
		while (pFontFamily == NULL || pFontFamily->GetLastStatus()
!= Ok)
		{
			delete pFontFamily;
			++i;
			pFontFamily = new FontFamily(famName[i % famCount]);
		}
			
		Font f(*pFontFamily, lineHeight * 5 / 6, 0, UnitPoint);
		sts = pg->DrawString(s, wcslen(s), &f, &r, &sf, &gb);
//		CHECK_RESULT(sts, "TestGradientLinearVertical2 DrawString");
		delete pFontFamily;
	}

	delete pg;
	
        pg->SetPageUnit(origUnit);
        pg->SetTransform(&origXform);
        return true;
*/

} // TestGradientLinearVertical2

VOID CPrinting::TestBug104604(Graphics *g)
{
    BYTE* memory = new BYTE[8*8*3];
    // checkerboard pattern
    for (INT i=0; i<8*8; i += 3)
    {
        if (i%2)
        {
            memory[i] = 0xff;
            memory[i+1] = 0;
            memory[i+2] = 0;
        }
        else
        {
            memory[i] = 0;
            memory[i+1] = 0;
            memory[i+2] = 0xff;
        }
    }
    
    Bitmap bitmap(8,8, 8*3, PixelFormat24bppRGB, memory);
    
    TextureBrush brush(&bitmap);

    g->SetCompositingMode(CompositingModeSourceCopy);
    g->FillRectangle(&brush, 0, 0, 100, 100);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\debug.h ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   debug.h
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// _debugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and 
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//
//  These macros require extra parantheses for the msg argument
//  for example:
//      WARNING(("App passed NULL pointer, ignoring...\n"));
//      ASSERTMSG(x > 0, ("x is less than 0\n"));
//

#if DBG

#ifndef _COMPLUS_GDI

// Global debug level

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_RIP     4

extern INT _debugLevel;

//--------------------------------------------------------------------------
// Debug build for native DLL
//--------------------------------------------------------------------------

// Emit debug messages

VOID DbgPrint(const CHAR*, ...);

// Strip the directory prefix from a filename

const CHAR*
StripDirPrefix(
    const CHAR* filename
    );

#define DBGMSG(level, prefix, msg) \
        { \
            if (_debugLevel <= (level)) \
            { \
                DbgPrint("%s %s (%d): ", prefix, StripDirPrefix(__FILE__), __LINE__); \
                DbgPrint msg; \
            } \
        }

#define DBGPRINT(level, msg) \
        { \
            if (_debugLevel <= (level)) \
            { \
                DbgPrint msg; \
            } \
        }
    
#else // _COMPLUS_GDI

//--------------------------------------------------------------------------
// Debug build COM+ IL
//--------------------------------------------------------------------------

VOID DbgPrint(const WCHAR* msg);
VOID DebugBreak();

#define DBGMSG(level, prefix, msg) \
        DbgPrint(L"*** DEBUG MESSAGE\n")

#define DBGPRINT(level, msg) \
        DbgPrint(L"*** DEBUG MESSAGE\n")

#endif // _COMPLUS_GDI

#define VERBOSE(msg) DBGPRINT(DBG_VERBOSE, msg)
#define TERSE(msg) DBGPRINT(DBG_TERSE, msg)
#define WARNING(msg) DBGMSG(DBG_WARNING, "WRN", msg)

#define ASSERT(cond) \
        { \
            if (! (cond)) \
            { \
                RIP(("\n")); \
            } \
        }

#define ASSERTMSG(cond, msg) \
        { \
            if (! (cond)) \
            { \
                RIP(msg); \
            } \
        }

#define RIP(msg) \
        { \
            DBGMSG(DBG_RIP, "RIP", msg); \
            DebugBreak(); \
        }

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define VERBOSE(msg)
#define TERSE(msg)
#define WARNING(msg)

#define ASSERT(cond)
#define ASSERTMSG(cond, msg)
#define RIP(msg)
#define DBGMSG(level, prefix, msg) 
#define DBGPRINT(level, msg)

#endif // !DBG

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\printtest\cprinttext.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrintText.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrintText.h"

CPrintText::CPrintText(BOOL bRegression)
{
        strcpy(m_szName,"Print Text");
        m_bRegression=bRegression;
}

CPrintText::~CPrintText()
{
}

void CPrintText::Draw(Graphics *g)
{
    //Font font(L"Arial", 60);

    Matrix m;
    g->SetTransform(&m);
   
    g->SetPageUnit(UnitDisplay);
    
    FontFamily  familyArial(L"Arial");
    Font fontArialS(&familyArial, 10.0f);
    Font fontArialL(&familyArial, 50.0f);

    FontFamily familyTahoma(L"Tahoma");
    Font fontTahomaS(&familyTahoma, 10.0f);
    Font fontTahomaL(&familyTahoma, 50.0f);

    FontFamily familyPapyrus(L"Papyrus");
    Font fontPapyrusS(&familyPapyrus, 10.0f);
    Font fontPapyrusL(&familyPapyrus, 50.0f);
    
    FontFamily familyOutlook(L"MS Outlook");
    Font fontOutlookS(&familyOutlook, 10.0f);
    Font fontOutlookL(&familyOutlook, 50.0f);

    Color color3(0xff, 100, 0, 200);
    Color color4(0x80, 0, 100, 50);
    SolidBrush brushSolidOpaque(color3);
    SolidBrush brushSolidAlpha(color4);
    
    WCHAR filename[256];
    wcscpy(filename, L"marble1.jpg");
    Bitmap *bitmap = new Bitmap(filename);                          
    TextureBrush textureBrush(bitmap, WrapModeTile);
    
    RectF rectf(20.0f, 0.0f, 50.0f, 25.0f);
    
    rectf.Y = 200.0f;
    Color color1(255, 255, 0, 0);
    Color color2(255, 0, 255, 0);
    LinearGradientBrush lineGradBrush(rectf, color1, color2, 0.0f);
    

/*  For reference:
    
    Status
    DrawString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        IN const Brush        *brush
*/

    // Small text (punt to GDI)
    g->DrawString(L"Small Solid Opaque", 
                  18, 
                  &fontArialS, 
                  PointF(rectf.X, rectf.Y), 
                  &brushSolidOpaque);

    // Small text (with Alpha)
    g->DrawString(L"Small Solid Alpha", 
                  17, 
                  &fontTahomaS,
                  PointF(rectf.X, rectf.Y + rectf.Height), 
                  &brushSolidAlpha);

    // Large text (punt to GDI)
    g->DrawString(L"Large Solid Opaque", 
                  18, 
                  &fontArialL, 
                  PointF(rectf.X, rectf.Y + rectf.Height*2), 
                  &brushSolidOpaque);

    // Large text (with Alpha)
    g->DrawString(L"Large Solid Alpha", 
                  17, 
                  &fontTahomaL,
                  PointF(rectf.X, rectf.Y + rectf.Height*4), 
                  &brushSolidAlpha);

    rectf.Y += rectf.Height*2;

    // Small text with texture
    g->DrawString(L"Small Texture", 
                  13, 
                  &fontPapyrusS, 
                  PointF(rectf.X, rectf.Y + rectf.Height*6), 
                  &textureBrush);

    // Small text with line gradient
    g->DrawString(L"Small Line Grad", 
                  15, 
                  &fontOutlookS,
                  PointF(rectf.X, rectf.Y + rectf.Height*7), 
                  &lineGradBrush);

    // Large text (punt to GDI)
    g->DrawString(L"Large Line Grad", 
                  15, 
                  &fontPapyrusL, 
                  PointF(rectf.X, rectf.Y + rectf.Height*8), 
                  &lineGradBrush);

    // Small text (with Alpha)
    g->DrawString(L"Large Texture", 
                  13,
                  &fontOutlookL,
                  PointF(rectf.X, rectf.Y + rectf.Height*12), 
                  &textureBrush);

    // Shadow part.
    REAL tx = 0.0f/500.0f*TESTAREAWIDTH, ty = 400.0f/500.0f*TESTAREAHEIGHT;
    Matrix skew;
    skew.Scale(1.0, 0.5);
    skew.Shear(-2.0, 0, MatrixOrderAppend);
    skew.Translate(tx, ty, MatrixOrderAppend);
    g->SetTransform(&skew);
    g->DrawString(L"Shadow", 6, &fontPapyrusL, PointF(rectf.X, rectf.Y), &brushSolidOpaque);

    delete bitmap;
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\dynarray.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   dynarray.hpp
*
* Abstract:
*
*   Dynamic array template classes. See DynamicArrays.doc in the Specs 
*   directory.
*
*   DynArray is a container which keeps its contents in a contiguous buffer,
*   reallocating memory as necessary. It accepts an optional initial
*   allocation, which is used unless it is too small to accommodate the
*   elements.
*
*   DynArrayIA is a cosmetic wrapper which encapsulates the intial allocation,
*   allowing the dynamic array to be treated like a normal class.
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   02/26/1999 agodfrey
*       Revamped it to use an implementation class (DynArrayImpl). 
*       Now the template part of it can compile to nothing, or be small enough
*       to inline efficiently, so that using the template with many different
*       types doesn't cause code bloat.
*
*       Also, I added a version (DynArrayIA) which makes using an initial
*       allocation much easier.
*
* Notes:
*
*   12/02/1998 davidx
*   Changes from the previous version in gdiplus prototype:
*   + getData: Use &dynarr[index] instead.
*   + increaseCount: Use addMultiple instead (2nd variation).
*   + replace: Use dynarr[index] = newItem.
*   + attachData: Use dynarr.replaceWith(dynarr2).
*   + constructor: No longer takes initialCapacity, use ReserveSpace instead
*   + new constructor: Takes a stack array which is used for buffer (faster).
*
*   02/26/1999 agodfrey
*   + Use the 'implementation class' to avoid code bloat for out-of-line
*     functions.
*   + GetCapacity: Unused, not useful - removed.
*   + Reset: Added 'shrink' flag (default true). If it's false, Reset sets the
*     count to zero but doesn't free the memory. This is preferable to
*     SetCount(0).
*   + Made ShrinkToSize() reuse the initial allocation. This also makes the
*     growing and shrinking logic simpler - 'no initial allocation' is treated
*     like an initial allocation of size zero (at memory location 'NULL').
*
\**************************************************************************/

#ifndef _DYNARRAY_HPP
#define _DYNARRAY_HPP

template <class T> class DynArray : public DynArrayImpl
{
public:
    
    // Default allocation step size

    enum
    {
        DEFAULT_STEPSIZE = 512
    };
    
    // Constructor
    //
    //   initalAllocation - the initial allocation, which can be global,
    //                      static or dynamic memory (or NULL)
    //   allocSize        - size of the initial allocation 
    //                      (0 if there is none)
    //   stepSize         - number of elements added each time the buffer grows

    DynArray(
        T *initialAllocation, 
        UINT allocSize, 
        UINT stepSize = DEFAULT_STEPSIZE
        ):
        DynArrayImpl(initialAllocation, allocSize, stepSize)
    {
    }

    // Constructor (no initial allocation)
    //
    //   stepSize - number of elements added each time the buffer grows

    DynArray(UINT stepSize = DEFAULT_STEPSIZE):
        DynArrayImpl(NULL, 0, stepSize)
    {
    }

    // Destructor

    ~DynArray()
    {
        if (DataBuffer != InitialAllocation)
        {
           GpFree(DataBuffer);
        }
    }

    // Change the step size to the specified value

    VOID SetStepSize(UINT stepSize = DEFAULT_STEPSIZE)
    {
        ASSERT(stepSize > 0);
        StepSize = stepSize;
    }
    
    // Return a pointer to the array data
    //   NOTE: We intentionally avoid type conversion operator here
    //   to reduce the chances for confusion.

    T *GetDataBuffer() const
    {
        return static_cast<T *>(DataBuffer);
    }

    // Index operator

    T &operator[](INT n) const
    {
        ASSERT(n >= 0 && (UINT)n < Count);
        return GetDataBuffer()[n];
    }

    // First/last element of the array

    T &First() const
    {
        ASSERT(Count > 0);
        return GetDataBuffer()[0];
    }

    T &Last() const
    {
        ASSERT(Count > 0);
        return GetDataBuffer()[Count-1];
    }
        
    // Number of elements in the array

    INT GetCount() const
    {
        return Count;
    }

    // Reset the dynamic array to empty state
    //
    // shrink - If FALSE, don't free the current buffer.

    VOID Reset(BOOL shrink=TRUE)
    {
        Count = 0;
        if (shrink)
        {
            ShrinkToSize();
        }
    }

    // Shrink the dynamic array capacity to be just big enough
    // for the number of existing elements in the array.
    //
    // This reuses the initial allocation if possible.

    VOID ShrinkToSize()
    {
        DynArrayImpl::ShrinkToSize(sizeof(T));
    }

    // Add a new element to the end of the dynamic array

    GpStatus Add(const T& newItem)
    {
        return DynArrayImpl::AddMultiple(sizeof(T), 1, &newItem);
    }

    // Add multiple items to the end of the dynamic array

    GpStatus AddMultiple(const T* newItems, INT n)
    {
        return DynArrayImpl::AddMultiple(sizeof(T), n, newItems);
    }
    
    // Another variation of addMultiple above
    //
    // In this case, the data for the new elements are
    // not available. Instead, we'll do the following:
    //  (1) reserve the space for additional elements
    //  (2) increase the Count by the number of additional elements
    //  (3) return a pointer to the first new elements

    T *AddMultiple(INT n)
    {
        return static_cast<T *>(DynArrayImpl::AddMultiple(sizeof(T), n));
    }

    // Detach the data buffer from the dynamic array
    // Cannot be used if there is an initial allocation

    T *DetachData()
    {
        return static_cast<T *>(DynArrayImpl::DetachData());
    }
    
    // Detatch the buffer from another array, and set this array
    // to point to it. NOTE: This modifies the other array.

    VOID ReplaceWith(DynArray<T> *dynarr)
    {
        if (DataBuffer != InitialAllocation)
        {
            GpFree(DataBuffer);
        }

        Count = dynarr->Count;
        Capacity = dynarr->Capacity;
        DataBuffer = dynarr->DetachData();
    }
    
    // More dangerous interface:
    //
    // These functions are alternatives to Add/AddMultiple.
    // They can be used to reduce overhead, but you have to know what
    // you're doing.
    //
    // AdjustCount/SetCount - modify the count directly, without growing or
    //   shrinking the array.
    // ReserveSpace - grow the buffer, but don't actually add any elements to
    //   the array.
    
    VOID AdjustCount(UINT addElts)
    {
        Count += addElts;
    }

    VOID SetCount(UINT count)
    {
        Count = count;
    }
    
    GpStatus ReserveSpace(UINT newElements)
    {
        return Grow(sizeof(T), newElements);
    }

	// !! This is added as a hack to allow bitwise cloning
	//    of DynArray types.

	GpStatus RenewDataBuffer()
	{
		void *oldDataBuffer = DataBuffer;
		void *oldInitialAllocation = InitialAllocation;

		InitialAllocation = NULL;
		AllocSize = 0;

		DataBuffer = (VOID*) malloc(Capacity*sizeof(T));
		memcpy(DataBuffer, oldDataBuffer, Capacity*sizeof(T));

		return Ok;
	}

};

// DynArrayIA: A version of DynArray which encapsulates the initial allocation.
//
// For example:
//
// DynArrayIA<MyType, 10> array(16);
//
// This declares a DynArray of MyType objects, with an initial allocation of
// 10 elements, and a step size of 16. Such a declaration can be used on
// the stack or in another object.

template <class T, int ALLOCSIZE> class DynArrayIA : public DynArray<T>
{
public:

    // Constructor
    //
    //   stepSize - number of elements added each time the buffer grows

    DynArrayIA(UINT stepSize = DEFAULT_STEPSIZE):
        DynArray<T>(InitialAllocationBuffer, ALLOCSIZE, stepSize)
    {
    }

private:
    T InitialAllocationBuffer[ALLOCSIZE];
};

#endif // !_DYNARRAY_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\functest\printtest\cprivateprinting.cpp ===
/******************************Module*Header*******************************\
* Module Name: CPrinting.cpp
*
* This file contains the code to support the functionality test harness
* for GDI+.  This includes menu options and calling the appropriate
* functions for execution.
*
* Created:  05-May-2000 - Jeff Vezina [t-jfvez]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/
#include "CPrivatePrinting.h"

CPrivatePrinting::CPrivatePrinting(BOOL bRegression)
{
        strcpy(m_szName,"Private Printing");
        m_bRegression=bRegression;
}

CPrivatePrinting::~CPrivatePrinting()
{
}

void CPrivatePrinting::Draw(Graphics *g)
{

    // Pattern fill using GDI TextureBrush
    TestBug104604(g);
}

VOID CPrivatePrinting::TestBug104604(Graphics *g)
{
    BYTE* memory = new BYTE[8*8*3];
    // checkerboard pattern
    for (INT i=0; i<8*8; i += 3)
    {
        if (i%2)
        {
            memory[i] = 0xff;
            memory[i+1] = 0;
            memory[i+2] = 0;
        }
        else
        {
            memory[i] = 0;
            memory[i+1] = 0;
            memory[i+2] = 0xff;
        }
    }

    // Use GDI+ to do texture fill.

    Bitmap bitmap(8,8, 8*3, PixelFormat24bppRGB, memory);
    
    TextureBrush brush(&bitmap);
    g->SetCompositingMode(CompositingModeSourceCopy);

    g->FillRectangle(&brush, 200, 0, 100, 100);

    // Use GDI to do the same thing.

    HBITMAP hbm = CreateBitmap(8, 8, 1, 24, memory);
    if (hbm) 
    {
        LOGBRUSH logBrush;
        logBrush.lbStyle = BS_PATTERN;
        logBrush.lbHatch = (ULONG_PTR) hbm;

        HBRUSH hbr = CreateBrushIndirect(&logBrush);

        if (hbr) 
        {
            POINT pts[4];
            pts[0].x = 0; pts[0].y = 0;
            pts[1].x = 100; pts[1].y = 0;
            pts[2].x = 100; pts[2].y = 100;
            pts[3].x = 0; pts[3].y = 100;

            HDC hdc = g->GetHDC();
            if (hdc) 
            {
                HBRUSH oldBr = (HBRUSH)SelectObject(hdc, hbr);
                Polygon(hdc, &pts[0], 4);
                SelectObject(hdc, oldBr);
                g->ReleaseHDC(hdc);
            }
            DeleteObject(hbr);
        }
        DeleteObject(hbm);
    }
    
    if (memory)
    {
        delete memory;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\dynarrayimpl.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Dynamic array implementation class
*
* Abstract:
*
*   This is the class which implements the dynamic array. 
*   It is used by the wrapper template classes DynArray and DynArrayIA.
*
* Created:
*
*  2/18/1999 agodfrey
*
\**************************************************************************/

#include "gdiptest.h"

/**************************************************************************\
*
* Function Description:
*
*   DynArrayImpl constructor
*
* Arguments:
*
*   initialAllocation - initial allocation, or NULL
*   allocSize         - size of the initial allocation
*   stepSize          - number of elements added each time the buffer grows
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/

DynArrayImpl::DynArrayImpl(
    void *initialAllocation, 
    UINT allocSize, 
    UINT stepSize
    )
{
    ASSERT((initialAllocation != NULL) || (allocSize == 0));

    DataBuffer = InitialAllocation = initialAllocation;
    Capacity = AllocSize = allocSize;
    Count = 0;
    StepSize = stepSize;
}

/**************************************************************************\
*
* Function Description:
*
*   Shrink the buffer so that it is just big enough for the items
*   the dynamic array holds.
*
* Arguments:
*
*   eltSize - size of each array element
*
* Return Value:
*
*   NONE
*
* Created:
*
*   1/18/1999 agodfrey
*     Added code to reuse the initial allocation.
*
\**************************************************************************/

VOID DynArrayImpl::ShrinkToSize(UINT eltSize) 
{
    ASSERT(Count <= Capacity);

    if (DataBuffer == InitialAllocation)
    {
        // Since we're shrinking, we know that the current data buffer
        // is big enough.
        
        return;
    }

    if (Count <= AllocSize)
    {
        // The buffer will fit into the initial allocation.

        GpFree(DataBuffer);
        DataBuffer = InitialAllocation;
        Capacity = AllocSize;
        return;
    }

    // If we get here, we know that DataBuffer points to dynamic memory,
    // and that Count != 0.
    //
    // The second point is important because GpRealloc(x, 0) returns
    // a pointer to a valid zero-length buffer.

    void *newbuf = GpRealloc(DataBuffer, Count*eltSize);

    if (!newbuf)
    {
        // GpRealloc failed. Keep the current allocation
        
        WARNING(("ShrinkToSize: GpRealloc failed"));
        return;
    }

    DataBuffer = newbuf;
    Capacity = Count;
}

/**************************************************************************\
*
* Function Description:
*
*   Add space for new elements (if necessary). Does not update Count.
*
* Arguments:
*
*   eltSize     - size of each array element
*   newElements - the number of new elements
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   1/18/1999 agodfrey
*
\**************************************************************************/

GpStatus DynArrayImpl::Grow(UINT eltSize, UINT newElements)
{
    UINT newCount = Count + newElements;

    if (newCount <= Capacity)
    {
        return Ok;
    }

    ASSERT(newCount > 0);

    // Round up new capacity to be a multiple of allocation step size

    Capacity = StepSize * ((newCount + StepSize - 1) / StepSize);

    void *newbuf;

    if (DataBuffer == InitialAllocation)
    {
        // Do our first dynamic allocation

        newbuf = GpMalloc(Capacity*eltSize);

        if (newbuf && Count)
        {
            GpMemcpy(newbuf, DataBuffer, Count*eltSize);
        }
    }
    else
    {
        // Reallocate memory

        newbuf = GpRealloc(DataBuffer, Capacity*eltSize);
    }

    if (!newbuf)
    {
        WARNING(("Grow: alloc failed\n"));
        return OutOfMemory;
    }

    DataBuffer = newbuf;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Detach the data buffer from the dynamic array.
*   Cannot be used if there is an initial allocation.
*
* Return Value:
*
*   The data buffer
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
void *DynArrayImpl::DetachData()
{
    ASSERT(InitialAllocation == NULL);

    void *data = DataBuffer;

    DataBuffer = NULL;
    Count = Capacity = 0;

    return data;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new, uninitialized elements, and return a pointer to them.
*
* Arguments:
*
*   eltSize     - size of each element
*   newElements - number of new elements
*
* Return Value:
* 
*   Pointer to the new space, or NULL on failure
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
void *DynArrayImpl::AddMultiple(UINT eltSize, UINT newElements)
{
    ASSERT(newElements>0);

    if (Grow(eltSize, newElements) != Ok)
        return NULL;

    void *newSpace = static_cast<BYTE *>(DataBuffer) + Count * eltSize;
    Count += newElements;

    return newSpace;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new elements, initializing them with the given data.
*
* Arguments:
*
*   eltSize     - size of each element
*   newElements - number of new elements
*   newData     - the data to be copied into the new space
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
GpStatus DynArrayImpl::AddMultiple(
    UINT eltSize, 
    UINT newElements, 
    const void *newData
    )
{
    ASSERT(newElements>0);

    GpStatus status = Grow(eltSize, newElements);
     
    if (status == Ok)
    {
        // NOTE: assume T is a shallow data type, i.e.
        //  it doesn't contain nested references.

        GpMemcpy(
            static_cast<BYTE *>(DataBuffer) + Count * eltSize, 
            newData, 
            newElements * eltSize
            );
        Count += newElements;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\dynarrayimpl.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Dynamic array implementation class
*
* Abstract:
*
*   This class contains definitions of functions which can't (or shouldn't)
*   be inlined. We use a separate implementation class because this allows us
*   to avoid the code bloat template classes produce; every instance of the
*   DynArray template can use the same version of each out-of-line member.
*
*   The DynArray data members need to be declared here, because they are
*   used by DynArrayImpl.
*
* Created:
*
*  2/18/1999 agodfrey
*
\**************************************************************************/

class DynArrayImpl
{
protected:
    
    // Constructor
    //
    //   initalAllocation - the initial allocation, which can be global,
    //                      static or dynamic memory (or NULL)
    //   allocSize        - size of the initial allocation 
    //                      (0 if there is none)
    //   stepSize         - number of elements added each time the buffer grows

    DynArrayImpl(void *initialAllocation, UINT allocSize, UINT stepSize);
    
    // Shrink the buffer so that it is just big enough for the items
    // the dynamic array holds.

    VOID ShrinkToSize(UINT eltSize);
    
    // Add space for new elements (if necessary). Does not update Count.
    // eltSize           - size of each element
    // newElements       - number of new elements

    GpStatus Grow(UINT eltSize, UINT newElements);

    // Add new, uninitialized elements, and return a pointer to them.
    // eltSize     - size of each element
    // newElements - number of new elements

    void *AddMultiple(UINT eltSize, UINT newElements);
    
    // Add new elements, initializing them with the given data.
    // eltSize     - size of each element
    // newElements - number of new elements
    // newData     - the data to be copied into the new space
    
    GpStatus AddMultiple(UINT eltSize, UINT newElements, const void *newData);
    
    // Detach the data buffer from the dynamic array.
    // Cannot be used if there is an initial allocation.

    void *DetachData();

    // Capacity, StepSize, AllocSize and Count are all measured in elements,
    // not bytes.

    void *DataBuffer;
    void *InitialAllocation;
    UINT AllocSize;
    UINT Capacity;
    UINT StepSize;
    UINT Count;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdipbrush.hpp ===
#ifndef _GDIPBRUSH_HPP
#define _GDIPBRUSH_HPP

class TestBrush;
class TestSolidBrush;
class TestTextureBrush;
class TestRectangleGradientBrush;
class TestRadialGradientBrush;
class TestTriangleGradientBrush;
class TestPathGradientBrush;
class TestHatchBrush;

//
// Interface class to inherit from GDI+ Brush objects
//

class TestBrushInterface : public TestConfigureInterface,
						   public TestDialogInterface
{
public:
	TestBrushInterface() : brush(NULL) {};

	~TestBrushInterface()
	{
		delete brush;
	}

	// acquire brush object
	virtual Brush* GetBrush() { return brush; }

	virtual INT GetType() = 0;

protected:
	// pointer to underlying GDI+ brush object
	Brush *brush;
};

class TestBrush : public TestBrushInterface
{
public:
	static TestBrush* CreateNewBrush(INT type);

	virtual VOID AddToFile(OutputFile* outfile, INT id = 0) = 0;
	virtual TestBrush* Clone() = 0;
};

class TestSolidBrush : public TestBrush
{
public:
	TestSolidBrush() 
	{
		argb = 0x80000000;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	// output brush setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	// return type of brush
	virtual INT GetType()
	{
		return SolidColorBrush;
	};

	// Clone interface
	virtual TestBrush* Clone() 
	{
		TestSolidBrush *newBrush = new TestSolidBrush();
		*newBrush = *this;					// bitwise copy

		if (brush)
			newBrush->brush = brush->Clone();	// clone GDI+ brush

		return newBrush;
	};

private:
	ARGB argb;
};

class TestTextureBrush : public TestBrush
{
public:
	TestTextureBrush() 
	{
		filename = NULL;
		bitmap = NULL;
		wrapMode = 0;
		matrix = NULL;
	}

	~TestTextureBrush()
	{
		if (filename)
			free(filename);

		delete bitmap;
		delete matrix;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	// output brush setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	// return type of brush
	virtual INT GetType()
	{
		return TextureFillBrush;
	};

	// Clone interface
	virtual TestBrush* Clone() 
	{
		TestTextureBrush *newBrush = new TestTextureBrush();
		*newBrush = *this;					// bitwise copy
		
		if (brush)
			newBrush->brush = brush->Clone();	// clone GDI+ brush
		
		if (bitmap)
			newBrush->bitmap = (Bitmap*)bitmap->Clone();
		
		if (matrix)
			newBrush->matrix = matrix->Clone();

		if (filename)
		{
#ifdef UNICODE
			newBrush->filename = _wcsdup(filename);
#else
			newBrush->filename = _strdup(filename);
#endif
		}

		return newBrush;
	};

private:
	Bitmap *bitmap;
	LPTSTR filename;
	INT wrapMode;
	Matrix *matrix;
};

class TestRectGradBrush : public TestBrush
{
public:
	friend class TestRectGradShape;

	TestRectGradBrush() 
	{
		horzBlend = vertBlend = NULL;
		wrapMode = 0;
		matrix = NULL;
	}

	~TestRectGradBrush()
	{
		if (horzBlend)
			free(horzBlend);
		
		if (vertBlend)
			free(vertBlend);

		delete matrix;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	// output brush setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	// return type of brush
	virtual INT GetType()
	{
		return RectGradBrush;
	};

	// Clone interface
	virtual TestBrush* Clone() 
	{
		TestRectGradBrush *newBrush = new TestRectGradBrush();
		*newBrush = *this;					// bitwise copy
		
		if (brush)
			newBrush->brush = brush->Clone();	// clone GDI+ brush
				
		if (matrix)
			newBrush->matrix = matrix->Clone();

		if (horzCount && horzBlend)
		{
			INT pos;

			newBrush->horzBlend = (REAL*)malloc(sizeof(REAL)*horzCount);
			for (pos = 0; pos < horzCount; pos++)
				newBrush->horzBlend[pos] = horzBlend[pos];
		}

		if (vertCount && vertBlend)
		{
			INT pos;

			newBrush->vertBlend = (REAL*)malloc(sizeof(REAL)*vertCount);
			for (pos = 0; pos < vertCount; pos++)
				newBrush->vertBlend[pos] = vertBlend[pos];
		}

		return newBrush;
	};

private:
	ERectangle rect;
	ARGB argb[4];

	INT horzCount, vertCount;
	REAL *horzBlend, *vertBlend;

	INT wrapMode;
	Matrix *matrix;
};

class TestRadialGradBrush : public TestBrush
{
public:
	friend class TestRadialGradShape;

	TestRadialGradBrush() 
	{
		blend = NULL;
		matrix = NULL;
		wrapMode = 0;
	}

	~TestRadialGradBrush()
	{
		if (blend)
			free(blend);

		delete matrix;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	// output brush setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	// return type of brush
	virtual INT GetType()
	{
		return RadialGradBrush;
	};

	// Clone interface
	virtual TestBrush* Clone() 
	{
		TestRadialGradBrush *newBrush = new TestRadialGradBrush();
		*newBrush = *this;					// bitwise copy
	
		if (brush)
			newBrush->brush = brush->Clone();	// clone GDI+ brush
	
		if (matrix)
			newBrush->matrix = matrix->Clone();

		if (blendCount && blend)
		{
			INT pos;

			blend = (REAL*)malloc(sizeof(REAL)*blendCount);
			for (pos = 0; pos < blendCount; pos++)
				newBrush->blend[pos] = blend[pos];
		}

		return newBrush;
	};

private:
	ERectangle rect;
	ARGB centerARGB, boundaryARGB;
	
	INT blendCount;
	REAL *blend;

	INT wrapMode;
	Matrix *matrix;
};

class TestTriangleGradBrush : public TestBrush
{
public:
	friend class TestTriangleGradShape;
	
	TestTriangleGradBrush() 
	{
        pts[0].X = 10; pts[0].Y = 10;
        pts[1].X = 90; pts[1].Y = 10;
        pts[2].X = 50; pts[2].Y = 100;

        blend[0] = blend[1] = blend[2] = NULL;

        argb[0] = 0x80FF0000;
        argb[1] = 0x8000FF00;
        argb[2] = 0x800000FF;

		wrapMode = 0;
		matrix = NULL;
	}

	~TestTriangleGradBrush()
	{
		for (INT pos = 0; pos < 3; pos++)
			if (blend[pos])
				free(blend[pos]);

		delete matrix;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	// output brush setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	// return type of brush
	virtual INT GetType()
	{
		return TriangleGradBrush;
	};

	// Clone interface
	virtual TestBrush* Clone() 
	{
		TestTriangleGradBrush *newBrush = new TestTriangleGradBrush();
		*newBrush = *this;					// bitwise copy
		
		if (brush)
			newBrush->brush = brush->Clone();	// clone GDI+ brush
				
		if (matrix)
			newBrush->matrix = matrix->Clone();

		for (INT pos = 0; pos < 3; pos++)
		{
			if (count[pos] && blend[pos])
			{
				newBrush->blend[pos] = (REAL*)malloc(sizeof(REAL)*count[pos]);
				for (INT pos2 = 0; pos2 < 3; pos2++)
					newBrush->blend[pos][pos2] = blend[pos][pos2];
			}
			else
			{
				newBrush->blend[pos] = NULL;
				newBrush->count[pos] = 0;
			}
		}

		return newBrush;
	};

private:
    ARGB argb[3];
    Point pts[3];
    INT count[3];           // blend factor counts
    REAL* blend[3];
	
	INT wrapMode;
	Matrix *matrix;
};

class TestPathGradBrush : public TestBrush
{
public:
	friend class TestTriangleGradShape;
	
	TestPathGradBrush() 
	{
		pts.Add(Point(100,100));
		pts.Add(Point(100,50));
		pts.Add(Point(150,150));
		pts.Add(Point(50,150));

        surroundBlend = centerBlend = NULL;
		surroundCount = centerCount = 0;
	
		argb.Add((ARGB)0x80000000);
        argb.Add((ARGB)0x80FF0000);
        argb.Add((ARGB)0x8000FF00);
        argb.Add((ARGB)0x800000FF);

		wrapMode = 0;
		matrix = NULL;
	}

	~TestPathGradBrush()
	{
		if (surroundBlend)
			free(surroundBlend);

		if (centerBlend)
			free(centerBlend);

		delete matrix;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	// output brush setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	// return type of brush
	virtual INT GetType()
	{
		return PathGradBrush;
	};

	// Clone interface
	virtual TestBrush* Clone() 
	{
		TestPathGradBrush *newBrush = new TestPathGradBrush();
		*newBrush = *this;					// bitwise copy
		
		if (brush)
			newBrush->brush = brush->Clone();	// clone GDI+ brush
				
		if (matrix)
			newBrush->matrix = matrix->Clone();

		// !! HACK POLICE !! HACK ALERT !!
		// internally clone the DataBuffer pointer

		pts.RenewDataBuffer();
		argb.RenewDataBuffer();

		if (surroundCount && surroundBlend)
		{
			newBrush->surroundBlend = (REAL*) malloc(sizeof(REAL)*surroundCount);
			memcpy(newBrush->surroundBlend, surroundBlend, sizeof(REAL)*surroundCount);
		}
		else
			newBrush->surroundBlend = NULL;
		
		if (centerCount && centerBlend)
		{
			newBrush->centerBlend = (REAL*) malloc(sizeof(REAL)*centerCount);
			memcpy(newBrush->centerBlend, centerBlend, sizeof(REAL)*centerCount);
		}
		else
			newBrush->centerBlend = NULL;

		return newBrush;
	};

private:
	ARGBArray argb;
	PointArray pts;

    REAL* surroundBlend;
	REAL* centerBlend;

	INT surroundCount;           // blend factor counts
	INT centerCount;
	
	INT wrapMode;
	Matrix *matrix;
};

class TestHatchBrush : public TestBrush
{
public:
	TestHatchBrush() 
	{
		foreArgb = 0xFF000000;
		backArgb = 0xFFFFFFFF;
		hatch = 0;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
							   UINT msg, 
							   WPARAM wParam, 
							   LPARAM lParam);

	// output brush setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	// return type of brush
	virtual INT GetType()
	{
		return HatchFillBrush;
	};

	// Clone interface
	virtual TestBrush* Clone() 
	{
		TestHatchBrush *newBrush = new TestHatchBrush();
		*newBrush = *this;					// bitwise copy

		if (brush)
			newBrush->brush = brush->Clone();	// clone GDI+ brush

		return newBrush;
	};

private:
	ARGB foreArgb, backArgb;
	INT hatch;
};

#endif // _GDIPBRUSH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdipdraw.cpp ===
#include "gdiptest.h"
#include <commctrl.h>


extern const TCHAR* formatExtList = 
					_T("CPP files\0*.cpp\0"
					   "Java files\0*.Java\0"
					   "VML files\0*.vml\0"
					   "All files\0*.*\0");

extern const TCHAR* defaultFormatExt = _T("cpp");

//*******************************************************************
//
// TestDraw
//
//
//
//*******************************************************************

VOID TestDraw::AddPoint(HWND hwnd, Point pt)
{
	if (!curShape)
	{
		// no current shape, create one of appropriate type
		curShape = TestShape::CreateNewShape(shapeType);
		curShape->Initialize(NULL);

		// save copy of brush & pen in shape
		curShape->SetBrush(curBrush->Clone());
		curShape->SetPen(curPen->Clone());
	}
	else if (curShape->IsComplete())
	{
		TestShape *lastShape = curShape;

		// add current shape to shape stack
		shapeStack.Push(curShape);

		// create blank shape of this type
		curShape = TestShape::CreateNewShape(shapeType);
		curShape->Initialize(lastShape);

		// save copy of brush & pen in shape
		curShape->SetBrush(curBrush->Clone());
		curShape->SetPen(curPen->Clone());
	}

	curShape->AddPoint(hwnd, pt);
}

BOOL TestDraw::DoneShape(HWND hwnd)
{
	// we are at regular end point regardless
	if (!curShape->IsComplete())
	{
		// if point can't be treated as an 'end point' then treat
		// it as a regular control point
		curShape->DoneShape(hwnd);
	}

	return curShape->IsComplete();
}

BOOL TestDraw::EndPoint(HWND hwnd, Point pt)
{
	AddPoint(hwnd, pt);
	
	return DoneShape(hwnd);
}

BOOL TestDraw::RemovePoint(HWND hwnd)
{
	if (!curShape || (curShape && !curShape->RemovePoint(hwnd)))
	{
		if (shapeStack.GetCount() > 0)
		{
			// the shape is empty, delete it
			delete curShape;
		
			curShape = shapeStack.Pop();

			// !! reset menu option for current shape
			UpdateStatus();

			return curShape->RemovePoint(hwnd);
		}
	}

	return FALSE;
}

VOID TestDraw::Draw(HWND hwnd)
{
	PAINTSTRUCT ps;
	RECT rt;
	HDC hdc;

	// !!! when CopyPixels work, cache the graphics up to the
	//     last shape.  We blit that, then the new shape begins.

	// posts a WM_ERASEBKGND message
	hdc = BeginPaint(hwnd, &ps);

	/////////////////////////////////////////////////////
	// GDI+ code BEGINS
	////////////////////////////////////////////////////
	Graphics *g = new Graphics(hwnd);

	GetClientRect(hwnd, &rt);
	ERectangle rect(rt.left, 
				   rt.top, 
				   rt.right-rt.left, 
				   rt.bottom-rt.top
				   -18);	// for status window

	// set appropriate clip region
	if (useClip)
	{
		Region region(rect);
		region.And(clipRegion);
		g->SetClip(&region);
	}
	else
	{
		g->SetClip(rect);
	}

	g->SetRenderingHint(antiAlias);

	g->SetWorldTransform(worldMatrix);

	// !!! iterate through stack of shapes.

	// because of alpha we can't just redraw the last shape,
	// otherwise we will blend alpha with ourself and whatever
	// else is under us.  clear the rectangle and redraw all.

	if (redrawAll)
	{
		INT count = shapeStack.GetCount();
		INT pos;
		
		for (pos=0; pos<count; pos++)
		{
			TestShape *shape = shapeStack[pos];
			
			if (!shape->GetDisabled())
			{
				// shape must be complete
				ASSERT(shape->IsComplete());

				shape->DrawShape(g);
	
				if (keepControlPoints)
					shape->DrawPoints(g);
			}
		}
	}

	if (curShape)
	{
		if (curShape->IsComplete())
		{
			curShape->DrawShape(g);

			if (keepControlPoints)
				goto DrawCurShape;
		}
		else
		{
DrawCurShape:
			g->SetClip(rect);
			curShape->DrawPoints(g);
		}
	}
	
	delete g;

	////////////////////////////////////////////////////
	// GDI+ code ENDS.
	////////////////////////////////////////////////////

	UpdateStatus();

	EndPaint(hwnd, &ps);

}

VOID TestDraw::SetClipRegion(HWND hwnd)
{

	if (!curShape)
	{
		WarningBox(_T("Create at least one shape first!"));
		return;
	}

	// we want to allow the very last shape to clip
	// so we add it in here to the stack list.
	if (curShape->IsComplete())
	{
		TestShape *lastShape = curShape;

		// add current shape to shape stack
		shapeStack.Push(curShape);

		// create blank shape of this type
		curShape = TestShape::CreateNewShape(shapeType);
		curShape->Initialize(lastShape);

		// save copy of brush & pen in shape
		curShape->SetBrush(curBrush->Clone());
		curShape->SetPen(curPen->Clone());
	}

	// notice we repeatly initialize even though we only
	// created this once...
	clipShapeRegion->Initialize(&shapeStack, curShape, useClip);

	if (clipShapeRegion->ChangeSettings(hwnd))
	{
		delete clipRegion;
		clipRegion = clipShapeRegion->GetClipRegion();

		useClip = clipShapeRegion->GetClipBool();
	
		SetMenuCheckCmd(hwnd, 
						MenuOtherPosition, 
						IDM_USECLIP, 
						useClip);

		// force redraw of all stacked shapes w/new clip region
		InvalidateRect(hwnd, NULL, TRUE);
		UpdateWindow(hwnd);
	}

	UpdateStatus();
}

VOID TestDraw::RememberPoint(Point pt)
{
	remPoint = pt;
}

VOID TestDraw::MoveControlPoint(Point pt)
{
	// find shape that hits control point.

	Point *hitpt = NULL;
	
	if (curShape)
	{
		if (curShape->MoveControlPoint(remPoint, pt))
			return;
		
		INT count = shapeStack.GetCount();
		INT pos;

		for (pos = count-1; pos>=0; pos--)
		{
			TestShape* shape = shapeStack[pos];

			if (shape->MoveControlPoint(remPoint, pt))
				return;
		}
	}

	// nothing moved
	WarningBeep();
}

VOID TestDraw::ChangeBrush(HWND hwnd, INT type)
{
	TestBrush *newBrush = NULL;

	if (curBrush && (type == curBrush->GetType()))
	{
		// same brush type

		// !!! change brush color in middle of drawing?

		TestBrush* newBrush = curBrush->Clone();

		if (newBrush->ChangeSettings(hwnd))
		{
			delete curBrush;
			curBrush = newBrush;
		}
	}
	else
	{
		// new brush type		
		
		SetMenuCheckPos(hwnd, 
						MenuBrushPosition, 
						curBrush->GetType(), 
						FALSE);

		newBrush = TestBrush::CreateNewBrush(type);

		if (!newBrush)
		{
			return;
		}

		newBrush->Initialize();
		
		// keep or discard changed brush settings
		if (newBrush->ChangeSettings(hwnd))
		{
			delete curBrush;
			curBrush = newBrush;
			// !!! change brush color in middle of drawing
		}
		else
		{	
			delete newBrush;
		}

		SetMenuCheckPos(hwnd, 
						MenuBrushPosition, 
						curBrush->GetType(), 
						TRUE);
	}

	if (curShape && curShape->GetCount() == 0)
	{
		curShape->SetBrush(curBrush->Clone());
	}

	UpdateStatus();
}

VOID TestDraw::ChangePen(HWND hwnd)
{
	TestPen *newPen = NULL;

	if (curPen)
	{
		TestPen *newPen = curPen->Clone();

		if (newPen->ChangeSettings(hwnd))
		{
			delete curPen;
			curPen = newPen;
		}
	}
	else
	{
		newPen = new TestPen();
		newPen->Initialize();

		// !!! change pen in middle of drawing?
		if (newPen->ChangeSettings(hwnd))
		{
			delete curPen;
			curPen = newPen;
		}
		else
		{
			delete newPen;
		}
	}

	if (curShape && curShape->GetCount() == 0)
	{
		curShape->SetPen(curPen->Clone());
	}

	UpdateStatus();
}

VOID TestDraw::ChangeShape(HWND hwnd, INT type)
{
	TestShape *shape;
	
	shape = TestShape::CreateNewShape(type);
	shape->Initialize(curShape);

	// save copy of brush & pen in shape
	shape->SetBrush(curBrush->Clone());
	shape->SetPen(curPen->Clone());

	if (shape->ChangeSettings(hwnd))
	{
		SetMenuCheckPos(hwnd, 
						MenuShapePosition, 
						shapeType, 
						FALSE);

		shapeType = type;

		// if shape can be completed, complete it, otherwise
		// destroy the shape.

		if (curShape)
		{
			if (!curShape->IsComplete())
			{
				curShape->DoneShape(hwnd);
			}

			if (!curShape->IsComplete() || curShape->IsEmpty())
			{
				delete curShape;
				curShape = NULL;
			}
		}

		if (curShape)
			shapeStack.Add(curShape);

		curShape = shape;

		SetMenuCheckPos(hwnd, 
						MenuShapePosition, 
						shapeType, 
						TRUE);
		
		// removing last incomplete shape, redraw the window.
		// OR completed shape, redraw the window
		InvalidateRect(hwnd, NULL, TRUE);
		UpdateWindow(hwnd);
	}
	else
	{
		delete shape;
	}

	UpdateStatus();
}

VOID TestDraw :: UpdateStatus(HWND hwnd)
{
	if (hwnd)
	{
		
		if (hwndStatus)
		{
			// destroy previous window
			DestroyWindow(hwndStatus);
			hwndStatus = NULL;
		}

		// we only want to destroy this window
		if (hwnd == (HWND)-1)
			return;

		hwndStatus = CreateStatusWindow(WS_CHILD | WS_VISIBLE,
										_T(""),
										hwnd,
										0);		// never used?
	}

	if (hwndStatus)
	{
		TCHAR str[MAX_PATH];
		
		_stprintf(&str[0],"[Last shape: %s] [Brush: %s] [Number of Points: %d]",
				shapeList[inverseShapeValue[GetShapeType()]],
				brushList[inverseBrushValue[GetBrushType()]],
				curShape ? curShape->GetCount() : 0);

		// !! for some reason, DrawStatusText didn't work here...
		//    wouldn't it just call SendMessage() ?!?

		SendMessage(hwndStatus, SB_SETTEXT, 0 | 0, (LPARAM)(LPTSTR)str);
	}
}

VOID TestDraw :: SaveAsFile(HWND hWnd)
{
	static TCHAR fname[MAX_PATH] = _T("");

	OPENFILENAME ofn =
	{
		sizeof(OPENFILENAME),
		hWnd,
		0,
		formatExtList,
		NULL,
		0,
		1,
		&fname[0],
		MAX_PATH-1,
		NULL,
		0,
		NULL,
		NULL,
		OFN_PATHMUSTEXIST,
		0,
		0,
		defaultFormatExt,
		NULL,
		NULL,
		NULL
	};

	if ((GetSaveFileName(&ofn) == TRUE) &&
			fname[0] != '\0')
	{
		OutputFile* outfile = OutputFile::CreateOutputFile(fname);
		
		if (outfile)
		{
			outfile->GraphicsProcedure();
			
			outfile->BeginIndent();
			
			outfile->GraphicsDeclaration();
			
			outfile->BlankLine();

			outfile->SetMatrixDeclaration(_T("g"),
										  _T("SetWorldTransform"),
										  _T("worldMatrix"),
										  worldMatrix);

			INT count = shapeStack.GetCount();
		
			for (INT pos=0; pos<count; pos++)
			{
				TestShape *shape = shapeStack[pos];
				ASSERT(shape->IsComplete());

				outfile->BlankLine();

				outfile->BeginIndent();

				shape->AddToFile(outfile);

				outfile->EndIndent();
			}

			if (curShape && curShape->IsComplete())
			{
				outfile->BlankLine();

				outfile->BeginIndent();

				curShape->AddToFile(outfile);

				outfile->EndIndent();
			}

			outfile->EndIndent();

			delete outfile;

			WarningBox(_T("Graphics source code saved."));
		}
		else
			WarningBox(_T("Can't create file for writing."));
	}

	UpdateStatus();
}

//*******************************************************************
//
// TestGradDraw
//
//
//
//*******************************************************************

VOID TestGradDraw::AddPoint(HWND hwnd, Point pt)
{
	gradShape->AddPoint(hwnd, pt);
}

BOOL TestGradDraw::DoneShape(HWND hwnd)
{
	// pop-up dialog box to configure point parameters
	gradShape->DoneShape(hwnd);

	return TRUE;
}

BOOL TestGradDraw::EndPoint(HWND hwnd, Point pt)
{
	return gradShape->EndPoint(hwnd, pt);
}

BOOL TestGradDraw::RemovePoint(HWND hwnd)
{
	return gradShape->RemovePoint(hwnd);
}

VOID TestGradDraw::Draw(HWND hwnd)
{
	PAINTSTRUCT ps;
	RECT rt;
	HDC hdc;

	// !!! when CopyPixels work, cache the graphics up to the
	//     last shape.  We blit that, then the new shape begins.

	hdc = BeginPaint(hwnd, &ps);

	/////////////////////////////////////////////////////
	// GDI+ code BEGINS
	////////////////////////////////////////////////////
	Graphics *g = new Graphics(hwnd);

	GetClientRect(hwnd, &rt);
	ERectangle rect(rt.left, 
				   rt.top, 
				   rt.right-rt.left, 
				   rt.bottom-rt.top);
	g->SetClip(rect);
	
	g->SetRenderingHint(TRUE);

	gradShape->DrawShape(g);
	gradShape->DrawPoints(g);
	
	delete g;

	////////////////////////////////////////////////////
	// GDI+ code ENDS.
	////////////////////////////////////////////////////

	EndPaint(hwnd, &ps);
}

VOID TestGradDraw::SetClipRegion(HWND hwnd)
{
}

VOID TestGradDraw::RememberPoint(Point pt)
{
	remPoint = pt;
}

VOID TestGradDraw::MoveControlPoint(Point pt)
{
	if (!gradShape->MoveControlPoint(remPoint, pt))
		WarningBeep();
}

VOID TestGradDraw :: UpdateStatus(HWND hwnd)
{
}

VOID TestGradDraw :: SaveAsFile(HWND hwnd)
{
}

BOOL TestGradDraw :: ChangeSettings(HWND hwndParent)
{
	HWND hWnd;
	MSG msg;
	
	HMENU hMenu = LoadMenu(hInst, 
						MAKEINTRESOURCE(IDR_GRADBRUSH));

	hWnd = CreateWindow(
			szWindowClass, 
			_T("Gradient Brush Shape"), 
			WS_OVERLAPPEDWINDOW | WS_VISIBLE,
			CW_USEDEFAULT, 
			CW_USEDEFAULT, 
			300, 
			200, 
			(HWND)hwndParent, 
			(HMENU)hMenu,							// menu handle
			(HINSTANCE)hInst, 
			(LPVOID)(static_cast<TestDrawInterface*>(this)));

    if (!hWnd)
    {
        return FALSE;
    }

    ShowWindow(hWnd, SW_SHOWNORMAL);
    UpdateWindow(hWnd);

	HACCEL hAccelTable = LoadAccelerators(hInst, (LPCTSTR)IDC_GDIPTEST);

   	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	DeleteObject(hAccelTable);

	return msg.wParam;
}

VOID TestGradDraw::Initialize()
{
	DebugBreak();
}

VOID TestGradDraw::Initialize(TestGradShape *newGradShape)
{
	gradShape = newGradShape;
}

VOID TestGradDraw::Reset(HWND hwnd)
{
	NotImplementedBox();
}

VOID TestGradDraw::Instructions(HWND hwnd)
{
	NotImplementedBox();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdipclip.h ===
enum NodeType
{
	DataNode = 0,
	AndNode = 1,
	OrNode = 2,
	XorNode = 3
};

// shape flags for temporary editing
#define ShapeDisabled		0x00000001

template <class Data> class TreeNode
{
public:
	friend class TestShapeRegion;

	TreeNode(NodeType type = DataNode, Data* data = NULL, BOOL notNode = FALSE)
	{
		this->type = type;
		this->data = data;
		this->notNode = notNode;
		nodeName = NULL;

		if (data)
		{
			// !! violates we are a template class.. Yipes!! hacky!!
			path = new GraphicsPath();
			data->AddToPath(path);
		}
		else
			path = NULL;

		nextSibling = NULL;
		prevSibling = NULL;
		parent = NULL;
		firstChild = NULL;

		hItem = (HTREEITEM)-1;
	}
	
	~TreeNode()
	{
		if (nodeName)
			free(nodeName);

		TreeNode* next = firstChild;
		while (next)
		{	
			TreeNode* nextnext = next->nextSibling;
			delete next;
			next = nextnext;
		}

		if (nextSibling)
			nextSibling->prevSibling = prevSibling;

		if (prevSibling)
			prevSibling->nextSibling = nextSibling;

		if (parent && parent->firstChild == this)
			parent->firstChild = nextSibling;

		if (path)
			delete path;
	};
	
	TreeNode* GetRoot()
	{
		TreeNode* next = parent;

		while (next && next->parent)
			next = next->parent;

		return next ? next : this;
	}

	BOOL HasChildren()
	{
		return (firstChild) ? TRUE : FALSE;
	}

	TreeNode* GetParent()
	{
		return parent;
	}

	TreeNode* GetNextSibling()
	{
		return nextSibling;
	}

	TreeNode* GetPrevSibling()
	{
		return prevSibling;
	}

	TreeNode* GetFirstChild()
	{
		return firstChild;
	}

	VOID MoveChildrenToParent()
	{
		ASSERT(parent);

		TreeNode* lastSibling = parent->firstChild;
		while (lastSibling->nextSibling)
			lastSibling = lastSibling->nextSibling;

		lastSibling->nextSibling = firstChild;
		if (firstChild)
			firstChild->prevSibling = lastSibling;

		lastSibling = firstChild;
		while (lastSibling)
		{
			lastSibling->parent = parent;
			lastSibling = lastSibling->nextSibling;
		}

		firstChild = NULL;
	}

	HTREEITEM CreateTreeView(HWND hwndTV)
	{
		HTREEITEM hTreeItem = AddToTreeView(hwndTV);

		if (nextSibling)
			nextSibling->CreateTreeView(hwndTV);

		if (firstChild)
			firstChild->CreateTreeView(hwndTV);

		return hTreeItem;
	}

	HTREEITEM AddToTreeView(HWND hwndTV)
	{
		nodeName = GetNodeName(type, notNode, data);

		TVINSERTSTRUCT insertStruct =
		{
			parent ? (HTREEITEM)parent->GetHTREEITEM() : TVI_ROOT,
			prevSibling ? (HTREEITEM)prevSibling->GetHTREEITEM() : TVI_FIRST,
		};
		
		TVITEMEX itemex =
		{
			TVIF_CHILDREN|
				TVIF_PARAM|
				TVIF_STATE|
				TVIF_TEXT,				// mask
			(HTREEITEM)(NULL),			// identifies TV item
			0,							// state
			0,							// stateMask
			nodeName,					// text to display
			0,							// cchTextMax
			0,							// iImage
			0,							// iSelectedImage
			(firstChild ? 1 : 0),		// cChildren
			(LPARAM)(this),				// lParam
			1							// iIntegral
		};

		// !! wasn't able to compile into one assignment !?!?
		insertStruct.itemex = itemex;

		hItem = TreeView_InsertItem(hwndTV, &insertStruct);

		return hItem;
	};

	VOID AddChild(TreeNode* node)
	{
		if (!firstChild)
		{
			firstChild = node;

			node->parent = this;
			node->prevSibling = NULL;
			
			node->nextSibling = NULL;
			node->firstChild = NULL;
		}
		else
		{
			TreeNode* next = firstChild;

			while (next->nextSibling)
				next = next->nextSibling;

			next->nextSibling = node;
			node->parent = this;
			node->prevSibling = next;

			node->nextSibling = NULL;
			node->firstChild = NULL;
		}
	};

	VOID AddSibling(TreeNode* node)
	{
		TreeNode* next = this;

		while (next->nextSibling)
			next = next->nextSibling;

		if (next)
		{
			next->nextSibling = node;
			node->parent = this->parent;
			node->prevSibling = next;

			node->nextSibling = NULL;
			node->firstChild = NULL;
		}
		else
			ASSERT(FALSE);
	};

	VOID AddAsParent(TreeNode* newParent)
	{
		newParent->parent = parent;
		newParent->prevSibling = prevSibling;
		newParent->nextSibling = nextSibling;
		newParent->firstChild = this;

		if (parent && parent->firstChild == this)
			parent->firstChild = newParent;

		if (prevSibling)
			prevSibling->nextSibling = newParent;
		
		if (nextSibling)
			nextSibling->prevSibling = newParent;

		nextSibling = NULL;
		prevSibling = NULL;
		parent = newParent;
	}

	BOOL IsEmpty()
	{
		return (type == DataNode) && (notNode) && (data == NULL);
	}

	BOOL IsInfinite()
	{
		return (type == DataNode) && (!notNode) && (data == NULL);
	}

	HTREEITEM GetHTREEITEM()
	{
		return hItem;
	}

	static LPTSTR GetNodeName(NodeType type, 
							  BOOL notNode,
							  Data* data)
	{
		TCHAR tmpName[MAX_PATH];
		LPTSTR name;

		switch(type)
		{
		case DataNode:
			// !! won't work on other template class types.
			if (data)
			{
				if (notNode)
				{
					name = &tmpName[0];

					_stprintf(&tmpName[0],
						_T("NOT %s"),
						data->GetShapeName());

				}
				else
					name = data->GetShapeName();
			}
			else
			{
				if (notNode)
					name = _T("Empty");
				else
					name = _T("Infinite");
			}
			break;
		
		case AndNode:
			if (notNode)
				name = _T("NAND");
			else
				name = _T("AND");
			break;

		case OrNode:
			if (notNode)
				name = _T("NOR");
			else
				name = _T("OR");
			break;

		case XorNode:
			if (notNode)
				name = _T("NXOR");
			else
				name = _T("XOR");
			break;

		default:
			ASSERT(FALSE);
			return _T("Unknown!?!");
		};
		
		return _tcsdup(name);
	}

	Region* GetRegion()
	{
		Region* newRegion = NULL;

		switch(type)
		{
		case DataNode:
		{
			if (path)
				newRegion = new Region(path);
			else
			{
				newRegion = new Region();
				newRegion->SetInfinite();
			}
			break;
		}

		case AndNode:
		case OrNode:
		case XorNode:
		{
			Region* curRegion;
			TreeNode* curNode = firstChild;
			
			newRegion = new Region();
			if (type == AndNode)
				newRegion->SetInfinite();
			else
				newRegion->SetEmpty();

			while (curNode)
			{
				curRegion = curNode->GetRegion();
				
				if (type == AndNode)
					newRegion->And(curRegion);
				else if (type == OrNode)
					newRegion->Or(curRegion);
				else
				{
					ASSERT(type == XorNode);
					newRegion->Xor(curRegion);
				}

				curNode = curNode->nextSibling;
				delete curRegion;
			}

			break;
		}

		default:
			ASSERT(FALSE);
			break;
		}
		
		// complement the current region
		if (notNode)
		{
			Region *tmpRegion = new Region();
			tmpRegion->SetInfinite();
			newRegion->Complement(tmpRegion);
			delete tmpRegion;
		}

		return newRegion;
	}

	TreeNode* Clone()
	{
		TreeNode* newNode = new TreeNode(type, data, notNode);
		TreeNode* curNode = firstChild;
		TreeNode* newSibling = NULL;

		// loop through all children, clone and add to 'newNode'
		while (curNode)
		{
			TreeNode *newChild = curNode->Clone();

			newChild->nodeName = GetNodeName(type, notNode, data);

			if (!newSibling)
				newSibling = newNode->firstChild = newChild;
			else 
			{
				newSibling->nextSibling = newChild;
				newChild->prevSibling = newSibling;
				newSibling = newChild;
			}

			newChild->parent = newNode;
			curNode = curNode->nextSibling;
		}
		
		return newNode;
	}

private:
	NodeType type;
	BOOL notNode;

	LPTSTR nodeName;

	TreeNode* nextSibling;
	TreeNode* prevSibling;
	TreeNode* firstChild;
	TreeNode* parent;

	HTREEITEM hItem;

	GraphicsPath* path;			// GDI+ path for shape
	
	Data* data;
};

typedef TreeNode<TestShape> ClipTree;

class TestShapeRegion : public TestConfigureInterface,
						public TestDialogInterface
{
public:
	TestShapeRegion()
	{
		clipTree = new ClipTree(AndNode, NULL, FALSE);
		origTree = NULL;

		shapeStack = new ShapeStack();
		origStack = NULL;
	}

	~TestShapeRegion()
	{
		delete clipTree;
		delete shapeStack;

		// do not delete 'origTree' or 'origStack'
		// these are temporary references for saving under 'OK'
	}

	//  configuration management
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();
	virtual VOID Initialize(ShapeStack* stack, TestShape* current, BOOL useClip);

	// dialog control interface methods
	virtual VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

	Region* GetClipRegion();
	BOOL GetClipBool()
	{
		return origUseClip;
	}

protected:
	VOID AddClipNode(HWND hwnd, NodeType type = DataNode);
	VOID RemoveClipNode(HWND hwnd);
	VOID ToggleNotNode(HWND hwnd);

	VOID ShiftCurrentShape(HWND hwnd, INT dir);
	VOID ToggleDisableShape(HWND hwnd);

	VOID UpdateShapePicture(HWND hwnd);
	VOID CleanUpPictures(HWND hwnd);

private:
	// currently modified parameters
	ShapeStack* shapeStack;
	ClipTree* clipTree;

	// original saved parameters
	ShapeStack* origStack;
	ClipTree* origTree;
	BOOL origUseClip;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdipbrush.cpp ===
#include "gdiptest.h"

extern const TCHAR* fileExtList = 
					_T("BMP files\0*.BMP\0"
					   "JPG files\0*.JPG\0"
					   "GIF files\0*.GIF\0"
					   "All files\0*.*\0");

extern const TCHAR* defaultExt = _T("jpg");

TestBrush* TestBrush::CreateNewBrush(INT type)
{
	switch (type)
	{
	case SolidColorBrush:
		return new TestSolidBrush();

	case TextureFillBrush:
		return new TestTextureBrush();

	case RectGradBrush:
		return new TestRectGradBrush();

	case RadialGradBrush:
		return new TestRadialGradBrush();

	case TriangleGradBrush:
		return new TestTriangleGradBrush();

	case PathGradBrush:
		return new TestPathGradBrush();

	case HatchFillBrush:
		return new TestHatchBrush();

	// !!! Other brush types

	default:
		NotImplementedBox();
		return NULL;
	}
}

//*******************************************************************
//
// TestSolidBrush
//
//
//
//*******************************************************************

BOOL TestSolidBrush :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_SOLIDBRUSH_DLG),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));


	if (ok)
	{
		// initialize a new GDI+ brush with settings
		delete brush;
		
		Color solidcolor(argb);
		
		brush = new SolidBrush(solidcolor);

		return TRUE;
	}
	
	return FALSE;
};

VOID TestSolidBrush :: Initialize()
{
	argb = 0x80000000;

	delete brush;
	
	Color solidcolor(argb);
						      
	brush = new SolidBrush(solidcolor);
}

VOID TestSolidBrush :: AddToFile(OutputFile* outfile, INT id)
{
	TCHAR colorStr[MAX_PATH];
	TCHAR brushStr[MAX_PATH];

	if (id)
	{
		_stprintf(&colorStr[0], _T("color%d"), id);
		_stprintf(&brushStr[0], _T("brush%d"), id);
	}
	else
	{
		_tcscpy(&colorStr[0], _T("color"));
		_tcscpy(&brushStr[0], _T("brush"));
	}

	outfile->ColorDeclaration(&colorStr[0], 
							  &argb);

	outfile->BlankLine();

	outfile->Declaration(_T("SolidBrush"), 
						 &brushStr[0], 
						 _T("%s"), 
						 &colorStr[0]);
}

VOID TestSolidBrush :: InitDialog(HWND hwnd)
{
	SetDialogLong(hwnd, IDC_SB_ALPHA, argb >> Color::AlphaShift);
}

BOOL TestSolidBrush :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	argb = (argb & ~Color::AlphaMask) |
		      (GetDialogLong(hwnd, IDC_SB_ALPHA) 
				  << Color::AlphaShift);
	
	if (warning)
		InitDialog(hwnd);

	return warning;
}

BOOL TestSolidBrush :: ProcessDialog(HWND hwnd, 
							UINT msg, 
							WPARAM wParam, 
							LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_SB_COLORBUTTON:
			UpdateRGBColor(hwnd, IDC_SB_PIC, argb);
			break;

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_SB_PIC, argb);
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestTextureBrush
//
//
//
//*******************************************************************

BOOL TestTextureBrush :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_TEXTURE_DLG),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));


	if (ok)
	{
		// try open file first
		if (!filename || !bitmap)
			return FALSE;

		// initialize a new GDI+ brush with settings
		delete brush;

		TextureBrush *texBrush = new TextureBrush(bitmap, 
											wrapValue[wrapMode]);
		texBrush->SetTransform(matrix);

		brush = texBrush;

		// release bitmap
		delete bitmap;
		bitmap = NULL;

		return TRUE;
	}
	
	return FALSE;
};

VOID TestTextureBrush :: Initialize()
{
	filename = NULL;
	wrapMode = Tile;
	
	delete matrix;
	matrix = new Matrix();
	
	ASSERT(!bitmap);

	delete brush;

	// no image is black
	brush = blackBrush->Clone();
}

VOID TestTextureBrush::AddToFile(OutputFile* outfile, INT id)
{
	TCHAR brushStr[MAX_PATH];
	TCHAR matrixStr[MAX_PATH];
	TCHAR bitmapStr[MAX_PATH];

	if (id)
	{
		_stprintf(&brushStr[0], _T("brush%d"), id);
		_stprintf(&matrixStr[0], _T("matrix%d"), id);
		_stprintf(&bitmapStr[0], _T("bitmap%d"), id);
	}
	else
	{
		_tcscpy(&brushStr[0], _T("brush"));
		_tcscpy(&matrixStr[0], _T("matrix"));
		_tcscpy(&bitmapStr[0], _T("bitmap"));
	}

	outfile->Declaration(_T("Bitmap"), 
						 &bitmapStr[0], 
						 "%s",
						 outfile->WStr(filename));

	outfile->BlankLine();

	outfile->Declaration(_T("TextureBrush"), 
						 &brushStr[0], 
						 _T("%s, %s"),
						 outfile->Ref(&bitmapStr[0]),
						 wrapStr[wrapMode]);

	outfile->BlankLine();

	outfile->SetMatrixDeclaration(&brushStr[0],
								  _T("SetTransform"), 
								  &matrixStr[0],
								  matrix);
}

VOID TestTextureBrush :: InitDialog(HWND hwnd)
{
	SetDialogText(hwnd, IDC_TEXTURE_FILENAME, filename, FALSE);
	SetDialogCombo(hwnd, IDC_BRUSH_WRAP, wrapList, numWrap, wrapMode);
}

BOOL TestTextureBrush :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	TCHAR fname[MAX_PATH];

	GetDialogText(hwnd, IDC_TEXTURE_FILENAME, &fname[0], MAX_PATH-1);

	if (filename)
		free(filename);

	filename = _tcsdup(&fname[0]);

	wrapMode = GetDialogCombo(hwnd, IDC_BRUSH_WRAP);

	return FALSE;
}

BOOL TestTextureBrush :: ProcessDialog(HWND hwnd, 
							UINT msg, 
							WPARAM wParam, 
							LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_TEXTURE_FILEBUTTON:
			{
				TCHAR fname[MAX_PATH];
	
				GetDialogText(hwnd, IDC_TEXTURE_FILENAME, &fname[0], MAX_PATH-1);

				OPENFILENAME ofn =
				{
					sizeof(OPENFILENAME),
					hwnd,
					0,
					fileExtList,
					NULL,
					0,
					1,
					&fname[0],
					MAX_PATH-1,
					NULL,
					0,
					NULL,
					NULL,
					OFN_PATHMUSTEXIST,
					0,
					0,
					defaultExt,
					NULL,
					NULL,
					NULL
				};

				if ((GetOpenFileName(&ofn) == TRUE) &&
					fname[0] != '\0')
				{
					HANDLE hFile = CreateFile(fname,
								  GENERIC_READ,
								  FILE_SHARE_READ,
								  NULL,
								  OPEN_EXISTING,
								  0,
								  0);

					if (!hFile)
					{
						WarningBox(_T("Can't open file for reading."));
						return TRUE;
					}

					CloseHandle(hFile);

#ifdef UNICODE
					LPWSTR wFilename = &fname[0];
#else // !UNICODE
					LPWSTR wFilename = (LPWSTR)malloc(sizeof(WCHAR)*(strlen(&fname[0])+1));

					MultiByteToWideChar(CP_ACP, 
						0,
						&fname[0], 
						strlen(&fname[0])+1,
						wFilename,
						strlen(&fname[0])+1);
#endif
					if (bitmap)
						delete bitmap;

					bitmap = new Bitmap(wFilename);

#ifndef UNICODE
					free(wFilename);
#endif
					if (!bitmap || bitmap->GetLastStatus() != Ok)
					{
						WarningBox(_T("Can't load bitmap file."));
						
						if (bitmap)
							delete bitmap;
					}
					else
					{
						SetDialogText(hwnd, IDC_TEXTURE_FILENAME, &fname[0], FALSE);
					}
				}
			}
			break;

		case IDC_BRUSH_TRANSFORM:
			{
				TestTransform transDlg;
				
				transDlg.Initialize(&matrix);

				transDlg.ChangeSettings(hwnd);
			}
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestRectGradBrush
//
//
//
//*******************************************************************

BOOL TestRectGradBrush :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_RECTGRAD_DLG),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	if (ok)
	{
		// initialize a new GDI+ brush with settings
		delete brush;

		Color colors[4] =
		{
			Color(argb[0]),
			Color(argb[1]),
			Color(argb[2]),
			Color(argb[3])
		};

		RectangleGradientBrush* rectBrush =
			 new RectangleGradientBrush(rect,
										(Color*)&colors[0],
										wrapValue[wrapMode]);
		rectBrush->SetTransform(matrix);
		rectBrush->SetHorizontalBlend(horzBlend, horzCount);
		rectBrush->SetVerticalBlend(vertBlend, vertCount);

		brush = rectBrush;
		return TRUE;
	}
	
	return FALSE;
};

VOID TestRectGradBrush :: Initialize()
{
	rect.X = rect.Y = 0;
	rect.Width = rect.Height = 100;

	// !! need editing support for these...
	horzCount = 0;
	horzBlend = NULL;
	vertCount = 0;
	vertBlend = NULL;

	wrapMode = 0;
	delete matrix;
	matrix = new Matrix();

	argb[0] = 0xFFFFFFFF;
	argb[1] = 0xFFFF0000;
	argb[2] = 0xFF00FF00;
	argb[3] = 0xFF0000FF;
	
	Color colors[4] =
	{ 
		Color(argb[0]),
		Color(argb[1]),
		Color(argb[2]),
		Color(argb[3])
	};

	delete brush;

	RectangleGradientBrush *rectBrush =
		 new RectangleGradientBrush(rect,
									(Color*)&colors[0],
									wrapValue[wrapMode]);

	rectBrush->SetTransform(matrix);
	rectBrush->SetHorizontalBlend(horzBlend, horzCount);
	rectBrush->SetVerticalBlend(vertBlend, vertCount);

	brush = rectBrush;
}

VOID TestRectGradBrush::AddToFile(OutputFile* outfile, INT id)
{
	TCHAR brushStr[MAX_PATH];
	TCHAR rectStr[MAX_PATH];
	TCHAR matrixStr[MAX_PATH];
	TCHAR colorsStr[MAX_PATH];
	TCHAR blend1Str[MAX_PATH];
	TCHAR blend2Str[MAX_PATH];

	if (id)
	{
		_stprintf(&brushStr[0], _T("brush%d"), id);
		_stprintf(&rectStr[0], _T("rect%db"), id);
		_stprintf(&matrixStr[0], _T("matrix%d"), id);
		_stprintf(&colorsStr[0], _T("colors%db"), id);
		_stprintf(&blend1Str[0], _T("horzBlend%db"), id);
		_stprintf(&blend2Str[0], _T("vertBlend%db"), id);
	}
	else
	{
		_tcscpy(&brushStr[0], _T("brush"));
		_tcscpy(&rectStr[0], _T("rectb"));
		_tcscpy(&matrixStr[0], _T("matrixb"));
		_tcscpy(&colorsStr[0], _T("colors"));
		_tcscpy(&blend1Str[0], _T("horzBlend"));
		_tcscpy(&blend2Str[0], _T("vertBlend"));
	}

	outfile->ColorDeclaration(&colorsStr[0], 
							  &argb[0],
							  4);

	outfile->BlankLine();

	outfile->RectangleDeclaration(&rectStr[0],
								  rect);

	outfile->BlankLine();

	outfile->Declaration(_T("RectangleGradientBrush"), 
						 &brushStr[0], 
						 _T("%s, %s, %s"),
						 &rectStr[0],
						 outfile->RefArray(&colorsStr[0]),
						 wrapStr[wrapMode]);

	outfile->BlankLine();

	outfile->SetMatrixDeclaration(&brushStr[0], 
								  _T("SetTransform"), 
								  &matrixStr[0],
								  matrix);

	if (horzBlend && horzCount) 
	{
		outfile->BlankLine();

	  	outfile->SetBlendDeclaration(&brushStr[0],
									 _T("SetHorizontalBlend"),
									 &blend1Str[0], 
									 horzBlend, 
									 horzCount);
	}

	if (vertBlend && vertCount)
	{
		outfile->BlankLine();

		outfile->SetBlendDeclaration(&brushStr[0],
									 _T("SetVerticalBlend"),
									 &blend2Str[0], 
									 vertBlend, 
									 vertCount);
	}
}

VOID TestRectGradBrush :: InitDialog(HWND hwnd)
{
	SetDialogReal(hwnd, IDC_RECTGRAD_X,		 rect.X);
	SetDialogReal(hwnd, IDC_RECTGRAD_Y,		 rect.Y);
	SetDialogReal(hwnd, IDC_RECTGRAD_WIDTH,  rect.Width);
	SetDialogReal(hwnd, IDC_RECTGRAD_HEIGHT, rect.Height);

	SetDialogLong(hwnd, IDC_RECTGRAD_ALPHA1, argb[0] >> Color::AlphaShift);
	SetDialogLong(hwnd, IDC_RECTGRAD_ALPHA2, argb[1] >> Color::AlphaShift);
	SetDialogLong(hwnd, IDC_RECTGRAD_ALPHA3, argb[2] >> Color::AlphaShift);
	SetDialogLong(hwnd, IDC_RECTGRAD_ALPHA4, argb[3] >> Color::AlphaShift);
	
	SetDialogCombo(hwnd, IDC_BRUSH_WRAP, wrapList, numWrap, wrapMode);

	// !! is this a bug: can't paint colors in this call??
	SendMessage(hwnd, WM_COMMAND, IDC_REFRESH_PIC, 0);
}


BOOL TestRectGradBrush :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	rect.X = GetDialogReal(hwnd, IDC_RECTGRAD_X);
	rect.Y = GetDialogReal(hwnd, IDC_RECTGRAD_Y);
	rect.Width = GetDialogReal(hwnd, IDC_RECTGRAD_WIDTH);
	rect.Height = GetDialogReal(hwnd, IDC_RECTGRAD_HEIGHT);

	argb[0] = (argb[0] & ~Color::AlphaMask)
				| (GetDialogLong(hwnd, IDC_RECTGRAD_ALPHA1) 
					<< Color::AlphaShift);
	
	argb[1] = (argb[1] & ~Color::AlphaMask)
				| (GetDialogLong(hwnd, IDC_RECTGRAD_ALPHA2) 
					<< Color::AlphaShift);

	argb[2] = (argb[2] & ~Color::AlphaMask)
				| (GetDialogLong(hwnd, IDC_RECTGRAD_ALPHA3) 
					<< Color::AlphaShift);

	argb[3] = (argb[3] & ~Color::AlphaMask)
				| (GetDialogLong(hwnd, IDC_RECTGRAD_ALPHA4) 
					<< Color::AlphaShift);

	wrapMode = GetDialogCombo(hwnd, IDC_BRUSH_WRAP);

	return FALSE;
}

BOOL TestRectGradBrush :: ProcessDialog(HWND hwnd, 
							UINT msg, 
							WPARAM wParam, 
							LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_RECTGRAD_COLOR1:
			UpdateRGBColor(hwnd, IDC_RECTGRAD_PIC1, argb[0]);
			break;

		case IDC_RECTGRAD_COLOR2:
			UpdateRGBColor(hwnd, IDC_RECTGRAD_PIC2, argb[1]);
			break;

		case IDC_RECTGRAD_COLOR3:
			UpdateRGBColor(hwnd, IDC_RECTGRAD_PIC3, argb[2]);
			break;

		case IDC_RECTGRAD_COLOR4:
			UpdateRGBColor(hwnd, IDC_RECTGRAD_PIC4, argb[3]);
			break;

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_RECTGRAD_PIC1, argb[0] & ~Color::AlphaMask);
			UpdateColorPicture(hwnd, IDC_RECTGRAD_PIC2, argb[1] & ~Color::AlphaMask);
			UpdateColorPicture(hwnd, IDC_RECTGRAD_PIC3, argb[2] & ~Color::AlphaMask);	
			UpdateColorPicture(hwnd, IDC_RECTGRAD_PIC4, argb[3] & ~Color::AlphaMask);
			break;

		case IDC_BRUSH_TRANSFORM:
			{
				TestTransform transDlg;
				
				transDlg.Initialize(&matrix);

				transDlg.ChangeSettings(hwnd);
			}
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestRadialGradBrush
//
//
//
//*******************************************************************

BOOL TestRadialGradBrush :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_RADGRAD_DLG),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));


	if (ok)
	{
		// initialize a new GDI+ brush with settings
		delete brush;

		Color centerColor(centerARGB);
		Color boundaryColor(boundaryARGB);

		RadialGradientBrush *radBrush 
			  = new RadialGradientBrush(rect,
										centerColor,
										boundaryColor,
										wrapValue[wrapMode]);
		
		radBrush->SetTransform(matrix);
		
		if (blend && blendCount)
			radBrush->SetBlend(blend, blendCount);
		
		brush = radBrush;

		return TRUE;
	}
	
	return FALSE;
};

VOID TestRadialGradBrush :: Initialize()
{
	delete matrix;
	matrix = new Matrix();

	rect.X = rect.Y = 0;
	rect.Width = rect.Height = 100;

	// !! need editing support for these...
	blendCount = 0;
	blend = NULL;

	wrapMode = 0;
	matrix->Reset();

	centerARGB = 0xFFFFFFFF;
	boundaryARGB = 0xFF000000;
	
	Color centerColor(centerARGB);
	Color boundaryColor(boundaryARGB);
	
	delete brush;

	RadialGradientBrush *radBrush =
			new RadialGradientBrush(rect,
									centerColor,
									boundaryColor,
									wrapValue[wrapMode]);

	radBrush->SetTransform(matrix);
	radBrush->SetBlend(blend, blendCount);

	brush = radBrush;
}

VOID TestRadialGradBrush::AddToFile(OutputFile* outfile, INT id)
{
	TCHAR brushStr[MAX_PATH];
	TCHAR matrixStr[MAX_PATH];
	TCHAR rectStr[MAX_PATH];
	TCHAR color1Str[MAX_PATH];
	TCHAR color2Str[MAX_PATH];
	TCHAR blendStr[MAX_PATH];

	if (id)
	{
		_stprintf(&brushStr[0], _T("brush%d"), id);
		_stprintf(&matrixStr[0], _T("matrix%d"), id);
		_stprintf(&rectStr[0], _T("rect%db"), id);
		_stprintf(&color1Str[0], _T("centerColor%db"), id);
		_stprintf(&color2Str[0], _T("boundaryColor%db"), id);
		_stprintf(&blendStr[0], _T("radialBlend%db"), id);
	}
	else
	{
		_tcscpy(&brushStr[0], _T("brush"));
		_tcscpy(&matrixStr[0], _T("matrix"));
		_tcscpy(&rectStr[0], _T("rectb"));
		_tcscpy(&color1Str[0], _T("centerColor"));
		_tcscpy(&color2Str[0], _T("boundaryColor"));
		_tcscpy(&blendStr[0], _T("radialBlend"));
	}

	outfile->ColorDeclaration(&color1Str[0], 
							  &centerARGB,
							  0);

	outfile->BlankLine();

	outfile->ColorDeclaration(&color2Str[0],
							  &boundaryARGB,
							  0);

	outfile->BlankLine();

	outfile->RectangleDeclaration(&rectStr[0],
								  rect);

	outfile->BlankLine();

	outfile->Declaration(_T("RadialGradientBrush"), 
						 &brushStr[0], 
						 _T("%s, %s, %s, %s"),
						 &rectStr[0],
						 &color1Str[0],
						 &color2Str[0],
						 wrapStr[wrapMode]);

	outfile->BlankLine();

	outfile->SetMatrixDeclaration(&brushStr[0], 
								  _T("SetTransform"), 
								  &matrixStr[0],
								  matrix);

	outfile->BlankLine();

	if (blend && blendCount)
	{
		outfile->BlankLine();

		outfile->SetBlendDeclaration(&brushStr[0],
									 _T("SetBlend"),
									 &blendStr[0], 
									 blend, 
									 blendCount);
	}
}

VOID TestRadialGradBrush :: InitDialog(HWND hwnd)
{
	SetDialogReal(hwnd, IDC_RADGRAD_X,		 rect.X);
	SetDialogReal(hwnd, IDC_RADGRAD_Y,		 rect.Y);
	SetDialogReal(hwnd, IDC_RADGRAD_WIDTH,   rect.Width);
	SetDialogReal(hwnd, IDC_RADGRAD_HEIGHT,  rect.Height);

	SetDialogLong(hwnd, IDC_RADGRAD_CENTERALPHA, centerARGB >> Color::AlphaShift);
	SetDialogLong(hwnd, IDC_RADGRAD_BOUNDARYALPHA, boundaryARGB >> Color::AlphaShift);
	
	SetDialogCombo(hwnd, IDC_BRUSH_WRAP, wrapList, numWrap, wrapMode);
}

BOOL TestRadialGradBrush :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	rect.X = GetDialogReal(hwnd, IDC_RADGRAD_X);
	rect.Y = GetDialogReal(hwnd, IDC_RADGRAD_Y);
	rect.Width = GetDialogReal(hwnd, IDC_RADGRAD_WIDTH);
	rect.Height = GetDialogReal(hwnd, IDC_RADGRAD_HEIGHT);

	centerARGB = (centerARGB & ~Color::AlphaMask)
				| (GetDialogLong(hwnd, IDC_RADGRAD_CENTERALPHA) 
					<< Color::AlphaShift);
	
	boundaryARGB = (boundaryARGB & ~Color::AlphaMask)
				| (GetDialogLong(hwnd, IDC_RADGRAD_BOUNDARYALPHA) 
					<< Color::AlphaShift);

	wrapMode = GetDialogCombo(hwnd, IDC_BRUSH_WRAP);

	return FALSE;
}

BOOL TestRadialGradBrush :: ProcessDialog(HWND hwnd, 
							UINT msg, 
							WPARAM wParam, 
							LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_RADGRAD_CENTER:
			UpdateRGBColor(hwnd, IDC_RADGRAD_PICC, centerARGB);
			break;

		case IDC_RADGRAD_BOUNDARY:
			UpdateRGBColor(hwnd, IDC_RADGRAD_PICB, boundaryARGB);
			break;

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_RADGRAD_PICC, centerARGB & ~Color::AlphaMask);
			UpdateColorPicture(hwnd, IDC_RADGRAD_PICB, boundaryARGB & ~Color::AlphaMask);
			break;
		
		case IDC_BRUSH_TRANSFORM:
			{
				TestTransform transDlg;
				
				transDlg.Initialize(&matrix);

				transDlg.ChangeSettings(hwnd);
			}
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestTriangleGradBrush
//
//
//
//*******************************************************************

BOOL TestTriangleGradBrush :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_TRIGRAD_DLG),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));


	if (ok)
	{
		// initialize a new GDI+ brush with settings
		delete brush;

		Color colors[3] =
		{
			Color(argb[0]),
			Color(argb[1]),
			Color(argb[2])
		};

		TriangleGradientBrush *triBrush 
			  = new TriangleGradientBrush(
						(Point*)&pts[0],
						(Color*)&colors[0],
						wrapValue[wrapMode]);

		triBrush->SetTransform(matrix);
		triBrush->SetBlend0(blend[0], count[0]);
		triBrush->SetBlend1(blend[1], count[1]);
		triBrush->SetBlend2(blend[2], count[2]);
		
		brush = triBrush;

		return TRUE;
	}
	
	return FALSE;
};

VOID TestTriangleGradBrush :: Initialize()
{
	delete matrix;
	matrix = new Matrix();

	pts[0].X = 10; pts[0].Y = 10;
	pts[1].X = 90; pts[1].Y = 10;
	pts[2].X = 50; pts[2].Y = 100;

	blend[0] = blend[1] = blend[2] = NULL;
	count[0] = count[1] = count[2] = 0;
		
	argb[0] = 0x80FF0000;
	argb[1] = 0x8000FF00;
	argb[2] = 0x800000FF;
	
	Color colors[3] = 
	{
		Color(argb[0]),
		Color(argb[1]),
		Color(argb[2])
	};

	wrapMode = 0;
	
	delete brush;

	TriangleGradientBrush *triBrush 
		  = new TriangleGradientBrush(
					(Point*)(&pts[0]),
					(Color*)(&colors[0]),
					wrapValue[wrapMode]);

	triBrush->SetTransform(matrix);
	triBrush->SetBlend0(blend[0], count[0]);
	triBrush->SetBlend1(blend[1], count[1]);
	triBrush->SetBlend2(blend[2], count[2]);
		
	brush = triBrush;
}

VOID TestTriangleGradBrush::AddToFile(OutputFile* outfile, INT id)
{
	INT pos;

	TCHAR brushStr[MAX_PATH];
	TCHAR matrixStr[MAX_PATH];
	TCHAR ptsStr[MAX_PATH];
	TCHAR colorsStr[MAX_PATH];
	TCHAR blendStr[3][MAX_PATH];

	if (id)
	{
		_stprintf(&brushStr[0], _T("brush%d"), id);
		_stprintf(&matrixStr[0], _T("matrix%db"), id);
		_stprintf(&ptsStr[0], _T("pts%db"), id);
		_stprintf(&colorsStr[0], _T("colors%db"), id);
		_stprintf(&blendStr[0][0], _T("blend%db01"), id);
		_stprintf(&blendStr[1][0], _T("blend%db12"), id);
		_stprintf(&blendStr[2][0], _T("blend%db20"), id);
	}
	else
	{
		_tcscpy(&brushStr[0], _T("brush"));
		_tcscpy(&brushStr[0], _T("matrixb"));
		_tcscpy(&ptsStr[0], _T("ptsb"));
		_tcscpy(&colorsStr[0], _T("colors"));
		_tcscpy(&blendStr[0][0], _T("blend01"));
		_tcscpy(&blendStr[1][0], _T("blend12"));
		_tcscpy(&blendStr[2][0], _T("blend20"));
	}

	outfile->PointDeclaration(&ptsStr[0],
							  &pts[0],
							  3);

	outfile->BlankLine();

	outfile->ColorDeclaration(&colorsStr[0], 
							  &argb[0],
							  3);

	outfile->BlankLine();

	outfile->Declaration(_T("TriangleGradientBrush"), 
						 &brushStr[0], 
						 _T("%s, %s, %s"),
						 outfile->RefArray(&ptsStr[0]),
						 outfile->RefArray(&colorsStr[0]),
						 wrapStr[wrapMode]);

	outfile->BlankLine();


	outfile->SetMatrixDeclaration(&brushStr[0], 
								  _T("SetTransform"), 
								  &matrixStr[0],
								  matrix);

	if (blend[0] && count[0])
	{
		outfile->BlankLine();
	
		outfile->SetBlendDeclaration(&brushStr[0],
									 _T("SetBlend01"),
									 &blendStr[0][0],
									 blend[0], 
									 count[0]);
	}

	if (blend[1] && count[1])
	{
		outfile->BlankLine();

		outfile->SetBlendDeclaration(&brushStr[0],
									 _T("SetBlend12"),
									 &blendStr[1][0],
									 blend[1], 
									 count[1]);
	}

	if (blend[2] && count[2])
	{
		outfile->BlankLine();

		outfile->SetBlendDeclaration(&brushStr[0],
									 _T("SetBlend20"),
									 &blendStr[2][0],
									 blend[2], 
									 count[2]);
	}
}

VOID TestTriangleGradBrush :: InitDialog(HWND hwnd)
{
	TCHAR tmp[MAX_PATH];

	_stprintf(tmp, "(%.f,%.f)", pts[0].X, pts[0].Y);
	SetDialogText(hwnd, IDC_TRIGRAD_PT1,	&tmp[0], FALSE);
	_stprintf(tmp, "(%.f,%.f)", pts[1].X, pts[1].Y);
	SetDialogText(hwnd, IDC_TRIGRAD_PT2,	&tmp[0], FALSE);
	_stprintf(tmp, "(%.f,%.f)", pts[2].X, pts[2].Y);
	SetDialogText(hwnd, IDC_TRIGRAD_PT3,	&tmp[0], FALSE);
	
	SetDialogCombo(hwnd, IDC_BRUSH_WRAP, wrapList, numWrap, wrapMode);
}

BOOL TestTriangleGradBrush :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	wrapMode = GetDialogCombo(hwnd, IDC_BRUSH_WRAP);

	return FALSE;
}

BOOL TestTriangleGradBrush :: ProcessDialog(HWND hwnd, 
							UINT msg, 
							WPARAM wParam, 
							LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_TRIGRAD_BUTTON:
		{
			EnableDialogControl(hwnd, IDC_TRIGRAD_BUTTON, FALSE);

			// create gradient edit shape
			TestTriangleGradShape *triGradShape
				= new TestTriangleGradShape();

			triGradShape->Initialize(&pts[0],
									 &argb[0],
									 (REAL**)&blend,
									 &count[0]);
			
			// create new draw object for window
			// and initialize it with this shape
			TestGradDraw *gradDraw = new TestGradDraw();
			gradDraw->Initialize(triGradShape);

			if (gradDraw->ChangeSettings(hwnd))
			{
				memcpy(&pts[0], 
					   triGradShape->GetPoints(),
					   sizeof(Point)*3);
				
				memcpy(&argb[0],
					   triGradShape->GetARGB(),
					   sizeof(ARGB)*3);

				INT newCount[3];

				memcpy(&newCount[0],
					   triGradShape->GetBlendCount(),
					   sizeof(INT)*3);

				REAL** newBlend = triGradShape->GetBlend();

				for (INT i = 0; i < 3; i++)
				{
					if (count[i] && blend[i])
					{
						count[i] = 0;
						free(blend[i]);
						blend[i] = NULL;
					}

					count[i] = newCount[i];
					blend[i] = (REAL*) malloc(sizeof(REAL)*count[i]);
					memcpy(blend[i], newBlend[i], sizeof(REAL)*count[i]);
				}

				// update points in dialog box
				InitDialog(hwnd);

				// update color pictures
				InvalidateRect(hwnd, NULL, TRUE);

			}  // ChangeSettings(hwnd);

			delete triGradShape;
			delete gradDraw;

			EnableDialogControl(hwnd, IDC_TRIGRAD_BUTTON, TRUE);
			EnableDialogControl(hwnd, IDC_OK, TRUE);
			EnableDialogControl(hwnd, IDC_CANCEL, TRUE);

			// update color pictures if necessary
			UpdateWindow(hwnd);
			InvalidateRect(hwnd, NULL, FALSE);
			break;
		}

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_TRIGRAD_PIC1, argb[0] & ~Color::AlphaMask);
			UpdateColorPicture(hwnd, IDC_TRIGRAD_PIC2, argb[1] & ~Color::AlphaMask);
			UpdateColorPicture(hwnd, IDC_TRIGRAD_PIC3, argb[2] & ~Color::AlphaMask);
			break;
		
		case IDC_BRUSH_TRANSFORM:
			{
				TestTransform transDlg;
				
				transDlg.Initialize(&matrix);

				transDlg.ChangeSettings(hwnd);
			}
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestPathGradBrush
//
//
//
//*******************************************************************

BOOL TestPathGradBrush :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_POLYGRAD_DLG),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));


	if (ok)
	{
		// initialize a new GDI+ brush with settings
		delete brush;

		PathGradientBrush *polyBrush
			  = new PathGradientBrush((Point*)&pts[1],
										 pts.GetCount()-1);

		polyBrush->SetTransform(matrix);
		polyBrush->SetWrapMode(wrapValue[wrapMode]);

//		polyBrush->SetSurroundBlend(surroundBlend, surroundCount);
		polyBrush->SetBlend(centerBlend, centerCount);

		polyBrush->SetCenterPoint(pts[0]);

		Color centerColor(argb[0]);
		polyBrush->SetCenterColor(argb[0]);

		for (INT pos = 1; pos < argb.GetCount(); pos++)
		{
			Color color(argb[pos]);
			polyBrush->SetSurroundColor(color, pos-1);
		}
		
		brush = polyBrush;

		return TRUE;
	}
	
	return FALSE;
};

VOID TestPathGradBrush :: Initialize()
{
	delete matrix;
	matrix = new Matrix();

	pts.Reset();

	pts.Add(Point(100,100));
	pts.Add(Point(100,50));
	pts.Add(Point(150,150));
	pts.Add(Point(50,150));

    surroundBlend = centerBlend = NULL;
	surroundCount = centerCount = 0;
	
	argb.Reset();

	argb.Add((ARGB)0x80000000);
    argb.Add((ARGB)0x80FF0000);
    argb.Add((ARGB)0x8000FF00);
    argb.Add((ARGB)0x800000FF);

	wrapMode = 0;

	// initialize a new GDI+ brush with settings
	delete brush;

	PathGradientBrush *polyBrush
		  = new PathGradientBrush((Point*)&pts[1],
										 pts.GetCount()-1);

	polyBrush->SetTransform(matrix);
	polyBrush->SetWrapMode(wrapValue[wrapMode]);

	polyBrush->SetCenterPoint(pts[0]);

	Color centerColor(argb[0]);
	polyBrush->SetCenterColor(argb[0]);

	for (INT pos = 1; pos < argb.GetCount(); pos++)
	{
		Color color(argb[pos]);
		polyBrush->SetSurroundColor(color, pos-1);
	}
		
	brush = polyBrush;
}

VOID TestPathGradBrush :: AddToFile(OutputFile* outfile, INT id)
{
	INT pos;

	TCHAR brushStr[MAX_PATH];
	TCHAR matrixStr[MAX_PATH];
	TCHAR ptsStr[MAX_PATH];
	TCHAR colorStr[MAX_PATH];
	TCHAR blendStr[MAX_PATH];

	if (id)
	{
		_stprintf(&brushStr[0], _T("brush%d"), id);
		_stprintf(&matrixStr[0], _T("matrix%d"), id);
		_stprintf(&ptsStr[0], _T("pts%db"), id);
		_stprintf(&colorStr[0], _T("centerColor%db"), id);
		_stprintf(&blendStr[0], _T("radialBlend%db01"), id);
	}
	else
	{
		_tcscpy(&brushStr[0], _T("brush"));
		_tcscpy(&matrixStr[0], _T("matrixb"));
		_tcscpy(&ptsStr[0], _T("ptsb"));
		_tcscpy(&colorStr[0], _T("centerColor"));
		_tcscpy(&blendStr[0], _T("radialBlend"));
	}

	outfile->PointDeclaration(&ptsStr[0],
							  &pts[1],
							  pts.GetCount()-1);

	outfile->BlankLine();

	outfile->Declaration(_T("PathGradientBrush"), 
						 &brushStr[0], 
						 _T("%s, %d, %s"),
						 outfile->RefArray(&ptsStr[0]),
						 pts.GetCount()-1,
						 wrapStr[wrapMode]);

	if (id)
	{
		_stprintf(&ptsStr[0], _T("centerpt%db"), id);
		_stprintf(&colorStr[0], _T("centerColor%db"), id);
	}
	else
	{
		_tcscpy(&ptsStr[0], _T("centerpt"));
		_stprintf(&colorStr[0], _T("centerColor"));
	}

	outfile->BlankLine();

	outfile->SetMatrixDeclaration(&brushStr[0], 
								  _T("SetTransform"), 
								  &matrixStr[0],
								  matrix);

	outfile->BlankLine();

	outfile->SetPointDeclaration(&brushStr[0],
								 _T("SetCenterPoint"),
								 &ptsStr[0],
								 &pts[0]);

	outfile->BlankLine();

	outfile->SetColorDeclaration(&brushStr[0],
								 _T("SetCenterColor"),
								 &colorStr[0], 
								 &argb[0]);

	if (centerBlend && centerCount)
	{
		outfile->BlankLine();
		
		outfile->SetBlendDeclaration(&brushStr[0],
									 _T("SetRadialBlend"),
									 &blendStr[0],
									 centerBlend,
									 centerCount);
	}

	// No surround blend since outer edge blend is fixed by
	// by radial blend

	for (pos = 1; pos < pts.GetCount()-1; pos++)
	{
		if (id)
			_stprintf(&colorStr[0], _T("color%db%d"), id, pos);
		else
			_stprintf(&colorStr[0], _T("color%d"), pos);

		outfile->BlankLine();

		outfile->ColorDeclaration(&colorStr[0],
								  &argb[pos]);

		outfile->ObjectCommand(&brushStr[0],
							   _T("SetSurroundColor"),
							   _T("%s, %d"),
							   &colorStr[0],
							   pos-1);
	}
}

VOID TestPathGradBrush :: InitDialog(HWND hwnd)
{
	TCHAR tmp[MAX_PATH];

	HWND hwndList = GetDlgItem(hwnd, IDC_POLYGRAD_POINTLIST);

	INT count = SendMessage(hwndList, LB_GETCOUNT, 0, 0);

	while (count)
	{
		// remove all items in list and repopulate
		count = SendMessage(hwndList, LB_DELETESTRING, 0, 0);
	}

	for (INT pos = 0; pos < pts.GetCount(); pos++)
	{
		if (!pos)
			_stprintf(tmp,"Center (%.f,%.f), Color=%08X",
					pts[0].X, pts[0].Y, argb[0]);
		else
			_stprintf(tmp,"Point (%.f,%.f), Color=%08X",
					pts[pos].X, pts[pos].Y, argb[pos]);
	
		SendMessage(hwndList, LB_ADDSTRING, 0, (WPARAM)tmp);
	}

	DeleteObject(hwndList);

	SetDialogCombo(hwnd, IDC_BRUSH_WRAP, wrapList, numWrap, wrapMode);
}

BOOL TestPathGradBrush :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	wrapMode = GetDialogCombo(hwnd, IDC_BRUSH_WRAP);

	return FALSE;
}

BOOL TestPathGradBrush :: ProcessDialog(HWND hwnd, 
							UINT msg, 
							WPARAM wParam, 
							LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_POLYGRAD_BUTTON:
		{
			EnableDialogControl(hwnd, IDC_POLYGRAD_BUTTON, FALSE);
			EnableDialogControl(hwnd, IDC_OK, FALSE);
			EnableDialogControl(hwnd, IDC_CANCEL, FALSE);
				
			// create gradient edit shape
			TestPathGradShape *polyGradShape
				= new TestPathGradShape();

			polyGradShape->Initialize(&pts,
									 &argb,
									 surroundBlend,
									 surroundCount,
									 centerBlend,
									 centerCount);
			
			// create new draw object for window
			// and initialize it with this shape
			TestGradDraw *gradDraw = new TestGradDraw();
			gradDraw->Initialize(polyGradShape);

			if (gradDraw->ChangeSettings(hwnd))
			{
				pts.Reset();
				argb.Reset();

				pts.AddMultiple(polyGradShape->GetPoints(),
								polyGradShape->GetCount());
				
				argb.AddMultiple(polyGradShape->GetARGB(),
								 polyGradShape->GetCount());

				if (surroundBlend)
					free(surroundBlend);

				if (centerBlend)
					free(centerBlend);

				surroundCount = polyGradShape->GetSurroundBlendCount();
				centerCount = polyGradShape->GetCenterBlendCount();

				if (surroundCount)
				{
					surroundBlend = (REAL*) malloc(sizeof(REAL)*surroundCount);
					memcpy(surroundBlend, polyGradShape->GetSurroundBlend(),
								sizeof(REAL)*surroundCount);
				}
				else
					surroundBlend = NULL;

				if (centerCount)
				{
					centerBlend = (REAL*) malloc(sizeof(REAL)*centerCount);
					memcpy(centerBlend, polyGradShape->GetCenterBlend(),
								sizeof(REAL)*centerCount);
				}
				else
					centerBlend = NULL;

				// update points in dialog box
				InitDialog(hwnd);

				// update color pictures
				InvalidateRect(hwnd, NULL, TRUE);

			}  // ChangeSettings(hwnd);

			delete polyGradShape;
			delete gradDraw;

			EnableDialogControl(hwnd, IDC_POLYGRAD_BUTTON, TRUE);
			EnableDialogControl(hwnd, IDC_OK, TRUE);
			EnableDialogControl(hwnd, IDC_CANCEL, TRUE);

			// update color pictures if necessary
			UpdateWindow(hwnd);
			InvalidateRect(hwnd, NULL, FALSE);
			break;
		}
		
		case IDC_BRUSH_TRANSFORM:
			{
				TestTransform transDlg;
				
				transDlg.Initialize(&matrix);

				transDlg.ChangeSettings(hwnd);
			}
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestHatchBrush
//
//
//
//*******************************************************************

BOOL TestHatchBrush :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_HATCH_DLG),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));


	if (ok)
	{
		// initialize a new GDI+ brush with settings
		delete brush;
	
		Color foreColor(foreArgb);
		Color backColor(backArgb);
		hatch = 0;

		brush = new HatchBrush(hatchValue[hatch], 
							   foreColor, 
							   backColor);

		return TRUE;
	}
	
	return FALSE;
};

VOID TestHatchBrush :: Initialize()
{
	foreArgb = 0xFF000000;
	backArgb = 0xFFFFFFFF;

	delete brush;
	
	Color foreColor(foreArgb);
	Color backColor(backArgb);
	hatch = 0;

	brush = new HatchBrush(hatchValue[hatch],
						   foreColor, 
						   backColor);
}

VOID TestHatchBrush::AddToFile(OutputFile* outfile, INT id)
{
	TCHAR brushStr[MAX_PATH];
	TCHAR color1Str[MAX_PATH];
	TCHAR color2Str[MAX_PATH];

	if (id)
	{
		_stprintf(&brushStr[0], _T("brush%d"), id);
		_stprintf(&color1Str[0], _T("foreColor%db"), id);
		_stprintf(&color2Str[0], _T("backColor%db"), id);
	}
	else
	{
		_tcscpy(&brushStr[0], _T("brush"));
		_tcscpy(&color1Str[0], _T("foreColor"));
		_tcscpy(&color2Str[0], _T("backColor"));
	}

	outfile->ColorDeclaration(&color1Str[0], 
							  &foreArgb);

	outfile->BlankLine();

	outfile->ColorDeclaration(&color2Str[0],
							  &backArgb);

	outfile->BlankLine();

	outfile->Declaration(_T("HatchBrush"), 
						 &brushStr[0], 
						 _T("%s, %s, %s"),
						 &color1Str[0],
						 &color2Str[0],
						 hatchStr[hatch]);
}

VOID TestHatchBrush :: InitDialog(HWND hwnd)
{
	SetDialogLong(hwnd, IDC_HATCH_FOREALPHA, 
		foreArgb >> Color::AlphaShift);

	SetDialogLong(hwnd, IDC_HATCH_BACKALPHA,
		backArgb >> Color::AlphaShift);

	SetDialogCombo(hwnd, IDC_HATCH_STYLE, hatchList, numHatch, hatch);
}

BOOL TestHatchBrush :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	foreArgb = (foreArgb & ~Color::AlphaMask) |
		      (GetDialogLong(hwnd, IDC_HATCH_FOREALPHA) 
				  << Color::AlphaShift);

	backArgb = (backArgb & ~Color::AlphaMask) |
			  (GetDialogLong(hwnd, IDC_HATCH_BACKALPHA)
				  << Color::AlphaShift);

	hatch = GetDialogCombo(hwnd, IDC_HATCH_STYLE);
	
	if (warning)
		InitDialog(hwnd);

	return warning;
}

BOOL TestHatchBrush :: ProcessDialog(HWND hwnd, 
							UINT msg, 
							WPARAM wParam, 
							LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_HATCH_FORECOLOR:
			UpdateRGBColor(hwnd, IDC_HATCH_FOREPIC, foreArgb);
			break;

		case IDC_HATCH_BACKCOLOR:
			UpdateRGBColor(hwnd, IDC_HATCH_BACKPIC, backArgb);
			break;

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_HATCH_FOREPIC, foreArgb);
			UpdateColorPicture(hwnd, IDC_HATCH_BACKPIC, backArgb);
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdipdraw.h ===
#ifndef GDIPDRAW_H
#define GDIPDRAW_H

// drawing context information 

class TestDrawInterface
{
public:
	// manipulate the current shape
	virtual VOID AddPoint(HWND hwnd, Point pt) = 0;
	virtual BOOL DoneShape(HWND hwnd) = 0;
	virtual BOOL EndPoint(HWND hwnd, Point pt) = 0;
	virtual BOOL RemovePoint(HWND hwnd) = 0;

	// draw all shapes
	virtual VOID Draw(HWND hwnd) = 0;
	virtual VOID SetClipRegion(HWND hwnd) = 0;

	// move around a control point
	virtual VOID RememberPoint(Point pt) = 0;
	virtual VOID MoveControlPoint(Point pt) = 0;
	
	// status window
	virtual VOID UpdateStatus(HWND hwnd = NULL) = 0;
	virtual VOID SaveAsFile(HWND hwnd) = 0;
};

class TestDraw : public TestDrawInterface
{
public:
	TestDraw() : curBrush(NULL), 
				 curPen(NULL), 
				 curShape(NULL),
				 clipShapeRegion(NULL),
				 shapeType(LineType),
				 redrawAll(FALSE),
				 keepControlPoints(FALSE),
				 antiAlias(FALSE),
				 useClip(FALSE)
	{
		// !! initialize in sync with menu choices
		curBrush = new TestSolidBrush();
		curBrush->Initialize();

		curPen = new TestPen();
		curPen->Initialize();

		clipShapeRegion = new TestShapeRegion();

		worldMatrix = new Matrix();
		hwndStatus = NULL;

		// !! infinite default may change??
		clipRegion = new Region();
		clipRegion->SetInfinite();
	}

	~TestDraw()
	{
		delete curBrush;
		delete curPen;
		delete curShape;
		delete clipShapeRegion;
		delete worldMatrix;
		delete clipRegion;
	}

	// manipulate the current shape
	virtual VOID AddPoint(HWND hwnd, Point pt);
	virtual BOOL DoneShape(HWND hwnd);
	virtual BOOL EndPoint(HWND hwnd, Point pt);
	virtual BOOL RemovePoint(HWND hwnd);

	// draw all shapes
	virtual VOID Draw(HWND hwnd);
	virtual VOID SetClipRegion(HWND hwnd);

	// move around a control point
	virtual VOID RememberPoint(Point pt);
	virtual VOID MoveControlPoint(Point pt);

	// status window
	virtual VOID UpdateStatus(HWND hwnd = NULL);
	virtual VOID SaveAsFile(HWND hwnd);
	
	VOID ChangeBrush(HWND hwnd, INT type);
	VOID ChangePen(HWND hwnd);
	VOID ChangeShape(HWND hwnd, INT type);

	INT GetBrushType()
	{
		if (!curBrush)
			return SolidColorBrush;
		else if (curShape && curShape->GetCount() > 0)
			return curShape->GetBrush()->GetType();
		else
			return curBrush->GetType();
	}

	INT GetPenType()
	{
		return 0;
	}

	INT GetShapeType()
	{
		if (curShape && curShape->GetCount() > 0)
			return curShape->GetType();
		else
			return shapeType;
	}

	Matrix* GetWorldMatrix()
	{
		return worldMatrix;
	}

	VOID SetWorldMatrix(Matrix* newMatrix)
	{
		delete worldMatrix;
		worldMatrix = newMatrix->Clone();
	}

	// make public to avoid get/set methods
public:
	BOOL redrawAll;
	BOOL keepControlPoints;
	BOOL antiAlias;
	BOOL useClip;

private:
	TestBrush *curBrush;
	TestPen *curPen;

	INT shapeType;
	TestShape *curShape;
	ShapeStack shapeStack;

	Matrix *worldMatrix;
	Region *clipRegion;

	TestShapeRegion *clipShapeRegion;

	Point remPoint;

	HWND hwndStatus;
};

class TestGradDraw : public TestDrawInterface,
					 public TestConfigureInterface
{
public:
	TestGradDraw() : gradShape(NULL) {};

	~TestGradDraw()
	{
		// caller's responsible to delete gradShape
	}

	// manipulate the current shape
	virtual VOID AddPoint(HWND hwnd, Point pt);
	virtual BOOL DoneShape(HWND hwnd);
	virtual BOOL EndPoint(HWND hwnd, Point pt);
	virtual BOOL RemovePoint(HWND hwnd);

	// draw all shapes
	virtual VOID Draw(HWND hwnd);
	virtual VOID SetClipRegion(HWND hwnd);

	// move around a control point
	virtual VOID RememberPoint(Point pt);
	virtual VOID MoveControlPoint(Point pt);

	// status window
	virtual VOID UpdateStatus(HWND hwnd = NULL);
	virtual VOID SaveAsFile(HWND hwnd);

	// configuration management interface
	// initializes/creates the test draw window
	BOOL ChangeSettings(HWND hwnd);
	VOID Initialize();
	VOID Initialize(TestGradShape *gradShape);

	/////////////////////////////////////////////////////////////////
	// Optional supported menu items

	virtual VOID Reset(HWND hwnd);
	virtual VOID Instructions(HWND hwnd);

private:
	TestGradShape *gradShape;

	Point remPoint;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdipclip.cpp ===
#include "gdiptest.h"

//*******************************************************************
//
// TestShapeRegion
//
//
//
//*******************************************************************

BOOL TestShapeRegion :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_SHAPE_DLG),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));


	if (ok)
	{
		// discard the saved original tree
		delete origTree;
		origTree = NULL;

		return TRUE;
	}
	else
	{
		// restore original clip region tree

		delete clipTree;
		clipTree = origTree;
		origTree = NULL;
		return FALSE;
	}
}

VOID TestShapeRegion :: Initialize()
{
	shapeStack = NULL;
}

VOID TestShapeRegion :: Initialize(ShapeStack *stack, 
								   TestShape* current,
								   BOOL useClip)
{
	origUseClip = useClip;

	origStack = stack;

	shapeStack->Reset();

	shapeStack->Push(current);
	
	for (INT pos = stack->GetCount()-1; pos>=0; pos--)
	{
		TestShape* shape = stack->GetPosition(pos);

		shapeStack->Push(shape);
		
		shape->dwFlags = shape->GetDisabled() 
									? ShapeDisabled : 0;
	}

	origTree = clipTree->Clone();	
}

VOID TestShapeRegion :: AddClipNode(HWND hwnd, NodeType newType)
{
	TestShape* curShape = NULL;

	TVITEMEX itemex;
	HWND hwndList;
	HWND hwndTree;

	if (newType == DataNode)
	{
		hwndList = GetDlgItem(hwnd, IDC_SHAPE_LIST);
		INT curIndex = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
		DeleteObject(hwndList);
	
		if (curIndex == LB_ERR)
		{
			DeleteObject(hwndList);
			WarningBox(_T("Failed to find shape in list."));
			return;
		}
		else if (curIndex == 0)
		{
			DeleteObject(hwndList);
			WarningBox(_T("Can't add current (incomplete) shape in list."));
			return;
		}
	
		curShape = shapeStack->GetPosition(curIndex);
	}
	
	hwndTree = GetDlgItem(hwnd, IDC_CLIP_TREE);

	HTREEITEM curSelect = TreeView_GetSelection(hwndTree);

	if (!curSelect)
	{
		DeleteObject(hwndTree);
		WarningBox(_T("No clip item selected."));
		return;
	}

	itemex.hItem = (HTREEITEM) curSelect;  
	itemex.mask = TVIF_PARAM;

	if (TreeView_GetItem(hwndTree, &itemex))
	{
		ClipTree* curNode = (ClipTree*) itemex.lParam;

		// we found current item
		ClipTree* newNode = new ClipTree(newType, curShape);
		if (newType == DataNode)
		{

			// if item is 'AND', 'OR' ,'XOR' then add as child
			if (curNode->type != DataNode)
			{
				itemex.cChildren = 1;
				itemex.mask = TVIF_CHILDREN;
				TreeView_SetItem(hwndTree, &itemex);

				curNode->AddChild(newNode);
			}
			else
			{
				// add as sibling to current node
				curNode->AddSibling(newNode);
			}

			// since node has no right siblings or children,
			// this should add in relation to node's parent and
			// left sibling.

			newNode->AddToTreeView(hwndTree);
		}
		else
		{
			// we are adding an AND, XOR, OR node.
			if (curNode->type != DataNode)
			{
				// simply change the current node's value
				curNode->type = newType;
				if (curNode->nodeName)
					free(curNode->nodeName);
				
				curNode->nodeName = ClipTree::GetNodeName(curNode->type,
														  curNode->notNode,
														  curNode->data);

				itemex.pszText = curNode->nodeName;
				itemex.cchTextMax = _tcslen(itemex.pszText)+1;
				itemex.mask = TVIF_TEXT;
				TreeView_SetItem(hwndTree, &itemex);

				delete newNode;
				newNode = NULL;
			}
			else
			{
				// adding an operand type to non-operand node
				// replace current node with ourselves and add
				// them as parent

				curNode->AddAsParent(newNode);

				// delete old data item
				TreeView_DeleteItem(hwndTree, curNode->GetHTREEITEM());
				
				// add new operand node
				newNode->AddToTreeView(hwndTree);
				
				// recreate data item subtree under operand node
				curNode->CreateTreeView(hwndTree);

				clipTree = newNode->GetRoot();

				// fool select below...
				newNode = curNode;
			}
		}

		if (newNode)
			TreeView_SelectItem(hwndTree, newNode->GetHTREEITEM());
	}
	else
   		WarningBox(_T("Failed to find selected tree node."));

	DeleteObject(hwndTree);
}

VOID TestShapeRegion :: RemoveClipNode(HWND hwnd)
{
	HWND hwndTree = GetDlgItem(hwnd, IDC_CLIP_TREE);

	HTREEITEM curSelect = TreeView_GetSelection(hwndTree);

	if (!curSelect)
	{
		DeleteObject(hwndTree);
		WarningBox(_T("No clip node selected."));
		return;
	}

	TVITEMEX itemex;
	itemex.hItem = (HTREEITEM) curSelect;  
	itemex.mask = TVIF_PARAM;

	if (TreeView_GetItem(hwndTree, &itemex))
	{
		// we found current item
		ClipTree* curNode = (ClipTree*) itemex.lParam;

		if (curSelect == clipTree->GetHTREEITEM())
		{
			DeleteObject(hwndTree);
			WarningBox(_T("Can't delete root of tree."));
			return;
		}

		ClipTree* nextFocusNode;

		if (curNode->prevSibling)
			nextFocusNode = curNode->GetPrevSibling();
		else if (curNode->nextSibling)
			nextFocusNode = curNode->GetNextSibling();
		else
			nextFocusNode = curNode->GetParent();

		if (curNode->HasChildren())
		{
			if (MessageBox(hwnd, _T("Remove All Children Regions?"), _T(""), MB_YESNO) == IDYES)
			{
				TreeView_DeleteItem(hwndTree, curNode->GetHTREEITEM());

				// delete all children
				delete curNode;
			}
			else
			{
				ClipTree* parent = curNode->GetParent();

				nextFocusNode = curNode->GetFirstChild();

				// merge children with parent node
				curNode->MoveChildrenToParent();

				delete curNode;

				// delete parent's subtree, then add it back
				TreeView_DeleteItem(hwndTree, parent->GetHTREEITEM());

				// recreate tree view based on new hierarchy
				parent->CreateTreeView(hwndTree);

				clipTree = parent->GetRoot();
			}
		}
		else
		{
			// no children, just remove this single node
			TreeView_DeleteItem(hwndTree, curNode->GetHTREEITEM());

			delete curNode;
		}

		if (nextFocusNode)
			TreeView_SelectItem(hwndTree, nextFocusNode->GetHTREEITEM());
	}
	else
		WarningBox(_T("Failed to find selected tree."));

	DeleteObject(hwndTree);
}

VOID TestShapeRegion :: ToggleNotNode(HWND hwnd)
{
	HWND hwndTree = GetDlgItem(hwnd, IDC_CLIP_TREE);

	HTREEITEM curSelect = TreeView_GetSelection(hwndTree);

	if (!curSelect)
	{
		DeleteObject(hwndTree);
		WarningBox(_T("No clip item selected."));
		return;
	}

	TVITEMEX itemex;
	itemex.hItem = (HTREEITEM) curSelect;  
	itemex.mask = TVIF_PARAM;

	if (TreeView_GetItem(hwndTree, &itemex))
	{
		// we found current item
		ClipTree* curNode = (ClipTree*) itemex.lParam;

		curNode->notNode = !curNode->notNode;

		free(curNode->nodeName);

		itemex.pszText = curNode->nodeName = 
							ClipTree::GetNodeName(curNode->type,
												  curNode->notNode,
												  curNode->data);
		itemex.mask = TVIF_HANDLE | TVIF_TEXT;
		TreeView_SetItem(hwndTree, &itemex);
	}

	DeleteObject(hwndTree);
}

VOID TestShapeRegion :: ShiftCurrentShape(HWND hwnd, INT dir)
{
	HWND hwndList = GetDlgItem(hwnd, IDC_SHAPE_LIST);

	INT curSel = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
	INT maxList = SendMessage(hwndList, LB_GETCOUNT, 0, 0);

	if (curSel == LB_ERR)
	{
		WarningBox(_T("No shape selected."));
		DeleteObject(hwndList);
		return;
	}
	else if (dir<0 && curSel <= 1)
	{
		WarningBox(_T("Can't move up!"));
		DeleteObject(hwndList);
		return;
	}
	else if (dir>0 && (curSel == maxList-1 || curSel == 0))
	{
		WarningBox(_T("Can't move down!"));
		DeleteObject(hwndList);
		return;
	}

	// swap shape items to shift up or down

	TestShape** shapeList = shapeStack->GetDataBuffer();
	TestShape* swapTemp = NULL;

	swapTemp = shapeList[curSel+dir];
	shapeList[curSel+dir] = shapeList[curSel];
	shapeList[curSel] = swapTemp;

	SendMessage(hwndList, LB_DELETESTRING, (WPARAM) curSel+dir, 0);

	SendMessage(hwndList, LB_INSERTSTRING, curSel,
		(LPARAM) shapeList[curSel]->GetShapeName());

	DeleteObject(hwndList);
}

VOID TestShapeRegion :: ToggleDisableShape(HWND hwnd)
{
	HWND hwndList = GetDlgItem(hwnd, IDC_SHAPE_LIST);

	INT curSel = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
	
	if (curSel == LB_ERR)
	{
		WarningBox(_T("No shape selected."));
		DeleteObject(hwndList);
		return;
	}

	TestShape* shape = shapeStack->GetPosition(curSel);

	// toggle disable state of shape
	shape->dwFlags ^= ShapeDisabled;

//	SetDisabled(!shape->GetDisabled());

	// name may change based on disabled status
	SendMessage(hwndList, LB_DELETESTRING, (WPARAM) curSel, 0);

	SendMessage(hwndList, LB_INSERTSTRING, (WPARAM) curSel,
								(LPARAM) shape->GetShapeName());
	
	SendMessage(hwndList, LB_SETCURSEL, (WPARAM) curSel, 0);

	DeleteObject(hwndList);
}

VOID TestShapeRegion :: UpdateShapePicture(HWND hwnd)
{
	HWND hwndShape;
	HDC hdcPic;
	HWND hwndFrame;
	HDC hdcFrame;
	RECT rectDst;
	SIZE size;

	INT curSel;

	hwndShape = GetDlgItem(hwnd, IDC_SHAPE_LIST);
	
	curSel = SendMessage(hwndShape, LB_GETCURSEL, 0, 0);

	hwndFrame = GetDlgItem(hwnd, IDC_SHAPE_PIC);
	GetClientRect(hwndFrame, &rectDst);
	hdcFrame = GetDC(hwndFrame);

	if (curSel == LB_ERR || curSel <= 0)
	{
badpic:
		// white GDI brush
		HBRUSH hbr = CreateSolidBrush(0x00FFFFFF);

		FillRect(hdcFrame, &rectDst, hbr);

		DeleteObject(hbr);
		DeleteObject(hwndFrame);
		DeleteObject(hdcFrame);
		DeleteObject(hwndShape);
		return;
	}

	hdcPic = shapeStack->GetPosition(curSel)->CreatePictureDC(hwnd, &rectDst);
	
	if (!hdcPic)
		goto badpic;
	
	// blit shape picture into the given frame
	// NOTE: should be same size
	BitBlt(hdcFrame, 
		   rectDst.left,
		   rectDst.top,
		   rectDst.right - rectDst.left,
		   rectDst.bottom - rectDst.top,
		   hdcPic,
		   0,
		   0,
		   SRCCOPY);

	ReleaseDC(hwndFrame, hdcFrame);
	DeleteObject(hwndFrame);
	DeleteObject(hwndShape);	
}

VOID TestShapeRegion :: CleanUpPictures(HWND hwnd)
{
	HWND hwndShape;
	HDC hdcPic;
	INT count;

	// !! This code is obsolete,
	//    it should only be used if we wish to recreate the pictures on
	//    each iteration

/*
	hwndShape = GetDlgItem(hwnd, IDC_SHAPE_LIST);

	count = SendMessage(hwndShape, LB_GETCOUNT, 0, 0);

	// clean up picture hwnd for each picture...
	for (INT pos = 0; pos < count; pos++)
	{
		hdcPic = (HDC) SendMessage(hwndShape, LB_GETITEMDATA, (WPARAM)pos, 0);
		if (hdcPic)
			DeleteDC(hdcPic);
	}

	DeleteObject(hwndShape);
*/
}

VOID TestShapeRegion :: InitDialog(HWND hwnd)
{
	HWND hwndTV;
	HWND hwndShape;

	RECT frameRect;
	HWND hwndFrame;

	hwndFrame = GetDlgItem(hwnd, IDC_SHAPE_PIC);
	GetWindowRect(hwndFrame, &frameRect);
	DeleteObject(hwndFrame);

	// display list of shapes
	hwndShape = GetDlgItem(hwnd, IDC_SHAPE_LIST);
	for (INT pos = 0; pos < shapeStack->GetCount(); pos++)
	{
		TestShape* shape = shapeStack->GetPosition(pos);

		SendMessage(hwndShape, LB_ADDSTRING, 0, (LPARAM)shape->GetShapeName());
	}
	DeleteObject(hwndShape);

	// add root of clip region tree to Tree View control
	// for display/editing

	hwndTV = GetDlgItem(hwnd, IDC_CLIP_TREE);
	clipTree = clipTree->GetRoot();

	HTREEITEM topTree = clipTree->CreateTreeView(hwndTV);

	// select root of tree
	TreeView_SelectItem(hwndTV, topTree);

	// expand entire tree
	TreeView_Expand(hwndTV, topTree, TVM_EXPAND);

	DeleteObject(hwndTV);

	SetDialogCheck(hwnd, IDC_CLIP_BOOL, origUseClip);
}

BOOL TestShapeRegion :: SaveValues(HWND hwnd)
{
	origUseClip = GetDialogCheck(hwnd, IDC_CLIP_BOOL);
	
	origStack->Reset();

	for (INT pos = shapeStack->GetCount()-1; pos >= 1; pos--)
	{
		TestShape* shape = shapeStack->GetPosition(pos);

		origStack->Push(shape);
		
		shape->SetDisabled(shape->dwFlags & ShapeDisabled);
	}
	
	return FALSE;
}

BOOL TestShapeRegion :: ProcessDialog(HWND hwnd, 
									  UINT msg, 
									  WPARAM wParam, 
									  LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
			{
				CleanUpPictures(hwnd);
				::EndDialog(hwnd, TRUE);
			}
			break;

		case IDC_SHAPE_UP:
			ShiftCurrentShape(hwnd, -1);
			break;

		case IDC_SHAPE_DOWN:
			ShiftCurrentShape(hwnd, +1);
			break;

		case IDC_SHAPE_DISABLE:
			ToggleDisableShape(hwnd);
			break;
		
		case IDC_SHAPE_PEN:
		case IDC_SHAPE_BRUSH:
			break;

		case IDC_CLIP_ADD:
			AddClipNode(hwnd);
			break;

		case IDC_CLIP_REMOVE:
			RemoveClipNode(hwnd);
			break;

		case IDC_CLIP_AND:
			AddClipNode(hwnd, AndNode);
			break;

		case IDC_CLIP_OR:
			AddClipNode(hwnd, OrNode);
			break;

		case IDC_CLIP_XOR:
			AddClipNode(hwnd, XorNode);
			break;

		case IDC_CLIP_NOT:
			ToggleNotNode(hwnd);
			break;

		case IDC_SHAPE_LIST:
			if (HIWORD(wParam) == LBN_SELCHANGE)
				UpdateShapePicture(hwnd);
			break;

		case IDC_REFRESH_PIC:
			UpdateShapePicture(hwnd);
			break;

		case IDC_CANCEL:
			CleanUpPictures(hwnd);
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

Region* TestShapeRegion :: GetClipRegion()
{
	// caller must free
	return clipTree->GetRegion();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdipoutput.cpp ===
#include "gdiptest.h"

//*******************************************************************
//
// OutputFile
//
//
//
//*******************************************************************

OutputFile* OutputFile :: CreateOutputFile(LPTSTR filename)
{
	// convert to upper case & verify file extension
	TCHAR tmpStr[MAX_PATH];
	_tcscpy(&tmpStr[0], filename);
	_tcsupr(&tmpStr[0]);
		
	LPTSTR ext = &tmpStr[0] + _tcslen(&tmpStr[0]) - 3;
	INT formatType = -1;

	FILE* outfile = _tfopen(filename, _T("w"));

	if (!outfile)
	{
		WarningBox(_T("Can't create the output file."));
		return NULL;
	}

	if (!_tcscmp(ext, _T("CPP")) || 
		!_tcscmp(ext, _T("C")) ||
		!_tcscmp(ext, _T("CXX")))
		return new CPPOutputFile(outfile);
	else if (!_tcscmp(ext, _T("JAVA")))
		return new JavaOutputFile(outfile);
	else if (!_tcscmp(ext, _T("VML")))
		return new VMLOutputFile(outfile);
	else
	{
		WarningBox(_T("Unrecognized file type (.cpp, .c, .cxx, .Java, .vml)"));
		return NULL;
	}
}

//*******************************************************************
//
// CPPOutputFile
//
//
//
//*******************************************************************

VOID CPPOutputFile :: GraphicsProcedure()
{
	_ftprintf(outfile, _T("VOID DoGraphicsTest(HWND hWnd)\n"));
}

VOID CPPOutputFile :: GraphicsDeclaration()
{
	_ftprintf(outfile, _T("%*sGraphics g(hWnd);\n"),
					   4, 
					   _T(""));
}

VOID CPPOutputFile :: PointDeclaration(LPCTSTR pointName, Point* pts, INT count)
{
	if (count < 0)
		_ftprintf(outfile, 
				  _T("%sPoint %s(%e, %e);\n"),
				  tabStr, 
				  pointName, 
				  pts->X, 
				  pts->Y);
	else
	{
		_ftprintf(outfile,
				  _T("%sPoint %s[%d];\n"),
				  tabStr, 
				  pointName, 
				  count);
		for (INT pos=0; pos<count; pos++, pts++)
			_ftprintf(outfile,
					  _T("%s%s[%d].X=%e; %s[%d].Y=%e;\n"),
					  tabStr, pointName, pos, pts->X, pointName, pos, pts->Y);
	}
}

VOID CPPOutputFile :: ColorDeclaration(LPCTSTR colorName, ARGB* argb, INT count)
{
	if (count < 0)
		_ftprintf(outfile, 
				  _T("%sColor %s(0x%08X);\n"),
				  tabStr, 
				  colorName, 
				  *argb);
	else
	{
		_ftprintf(outfile,
				  _T("%sColor %s[%d];\n"),
				  tabStr, 
				  colorName, 
				  count);
		for (INT pos=0; pos<count; pos++, argb++)
			_ftprintf(outfile,
					  _T("%s%s[%d] = Color(0x%08X);\n"),
					  tabStr, 
					  colorName, 
					  pos, 
					  *argb);
	}
}

VOID CPPOutputFile :: RectangleDeclaration(LPCTSTR rectName, ERectangle& rect)
{
	_ftprintf(outfile, 
			  _T("%sERectangle %s(%e, %e, \n"
			     "%s%*s%e, %e);\n"),
			  tabStr, 
			  rectName, 
			  rect.X, 
			  rect.Y,
			  tabStr,
			  12 + _tcslen(rectName),
			  _T(""),
			  rect.Width, 
			  rect.Height);
}

VOID CPPOutputFile :: Declaration(LPCTSTR type,
					     LPCTSTR object,
					     LPCTSTR argList,
						 ...) 
{
	TCHAR declArgs[MAX_PATH];
	va_list args;
	
	va_start (args, argList);
	_vstprintf(&declArgs[0], argList, args);
	va_end (args);

	_ftprintf(outfile,
			  _T("%s%s %s(%s);\n"),
			  tabStr,
			  type,
			  object,
			  declArgs);
}

// set matrix, do nothing if identity matrix
VOID CPPOutputFile :: SetPointDeclaration(LPCTSTR object,
								 LPCTSTR command,
								 LPCTSTR varName,
								 Point* pts,
								 INT count,
								 BOOL ref) 
{
	if (count < 0)
	{
		_ftprintf(outfile, 
				  _T("%sPoint %s(%e, %e);\n"),
				  tabStr, 
				  varName, 
				  pts->X, 
				  pts->Y);
		_ftprintf(outfile,
				  _T("%s%s.%s(%s);\n"),
				  tabStr,
				  object,
				  command,
				  ref ? Ref(_T(varName)) : varName);
	}
	else
	{
		_ftprintf(outfile,
				  _T("%sPoint %s[%d];\n"),
				  tabStr, 
				  varName, 
				  count);
		for (INT pos=0; pos<count; pos++, pts++)
			_ftprintf(outfile,
					  _T("%s%s[%d].X=%e; %s[%d].Y=%e;\n"),
					  tabStr, 
					  varName, 
					  pos, 
					  pts->X, 
					  varName, 
					  pos, 
					  pts->Y);
		_ftprintf(outfile,
				  _T("%s%s.%s(%s);\n"),
				  tabStr,
				  object,
				  command,
				  RefArray(varName));	
	}
}
	
VOID CPPOutputFile :: SetColorDeclaration(LPCTSTR object,
								 LPCTSTR command,
								 LPCTSTR varName,
								 ARGB* colors,
								 INT count,
								 BOOL ref) 
{
	if (count < 0)
	{
		_ftprintf(outfile, 
				  _T("%sColor %s(0x%08X);\n"),
				  tabStr, 
				  varName, 
				  *colors);
		_ftprintf(outfile,
				  _T("%s%s.%s(%s%s);\n"),
				  tabStr,
				  object,
				  command,
				  ref ? _T("&") : _T(""),
				  varName);	
	}
	else
	{
		_ftprintf(outfile,
				  _T("%sColor %s[%d];\n"),
				  tabStr, 
				  varName, 
				  count);
		for (INT pos=0; pos<count; pos++, colors++)
			_ftprintf(outfile,
					  _T("%s%s[%d] = Color(0x%08X);\n"),
					  tabStr, 
					  varName, 
					  pos, 
					  *colors);
		_ftprintf(outfile,
				  _T("%s%s.%s(&%s[0]);\n"),
				  tabStr,
				  object,
				  command,
				  varName);	
	}
}

VOID CPPOutputFile :: SetMatrixDeclaration(LPCTSTR object,
								  LPCTSTR command,
								  LPCTSTR varName,
								  Matrix* matrix) 
{
	REAL m[6];

	if (matrix->IsIdentity())
	{
		_ftprintf(outfile,
				  _T("%s// identity matrix transform\n"),
				  tabStr);
		return;
	}
	
	matrix->GetElements(&m[0]);

	_ftprintf(outfile,
			  _T("%sMatrix %s(%e, %e, %e, \n"
			     "%s%*s%e, %e, %e);\n"),
			  tabStr,
			  varName,
			  m[0],
			  m[1],
			  m[2],
			  tabStr,
			  8 + _tcslen(varName),
			  _T(""),
			  m[3],
			  m[4],
			  m[5]);
	_ftprintf(outfile,
			  _T("%s%s.%s(&%s);\n"),
			  tabStr,
			  object,
			  command,
			  varName);
}

VOID CPPOutputFile :: SetBlendDeclaration(LPCTSTR object,
								 LPCTSTR command,
								 LPCTSTR varName,
								 REAL* blend,
								 INT count)
{
	_ftprintf(outfile,
			  _T("%sREAL %s[%d];\n"),
			  tabStr, 
			  varName, 
			  count);
	for (INT pos=0; pos<count; pos++, blend++)
		_ftprintf(outfile,
				  _T("%s%s[%d] = %e;\n"),
				  tabStr, 
				  varName, 
				  pos, 
				  *blend);
	_ftprintf(outfile,
			  _T("%s%s.%s(&%s[0]);\n"),
			  tabStr,
			  object,
			  command,
			  varName);	
}

VOID CPPOutputFile :: GraphicsCommand(LPCTSTR command,
			 				 LPCTSTR argList,
							 ...) 
{
	TCHAR declArgs[MAX_PATH];
	va_list args;
	
	va_start (args, argList);
	_vstprintf(&declArgs[0], argList, args);
	va_end (args);

	_ftprintf(outfile,
			  _T("%sg.%s(%s);\n"),
			  tabStr,
			  command,
			  declArgs);
}

VOID CPPOutputFile :: ObjectCommand(LPCTSTR object,
						   LPCTSTR command,
						   LPCTSTR argList,
						   ...) 
{
	TCHAR declArgs[MAX_PATH];
	va_list args;
	
	va_start (args, argList);
	_vstprintf(&declArgs[0], argList, args);
	va_end (args);

	_ftprintf(outfile,
			  _T("%s%s.%s(%s);\n"),
			  tabStr,
			  object,
			  command,
			  declArgs);
}

VOID CPPOutputFile :: BeginIndent()
{
	TCHAR tmp[MAX_PATH];

	_ftprintf(outfile, _T("%s{\n"), tabStr);
	tabs++;
	_stprintf(&tmp[0], "%%%ds", tabs*4);
	_stprintf(&tabStr[0], &tmp[0], _T(""));
}

VOID CPPOutputFile :: EndIndent()
{
	TCHAR tmp[MAX_PATH];

	tabs--;
	_stprintf(&tmp[0], "%%%ds", tabs*4);
	_stprintf(&tabStr[0], &tmp[0], _T(""));
	_ftprintf(outfile, _T("%s}\n"), tabStr);
}

VOID CPPOutputFile :: BlankLine() 
{
	_ftprintf(outfile, _T("\n"));
}

LPTSTR CPPOutputFile :: Ref(LPCTSTR refStr)
{
	static TCHAR tmpStr[3][MAX_PATH];
	static INT pos = 0;

	_stprintf(&tmpStr[pos % 3][0], "&%s", refStr);
		
	pos++;

	return &tmpStr[(pos-1) % 3][0];
}

LPTSTR CPPOutputFile :: RefArray(LPCTSTR refStr)
{
	static TCHAR tmpStr[3][MAX_PATH];
	static INT pos = 0;

	_stprintf(&tmpStr[pos % 3][0], "&%s[0]", refStr);
		
	pos++;

	return &tmpStr[(pos-1) % 3][0];
}

LPTSTR CPPOutputFile :: WStr(LPCTSTR refStr)
{
	static TCHAR tmpStr[3][MAX_PATH];
	static INT pos = 0;
	TCHAR tmpSlash[MAX_PATH];
	INT cnt, cntpos = 0;

	// convert single slashes to double slashes
	for (cnt = 0; cnt < _tcslen(refStr)+1; cnt++)
		if (refStr[cnt] == '\\')
		{
			tmpSlash[cntpos++] = '\\';
			tmpSlash[cntpos++] = '\\';
		}
		else
			tmpSlash[cntpos++] = refStr[cnt];

	_stprintf(&tmpStr[pos % 3][0], "L\"%s\"", tmpSlash);
		
	pos++;

	return &tmpStr[(pos-1) % 3][0];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdippen.hpp ===
#ifndef _GDIPPEN_HPP
#define _GDIPPEN_HPP

class TestPenInterface : public TestConfigureInterface,
						 public TestDialogInterface
{
public:
	// acquire brush object
	virtual Pen* GetPen() { return pen; };

	// output pen setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0) = 0;

	~TestPenInterface()
	{
		delete pen;
	}

protected:
	// pointer to underlying GDI+ brush object
	Pen *pen;
};

class TestPen : public TestPenInterface
{
public:
	TestPen()
	{
	    pen = NULL;
		brush = NULL;
		tempBrush = NULL;
	}

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	// output pen setup to File
	virtual VOID AddToFile(OutputFile* outfile, INT id = 0);

	virtual TestPen* Clone() 
	{
		TestPen *newPen = new TestPen();
		*newPen = *this;					// bitwise copy
		
		if (pen)
			newPen->pen = pen->Clone();	
		
		if (brush)	
			newPen->brush = brush->Clone();

		if (tempBrush)
			newPen->tempBrush = tempBrush->Clone();
		
		return newPen;
	};

protected:
	// helper routine to toggle enable/disable of brush
	VOID EnableBrushFields(HWND hwnd, BOOL enable = TRUE);

private:
	// tempBrush should be NULL unless we are changing settings
	TestBrush *brush, *tempBrush;
	INT brushSelect, tempBrushSelect;
	BOOL useBrush;

	ARGB argb;
	REAL width;
	INT startCap, endCap, dashCap;
	INT lineJoin;
	REAL miterLimit;
	INT dashStyle;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdiptest.h ===
#ifndef _GDIPTEST_H
#define _GDIPTEST_H

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winuser.h>
#include <tchar.h>
#include <math.h>
#include <commdlg.h>
#include <commctrl.h>
#include <float.h>

// not used
#undef IStream
#define IStream int

#include <gdiplus.hpp>

using namespace Gdiplus;

#include "resource.h"

// needed for dynamic array support
#include "debug.h"
#include "runtime.hpp"
#include "dynarrayimpl.hpp"
#include "dynarray.hpp"

#include "gdiputils.h"
#include "gdipoutput.hpp"
#include "gdipbrush.hpp"
#include "gdippen.hpp"
#include "gdipshape.hpp"
#include "gdipclip.h"
#include "gdipdraw.h"

#endif // _GDIPTEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdipoutput.hpp ===
class OutputFile
{
public:
	OutputFile(FILE* out)
	{
		outfile = out;
		tabs = 0;
		tabStr[0] = '\0';
	}

	~OutputFile()
	{
		if (outfile)
		{
			fflush(outfile);
			fclose(outfile);
		}
	}

	static OutputFile* CreateOutputFile(LPTSTR filename);

	virtual VOID GraphicsProcedure() = 0;
	virtual VOID GraphicsDeclaration() = 0;

	virtual VOID PointDeclaration(LPCTSTR pointName, Point* pts, INT count = -1) = 0;
	virtual VOID ColorDeclaration(LPCTSTR colorName, ARGB* argb, INT count = -1) = 0;
	virtual VOID RectangleDeclaration(LPCTSTR rectName, ERectangle& rect) = 0;

	virtual VOID Declaration(LPCTSTR type,
						     LPCTSTR object,
						     LPCTSTR argList,
						     ...) = 0;

	// set matrix, do nothing if identity matrix
	virtual VOID SetPointDeclaration(LPCTSTR object,
									 LPCTSTR command,
									 LPCTSTR varName,
									 Point* pts,
									 INT count = -1,
									 BOOL ref = FALSE) = 0;
	
	virtual VOID SetColorDeclaration(LPCTSTR object,
									 LPCTSTR command,
									 LPCTSTR varName,
									 ARGB* colors,
									 INT count = -1,
									 BOOL ref = FALSE) = 0;

	virtual VOID SetMatrixDeclaration(LPCTSTR object,
									  LPCTSTR command,
									  LPCTSTR varName,
									  Matrix* matrix) = 0;

 	virtual VOID SetBlendDeclaration(LPCTSTR object,
									 LPCTSTR command,
									 LPCTSTR varName,
									 REAL* blend,
									 INT count) = 0;

	virtual VOID GraphicsCommand(LPCTSTR command,
				 				 LPCTSTR argList,
								 ...) = 0;

	virtual VOID ObjectCommand(LPCTSTR object,
							   LPCTSTR command,
							   LPCTSTR argList,
							   ...) = 0;

	virtual VOID BeginIndent() = 0;
	virtual VOID EndIndent() = 0;
	virtual VOID BlankLine() = 0;

	virtual LPTSTR Ref(LPCTSTR) = 0;
	virtual LPTSTR RefArray(LPCTSTR refStr) = 0;
	virtual LPTSTR WStr(LPCTSTR) = 0;

protected:
	FILE* outfile;
	INT tabs;
	TCHAR tabStr[MAX_PATH];
};

class CPPOutputFile : public OutputFile
{
public:
	CPPOutputFile(FILE* out) : OutputFile(out) {}

	virtual VOID GraphicsProcedure();
	virtual VOID GraphicsDeclaration();

	virtual VOID PointDeclaration(LPCTSTR pointName, Point* pts, INT count = -1);
	virtual VOID ColorDeclaration(LPCTSTR colorName, ARGB* argb, INT count = -1);
	virtual VOID RectangleDeclaration(LPCTSTR rectName, ERectangle& rect);

	virtual VOID Declaration(LPCTSTR type,
						     LPCTSTR object,
						     LPCTSTR argList,
							 ...);

	// set matrix, do nothing if identity matrix
	virtual VOID SetPointDeclaration(LPCTSTR object,
									 LPCTSTR command,
									 LPCTSTR varName,
									 Point* pts,
									 INT count = -1,
									 BOOL ref = FALSE);
	
	virtual VOID SetColorDeclaration(LPCTSTR object,
									 LPCTSTR command,
									 LPCTSTR varName,
									 ARGB* colors,
									 INT count = -1,
									 BOOL ref = FALSE);

	virtual VOID SetMatrixDeclaration(LPCTSTR object,
									  LPCTSTR command,
									  LPCTSTR varName,
									  Matrix* matrix);

 	virtual VOID SetBlendDeclaration(LPCTSTR object,
									 LPCTSTR command,
									 LPCTSTR varName,
									 REAL* blend,
									 INT count);

	virtual VOID GraphicsCommand(LPCTSTR command,
				 				 LPCTSTR argList,
								 ...);

	virtual VOID ObjectCommand(LPCTSTR object,
							   LPCTSTR command,
							   LPCTSTR argList,
							   ...);

	virtual VOID BeginIndent();
	virtual VOID EndIndent();
	virtual VOID BlankLine();

	// add '&' to constant
	virtual LPTSTR Ref(LPCTSTR refStr);
	
	// add '&' name '[x]'
	virtual LPTSTR RefArray(LPCTSTR refStr);

	// Add 'L' to constant
	virtual LPTSTR WStr(LPCTSTR refStr);
};

class JavaOutputFile : public CPPOutputFile
{
public:
	JavaOutputFile(FILE* out) : CPPOutputFile(out) {};
};

class VMLOutputFile : public CPPOutputFile
{
public:
	VMLOutputFile(FILE* out) : CPPOutputFile(out) {};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdippen.cpp ===
#include "gdiptest.h"

//*******************************************************************
//
// TestPen
//
//
//
//*******************************************************************

BOOL TestPen :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_PEN_DLG),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)(static_cast<TestDialogInterface*>(this)));

	// customize brush && then cancel
	if (tempBrush)
	{
		delete tempBrush;
		tempBrush = NULL;
	}

	if (ok)
	{		
		delete pen;

		if (useBrush)
		{
			ASSERT(brush);
		
			pen = new Pen(brush->GetBrush(), width);
		}
		else
		{
			Color color(argb);
			
			pen = new Pen(color, width);
		}

  		pen->SetLineCap(capValue[startCap],
						capValue[endCap],
						dashCapValue[dashCap]);
		pen->SetLineJoin(joinValue[lineJoin]);
		pen->SetMiterLimit(miterLimit);
		pen->SetDashStyle(dashValue[dashStyle]);
				
		return TRUE;
	}
	
	return FALSE;
};

VOID TestPen :: Initialize()
{
	delete brush;
	brush = NULL;
	delete tempBrush;
	tempBrush = NULL;
	brushSelect = tempBrushSelect = 0;
	useBrush = FALSE;

	argb = 0x80808080;			// grayish, alpha = 0x80

	width = 5.0f;
	startCap = SquareCap;
	endCap = SquareCap;
	dashCap = FlatCap;
	lineJoin = RoundJoin;
	miterLimit = 0;
	dashStyle = Solid;

	Color color(argb);

	pen = new Pen(color, width);
	
	pen->SetLineCap(capValue[startCap],
					capValue[endCap],
					dashCapValue[dashCap]);
	pen->SetLineJoin(joinValue[lineJoin]);
	pen->SetMiterLimit(miterLimit);
	pen->SetDashStyle(dashValue[dashStyle]);
}

VOID TestPen :: AddToFile(OutputFile* outfile, INT id)
{
	TCHAR penStr[MAX_PATH];
	TCHAR brushStr[MAX_PATH];
	TCHAR colorStr[MAX_PATH];

	if (id)
	{
		_stprintf(&penStr[0], _T("pen%dp"), id);
		_stprintf(&colorStr[0], _T("color%dp"), id);
	}
	else
	{
		_tcscpy(&penStr[0], _T("pen"));
		_tcscpy(&colorStr[0], _T("color"));
	}

	if (useBrush)
	{
		_stprintf(&brushStr[0], "brush%d", 2);

		brush->AddToFile(outfile, 2);
		outfile->Declaration(_T("Pen"),
							 &penStr[0],
							 _T("%s, %e"),
							 outfile->Ref(&brushStr[0]),
							 width);
	}
	else
	{
		outfile->ColorDeclaration(&colorStr[0],
								  &argb);
		outfile->Declaration(_T("Pen"),
							 &penStr[0],
							 _T("%s, %e"),
							 &colorStr[0],
							 width);
	}

	outfile->ObjectCommand(&penStr[0],
						   _T("SetLineCap"),
						   _T("%s, %s, %s"),
						   capStr[startCap],
						   capStr[endCap],
						   dashCapStr[dashCap]);

	outfile->ObjectCommand(&penStr[0],
						   _T("SetLineJoin"),
						   joinStr[lineJoin]);

	if (joinValue[lineJoin] == MiterJoin)
		outfile->ObjectCommand(&penStr[0],
							   _T("SetMiterLimit"),
							   _T("%e"),
							   miterLimit);
	
	outfile->ObjectCommand(&penStr[0],
						   _T("SetDashStyle"),
						   dashStr[dashStyle]);
}

VOID TestPen :: EnableBrushFields(HWND hwnd, BOOL enable)
{
	HWND hwdAlpha  = GetDlgItem(hwnd, IDC_PEN_ALPHA);
	HWND hwdColorB = GetDlgItem(hwnd, IDC_PEN_COLORBUTTON);
	HWND hwdColorP = GetDlgItem(hwnd, IDC_PEN_COLORPIC);
	HWND hwdBrushB = GetDlgItem(hwnd, IDC_PEN_BRUSHBUTTON);
	HWND hwdList   = GetDlgItem(hwnd, IDC_PEN_BRUSHLIST);
	
	SetDialogCheck(hwnd, IDC_PEN_BRUSH, enable);
	SetDialogCheck(hwnd, IDC_PEN_COLOR, !enable);

	EnableWindow(hwdBrushB, enable);
	EnableWindow(hwdList, enable);
	
	EnableWindow(hwdAlpha, !enable);
	EnableWindow(hwdColorP, !enable);
	EnableWindow(hwdColorB, !enable);

	DeleteObject(hwdAlpha);
	DeleteObject(hwdColorP);
	DeleteObject(hwdColorB);
	DeleteObject(hwdBrushB);
	DeleteObject(hwdList);
}

VOID TestPen :: InitDialog(HWND hwnd)
{
	INT i,j;

	// Color/Brush button

	SetDialogCheck(hwnd, IDC_PEN_BRUSH, useBrush);
	SetDialogCheck(hwnd, IDC_PEN_COLOR, !useBrush);

	HWND hwndBrushList = GetDlgItem(hwnd, IDC_PEN_BRUSHLIST);
	EnableWindow(hwndBrushList, useBrush);

	// Store pointer to underlying Brush object in Brush Button
	if (tempBrush)
	{
		// we had a warning, keep the temp Brush until we really save.
	}
	else if (brush)
	{		
		// first pop-up occurrence
		tempBrush = brush->Clone();
		tempBrushSelect = brushSelect;
		SetDialogCombo(hwnd, IDC_PEN_BRUSHLIST, brushList, numBrushes, brushSelect);
	}
	else
	{
		tempBrush = NULL;
		tempBrushSelect = 0;
		SetDialogCombo(hwnd, IDC_PEN_BRUSHLIST, brushList, numBrushes, 0);
	}

	DeleteObject(hwndBrushList);

	// Color values
	SetDialogLong(hwnd, IDC_PEN_ALPHA, argb >> Color::AlphaShift);
	
	EnableBrushFields(hwnd, useBrush);

	// Start/End/Dash Cap
	SetDialogCombo(hwnd, IDC_PEN_STARTCAP, capList, numCaps, startCap);
	SetDialogCombo(hwnd, IDC_PEN_ENDCAP, capList, numCaps, endCap);
	SetDialogCombo(hwnd, IDC_PEN_DASHCAP, dashCapList, numDashCaps, dashCap);

	// Line Join
	SetDialogCombo(hwnd, IDC_PEN_JOIN, joinList, numJoin, lineJoin);

	// Dash Style
	SetDialogCombo(hwnd, IDC_PEN_DASHSTYLE, dashList, numDash, dashStyle);
	
	// Width
	SetDialogReal(hwnd, IDC_PEN_WIDTH, width);

}

BOOL TestPen :: SaveValues(HWND hwnd)
{
	BOOL warning = FALSE;

	// Solid color values
	argb = (argb & ~Color::AlphaMask) |
				(GetDialogLong(hwnd, IDC_PEN_ALPHA)
					<< Color::AlphaShift);

	startCap = GetDialogCombo(hwnd, IDC_PEN_STARTCAP);
	endCap = GetDialogCombo(hwnd, IDC_PEN_ENDCAP);
	dashCap = GetDialogCombo(hwnd, IDC_PEN_DASHCAP);

	// Width
	width = GetDialogReal(hwnd, IDC_PEN_WIDTH);
	if (width < 0.01f)
	{
		width = 0.01f;
		warning = TRUE;
	}
	else if (width > 100)
	{
		width = 100.0f;
		warning = TRUE;
	}

	dashStyle = GetDialogCombo(hwnd, IDC_PEN_DASHSTYLE);
	lineJoin = GetDialogCombo(hwnd, IDC_PEN_JOIN);

	// !! miter limit not currently supported
	miterLimit = 0;

	BOOL tempUse = GetDialogCheck(hwnd, IDC_PEN_BRUSH);
	if (tempUse)
	{
		 tempBrushSelect = GetDialogCombo(hwnd, IDC_PEN_BRUSHLIST);
		 			 
		 if (!tempBrush || 
			 (tempBrush->GetType() != brushValue[tempBrushSelect]))
		 {
			 WarningBox("Must customize Brush or select Color.");
			 warning = TRUE;
		 }
		 else
		 {
			 // we are saving, copy tempBrush to real Brush
			 // no reason to clone
			 if (!warning)
			 {
				 delete brush;
				 brush = tempBrush;
				 brushSelect = tempBrushSelect;
				 tempBrush = NULL;
				 tempBrushSelect = 0;
			 }
		 }
	}
	else
	{
		// no warnings and not using temp brush, delete it.
		if (!warning)
		{
			delete tempBrush;
			tempBrush = NULL;
		}
	}

	if (warning)
		InitDialog(hwnd);

	return warning;
}

BOOL TestPen :: ProcessDialog(HWND hwnd, 
			  				  UINT msg, 
							  WPARAM wParam, 
							  LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		// pop-up brush customization window
		case IDC_PEN_BRUSHBUTTON:
			{
				ASSERT(useBrush);

				// get selected brush type
				tempBrushSelect = GetDialogCombo(hwnd, IDC_PEN_BRUSHLIST);

				if (tempBrush)
				{
					// change in brush type, create new temp brush
					if (tempBrush->GetType() != brushValue[tempBrushSelect])
					{
						// we've changed type,
						delete tempBrush;
						tempBrush = NULL;

						tempBrush = TestBrush::CreateNewBrush(brushValue[tempBrushSelect]);
						tempBrush->Initialize();

						if (!tempBrush->ChangeSettings(hwnd))
						{
							delete tempBrush;
							tempBrush = NULL;
						}
					}
					else
					{
						// change settings on temp brush
						tempBrush->ChangeSettings(hwnd);
					}
				}
				else
				{
					// no brush type previously selected.
					tempBrush = TestBrush::CreateNewBrush(brushValue[tempBrushSelect]);
					tempBrush->Initialize();

					if (!tempBrush->ChangeSettings(hwnd))
					{
						delete tempBrush;
						tempBrush = NULL;
					}
				}
			}
			break;

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_PEN_COLORPIC, argb);
			break;

		case IDC_PEN_COLORBUTTON:
			UpdateRGBColor(hwnd, IDC_PEN_COLORPIC, argb);
			break;

			// enable/disable appropriate fields
		case IDC_PEN_BRUSH:
			EnableBrushFields(hwnd, TRUE);
			useBrush = TRUE;
			break;

		case IDC_PEN_COLOR:
			EnableBrushFields(hwnd,FALSE);
			useBrush = FALSE;
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}
/*
	if (HIWORD(wParam) == CBN_DROPDOWN)
	{
		// list box about to be displayed
		DebugBreak();
	}

	if (HIWORD(wParam) == CBN_CLOSEUP)
	{
		// about to close list-box
		DebugBreak();
	}

*/
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdiptest.cpp ===
// gdipdraw.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include "gdiptest.h"

#pragma hdrstop
// end of precompiled header segment

//using namespace Gdiplus;

// Global Variables:
HINSTANCE hInst;								// current instance
TCHAR szTitle[MAX_LOADSTRING];								// The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];								// The title bar text

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
	MSG msg;
	HACCEL hAccelTable;
	HWND hWnd;

	// Initialize global strings
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_GDIPTEST, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	TestDraw draw;

	// Perform application initialization:
	hWnd = InitInstance (hInstance, nCmdShow, 
				(LPVOID)(static_cast<TestDrawInterface*>(&draw)));

	if (hWnd == (HWND)0)
	{
		return FALSE;
	}

	// initialize global control point colors
	blackColor = new Color(0x80, 0, 0, 0);
	blackBrush = new SolidBrush(*blackColor);
	blackPen = new Pen(*blackColor, 5.0f);

	Color whiteColor(0xFFFFFFFF);
	backBrush = new SolidBrush(whiteColor);

	draw.UpdateStatus(hWnd);

    // initialize menu check marks
    SetMenuCheckPos(hWnd, MenuShapePosition, 0, TRUE);
    SetMenuCheckPos(hWnd, MenuBrushPosition, 0, TRUE);

    hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_GDIPTEST);

	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	delete blackColor;
	delete blackBrush;
	delete blackPen;
	
	delete backBrush;

	return msg.wParam;
}

//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndTestDrawProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_GDIPTEST);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= (LPCSTR)IDC_GDIPTEST;
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	return RegisterClassEx(&wcex);
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
HWND InitInstance(HINSTANCE hInstance, int nCmdShow, LPVOID param)
{
   HWND hWnd;

   hInst = hInstance; // Store instance handle in our global variable

   hWnd = CreateWindow(
			szWindowClass, 
			szTitle, 
			WS_OVERLAPPEDWINDOW,
			CW_USEDEFAULT, 
			0, 
			CW_USEDEFAULT, 
			0, 
			NULL, 
			NULL, 
			hInstance, 
			param);

   if (!hWnd)
   {
      return (HWND)0;
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return hWnd;
}

//
//  FUNCTION: WndTestDrawProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND	- process the application menu
//  WM_PAINT	- Paint the main window
//  WM_DESTROY	- post a quit message and return
//
//
LRESULT CALLBACK WndTestDrawProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;

	switch (message) 
	{
		case WM_CREATE:
		{	
			TestDrawInterface* dlgInt = 
				static_cast<TestDrawInterface*>
				      (((LPCREATESTRUCT)lParam)->lpCreateParams);
					  
			SetWindowLong(hWnd, GWL_USERDATA, (LONG)dlgInt);
			break;
		}

		case WM_COMMAND:
		{
			wmId    = LOWORD(wParam); 
			wmEvent = HIWORD(wParam); 

			TestDrawInterface* drawInt = 
				(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);

			TestDraw* draw = static_cast<TestDraw*>(drawInt);
			
			TestGradDraw* graddraw = static_cast<TestGradDraw*>(drawInt);
				
			// Parse the menu selections:
			switch (wmId)
			{
			// Shape Menu
			case IDM_LINE:
				draw->ChangeShape(hWnd, LineType);
				break;

			case IDM_ARC:
				draw->ChangeShape(hWnd, ArcType);
				break;
				
			case IDM_BEZIER:
				draw->ChangeShape(hWnd, BezierType);
				break;

			case IDM_RECT:
				draw->ChangeShape(hWnd, RectType);
				break;

			case IDM_ELLIPSE:
				draw->ChangeShape(hWnd, EllipseType);
				break;

			case IDM_PIE:
				draw->ChangeShape(hWnd, PieType);
				break;

			case IDM_POLYGON:
				draw->ChangeShape(hWnd, PolygonType);
				break;

			case IDM_CURVE:
				draw->ChangeShape(hWnd, CurveType);
				break;

			case IDM_CLOSED:
				draw->ChangeShape(hWnd, ClosedCurveType);
				break;

			case IDM_REGION:
				// do complete redraw if leaving incomplete shape
				break;

			// Brush Menu
			case IDM_SOLIDBRUSH: 
				draw->ChangeBrush(hWnd, SolidColorBrush); 
				break;

			case IDM_TEXTURE:    
				draw->ChangeBrush(hWnd, TextureFillBrush); 
				break;
				
			case IDM_RECTGRAD:   
				draw->ChangeBrush(hWnd, RectGradBrush); 
				break;

			case IDM_RADGRAD:   
				draw->ChangeBrush(hWnd, RadialGradBrush); 
				break;

			case IDM_TRIGRAD:   
				draw->ChangeBrush(hWnd, TriangleGradBrush); 
				break;

			case IDM_POLYGRAD:   
				draw->ChangeBrush(hWnd, PathGradBrush); 
				break;

			case IDM_HATCH:      
				draw->ChangeBrush(hWnd, HatchFillBrush); 
				break;

			// Pen Menu
			case IDM_PEN:		 
				draw->ChangePen(hWnd); 
				break;

			// Redraw Menu
			case IDM_REDRAWALL:
				draw->redrawAll = !draw->redrawAll;
				SetMenuCheckCmd(hWnd, 
					MenuOtherPosition, 
					wmId, 
					draw->redrawAll);
					
				// force redraw of all stacked shapes
				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
				break;

			case IDM_KEEPCONTROLPOINTS:
				draw->keepControlPoints = !draw->keepControlPoints;
				SetMenuCheckCmd(hWnd, 
					MenuOtherPosition, 
					wmId, 
					draw->keepControlPoints);

				// force redraw of all stacked shapes
				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
				break;

			case IDM_ANTIALIASED:
				draw->antiAlias = !draw->antiAlias;
				SetMenuCheckCmd(hWnd, 
					MenuOtherPosition, 
					wmId, 
					draw->keepControlPoints);

				// force redraw of all stacked shapes
				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
				break;

			case IDM_USECLIP:
				draw->useClip = !draw->useClip;
				SetMenuCheckCmd(hWnd, 
					MenuOtherPosition, 
					wmId, 
					draw->useClip);

				// force redraw of all stacked shapes
				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
				break;

			case IDM_WORLD_TRANSFORM:
			{
				Matrix *matrix = draw->GetWorldMatrix()->Clone();

				TestTransform transDlg;
				transDlg.Initialize(&matrix);
				transDlg.ChangeSettings(hWnd);

				draw->SetWorldMatrix(matrix);
				
				delete matrix;
				
				break;
			}

			case IDM_SETCLIP:
				draw->SetClipRegion(hWnd);
				break;

			case IDM_SAVEFILE:
				draw->SaveAsFile(hWnd);
				break;
		
			case IDM_DELETE:
				draw->RemovePoint(hWnd);
				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
				break;

			case IDM_RESET:
				graddraw->Reset(hWnd);
				break;

			case IDM_INSTRUCTIONS:
				graddraw->Instructions(hWnd);
				break;
				
			case IDM_CANCEL:
				DestroyWindow(hWnd);
				PostQuitMessage(FALSE);
				break;

			case IDM_DONE:
				DestroyWindow(hWnd);
				PostQuitMessage(TRUE);
				break;

			// Exit Test App
			case IDM_EXIT:
			   DestroyWindow(hWnd);
			   break;

			default:
			   return DefWindowProc(hWnd, message, wParam, lParam);
			}

			break;
		}

		case WM_LBUTTONUP:
			{
				Point pt(LOWORD(lParam), 
						 HIWORD(lParam));

				TestDrawInterface* drawInt = 
					(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);

				drawInt->AddPoint(hWnd, pt);

				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
			}
			break;

		case WM_MBUTTONUP:
			{
				Point pt(LOWORD(lParam), 
						 HIWORD(lParam));

				TestDrawInterface* drawInt = 
					(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);

				drawInt->EndPoint(hWnd, pt);
				
				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
			}
			break;

		case WM_RBUTTONDOWN:
			{
				Point pt(LOWORD(lParam), 
						 HIWORD(lParam));

				TestDrawInterface* drawInt = 
					(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);
		
				drawInt->RememberPoint(pt);
			}
			break;

		case WM_RBUTTONUP:
			{
				Point pt(LOWORD(lParam), 
						 HIWORD(lParam));

				TestDrawInterface* drawInt = 
					(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);
		
				drawInt->MoveControlPoint(pt);
				
				InvalidateRect(hWnd, NULL, TRUE);
				UpdateWindow(hWnd);
			}
			break;

		case WM_PAINT:
			{
				TestDrawInterface* drawInt = 
					(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);
		
				if (drawInt)
					drawInt->Draw(hWnd);
			}
			break;

		case WM_ENTERSIZEMOVE:
			{
				// reposition the status window
				TestDrawInterface* drawInt = 
					(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);
		
				if (drawInt)
					drawInt->UpdateStatus((HWND)-1);
			}
			break;

		case WM_SIZE:
			{
				// reposition the status window
				TestDrawInterface* drawInt = 
					(TestDrawInterface*)GetWindowLong(hWnd, GWL_USERDATA);
		
				if (drawInt)
					drawInt->UpdateStatus(hWnd);
			}
			break;

		case WM_DESTROY:
			PostQuitMessage(0);
			break;

		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdipshape.hpp ===
#ifndef GDIPSHAPE_HPP
#define GDIPSHAPE_HPP

class TestShapeInterface;
class TestShape;
class LineShape;
class ArcShape;
class BezierShape;
class RectShape;
class EllipseShape;
class PieShape;
class PolygonShape;
class CurveShape;
class ClosedCurveShape;

class TestRectGradShape;
class TestRadialGradShape;
class TestTriangleGradShape;
class TestPathGradShape;

class TestShapeInterface : public TestConfigureInterface,
						   public TestDialogInterface
{
public:
	// initialize shape parameters to that of compatible shape
	virtual VOID Initialize(TestShape *shape) = 0;

	// add point to shape
	virtual BOOL AddPoint(HWND hwnd, Point pt) = 0;

	// user indicates we're done shape
	virtual VOID DoneShape(HWND hwnd) = 0;

	// last point added directly by a user
	virtual BOOL EndPoint(HWND hwnd, Point pt) = 0;

	// remove last control point from shape
	virtual BOOL RemovePoint(HWND hwnd) = 0;

	// do we encapsulate an entire shape?
	virtual BOOL IsComplete() = 0;

	// are there no control points for this shape?
	virtual BOOL IsEmpty() = 0;

	// draw control points ONLY
	virtual VOID DrawPoints(Graphics* g) = 0;

	// draw entire shape (no control points)
	virtual VOID DrawShape(Graphics* g) = 0;

	// add shape to path if complete
	virtual VOID AddToPath(GraphicsPath* path) = 0;

	// write instructions to create function
	virtual VOID AddToFile(OutputFile* outfile) = 0;

	// get type of shape
	virtual INT GetType() = 0;

	// return DC containing shape picture
	virtual HDC CreatePictureDC(HWND hwnd, RECT *rect) = 0;
};

class TestShape: public TestShapeInterface
{
public:

	TestShape() : pen(NULL),
				  brush(NULL),
				  done(FALSE),
				  shapeName(NULL),
				  disabled(FALSE)
	{
		pts.Reset();

		// !! hack for distinct names
		static INT shapeCount = 0;
		shapeName = (LPTSTR)malloc(sizeof(TCHAR)*100);
		sprintf(shapeName, _T("Shape (%d)"), shapeCount++);

		hdcPic = NULL;
	}

	~TestShape()
	{
		if (hdcPic)
			DeleteDC(hdcPic);

		delete pen;
		delete brush;
		
		if (shapeName)
			free(shapeName);
	}

	// useful helper functions
	static TestShape* CreateNewShape(INT type);

	// temporary overload for those who don't implement these.
	virtual VOID Initialize()
	{
	};

	virtual VOID Initialize(TestShape *shape) 
	{
		this->Initialize();
	};

	virtual HDC CreatePictureDC(HWND hwnd, RECT *rect);

	virtual VOID SetBrush(TestBrush *newbrush)
	{
		delete brush;
		brush = newbrush;
	}

	virtual VOID SetPen(TestPen *newpen)
	{
		delete pen;
		pen = newpen;
	}
	
	virtual TestBrush* GetBrush()
	{
		return brush;
	}

	virtual TestPen* GetPen()
	{
		return pen;
	}

	virtual VOID SetDisabled(BOOL disabled)
	{
		this->disabled = disabled;
	}

	virtual BOOL GetDisabled()
	{
		return disabled;
	}

	virtual BOOL EndPoint(HWND hwnd, Point pt);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual VOID DrawPoints(Graphics* g);
	virtual BOOL MoveControlPoint(Point origPt, Point newPt);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	virtual BOOL IsEmpty()
	{
		return (pts.GetCount() == 0);
	}

	virtual INT GetCount()
	{
		return pts.GetCount();
	}

	virtual INT GetType()
	{
		ASSERT(FALSE);
		return -1;	
	}

	virtual LPTSTR GetShapeName()
	{
		// !! alter name based on Disabled/Not disabled?!?
		return shapeName;
	}

/*
	virtual INT* ShapeCount()
	{
		static INT shapeCount = 0;
		return &shapeCount;
	}

	virtual INT* RevCount()
	{
		static INT revCount = 0;
		return &revCount;
	}

	virtual TestShape* Clone()
	{
		TestShape* newShape = new TestShape();
		*newShape = *this;

		// clone GDI+ brush and pen
		newShape->brush = brush->Clone();
		newShape->pen = pen->Clone();
	
		// make extra copy of dynamic point array and shape name
		newShape->pts.RenewDataBuffer();
	}
*/

public:
	// for use by other objects in system for temporary storage
	DWORD dwFlags;

protected:
	TestBrush *brush;
	TestPen *pen;

	PointArray pts;
	BOOL done;

	LPTSTR shapeName;
	BOOL disabled;

	HDC hdcPic;
};

class LineShape : public TestShape
{
public:
	friend class LineShape;

	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return LineType; 
	}
};

class ArcShape : public TestShape
{
public:
	friend class ArcShape;
	
	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return ArcType; 
	}

private:
	REAL start;
	REAL sweep;
	BOOL popup;
};

class BezierShape : public TestShape
{
public:
	friend class BezierShape;

	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return BezierType; 
	}
};

class RectShape : public TestShape
{
public:
	friend class RectShape;
	
	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return RectType; 
	}
};

class EllipseShape : public TestShape
{
public:
	friend class EllipseShape;
	
	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return EllipseType; 
	}
};

class PieShape : public TestShape
{
public:
	friend class PieShape;
	
	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return PieType; 
	}

private:
	REAL start;
	REAL sweep;
	BOOL popup;
};

class PolygonShape : public TestShape
{
public:
	friend class PolygonShape;
	
	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return PolygonType; 
	}
};

class CurveShape : public TestShape
{
public:
	friend class CurveShape;
	
	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return CurveType; 
	}

private:
	REAL tension;
	INT offset;
	INT numSegments;
	BOOL popup;
};

class ClosedCurveShape : public TestShape
{
public:
	friend class ClosedCurveShape;
	
	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL RemovePoint(HWND hwnd);
	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual VOID AddToPath(GraphicsPath* path);
	virtual VOID AddToFile(OutputFile* outfile);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	virtual INT GetType() 
	{ 
		return ClosedCurveType; 
	}

private:
	REAL tension;
	BOOL popup;
};
//*******************************************************************
//
// TestGradShapeInterface
//
//
//
//*******************************************************************

class TestGradShape : public TestShape
{
public:
	TestGradShape()
	{
		argb.Reset();
	}
	
	virtual VOID DrawPoints(Graphics* g);

protected:
	INT FindControlPoint(Point pt);
	INT FindLocationToInsert(Point pt);

	ARGBArray argb;

	INT curIndex;
	ARGB tmpArgb;
};

//*******************************************************************
//
// TestTriangleGradShape
//
//
//
//*******************************************************************

#define TriangleCount 3

class TestTriangleGradShape : public TestGradShape
{
public:
	TestTriangleGradShape()
	{
		argb.Reset();

		blend[0] = blend[1] = blend[2] = NULL;
		
		gdiBrush = NULL;
	}

	~TestTriangleGradShape()
	{
		for (INT i = 0; i < 3; i++)
			if (blend[i])
				free(blend[i]);

		delete gdiBrush;
	}

	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL EndPoint(HWND hwnd, Point pt);
	virtual BOOL RemovePoint(HWND hwnd);

	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual BOOL MoveControlPoint(Point origPt, Point newPt);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	VOID Initialize(Point* pts, 
					ARGB* argb, 
					REAL** blend, 
					INT* blendCount);
	
	Point* GetPoints()
	{
		return pts.GetDataBuffer();
	}

	ARGB* GetARGB()
	{
		return argb.GetDataBuffer();
	}

	REAL** GetBlend()
	{
		return &blend[0];
	}

	INT* GetBlendCount()
	{
		return &count[0];
	}

private:
	TriangleGradientBrush* gdiBrush;
	
	REAL* blend[3];
	INT count[3];
};

//*******************************************************************
//
// TestPathGradShape
//
//
//
//*******************************************************************

class TestPathGradShape : public TestGradShape
{
public:
	TestPathGradShape()
	{
		argb.Reset();

		surroundBlend = centerBlend = NULL;
		surroundCount = centerCount = 0;
		
		gdiBrush = NULL;
	}

	~TestPathGradShape()
	{
		if (surroundBlend)
			free(surroundBlend);

		if (centerBlend)
			free(centerBlend);

		delete gdiBrush;
	}

	// Shape usage methods
	virtual VOID Initialize(TestShape *shape);
	virtual BOOL AddPoint(HWND hwnd, Point pt);
	virtual VOID DoneShape(HWND hwnd);
	virtual BOOL EndPoint(HWND hwnd, Point pt);
	virtual BOOL RemovePoint(HWND hwnd);

	virtual BOOL IsComplete();
	virtual VOID DrawShape(Graphics* g);
	virtual BOOL MoveControlPoint(Point origPt, Point newPt);

	// Configuration Interface
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();

	// Dialog Management Interface
	virtual	VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam);

	VOID Initialize(PointArray* pts, 
					ARGBArray* argb, 
					REAL* surroundBlend,
					INT surroundColor,
					REAL* centerBlend,
					INT centerColor);
	
	Point* GetPoints()
	{
		return pts.GetDataBuffer();
	}

	ARGB* GetARGB()
	{
		return argb.GetDataBuffer();
	}

	REAL* GetCenterBlend()
	{
		return centerBlend;
	}

	INT GetCenterBlendCount()
	{
		return centerCount;
	}

	REAL* GetSurroundBlend()
	{
		return surroundBlend;
	}

	INT GetSurroundBlendCount()
	{
		return surroundCount;
	}

private:
	PathGradientBrush* gdiBrush;

	REAL* surroundBlend;
	REAL* centerBlend;
	INT surroundCount, centerCount;
};

#endif  // _GDIPSHAPE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdipshape.cpp ===
#include "gdiptest.h"

//*******************************************************************
//
// TestShape
//
//
//
//*******************************************************************

TestShape* TestShape :: CreateNewShape(INT type)
{
	switch (type)
	{
	case LineType:
		return new LineShape();
		
	case ArcType:
		return new ArcShape();

	case BezierType:
		return new BezierShape();

	case RectType:
		return new RectShape();

	case EllipseType:
		return new EllipseShape();

	case PieType:
		return new PieShape();

	case PolygonType:
		return new PolygonShape();

	case CurveType:
		return new CurveShape();
		break;

	case ClosedCurveType:
		return new ClosedCurveShape();
		break;

	// !!! Other shapes types

	default:
		NotImplementedBox();
		return NULL;
	}
}

// black squares
VOID TestShape :: DrawPoints(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	while (count)
	{
		ERectangle rect(ptbuf->X-pointRadius,
						ptbuf->Y-pointRadius,
						2*pointRadius,
						2*pointRadius);

		g->FillRectangle(blackBrush, rect);
		// g->FillEllipse(ptBrush, rect);

		count--, ptbuf++;
	}
}

BOOL TestShape::EndPoint(HWND hwnd, Point pt)
{
	AddPoint(hwnd, pt);
	DoneShape(hwnd);

	return FALSE;
}

INT TestGradShape :: FindLocationToInsert(Point pt)
{
	// !! Not implemented yet.
	return 0;
}

// square color from ARGB value
VOID TestGradShape :: DrawPoints(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	for (INT i = 0; i < count; i++)
	{
		ERectangle rect(ptbuf->X-pointRadius,
						ptbuf->Y-pointRadius,
						2*pointRadius,
						2*pointRadius);

		Color solidColor((argb[i] & ~Color::AlphaMask)
						| (0xFF << Color::AlphaShift));

		SolidBrush solidBrush((argb[i] & ~Color::AlphaMask) == 0
									? *blackColor : solidColor);

		g->FillRectangle(&solidBrush, rect);

		ptbuf++;
	}
}

BOOL TestShape :: MoveControlPoint(Point origPt, Point newPt)
{
	INT count = pts.GetCount();
	INT pos = 0;

	// !!! what if multiple control points overlap?
	//     can't get to one of them
	for (pos = 0; pos<count; pos++)
	{
		Point *ctrlPt = &pts[pos];

		ERectangle ctrlRect(ctrlPt->X-pointRadius,
							ctrlPt->Y-pointRadius,
							2*pointRadius,
							2*pointRadius);

		if (origPt.X>ctrlPt->X-pointRadius &&
			origPt.X<ctrlPt->X+pointRadius &&
			origPt.Y>ctrlPt->Y-pointRadius &&
			origPt.Y<ctrlPt->Y+pointRadius)
		{
			ctrlPt->X = newPt.X;
			ctrlPt->Y = newPt.Y;
			return TRUE;
		}
	}

	return FALSE;
}

INT TestGradShape :: FindControlPoint(Point pt)
{
	INT count = pts.GetCount();
	INT pos = 0;

	// !!! what if multiple control points overlap?
	//     can't get to one of them
	for (pos = 0; pos < count; pos++)
	{
		Point *ctrlPt = &pts[pos];

		ERectangle ctrlRect(ctrlPt->X-pointRadius,
							ctrlPt->Y-pointRadius,
							2*pointRadius,
							2*pointRadius);

		if (pt.X>ctrlPt->X-pointRadius &&
			pt.X<ctrlPt->X+pointRadius &&
			pt.Y>ctrlPt->Y-pointRadius &&
			pt.Y<ctrlPt->Y+pointRadius)
		{
			return pos;
		}
	}

	return -1;
}

BOOL TestShape :: RemovePoint(HWND hwnd)
{
	return FALSE;
}

VOID TestShape :: AddToPath(GraphicsPath* path)
{
}

VOID TestShape :: AddToFile(OutputFile* outfile)
{
}

HDC TestShape :: CreatePictureDC(HWND hwnd, RECT *dstRect)
{
	// always return the cached version if possible

	HWND hwndLast = GetWindow(hwnd, GW_OWNER);
	HDC hdc;
	HDC hdc2;

	HDC hdcWindow;
	HBITMAP hbm;
	HBITMAP hbm2;

	// get handle to main window
	while (hwndLast)
	{
		hwnd = hwndLast;
		hwndLast = GetWindow(hwnd, GW_OWNER);
	}

	// !! BUG BUG: we are actually getting handle
	//    to the dialog, not the main window 
	//    IS THIS TRUE?!?!
	
	RECT srcRect;
	GetClientRect(hwnd, &srcRect);
	hdcWindow = GetDC(hwnd);

	SIZE size;
	size.cx = srcRect.right-srcRect.left;
	size.cy = srcRect.bottom-srcRect.top;

	if (hdcPic)
	{
	    hbm = CreateCompatibleBitmap(hdcPic, 1, 1);
		hbm = (HBITMAP) SelectObject(hdcPic, (HGDIOBJ)hbm);
		
		SIZE origSize;
		GetBitmapDimensionEx(hbm, &origSize);

		DeleteObject(SelectObject(hdcPic, (HGDIOBJ)hbm));

		// if size hasn't changed, don't recreate
		if (origSize.cx == size.cx && 
			origSize.cy == size.cy)
		{
			ReleaseDC(hwnd, hdcWindow);
			return hdcPic;
		}

		// clean up the old picture DC
		DeleteObject(hdcPic);
		hdcPic = NULL;
		// create new picture image
	}

	SIZE size2;
	size2.cx = dstRect->right-dstRect->left;
	size2.cy = dstRect->bottom-dstRect->top;

	hdc = CreateCompatibleDC(hdcWindow);	// source
	hdc2 = CreateCompatibleDC(hdcWindow);	// destination

	hbm = CreateCompatibleBitmap(hdcWindow, size.cx, size.cy);
	hbm2 = CreateCompatibleBitmap(hdcWindow, size2.cx, size2.cy);

	SetBitmapDimensionEx(hbm2, size.cx, size.cy, NULL);

	DeleteObject((HBITMAP) SelectObject(hdc, (HGDIOBJ) hbm));
	DeleteObject((HBITMAP) SelectObject(hdc2, (HGDIOBJ) hbm2));

	// white GDI brush
	HBRUSH hbr = CreateSolidBrush(0x00FFFFFF);
	srcRect.left = srcRect.top = 0;
	srcRect.right = size.cx;
	srcRect.bottom = size.cy;
	
	FillRect(hdc, &srcRect, hbr);
	DeleteObject(hbr);

	{
		// create GDI+ graphics context for this memory DC
		Graphics g(hdc);

		DrawShape(&g);	
	}

	StretchBlt(hdc2,
			   0,
			   0,
			   size2.cx,
			   size2.cy,
			   hdc,
			   srcRect.left,
			   srcRect.top,
			   size.cx,
			   size.cy,
			   SRCCOPY);

	ReleaseDC(hwnd, hdcWindow);
	ReleaseDC(hwnd, hdc);
	
	// !! necessary?
	DeleteObject(hbm);

	// return DC with GDI+ drawn graphics shape, cache it
	return (hdcPic = hdc2);
}

//*******************************************************************
//
// LineShape
//
//
//
//*******************************************************************

BOOL LineShape :: AddPoint(HWND hwnd, Point pt)
{
	pts.Add(pt);
	return TRUE;
}

VOID LineShape :: DoneShape(HWND hwnd)
{
	if (pts.GetCount()>1)
		done = TRUE;
	else
		done = FALSE;
}

BOOL LineShape :: IsComplete()
{
	return done;
}

BOOL LineShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = TRUE;
		return TRUE;
	}
	else
		return FALSE;
}

VOID LineShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	ASSERT(IsComplete());

	if (pen)
		g->DrawLines(pen->GetPen(), ptbuf, count);

	// brush is not used
}

VOID LineShape :: AddToPath(GraphicsPath* path)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	ASSERT(Path);

	path->AddLines(ptbuf, count);
}

VOID LineShape :: AddToFile(OutputFile* outfile)
{
	INT count = pts.GetCount();

	pen->AddToFile(outfile);
	
	outfile->BlankLine();
	
	outfile->PointDeclaration(_T("pts"),
							  (Point*)pts.GetDataBuffer(),
							  count);
	
	outfile->BlankLine();
	
	outfile->GraphicsCommand(_T("DrawLine"),
							 _T("%s, %s, %d"),
							 outfile->Ref(_T("pen")),
							 outfile->RefArray(_T("pts")),
							 count);
}

// Configuration management functions
BOOL LineShape :: ChangeSettings(HWND hwnd)
{
	return TRUE;
}

VOID LineShape :: Initialize()
{
	// do nothing
};

VOID LineShape :: Initialize(TestShape* shape)
{
	// do nothing
}

// Dialog management functions (not used)
VOID LineShape :: InitDialog(HWND hwnd)
{
	DebugBreak();
}

BOOL LineShape :: SaveValues(HWND hwnd)
{
	DebugBreak();
	return FALSE;
}

BOOL LineShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	DebugBreak();
	return FALSE;
}

//*******************************************************************
//
// ArcShape
//
//
//
//*******************************************************************

BOOL ArcShape :: AddPoint(HWND hwnd, Point pt)
{
	ASSERT(pts.GetCount() < 2);

	pts.Add(pt);

	// force complete on point pairs (rect) if possible
	DoneShape(hwnd);
	
	return TRUE;
}

VOID ArcShape :: DoneShape(HWND hwnd)
{
	ASSERT(pts.GetCount() <= 2);

	if (pts.GetCount() == 2)
	{
		done = TRUE;

		if (popup)
		{
			// !!! cheating, we use global HWND, should use
			//     HWND passed in.
			ChangeSettings(hwnd);
		}

	}
	else
		done = FALSE;
}

BOOL ArcShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL ArcShape :: IsComplete()
{
	return done;
}

VOID ArcShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ASSERT(IsComplete());
	ASSERT(count == 2);

	if (pen) 
	{
		// create appropriate rectangle
		// !! cache this?
		ERectangle rect(min(pt1->X, pt2->X),
						min(pt1->Y, pt2->Y),
						fabsf(pt1->X-pt2->X),
						fabsf(pt1->Y-pt2->Y));

		g->DrawArc(pen->GetPen(), rect, start, sweep);
	}

	// brush is not used
}

VOID ArcShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	if (count < 2)
		return;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	path->AddArc(rect, start, sweep);
}

VOID ArcShape :: AddToFile(OutputFile* outfile)
{
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	pen->AddToFile(outfile);

	outfile->BlankLine();

	outfile->RectangleDeclaration(_T("rect"), 
								  rect);

	outfile->BlankLine();

	outfile->GraphicsCommand(_T("DrawArc"),
							 _T("%s, %s, %e, %e"),
							 outfile->Ref(_T("pen")),
							 _T("rect"),
							 start,
							 sweep);
}

// Configuration management functions
BOOL ArcShape :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_ARC_DLG),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	return ok;
}

VOID ArcShape :: Initialize()
{
	sweep = 90.0f;
	start = 0.0f;
	popup = FALSE;
};

VOID ArcShape :: Initialize(TestShape *shape)
{
	// if compatible, copy parameters from another compatible shape
	if (shape && shape->GetType() == GetType())
	{
		ArcShape* arcshape = static_cast<ArcShape*>(shape);

		sweep = arcshape->sweep;
		start = arcshape->start;
		popup = arcshape->popup;
	}
	else
		Initialize();
}

// Dialog management functions (not used)
VOID ArcShape :: InitDialog(HWND hwnd)
{
	SetDialogReal(hwnd, IDC_ARC_START, start);
	SetDialogReal(hwnd, IDC_ARC_SWEEP, sweep);
	SetDialogCheck(hwnd, IDC_ARC_POPUP, popup);
}

BOOL ArcShape :: SaveValues(HWND hwnd)
{
	start = GetDialogReal(hwnd, IDC_ARC_START);
	sweep = GetDialogReal(hwnd, IDC_ARC_SWEEP);
	popup = GetDialogCheck(hwnd, IDC_ARC_POPUP);

	// no warnings, anything goes
	return FALSE;
}

BOOL ArcShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	if (msg == WM_COMMAND &&
		LOWORD(wParam) == IDC_OK)
	{
		if (SaveValues(hwnd))
			WarningBeep();
		else
			::EndDialog(hwnd, TRUE);

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// BezierShape
//
//
//
//*******************************************************************

BOOL BezierShape :: AddPoint(HWND hwnd, Point pt)
{
	pts.Add(pt);

	return TRUE;
}

VOID BezierShape :: DoneShape(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count>3)
	{
		if (count % 3 != 1)
		{
			// if they have wrong # of pts, but want to stop,
			// then draw with control points we have.
			while (count % 3 != 1) count--;
			pts.SetCount(count);
		}
		done = TRUE;
	}
	else
	{
		done = FALSE;
	}
}

BOOL BezierShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL BezierShape :: IsComplete()
{
	return done;
}

VOID BezierShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	ASSERT(IsComplete());

	if (pen)
		g->DrawBeziers(pen->GetPen(), ptbuf, count);

	// brush is not used
}

VOID BezierShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	if (count > 0)
		path->AddBeziers(ptbuf, count);
}

VOID BezierShape :: AddToFile(OutputFile* outfile)
{
	INT count = pts.GetCount();

	pen->AddToFile(outfile);

	outfile->BlankLine();

	outfile->PointDeclaration(_T("pts"),
							  (Point*)pts.GetDataBuffer(),
							  count);

	outfile->BlankLine();

	outfile->GraphicsCommand(_T("DrawBezier"),
							 _T("%s, %s, %d"),
							 outfile->Ref(_T("pen")),
							 outfile->RefArray(_T("pts")),
							 count);
}

// Configuration management functions
BOOL BezierShape :: ChangeSettings(HWND hwnd)
{
	return TRUE;
}

VOID BezierShape :: Initialize()
{
	pts.Reset();
};

VOID BezierShape :: Initialize(TestShape *shape)
{
}

// Dialog management functions (not used)
VOID BezierShape :: InitDialog(HWND hwnd)
{
	DebugBreak();
}

BOOL BezierShape :: SaveValues(HWND hwnd)
{
	DebugBreak();
	return FALSE;
}

BOOL BezierShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	DebugBreak();
	return FALSE;
}

//*******************************************************************
//
// RectShape
//
//
//
//*******************************************************************

BOOL RectShape :: AddPoint(HWND hwnd, Point pt)
{
	ASSERT(pts.GetCount() < 2);

	pts.Add(pt);

	// force complete on point pairs (rect) if possible
	DoneShape(hwnd);
	
	return TRUE;
}

VOID RectShape :: DoneShape(HWND hwnd)
{
	ASSERT(pts.GetCount() <= 2);

	if (pts.GetCount() == 2)
		done = TRUE;
	else
		done = FALSE;
}

BOOL RectShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL RectShape :: IsComplete()
{
	return done;
}

VOID RectShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ASSERT(IsComplete());
	ASSERT(count == 2);

	if (pen && brush) 
	{
		// create appropriate rectangle
		// !! cache this?
		ERectangle rect(min(pt1->X, pt2->X),
						min(pt1->Y, pt2->Y),
						fabsf(pt1->X-pt2->X),
						fabsf(pt1->Y-pt2->Y));

		g->FillRectangle(brush->GetBrush(), rect);
		g->DrawRectangle(pen->GetPen(), rect);
	}
}

VOID RectShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	if (count < 2)
		return;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	path->AddRectangle(rect);
}

VOID RectShape :: AddToFile(OutputFile* outfile)
{
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	
	brush->AddToFile(outfile);
	
	outfile->BlankLine();
	
	outfile->RectangleDeclaration(_T("rect"), rect);

	outfile->GraphicsCommand(_T("FillRectangle"),
							 _T("%s, %s"),
							 outfile->Ref(_T("brush")),
							 _T("rect"));
	
	outfile->BlankLine();

	pen->AddToFile(outfile);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("DrawRectangle"),
							 _T("%s, %s"),
							 outfile->Ref(_T("pen")),
							 _T("rect"));
}

// Configuration management functions
BOOL RectShape :: ChangeSettings(HWND hwndParent)
{
	return TRUE;
}

VOID RectShape :: Initialize()
{
	pts.Reset();
}

VOID RectShape :: Initialize(TestShape *shape)
{
}

// Dialog management functions (not used)
VOID RectShape :: InitDialog(HWND hwnd)
{
	DebugBreak();
}

BOOL RectShape :: SaveValues(HWND hwnd)
{
	DebugBreak();
	return FALSE;
}

BOOL RectShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	DebugBreak();
	return FALSE;
}

//*******************************************************************
//
// EllipseShape
//
//
//
//*******************************************************************

BOOL EllipseShape :: AddPoint(HWND hwnd, Point pt)
{
	ASSERT(pts.GetCount() < 2);

	pts.Add(pt);

	// force complete on point pairs (rect) if possible
	DoneShape(hwnd);
	
	return TRUE;
}

VOID EllipseShape :: DoneShape(HWND hwnd)
{
	ASSERT(pts.GetCount() <= 2);

	if (pts.GetCount() == 2)
		done = TRUE;
	else
		done = FALSE;
}

BOOL EllipseShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL EllipseShape :: IsComplete()
{
	return done;
}

VOID EllipseShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ASSERT(IsComplete());
	ASSERT(count == 2);

	if (pen && brush) 
	{
		// create appropriate rectangle
		// !! cache this?
		ERectangle rect(min(pt1->X, pt2->X),
						min(pt1->Y, pt2->Y),
						fabsf(pt1->X-pt2->X),
						fabsf(pt1->Y-pt2->Y));

		g->FillEllipse(brush->GetBrush(), rect);
		g->DrawEllipse(pen->GetPen(), rect);
	}
}

VOID EllipseShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	if (count < 2) 
		return;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	path->AddEllipse(rect);
}

VOID EllipseShape :: AddToFile(OutputFile* outfile)
{
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	brush->AddToFile(outfile);

	outfile->BlankLine();

	outfile->RectangleDeclaration(_T("rect"), rect);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("FillEllipse"),
							 _T("%s, %s"),
							 outfile->Ref(_T("brush")),
							 _T("rect"));
	
	outfile->BlankLine();

	pen->AddToFile(outfile);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("DrawEllipse"),
							 _T("%s, %s"),
							 outfile->Ref(_T("pen")),
							 _T("rect"));
}

// Configuration management functions
BOOL EllipseShape :: ChangeSettings(HWND hwndParent)
{
	return TRUE;
}

VOID EllipseShape :: Initialize()
{
	pts.Reset();
}

VOID EllipseShape :: Initialize(TestShape *shape)
{
}

// Dialog management functions (not used)
VOID EllipseShape :: InitDialog(HWND hwnd)
{
	DebugBreak();
}

BOOL EllipseShape :: SaveValues(HWND hwnd)
{
	DebugBreak();
	return FALSE;
}

BOOL EllipseShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	DebugBreak();
	return FALSE;
}

//*******************************************************************
//
// PieShape
//
//
//
//*******************************************************************

BOOL PieShape :: AddPoint(HWND hwnd, Point pt)
{
	ASSERT(pts.GetCount() < 2);

	pts.Add(pt);

	// force complete on point pairs (rect) if possible
	DoneShape(hwnd);
	
	return TRUE;
}

VOID PieShape :: DoneShape(HWND hwnd)
{
	if (pts.GetCount() >= 2)
	{
		done = TRUE;

		if (popup)
		{
			// !!! cheating, we use global HWND, should use
			//     HWND passed in.
			ChangeSettings(hwnd);
		}

	}
	else
		done = FALSE;
}

BOOL PieShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL PieShape :: IsComplete()
{
	return done;
}

VOID PieShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ASSERT(IsComplete());
	ASSERT(count<2);

	if (pen && brush) 
	{
		// create appropriate rectangle
		// !! cache this?
		ERectangle rect(min(pt1->X, pt2->X),
						min(pt1->Y, pt2->Y),
						fabsf(pt1->X-pt2->X),
						fabsf(pt1->Y-pt2->Y));

		g->FillPie(brush->GetBrush(), rect, start, sweep);
		g->DrawPie(pen->GetPen(), rect, start, sweep);
	}
}

VOID PieShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	if (count < 2) 
		return;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	path->AddPie(rect, start, sweep);
}

VOID PieShape :: AddToFile(OutputFile* outfile)
{
	Point* pt1 = (Point*)pts.GetDataBuffer();
	Point* pt2 = pt1++;

	ERectangle rect(min(pt1->X, pt2->X),
					min(pt1->Y, pt2->Y),
					fabsf(pt1->X-pt2->X),
					fabsf(pt1->Y-pt2->Y));

	brush->AddToFile(outfile);

	outfile->BlankLine();

	outfile->RectangleDeclaration(_T("rect"), rect);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("FillPie"),
							 _T("%s, %s, %e, %e"),
							 outfile->Ref(_T("brush")),
							 _T("rect"),
							 start,
							 sweep);

	outfile->BlankLine();

	pen->AddToFile(outfile);

	outfile->BlankLine();
	
	outfile->GraphicsCommand(_T("DrawPie"),
							 _T("%s, %s, %e, %e"),
							 outfile->Ref(_T("pen")),
							 _T("rect"),
							 start,
							 sweep);
}

// Configuration management functions
BOOL PieShape :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_ARC_DLG),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	return ok;
}

VOID PieShape :: Initialize()
{
	sweep = 90.0f;
	start = 0.0f;
	popup = FALSE;
};

VOID PieShape :: Initialize(TestShape *shape)
{
	// if compatible, copy parameters from another compatible shape
	if (shape && shape->GetType() == GetType())
	{
		PieShape* pieshape = static_cast<PieShape*>(shape);

		sweep = pieshape->sweep;
		start = pieshape->start;
		popup = pieshape->popup;
	}
	else
		Initialize();
}

// Dialog management functions (not used)
VOID PieShape :: InitDialog(HWND hwnd)
{
	SetWindowText(hwnd, _T("Pie Shape Parameters"));

	SetDialogReal(hwnd, IDC_ARC_START, start);
	SetDialogReal(hwnd, IDC_ARC_SWEEP, sweep);
	SetDialogCheck(hwnd, IDC_ARC_POPUP, popup);
}

BOOL PieShape :: SaveValues(HWND hwnd)
{
	start = GetDialogReal(hwnd, IDC_ARC_START);
	sweep = GetDialogReal(hwnd, IDC_ARC_SWEEP);
	popup = GetDialogCheck(hwnd, IDC_ARC_POPUP);

	// no warnings, anything goes
	return FALSE;
}

BOOL PieShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
    if (msg == WM_COMMAND &&
        LOWORD(wParam) == IDC_OK)
    {
        if (SaveValues(hwnd))
            WarningBeep();
        else
            ::EndDialog(hwnd, TRUE);

        return TRUE;
    }

    return FALSE;
}

//*******************************************************************
//
// PolygonShape
//
//
//
//*******************************************************************

BOOL PolygonShape :: AddPoint(HWND hwnd, Point pt)
{
	pts.Add(pt);
	return TRUE;
}

VOID PolygonShape :: DoneShape(HWND hwnd)
{
	if (pts.GetCount()>=3)
		done = TRUE;
	else
		done = FALSE;
}

BOOL PolygonShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL PolygonShape :: IsComplete()
{
	return done;
}

VOID PolygonShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	ASSERT(IsComplete());
	ASSERT(count >= 3);

	if (pen && brush)
	{
		g->FillPolygon(brush->GetBrush(), ptbuf, count);
		g->DrawPolygon(pen->GetPen(), ptbuf, count);
	}
}

VOID PolygonShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	if (count > 2)
		path->AddPolygon(ptbuf, count);
}

VOID PolygonShape :: AddToFile(OutputFile* outfile)
{
	INT count = pts.GetCount();

	brush->AddToFile(outfile);

	outfile->BlankLine();

	outfile->PointDeclaration(_T("pts"), 
							  (Point*)pts.GetDataBuffer(),
							  count);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("FillPolygon"),
							 _T("%s, %s, %d"),
							 outfile->Ref(_T("brush")),
							 outfile->RefArray(_T("pts")),
							 count);
	
	outfile->BlankLine();

	pen->AddToFile(outfile);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("DrawPolygon"),
							 _T("%s, %s, %d"),
							 outfile->Ref(_T("pen")),
							 outfile->RefArray(_T("pts")),
							 count);
}

// Configuration management functions
BOOL PolygonShape :: ChangeSettings(HWND hwnd)
{
	return TRUE;
}

VOID PolygonShape :: Initialize()
{
	// do nothing
};

VOID PolygonShape :: Initialize(TestShape* shape)
{
	// do nothing
}

// Dialog management functions (not used)
VOID PolygonShape :: InitDialog(HWND hwnd)
{
	DebugBreak();
}

BOOL PolygonShape :: SaveValues(HWND hwnd)
{
	DebugBreak();
	return FALSE;
}

BOOL PolygonShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	DebugBreak();
	return FALSE;
}

//*******************************************************************
//
// CurveShape
//
//
//
//*******************************************************************

BOOL CurveShape :: AddPoint(HWND hwnd, Point pt)
{
	pts.Add(pt);
	
	return TRUE;
}

VOID CurveShape :: DoneShape(HWND hwnd)
{
	if (pts.GetCount() >= 2)
	{
		done = TRUE;

		if (popup)
		{
			// !!! cheating, we use global HWND, should use
			//     HWND passed in.
			ChangeSettings(hwnd);
		}

	}
	else
		done = FALSE;
}

BOOL CurveShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CurveShape :: IsComplete()
{
	return done;
}

VOID CurveShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	ASSERT(IsComplete());
	ASSERT(count<2);

	if (pen) 
	{
		g->DrawCurve(pen->GetPen(), ptbuf, count, offset, numSegments, tension);
	}
}

VOID CurveShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	if (count > 2)
		path->AddCurve(ptbuf, count, tension, offset, numSegments);
}

VOID CurveShape :: AddToFile(OutputFile* outfile)
{
	INT count = pts.GetCount();

	pen->AddToFile(outfile);

	outfile->BlankLine();

	outfile->PointDeclaration(_T("pts"),
							  (Point*)pts.GetDataBuffer(),
							  count);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("DrawCurve"),
							 _T("%s, %s, %d, %d, %d, %e"),
							 outfile->Ref(_T("pen")),
							 outfile->RefArray(_T("pts")),
							 count,
							 offset,
							 numSegments,
							 tension);
}

// Configuration management functions
BOOL CurveShape :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_CURVE_DLG),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	return ok;
}

VOID CurveShape :: Initialize()
{
	tension = 0.0;
	offset = 0;
	numSegments = 1;
	popup = FALSE;
};

VOID CurveShape :: Initialize(TestShape *shape)
{
	// if compatible, copy parameters from another compatible shape
	if (shape && shape->GetType() == GetType())
	{
		CurveShape* curveshape = static_cast<CurveShape*>(shape);

		tension = curveshape->tension;
		offset = curveshape->offset;
		numSegments = curveshape->numSegments;
		popup = curveshape->popup;
	}
	else
		Initialize();
}

// Dialog management functions (not used)
VOID CurveShape :: InitDialog(HWND hwnd)
{
	SetDialogReal(hwnd, IDC_CURVE_TENSION, tension);
	SetDialogLong(hwnd, IDC_CURVE_OFFSET, offset);
	SetDialogLong(hwnd, IDC_CURVE_SEGMENTS, numSegments);
	SetDialogCheck(hwnd, IDC_ARC_POPUP, popup);
}

BOOL CurveShape :: SaveValues(HWND hwnd)
{
	tension = GetDialogReal(hwnd, IDC_CURVE_TENSION);
	offset = GetDialogLong(hwnd, IDC_CURVE_OFFSET);
	numSegments = GetDialogLong(hwnd, IDC_CURVE_SEGMENTS);
	popup = GetDialogCheck(hwnd, IDC_ARC_POPUP);

	// !! could add some warnings...
	// no warnings, anything goes
	return FALSE;
}

BOOL CurveShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	if (msg == WM_COMMAND &&
		LOWORD(wParam) == IDC_OK)
	{
		if (SaveValues(hwnd))
			WarningBeep();
		else
			::EndDialog(hwnd, TRUE);

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// ClosedCurveShape
//
//
//
//*******************************************************************

BOOL ClosedCurveShape :: AddPoint(HWND hwnd, Point pt)
{
	pts.Add(pt);
	
	return TRUE;
}

VOID ClosedCurveShape :: DoneShape(HWND hwnd)
{
	if (pts.GetCount() >= 2)
	{
		done = TRUE;

		if (popup)
		{
			// !!! cheating, we use global HWND, should use
			//     HWND passed in.
			ChangeSettings(hwnd);
		}

	}
	else
		done = FALSE;
}

BOOL ClosedCurveShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 0)
	{
		pts.SetCount(count-1);
		done = FALSE;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL ClosedCurveShape :: IsComplete()
{
	return done;
}

VOID ClosedCurveShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	ASSERT(IsComplete());
	ASSERT(count<2);

	if (pen && brush) 
	{
		g->FillClosedCurve(brush->GetBrush(), ptbuf, count, tension, Alternate);
		g->DrawClosedCurve(pen->GetPen(), ptbuf, count, tension);
	}
}

VOID ClosedCurveShape :: AddToPath(GraphicsPath* path)
{
	ASSERT(Path);

	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	if (count > 2)
		path->AddClosedCurve(ptbuf, count, tension);
}

VOID ClosedCurveShape :: AddToFile(OutputFile* outfile)
{
	INT count = pts.GetCount();

	brush->AddToFile(outfile);

	outfile->BlankLine();

	outfile->PointDeclaration(_T("pts"),
							  (Point*)pts.GetDataBuffer(),
							  count);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("FillClosedCurve"),
							 _T("%s, %s, %d, %e, %s"),
							 outfile->Ref(_T("brush")),
							 outfile->RefArray(_T("pts")),
							 count,
							 tension,							 
							 _T("Alternate"));
	
	outfile->BlankLine();

	pen->AddToFile(outfile);
	
	outfile->BlankLine();

	outfile->GraphicsCommand(_T("DrawClosedCurve"),
							 _T("%s, %s, %d, %e"),
							 outfile->Ref(_T("pen")),
							 outfile->RefArray(_T("pts")),
							 count,
							 tension);
}

// Configuration management functions
BOOL ClosedCurveShape :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_CURVE_DLG),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	return ok;
}

VOID ClosedCurveShape :: Initialize()
{
	tension = 0.0;
	popup = FALSE;
};

VOID ClosedCurveShape :: Initialize(TestShape *shape)
{
	// if compatible, copy parameters from another compatible shape
	if (shape && shape->GetType() == GetType())
	{
		ClosedCurveShape* closedcurveshape = 
					static_cast<ClosedCurveShape*>(shape);

		tension = closedcurveshape->tension;
		popup = closedcurveshape->popup;
	}
	else
		Initialize();
}

// Dialog management functions (not used)
VOID ClosedCurveShape :: InitDialog(HWND hwnd)
{
	SetWindowText(hwnd, _T("Closed Curve Shape Parameters"));
	SetDialogReal(hwnd, IDC_CURVE_TENSION, tension);
	SetDialogLong(hwnd, IDC_CURVE_OFFSET, 0, FALSE);
	SetDialogLong(hwnd, IDC_CURVE_SEGMENTS, 0, FALSE);
	SetDialogCheck(hwnd, IDC_ARC_POPUP, popup);
}

BOOL ClosedCurveShape :: SaveValues(HWND hwnd)
{
	tension = GetDialogReal(hwnd, IDC_CURVE_TENSION);
	popup = GetDialogCheck(hwnd, IDC_ARC_POPUP);

	// no warnings, anything goes
	return FALSE;
}

BOOL ClosedCurveShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	if (msg == WM_COMMAND &&
		LOWORD(wParam) == IDC_OK)
	{
		if (SaveValues(hwnd))
			WarningBeep();
		else
			::EndDialog(hwnd, TRUE);

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestTriangleGradShape
//
//
//
//*******************************************************************

BOOL TestTriangleGradShape :: AddPoint(HWND hwnd, Point pt)
{
	return FALSE;
}

VOID TestTriangleGradShape :: DoneShape(HWND hwnd)
{
	DebugBreak();
}

BOOL TestTriangleGradShape :: EndPoint(HWND hwnd, Point pt)
{
	curIndex = FindControlPoint(pt);

	// we aren't at a control point, no dialog box
	if (curIndex < 0)
	{
		WarningBeep();
	}
	else
	{
		// pop-up dialog to configure color & blend at this point.
		return ChangeSettings(hwnd);
	}

	return FALSE;
}

BOOL TestTriangleGradShape :: RemovePoint(HWND hwnd)
{
	return FALSE;
}

BOOL TestTriangleGradShape :: IsComplete()
{
	return TRUE;
}

BOOL TestTriangleGradShape :: MoveControlPoint(Point origPt, Point newPt)
{
	INT pos = 0;

	// !!! what if multiple control points overlap?
	//     can't get to one of them
	for (pos = 0; pos<3; pos++)
	{
		Point *ctrlPt = &pts[pos];

		ERectangle ctrlRect(ctrlPt->X-pointRadius,
							ctrlPt->Y-pointRadius,
							2*pointRadius,
							2*pointRadius);

		if (origPt.X>ctrlPt->X-pointRadius &&
			origPt.X<ctrlPt->X+pointRadius &&
			origPt.Y>ctrlPt->Y-pointRadius &&
			origPt.Y<ctrlPt->Y+pointRadius)
		{
			ctrlPt->X = newPt.X;
			ctrlPt->Y = newPt.Y;

			gdiBrush->SetTriangle(&pts[0]);

			return TRUE;
		}
	}

	return FALSE;
}

VOID TestTriangleGradShape :: DrawShape(Graphics* g)
{
	if (gdiBrush)
		g->FillPolygon(gdiBrush, (Point*)&pts[0], 3);
}

// Configuration management functions
BOOL TestTriangleGradShape :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_TRIGRAD_DLG2),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	if (ok)
	{
		// !! really only need to set one blend & color, but
		//    the API requires we set all three.

		gdiBrush->SetBlend0(blend[0], count[0]);
		gdiBrush->SetBlend1(blend[1], count[1]);
		gdiBrush->SetBlend2(blend[2], count[2]);
	
		Color colors[3] =
		{
			Color(argb[0]),
			Color(argb[1]),
			Color(argb[2])
		};

		gdiBrush->SetColors(&colors[0]);

		gdiBrush->SetTriangle(&pts[0]);
	}

	return ok;
}

VOID TestTriangleGradShape :: Initialize()
{
	DebugBreak();
};

VOID TestTriangleGradShape :: Initialize(TestShape* shape)
{
	DebugBreak();
}	

VOID TestTriangleGradShape :: Initialize(Point* newPts,
										 ARGB* newArgb,
										 REAL** newBlend,
										 INT* newBlendCount)
{
	Color color[3];

	pts.Reset();
	argb.Reset();

	for (INT i = 0; i < 3; i++)
	{
		pts.Add(newPts[i]);
		argb.Add(newArgb[i]);

		count[i] = newBlendCount[i];

		if (count[i])
		{
			blend[i] = (REAL*) malloc(sizeof(REAL)*count[i]);
			memcpy(blend[i], newBlend[i], sizeof(REAL)*count[i]);
		}
		else
			blend[i] = NULL;

		color[i] = Color(argb[i]);
	}

	gdiBrush = new TriangleGradientBrush(newPts, &color[0]);

	gdiBrush->SetBlend0(blend[0], count[0]);
	gdiBrush->SetBlend1(blend[1], count[1]);
	gdiBrush->SetBlend2(blend[2], count[2]);
}

// Dialog management functions (not used)
VOID TestTriangleGradShape :: InitDialog(HWND hwnd)
{
	tmpArgb = argb[curIndex];

	SetDialogLong(hwnd, IDC_TRIGRAD_ALPHA, (tmpArgb & Color::AlphaMask) >> Color::AlphaShift);
	SetDialogRealList(hwnd, IDC_TRIGRAD_BLEND, blend[curIndex], count[curIndex]);
}

BOOL TestTriangleGradShape :: SaveValues(HWND hwnd)
{
	argb[curIndex] = ((tmpArgb & ~Color::AlphaMask) |
						(GetDialogLong(hwnd, IDC_TRIGRAD_ALPHA) 
							<< Color::AlphaShift));

	if (count[curIndex] > 0) 
		free(blend[curIndex]);

	GetDialogRealList(hwnd, IDC_TRIGRAD_BLEND, &(blend[curIndex]), 
											   &(count[curIndex]));
	return FALSE;
}

BOOL TestTriangleGradShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_TRIGRAD_COLORBUTTON:
			UpdateRGBColor(hwnd, IDC_TRIGRAD_PIC, tmpArgb);
			break;

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_TRIGRAD_PIC, tmpArgb);
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

//*******************************************************************
//
// TestPathGradShape
//
//
//
//*******************************************************************

BOOL TestPathGradShape :: AddPoint(HWND hwnd, Point pt)
{
	// Find point pair to insert between
	// INT insertAt = FindLocationToInsert(pt);

	curIndex = pts.GetCount();

	pts.Add(pt);
	argb.Add(0x80000000);

	if(!ChangeSettings(hwnd))
	{
		// undo this add, we canceled the point.
		pts.SetCount(curIndex);
	}

	return FALSE;
}

VOID TestPathGradShape :: DoneShape(HWND hwnd)
{
	DebugBreak();
}

BOOL TestPathGradShape :: EndPoint(HWND hwnd, Point pt)
{
	curIndex = FindControlPoint(pt);

	// we aren't at a control point, no dialog box
	if (curIndex < 0)
	{
		WarningBeep();
	}
	else
	{
		// pop-up dialog to configure color & blend at this point.
		return ChangeSettings(hwnd);
	}

	return FALSE;
}

BOOL TestPathGradShape :: RemovePoint(HWND hwnd)
{
	INT count = pts.GetCount();

	if (count > 4)
	{
		pts.SetCount(count-1);
		return TRUE;
	}
	else
		return FALSE;
}

BOOL TestPathGradShape :: IsComplete()
{
	return TRUE;
}

BOOL TestPathGradShape :: MoveControlPoint(Point origPt, Point newPt)
{
	INT count = pts.GetCount();
	INT pos = 0;

	// !!! what if multiple control points overlap?
	//     can't get to one of them
	for (pos = 0; pos<count; pos++)
	{
		Point *ctrlPt = &pts[pos];

		ERectangle ctrlRect(ctrlPt->X-pointRadius,
							ctrlPt->Y-pointRadius,
							2*pointRadius,
							2*pointRadius);

		if (origPt.X>ctrlPt->X-pointRadius &&
			origPt.X<ctrlPt->X+pointRadius &&
			origPt.Y>ctrlPt->Y-pointRadius &&
			origPt.Y<ctrlPt->Y+pointRadius)
		{
			ctrlPt->X = newPt.X;
			ctrlPt->Y = newPt.Y;

			if (pos > 0)
				gdiBrush->SetPoint(ctrlPt,pos-1);
			else
				gdiBrush->SetCenterPoint(*ctrlPt);

			return TRUE;
		}
	}

	return FALSE;
}

VOID TestPathGradShape :: DrawShape(Graphics* g)
{
	INT count = pts.GetCount();
	Point* ptbuf = (Point*)pts.GetDataBuffer();

	if (gdiBrush)
		g->FillPolygon(gdiBrush, (Point*)&pts[1], count-1);
}

// Configuration management functions
BOOL TestPathGradShape :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_POLYGRAD_DLG2),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	if (ok)
	{
		delete gdiBrush;

		gdiBrush = new PathGradientBrush((Point*)&pts[1], 
										pts.GetCount()-1);

		// set blending factors
		gdiBrush->SetBlend(centerBlend, centerCount);
		//gdiBrush->SetSurroundBlend(surroundBlend, surroundCount);

		// set colors
		Color center(argb[0]);
		gdiBrush->SetCenterColor(center);

		for (INT pos = 1; pos < pts.GetCount(); pos++)
		{
			Color color(argb[pos]);
			gdiBrush->SetSurroundColor(color, pos-1);
		}

		// set points
		gdiBrush->SetCenterPoint(pts[0]);
		gdiBrush->SetPolygon(&pts[1]);
	}

	return ok;
}

VOID TestPathGradShape :: Initialize()
{
	DebugBreak();
};

VOID TestPathGradShape :: Initialize(TestShape* shape)
{
	DebugBreak();
}	

VOID TestPathGradShape :: Initialize(PointArray* newPts,
										ARGBArray* newArgb,
										REAL* newSurroundBlend,
										INT newSurroundCount,
										REAL* newCenterBlend,
										INT newCenterCount)
{
	INT pos;

	pts.Reset();
	argb.Reset();
	
	for (pos = 0; pos < newPts->GetCount(); pos++)
	{
		pts.Add((*newPts)[pos]);
		argb.Add((*newArgb)[pos]);
	}

	surroundCount = newSurroundCount;
	centerCount = newCenterCount;

	if (surroundCount && newSurroundBlend)
	{
		surroundBlend = (REAL*) malloc(sizeof(REAL)*surroundCount);
		memcpy(surroundBlend, newSurroundBlend, sizeof(REAL)*surroundCount);
	}
	else
		surroundBlend = NULL;
	
	if (centerCount && newCenterBlend)
	{
		centerBlend = (REAL*) malloc(sizeof(REAL)*centerCount);
		memcpy(centerBlend, newCenterBlend, sizeof(REAL)*centerCount);
	}
	else
		centerBlend = NULL;

	gdiBrush = new PathGradientBrush((Point*)&pts[1], 
										newPts->GetCount()-1);

	gdiBrush->SetCenterPoint(pts[0]);
	Color centerColor(argb[0]);
	gdiBrush->SetCenterColor(centerColor);

	for (pos = 1; pos < pts.GetCount(); pos++)
	{
		Color color(argb[pos]);
		gdiBrush->SetSurroundColor(color, pos-1);
	}

	// set blending factors
	gdiBrush->SetBlend(centerBlend, centerCount);
	//gdiBrush->SetSurroundBlend(surroundBlend, surroundCount);
}

// Dialog management functions (not used)
VOID TestPathGradShape :: InitDialog(HWND hwnd)
{
	tmpArgb = argb[curIndex];

	SetDialogLong(hwnd, IDC_POLYGRAD_ALPHA, (tmpArgb & Color::AlphaMask) >> Color::AlphaShift);

	if (curIndex)
	{
		SetDialogRealList(hwnd, 
						  IDC_POLYGRAD_BLEND,
						  surroundBlend, 
						  surroundCount);
	}
	else
	{
		SetDialogRealList(hwnd, 
						  IDC_POLYGRAD_BLEND, 
						  centerBlend, 
						  centerCount);
	}

}

BOOL TestPathGradShape :: SaveValues(HWND hwnd)
{
	argb[curIndex] = ((tmpArgb & ~Color::AlphaMask) |
						(GetDialogLong(hwnd, IDC_POLYGRAD_ALPHA) 
							<< Color::AlphaShift));

	if (curIndex)
	{
		if (surroundBlend)
			free(surroundBlend);

		GetDialogRealList(hwnd, IDC_POLYGRAD_BLEND, &surroundBlend, 
												    &surroundCount);
	}
	else
	{
		if (centerBlend)
			free(centerBlend);
		
		GetDialogRealList(hwnd, IDC_POLYGRAD_BLEND, &centerBlend,
													&centerCount);
	}

	return FALSE;
}

BOOL TestPathGradShape :: ProcessDialog(HWND hwnd, 
					UINT msg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_POLYGRAD_COLORBUTTON:
			UpdateRGBColor(hwnd, IDC_POLYGRAD_PIC, tmpArgb);
			break;

		case IDC_REFRESH_PIC:
			UpdateColorPicture(hwnd, IDC_POLYGRAD_PIC, tmpArgb);
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	gdiptest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

#include "gdiptest.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdiputils.cpp ===
#include "gdiptest.h"

//*******************************************************************
//
// AllBrushDialog 
//
//
//
//*******************************************************************

inline VOID NotImplementedBox()
{
	MessageBox(NULL, _T("Not Implemented") , _T(""),MB_OK);
};

inline VOID WarningBox(TCHAR* string)
{
	MessageBox(NULL, string, _T(""), MB_OK);
};

VOID WarningBeep()
{
	Beep(5000 /* hertz */, 400 /* milliseconds */);
}

Brush* blackBrush = NULL;
Brush* backBrush = NULL;
Pen* blackPen = NULL;
Color* blackColor = NULL;

	const TCHAR* tabStr = _T("    ");

	const TCHAR* formatList[numFormats] =
	{
		_T("CPP File"),
		_T("Java File"),
		_T("VML File")
	};

	const FormatType formatValue[numFormats] =
	{
		CPPFile,
		JavaFile,
		VMLFile
	};

	const TCHAR* shapeList[numShapes] =
	{
		_T("Line"),
		_T("Arc"),
		_T("Bezier"),
		_T("Rectangle"),
		_T("Ellipse"),
		_T("Pie"),
		_T("Polygon"),
		_T("Curve (Spline)"),
		_T("Closed Curve")
	};

	const INT shapeValue[numShapes] =
	{
		LineType,
		ArcType,
		BezierType,
		RectType,
		EllipseType,
		PieType,
		PolygonType,
		CurveType,
		ClosedCurveType
	};
		
	const INT inverseShapeValue[numShapes] =	// index by ShapeType
	{
		0,
		1,
		2,
		3,
		4,
		5,
		6,
		7,
		8
	};

	const TCHAR* brushList[numBrushes] =
	{
		_T("Solid"),
		_T("Texture (Bitmap)"),
		_T("Rectangle Gradient"),
		_T("Radial Gradient"),
		_T("Triangle Gradient"),
		_T("Polygon Gradient"),
		_T("Hatch")	
	};

	const INT brushValue[numBrushes] = 
	{
		SolidColorBrush,
		TextureFillBrush,
		RectGradBrush,
		RadialGradBrush,
		TriangleGradBrush,
		PathGradBrush,
		HatchFillBrush
	};

	const INT inverseBrushValue[numBrushes] = // index by BrushType
	{
		0,
		6,
		1,
		2,
		3,
		4,
		5
	};

	const TCHAR* capList[numCaps] = 
	{ 
		_T("Square"),
		_T("Round"),
		_T("Flat"),
		_T("Arrow"),
		_T("Diamond"),
		_T("Round") 
	};
	
	const TCHAR* capStr[numCaps] = 
	{ 
		_T("SquareCap"),
		_T("RoundCap"),
		_T("FlatCap"),
		_T("ArrowAnchor"),
		_T("DiamondAnchor"),
		_T("RoundAnchor") 
	};
	
	const LineCap capValue[numCaps] = 
	{
		SquareCap,
		RoundCap,
		FlatCap,
		ArrowAnchor,
		DiamondAnchor,
		RoundAnchor
	};

	const TCHAR* dashCapList[numDashCaps] = 
	{ 
		_T("Flat"),
		_T("Round"),
		_T("Triangle")
	};
	
	const TCHAR* dashCapStr[numDashCaps] = 
	{ 
		_T("FlatCap"),
		_T("RoundCap"),
		_T("TriangleCap")
	};
	
	const DashCap dashCapValue[numDashCaps] = 
	{
		FlatCap,
		RoundCap,
		TriangleCap
	};

	const TCHAR* joinList[numJoin] =
	{
		_T("Miter"),
		_T("Round"),
		_T("Bevel")
	};
	
	const TCHAR* joinStr[numJoin] =
	{
		_T("MiterJoin"),
		_T("RoundJoin"),
		_T("BevelJoin")
	};

	const LineJoin joinValue[numJoin] =
	{
		MiterJoin,
		RoundJoin,
		BevelJoin
	};

	const TCHAR* dashList[numDash] =
	{
		_T("Solid"),
		_T("Dash"),
		_T("Dot"),
		_T("Dash Dot"),
		_T("Dash Dot Dot")
	};

	const TCHAR* dashStr[numDash] =
	{
		_T("Solid"),
		_T("Dash"),
		_T("Dot"),
		_T("DashDot"),
		_T("DashDotDot")
	};

	const DashStyle dashValue[numDash] =
	{
		Solid,
		Dash,
		Dot,
		DashDot,
		DashDotDot
	};

	const TCHAR* wrapList[numWrap] =
	{
		_T("Tile"),
		_T("Tile Flip X"),
		_T("Tile Flip Y"),
		_T("Tile Flip XY"),
		_T("Clamp"),
		_T("Extrapolate")
	};

	const TCHAR* wrapStr[numWrap] =
	{
		_T("Tile"),
		_T("TileFlipX"),
		_T("TileFlipY"),
		_T("TileFlipXY"),
		_T("Clamp"),
		_T("Extrapolate")
	};

	const WrapMode wrapValue[numWrap] =
	{
		Tile,
		TileFlipX,
		TileFlipY,
		TileFlipXY,
		Clamp,
		Extrapolate
	};

	const TCHAR* hatchList[numHatch] =
	{
		_T("Forward Diagonal"),
		_T("Backward Diagonal"),
		_T("Cross"),
		_T("Diagonal Cross"),
		_T("Horizontal"),
		_T("Vertical")
	};

	const TCHAR* hatchStr[numHatch] =
	{
		_T("ForwardDiagonal"),
		_T("BackwardDiagonal"),
		_T("Cross"),
		_T("DiagonalCross"),
		_T("Horizontal"),
		_T("Vertical")
	};

	const HatchStyle hatchValue[numHatch] =
	{
		ForwardDiagonal,
		BackwardDiagonal,
		Cross,
		DiagonalCross,
		Horizontal,
		Vertical
	};

VOID SetDialogLong(HWND hwnd, UINT idc, UINT value, BOOL enable)
{
	HWND hwndControl;
	TCHAR tmp[256];

	hwndControl = GetDlgItem(hwnd, idc);
	_stprintf(tmp, _T("%ld"), value);
	SendMessage(hwndControl, WM_SETTEXT, 0, (LPARAM)&tmp[0]);

	EnableWindow(hwndControl, enable);

	DeleteObject(hwndControl);
}

UINT GetDialogLong(HWND hwnd, UINT idc)
{
	HWND hwndControl;
	TCHAR tmp[256];
	UINT value = 0;

	hwndControl = GetDlgItem(hwnd, idc);
	SendMessage(hwndControl, WM_GETTEXT, 255, (LPARAM)&tmp[0]);
	_stscanf(tmp,_T("%ld"), &value);

	DeleteObject(hwndControl);

	return value;
}

VOID SetDialogText(HWND hwnd, UINT idc, LPTSTR text, BOOL enable)
{
	HWND hwndControl;

	hwndControl = GetDlgItem(hwnd, idc);

	SendMessage(hwndControl, WM_SETTEXT, 0, (LPARAM)text);

	EnableWindow(hwndControl, enable);

	DeleteObject(hwndControl);
}

VOID GetDialogText(HWND hwnd, UINT idc, LPTSTR text, INT maxSize)
{
	HWND hwndControl;
	UINT value = 0;

	hwndControl = GetDlgItem(hwnd, idc);
	SendMessage(hwndControl, WM_GETTEXT, maxSize, (LPARAM)text);

	DeleteObject(hwndControl);
}

VOID SetDialogReal(HWND hwnd, UINT idc, REAL value)
{
	HWND hwndControl;
	TCHAR tmp[256];

	hwndControl = GetDlgItem(hwnd, idc);
	_stprintf(tmp, _T("%8.3f"), value);
	SendMessage(hwndControl, WM_SETTEXT, 0, (LPARAM)&tmp[0]);

	DeleteObject(hwndControl);
}

REAL GetDialogReal(HWND hwnd, UINT idc)
{
	HWND hwndControl;
	TCHAR tmp[256];
	REAL value = 0.0f;

	hwndControl = GetDlgItem(hwnd, idc);
	SendMessage(hwndControl, WM_GETTEXT, 255, (LPARAM)&tmp[0]);
	_stscanf(tmp, _T("%f"), &value);

	DeleteObject(hwndControl);

	return value;
}

VOID SetDialogRealList(HWND hwnd, UINT idc, REAL* blend, INT count)
{
	HWND hwndControl;
	TCHAR buf[4*MAX_PATH];
	TCHAR tmp[MAX_PATH];

	hwndControl = GetDlgItem(hwnd, idc);

	buf[0] = _T('\0');

	for (INT i = 0; i < count; i++)
	{
		_stprintf(tmp, _T("%.2f"), blend[i]);
		_tcscat(buf, tmp);
		if (i != count-1)
			_tcscat(buf, _T(" "));
	}

	SendMessage(hwndControl, WM_SETTEXT, 0, (LPARAM)buf);

	DeleteObject(hwndControl);
}

VOID GetDialogRealList(HWND hwnd, UINT idc, REAL** blend, INT *count)
{
	HWND hwndControl;
	TCHAR buf[4*MAX_PATH];
	TCHAR* curpos = &buf[0];
	REAL value;
	INT pos;

	const LPTSTR seps = _T(" \n\r,\t");

	hwndControl = GetDlgItem(hwnd, idc);
	SendMessage(hwndControl, WM_GETTEXT, 4*MAX_PATH, (LPARAM)buf);

	INT newCount = 0;

	curpos = _tcstok(&buf[0], seps);

	// find number of real values in list
	while (curpos)
	{
		if ((curpos[0] >= '0' && curpos[0] <= '9') ||
			curpos[0] == '.')
		{
			newCount++;
		}

		curpos = _tcstok(NULL, seps);
	}

	// !! caller must free the old blend factor memory
	//if (*count && *blend)
	//	free(*blend);

	if (!newCount)
	{
		*count = newCount;
		*blend = NULL;
		return;
	}

	SendMessage(hwndControl, WM_GETTEXT, 4*MAX_PATH, (LPARAM)buf);

	*count = newCount;
	*blend = (REAL*) malloc(sizeof(REAL)*newCount);

	// extract actual values from the list.
	pos = 0;

	curpos = _tcstok(&buf[0], seps);

	while (curpos != NULL)
	{
		if ((curpos[0] >= '0' && curpos[0] <= '9') ||
			curpos[0] == '.')
		{
			ASSERT(pos < newCount);
			if (pos >= newCount)
				DebugBreak();

			_stscanf(curpos, _T("%f"), &value);
			(*blend)[pos] = value;
			pos++;
		}

		curpos = _tcstok(NULL, seps);
	}

	DeleteObject(hwndControl);
}

VOID SetDialogCombo(HWND hwnd, UINT idc, const TCHAR* strings[], INT count, INT cursel)
{
	HWND hwndControl;

	// !!! use SendDlgItemMessage instead

	hwndControl = GetDlgItem(hwnd, idc);
	for (INT i=0; i<count; i++)
		SendMessage(hwndControl, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)strings[i]);

	SendMessage(hwndControl, CB_SETCURSEL, cursel, 0);

	DeleteObject(hwndControl);
}

INT GetDialogCombo(HWND hwnd, UINT idc)
{
	HWND hwndControl;

	hwndControl = GetDlgItem(hwnd, idc);

	INT cursel = SendMessage(hwndControl, CB_GETCURSEL, 0, 0);

	DeleteObject(hwndControl);

	return cursel;
}


VOID SetDialogCheck(HWND hwnd, UINT idc, BOOL checked)
{
	HWND hwndControl;

	hwndControl = GetDlgItem(hwnd, idc);
	SendMessage(hwndControl, BM_SETCHECK, (WPARAM)
					checked ? BST_CHECKED : BST_UNCHECKED, 0);
	DeleteObject(hwndControl);
}

BOOL GetDialogCheck(HWND hwnd, UINT idc)
{
	HWND hwndControl;
	BOOL checked = FALSE;

	hwndControl = GetDlgItem(hwnd, idc);
	checked = SendMessage(hwndControl, BM_GETCHECK, 0, 0);
	DeleteObject(hwndControl);

	return checked;
}

VOID EnableDialogControl(HWND hwnd, INT idc, BOOL enable)
{
	HWND hwndCtrl = GetDlgItem(hwnd, idc);
	EnableWindow(hwndCtrl, enable);
	DeleteObject(hwndCtrl);
}

VOID SetMenuCheck(HWND hwnd, INT menuPos, UINT idm, BOOL checked, BOOL byCmd)
{
	HMENU hmenu = GetMenu(hwnd);
	HMENU otherHmenu = GetSubMenu(hmenu, menuPos);

	CheckMenuItem(otherHmenu, idm, 
		(byCmd ? MF_BYCOMMAND : MF_BYPOSITION) |
		(checked ? MF_CHECKED : MF_UNCHECKED));

	DeleteObject(hmenu);
	DeleteObject(otherHmenu);
}

VOID UpdateColorPicture(HWND hwnd, INT idc, ARGB argb)
{
	LOGBRUSH lb;
	lb.lbStyle = BS_SOLID;
	lb.lbColor = ((argb & Color::RedMask) >> Color::RedShift) |
				 ((argb & Color::GreenMask)) |
				 ((argb & Color::BlueMask) << Color::RedShift);
	lb.lbHatch = NULL;

	HWND hwndPic = GetDlgItem(hwnd, idc);

	HDC hdc = GetDC(hwndPic);

	HBRUSH hbr = CreateBrushIndirect(&lb);
	ASSERT(hbr);

	HBRUSH hbrOld = (HBRUSH) SelectObject(hdc, hbr);

	RECT rect;
	GetClientRect(hwndPic, &rect);

	FillRect(hdc, &rect, hbr);

	SelectObject(hdc, hbrOld);

	InvalidateRect(hwndPic, NULL, TRUE);

	DeleteObject(hbr);
	DeleteObject(hdc);
	DeleteObject(hwndPic);
}

VOID UpdateRGBColor(HWND hwnd, INT idcPic, ARGB& argb)
{
	static COLORREF custColor[16]
		= { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };

	CHOOSECOLOR chooseColor =
	{
		sizeof(CHOOSECOLOR),
		hwnd,
		0,
		argb & ~Color::AlphaMask,
		(COLORREF*)&custColor[0],
		CC_ANYCOLOR | CC_FULLOPEN | CC_RGBINIT,
		0,
		0,
		0
	};

	if (ChooseColor(&chooseColor))
	{
		// COLORREF & ARGB reverse Red and Blue position
		argb = ((chooseColor.rgbResult & 0x0000FF) << 16) |
			   ((chooseColor.rgbResult & 0x00FF00)) |
			   ((chooseColor.rgbResult & 0xFF0000) >> 16);

		UpdateColorPicture(hwnd, idcPic, argb);
	}
};
/*
VOID OutputRectangle(FILE* file, INT formatType, ERectangle* rect)
{
	switch(formatType)
	{
	case CPPFile:
		_ftprintf(file,
				  _T(tabStr tabStr tabStr
				     "ERectangle rect(%e, %e,\n"
					 tabStr tabStr tabStr
					 "                %e, %e);\n",
					 rect.X, rect.Y, rect.Width, rect.Height);
		break;

	case JavaFile:
		_ftprintf(file,
				  _T(tabStr tabStr tabStr
				     "Rectangle rect = new Rectangle(%e, %e,\n"
					 tabStr tabStr tabStr
					 "                               %e, %e);\n",
					 rect.X, rect.Y, rect.Width, rect.Height);
		break;

	case VMLFile:
		break;
	}
}


VOID OutputPointList(FILE* file, INT formatType, Point* pts, INT count)
{
	INT cnt;

	switch(formatType)
	{
	case CPPFile:
		_ftprintf(file, 
				  _T(tabStr tabStr tabStr 
							"Point pts[%d];\n"),
				  count);

		for (cnt = 0; cnt < count; cnt++)
			_ftprintf(file, 
					  _T(tabStr tabStr tabStr
							"pts[%d].X = %e; "
			                "pts[%d].Y = %e;\n"),
							cnt, pts[cnt].X,
							cnt, pts[cnt].Y);
		break;

	case JavaFile:
		_ftprintf(file, 
				  _T(tabStr tabStr tabStr
							"Point[] pts = new Point[%d]\n"),
					 count);

		for (cnt = 0; cnt < count; cnt++)
			_ftprintf(file, 
					  _T(tabStr tabStr tabStr 
					     "pts[%d] = new Point(%e, %e)\n"),
						 cnt, pts[cnt].X, pts[cnt].Y);
		break;

	case VMLFile:
		break;
	}
};
*/
//*******************************************************************
//
// TestTransform
//
//*******************************************************************

BOOL TestTransform :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_MATRIX_DLG),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	if (ok)
	{
		REAL m[6];
		
		// !! This is bad inconsistency in matrix API
		matrix->GetElements(&m[0]);
		(*origMatrix)->SetElements(m[0], m[1], m[2], m[3], m[4], m[5]);
	}

	return ok;
}

VOID TestTransform :: Initialize()
{
	DebugBreak();
}

VOID TestTransform :: Initialize(Matrix **newMatrix)
{
	origMatrix = newMatrix;
	if (*newMatrix)
		matrix = (*newMatrix)->Clone();
	else
		matrix = new Matrix();
}

VOID TestTransform :: EnableDialogButtons(HWND hwnd, BOOL enable)
{
	EnableDialogControl(hwnd, IDC_MATRIX_RESET, enable);
	EnableDialogControl(hwnd, IDC_MATRIX_TRANSLATE, enable);
	EnableDialogControl(hwnd, IDC_MATRIX_SCALE, enable);
	EnableDialogControl(hwnd, IDC_MATRIX_ROTATE, enable);
	EnableDialogControl(hwnd, IDC_MATRIX_SHEAR, enable);
	EnableDialogControl(hwnd, IDC_MATRIX_INVERT, enable);
	EnableDialogControl(hwnd, IDC_OK, enable);
	EnableDialogControl(hwnd, IDC_CANCEL, enable);
}

VOID TestTransform :: UpdateTransformPicture(HWND hwnd, 
											 INT idc, 
											 Matrix* matrix)
{
	INT pos;
	Matrix tmpMatrix;

	// get client rectangle of picture area
	HWND hwndPic = GetDlgItem(hwnd, idc);
	RECT rect;
	GetClientRect(hwndPic, &rect);

	Graphics *g = new Graphics(hwndPic);

	ERectangle bound(REAL_MAX, REAL_MAX, -REAL_MAX, -REAL_MAX);
	
	ERectangle rectf(rect.left,	rect.top,
					 rect.right - rect.left,
					 rect.bottom - rect.top);

	Point pts[4] =
	{
		Point(rectf.X-rectf.Width/2, rectf.Y-rectf.Height/2),
		Point(rectf.X+rectf.Width/2, rectf.Y-rectf.Height/2),
		Point(rectf.X+rectf.Width/2, rectf.Y+rectf.Height/2),
		Point(rectf.X-rectf.Width/2, rectf.Y+rectf.Height/2)
	};

	matrix->TransformPoints(&pts[0], 4);

	// compute bounding box of transformed rectangle
	for (pos=0; pos < 4; pos++)
	{
		if (pts[pos].X < bound.GetLeft())
		{
			bound.Width += fabsf(pts[pos].X-bound.GetLeft());
			bound.X = pts[pos].X;
		}

		if (pts[pos].X > bound.GetRight())
			bound.Width = fabsf(pts[pos].X-bound.GetLeft());

		// on screen, y positive goes downward
		// instead of the traditional upward

		if (pts[pos].Y < bound.GetTop())
		{
			bound.Height += fabsf(pts[pos].Y-bound.GetTop());
			bound.Y = pts[pos].Y;
		}
		
		if (pts[pos].Y > bound.GetBottom())
			bound.Height = fabsf(pts[pos].Y-bound.GetTop());
	}

	// translate relative to the origin
	tmpMatrix.Translate(-((bound.GetLeft()+bound.GetRight())/2),
						 -((bound.GetTop()+bound.GetBottom())/2),
						 AppendOrder);

	// scale to fit our rectangle
	REAL scale = min((rectf.Width-30.0f)/bound.Width,
					 (rectf.Height-30.0f)/bound.Height);

	tmpMatrix.Scale(scale, scale, AppendOrder);

	// translate relative to center of our rectangle
	tmpMatrix.Translate(rectf.Width/2, 
						rectf.Height/2,
						AppendOrder);

	// transform our points by tmpMatrix
	tmpMatrix.TransformPoints(&pts[0], 4);

	// opaque colors RED & BLACK
	Color redColor(0xFF000000 | Color::Red);
	SolidBrush redBrush(redColor);

	Color blackColor(0xFF000000 | Color::Black);
	SolidBrush myBlackBrush(blackColor);

	g->FillRectangle(&myBlackBrush, rectf);
	g->FillPolygon(&redBrush, &pts[0], 4);

	delete g;
}

VOID TestTransform :: InitDialog(HWND hwnd)
{
	REAL m[6];
		
	matrix->GetElements(&m[0]);

	SetDialogReal(hwnd, IDC_MATRIX_M11, m[0]);
	SetDialogReal(hwnd, IDC_MATRIX_M12, m[1]);
	SetDialogReal(hwnd, IDC_MATRIX_M13, 0.0f);
	SetDialogReal(hwnd, IDC_MATRIX_M21, m[2]);
	SetDialogReal(hwnd, IDC_MATRIX_M22, m[3]);
	SetDialogReal(hwnd, IDC_MATRIX_M23, 0.0f);
	SetDialogReal(hwnd, IDC_MATRIX_M31, m[4]);
	SetDialogReal(hwnd, IDC_MATRIX_M32, m[5]);
	SetDialogReal(hwnd, IDC_MATRIX_M33, 1.0f);

	EnableDialogControl(hwnd, IDC_MATRIX_M13, FALSE);
	EnableDialogControl(hwnd, IDC_MATRIX_M23, FALSE);
	EnableDialogControl(hwnd, IDC_MATRIX_M33, FALSE);

	SetDialogCheck(hwnd, IDC_MATRIX_PREPEND, 
		*matrixPrepend == PrependOrder ? TRUE : FALSE);

	UpdateTransformPicture(hwnd, IDC_MATRIX_PIC, matrix);
}

BOOL TestTransform :: SaveValues(HWND hwnd)
{
	*matrixPrepend = (GetDialogCheck(hwnd, IDC_MATRIX_PREPEND) == TRUE ?
							PrependOrder : AppendOrder);

	matrix->SetElements(GetDialogReal(hwnd, IDC_MATRIX_M11),
						GetDialogReal(hwnd, IDC_MATRIX_M12),
						GetDialogReal(hwnd, IDC_MATRIX_M21),
						GetDialogReal(hwnd, IDC_MATRIX_M22),
						GetDialogReal(hwnd, IDC_MATRIX_M31),
						GetDialogReal(hwnd, IDC_MATRIX_M32));

	// !! check for singular matrix ??
	return FALSE;
}

BOOL TestTransform :: ProcessDialog(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	if (msg == WM_COMMAND)
	{
		switch(LOWORD(wParam))
		{
		case IDC_OK:
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);
			break;

		case IDC_MATRIX_RESET:
			matrix->Reset();
			InitDialog(hwnd);
			break;

		case IDC_MATRIX_TRANSLATE:
			{
				EnableDialogButtons(hwnd, FALSE);
				
				TestMatrixOperation matrixOp;

				matrixOp.Initialize(_T("Translate Matrix Operation"),
									_T("Translate"),
									_T("Translate points by X and Y"),
									2);

				if (matrixOp.ChangeSettings(hwnd))
				{
					matrix->Translate(matrixOp.GetX(),
									  matrixOp.GetY(),
									  *matrixPrepend);
					
					// redisplay dialog entries
					InitDialog(hwnd);
				}

				EnableDialogButtons(hwnd, TRUE);
			}
			break;

		case IDC_MATRIX_SCALE:
			{
				EnableDialogButtons(hwnd, FALSE);
				
				TestMatrixOperation matrixOp;

				matrixOp.Initialize(_T("Scale Matrix Operation"),
									_T("Scale"),
									_T("Scale points by X and Y"),
									2);

				if (matrixOp.ChangeSettings(hwnd))
				{
					matrix->Scale(matrixOp.GetX(),
								  matrixOp.GetY(),
								  *matrixPrepend);
					
					// redisplay dialog entries
					InitDialog(hwnd);
				}

				EnableDialogButtons(hwnd, TRUE);
			}
			break;

		case IDC_MATRIX_ROTATE:
			{
				EnableDialogButtons(hwnd, FALSE);
				
				TestMatrixOperation matrixOp;

				matrixOp.Initialize(_T("Rotate Matrix Operation"),
									_T("Rotate"),
									_T("Rotate points by angle"),
									1);

				if (matrixOp.ChangeSettings(hwnd))
				{
					matrix->Rotate(matrixOp.GetX(),
								   *matrixPrepend);
					
					// redisplay dialog entries
					InitDialog(hwnd);
				}

				EnableDialogButtons(hwnd, TRUE);
			}
			break;
			
		case IDC_MATRIX_SHEAR:
			{
				EnableDialogButtons(hwnd, FALSE);
				
				TestMatrixOperation matrixOp;

				matrixOp.Initialize(_T("Shear Matrix Operation"),
									_T("Shear"),
									_T("Shear points by X and Y"),
									2);

				if (matrixOp.ChangeSettings(hwnd))
				{
					matrix->Shear(matrixOp.GetX(),
								  matrixOp.GetY());
					// !! should this be added?
					//			  *matrixPrepend);
					
					// redisplay dialog entries
					InitDialog(hwnd);
				}

				EnableDialogButtons(hwnd, TRUE);
			}
			break;

		case IDC_MATRIX_INVERT:
			matrix->Invert();
			InitDialog(hwnd);
			break;

		case IDC_REFRESH_PIC:
			UpdateTransformPicture(hwnd, IDC_MATRIX_PIC, matrix);
			break;

		case IDC_CANCEL:
			::EndDialog(hwnd, FALSE);
			break;

		case IDC_MATRIX_PREPEND:
			*matrixPrepend = (GetDialogCheck(hwnd, IDC_MATRIX_PREPEND) == TRUE ?
					PrependOrder : AppendOrder);
			break;
			
		default:
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

BOOL TestMatrixOperation :: ChangeSettings(HWND hwndParent)
{
	BOOL ok = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_MATRIX_DLG2),
							hwndParent,
							(DLGPROC)&AllDialogBox,
							(LPARAM)((TestDialogInterface*)this));

	return ok;
}

VOID TestMatrixOperation :: Initialize()
{
	DebugBreak();
}

VOID TestMatrixOperation :: Initialize(TCHAR* newDialogTitle,
									   TCHAR* newSubTitle,
									   TCHAR* newDescStr,
									   INT newCount)
{
	dialogTitle = newDialogTitle;
	subTitle = newSubTitle;
	descStr = newDescStr;
	count = newCount;
}

VOID TestMatrixOperation :: InitDialog(HWND hwnd)
{
	SetWindowText(hwnd, dialogTitle);
	SetDialogText(hwnd, IDC_MATRIX_OPERATION, subTitle);
	SetDialogText(hwnd, IDC_MATRIX_TEXT, descStr);

	SetDialogReal(hwnd, IDC_MATRIX_X, x);
	SetDialogReal(hwnd, IDC_MATRIX_Y, y);

	EnableDialogControl(hwnd, IDC_MATRIX_Y, count >= 2);
}

BOOL TestMatrixOperation :: SaveValues(HWND hwnd)
{
	x = GetDialogReal(hwnd, IDC_MATRIX_X);
	y = GetDialogReal(hwnd, IDC_MATRIX_Y);

	return FALSE;
}

BOOL TestMatrixOperation :: ProcessDialog(HWND hwnd, 
										  UINT msg, 
										  WPARAM wParam, 
										  LPARAM lParam)
{
    if (msg == WM_COMMAND)
	{
		if (LOWORD(wParam) == IDC_OK)
		{
			if (SaveValues(hwnd))
				WarningBeep();
			else
				::EndDialog(hwnd, TRUE);

	        return TRUE;
		}
		else if (LOWORD(wParam) == IDC_CANCEL)
		{
			::EndDialog(hwnd, FALSE);
		}
	}
    
	return FALSE;

}

//*******************************************************************
//
// Dialog Window Proc Handler
//
//*******************************************************************

LRESULT CALLBACK AllDialogBox(
							  HWND hwnd,
							  UINT msg,
							  WPARAM wParam,
							  LPARAM lParam
							  )
{
	switch (msg)
	{
	case WM_INITDIALOG:
		{
			// save pointer to brush interface for this object
			SetWindowLong(hwnd, DWL_USER, lParam);
			ASSERT(lParam != 0);
			TestDialogInterface* dlgInt = (TestDialogInterface*) lParam;

			dlgInt->InitDialog(hwnd);
		}
		break;

	case WM_PAINT:
		{
			TestDialogInterface* dlgInt = (TestDialogInterface*) 
						GetWindowLong(hwnd, DWL_USER);
			ASSERT(dlgInt != NULL);

			if (dlgInt)
				dlgInt->ProcessDialog(hwnd, WM_COMMAND, IDC_REFRESH_PIC, 0);
			return FALSE;
		}
		break;

	case WM_CLOSE:
		{
			DestroyWindow(hwnd);
			break;
		}

	default:
		{
			TestDialogInterface* dlgInt = (TestDialogInterface*) 
						GetWindowLong(hwnd, DWL_USER);
			ASSERT(dlgInt != NULL);

			if (dlgInt)
				return dlgInt->ProcessDialog(hwnd, msg, wParam, lParam);
			else
				return FALSE;
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by gdiptest.rc
//
#define IDC_MYICON                      2
#define IDD_GDIPTEST_DIALOG             102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_GDIPTEST                    107
#define IDI_SMALL                       108
#define IDC_GDIPTEST                    109
#define IDR_MAINFRAME                   128
#define IDD_SOLIDBRUSH_DLG              130
#define IDD_PEN_DLG                     131
#define IDD_ARC_DLG                     132
#define IDD_CURVE_DLG                   133
#define IDD_TEXTURE_DLG                 134
#define IDD_RECTGRAD_DLG                135
#define IDD_RADGRAD_DLG                 136
#define IDR_GRADBRUSH                   137
#define IDD_TRIGRAD_DLG                 138
#define IDD_TRIGRAD_DLG2                139
#define IDD_POLYGRAD_DLG                140
#define IDD_POLYGRAD_DLG2               141
#define IDD_MATRIX_DLG                  142
#define IDD_MATRIX_DLG2                 143
#define IDD_HATCH_DLG                   144
#define IDD_SHAPE_DLG                   145
#define IDC_REFRESH_PIC                 200
#define IDC_SB_ALPHA                    1000
#define IDC_SB_RED                      1001
#define IDC_HATCH_BACKALPHA             1001
#define IDC_SB_GREEN                    1002
#define IDC_SB_BLUE                     1003
#define IDC_OK                          1004
#define IDC_CANCEL                      1005
#define IDC_PEN_BRUSH                   1006
#define IDC_PEN_COLOR                   1007
#define IDC_PEN_WIDTH                   1008
#define IDC_PEN_STARTCAP                1013
#define IDC_PEN_ENDCAP                  1014
#define IDC_PEN_DASHCAP                 1015
#define IDC_PEN_DASHSTYLE               1016
#define IDC_PEN_JOIN                    1017
#define IDC_PEN_ALPHA                   1018
#define IDC_PEN_GREEN                   1019
#define IDC_PEN_RED                     1020
#define IDC_PEN_BLUE                    1021
#define IDC_PEN_BRUSHBUTTON             1022
#define IDC_PEN_BRUSHLIST               1023
#define IDC_LIST2                       1026
#define IDC_POLYGRAD_POINTLIST          1026
#define IDC_ARC_START                   1028
#define IDC_ARC_SWEEP                   1029
#define IDC_ARC_POPUP                   1030
#define IDC_CURVE_TENSION               1031
#define IDC_CURVE_OFFSET                1032
#define IDC_CURVE_SEGMENTS              1033
#define IDC_TEXTURE_FILENAME            1034
#define IDC_BRUSH_WRAP                  1035
#define IDC_TEXTURE_FILEBUTTON          1036
#define IDC_BRUSH_TRANSFORM             1037
#define IDC_RECTGRAD_X                  1038
#define IDC_RECTGRAD_Y                  1039
#define IDC_RECTGRAD_WIDTH              1040
#define IDC_RECTGRAD_HEIGHT             1041
#define IDC_RECTGRAD_COLOR1             1042
#define IDC_RECTGRAD_COLOR2             1043
#define IDC_RECTGRAD_COLOR3             1044
#define IDC_RECTGRAD_COLOR4             1045
#define IDC_RECTGRAD_ALPHA1             1047
#define IDC_RECTGRAD_ALPHA2             1048
#define IDC_RECTGRAD_ALPHA4             1049
#define IDC_RECTGRAD_ALPHA3             1050
#define IDC_RECTGRAD_PIC1               1051
#define IDC_RECTGRAD_PIC3               1052
#define IDC_RECTGRAD_PIC2               1053
#define IDC_RECTGRAD_PIC4               1054
#define IDC_RADGRAD_X                   1055
#define IDC_RADGRAD_Y                   1056
#define IDC_RADGRAD_WIDTH               1057
#define IDC_RADGRAD_HEIGHT              1058
#define IDC_RADGRAD_CENTER              1059
#define IDC_RADGRAD_BOUNDARY            1060
#define IDC_RADGRAD_CENTERALPHA         1061
#define IDC_RADGRAD_BOUNDARYALPHA       1062
#define IDC_RADGRAD_PICB                1063
#define IDC_RADGRAD_PICC                1064
#define IDC_PEN_COLORBUTTON             1065
#define IDC_PEN_PIC                     1066
#define IDC_PEN_COLORPIC                1067
#define IDC_SB_COLORBUTTON              1068
#define IDC_SB_PIC                      1069
#define IDC_TRIGRAD_BUTTON              1070
#define IDC_HATCH_BACKCOLOR             1070
#define IDC_HATCH_BACKPIC               1071
#define IDC_TRIGRAD_PT1                 1072
#define IDC_TRIGRAD_PT2                 1073
#define IDC_TRIGRAD_PT3                 1074
#define IDC_TRIGRAD_PIC1                1075
#define IDC_TRIGRAD_PIC2                1076
#define IDC_TRIGRAD_PIC3                1077
#define IDC_TRIGRAD_COLORBUTTON         1078
#define IDC_TRIGRAD_ALPHA               1079
#define IDC_TRIGRAD_BLEND               1082
#define IDC_TRIGRAD_PIC                 1083
#define IDC_POLYGRAD_BUTTON             1084
#define IDC_POLYGRAD_COLORBUTTON        1086
#define IDC_POLYGRAD_ALPHA              1087
#define IDC_POLYGRAD_PIC                1088
#define IDC_POLYGRAD_BLEND              1089
#define IDC_MATRIX_RESET                1090
#define IDC_MATRIX_TRANSLATE            1091
#define IDC_MATRIX_SCALE                1092
#define IDC_MATRIX_ROTATE               1093
#define IDC_MATRIX_SHEAR                1094
#define IDC_MATRIX_INVERT               1095
#define IDC_MATRIX_M11                  1097
#define IDC_MATRIX_M12                  1098
#define IDC_MATRIX_M13                  1099
#define IDC_MATRIX_M21                  1100
#define IDC_MATRIX_M22                  1101
#define IDC_MATRIX_M23                  1102
#define IDC_MATRIX_M31                  1103
#define IDC_MATRIX_M32                  1104
#define IDC_MATRIX_M33                  1105
#define IDC_MATRIX_PIC                  1106
#define IDC_MATRIX_PREPEND              1107
#define IDC_MATRIX_TEXT                 1108
#define IDC_MATRIX_X                    1109
#define IDC_MATRIX_Y                    1110
#define IDC_MATRIX_OPERATION            1111
#define IDC_HATCH_FORECOLOR             1112
#define IDC_HATCH_FOREALPHA             1113
#define IDC_HATCH_FOREPIC               1114
#define IDC_HATCH_STYLE                 1115
#define IDC_CLIP_TREE                   1117
#define IDC_CLIP_AND                    1118
#define IDC_CLIP_OR                     1119
#define IDC_CLIP_XOR                    1120
#define IDC_CLIP_NOT                    1121
#define IDC_CLIP_ADD                    1125
#define IDC_CLIP_REMOVE                 1126
#define IDC_SHAPE_UP                    1127
#define IDC_SHAPE_DOWN                  1128
#define IDC_SHAPE_DISABLE               1129
#define IDC_SHAPE_TOP                   1130
#define IDC_SHAPE_CLONE                 1131
#define IDC_SHAPE_BRUSH                 1132
#define IDC_SHAPE_PIC                   1133
#define IDC_SHAPE_PEN                   1134
#define IDC_SHAPE_LIST                  1135
#define IDC_CLIP_BOOL                   1136
#define IDC_TREE_SELECT                 2000
#define IDM_ARC                         32775
#define IDM_BEZIER                      32776
#define IDM_REGION                      32777
#define IDM_ELLIPSE                     32778
#define IDM_SOLIDBRUSH                  32779
#define IDM_TEXTURE                     32780
#define IDM_RECTGRAD                    32781
#define IDM_RADGRAD                     32782
#define IDM_TRIGRAD                     32783
#define IDM_POLYGRAD                    32784
#define IDM_HATCH                       32785
#define IDM_PEN                         32786
#define IDM_REDRAW                      32787
#define IDM_REDRAWALL                   32788
#define IDM_KEEPCONTROLPOINTS           32789
#define IDM_LINE                        32790
#define IDM_RECT                        32791
#define IDM_PIE                         32792
#define IDM_POLYGON                     32793
#define IDM_CURVE                       32794
#define IDM_CLOSED                      32795
#define IDM_ANTIALIASED                 32796
#define IDM_RESET                       32797
#define IDM_INSTRUCTIONS                32798
#define IDM_DONE                        32799
#define IDM_CANCEL                      32800
#define IDM_WORLD_TRANSFORM             32801
#define IDM_DELETE                      32802
#define IDM_USECLIP                     32803
#define IDM_SAVEFILE                    32804
#define IDM_SHAPELIST                   32805
#define IDM_SETCLIP                     32806
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        146
#define _APS_NEXT_COMMAND_VALUE         32807
#define _APS_NEXT_CONTROL_VALUE         1137
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

// Local Header Files

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\gdiputils.h ===
class TestConfigureInterface	// abstract class
{
public:
	// pop-up dialog to configure brush
	virtual BOOL ChangeSettings(HWND hwnd) = 0;

	// re-initialize the brush to a default value
	virtual VOID Initialize() = 0;
};

class TestDialogInterface
{
public:
	// WM_INITDIALOG
	virtual VOID InitDialog(HWND hwnd) = 0;

	// IDC_OK only 
	virtual BOOL SaveValues(HWND hwnd) = 0;

	// WM_ else...
	virtual BOOL ProcessDialog(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) = 0;
};

class TestTransform : public TestConfigureInterface,
                      public TestDialogInterface
{
public:
	TestTransform()
	{
		static MatrixOrder matrixPrependSave = PrependOrder;

		matrixPrepend = &matrixPrependSave;

		matrix = NULL;
	}

	~TestTransform()
	{
		delete matrix;
	}

	// Configuration interface methods
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();
	virtual VOID Initialize(Matrix** matrix);

	// Dialog maintenance methods
	virtual VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

protected:
	VOID EnableDialogButtons(HWND hwnd, BOOL enable);
	VOID UpdateTransformPicture(HWND hwnd, INT idc, Matrix* matrix);

private:
	Matrix** origMatrix;
	Matrix* matrix;

	MatrixOrder* matrixPrepend;
};

class TestMatrixOperation : public TestConfigureInterface,
							public TestDialogInterface
{
public:
	TestMatrixOperation()
	{
		x = y = 0.0f;
		count = 0;
	}

	~TestMatrixOperation()
	{
	}

	// Configuration interface methods
	virtual BOOL ChangeSettings(HWND hwnd);
	virtual VOID Initialize();
	virtual VOID Initialize(TCHAR* dialogTitle,
							TCHAR* subTitle,
							TCHAR* descStr,
							INT count);

	// Dialog maintenance methods
	virtual VOID InitDialog(HWND hwnd);
	virtual BOOL SaveValues(HWND hwnd);
	virtual BOOL ProcessDialog(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

	REAL GetX()
	{
		return x;
	};
	
	REAL GetY()
	{
		return y;
	};

private:
	TCHAR* dialogTitle;
	TCHAR* subTitle;
	TCHAR* descStr;
	INT count;
	REAL x, y;
};

// !! hacky stack based on DynArray types...

template <class T> class Stack : public DynArray<T>
{
public:

	typedef DynArray<T*> TArray;

    VOID Push(T& t)
	{
		Add(t);
	}

    T& Pop()
	{
		INT count = GetCount();
		
		if (count)
		{
			T& t = Last();
			AdjustCount(-1);
			return t;
		}
		else
		{
			ASSERT(FALSE);
			return GetPosition(0);		// !! hackish...
		}
	}

	T& GetPosition(INT pos)
	{
		return GetDataBuffer()[pos];
	}
};

class TestShape;

typedef Stack<TestShape*> ShapeStack;

// menu positions in window menu bar
const INT MenuFilePosition    = 0;
const INT MenuShapePosition   = 1;
const INT MenuBrushPosition   = 2;
const INT MenuPenPosition     = 3;
const INT MenuOtherPosition   = 4;

#define SetMenuCheckPos(w,x,y,z) SetMenuCheck(w,x,y,z,FALSE)
#define SetMenuCheckCmd(w,x,y,z) SetMenuCheck(w,x,y,z,TRUE)

extern VOID SetMenuCheck(HWND hwnd, 
						 INT menuPos, 
						 UINT idm, 
						 BOOL checked, 
						 BOOL byCmd);

extern Brush* blackBrush;
extern Brush* backBrush;
extern Pen* blackPen;
extern Color* blackColor;

#define MAX_LOADSTRING 100

extern VOID NotImplementedBox();
extern VOID WarningBox(TCHAR* string);
extern HINSTANCE hInst;
extern TCHAR szTitle[MAX_LOADSTRING];
extern TCHAR szWindowClass[MAX_LOADSTRING];
extern VOID WarningBeep();

extern VOID SetDialogLong(HWND hwnd, UINT idc, UINT value, BOOL enable = TRUE);
extern UINT GetDialogLong(HWND hwnd, UINT idc);
extern VOID SetDialogReal(HWND hwnd, UINT idc, REAL value);
extern REAL GetDialogReal(HWND hwnd, UINT idc);
extern VOID SetDialogText(HWND hwnd, UINT idc, LPTSTR text, BOOL enable = TRUE);
extern VOID GetDialogText(HWND hwnd, UINT idc, LPTSTR text, INT maxSize);
extern VOID SetDialogCombo(HWND hwnd, UINT idc, const TCHAR* strings[], INT count, INT cursel);
extern INT GetDialogCombo(HWND hwnd, UINT idc);
extern VOID SetDialogCheck(HWND hwnd, UINT idc, BOOL checked);
extern BOOL GetDialogCheck(HWND hwnd, UINT idc);
extern VOID SetDialogRealList(HWND hwnd, UINT idc, REAL* blend, INT count);
extern VOID	GetDialogRealList(HWND hwnd, UINT idc, REAL** blend, INT *count);
extern VOID EnableDialogControl(HWND hwnd, INT idc, BOOL enable);

extern VOID UpdateColorPicture(HWND hwnd, INT idc, ARGB argb);
extern VOID UpdateRGBColor(HWND hwnd, INT idcPic, ARGB& argb);

// Foward declarations of functions included in this code module:
ATOM				MyRegisterClass(HINSTANCE hInstance);
HWND				InitInstance(HINSTANCE, int, LPVOID);
LRESULT CALLBACK	WndTestDrawProc(HWND, UINT, WPARAM, LPARAM);

extern LRESULT CALLBACK AllDialogBox(
									 HWND hwnd,
									 UINT msg,
									 WPARAM wParam,
									 LPARAM lParam
									 );
enum FormatType
{
	CPPFile,
	JavaFile,
	VMLFile
};

extern const TCHAR* tabStr;

const INT numFormats = 3;
extern const TCHAR* formatList[numFormats];
extern const FormatType formatValue[numFormats];

const INT numShapes = 9;
extern const TCHAR* shapeList[numShapes];
extern const INT shapeValue[numShapes];
extern const INT inverseShapeValue[numShapes];

const INT numBrushes = 7;
extern const TCHAR* brushList[numBrushes];
extern const INT brushValue[numBrushes]; 
extern const INT inverseBrushValue[numBrushes];

const int numCaps = 6;
extern const TCHAR* capList[numCaps];
extern const TCHAR* capStr[numCaps];
extern const LineCap capValue[numCaps];

const int numDashCaps = 3;
extern const TCHAR* dashCapList[numDashCaps];
extern const TCHAR* dashCapStr[numDashCaps];
extern const DashCap dashCapValue[numDashCaps];

const INT numJoin = 3;
extern const TCHAR* joinList[numJoin];
extern const TCHAR* joinStr[numJoin];
extern const LineJoin joinValue[numJoin];
	
const INT numDash = 5;
extern const TCHAR* dashList[numDash];
extern const TCHAR* dashStr[numDash];
extern const DashStyle dashValue[numDash];

const INT numWrap = 6;
extern const TCHAR* wrapList[numWrap];
extern const TCHAR* wrapStr[numWrap];
extern const WrapMode wrapValue[numWrap];

const INT numHatch = 6;
extern const TCHAR* hatchList[numHatch];
extern const TCHAR* hatchStr[numHatch];
extern const HatchStyle hatchValue[numHatch];

// Shapes:
//   Line(s), Arc(s), Bezier(s), Rect(s), Ellipse(s), Pie(s), Polygon(s),
//   Curve(s), Path(s), ClosedCurve(s)

enum ShapeTypes
{
	LineType = 0,
	ArcType = 1,
	BezierType = 2,
	RectType = 3,
	EllipseType = 4,
	PieType = 5,
	PolygonType = 6,
	CurveType = 7,
	ClosedCurveType = 8
};

const INT pointRadius = 4;

typedef DynArray<Point> PointArray;
typedef DynArray<ARGB> ARGBArray;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\harness\main.cxx ===
//
// Generic Windows program template
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <math.h>             // sin & cos
#include <tchar.h>

//
// Where is IStream included from?
//

#define IStream int

#include <gdiplus.hpp>

using namespace Gdiplus;

CHAR* programName;      // program name
HINSTANCE appInstance;  // handle to the application instance

#include "..\test.cpp"  // include generated code file

//
// Display an error message dialog and quit
//

VOID
Error(
    PCSTR fmt,
    ...
    )

{
    CHAR buf[1024];
    va_list arglist;

    va_start(arglist, fmt);
    vfprintf(stderr, fmt, arglist);
    va_end(arglist);

    exit(-1);
}


//
// Handle window repaint event
//

VOID
DoPaint(
    HWND hwnd
    )

{
    HDC hdc;
    PAINTSTRUCT ps;
    
    hdc = BeginPaint(hwnd, &ps);

    RECT rect;
    GetClientRect(hwnd, &rect);

    HBRUSH hbr, hbrOld;

    hbr = CreateSolidBrush(0xFFFFFF);

    hbrOld = (HBRUSH) SelectObject(hdc, hbr);

    FillRect(hdc, &rect, hbr);

    SelectObject(hdc, hbrOld);

    DeleteObject(hbr);

    DoGraphicsTest(hwnd);
   
    EndPaint(hwnd, &ps);
}


//
// Window callback procedure
//

LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

{
    switch (uMsg)
    {
    case WM_PAINT:
        DoPaint(hwnd);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//
// Create main application window
//

VOID
CreateMyWindow(
    LPVOID image,
    LPCTSTR title
    )

#define MYWNDCLASSNAME _T("Test Harness")

{
    //********************************************************************
    //
    // Register window class if necessary
    //

    static BOOL wndclassRegistered = FALSE;

    if (!wndclassRegistered)
    {
        WNDCLASS wndClass =
        {
            0,
            MyWindowProc,
            0,
            0,
            appInstance,
            NULL,
            NULL,
            NULL,
            NULL,
            MYWNDCLASSNAME
        };

        RegisterClass(&wndClass);
        wndclassRegistered = TRUE;
    }

    HWND hwnd;
    INT width = 600, height = 600;

    hwnd = CreateWindow(
                    MYWNDCLASSNAME,
                    title,
                    WS_OVERLAPPED | WS_SYSMENU | WS_VISIBLE,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    width,
                    height,
                    NULL,
                    NULL,
                    appInstance,
                    NULL);

    if (hwnd == NULL)
        Error("Couldn't create image window\n");

    SetWindowLong(hwnd, GWL_USERDATA, (LONG) image);
}


//
// Main program entrypoint
//

INT _cdecl
main(
    INT argc,
    CHAR **argv
    )

{
    programName = *argv++;
    argc--;
    appInstance = GetModuleHandle(NULL);

    //
    // Create the main application window
    //
    //********************************************************************

    CreateMyWindow(NULL, _T("Original Image"));

    //
    // Main message loop
    //

    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gpcfm\conform\brushtst.cxx ===
#include <windows.h>

#define IStream int
#include <gdiplus.h>

#include <brushtst.hxx>
#include <report.hxx>
#include <epsilon.hxx>


BrushTst::BrushTst(VOID)
{
    lstrcpy(name, TEXT("BrushTst"));
    //hresult = NO_ERROR;
}

BrushTst::~BrushTst(VOID)
{
}

VOID BrushTst::vEntry(Graphics *gfx, HWND hwnd, Report *rpt, Epsilon *eps)
{

    Matrix mat;
    mat.Rotate(15);
    mat.Translate(-2.5, -2.5);
    gfx->SetWorldTransform(&mat);

    hresult = NO_ERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gdiptest\test.cpp ===
VOID DoGraphicsTest(HWND hWnd)
{
    Graphics g(hWnd);

    Matrix worldMatrix(1.000000e+000, 2.500000e-001, -2.500000e-001, 
                       1.000000e+000, 1.000000e+002, 0.000000e+000);
    g.SetWorldTransform(&worldMatrix);

    {
        Color color(0x400080FF);
        Pen pen(color, 2.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        Point pts[13];
        pts[0].X=4.400000e+001; pts[0].Y=3.700000e+001;
        pts[1].X=3.190000e+002; pts[1].Y=4.000000e+001;
        pts[2].X=4.790000e+002; pts[2].Y=4.200000e+001;
        pts[3].X=5.210000e+002; pts[3].Y=8.200000e+001;
        pts[4].X=1.750000e+002; pts[4].Y=1.140000e+002;
        pts[5].X=1.300000e+001; pts[5].Y=1.390000e+002;
        pts[6].X=2.500000e+002; pts[6].Y=1.820000e+002;
        pts[7].X=5.280000e+002; pts[7].Y=1.890000e+002;
        pts[8].X=4.290000e+002; pts[8].Y=2.780000e+002;
        pts[9].X=1.280000e+002; pts[9].Y=2.840000e+002;
        pts[10].X=9.600000e+001; pts[10].Y=2.980000e+002;
        pts[11].X=4.280000e+002; pts[11].Y=3.270000e+002;
        pts[12].X=5.230000e+002; pts[12].Y=3.100000e+002;

        g.DrawLine(&pen, &pts[0], 13);
    }

    {
        Color color(0x8080FFFF);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        ERectangle rect(2.900000e+001, 4.000000e+001, 
                        3.600000e+002, 2.260000e+002);

        g.DrawArc(&pen, rect, 9.000000e+001, 9.000000e+001);
    }

    {
        Bitmap bitmap(L"Z:\\nt\\private\\ntos\\w32\\winplus\\src\\gdiplus\\test\\dlltest\\winnt256.bmp");

        TextureBrush brush(&bitmap, Tile);

        // identity matrix transform

        ERectangle rect(2.220000e+002, 4.200000e+001, 
                        3.170000e+002, 2.130000e+002);

        g.FillPie(&brush, rect, 0.000000e+000, 9.000000e+001);

        Color color(0x8080FFFF);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        g.DrawPie(&pen, rect, 0.000000e+000, 9.000000e+001);
    }

    {
        Bitmap bitmap(L"Z:\\nt\\private\\ntos\\w32\\winplus\\src\\gdiplus\\test\\dlltest\\winnt256.bmp");

        TextureBrush brush(&bitmap, Tile);

        // identity matrix transform

        ERectangle rect(2.230000e+002, 5.100000e+001, 
                        1.270000e+002, 1.300000e+002);

        g.FillEllipse(&brush, rect);

        Color color(0x8080FFFF);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        g.DrawEllipse(&pen, rect);
    }

    {
        Bitmap bitmap(L"Z:\\nt\\private\\ntos\\w32\\winplus\\src\\gdiplus\\test\\dlltest\\winnt256.bmp");

        TextureBrush brush(&bitmap, Tile);

        // identity matrix transform

        ERectangle rect(3.150000e+002, 2.900000e+001, 
                        2.500000e+002, 1.930000e+002);

        g.FillPie(&brush, rect, 9.000000e+001, 9.000000e+001);

        Color color(0x8080FFFF);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        g.DrawPie(&pen, rect, 9.000000e+001, 9.000000e+001);
    }

    {
        Bitmap bitmap(L"Z:\\nt\\private\\ntos\\w32\\winplus\\src\\gdiplus\\test\\dlltest\\winnt256.bmp");

        TextureBrush brush(&bitmap, Tile);

        // identity matrix transform

        Point pts[10];
        pts[0].X=4.600000e+001; pts[0].Y=5.500000e+001;
        pts[1].X=2.420000e+002; pts[1].Y=3.600000e+001;
        pts[2].X=3.780000e+002; pts[2].Y=3.900000e+001;
        pts[3].X=4.580000e+002; pts[3].Y=7.600000e+001;
        pts[4].X=4.850000e+002; pts[4].Y=2.540000e+002;
        pts[5].X=2.840000e+002; pts[5].Y=2.870000e+002;
        pts[6].X=1.230000e+002; pts[6].Y=2.800000e+002;
        pts[7].X=4.800000e+001; pts[7].Y=2.210000e+002;
        pts[8].X=3.100000e+001; pts[8].Y=1.550000e+002;
        pts[9].X=3.400000e+001; pts[9].Y=1.050000e+002;

        g.FillPolygon(&brush, &pts[0], 10);

        Color color(0x80FF8040);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        g.DrawPolygon(&pen, &pts[0], 10);
    }

    {
        Color color(0x80FF8040);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        Point pts[28];
        pts[0].X=4.300000e+001; pts[0].Y=1.900000e+001;
        pts[1].X=3.200000e+001; pts[1].Y=6.800000e+001;
        pts[2].X=3.200000e+001; pts[2].Y=1.590000e+002;
        pts[3].X=3.300000e+001; pts[3].Y=2.300000e+002;
        pts[4].X=3.200000e+001; pts[4].Y=2.840000e+002;
        pts[5].X=8.200000e+001; pts[5].Y=3.240000e+002;
        pts[6].X=1.310000e+002; pts[6].Y=2.090000e+002;
        pts[7].X=1.310000e+002; pts[7].Y=1.180000e+002;
        pts[8].X=1.470000e+002; pts[8].Y=1.900000e+001;
        pts[9].X=2.030000e+002; pts[9].Y=1.900000e+001;
        pts[10].X=2.160000e+002; pts[10].Y=6.400000e+001;
        pts[11].X=2.160000e+002; pts[11].Y=1.420000e+002;
        pts[12].X=2.180000e+002; pts[12].Y=2.040000e+002;
        pts[13].X=2.190000e+002; pts[13].Y=2.680000e+002;
        pts[14].X=2.580000e+002; pts[14].Y=3.160000e+002;
        pts[15].X=3.090000e+002; pts[15].Y=2.950000e+002;
        pts[16].X=3.080000e+002; pts[16].Y=1.260000e+002;
        pts[17].X=3.190000e+002; pts[17].Y=1.700000e+001;
        pts[18].X=3.890000e+002; pts[18].Y=2.100000e+001;
        pts[19].X=4.250000e+002; pts[19].Y=1.670000e+002;
        pts[20].X=4.250000e+002; pts[20].Y=2.510000e+002;
        pts[21].X=4.670000e+002; pts[21].Y=3.280000e+002;
        pts[22].X=5.720000e+002; pts[22].Y=2.410000e+002;
        pts[23].X=5.720000e+002; pts[23].Y=2.410000e+002;
        pts[24].X=5.450000e+002; pts[24].Y=1.110000e+002;
        pts[25].X=5.140000e+002; pts[25].Y=3.600000e+001;
        pts[26].X=5.140000e+002; pts[26].Y=3.500000e+001;
        pts[27].X=4.600000e+002; pts[27].Y=1.700000e+001;

        g.DrawCurve(&pen, &pts[0], 28, 2.000000e+000, 0, 23);
    }

    {
        Color colors[4];
        colors[0] = Color(0x50FFFFFF);
        colors[1] = Color(0x50FF0000);
        colors[2] = Color(0x5000FF00);
        colors[3] = Color(0x500000FF);

        ERectangle rectb(0.000000e+000, 0.000000e+000, 
                         1.000000e+002, 1.000000e+002);

        RectangleGradientBrush brush(rectb, &colors[0], Tile);

        Matrix matrixb(1.000000e+000, 2.500000e-001, -2.500000e-001, 
                       1.000000e+000, 0.000000e+000, 0.000000e+000);
        brush.SetTransform(&matrixb);

        ERectangle rect(7.000000e+000, 5.000000e+000, 
                        5.710000e+002, 3.470000e+002);
        g.FillRect(&brush, rect);

        Color color(0x80FF8040);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        g.DrawRect(&pen, rect);
    }
    {
        Color colors[4];
        colors[0] = Color(0x50FFFFFF);
        colors[1] = Color(0x50FF0000);
        colors[2] = Color(0x5000FF00);
        colors[3] = Color(0x500000FF);

        ERectangle rectb(0.000000e+000, 0.000000e+000, 
                         1.000000e+002, 1.000000e+002);

        RectangleGradientBrush brush(rectb, &colors[0], Tile);

        Matrix matrixb(1.000000e+000, 2.500000e-001, -2.500000e-001, 
                       1.000000e+000, 0.000000e+000, 0.000000e+000);
        brush.SetTransform(&matrixb);

        ERectangle rect(2.090000e+002, 1.800000e+001, 
                        1.100000e+001, 4.500000e+001);
        g.FillRect(&brush, rect);

        Color color(0x80FF8040);
        Pen pen(color, 1.000000e+001);
        pen.SetLineCap(RoundCap, FlatCap, FlatCap);
        pen.SetLineJoin(RoundJoin);
        pen.SetDashStyle(Solid);

        g.DrawRect(&pen, rect);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gpcfm\conform\regiontst.cxx ===
#include <windows.h>

#define IStream int
#include <gdiplus.h>

#include <regiontst.hxx>
#include <report.hxx>
#include <epsilon.hxx>

RegionTst::RegionTst()
{
    lstrcpy(name, TEXT("RegionTst"));
    //hresult = NO_ERROR;
}

RegionTst::~RegionTst()
{
}

VOID RegionTst::vEntry(Graphics *gfx, HWND hwnd, Report *rpt, Epsilon *eps)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gpcfm\conform\pentst.cxx ===
#include <windows.h>

#define IStream int
#include <gdiplus.h>

#include <pentst.hxx>
#include <report.hxx>
#include <epsilon.hxx>

PenTst::PenTst()
{
    lstrcpy(name, TEXT("PenTst"));
    //hresult = NO_ERROR;
}

PenTst::~PenTst()
{
}

VOID PenTst::vEntry(Graphics *gfx, HWND hwnd, Report *rpt, Epsilon *eps)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gpcfm\conform\gradienttst.cxx ===
#include <windows.h>

#define IStream int
#include <gdiplus.h>

#include <gradienttst.hxx>
#include <report.hxx>
#include <epsilon.hxx>
#include <tsterror.hxx>

// compiler complained abs() ambiguous call to overloaded functions!
#define ABS(x) ((x) > 0) ? (x) : -(x)

GradientTst::GradientTst(VOID)
{
    lstrcpy(name, TEXT("GradientTst"));
}

GradientTst::~GradientTst(VOID)
{
}

VOID GradientTst::vEntry(Graphics *gfx, HWND hwnd, Report *rpt, Epsilon *eps)
{
    RECT rc;
    GetClientRect(hwnd, &rc);

    hresult = NO_ERROR;

    int iWidth = rc.right-rc.left;
    int iHeight = rc.bottom-rc.top;
    Rect brushRect(rc.left, rc.top, iWidth, iHeight);

    Color colors[5] =
    {
        Color(255, 0, 0, 0),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 255, 255, 255)
    };

    RectangleGradientBrush rectGrad0(brushRect, (Color*) &colors, WrapModeTile);

    gfx->FillRectangle(&rectGrad0, 0, 0, iWidth, iHeight);

    // We will have a getPixel method so the derived class doesn't have to
    // get the dc and use the slow GetPixel.  We'll have the alpha value as well.
    //
    // Besides, we could have all sorts of dc, test don't have to know what's
    // the right way to retrieve either bits or dc.
    //
    // Epsilon should be part of Test.  So, we don't have to pass it in.
    //
    // For now, I cheat..
    HDC hdc = GetDC(hwnd);

    // Verification:
    // Check endpoints

    COLORREF cr[4];

    cr[0] = GetPixel(hdc, 0, 0);
    cr[1] = GetPixel(hdc, rc.right-2, 0);
    cr[2] = GetPixel(hdc, 0, rc.bottom-2);
    cr[3] = GetPixel(hdc, rc.right-2, rc.bottom-2);

    for (int i = 0; i < 4; i++)
    {
        int iRedGot = cr[i] & 0x000000ff;
        int iGrnGot = (cr[i] & 0x0000ff00) >> 8;
        int iBluGot = (cr[i] & 0x00ff0000) >> 16;

        int iRedExp = colors[i].GetRed();
        int iGrnExp = colors[i].GetGreen();
        int iBluExp = colors[i].GetBlue();

        if ((ABS(iRedExp - iRedGot) > eps->fRed) ||
            (ABS(iGrnExp - iGrnGot) > eps->fGrn) ||
            (ABS(iBluExp - iBluGot) > eps->fBlu))
        {
            rpt->vLog(TLS_SEV3,
                "Rendered(RGB) %lx, %lx, %lx, \tExpected(RGB) %lx, %lx, %lx, \tcorner=%d",
                iRedGot, iGrnGot, iBluGot, iRedExp, iGrnExp, iBluExp, i);
            hresult = S_E_GRADIENTTST1;
        }
    }

    // monotonic increasing?
    COLORREF crPrev = GetPixel(hdc, 0, 0);
    for (int y = 1; y < iHeight-2; y++)
    {
        COLORREF crX1 = GetPixel(hdc, 0, y);
        if (crX1 < crPrev)
        {
            rpt->vLog(TLS_SEV3, "Not monotonic inc in x: crX1 %lx < crPrev %lx", crX1, crPrev);
            break;
        }
    }

    crPrev = GetPixel(hdc, 0, 0);
    for (int x = 1; x < iWidth-2; x++)
    {
        COLORREF crX1 = GetPixel(hdc, x, 0);
        if (crX1 < crPrev)
        {
            rpt->vLog(TLS_SEV3, "Not monotonic inc in y: crX1 %lx < crPrev %lx", crX1, crPrev);
            break;
        }
    }

    //COLORREF crX1 = GetPixel(hdc, 0, 0);                // 0
    //COLORREF crX2 = GetPixel(hdc, rc.right/4, 0);       // 39
    //COLORREF crX3 = GetPixel(hdc, rc.right/2, 0);       // 7b
    //COLORREF crX4 = GetPixel(hdc, rc.right-2, 0);       // ff
    //COLORREF crX5 = GetPixel(hdc, rc.right-1, 0);       // 0  (whatever in desktop)
    //COLORREF crX6 = GetPixel(hdc, rc.right, 0);         // ffffffff (wnd frame)

    // expect brush origin at (0,0) ie. a value of 0
    // expect brush

    //rpt->vLog(TLS_LOG, "%lx, %lx, %lx, %lx, %lx, %lx", crX1, crX2, crX3, crX4, crX5, crX6);

    REAL penWidth = 1;

    Color blueColor(0, 0, 255);
    Pen bluePen(blueColor, penWidth);

    gfx->DrawRectangle(&bluePen, 0, 0, iWidth, iHeight);

    // check top
    COLORREF crX1 = GetPixel(hdc, 0, 0);                  // ff0000
    COLORREF crX2 = GetPixel(hdc, rc.right/4, 0);         // ff0000
    COLORREF crX3 = GetPixel(hdc, rc.right/2, 0);         // ff0000
    COLORREF crX4 = GetPixel(hdc, rc.right-2, 0);         // ff0000

    //rpt->vLog(TLS_LOG, "%lx, %lx, %lx, %lx", crX1, crX2, crX3, crX4);

    // check 2nd from top
    crX1 = GetPixel(hdc, 0, 1);                         // ff0000
    crX2 = GetPixel(hdc, rc.right/4, 1);                // 39
    crX3 = GetPixel(hdc, rc.right/2, 1);                // 7b
    crX4 = GetPixel(hdc, rc.right-2, 1);                // f7
    COLORREF crX5 = GetPixel(hdc, rc.right-1, 1);                // 0  (desktop color)
    COLORREF crX6 = GetPixel(hdc, rc.right, 1);                  // ffffffff (wnd frame)

    //rpt->vLog(TLS_LOG, "%lx, %lx, %lx, %lx, %lx, %lx", crX1, crX2, crX3, crX4, crX5, crX6);

    // check left
    // check right
    // check bottom

    ReleaseDC(hwnd, hdc);

    //Sleep(1000 * 60);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gpcfm\conform\test.cxx ===
class TstIF
{
public:
    virtual BOOL Setup()=0;
    virtual BOOL Execute()=0;
    virtual BOOL Verify()=0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gradient\debug.h ===
/******************************Module*Header*******************************\
* Module Name: debug.h
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

extern void LBprintf(PCH, ...);
extern void LBreset(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gpcfm\conform\xformtst.cxx ===
#include <windows.h>

#define IStream int
#include <gdiplus.h>

#include <xformtst.hxx>
#include <report.hxx>
#include <epsilon.hxx>

XformTst::XformTst()
{
    lstrcpy(name, TEXT("XformTst"));
    //hresult = NO_ERROR;
}

XformTst::~XformTst()
{
}

VOID XformTst::vEntry(Graphics *gfx, HWND hwnd, Report *rpt, Epsilon *eps)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gradient\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#define MM_NEW          0x8001
#define MM_EXIT         0x8002
#define MM_TEST         0x8003

#define IDB_BITMAPCMYKTEST  0x9001

VOID Test(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gpcfm\engine\debug.cxx ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#include <debug.hxx>

namespace Globals
{
    DWORD dwDebug = 0;
    #if 0
    TCHAR AvailableTst[][MAX_STRING] =
    {
        TEXT("BrushTst"),
        TEXT("PenTst"),
        TEXT("RegionTst"),
        TEXT("XformTst")
    };
    #endif
};

VOID vOut(DWORD dwFlag, TCHAR message[MAX_STRING], ...)
{
    if (Globals::dwDebug & dwFlag)
    {
        va_list ArgList;
        TCHAR text[MAX_STRING*2];

        va_start(ArgList, message);
        _vstprintf(text, message, ArgList);
        va_end(ArgList);

        OutputDebugString(text);
    }
    return;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\libtest\debug.h ===
/******************************Module*Header*******************************\
* Module Name: debug.h
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

extern void LBprintf(PCH, ...);
extern void LBreset(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gpcfm\engine\report.cxx ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#include <ntlog.h>
#include <report.hxx>
#include <debug.hxx>

Report::Report(TCHAR *name)
{
    handleLog = tlCreateLog(name,
        TLS_REFRESH | TLS_INFO | TLS_SEV3 | TLS_SEV2 | TLS_VARIATION);

    if (handleLog == NULL)
    {
        vOut(DBG_REPORT, TEXT("Report(): tlCreateLog failed"));
        valid = FALSE;
    }
    else
    {
        valid = TRUE;
        tlAddParticipant(handleLog, 0L, 0);
    }
}

Report::~Report(VOID)
{
    if (valid)
    {
        tlReportStats(handleLog);
        tlRemoveParticipant(handleLog);
        tlDestroyLog(handleLog);
    }
}

VOID Report::vLog(DWORD level, TCHAR *message, ...)
{
    if (valid)
    {
        va_list ArgList;
        TCHAR text[MAX_STRING*2];

        va_start(ArgList, message);
        _vstprintf(text, message, ArgList);
        va_end(ArgList);

        tlLog(handleLog, level, "", 0, text);
    }
}

VOID Report::vStartVariation(VOID)
{
    if (valid)
    {
        tlStartVariation(handleLog);
    }
}

DWORD Report::dwEndVariation(VOID)
{
    DWORD dwVer = 0L;

    if (valid)
    {
        dwVer = tlEndVariation(handleLog);
    }
    return dwVer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\imgtest\rsrc.h ===
#define IDR_MAINMENU        100
#define IDR_ACCELTABLE      101

#define IDM_OPEN            200
#define IDM_SAVE            201
#define IDM_FIT_WINDOW      202
#define IDM_QUIT            203

#define IDM_CONVERT_RGB555  300
#define IDM_CONVERT_RGB565  301
#define IDM_CONVERT_RGB24   302
#define IDM_CONVERT_RGB32   303
#define IDM_CONVERT_ARGB    304

#define IDM_SCALE_GDI       400
#define IDM_SCALE_GDIHT     401
#define IDM_SCALE_NEIGHBOR  402
#define IDM_SCALE_BILINEAR  403
#define IDM_SCALE_AVERAGING 404
#define IDM_SCALE_BICUBIC   405

#define IDM_BMP_CROP        500
#define IDM_BMP_RESIZE      501
#define IDM_BMP_FLIPX       502
#define IDM_BMP_FLIPY       503
#define IDM_BMP_ROTATE90    504
#define IDM_BMP_ROTATE270   505
#define IDM_BRIGHTEN        506
#define IDM_DARKEN          507
#define IDM_INCCONTRAST     508
#define IDM_DECCONTRAST     509
#define IDM_INCGAMMA        510
#define IDM_DECGAMMA        511
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\imgdiff\imgdiff.cxx ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Program Name:
*
*   ImgDiff
*
*   ImgDiff source_file_1 source_file_2 destination_file
*
*   This will difference the two source files (provided they're the same size)
*   and output the resulting image.
*
*   Technically it does:
*
*   CD[i] = | S1[i] - S2[i] |
*
*   where i indexes the color channels rather than the pixels.
*   because it's an abs computation, the input source file order is unimportant.
*
*
* Created:
*
*   06/25/2000 asecchia
*      Created it.
*
**************************************************************************/

#include <stdio.h>
#include <windows.h>
#include <objbase.h>
#include <gdiplus.h>

INT AsciiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
)
{
    return( MultiByteToWideChar(
        CP_ACP,
        0,
        ansiStr,
        -1,
        unicodeStr,
        unicodeSize
    ) > 0 );
}

#define Fail() goto cleanup

void _cdecl main(int argc, char **argv) 
{

    if(argc<4) 
    {
        printf("error - need source1 and source2 and destination filename\n");
        printf("usage: ImgDiff srcfilename srcfilename dstfilename\n");
        return;
    }
    
    using namespace Gdiplus;

    Status status;
    WCHAR source1[1024];
    WCHAR source2[1024];
    WCHAR outfilename[1024];
    AsciiToUnicodeStr(argv[1], source1, 1024);
    AsciiToUnicodeStr(argv[2], source2, 1024);
    AsciiToUnicodeStr(argv[3], outfilename, 1024);


    ImageCodecInfo* codecs = NULL;
    UINT count;
    UINT cbCodecs;
    
    // Open the source images
    
    Bitmap *srcBmp1 = new Bitmap(source1);
    Bitmap *srcBmp2 = new Bitmap(source2);

    // Ask the source image for it's size.
    
    int width = srcBmp1->GetWidth();
    int height = srcBmp1->GetHeight();

    
    if( (width != (int)srcBmp2->GetWidth()) ||
        (height != (int)srcBmp2->GetHeight())   )
    {
        printf("the two input files are different sizes\n");
        return;
    }

    printf("Input images are (%d x %d)\n", width, height);
    
    // Create a destination image to draw onto
    
    Bitmap *dstBmp = new Bitmap(
        width, 
        height,
        PixelFormat32bppARGB
    );
    
    BitmapData bdSrc1;
    BitmapData bdSrc2;
    BitmapData bdDst;
    
    Rect rect(0,0,width,height);
    
    srcBmp1->LockBits(rect, ImageLockModeRead, PixelFormat32bppARGB, &bdSrc1);
    srcBmp2->LockBits(rect, ImageLockModeRead, PixelFormat32bppARGB, &bdSrc2);
    dstBmp->LockBits(rect, ImageLockModeWrite, PixelFormat32bppARGB, &bdDst);
    
    int x, y;
    
    unsigned char *s1, *s2, *d;
    
    for(y = 0; y < (int)bdSrc1.Height; y++)
    {
        for(x = 0; x < (int)bdSrc1.Width; x++)
        {
            s1 = (unsigned char *)((ARGB*)(bdSrc1.Scan0) + x + y * bdSrc1.Width);
            s2 = (unsigned char *)((ARGB*)(bdSrc2.Scan0) + x + y * bdSrc2.Width);
            d =  (unsigned char *)((ARGB*)(bdDst.Scan0) + x + y * bdDst.Width);
         
            // per channel subtract.
               
            d[0] = (unsigned char)abs(s1[0] - s2[0]);
            d[1] = (unsigned char)abs(s1[1] - s2[1]);
            d[2] = (unsigned char)abs(s1[2] - s2[2]);
            d[3] = (unsigned char)abs(s1[3] - s2[3]);
        }
    }
    
    srcBmp1->UnlockBits(&bdSrc1);
    srcBmp2->UnlockBits(&bdSrc2);
    dstBmp->UnlockBits(&bdDst);
    
    // Now start finding a codec to output the image.

    cbCodecs = 0;
    GetImageEncodersSize(&count, &cbCodecs);

    // Allocate space for the codec list
    
    codecs = static_cast<ImageCodecInfo *>(malloc (cbCodecs));
    
    if (codecs == NULL)
    {
        printf("error: failed to allocate memory for codecs\n");
        Fail();
    }

    // Get the list of encoders
    
    status = GetImageEncoders(count, cbCodecs, codecs);
    
    if (status != Ok)
    {
        printf("Error: GetImageEncoders returned %d\n", status);
        Fail();
    }

    // Search the codec list for the JPEG codec.
    // Use the Mime Type field to specify the correct codec.
    
    for(UINT i=0; i<count; i++) {
        if(wcscmp(codecs[i].MimeType, L"image/bmp")==0) {break;}
    }

    if(i>=count)
    {
        fprintf(stderr, "failed to find the codec\n");
        Fail();
    }

    // Output the image to disk.
    
    CLSID tempClsID;
    tempClsID = codecs[i].Clsid;
    
    status = dstBmp->Save(
        outfilename, 
        &tempClsID, 
        NULL
    );

    if (status != Ok) 
    {
        fprintf(stderr, "SaveImage--Save() failed\n");
        Fail();
    }

    // We're golden - everything worked.
    
    printf("Done\n");


    // Clean up the objects we used.
    
    cleanup:   
    
    
    free(codecs);    
    delete dstBmp;
    delete srcBmp1;
    delete srcBmp2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gradient\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

// for Win95 compile
#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <gdiplus.h>

#include "wndstuff.h"

#include "../gpinit.inc"

HINSTANCE ghInstance;
HWND ghwndMain;
HWND ghwndDebug;
HWND ghwndList;
HBRUSH ghbrWhite;

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {
    case WM_CREATE:
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case MM_TEST:
            Test(hwnd);
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/******************************Public*Routine******************************\
* DebugWndProc
*
* List box is maintained here.
*
\**************************************************************************/

LONG_PTR FAR PASCAL DebugWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT    rcl;
    HDC     hdc;
    LONG_PTR    lRet = 0;

// Process window message.

    switch (message)
    {
    case WM_SIZE:
        lRet = DefWindowProc(ghwndList, message, wParam, lParam);
        GetClientRect(ghwndMain, &rcl);
        MoveWindow(
            ghwndList,
            rcl.left, rcl.top,
            (rcl.right - rcl.left), (rcl.bottom - rcl.top),
            TRUE
            );
        UpdateWindow(ghwndList);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        lRet = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    }

    return lRet;
}

/******************************Public*Routine******************************\
* LBprintf
*
* ListBox printf implementation.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBprintf(PCH msg, ...)
{
    if (ghwndList)
    {
        va_list ap;
        char buffer[256];

        va_start(ap, msg);

        vsprintf(buffer, msg, ap);

        SendMessage(ghwndList, LB_ADDSTRING, (WPARAM) 0, (LPARAM) buffer);
        SendMessage(ghwndList, WM_SETREDRAW, (WPARAM) TRUE, (LPARAM) 0);
        InvalidateRect(ghwndList, NULL, TRUE);
        UpdateWindow(ghwndList);

        va_end(ap);
    }
}

/******************************Public*Routine******************************\
* LBreset
*
* Reset ListBox state (clear).
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBreset()
{
    if (ghwndList)
        SendMessage(ghwndList, LB_RESETCONTENT, (WPARAM) FALSE, (LPARAM) 0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(BOOL debug)
{
    WNDCLASS wc;

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_VISIBLE      |  
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL);

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }

    if (debug)
    {
        RECT rcl;

        memset(&wc, 0, sizeof(wc));
        wc.style = 0;
        wc.lpfnWndProc = DebugWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = ghInstance;
        wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = ghbrWhite;
        wc.lpszClassName = "DebugWClass";
        RegisterClass(&wc);

        ghwndDebug = CreateWindow(
            "DebugWClass",
            "Debug output",
            WS_OVERLAPPEDWINDOW|WS_MAXIMIZE,
            600,
            70,
            300,
            500,
            NULL,
            NULL,
            ghInstance,
            NULL
            );

        if (ghwndDebug)
        {
            ShowWindow(ghwndDebug, SW_NORMAL);
            UpdateWindow(ghwndDebug);

        // Create the list box to fill the main window.

            GetClientRect(ghwndDebug, &rcl);

            ghwndList = CreateWindow(
                "LISTBOX",
                "Debug output",
                WS_CHILD | WS_VISIBLE | WS_VSCROLL
                | WS_HSCROLL | LBS_NOINTEGRALHEIGHT,
                rcl.left, rcl.top,
                (rcl.right - rcl.left), (rcl.bottom - rcl.top),
                ghwndDebug,
                NULL,
                ghInstance,
                NULL
                );

            if (ghwndList)
            {
                SendMessage(
                    ghwndList,
                    WM_SETFONT,
                    (WPARAM) GetStockObject(ANSI_FIXED_FONT),
                    (LPARAM) FALSE
                    );

                LBreset();

                ShowWindow(ghwndList, SW_NORMAL);
                UpdateWindow(ghwndList);
            }
        }

    }

    SetFocus(ghwndMain);

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
    
    BOOL wantDebugWindow = FALSE;

    CoInitialize(NULL);

    // Parse arguments

    for (argc--, argv++ ; argc && '-' == **argv ; argc--, argv++ )
    {
        switch ( *(++(*argv)) )
        {
        case 'd':
        case 'D':
            wantDebugWindow = TRUE;
            break;
        }
    }

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp(wantDebugWindow))
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    CoUninitialize();
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gpcfm\engine\driver.cxx ===
#include <windows.h>
#include <stdio.h>
#define IStream int
#include <gdiplus.h>

#include <environ.hxx>
#include <report.hxx>
#include <epsilon.hxx>
#include <debug.hxx>
#include <driver.hxx>
#include <test.hxx>
#include <common.hxx>
#include <brushtst.hxx>
#include <regiontst.hxx>
#include <pentst.hxx>
#include <xformtst.hxx>
#include <gradienttst.hxx>

class TestList;

enum dctypes
{
    CACHEDDC,
    DISPLAYDC,                      // xxx multimonitor
    PRINTERDC,
    METAFILEDC,
    DDRAWSURFDC,
    DIBDC,
    CMPBMPDC
};

TCHAR *GetTypeString(int iType)
{
    switch(iType)
    {
        default:
        case CACHEDDC:
            return TEXT("CACHEDDC");

        case DISPLAYDC:
            return TEXT("DISPLAYDC");

        case PRINTERDC:
            return TEXT("PRINTERDC");

        case METAFILEDC:
            return TEXT("METAFILEDC");

        case DDRAWSURFDC:
            return TEXT("DDRAWSURFDC");

        case DIBDC:
            return TEXT("DIBDC");

        case CMPBMPDC:
            return TEXT("CMPBMPDC");
    }
}

HDC hdcAcquireDC(HWND hwnd, int types)
{
    switch (types)
    {
    default:
    case CACHEDDC:
        return GetDC(hwnd);
    /*
    case DISPLAYDC:

    case PRINTERDC:

    case METAFILEDC:
        HDC hdcref = GetDC(hwnd);
        RECT rc;

        GetClientRect(hwnd, &rc);
        return CreateEnhMetaFile(hdcref, NULL, &rc, TEXT("gpcfm.emf"));

    case DDRAWSURFDC:
        //

    case DIBDC:
    case CMPBMPDC:

    */
    }
}

class TestList
{
    friend int __cdecl main(int argc, char **argv);

    TestList(Report *rpt, int argc, char **argv)
    {
        if (argc > 1)
        {
            lstrcpy(AvailableTst[0], TEXT("BrushTst"));
            lstrcpy(AvailableTst[1], TEXT("PenTst"));
            lstrcpy(AvailableTst[2], TEXT("RegionTst"));
            lstrcpy(AvailableTst[3], TEXT("XformTst"));
            lstrcpy(AvailableTst[3], TEXT("GradientTst"));
            lNumTst = 4;
            bInitialized = bInit(rpt, argv[1]);
        }
        else
        {
            bInitialized = FALSE;
            rpt->vLog(TLS_LOG, "No script file");
        }
    }

    ~TestList()
    {
    }

    LONG lFindMatch(TCHAR *name)
    {
        //LONG lNumTst = sizeof(AvailableTst)/sizeof(AvailableTst[0]);
        for (LONG idx = 0; idx < lNumTst; idx++)
        {
            if (strcmp(AvailableTst[idx], name) == 0)
            {
                return idx;
            }
        }
        return -1;
    }

    BOOL bInit(Report *rpt, char *scr)
    {
        FILE *scriptFile;

        //
        // xxx retrieve name of script file from command line!
        //     save name of script file!
        //
        //scriptFile = fopen(TEXT("gpcfm.scr"), "r");
        scriptFile = fopen(scr, "r");
        if (scriptFile != NULL)
        {
            LONG idx = 0;
            TCHAR buf[MAX_STRING];

            while (!feof(scriptFile) && (idx < MAX_ELEMENTS-1))
            {
                fscanf(scriptFile, "%[^\n]", buf);
                if (buf[0] != '#')
                {
                    LONG index = lFindMatch(buf);
                    if (index == -1)
                    {
                        rpt->vLog(TLS_LOG, "%s not found", buf);
                        continue;
                    }
                    else
                    {
                        lst[idx++] = index;
                    }
                }
                fscanf(scriptFile, "%[\n]", buf);
            }
            lst[idx] = -1;
            fclose(scriptFile);
            return TRUE;
        }
        else
        {
            rpt->vLog(TLS_LOG, "Failed to open script file");
            return FALSE;
        }
    }

    Test* AcquireTst(TCHAR *pname)
    {
        Test *tst;

        if (strcmp(pname, TEXT("BrushTst")) == 0)
            tst = new BrushTst();
        else if (strcmp(pname, TEXT("PenTst")) == 0)
            tst = new PenTst();
        else if (strcmp(pname, TEXT("RegionTst")) == 0)
            tst = new RegionTst();
        else if (strcmp(pname, TEXT("XformTst")) == 0)
            tst = new XformTst();
        else if (strcmp(pname, TEXT("GradientTst")) == 0)
            tst = new GradientTst();

        return tst;
    }

public:
    LONG lst[MAX_ELEMENTS];
    BOOL bInitialized;
    TCHAR AvailableTst[100][MAX_STRING];
    LONG lNumTst;
};


int __cdecl main(int argc, char **argv)
{
    //
    // xxx retrieve name of log file from
    //     [option 1]   script file
    //     [option 2]   registry
    //     [option 3]   hardcoded, leave it as is
    //
    Report *rpt = new Report(TEXT("GpCfm.log"));

    //
    // xxx processing the command line
    //     do we want anything more than just the script file in command line?
    //
    TestList *tstLst = new TestList(rpt, argc, argv);

    if (tstLst->bInitialized)
    {
        Environment *env = new Environment();
        env->vStatusReport(rpt);

        //
        // xxx
        // how do we dynamically turn a particular one on or off?
        // - use a structure instead of enum...
        //   read from script and dis/enable as appropriate
        //
        // reminder: need to get GDI HDC from various Graphics context.
        //
        for (int dct = CACHEDDC; dct <= CMPBMPDC; dct++)
        {
            rpt->vLog(TLS_LOG, "DCTypes: %s", GetTypeString(dct));
            TestWnd *tstWnd = new TestWnd();
            if (tstWnd->hwnd)
            {
                HDC hdc = hdcAcquireDC(tstWnd->hwnd, dct);
                Epsilon *eps = new Epsilon(env, hdc);

                for (int i = 0; tstLst->lst[i] != -1; i++)
                {
                    Test *tst = tstLst->AcquireTst(tstLst->AvailableTst[tstLst->lst[i]]);
                    rpt->vStartVariation();

                    Graphics *gfx = new Graphics(hdc);

                    tst->vEntry(gfx, tstWnd->hwnd, rpt, eps);

                    delete gfx;

                    DWORD dwVer = rpt->dwEndVariation();
                    if (tst->hresult != NO_ERROR)
                    {
                        rpt->vLog(TLS_SEV3 | TLS_VARIATION, "%s failed", tstLst->AvailableTst[tstLst->lst[i]]);
                        eps->vReport(rpt);
                    }
                    else
                    {
                        rpt->vLog(dwVer | TLS_VARIATION, "%s passed", tstLst->AvailableTst[tstLst->lst[i]]);
                    }
                    delete tst;
                }
                delete eps;

                if (dct == CMPBMPDC)
                    tstWnd->vUnReg();
            }
            else
            {
                rpt->vLog(TLS_LOG, "Create TestWnd failed");
            }
        }
        delete env;
    }
    else
    {
        rpt->vLog(TLS_LOG, "TestList initialization failed");
    }
    delete rpt;
    return 0;
}


LRESULT CALLBACK WndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lr = 0;

    switch(uiMsg)
    {
        case WM_CLOSE:
            DestroyWindow(hwnd);
            break;
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
        default:
            lr = DefWindowProc(hwnd, uiMsg, wParam, lParam);
            break;
    }
    return lr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\imgtest\imgtest.cpp ===
//
// Simple test program for imaging library
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <objbase.h>
#include <urlmon.h>
#include <commdlg.h>

#include <imaging.h>
#include <initguid.h>
#include <imgguids.h>

#include "rsrc.h"

CHAR* programName;          // program name
HINSTANCE appInstance;      // handle to the application instance
HWND hwndMain;              // handle to application's main window
IImagingFactory* imgfact;   // pointer to IImageingFactory object
IImage* curImage;           // pointer to IImage object
CHAR curFilename[MAX_PATH]; // current image filename
INT scaleMethod = IDM_SCALE_NEIGHBOR;


//
// Display an error message dialog
//

BOOL
CheckHRESULT(
    HRESULT hr,
    INT line
    )
{
    if (SUCCEEDED(hr))
        return TRUE;

    CHAR buf[1024];

    sprintf(buf, "Error on line %d: 0x%x\n", line, hr);
    MessageBoxA(hwndMain, buf, programName, MB_OK);

    return FALSE;
}

#define CHECKHR(hr) CheckHRESULT(hr, __LINE__)
#define LASTWIN32HRESULT HRESULT_FROM_WIN32(GetLastError())

#if DBG
#define VERBOSE(args) printf args
#else
#define VERBOSE(args)
#endif


//
// Helper class to convert ANSI strings to Unicode strings
//

inline BOOL
UnicodeToAnsiStr(
    const WCHAR* unicodeStr,
    CHAR* ansiStr,
    INT ansiSize
    )
{
    return WideCharToMultiByte(
                CP_ACP,
                0,
                unicodeStr,
                -1,
                ansiStr,
                ansiSize,
                NULL,
                NULL) > 0;
}

inline BOOL
AnsiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
    )
{
    return MultiByteToWideChar(
                CP_ACP,
                0,
                ansiStr,
                -1,
                unicodeStr,
                unicodeSize) > 0;
}


class UnicodeStrFromAnsi
{
public:

    UnicodeStrFromAnsi(const CHAR* ansiStr)
    {
        if (ansiStr == NULL)
        {
            valid = TRUE;
            unicodeStr = NULL;
        }
        else
        {
            // NOTE: we only handle strings with length < MAX_PATH.

            valid = AnsiToUnicodeStr(ansiStr, buf, MAX_PATH);
            unicodeStr = valid ? buf : NULL;
        }
    }

    BOOL IsValid() const
    {
        return valid;
    }

    operator WCHAR*()
    {
        return unicodeStr;
    }

private:

    BOOL valid;
    WCHAR* unicodeStr;
    WCHAR buf[MAX_PATH];
};


//
// Get scale method strings and interpolation hints
//

const CHAR*
GetScaleMethodStr()
{
    switch (scaleMethod)
    {
    case IDM_SCALE_GDI:         return "GDI";
    case IDM_SCALE_GDIHT:       return "GDI + Halftone";
    case IDM_SCALE_NEIGHBOR:    return "Nearest Neighbor";
    case IDM_SCALE_BILINEAR:    return "Bilinear";
    case IDM_SCALE_AVERAGING:   return "Averaging";
    case IDM_SCALE_BICUBIC:     return "Bicubic";
    default:                    return "Unknown";
    }
}

InterpolationHint
GetScaleMethodInterp()
{
    switch (scaleMethod)
    {
    case IDM_SCALE_BILINEAR:    return INTERP_BILINEAR;
    case IDM_SCALE_AVERAGING:   return INTERP_AVERAGING;
    case IDM_SCALE_BICUBIC:     return INTERP_BICUBIC;
    case IDM_SCALE_NEIGHBOR:    return INTERP_NEAREST_NEIGHBOR;
    case IDM_SCALE_GDI:
    case IDM_SCALE_GDIHT:
    default:                    return INTERP_DEFAULT;
    }
}


//
// Get pixel format strings
//

const CHAR*
GetPixelFormatStr(
    PixelFormatID pixfmt
    )
{
    switch (pixfmt)
    {
    case PIXFMT_1BPP_INDEXED:       return "1bpp indexed";
    case PIXFMT_4BPP_INDEXED:       return "4bpp indexed";
    case PIXFMT_8BPP_INDEXED:       return "8bpp indexed";
    case PIXFMT_16BPP_GRAYSCALE:    return "16bpp grayscale";
    case PIXFMT_16BPP_RGB555:       return "16bpp RGB 5-5-5";
    case PIXFMT_16BPP_RGB565:       return "16bpp RGB 5-6-5";
    case PIXFMT_16BPP_ARGB1555:     return "16bpp ARGB 1-5-5-5";
    case PIXFMT_24BPP_RGB:          return "24bpp RGB";
    case PIXFMT_32BPP_RGB:          return "32bpp RGB";
    case PIXFMT_32BPP_ARGB:         return "32bpp ARGB";
    case PIXFMT_32BPP_PARGB:        return "32bpp premultiplied ARGB";
    case PIXFMT_48BPP_RGB:          return "48bpp RGB";
    case PIXFMT_64BPP_ARGB:         return "64bpp ARGB";
    case PIXFMT_64BPP_PARGB:        return "64bpp premultiplied ARGB";
    case PIXFMT_UNDEFINED:
    default:                        return "Unknown";
    }
}

//
// Force a refresh of the image window
//

VOID RefreshImageDisplay()
{
    InvalidateRect(hwndMain, NULL, FALSE);

    // Update window title

    CHAR title[2*MAX_PATH];
    CHAR* p = title;

    strcpy(p, curFilename);
    p += strlen(p);

    HRESULT hr;
    SIZE size;
    IBitmapImage* bmp;

    hr = curImage->QueryInterface(IID_IBitmapImage, (VOID**) &bmp);

    if (FAILED(hr))
    {
        // Decoded image

        hr = curImage->GetPhysicalDimension(&size);

        if (SUCCEEDED(hr))
        {
            sprintf(p, ", Dimension: %0.2fx%0.2fmm", size.cx / 100.0, size.cy / 100.0);
            p += strlen(p);
        }
    }
    else
    {
        // In-memory bitmap image

        hr = bmp->GetSize(&size);

        if (CHECKHR(hr))
        {
            sprintf(p, ", Size: %dx%d", size.cx, size.cy);
            p += strlen(p);
        }

        PixelFormatID pixfmt;

        hr = bmp->GetPixelFormatID(&pixfmt);

        if (CHECKHR(hr))
        {
            sprintf(p, ", Pixel Format: %s", GetPixelFormatStr(pixfmt));
            p += strlen(p);
        }

        bmp->Release();
    }

    sprintf(p, ", Scale Method: %s", GetScaleMethodStr());
    p += strlen(p);

    SetWindowText(hwndMain, title);
}


//
// Set the current image
//

VOID
SetCurrentImage(
    IUnknown* unk,
    const CHAR* filename = NULL
    )
{
    IImage* image;

    if (filename != NULL)
    {
        // Decoded image

        image = (IImage*) unk;
        strcpy(curFilename, filename);
    }
    else
    {
        // In-memory bitmap image

        HRESULT hr;

        hr = unk->QueryInterface(IID_IImage, (VOID**) &image);
        unk->Release();

        if (!CHECKHR(hr))
            return;

        strcpy(curFilename, "In-memory Bitmap");
    }

    if (curImage)
        curImage->Release();

    curImage = image;
    RefreshImageDisplay();
}


//
// Resize the window so it fits the image
//

#define MINWINWIDTH     200
#define MINWINHEIGHT    100
#define MAXWINWIDTH     1024
#define MAXWINHEIGHT    768

VOID
DoSizeWindowToFit(
    HWND hwnd,
    BOOL strict = FALSE
    )
{
    HRESULT hr;
    IBitmapImage* bmp;
    SIZE size;

    // Check if the current image is a bitmap image
    //  in that case, we'll get the pixel dimension

    hr = curImage->QueryInterface(IID_IBitmapImage, (VOID**) &bmp);

    if (SUCCEEDED(hr))
    {
        hr = bmp->GetSize(&size);
        bmp->Release();
    }

    // Otherwise, try to get device-independent image dimension

    if (FAILED(hr))
    {
        hr = curImage->GetPhysicalDimension(&size);
        if (FAILED(hr))
            return;

        size.cx = (INT) (size.cx * 96.0 / 2540.0 + 0.5);
        size.cy = (INT) (size.cy * 96.0 / 2540.0 + 0.5);
    }

    if (SUCCEEDED(hr))
    {
        // Figure out window border dimensions

        RECT r1, r2;
        INT w, h;

        w = size.cx;
        h = size.cy;

        if (!strict)
        {
            if (w < MINWINWIDTH)
                w = MINWINWIDTH;
            else if (w > MAXWINWIDTH)
                w = MAXWINWIDTH;

            if (h < MINWINHEIGHT)
                h = MINWINHEIGHT;
            else if (h > MAXWINHEIGHT)
                h = MAXWINHEIGHT;
        }

        GetWindowRect(hwnd, &r1);
        GetClientRect(hwnd, &r2);

        w += (r1.right - r1.left) - (r2.right - r2.left);
        h += (r1.bottom - r1.top) - (r2.bottom - r2.top);

        // Resize the window

        do
        {
            SetWindowPos(
                hwnd,
                NULL,
                0, 0, 
                w, h,
                SWP_NOMOVE | SWP_NOZORDER);

            GetClientRect(hwnd, &r2);
            h += GetSystemMetrics(SM_CYMENU);
        }
        while (r2.bottom == 0);
    }
}


//
// Convert current image to a bitmap image
//

IBitmapImage*
ConvertImageToBitmap(
    IImage* image,
    INT width = 0,
    INT height = 0,
    PixelFormatID pixfmt = PIXFMT_DONTCARE,
    InterpolationHint hint = INTERP_DEFAULT
    )
{
    if (!image)
        return NULL;

    HRESULT hr;
    IBitmapImage* bmp;

    hr = image->QueryInterface(IID_IBitmapImage, (VOID**) &bmp);

    if (SUCCEEDED(hr))
    {
        SIZE size;
        PixelFormatID fmt;

        // Current image is already a bitmap image and
        //  its dimension and pixel format are already as expected

        hr = bmp->GetSize(&size);
        if (!CHECKHR(hr))
            return NULL;

        hr = bmp->GetPixelFormatID(&fmt);
        if (!CHECKHR(hr))
            return NULL;

        if ((width == 0 || size.cx == width) &&
            (height == 0 || size.cy == height) &&
            (pixfmt == PIXFMT_DONTCARE || pixfmt == fmt))
        {
            return bmp;
        }

        bmp->Release();
    }

    // Convert the current image to a bitmap image

    if (width == 0 && height == 0)
    {
        ImageInfo imageInfo;
        hr = image->GetImageInfo(&imageInfo);

        // If the source image is scalable, then compute
        // the appropriate pixel dimension for the bitmap

        if (SUCCEEDED(hr) && (imageInfo.Flags & IMGFLAG_SCALABLE))
        {
            width = (INT) (96.0 * imageInfo.Width / imageInfo.Xdpi + 0.5);
            height = (INT) (96.0 * imageInfo.Height / imageInfo.Ydpi + 0.5);
        }
    }

    hr = imgfact->CreateBitmapFromImage(
                        image,
                        width, 
                        height, 
                        pixfmt,
                        hint,
                        &bmp);

    return SUCCEEDED(hr) ? bmp : NULL;
}


//
// Create an image object from a file
//

VOID
OpenImageFile(
    const CHAR* filename
    )
{
    HRESULT hr;
    IImage* image;
    IStream* stream;
    static BOOL useUrlMon = FALSE;

    if (useUrlMon)
    {
        // Use URLMON.DLL to turn file into stream

        CHAR fullpath[MAX_PATH];
        CHAR* p;

        if (!GetFullPathName(filename, MAX_PATH, fullpath, &p))
            return;

        hr = URLOpenBlockingStreamA(NULL, fullpath, &stream, 0, NULL);

        if (!CHECKHR(hr))
            return;

        hr = imgfact->CreateImageFromStream(stream, &image);
        stream->Release();
    }
    else
    {
        // Use filename directly 

        UnicodeStrFromAnsi namestr(filename);

        if (namestr.IsValid())
            hr = imgfact->CreateImageFromFile(namestr, &image);
        else
            hr = E_FAIL;
    }

    // Set the new image as the current image

    if (CHECKHR(hr))
    {
        SetCurrentImage(image, filename);
        DoSizeWindowToFit(hwndMain);
    }
}


//
// Save the current image to a file
//

VOID
SaveImageFile(
    const CHAR* filename,
    const CLSID* clsid
    )
{
    if (!curImage)
        return;

    // Create an encoder object

    HRESULT hr;
    IImageEncoder* encoder;
    UnicodeStrFromAnsi namestr(filename);

    if (namestr.IsValid())
        hr = imgfact->CreateImageEncoderToFile(clsid, namestr, &encoder);
    else
        hr = E_FAIL;

    if (!CHECKHR(hr))
        return;

    // Get an IImageSink interface to the encoder

    IImageSink* sink;

    hr = encoder->GetEncodeSink(&sink);

#if defined(ROTATION_TEST)
    // Rotation test

    EncoderParams*  pMyEncoderParams;

    pMyEncoderParams = (EncoderParams*)malloc
                       ( sizeof(EncoderParams)
                       + sizeof(EncoderParam));

    pMyEncoderParams->Params[0].paramGuid = ENCODER_ROTATION;
    pMyEncoderParams->Params[0].Value = "90";
    pMyEncoderParams->Count = 1;
    hr = encoder->SetEncoderParam(pMyEncoderParams);
    free(pMyEncoderParams);
#endif

    if (CHECKHR(hr))
    {
        hr = curImage->PushIntoSink(sink);
        CHECKHR(hr);

        sink->Release();
    }

    encoder->TerminateEncoder();
    encoder->Release();
}


//
// Handle window repaint event
//

VOID
DoPaint(
    HWND hwnd
    )
{
    HDC hdc;
    PAINTSTRUCT ps;
    RECT rect;
    DWORD timer;
    HRESULT hr = E_FAIL;

    hdc = BeginPaint(hwnd, &ps);

    GetClientRect(hwnd, &rect);

    if (scaleMethod == IDM_SCALE_GDIHT)
        SetStretchBltMode(hdc, HALFTONE);
    else
        SetStretchBltMode(hdc, COLORONCOLOR);

    VERBOSE(("Scale method: %d, ", scaleMethod));
    timer = GetTickCount();

    if (scaleMethod == IDM_SCALE_GDI || 
        scaleMethod == IDM_SCALE_GDIHT)
    {
        hr = curImage->Draw(hdc, &rect, NULL);

        VERBOSE(("GDI time: %dms\n", GetTickCount() - timer));
    }
    else
    {
        IBitmapImage* bmp;

        bmp = ConvertImageToBitmap(
                    curImage,
                    rect.right,
                    rect.bottom,
                    PIXFMT_DONTCARE,
                    GetScaleMethodInterp());

        if (!bmp)
            goto endPaint;

        VERBOSE(("Stretch time: %dms, ", GetTickCount() - timer));

        IImage* image;

        hr = bmp->QueryInterface(IID_IImage, (VOID**) &image);
        bmp->Release();

        if (FAILED(hr))
            goto endPaint;
        
        timer = GetTickCount();
        hr = image->Draw(hdc, &rect, NULL);
        VERBOSE(("GDI time: %dms\n", GetTickCount() - timer));

        image->Release();
    }

endPaint:

    if (FAILED(hr))
        FillRect(hdc, &rect, (HBRUSH) GetStockObject(BLACK_BRUSH));

    EndPaint(hwnd, &ps);
}


//
// Convert the current image to a bitmap
//

VOID
DoConvertToBitmap(
    HWND hwnd,
    INT menuCmd
    )
{
    // Map menu selection to its corresponding pixel format

    PixelFormatID pixfmt;

    switch (menuCmd)
    {
    case IDM_CONVERT_RGB555:
        pixfmt = PIXFMT_16BPP_RGB555;
        break;
        
    case IDM_CONVERT_RGB565:
        pixfmt = PIXFMT_16BPP_RGB565;
        break;
        
    case IDM_CONVERT_RGB24:
        pixfmt = PIXFMT_24BPP_RGB;
        break;
        
    case IDM_CONVERT_RGB32:
        pixfmt = PIXFMT_32BPP_RGB;
        break;
        
    case IDM_CONVERT_ARGB:
    default:
        pixfmt = PIXFMT_32BPP_ARGB;
        break;
    }

    // Convert the current image to a bitmap image

    IBitmapImage* bmp = ConvertImageToBitmap(curImage, 0, 0, pixfmt);

    // Set the bitmap image as the current image

    if (bmp)
        SetCurrentImage(bmp);
}


//
// Compose a file type filter string given an array of
// ImageCodecInfo structures
//

#define SizeofWSTR(s) (sizeof(WCHAR) * (wcslen(s) + 1))
#define SizeofSTR(s) (strlen(s) + 1)

CHAR*
MakeFilterFromCodecs(
    UINT count,
    const ImageCodecInfo* codecs,
    BOOL open
    )
{
    static const CHAR allFiles[] = "All Files\0*.*\0";

    // Figure out the total size of the filter string

    UINT index, size;

    for (index=size=0; index < count; index++)
    {
        size += SizeofWSTR(codecs[index].FormatDescription) +
                SizeofWSTR(codecs[index].FilenameExtension);
    }

    if (open)
        size += sizeof(allFiles);
    
    size += sizeof(CHAR);

    // Allocate memory

    CHAR *filter = (CHAR*) malloc(size);
    CHAR* p = filter;
    const WCHAR* ws;

    if (!filter)
        return NULL;

    for (index=0; index < count; index++)
    {
        ws = codecs[index].FormatDescription;
        size = SizeofWSTR(ws);

        if (UnicodeToAnsiStr(ws, p, size))
            p += SizeofSTR(p);
        else
            break;

        ws = codecs[index].FilenameExtension;
        size = SizeofWSTR(ws);

        if (UnicodeToAnsiStr(ws, p, size))
            p += SizeofSTR(p);
        else
            break;
    }

    if (index < count)
    {
        free(filter);
        return NULL;
    }

    if (open)
    {
        size = sizeof(allFiles);
        memcpy(p, allFiles, size);
        p += size;
    }

    *((CHAR*) p) = '\0';
    return filter;
}


//
// Open image file
//

VOID
DoOpen(
    HWND hwnd
    )
{
    OPENFILENAME ofn;
    CHAR filename[MAX_PATH];

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = appInstance;
    ofn.lpstrFile = filename;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Open Image File";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_FILEMUSTEXIST;
    filename[0] = '\0';

    // Make up the file type filter string

    HRESULT hr;
    ImageCodecInfo* codecs;
    UINT count;

    hr = imgfact->GetInstalledDecoders(&count, &codecs);

    if (!CHECKHR(hr))
        return;

    CHAR* filter = MakeFilterFromCodecs(count, codecs, TRUE);

    if (codecs)
        CoTaskMemFree(codecs);

    if (!filter)
    {
        CHECKHR(LASTWIN32HRESULT);
        return;
    }

    ofn.lpstrFilter = filter;
    
    // Present the file/open dialog

    if (GetOpenFileName(&ofn))
        OpenImageFile(filename);

    free(filter);
}


//
// Save image file
//

VOID
DoSave(
    HWND hwnd
    )
{
    OPENFILENAME ofn;
    CHAR filename[MAX_PATH];

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = appInstance;
    ofn.lpstrFile = filename;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = "Save Image File";
    ofn.lpstrInitialDir = ".";
    ofn.Flags = OFN_CREATEPROMPT | OFN_OVERWRITEPROMPT;
    filename[0] = '\0';

    // Make up the file type filter string

    HRESULT hr;
    ImageCodecInfo* codecs;
    UINT count;

    hr = imgfact->GetInstalledEncoders(&count, &codecs);

    if (!CHECKHR(hr))
        return;

    CHAR* filter = MakeFilterFromCodecs(count, codecs, FALSE);

    if (!filter)
    {
        CHECKHR(LASTWIN32HRESULT);
    }
    else
    {
        ofn.lpstrFilter = filter;

        // Present the file/save dialog

        if (GetSaveFileName(&ofn))
        {
            UINT index = ofn.nFilterIndex;

            if (index == 0 || index > count)
                index = 0;
            else
                index--;

            SaveImageFile(filename, &codecs[index].Clsid);
        }   

        free(filter);
    } 

    CoTaskMemFree(codecs);
}


//
// Crop the image
//
// NOTE: We're not spending time here to do a fancy UI.
//  So we'll just inset the image by 5 pixels each time.
//

VOID
DoCrop(
    HWND hwnd
    )
{
    IBitmapImage* bmp;

    if (bmp = ConvertImageToBitmap(curImage))
    {
        HRESULT hr;
        IBasicBitmapOps* bmpops = NULL;
        SIZE size;

        hr = bmp->QueryInterface(IID_IBasicBitmapOps, (VOID**) &bmpops);

        if (CHECKHR(hr))
            hr = bmp->GetSize(&size);

        if (CHECKHR(hr))
        {
            RECT r = { 5, 5, size.cx - 5, size.cy - 5 };
            IBitmapImage* newbmp;

            hr = bmpops->Clone(&r, &newbmp, TRUE);

            if (CHECKHR(hr))
                SetCurrentImage(newbmp);
        }

        if (bmp) bmp->Release();
        if (bmpops) bmpops->Release();
    }
}


//
// Resize the image to the current window size, using bilinear scaling
//

VOID
DoResize(
    HWND hwnd
    )
{
    RECT rect;
    HRESULT hr;
    IBitmapImage* bmp;

    GetClientRect(hwnd, &rect);

    bmp = ConvertImageToBitmap(
                curImage,
                rect.right,
                rect.bottom,
                PIXFMT_DONTCARE,
                INTERP_BILINEAR);

    if (bmp)
        SetCurrentImage(bmp);
}


//
// Flip or rotate the image
//

VOID
DoFlipRotate(
    HWND hwnd,
    INT menuCmd
    )
{
    IBitmapImage* bmp;
    IBitmapImage* newbmp;
    IBasicBitmapOps* bmpops;
    HRESULT hr;

    bmp = ConvertImageToBitmap(curImage);

    if (!bmp)
        return;

    hr = bmp->QueryInterface(IID_IBasicBitmapOps, (VOID**) &bmpops);

    if (CHECKHR(hr))
    {
        switch (menuCmd)
        {
        case IDM_BMP_FLIPX:
            hr = bmpops->Flip(TRUE, FALSE, &newbmp);
            break;
        case IDM_BMP_FLIPY:
            hr = bmpops->Flip(FALSE, TRUE, &newbmp);
            break;
        case IDM_BMP_ROTATE90:
            hr = bmpops->Rotate(90, INTERP_DEFAULT, &newbmp);
            break;
        case IDM_BMP_ROTATE270:
            hr = bmpops->Rotate(270, INTERP_DEFAULT, &newbmp);
            break;
        }

        bmpops->Release();

        if (CHECKHR(hr))
        {
            SetCurrentImage(newbmp);

            if (menuCmd == IDM_BMP_ROTATE90 ||
                menuCmd == IDM_BMP_ROTATE270)
            {
                DoSizeWindowToFit(hwnd);
            }
        }
    }

    bmp->Release();
}


//
// Perform point operation on the image
//

VOID
DoPointOps(
    HWND hwnd,
    INT menuCmd
    )
{
    IBitmapImage* bmp;
    IBitmapImage* newbmp;
    IBasicBitmapOps* bmpops;
    HRESULT hr;

    bmp = ConvertImageToBitmap(curImage);

    if (!bmp)
        return;

    hr = bmp->QueryInterface(IID_IBasicBitmapOps, (VOID**) &bmpops);

    if (CHECKHR(hr))
    {
        switch (menuCmd)
        {
        case IDM_BRIGHTEN:
            hr = bmpops->AdjustBrightness(0.1f);
            break;
        case IDM_DARKEN:
            hr = bmpops->AdjustBrightness(-0.1f);
            break;
        case IDM_INCCONTRAST:
            hr = bmpops->AdjustContrast(-0.1f, 1.1f);
            break;
        case IDM_DECCONTRAST:
            hr = bmpops->AdjustContrast(0.1f, 0.9f);
            break;
        case IDM_INCGAMMA:
            hr = bmpops->AdjustGamma(1.1f);
            break;
        case IDM_DECGAMMA:
            hr = bmpops->AdjustGamma(0.9f);
            break;
        }

        bmpops->Release();

        if (CHECKHR(hr))
            SetCurrentImage(bmp);
    }

    if (FAILED(hr))
        bmp->Release();
}

VOID
DisplayProperties(
        IPropertySetStorage *propSetStg
        )
{
    HRESULT hresult;
    IPropertyStorage *propStg;
    IEnumSTATPROPSTG *enumPS;

    hresult = propSetStg->Open(FMTID_ImageInformation, STGM_READ | STGM_SHARE_EXCLUSIVE, &propStg);
    if (FAILED(hresult)) 
    {
        //printf("DisplayProperties:  failed to open propSetStg\n");
        return;
    }

    hresult = propStg->Enum(&enumPS);
    if (FAILED(hresult)) 
    {
        printf("DisplayProperties:  failed to create enumerator\n");
        return;
    }

    hresult = enumPS->Reset();
    if (FAILED(hresult)) 
    {
        printf("DisplayProperties:  failed to reset enumerator\n");
        return;
    }

    STATPROPSTG sps;
    while ((enumPS->Next(1, &sps, NULL)) == S_OK) 
    {
        if (sps.lpwstrName) 
        {
            wprintf(sps.lpwstrName);
            CoTaskMemFree(sps.lpwstrName);

            PROPSPEC propSpec[1];
            PROPVARIANT propVariant[1];
            
            propSpec[0].ulKind = PRSPEC_PROPID;
            propSpec[0].propid = sps.propid;

            hresult = propStg->ReadMultiple(1, propSpec, propVariant);
            if (FAILED(hresult)) 
            {
                printf("DisplayProperties:  failed in ReadMultiple\n");
            }

            switch(propVariant[0].vt) 
            {
            case VT_BSTR:
                wprintf(L" : %s\n", propVariant[0].bstrVal);
                break;

            case VT_I4:
                wprintf(L" : %d\n", propVariant[0].lVal);
                break;

            case VT_R8:
                wprintf(L" : %f\n", (FLOAT) propVariant[0].dblVal);
                break;

            default:
                wprintf(L"Unknown VT type\n");
                break;
            }

            PropVariantClear(&propVariant[0]);
        }
    }

    enumPS->Release();
    propStg->Release();
}

//
// Handle menu commands
//

VOID
DoMenuCommand(
    HWND hwnd,
    INT menuCmd
    )
{
    switch (menuCmd)
    {
    case IDM_OPEN:
        DoOpen(hwnd);
        break;

    case IDM_SAVE:
        DoSave(hwnd);
        break;

    case IDM_QUIT:
        PostQuitMessage(0);
        break;

    case IDM_FIT_WINDOW:
        DoSizeWindowToFit(hwnd, TRUE);
        break;

    case IDM_CONVERT_RGB555:
    case IDM_CONVERT_RGB565:
    case IDM_CONVERT_RGB24:
    case IDM_CONVERT_RGB32:
    case IDM_CONVERT_ARGB:
        DoConvertToBitmap(hwnd, menuCmd);
        break;

    case IDM_SCALE_GDI:
    case IDM_SCALE_GDIHT:
    case IDM_SCALE_NEIGHBOR:
    case IDM_SCALE_BILINEAR:
    case IDM_SCALE_AVERAGING:
    case IDM_SCALE_BICUBIC:
        scaleMethod = menuCmd;
        RefreshImageDisplay();
        break;

    case IDM_BMP_CROP:
        DoCrop(hwnd);
        break;

    case IDM_BMP_RESIZE:
        DoResize(hwnd);
        break;

    case IDM_BMP_FLIPX:
    case IDM_BMP_FLIPY:
    case IDM_BMP_ROTATE90:
    case IDM_BMP_ROTATE270:
        DoFlipRotate(hwnd, menuCmd);
        break;
    
    case IDM_BRIGHTEN:
    case IDM_DARKEN:
    case IDM_INCCONTRAST:
    case IDM_DECCONTRAST:
    case IDM_INCGAMMA:
    case IDM_DECGAMMA:
        DoPointOps(hwnd, menuCmd);
        break;    
    }
}


//
// Window callback procedure
//

LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch (uMsg)
    {
    case WM_COMMAND:
        DoMenuCommand(hwnd, LOWORD(wParam));
        break;

    case WM_PAINT:
        DoPaint(hwnd);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//
// Create main application window
//

#define MYWNDCLASSNAME "ImgTest"

VOID
CreateMainWindow(
    VOID
    )
{
    HBRUSH hBrush = CreateSolidBrush(RGB(255, 250, 250));
    //
    // Register window class
    //

    WNDCLASS wndClass =
    {
        CS_HREDRAW|CS_VREDRAW,
        MyWindowProc,
        0,
        0,
        appInstance,
        LoadIcon(NULL, IDI_APPLICATION),
        LoadCursor(NULL, IDC_ARROW),
        hBrush,
        MAKEINTRESOURCE(IDR_MAINMENU),
        MYWNDCLASSNAME
    };

    RegisterClass(&wndClass);

    hwndMain = CreateWindow(
                    MYWNDCLASSNAME,
                    MYWNDCLASSNAME,
                    WS_OVERLAPPEDWINDOW,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    NULL,
                    NULL,
                    appInstance,
                    NULL);

    if (!hwndMain)
    {
        CHECKHR(HRESULT_FROM_WIN32(GetLastError()));
        exit(-1);
    }
}


//
// Create a new test bitmap object from scratch
//

#define STEPS 16

VOID
CreateNewTestBitmap()
{
    IBitmapImage* bmp;
    BitmapData bmpdata;
    HRESULT hr;

    hr = imgfact->CreateNewBitmap(
                STEPS,
                STEPS,
                PIXFMT_32BPP_ARGB,
                &bmp);

    if (!CHECKHR(hr))
        return;

    hr = bmp->LockBits(
                NULL,
                IMGLOCK_WRITE,
                PIXFMT_DONTCARE,
                &bmpdata);

    if (!CHECKHR(hr))
    {
        bmp->Release();
        return;
    }

    // Make a horizontal blue gradient

    UINT x, y;
    ARGB colors[STEPS];

    for (x=0; x < STEPS; x++)
        colors[x] = MAKEARGB(255, 0, 0, x * 255 / (STEPS-1));

    for (y=0; y < STEPS; y++)
    {
        ARGB* p = (ARGB*) ((BYTE*) bmpdata.Scan0 + y*bmpdata.Stride);

        for (x=0; x < STEPS; x++)
            *p++ = colors[(x+y) % STEPS];
    }

    bmp->UnlockBits(&bmpdata);
    SetCurrentImage(bmp);
}


//
// Main program entrypoint
//

INT _cdecl
main(
    INT argc,
    CHAR **argv
    )
{
    programName = *argv++;
    argc--;
    appInstance = GetModuleHandle(NULL);
    CoInitialize(NULL);

    //
    // Create an IImagingFactory object
    //
     
    HRESULT hr;

    hr = CoCreateInstance(
            CLSID_ImagingFactory,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IImagingFactory,
            (VOID**) &imgfact);

    if (!CHECKHR(hr))
        exit(-1);

    //
    // Create the main application window
    //

    CreateMainWindow();

    //
    // Create a test image
    //

    if (argc != 0)
        OpenImageFile(*argv);
    
    if (!curImage)
        CreateNewTestBitmap();

    if (!curImage)
        exit(-1);

    DoSizeWindowToFit(hwndMain);
    ShowWindow(hwndMain, SW_SHOW);

    //
    // Main message loop
    //

    MSG msg;
    HACCEL accel;

    accel = LoadAccelerators(appInstance, MAKEINTRESOURCE(IDR_ACCELTABLE));

    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, accel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    curImage->Release();
    imgfact->Release();

    CoUninitialize();
    return (INT)(msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\gradient\gradient.cpp ===
/******************************Module*Header*******************************\
* Module Name: test.c
*
* Created: 09-Dec-1992 10:51:46          
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
* Contains the test
*
\**************************************************************************/

#include <windows.h>
#include <objbase.h>
#include <math.h>             // sin & cos
#include "wndstuff.h"
#include "debug.h"

//
// Where is IStream included from?
//

#define IStream int

#include <gdiplus.h>

using namespace Gdiplus;

#ifndef ASSERT
    #define ASSERT(cond)    if (!(cond)) { DebugBreak(); }
#endif


// Figures out the Affine matrix mapping from the unit square to the
// input parallelogram

VOID InferAffineMatrix(
    const GpPointF* destPoints,  // must be 3 points.
    Matrix *m
    )
{
    float x0 = destPoints[0].X;
    float y0 = destPoints[0].Y;
    float x1 = destPoints[1].X;
    float y1 = destPoints[1].Y;
    float x2 = destPoints[2].X;
    float y2 = destPoints[2].Y;

    float u0 = 0.0f;
    float v0 = 0.0f;
    float u1 = u0 + 1.0f;
    float v1 = v0;
    float u2 = u0;
    float v2 = v0 + 1.0f;

    float d = u0*(v1-v2) - v0*(u1-u2) + (u1*v2-u2*v1);

    if (fabsf(d) < REAL_EPSILON)
    {
        ASSERT(FALSE);
        return;
    }
    
    d = 1.0f / d;

    float t0 = v1-v2;
    float t1 = v2-v0;
    float t2 = v0-v1;
    float M11 = d * (x0*t0 + x1*t1 + x2*t2);
    float M12 = d * (y0*t0 + y1*t1 + y2*t2);

    t0 = u2-u1;
    t1 = u0-u2;
    t2 = u1-u0;
    float M21 = d * (x0*t0 + x1*t1 + x2*t2);
    float M22 = d * (y0*t0 + y1*t1 + y2*t2);

    t0 = u1*v2-u2*v1;
    t1 = u2*v0-u0*v2;
    t2 = u2*v1-u1*v0;
    float Dx  = d * (x0*t0 + x1*t1 + x2*t2);
    float Dy  = d * (y0*t0 + y1*t1 + y2*t2);
    
    m->SetElements(M11, M12, M21, M22, Dx, Dy);
}


/******************************Public*Routine******************************\
* vTest
*
* This is the workhorse routine that does the test. The test is
* started by chosing it from the window menu.
*
* History:
*  Tue 08-Dec-1992 17:31:22 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/


const PointF center(400.0f, 400.0f);

VOID Test(HWND hwnd)
{
    Graphics *g = new Graphics(hwnd);
    
    //g->SetSmoothingMode(SmoothingModeAntiAlias);
    
    DWORD c0 = 0xff0000ff;
    DWORD c1 = 0xffff0000;
    DWORD c2 = 0xff00ff00;
    
    LinearGradientBrush brush(
        PointF(-0.5f, -0.5f), 
        PointF(0.5f, 0.5f),
        Color(c0),
        Color(c1)
    );
    
    Pen edgePen(Color(0xff000000), 3.5f/400.0f);
    
    brush.SetGammaCorrection(TRUE);
    brush.SetWrapMode(WrapModeTile);
    brush.SetBlendTriangularShape(0.5f, 1.0f);
//    brush.SetBlendBellShape(0.2f, 0.5f);
    
    Matrix m;
    
    GraphicsPath gp;
    
    PointF points[4] = {
        PointF(-0.5f, -0.5f),
        PointF(0.5f, -0.5f),
        PointF(0.5f, 0.5f),
        PointF(-0.5f, 0.5f)
    };
    
    Matrix bm;
    brush.GetTransform(&bm);
    
    gp.AddPolygon(points, 4);
    
    
    
    g->TranslateTransform(center.X, center.Y);
    g->ScaleTransform(400.0f, 400.0f);
  /*  
    m.SetElements(100.0f, 0.0f, 0.0f, 300.0f, 0.0f, 0.0f);
    gp.Transform(&m);
    brush.MultiplyTransform(&m, MatrixOrderAppend);
    g->FillPath(&brush, &gp);
    g->TranslateTransform(-200.0f, 0.0f);
    brush.SetTransform(&bm);
    brush.SetLinearPoints(PointF(0.0f, 0.0f), PointF(100.0f, 300.0f));
    brush.SetLinearColors(Color(c1), Color(c0));
    g->FillPath(&brush, &gp);
  
  */
    
    // Simple rotate on the brush transform
    
    g->DrawPath(&edgePen, &gp);
    
    for(int i = 0; i < 181; i++)
    {
        g->FillPath(&brush, &gp);
        brush.RotateTransform(1.0f);
    }
    
    brush.SetTransform(&bm);
    
    // Vertical stretch, no brush transform.
    
    for(int i = 0; i < 101; i++)
    {
        float t = i/100.0f;
        float r = 2.0f*(float)M_PI*(t);
        m.Reset();
        m.Scale(1.0f, 1.0f + (float)sin(r)/70.0f);
        gp.Transform(&m);
        g->FillPath(&brush, &gp);
        g->DrawPath(&edgePen, &gp);
    }
    
    brush.SetTransform(&bm);
    gp.Reset();
    gp.AddPolygon(points, 4);

    for(int i = 0; i < 101; i++)
    {
        float t = i/100.0f;
        float r = 2.0f*(float)M_PI*(t);
        m.Reset();
        m.Scale(1.0f + (float)sin(r)/70.0f, 1.0f);
        gp.Transform(&m);
        g->FillPath(&brush, &gp);
        g->DrawPath(&edgePen, &gp);
    }
    
    brush.SetTransform(&bm);
    gp.Reset();
    gp.AddPolygon(points, 4);

    for(int i = 0; i < 101; i++)
    {
        float r = (float)M_PI*(i/200.0f);
        m.Reset();
        m.Scale(1.0f, 1.0f + (float)sin(r));
        
        gp.Reset();
        gp.AddPolygon(points, 4);
        gp.Transform(&m);
        
        brush.SetTransform(&bm);
        brush.GetTransform(&m);
        m.Scale(1.0f, 1.0f+(float)sin(r), MatrixOrderAppend);
        brush.SetTransform(&m);
        g->FillPath(&brush, &gp);
        g->DrawPath(&edgePen, &gp);
    }
    
    for(int i = 0; i < 101; i++)
    {
        float r = (float)M_PI*(i/200.0f);
        m.Reset();
        m.Scale(
            1.0f + (float)sin(r), 
            1.0f + (float)sin(r+M_PI/2.0f)
        );
        
        gp.Reset();
        gp.AddPolygon(points, 4);
        gp.Transform(&m);
        
        brush.SetTransform(&bm);
        brush.GetTransform(&m);
        
        m.Scale(
            1.0f + (float)sin(r), 
            1.0f + (float)sin(r+M_PI/2.0f), 
            MatrixOrderAppend
        );
        
        brush.SetTransform(&m);
        g->FillPath(&brush, &gp);
        g->DrawPath(&edgePen, &gp);
    }

    for(int i = 0; i < 101; i++)
    {
        float r = (float)M_PI*(i/200.0f);
        m.Reset();
        m.Scale(
            1.0f + (float)sin(r+M_PI/2.0f), 
            1.0f
        );
        
        gp.Reset();
        gp.AddPolygon(points, 4);
        gp.Transform(&m);
        
        brush.SetTransform(&bm);
        brush.GetTransform(&m);
        
        m.Scale(
            1.0f+(float)sin(r+M_PI/2.0f), 
            1.0f,
            MatrixOrderAppend
        );
        
        brush.SetTransform(&m);
        g->FillPath(&brush, &gp);
        g->DrawPath(&edgePen, &gp);
    }
   
    brush.SetTransform(&bm);
    gp.Reset();
    gp.AddPolygon(points, 4);
    
    Matrix gm;
    g->GetTransform(&gm);
   
    for(int i = 0; i < 181; i++)
    {
        g->FillPath(&brush, &gp);
        g->DrawPath(&edgePen, &gp);
        brush.RotateTransform(-1.0f);
        g->RotateTransform(1.0f);
    }

    for(int i = 0; i < 181; i++)
    {
        g->FillPath(&brush, &gp);
        g->DrawPath(&edgePen, &gp);
        g->RotateTransform(1.0f);
    }

    for(int i = 0; i < 181; i++)
    {
        float r = (float)M_PI*(i/180.0f);
        g->FillPath(&brush, &gp);
        g->SetTransform(&gm);
        g->RotateTransform((float)i);
        g->ScaleTransform(
            1.0f+(float)sin(r)/2.0f, 
            1.0f,
            MatrixOrderAppend
        );
    }
    g->SetTransform(&gm);
    brush.SetTransform(&bm);
    gp.Reset();
    gp.AddPolygon(points, 4);
    g->FillPath(&brush, &gp);
    g->DrawPath(&edgePen, &gp);
    delete g;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\libtest\libtest.cpp ===
/******************************Module*Header*******************************\
* Module Name: test.c
*
* Created: 09-Dec-1992 10:51:46
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
* Contains the test
*
\**************************************************************************/

#include <windows.h>
#include <objbase.h>
#include <math.h>             // sin & cos
#include "debug.h"

#define USE_NEW_APIS 1
#define USE_NEW_APIS2 1

//
// Where is IStream included from?
//

#define IStream int

#include <gdiplus.h>

using namespace Gdiplus;

/******************************Public*Routine******************************\
* vTest
*
* This is the workhorse routine that does the test. The test is
* started by chosing it from the window menu.
*
* History:
*  Tue 08-Dec-1992 17:31:22 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

class RectI
{
public:
    INT X;
    INT Y; 
    INT Width;
    INT Height;
};

VOID TestContainerClip(Graphics *g);
VOID TestContainer(Graphics *g);
VOID TestPolygons(Graphics *g);
VOID TestPaths(Graphics *g);
VOID TestDashes(Graphics *g);
VOID TestRegions(Graphics *g);
VOID TestGradients(Graphics* g);
VOID TestHatches(Graphics* g);
VOID TestBitmaps(Graphics* g);
VOID TestPrimitives(Graphics *g);
VOID TestMixedObjects(Graphics *g);
VOID TestTexts(Graphics* g);
VOID TestTextAlongPath(Graphics *g);
VOID TestDerive(HWND hwnd);
VOID TestImaging(Graphics* g);
VOID TestBitmapGraphics(Graphics* g);
VOID TestCompoundLines(Graphics *g);

VOID
Test(
    HWND hwnd
    )
{
    Graphics *g = Graphics::FromHWND(hwnd);
    g->SetSmoothingMode(SmoothingModeAntiAlias);

    // Scale everything up by scale
    REAL scale = (REAL) 1.2;
    g->SetPageUnit(UnitDisplay);
    g->SetPageScale(scale);
    g->RotateTransform(10);

    {
        HDC     hdc = GetDC(hwnd);
        {
            Metafile    recording(L"TestEmfP.Emf", hdc);
            Graphics    gMeta(&recording);
    
            gMeta.SetSmoothingMode(SmoothingModeAntiAlias);
            TestContainer(&gMeta);
        }
    
        GpRectF playbackRect;
        g->GetVisibleClipBounds(&playbackRect);

        {
            Metafile    playback(L"TestEmfP.Emf");
            g->DrawImage(&playback, playbackRect);
        }

        ReleaseDC(hwnd, hdc);
    }
    
    TestContainerClip(g);
    TestPolygons(g);
    TestPaths(g);
    TestRegions(g);
    TestBitmaps(g);
    TestPrimitives(g);
    TestMixedObjects(g);
    TestGradients(g);
    TestHatches(g);
    TestTexts(g);
    TestDerive(hwnd);
    TestImaging(g);
    TestDashes(g);
    TestBitmapGraphics(g);
    TestCompoundLines(g);

    delete g;
}


VOID DrawContainer(Graphics * g, ARGB * argb, INT count)
{
    Matrix    mymatrix;
    g->SetPageUnit(UnitInch);

    Rect clipRect(0,0,5,5);
    g->SetClip(clipRect);

    mymatrix.Translate(2.5, 2.5);
    mymatrix.Rotate(15);
    mymatrix.Translate(-2.5, -2.5);
    g->SetTransform(&mymatrix);

    Color   color(*argb++); 
    SolidBrush contBrush(color);
    g->FillRectangle(&contBrush, 0, 0, 5, 5);
    if (--count == 0)
    {
        return;
    }
    RectF     destRect(.5, .5, 4, 4);
    RectF     srcRect(0, 0, 5, 5);
    INT id = g->BeginContainer(destRect, srcRect, UnitInch);
    g->ResetClip();
    DrawContainer (g, argb, count);
    g->EndContainer(id);
}

VOID TestContainerClip(Graphics *g)
{
    ARGB     colors[5];
    
    colors[0] = Color::MakeARGB(255, 255, 0, 0);
    colors[1] = Color::MakeARGB(255, 0, 255, 0);
    colors[2] = Color::MakeARGB(255, 0, 0, 255);
    colors[3] = Color::MakeARGB(255, 255, 255, 0);
    colors[4] = Color::MakeARGB(255, 0, 255, 255);

    GraphicsState s = g->Save();
    DrawContainer(g, colors, 5);
    g->Restore(s);
}

GraphicsPath      circlePath;
RectF        circleRect(0,0,4,4);

#define ROOT    0
#define LEFT    1
#define RIGHT   2
#define TOP     3
#define BOTTOM  4


VOID DrawFractal(Graphics * g, BYTE gray, INT side, INT count)
{
    ARGB        argb;

    switch (count % 3)
    {
    case 0:
        argb = Color::MakeARGB(255, 0, 0, gray);
        break;
    case 1:
        argb = Color::MakeARGB(255, 0, gray, 0);
        break;
    case 2:
        argb = Color::MakeARGB(255, gray, 0, 0);
        gray -= 60;
        break;
    }
    Color   color(argb);
    SolidBrush contBrush(color);
    g->SetPageUnit(UnitInch);
    g->FillPath(&contBrush, &circlePath);
    
    if (--count == 0)
    {
        return;
    }

    RectF              destRect;
    GraphicsContainer  cstate;

    if (side != LEFT)
    {
        destRect = RectF(4, 1, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, RIGHT, count);
        g->EndContainer(cstate);
    }
    if (side != TOP)
    {
        destRect = RectF(1, 4, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, BOTTOM, count);
        g->EndContainer(cstate);
    }
    if (side != RIGHT)
    {
        destRect = RectF(-2, 1, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, LEFT, count);
        g->EndContainer(cstate);
    }
    if (side != BOTTOM)
    {
        destRect = RectF(1, -2, 2, 2);
        cstate = g->BeginContainer(destRect, circleRect, UnitInch);
        g->SetSmoothingMode(SmoothingModeAntiAlias);
        DrawFractal(g, gray, TOP, count);
        g->EndContainer(cstate);
    }
}

VOID TestContainer(Graphics * g)
{
    circlePath.AddEllipse(circleRect);
    
    INT id = g->Save();
    g->TranslateTransform(5, 4);
    DrawFractal(g, 245, ROOT, 8);
    g->Restore(id);
}

/**************************************************************************\
* TestPolygons
*
* A test for drawing and filling of rectangles and polygons.
*
\**************************************************************************/

VOID TestPolygons(Graphics *g)
{
    REAL width = 4; // Pen width

    Color redColor(255, 0, 0);

    SolidBrush redBrush(redColor);
    g->FillRectangle(&redBrush, 20, 20, 50, 50);

    Color alphaColor(128, 0, 255, 0);

    SolidBrush alphaBrush(alphaColor);
    g->FillRectangle(&alphaBrush, 10, 10, 40, 40);

    Point points[4];
    points[0].X = 50;
    points[0].Y = 50;
    points[1].X = 100;
    points[1].Y = 50;
    points[2].X = 120;
    points[2].Y = 120;
    points[3].X = 50;
    points[3].Y = 100;    

    Color blueColor(128, 0, 0, 255);

    SolidBrush blueBrush(blueColor);
    g->FillPolygon(&blueBrush, points, 4);

    // Currently only Geometric pen works for lines. - ikkof 1/6/99.

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);
    blackPen.SetLineJoin(LineJoinRound);
    g->DrawPolygon(&blackPen, points, 4);
//    g->DrawLines(&blackPen, points, 4, FALSE);
}


/**************************************************************************\
* TestPaths
*
* A test for general paths.
*
\**************************************************************************/

VOID TestPaths(Graphics *g)
{
    REAL width = 4;         // Pen width
    Point points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);
    path->Transform(&matrix);
    
    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = (REAL) 0.2;
    Pen blackPen(&blackBrush, width);
    blackPen.SetStartCap(LineCapRound);
//    blackPen.SetEndCap(LineCapSquare);
    blackPen.SetEndCap(LineCapArrowAnchor);
    Region * region = new Region(path);
    g->FillPath(&yellowBrush, path);
    g->DrawPath(&blackPen, path);
    delete path;
    delete region;
}

/**************************************************************************\
* TestDashes
*
* A test for drawing dashed lines.
*
\**************************************************************************/

VOID TestDashes(Graphics *g)
{
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    path->Transform(&matrix);

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = (REAL) 0.2;
    Pen pen1(&blackBrush, width);
    pen1.SetDashStyle(DashStyleDashDotDot);
    pen1.SetDashCap(DashCapRound);
    g->DrawPath(&pen1, path);

    // Create a multiple segment with a closed segment.

    points[0].X = 50;
    points[0].Y = 50;
    points[1].X = 100;
    points[1].Y = 50;
    points[2].X = 120;
    points[2].Y = 120;
    points[3].X = 50;
    points[3].Y = 100;    

    path->Reset();
    path->AddLines(points, 4);
    path->CloseFigure();

    points[0].X = 150;
    points[0].Y = 60;
    points[1].X = 200;
    points[1].Y = 150;
    path->AddLines(points, 2);
    path->Transform(&matrix);

    Color blueColor(128, 0, 0, 255);

    SolidBrush blueBrush(blueColor);

    width = 5;
    Pen pen2(&blueBrush, width);
    pen2.SetDashStyle(DashStyleDashDotDot);
    g->DrawPath(&pen2, path);

    delete path;
}

/**************************************************************************\
* TestRegions
*
* A test for region fill.
*
\**************************************************************************/

VOID TestRegions(Graphics *g)
{
    REAL width = 2;     // Pen width
    PointF points[5];
    
    REAL s, c, theta;
    REAL pi = 3.1415926535897932f;
    REAL scale = 30;
    PointF orig(200, 140);

    theta = -pi/2;

    // Create a star shape.
    for(INT i = 0; i < 5; i++)
    {
        s = sinf(theta);
        c = cosf(theta);
        points[i].X = scale*c + orig.X;
        points[i].Y = scale*s + orig.Y;
        theta += 0.8f*pi;
    }

    Color orangeColor(128, 255, 180, 0);

    SolidBrush orangeBrush(orangeColor);
    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
//    Path* path = new GraphicsPath(Winding);
    path->AddPolygon(points, 5);
    
    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);
    Region * region = new Region(path);

    g->FillRegion(&orangeBrush, region);  // There is a BUG!
//    g->FillGraphicsPath(&orangeBrush, path);  // Fill path works fine.
    
    blackPen.SetLineJoin(LineJoinMiter);
    g->DrawPath(&blackPen, path);
    delete path;
    delete region;
}

GraphicsPath* CreateHeartPath(const RectF& rect)
{
    GpPointF points[7];
    points[0].X = 0;
    points[0].Y = 0;
    points[1].X = 1.00;
    points[1].Y = -1.00;
    points[2].X = 2.00;
    points[2].Y = 1.00;
    points[3].X = 0;
    points[3].Y = 2.00;
    points[4].X = -2.00;
    points[4].Y = 1.00;
    points[5].X = -1.00;
    points[5].Y = -1.00;
    points[6].X = 0;
    points[6].Y = 0;

    Matrix matrix;

    matrix.Scale(rect.Width/2, rect.Height/3, MatrixOrderAppend);
    matrix.Translate(3*rect.Width/2, 4*rect.Height/3, MatrixOrderAppend);
    matrix.TransformPoints(&points[0], 7);

    GraphicsPath* path = new GraphicsPath();
    
    if(path)
    {
        path->AddBeziers(&points[0], 7);
        path->CloseFigure();
    }

    return path;
}

    
/**************************************************************************\
* TestGradients
*
* A test for rectangle and radial gradients.
*
\**************************************************************************/

VOID TestGradients(Graphics* g)
{
    REAL width = 4; // Pen width

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 32, 32);

    Color colors[5] = {
        Color(255, 255, 255, 255),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 0, 0, 0)
    };

//    RectangleGradientBrush rectGrad(brushRect, (Color*) &colors, WrapModeTile);
    
    // Rotate a brush.
    GpMatrix xForm;
    xForm.Rotate(30);
//    rectGrad.SetTransform(&xForm);

    // Change the wrapping mode and fill.

// !! No longer supported
//    rectGrad.SetWrapMode(WrapModeTileFlipXY);
//    g->FillRectangle(&rectGrad, 350, 20, 100, 80);
    
    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    Pen blackPen(&blackBrush, width);

    g->DrawRectangle(&blackPen, brushRect);

    // Create a radial gradient brush.

    Color centerColor(255, 255, 255, 255);
    Color boundaryColor(255, 0, 0, 0);
    brushRect.X = 380;
    brushRect.Y = 130;
    brushRect.Width = 60;
    brushRect.Height = 32;
    PointF center;
    center.X = brushRect.X + brushRect.Width/2;
    center.Y = brushRect.Y + brushRect.Height/2;
    xForm.Reset();
    xForm.RotateAt(-30, center, MatrixOrderAppend);
// !! No longer supported
//    RadialGradientBrush radGrad(brushRect, centerColor,
//                                boundaryColor, WrapModeClamp);
//    radGrad.SetTransform(&xForm);
//    g->FillRectangle(&radGrad, 320, 120, 120, 100);

//    Pen gradPen(&rectGrad, width);
//    g->DrawRectangle(&gradPen, 320, 120, 120, 100);

    // Triangle gradient.
    
    PointF points[7];
    points[0].X = 50;
    points[0].Y = 10;
    points[1].X = 200;
    points[1].Y = 20;
    points[2].X = 100;
    points[2].Y = 100;
    points[3].X = 30;
    points[3].Y = 120;

    Color colors1[5] = {
        Color(255, 255, 255, 0),
        Color(255, 255, 0, 0),
        Color(255, 0, 255, 0),
        Color(255, 0, 0, 255),
        Color(255, 0, 0, 0)
    };

// !! No longer supported
//    TriangleGradientBrush triGrad(points, (Color*) &colors);
//    g->FillPolygon(&triGrad, points, 3);
    RectF triRect;
//    triGrad.GetRectangle(triRect);
//    g->FillRectangle(&triGrad, triRect);

    points[0].X = 200;
    points[0].Y = 300;
    points[1].X = 280;
    points[1].Y = 350;
    points[2].X = 220;
    points[2].Y = 420;
    points[3].X = 160;
    points[3].Y = 440;
    points[4].X = 120;
    points[4].Y = 370;

    PathGradientBrush polyGrad(points, 5);

    REAL blend[10];
    Color presetColors[10];
    REAL positions[10];
    INT count;
    INT i;

    count = 3;
    blend[0] = (REAL) 0;
    blend[1] = (REAL) 0;
    blend[2] = (REAL) 1;
    positions[0] = (REAL) 0;
    positions[1] = (REAL) 0.4;
    positions[2] = (REAL) 1;

    // Test for blending factors.

    polyGrad.SetBlend(&blend[0], &positions[0], count);

    polyGrad.SetCenterColor(centerColor);
    i = 5;
    polyGrad.SetSurroundColors(colors1, &i);
    
//    g->FillPolygon(&polyGrad, points, 5);
    RectF polyRect;
    polyGrad.GetRectangle(&polyRect);
    g->FillRectangle(&polyGrad, polyRect);

    // Create a heart shaped path.

    RectF rect;
    rect.X = 300;
    rect.Y = 300;
    rect.Width = 150;
    rect.Height = 150;
    GraphicsPath *path = CreateHeartPath(rect);

    // Create a gradient from a path.

    PathGradientBrush pathGrad(path);
    delete path;
    pathGrad.SetCenterColor(centerColor);
    i = 1;
    pathGrad.SetSurroundColors(&Color(255, 255, 0, 0), &i);
    pathGrad.GetRectangle(&polyRect);

    // Set the rect focus.

    PointF centerPt;

    pathGrad.GetCenterPoint(&centerPt);
    centerPt.X -= 15;
    centerPt.Y += 30;
    pathGrad.SetCenterPoint(centerPt);
    REAL xScale, yScale;
    pathGrad.GetFocusScales(&xScale, &yScale);
    xScale = 0.4f;
    yScale = 0.3f;
    pathGrad.SetFocusScales(xScale, yScale);

    g->FillRectangle(&pathGrad, polyRect);

    // Test for LineGradientBrush.

    RectF lineRect(120, -20, 200, 60);
    Color color1(200, 255, 255, 0);
    Color color2(200, 0, 0, 255);

    LinearGradientBrush lineGrad(lineRect, color1, color1,
                        LinearGradientModeForwardDiagonal);

    // Test for preset colors

    presetColors[0] = Color(200, 0, 255, 255);
    presetColors[1] = Color(200, 255, 255, 0);
    presetColors[2] = Color(200, 0, 255, 0);
    lineGrad.SetInterpolationColors(&presetColors[0], &positions[0], count);

    g->FillRectangle(&lineGrad, lineRect);

}
    

/**************************************************************************\
* TestHatches
*
* A test for hatch brushes
*
\**************************************************************************/

VOID TestHatches(Graphics* g)
{
    Color foreColor(0, 0, 0);
    Color backColor(128, 255, 255, 255);

    HatchStyle style[6];
    style[0] = HatchStyleForwardDiagonal;
    style[1] = HatchStyleBackwardDiagonal;
    style[2] = HatchStyleCross;
    style[3] = HatchStyleDiagonalCross;
    style[4] = HatchStyleHorizontal;
    style[5] = HatchStyleVertical;

    // Pick one of the above hatch styles.

    HatchBrush hatch(style[3], foreColor, backColor);
    g->FillRectangle(&hatch, 200, 20, 100, 80);
}

/**************************************************************************\
* TestBitmaps
*
* A test for texture filling and DrawImage.
*
\**************************************************************************/

VOID TestBitmaps(Graphics* g)
{
    Point points[4];
    REAL width = 4;     // Pen width


    WCHAR filename[256];
    wcscpy(filename, L"../data/brick.jpg");
    Bitmap *bitmap = new Bitmap(filename);

    // Create a texture brush.

    RectI copyRect;
    copyRect.X = 0;
    copyRect.Y = 0;
    copyRect.Width = 40;
    copyRect.Height = 30;

    Bitmap *copiedBitmap = bitmap->Clone(copyRect.X, copyRect.Y,
                                         copyRect.Width, copyRect.Height,
                                         PixelFormat32bppARGB);
 
    if(copiedBitmap)
    {
        // Create a texture brush.
                          
        TextureBrush textureBrush(copiedBitmap, WrapModeTile);

        //copiedBitmap->Dispose();
        
        // Create a radial gradient pen.

        Color redColor(255, 0, 0);

        SolidBrush redBrush(redColor);
        Pen redPen(&redBrush, width);

        GraphicsPath *path;

        points[0].X = 100;
        points[0].Y = 60;
        points[1].X = -50;
        points[1].Y = 60;
        points[2].X = 150;
        points[2].Y = 250;
        points[3].X = 200;
        points[3].Y = 120;
        path = new GraphicsPath(FillModeAlternate);
        path->AddBeziers(points, 4);    
        g->FillPath(&textureBrush, path);
        g->DrawPath(&redPen, path);

        delete path;
        delete copiedBitmap;
    }

    delete bitmap;

    PointF destPoints[3];

    destPoints[0].X = 300;
    destPoints[0].Y = 50;
    destPoints[1].X = 450;
    destPoints[1].Y = 50;
    destPoints[2].X = 240;
    destPoints[2].Y = 200;
 
    Matrix mat;
    mat.Translate(0, 100);
    mat.TransformPoints(&destPoints[0], 3);
    wcscpy(filename, L"../data/apple1.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);
 
    delete bitmap;

    destPoints[0].X = 30;
    destPoints[0].Y = 200;
    destPoints[1].X = 200;
    destPoints[1].Y = 200;
    destPoints[2].X = 200;
    destPoints[2].Y = 420;

    wcscpy(filename, L"../data/dog2.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);
 
    delete bitmap;

    Color color(100, 128, 255, 0);

    SolidBrush brush(color);

    Point pts[10];
    INT count = 4;

    pts[0].X = 150;
    pts[0].Y = 60;
    pts[1].X = 100;
    pts[1].Y = 230;
    pts[2].X = 250;
    pts[2].Y = 260;
    pts[3].X = 350;
    pts[3].Y = 100;

    g->FillClosedCurve(&brush, pts, count);

    wcscpy(filename, L"../data/ballmer.jpg");
    bitmap = new Bitmap(filename);
    RectF destRect(220, 50, 180, 120);
    RectF srcRect;
    srcRect.X = 100;
    srcRect.Y = 40;
    srcRect.Width = 200;
    srcRect.Height = 200;
    g->DrawImage(bitmap, destRect, srcRect.X, srcRect.Y,
        srcRect.Width, srcRect.Height, UnitPixel);
    delete bitmap;
}

/**************************************************************************\
* TestPrimitives
*
* A test for ellipse, arc, pie, curve, and closed curve.
*
\**************************************************************************/

VOID
TestPrimitives(
    Graphics* g
    )
{
    RectF rect;

    rect.X = 250;
    rect.Y = 230;
    rect.Width = 150;
    rect.Height = 100;

    Color color(128, 128, 255, 0);

    SolidBrush brush(color);

    REAL width = 1;

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen pen(&blackBrush, width);

//    g->FillEllipse(&brush, rect);
//    g->DrawEllipse(&pen, rect);
    REAL startAngle = 0;
    REAL sweepAngle = 240;
    g->FillPie(&brush, rect, startAngle, sweepAngle);
    g->DrawPie(&pen, rect, startAngle, sweepAngle);

    PointF pts[10];
    INT count = 4;

    pts[0].X = 200;
    pts[0].Y = 160;
    pts[1].X = 150;
    pts[1].Y = 230;
    pts[2].X = 200;
    pts[2].Y = 260;
    pts[3].X = 300;
    pts[3].Y = 200;

    g->FillClosedCurve(&brush, pts, count);
    g->DrawClosedCurve(&pen, pts, count);
}


/**************************************************************************\
* TestMixedObjects
*
* A test for different brushes and pens.
*
\**************************************************************************/

VOID TestMixedObjects(Graphics* g)
{
    Point points[10];
    REAL width = 4;     // Pen width

    // Load bmp files.

    WCHAR *filename = L"winnt256.bmp";
    Bitmap *bitmap = new Bitmap(filename);

    // Create a texture brush.

    RectI copyRect;
    copyRect.X = 60;
    copyRect.Y = 60;
    copyRect.Width = 80;
    copyRect.Height = 60;
    Bitmap *copiedBitmap = bitmap->Clone(copyRect.X, copyRect.Y,
                                            copyRect.Width, copyRect.Height,
                                            PixelFormat32bppPARGB);

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 32, 32);
    Color colors[4] = {
       Color(255, 255, 255, 255),
       Color(255, 255, 0, 0),
       Color(255, 0, 255, 0),
       Color(255, 0, 0, 255)
    };
// !! No longer supported
//    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors, WrapModeTile);
    width = 8;
//    Pen gradPen(&rectGrad, width);

    if(copiedBitmap)
    {
        // Create a texture brush.

        TextureBrush textureBrush(copiedBitmap, WrapModeTile);

        //copiedBitmap->Dispose();
        
        // Create a radial gradient pen.

        points[3].X = 50;
        points[3].Y = 300;
        points[2].X = 100;
        points[2].Y = 300;
        points[1].X = 120;
        points[1].Y = 370;
        points[0].X = 50;
        points[0].Y = 350;

//        gradPen.SetLineJoin(LineJoinMiter);
        g->FillPolygon(&textureBrush, points, 4); 
//        g->DrawPolygon(&gradPen, points, 4);
    }

    delete copiedBitmap;
    delete bitmap;
}

/**************************************************************************\
* TestTexts
*
* A test for drawing texts.
*
\**************************************************************************/

VOID TestTexts(Graphics *g)
{
    //Font font(L"Arial", 60);

    FontFamily  ff(L"Arial");
    RectF     rectf(20, 0, 300, 200);
    GraphicsPath  path;

    // Solid color text.

    Color color(128, 100, 0, 200);
    SolidBrush brush(color);
    path.AddString(L"Color", 5, &ff, 0, 60,  rectf, NULL);
    g->FillPath(&brush, &path);

    // Texture text.

    WCHAR filename[256];
    wcscpy(filename, L"../data/marble1.jpg");
    Bitmap *bitmap = new Bitmap(filename);                          
    TextureBrush textureBrush(bitmap, WrapModeTile);
    path.Reset();
    rectf.X = 200;
    rectf.Y = 20;
    path.AddString(L"Texture", 7, &ff, 0, 60, rectf, NULL);
    g->FillPath(&textureBrush, &path);
    delete bitmap;

    // Gradient text.

    rectf.X = 40;
    rectf.Y = 80;
    path.Reset();
    path.AddString(L"Gradient", 8, &ff, 0, 60, rectf, NULL);
    Color color1(255, 255, 0, 0);
    Color color2(255, 0, 255, 0);
    LinearGradientBrush lineGrad(rectf, color1, color2, 0.0f);
    g->FillPath(&lineGrad, &path);

    // Shadow test

    REAL charHeight = 60;
    REAL topMargin = - 5;
    rectf.X = 0;
    rectf.Y = - charHeight - topMargin; // Make y-coord of the base line
                                        // of the characters to be 0.

    path.Reset();
    path.AddString(L"Shadow", 6, &ff, 0, charHeight, rectf, NULL);
    GraphicsPath* clonePath = path.Clone();

    Color redColor(255, 0, 0);
    Color grayColor(128, 0, 0, 0);
    SolidBrush redBrush(redColor);
    SolidBrush grayBrush(grayColor);

    // Shadow part.

    REAL tx = 180, ty = 200;
    Matrix skew;
    skew.Scale(1.0, 0.5);
    skew.Shear(-2.0, 0, MatrixOrderAppend);
    skew.Translate(tx, ty, MatrixOrderAppend);
    clonePath->Transform(&skew);
    g->FillPath(&grayBrush, clonePath);
    delete clonePath;

    // Front part.

    Matrix trans1;
    trans1.Translate(tx, ty);
    path.Transform(&trans1);
    g->FillPath(&redBrush, &path);


    return;
/*
    REAL x = 200, y = 150;

    RectF brushRect(x, y, 150, 32);
    Color colors[4] = {
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0),
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0)
    };
    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors, WrapModeTile);

    g->DrawString(L"GDI+", &font, &rectGrad, x, y);


    // And now with DrawText

    RectF rect(400, 200, 400, 400);

    g->DrawText(
        DrawTextDisplay,
        L"A few words powered by GDI+: \
\x3c3\x3bb\x3b1\x3b4 \
\x627\x644\x633\x644\x627\x645 \
\x5e9\x5dc\x5d5\x5dd \
\xe2d\xe4d\xe01\xe29\xe23\xe44\xe17\xe22 \
\x110\x068\x0ea\x300\x103",
       &font,           // Initial font
       &rectGrad,       // Initial brush (ignored for the time being)
        LANG_NEUTRAL,   // Initial language
       &rect            // Formatting rectangle
    );
*/

}

VOID TestTextAlongPath(Graphics *g)
{
    Point points[4];

    points[3].X = 100;
    points[3].Y = 10;
    points[2].X = -50;
    points[2].Y = 50;
    points[1].X = 150;
    points[1].Y = 200;
    points[0].X = 200;
    points[0].Y = 70;

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    path->Transform(&matrix);

    Color textColor(180, 200, 0, 200);
    SolidBrush textBrush(textColor);

    WCHAR text[] = L"Windows 2000";

    REAL offset = 60;

//    g->DrawString(text, 12, NULL, path, NULL, &textBrush, offset);

    delete path;
}

/**************************************************************************\
* TestDerive
*
* Test 
* A test for derivation support.
*
\**************************************************************************/

VOID 
TestDerive(
    HWND hwnd
    )
{
    HDC hdcScreen = GetDC(hwnd);
    HRGN hrgn = CreateEllipticRgn(10, 10, 300, 300);

    SetMapMode(hdcScreen, MM_TWIPS);
    SelectClipRgn(hdcScreen, hrgn);
    HBRUSH hbrushRed = CreateSolidBrush(RGB(255, 0, 0));
    SelectObject(hdcScreen, hbrushRed);
    Rectangle(hdcScreen, 0, 0, 3000, -3000);

    {
        Graphics g(hdcScreen);                                     
        SolidBrush solidBrush(Color(0, 255, 0));
        g.FillRectangle(&solidBrush, 0, -3000, 3000, 3000);
    }

    HBITMAP hbmBitmap = CreateCompatibleBitmap(hdcScreen, 50, 50);
    HDC hdcBitmap = CreateCompatibleDC(hdcScreen);
    SelectObject(hdcBitmap, hbmBitmap);
    SetWindowOrgEx(hdcBitmap, 40, 80, NULL);

    SelectObject(hdcBitmap, hbrushRed);
    Rectangle(hdcBitmap, 40, 80, 50, 50);

    {
        Graphics g(hdcBitmap);
        SolidBrush solidBrush(Color(0, 0, 255));
        g.FillRectangle(&solidBrush, 40, 80, 90, 130);

#if 0

        // The DC that we get back should have the same transform set
        // as that which we originally passed in:

        HDC hdcGet = g.GetHdc();
        point.x = 0;
        point.y = 0;
        DPtoLP(hdcGet, &point, 1);

        // !!! BAD on Alpha box
        // if ((hdcGet == NULL) || (point.x != 40) || (point.y != 80)) _asm int 3;

        g.ReleaseHdc(hdcGet);

#endif

    }

    // The DC should have beeen returned to the top save level:

    INT saveLevel = SaveDC(hdcBitmap);

    // !!! BAD on Alpha box
    // if (saveLevel != 1) _asm int 3;

    // The DC should have had its transform restored:

    POINT oldPoint;
    SetWindowOrgEx(hdcBitmap, 0, 0, &oldPoint);

    // !!! BAD on Alpha box
    // if ((oldPoint.x != 40) || (oldPoint.y != 80)) _asm int 3;

    // Blt the (hopefully) blue square to the screen.  But first,
    // reset our transform on 'hdcScreen' the lazy way:

    ReleaseDC(hwnd, hdcScreen);
    hdcScreen = GetDC(hwnd);
    BitBlt(hdcScreen, 0, 0, 50, 50, hdcBitmap, 0, 0, SRCCOPY);
    ReleaseDC(hwnd, hdcScreen);
}

/**************************************************************************\
* TestImaging
*
* A test for imaging and DrawImage.
*
\**************************************************************************/

BOOL CALLBACK MyDrawImageAbort(VOID* data)
{
    UINT *count = (UINT*) data;

    *count += 1;

    //LBprintf("MyDrawImageAbort: %ld", *count);

    return FALSE;
}

VOID TestImaging(Graphics* g)
{
    // Load bmp files.

    WCHAR *filename = L"winnt256.bmp";
    Image *image = new Image(filename);

    // Get information on the image.

    Image *imageThumb = image->GetThumbnailImage(32, 32);

    // Try to save thumbnail

    WCHAR *thumbfile = L"thumb256.bmp";

    CLSID _BmpCodecClsID_ =
    {
        0x557cf400,
        0x1a04,
        0x11d3,
        {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
    };

    if (imageThumb->Save(thumbfile, &_BmpCodecClsID_, NULL) == Ok)
        LBprintf("thumbnail save OK");
    else
        LBprintf("thumbnail save failed");

    RectF srcRect;
    srcRect.X = 20;
    srcRect.Y = 20;
    srcRect.Width = 180;
    srcRect.Height = 180;

    PointF points[4];

    PointF destPoints[3];

    destPoints[0].X = 300;
    destPoints[0].Y = 50;
    destPoints[1].X = 450;
    destPoints[1].Y = 50;
    destPoints[2].X = 240;
    destPoints[2].Y = 200;
    //g->DrawImage(image, &destPoints[0], 3);

    RectF thumbRect(220, 50, (REAL) imageThumb->GetWidth(), (REAL) imageThumb->GetHeight());
    
    //g->DrawImage(imageThumb, thumbRect);

    UINT abortCount = 0;

    ImageAttributes imgAttrib;

    Rect destRect(50, 10, 100, 100);

    // Make near-white to white transparent

    Color c1(200, 200, 200);
    Color c2(255, 255, 255);
    imgAttrib.SetColorKey(c1, c2);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    ColorMatrix darkMatrix = {.75, 0, 0, 0, 0,
                              0, .75, 0, 0, 0,
                              0, 0, .75, 0, 0,
                              0, 0, 0, 1, 0,
                              0, 0, 0, 0, 1};

    ColorMatrix greyMatrix = {.25, .25, .25, 0, 0,
                              .25, .25, .25, 0, 0,
                              .25, .25, .25, 0, 0,
                              0, 0, 0, 1, 0,
                              (REAL).1, (REAL).1, (REAL).1, 0, 1};

    ColorMatrix pinkMatrix = {(REAL).33, .25, .25, 0, 0,
                              (REAL).33, .25, .25, 0, 0,
                              (REAL).33, .25, .25, 0, 0,
                              0, 0, 0, 1, 0,
                              0, 0, 0, 0, 1};

    // red->blue, green->red, blue->green, alpha = 0.75
    ColorMatrix swapMatrix = {0, 0, 1, 0, 0,
                              1, 0, 0, 0, 0,
                              0, 1, 0, 0, 0,
                              0, 0, 0, .75, 0,
                              0, 0, 0, 0, 1};

    // red->blue, green->red, blue->green, alpha = 0.9
    ColorMatrix swapMatrix2 = {0, 0, 1, 0, 0,
                               1, 0, 0, 0, 0,
                               0, 1, 0, 0, 0,
                               0, 0, 0, 0, 0,
                               0, 0, 0, (REAL).9, 1};

    imgAttrib.ClearColorKey();
    imgAttrib.SetColorMatrix(&greyMatrix);

    destRect.Y += destRect.Height;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    imgAttrib.SetColorMatrix(&pinkMatrix, ColorMatrixFlagsSkipGrays);

    destRect.Y += destRect.Height;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    imgAttrib.SetColorMatrix(&darkMatrix);

    destRect.X += destRect.Width;
    destRect.Y = 10;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    destRect.Y += destRect.Height;

    imgAttrib.ClearColorMatrix();
    imgAttrib.SetGamma(3.0);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    destRect.Y += destRect.Height;

    imgAttrib.SetThreshold(0.5);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    imgAttrib.SetColorMatrix(&swapMatrix);
    imgAttrib.ClearGamma();
    imgAttrib.ClearThreshold();

    destRect.X += destRect.Width;
    destRect.Y = 10;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    destRect.Y += destRect.Height;

    imgAttrib.SetNoOp();
    imgAttrib.SetColorMatrix(&swapMatrix2);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    destRect.Y += destRect.Height;

    imgAttrib.ClearNoOp();

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    delete image;
    delete imageThumb;
}

VOID TestBitmapGraphics(Graphics* g)
{
    INT bitmapSize = 500;

    Bitmap* bitmap = new Bitmap(bitmapSize, bitmapSize, g);

    if (!bitmap)
        LBprintf("Bitmap creation failed");
    else
    {
        LBprintf("ImageInfo: %ld x %ld", bitmap->GetWidth(), bitmap->GetHeight());
    }

    Graphics *bitmapGraphics = Graphics::FromImage(bitmap);

    if (!bitmapGraphics)
        LBprintf("Bitmap.GetGraphics() failed");

    TestContainerClip(bitmapGraphics);
    TestContainer(bitmapGraphics);
    TestPolygons(bitmapGraphics);
    TestPaths(bitmapGraphics);
    TestRegions(bitmapGraphics);
    TestGradients(bitmapGraphics);
    TestHatches(bitmapGraphics);
    TestBitmaps(bitmapGraphics);
    TestPrimitives(bitmapGraphics);
    TestMixedObjects(bitmapGraphics);
    TestTexts(bitmapGraphics);
    TestImaging(bitmapGraphics);

    delete bitmapGraphics;

    Rect destRect(100, 100, bitmapSize, bitmapSize);

    g->DrawImage(bitmap, destRect, 0, 0, bitmapSize, bitmapSize, UnitPixel);

    delete bitmap;
}

/**************************************************************************\
* TestCompoundLines
*
* A test for compound lines.
*
\**************************************************************************/

VOID TestCompoundLines(Graphics *g)
{
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);

    points[0].X = 260;
    points[0].Y = 20;
    path->AddLines(points, 1);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);
    matrix.Translate(0, 30);

    // If you wanto to flatten the path before rendering,
    // Flatten() can be called.

    BOOL flattenFirst = FALSE;

    if(!flattenFirst)
    {
        // Don't flatten and keep the original path.
        // FillPath or DrawPath will flatten the path automatically
        // without modifying the original path.

        path->Transform(&matrix);
    }
    else
    {
        // Flatten this path.  The resultant path is made of line
        // segments.  The original path information is lost.

        path->Flatten(&matrix);
    }

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = (REAL) 0.2;
    Pen blackPen(&blackBrush, width);

    REAL* compoundArray = new REAL[6];
    compoundArray[0] = 0.0f;
    compoundArray[1] = 0.2f;
    compoundArray[2] = 0.4f;
    compoundArray[3] = 0.6f;
    compoundArray[4] = 0.8f;
    compoundArray[5] = 1.0f;
    blackPen.SetCompoundArray(&compoundArray[0], 6);
    blackPen.SetDashStyle(DashStyleDash);

    blackPen.SetStartCap(LineCapDiamondAnchor);    
    blackPen.SetEndCap(LineCapArrowAnchor);

    g->FillPath(&yellowBrush, path);
    g->DrawPath(&blackPen, path);
    
    delete [] compoundArray;
    delete path;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\libtest\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#define MM_NEW          0x8001
#define MM_EXIT         0x8002
#define MM_TEST         0x8003

VOID Test(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\multithread\precomp.hpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commdlg.h>
#include <string.h>
#include <math.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <commctrl.h>
#include <winspool.h>
#include <wingdi.h>
#include <malloc.h>
#include <limits.h>
#include <ntverp.h>

#include <objbase.h>
#include <gdiplus/gdiplus.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\multithread\multithread.cpp ===
// This is a dual threaded test app designed to expose a weakness in 
// GDI+. The CreateDCA("DISPLAY", NULL, NULL, NULL) used to create our
// Globals::DesktopDc during GdiplusStartup has thread affinity (as opposed
// to other inputs to CreateDCA) and therefore when the creation thread
// is terminated, the global DC goes away. This will cause random drawing
// failure in gdiplus.
//
// The main thread spawns a 'creation' thread to initialize gdiplus and draw
// something. When it's done and terminated, the main thread attempts to draw
// something on the screen before shutting down gdiplus. By the time the 
// main thread gets to draw something, the DesktopDc has been cleaned up and
// we ASSERT in gdiplus.
//
// Created: 02/03/2001 [asecchia]
//

#include "precomp.hpp"

using namespace Gdiplus;

GdiplusStartupInput sti;
ULONG_PTR token;
bool gdiplusInitialized = false;
DWORD threadId;


// This is a CriticalSection Proxy designed to 
// automatically acquire the critical section 
// when the instance is created and release 
// it when it goes out of scope.

class ThreadMutex
{
public:

    static VOID InitializeCriticalSection()
    {
        ::InitializeCriticalSection(&critSec);
    }

    static VOID DeleteCriticalSection()
    {
        ::DeleteCriticalSection(&critSec);
    }

    ThreadMutex()
    {
        EnterCriticalSection(&critSec);
    }

    ~ThreadMutex()
    {
        LeaveCriticalSection(&critSec);
    }

private:
    static CRITICAL_SECTION critSec;
};

CRITICAL_SECTION ThreadMutex::critSec;

// This is the main routine for the creation thread.
// GDI+ will be initialized on this thread and we'll draw a red rectangle
// on the screen.
// It's protected under the thread mutex help ensure this thread is done
// before the main thread continues.
// This is not normally a useful requirement, but for the purposes of this 
// test, it's important.

DWORD WINAPI ThreadProc(VOID*)
{
    ThreadMutex tm;
    
    gdiplusInitialized = (Ok == GdiplusStartup(&token, &sti, NULL));
    
    if(gdiplusInitialized)
    {
        HDC hdc = GetDC(NULL);
        
        // Draw a red rectangle.
        
        Graphics g(hdc);
        SolidBrush brush(Color(0x3fff0000));
        g.FillRectangle(&brush, 300, 300, 400, 200);    
        
        ReleaseDC(NULL, hdc);
    }
    
    return 1;
}


// Main thread of execution.

void __cdecl main( void )
{
    ThreadMutex::InitializeCriticalSection();
    
    // Make the creation thread.

    CreateThread(
        NULL,                        // LPSECURITY_ATTRIBUTES
        0,                           // same stack size
        &ThreadProc,
        0,                           // parameter to thread
        0,                           // creation flags
        &threadId
    );


    // wait for the creation thread to initialize gdiplus.
    // This ensures the creation thread happens first and ensures the
    // correct ordering of acquiring the ThreadMutex.
    
    do { } while(!gdiplusInitialized);

    {
        // block till the ThreadMutex becomes available.
        // This ensures that the creation thread is done before we get started.
        
        ThreadMutex tm;

        // The thread mutex will ensure that we don't start till the thread
        // proc for the creation thread is done. However we want to wait till
        // NTUSER is done cleaning up our thread specific resources during
        // thread terminationi and that's not protected by the ThreadMutex.
        // Wait 5 seconds here to ensure that thread termination has enough
        // time to finish.
        
        Sleep(500);
        
        // If initialization of gdiplus was successful, draw a blue rectangle.
        
        if(gdiplusInitialized)
        {
            HDC hdc = GetDC(NULL);
        
            // Draw a blue rectangle.
                
            Graphics g(hdc);
            SolidBrush brush(Color(0x3f0000ff));
            g.FillRectangle(&brush, 100, 100, 400, 200);    
            
            ReleaseDC(NULL, hdc);
        }
    }
    
    // scope barrier so the objects above destruct before we call shutdown.
    
    if(gdiplusInitialized)
    {
        GdiplusShutdown(token);
    }
    
    ThreadMutex::DeleteCriticalSection();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\moo\moo.cxx ===
#include <stdio.h>
#include <math.h>
#include <windows.h>
#include <objbase.h>
#include <gdiplus.h>
#include "..\gpinit.inc"

#define or )
#define moo (
#define a
#define o 1
#define oo moo o + o or
#define m oo*
#define MOO m m moo m m m m oo - moo m oo + oo + o ))
#define M m MOO ,
#define O o*MOO ,
#define GotMilk *O M MOO
#define The Graphics
#define with a GetDC
#define goes a
#define to ;
#define fun to float
#define holy fun *
#define fly goes MOO or
#define the GraphicsPath goes
#define JumpOver AddLines
#define and or to
#define Follow(moo) Draw##moo
#define Say Follow(Ellipse)
#define mooo Pen
        
void __cdecl main() 
{
    using namespace Gdiplus;
    
    The cow goes moo with a moo o-o or and mooo mooo moo Color 
    moo M(m o-o or, oo*m moo oo -o-o), m MOO or , m m m m o+oo and cow.
    Say moo &mooo, moo m o+o or 
    * O m O O m MOO and cow. 
    Say moo & mooo, (m o+oo+o or GotMilk?
    MOO: !moo a moo oo) 
    or + MOO - O m MOO or fun 
    ooo[(m o+o or*moo
    o+m o or+o] holy Cow = ooo;* moo Cow++) = moo MOO and*moo Cow 
    ++or = m M*moo Cow++ or = moo MOO and*moo Cow ++or = M*moo Cow++ 
    or = MOO + moo m m o+o or*moo m m 
    m o+oo and *(Cow++ or = MOO + MOO + M * moo Cow++)= 
    MOO + O * (Cow++ or = moo MOO + MOO); *
    moo Cow++ or = M*moo Cow++ or = m moo MOO+
    fly to the moon; moon.JumpOver 
    (moo PointF*or ooo, m o+o+oo and cow. 
    Follow(Path) moo &mooo, &moon );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\pathtest\pathtest.cpp ===
#include <crtdbg.h>

#include <stdio.h>
#include <objbase.h>
#include <windows.h>
#include <winspool.h>
#include <commdlg.h>
#include <gdiplus.h>
using namespace Gdiplus;

#include "wndstuff.h"

GraphicsPath gppath;
GraphicsPath widepath;
GraphicsPath clippath;
TextureBrush *texturebrush = NULL;
PointF lastpoint(-1,-1);
Bitmap *offscreenbitmap = NULL;
int subpathlength = 0;
int ScaleColorMode = 0;
WCHAR savedFilename[255];

void
RemakePath(GraphicsPath *linepath, GraphicsPath *bezpath, BOOL bezmode)
{
    GraphicsPath *temppath = linepath->Clone();
    temppath->CloseFigure();
    bezpath->Reset();
    PointF *points = new PointF[temppath->GetPointCount()];
    BYTE *types = new BYTE[temppath->GetPointCount()];
    temppath->GetPathPoints(points, temppath->GetPointCount());
    temppath->GetPathTypes(types, temppath->GetPointCount());
    int last = 0;
    for (int i=0; i<temppath->GetPointCount(); i++)
    {
        if (types[i] & PathPointTypeCloseSubpath)
        {
            if (i-last+1 > 2)
            {
                if (!bezmode)
                {
                    bezpath->AddPolygon(points+last, i-last+1);
                }
                else
                {
                    bezpath->AddClosedCurve(points+last, i-last+1);
                }
                last = i+1;
            }
        }
    }
    delete points;
    delete types;
    delete temppath;
}

void
SplitPath(BOOL bezmode, BOOL before, BOOL after, float flatness)
{
    if (gppath.GetPointCount() < 3)
        return;
        
    RemakePath(&gppath, &widepath, bezmode);
    
    if (widepath.GetPointCount() > 2)
    {
        Pen pen(Color(0xff000000), 20);
        pen.SetLineJoin(LineJoinMiter);
        pen.SetMiterLimit(5);
        Matrix matrix;
        if (before)
            widepath.Outline(NULL, flatness);
        widepath.Widen(&pen, NULL, flatness);
        if (after)
            widepath.Outline(NULL, flatness);
    }
}

void
ClosePath()
{
    if (gppath.GetPointCount() < 1)
        return;
    gppath.CloseFigure();
    lastpoint = PointF(-1,-1);
}

void
ClearPath()
{
    lastpoint = PointF(-1,-1);
    gppath.Reset();
    widepath.Reset();
}

void
ClipPath(BOOL bezmode)
{
    clippath.Reset();
    GraphicsPath remadepath;
    RemakePath(&gppath, &remadepath, bezmode);
    clippath.AddPath(&remadepath, FALSE);
    ClearPath();
}

void
ClearClipPath()
{
    clippath.Reset();
}

void
AddPoint(INT x, INT y)
{
    if (!(lastpoint.X == -1 && lastpoint.Y == -1))
    {
        gppath.AddLine(lastpoint, PointF((float)x, (float)y));
    }
    lastpoint = PointF((float)x, (float)y);
}

void
OpenPath(char *filename)
{
    FILE *f = fopen(filename, "rt");
    INT count;

    fscanf(f, "%i", &count);
    for (INT i=0; i<count; i++)
    {
        INT type;
        REAL x, y;
        fscanf(f, "%i %f %f\n", &type, &x, &y);

        if (((type & 7) == 0) && i == 0)
        {
            gppath.Reset();
            PointF lastpoint; lastpoint.X = -1; lastpoint.Y = -1;
        }

        if ((type & 7) == 0)
        {
            lastpoint = PointF((float)x, (float)y);
        }
        else if ((type & 7) == 1)
        {
            gppath.AddLine(lastpoint, PointF((float)x, (float)y));
            lastpoint = PointF((float)x, (float)y);
        }
        
        if (type & 128)
        {
            //gppath.AddLine(firstpoint, lastpoint);
            ClosePath();
        }
    }

    fclose(f);
}

void
SavePath(char *filename)
{
    FILE *f = fopen(filename, "wt");

    int count = gppath.GetPointCount();

    Point *pathpoints = new Point[count];
    BYTE *pathtypes = new BYTE[count];
    gppath.GetPathPoints(pathpoints, count);
    gppath.GetPathTypes(pathtypes, count);

    fprintf(f, "%d\n", count);
    for (int i=0; i<count; i++)
    {
        fprintf(f, "%i %d %d\n", pathtypes[i], pathpoints[i].X, pathpoints[i].Y);
    }

    fclose(f);
    
    delete pathpoints;
    delete pathtypes;
}

void
SetColorMode(INT colorMode)
{
    ScaleColorMode = colorMode;
    ChangeTexture(savedFilename);
}

Color
ScaleColor(Color color, INT x, INT width)
{
    REAL alphaScale = 1, redScale = 1, greenScale = 1, blueScale = 1;
    switch (ScaleColorMode)
    {
    case 1:
        alphaScale = 0.5;
        break;
    case 2:
        alphaScale = (REAL)x / width;
        break;
    }
    
    REAL alpha = ((REAL)color.GetAlpha())*alphaScale;
    REAL red = ((REAL)color.GetRed())*redScale;
    REAL green = ((REAL)color.GetGreen())*greenScale;
    REAL blue = ((REAL)color.GetBlue())*blueScale;
    return Color((BYTE)alpha, (BYTE)red, (BYTE)green, (BYTE)blue);
}

void
ScaleColors(Bitmap* destBitmap, Bitmap *bitmap)
{
    BitmapData bmpData;
    Rect rect = Rect(0, 0, bitmap->GetWidth(), bitmap->GetHeight());
    if (bitmap->LockBits(&rect, ImageLockModeRead, PixelFormat32bppARGB, &bmpData) == Ok)
    {
        ARGB *data;
        for (UINT y=0; y<bitmap->GetHeight(); y++)
        {
            data = (ARGB*)((BYTE*)bmpData.Scan0+(y*bmpData.Stride));
            for (UINT x=0; x<bitmap->GetWidth(); x++)
            {
                *data = ScaleColor(Color(*data), x, bitmap->GetWidth()).GetValue();
                data++;
            }
        }
        BitmapData bmpDataDest;
        if (destBitmap->LockBits(&rect, ImageLockModeWrite, PixelFormat32bppARGB, &bmpDataDest) == Ok)
        {
            memcpy(bmpDataDest.Scan0, bmpData.Scan0, bitmap->GetWidth() * bitmap->GetHeight() * sizeof(ARGB));
            destBitmap->UnlockBits(&bmpDataDest);
        }
        bitmap->UnlockBits(&bmpData);
    }
}

void
ChangeTexture(const WCHAR *filename)
{
    wcsncpy(savedFilename, filename, 255);
    delete texturebrush;
    Bitmap image(filename);
    Bitmap image2(image.GetWidth(), image.GetHeight(), PixelFormat32bppARGB);
    ScaleColors(&image2, &image);
    texturebrush = new TextureBrush(&image2);
}

void
Resize(INT x, INT y)
{
    delete offscreenbitmap;
    offscreenbitmap = new Bitmap(x, y, PixelFormat32bppPARGB);
}

void
CleanUp()
{
    delete offscreenbitmap;
    delete texturebrush;
}

VOID
Print(HWND hwnd, float flatness, PtFlag flags)
{
    PRINTDLG printdlg;
    memset(&printdlg, 0, sizeof(PRINTDLG));
    printdlg.lStructSize = sizeof(PRINTDLG);
    printdlg.hwndOwner = hwnd;
    printdlg.hDevMode = NULL;
    printdlg.hDevNames = NULL;
    printdlg.hDC = NULL;
    printdlg.Flags = PD_RETURNDC;
    if (PrintDlg(&printdlg))
    {        
        DOCINFO di;
        memset(&di, 0, sizeof(DOCINFO));
        di.cbSize = sizeof(DOCINFO);
        di.lpszDocName = "Path Printing Test";
        di.lpszOutput = (LPTSTR)NULL;
        di.lpszDatatype = (LPTSTR)NULL;
        di.fwType = 0;
        DEVMODE *devmode = (DEVMODE*)GlobalLock(printdlg.hDevMode);
        if (devmode == NULL)
            return;
        HANDLE hprinter;
        OpenPrinter((LPSTR)devmode->dmDeviceName, &hprinter, NULL);
        GlobalUnlock(printdlg.hDevMode);

        StartDoc(printdlg.hDC, &di);
        StartPage(printdlg.hDC);

        DrawPath(hwnd, &printdlg.hDC, &hprinter, flatness, flags);
        
        EndPage(printdlg.hDC);
        EndDoc(printdlg.hDC);
    }
    else
    {
        DWORD error = CommDlgExtendedError();
        if (error)
        {
            char errormessage[100];
            sprintf(errormessage, "PrintDlg error: %d", error);
            MessageBox(hwnd, errormessage, "PrintDlg error", MB_OK);
        }
    }
}

void
DrawPath(HWND hwnd, HDC *phdc, HANDLE *hprinter, float flatness, PtFlag flags)
{
    if (!offscreenbitmap)
        return;

    Graphics *renderinggraphics;
    if (phdc)
    {
        renderinggraphics = new Graphics(*phdc, *hprinter);
    }
    else
    {
        renderinggraphics = new Graphics(offscreenbitmap);
    }

    RECT rect;
    GetClientRect(hwnd, &rect);

    Brush *background;
    if (flags & PTBackgroundGradFillFlag)
    {
        background = new LinearGradientBrush(Point(0, 0), Point((rect.right-rect.left)/4, 0), Color(0xffffffff), Color(0xff0000ff));
        ((LinearGradientBrush*)background)->SetWrapMode(WrapModeTileFlipX);
    }
    else
    {
        background = new SolidBrush(Color(0xffffffff));
    }
    renderinggraphics->FillRectangle(background, Rect(rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top));
    delete background;

    renderinggraphics->SetSmoothingMode(SmoothingModeAntiAlias);

    if (gppath.GetPointCount() > 0)
    {
        SplitPath(flags & PtBezierFlag, flags & PtOutlineBeforeFlag, flags & PtOutlineAfterFlag, flatness);
        if (clippath.GetPointCount() > 2)
        {
            renderinggraphics->SetClip(&clippath);
        }
        
        if (flags & PtTextureFillFlag)
        {
            if (!texturebrush)
                ChangeTexture(L"mycomputer.jpg");

            GraphicsPath bezpath;
            RemakePath(&gppath, &bezpath, flags & PtBezierFlag);
            if (flags & PtOutlineBeforeFlag)
                bezpath.Outline();
            bezpath.SetFillMode(FillModeWinding);
            renderinggraphics->FillPath(texturebrush, &bezpath);
        }

        if (flags & PtTransSolidFillFlag)
        {
            SolidBrush transsolidbrush(Color(0x80ffff00));
            GraphicsPath bezpath;
            RemakePath(&gppath, &bezpath, flags & PtBezierFlag);
            if (flags & PtOutlineBeforeFlag)
                bezpath.Outline();
            bezpath.SetFillMode(FillModeAlternate);
            renderinggraphics->FillPath(&transsolidbrush, &bezpath);
        }

        if (flags & PtTransGradFillFlag)
        {
            GraphicsPath bezpath;
            RemakePath(&gppath, &bezpath, flags & PtBezierFlag);
            Matrix m;
            bezpath.Flatten(&m, flatness);
            INT count = bezpath.GetPointCount();
            if (flags & PtOutlineBeforeFlag)
                bezpath.Outline();
            bezpath.SetFillMode(FillModeAlternate);
            PathGradientBrush pathgradientbrush(&bezpath);
            Color *colors = new Color[count];
            for (int i=0; i<count; i++)
                colors[i] = (i/2 == (float)i/2) ? 0xffff0000 : 0x80000000;
            pathgradientbrush.SetCenterColor(0x00000000);
            pathgradientbrush.SetSurroundColors(colors, &count);
            renderinggraphics->FillPath(&pathgradientbrush, &bezpath);
            delete colors;
        }

        if (!(flags & PtHatchBrushFlag))
        {
            SolidBrush pathbrush(Color(0xffc0c0ff));
            renderinggraphics->FillPath(&pathbrush, &widepath);
        }
        else
        {
            HatchBrush pathbrush(HatchStyleDiagonalBrick, Color(0xff000000), Color(0xffc0c0ff));
            renderinggraphics->FillPath(&pathbrush, &widepath);
        }

        Pen blackpen(Color(0xff000000), 2);
        blackpen.SetLineJoin(LineJoinMiter);
        renderinggraphics->DrawPath(&blackpen, &widepath);

        renderinggraphics->ResetClip();

        SolidBrush solidbrush(0xff0000ff);
        Pen pathpen(&solidbrush);
        pathpen.SetLineJoin(LineJoinRound);
        if (!(flags & PtDashPatternFlag))
        {
            pathpen.SetWidth(6);
        }
        else
        {
            pathpen.SetWidth(8);
            pathpen.SetDashStyle(DashStyleDot);
            pathpen.SetDashCap(DashCapRound);
            REAL distances[6] = {1.0f, 1.0f, 3.0f, 3.5f, 7.0f, 9.0f};
            pathpen.SetDashPattern(distances,6);
        }
        renderinggraphics->DrawPath(&pathpen, &gppath);

        PointF *points = new PointF[gppath.GetPointCount()];
        gppath.GetPathPoints(points, gppath.GetPointCount());
        for (INT i=0; i<gppath.GetPointCount(); i++)
        {
            SolidBrush bluebrush(Color(0xff0000ff));
            RectF rect((float)points[i].X-4, (float)points[i].Y-4, 8, 8);
            renderinggraphics->FillEllipse(&bluebrush, rect);
        }
        delete points;
    }

    if (clippath.GetPointCount() > 2)
    {
        Pen clippen(Color(0xffff0000), 4);
        clippen.SetDashStyle(DashStyleDot);
        clippen.SetLineJoin(LineJoinRound);
        renderinggraphics->DrawPath(&clippen, &clippath);
    }

    SolidBrush darkbluebrush(Color(0xff0000c0));
    if (lastpoint.X != -1 && lastpoint.Y != -1)
    {
        RectF rect(lastpoint.X-6, lastpoint.Y-6, 12, 12);
        renderinggraphics->FillEllipse(&darkbluebrush, rect);
    }

    delete renderinggraphics;

    if (phdc == NULL)
    {
        HDC hdc = GetDC(hwnd);
        Graphics *g = new Graphics(hdc);
        PAINTSTRUCT paintstruct;
        BeginPaint(hwnd, &paintstruct);
        g->DrawImage(offscreenbitmap, 0, 0);
        EndPaint(hwnd, &paintstruct);
        ReleaseDC(hwnd, hdc);
        delete g;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\pathtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wndstuff.rc
//
#define IDR_ACCELERATOR1                101
#define MM_CLEARPATH                    40001
#define MM_OBEFOREMODE                  40002
#define MM_OAFTERMODE                   40003
#define MM_FLATNESS_1                   40004
#define MM_FLATNESS_2                   40005
#define MM_FLATNESS_3                   40006
#define MM_FLATNESS_4                   40007
#define MM_PRINT                        40008
#define MM_SAVESCRIPT                   40009
#define MM_SHOWHATCHBRUSHSTROKE         40010
#define MM_SHOWDASHSTROKE               40011
#define MM_USEASCLIPPATH                40012
#define MM_CLEARCLIPPATH                40013
#define MM_CHANGETEXTUREFILL            40014
#define MM_OPENFILE                     40015
#define MM_SAVEFILE                     40016
#define MM_SHOWTRANSSOLIDFILL           40017
#define MM_SHOWTEXTUREFILL              40018
#define MM_SHOWTRANSGRADFILL            40019
#define MM_LINEMODE                     40020
#define MM_BEZIERMODE                   40021
#define MM_CLOSEPATH                    40022
#define MM_COLORMODE_NOCHANGE           40023
#define MM_COLORMODE_TRANS50            40024
#define MM_COLORMODE_GRADTRANS          40025
#define MM_SHOWBGGRADFILL               40026

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40027
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\libtest\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

// for Win95 compile
#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <tchar.h>

//
// Where is IStream included from?
//

#define IStream int

#include <gdiplus.h>
using namespace Gdiplus;

#include "wndstuff.h"

HINSTANCE ghInstance;
HWND ghwndMain;
HWND ghwndDebug;
HWND ghwndList;
HBRUSH ghbrWhite;

VOID WINAPI
AltDebugEvent(
    DebugEventLevel level, 
    CHAR *message)
{
    OutputDebugStringA("AltDebugEvent: ");
    OutputDebugStringA(message);
    if (level == DebugEventLevelFatal)
    {
        DebugBreak();
    }
}

GdiplusStartupOutput gGpSto;

// Because we have global initializers which call GDI+, GDI+ needs to be
// initialized before, and destroyed after, those constructors and destructors.
// Here goes:

#pragma warning( push )
#pragma warning( disable : 4073 )

#pragma code_seg( "MySeg" )
#pragma init_seg( lib )

class GdiplusInitHelper
{
public:
    GdiplusInitHelper() : gpToken(0), Valid(FALSE)
    {
        // Use the non-defaults, to test the alternative code-path.

        GdiplusStartupInput sti(AltDebugEvent, TRUE, TRUE);
    
        if (GdiplusStartup(&gpToken, &sti, &gGpSto) == Ok)
        {
            Valid = TRUE;
        }
        else
        {
            MessageBox(0, _T("Engine didn't initialize"), _T("Uh oh"), MB_OK);
        }        
    }
    ~GdiplusInitHelper()
    {
        if (Valid)
        {
            GdiplusShutdown(gpToken);
        }
    }
    BOOL IsValid() { return Valid; }
    
private:    
    ULONG_PTR gpToken;
    BOOL Valid;
};

GdiplusInitHelper gGdiplusInitHelper;

#pragma code_seg()
#pragma warning( pop )

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case MM_TEST:
            Test(hwnd);
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/******************************Public*Routine******************************\
* DebugWndProc
*
* List box is maintained here.
*
\**************************************************************************/

LONG_PTR FAR PASCAL DebugWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT    rcl;
    HDC     hdc;
    LONG_PTR    lRet = 0;

// Process window message.

    switch (message)
    {
    case WM_SIZE:
        lRet = DefWindowProc(ghwndList, message, wParam, lParam);
        GetClientRect(ghwndMain, &rcl);
        MoveWindow(
            ghwndList,
            rcl.left, rcl.top,
            (rcl.right - rcl.left), (rcl.bottom - rcl.top),
            TRUE
            );
        UpdateWindow(ghwndList);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        lRet = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    }

    return lRet;
}

/******************************Public*Routine******************************\
* LBprintf
*
* ListBox printf implementation.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBprintf(PCH msg, ...)
{
    if (ghwndList)
    {
        va_list ap;
        char buffer[256];

        va_start(ap, msg);

        vsprintf(buffer, msg, ap);

        SendMessage(ghwndList, LB_ADDSTRING, (WPARAM) 0, (LPARAM) buffer);
        SendMessage(ghwndList, WM_SETREDRAW, (WPARAM) TRUE, (LPARAM) 0);
        InvalidateRect(ghwndList, NULL, TRUE);
        UpdateWindow(ghwndList);

        va_end(ap);
    }
}

/******************************Public*Routine******************************\
* LBreset
*
* Reset ListBox state (clear).
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBreset()
{
    if (ghwndList)
        SendMessage(ghwndList, LB_RESETCONTENT, (WPARAM) FALSE, (LPARAM) 0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(BOOL debug)
{
    WNDCLASS wc;

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_VISIBLE      |  
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL);

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }

    if (debug)
    {
        RECT rcl;

        memset(&wc, 0, sizeof(wc));
        wc.style = 0;
        wc.lpfnWndProc = DebugWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = ghInstance;
        wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = ghbrWhite;
        wc.lpszClassName = "DebugWClass";
        RegisterClass(&wc);

        ghwndDebug = CreateWindow(
            "DebugWClass",
            "Debug output",
            WS_OVERLAPPEDWINDOW|WS_MAXIMIZE,
            600,
            70,
            300,
            500,
            NULL,
            NULL,
            ghInstance,
            NULL
            );

        if (ghwndDebug)
        {
            ShowWindow(ghwndDebug, SW_NORMAL);
            UpdateWindow(ghwndDebug);

        // Create the list box to fill the main window.

            GetClientRect(ghwndDebug, &rcl);

            ghwndList = CreateWindow(
                "LISTBOX",
                "Debug output",
                WS_CHILD | WS_VISIBLE | WS_VSCROLL
                | WS_HSCROLL | LBS_NOINTEGRALHEIGHT,
                rcl.left, rcl.top,
                (rcl.right - rcl.left), (rcl.bottom - rcl.top),
                ghwndDebug,
                NULL,
                ghInstance,
                NULL
                );

            if (ghwndList)
            {
                SendMessage(
                    ghwndList,
                    WM_SETFONT,
                    (WPARAM) GetStockObject(ANSI_FIXED_FONT),
                    (LPARAM) FALSE
                    );

                LBreset();

                ShowWindow(ghwndList, SW_NORMAL);
                UpdateWindow(ghwndList);
            }
        }

    }

    SetFocus(ghwndMain);

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    BOOL wantDebugWindow = FALSE;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }

    CoInitialize(NULL);

    // Parse arguments

    for (argc--, argv++ ; argc && '-' == **argv ; argc--, argv++ )
    {
        switch ( *(++(*argv)) )
        {
        case 'd':
        case 'D':
            wantDebugWindow = TRUE;
            break;
        }
    }

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp(wantDebugWindow))
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(1));
    
    ULONG_PTR notifyToken;
    
    gGpSto.NotificationHook(&notifyToken);
    
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    gGpSto.NotificationUnhook(notifyToken);

    CoUninitialize();

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\pathtest\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#include "resource.h"

enum PtFlag {
    PtNoFlag = 0,
    PtBezierFlag = 1,
    PtOutlineBeforeFlag = 2,
    PtOutlineAfterFlag = 4,
    PtDashPatternFlag = 8,
    PtHatchBrushFlag = 16,
    PtTextureFillFlag = 32,
    PtTransSolidFillFlag = 64,
    PtTransGradFillFlag = 128,
    PTBackgroundGradFillFlag = 256,
};


void DrawPath(HWND hwnd, HDC *phdc, HANDLE *hprinter, float flatness, PtFlag flags);
void AddPoint(INT x, INT y);
void OpenPath(char *filename);
void SavePath(char *filename);
void ChangeTexture(const WCHAR *filename);
void SetColorMode(INT colorMode);
void ClosePath();
void ClearPath();
void ClipPath(BOOL bezmode);
void ClearClipPath();
void Resize(INT x, INT y);
void CleanUp();
void Print(HWND hwnd, float flatness, PtFlag flags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\pathtest\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

// for Win95 compile
#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <commdlg.h>
#include "wndstuff.h"

#include "../gpinit.inc"

HINSTANCE ghInstance;
HWND ghwndMain;
HWND ghwndDebug;
HWND ghwndList;
HBRUSH ghbrWhite;
bool buttondown = false;
float flatness = 0.25f;


PtFlag ifs(INT f, PtFlag v)
{
    return f ? v : PtNoFlag;
}

PtFlag CalcFlags(HWND hwnd)
{
    return (PtFlag)(
        ifs(GetMenuState(GetMenu(hwnd), MM_BEZIERMODE, MF_BYCOMMAND) & MF_CHECKED, PtBezierFlag) | 
        ifs(GetMenuState(GetMenu(hwnd), MM_OBEFOREMODE, MF_BYCOMMAND) & MF_CHECKED, PtOutlineBeforeFlag) | 
        ifs(GetMenuState(GetMenu(hwnd), MM_OAFTERMODE, MF_BYCOMMAND) & MF_CHECKED, PtOutlineAfterFlag) | 
        ifs(GetMenuState(GetMenu(hwnd), MM_SHOWDASHSTROKE, MF_BYCOMMAND) & MF_CHECKED, PtDashPatternFlag) | 
        ifs(GetMenuState(GetMenu(hwnd), MM_SHOWHATCHBRUSHSTROKE, MF_BYCOMMAND) & MF_CHECKED, PtHatchBrushFlag) | 
        ifs(GetMenuState(GetMenu(hwnd), MM_SHOWTEXTUREFILL, MF_BYCOMMAND) & MF_CHECKED, PtTextureFillFlag) | 
        ifs(GetMenuState(GetMenu(hwnd), MM_SHOWTRANSSOLIDFILL, MF_BYCOMMAND) & MF_CHECKED, PtTransSolidFillFlag) | 
        ifs(GetMenuState(GetMenu(hwnd), MM_SHOWTRANSGRADFILL, MF_BYCOMMAND) & MF_CHECKED, PtTransGradFillFlag) |
        ifs(GetMenuState(GetMenu(hwnd), MM_SHOWBGGRADFILL, MF_BYCOMMAND) & MF_CHECKED, PTBackgroundGradFillFlag));}

void HandleCheckUncheck(INT flag, HWND hwnd)
{
    if (GetMenuState(GetMenu(hwnd), flag, MF_BYCOMMAND) & MF_CHECKED)
        CheckMenuItem(GetMenu(hwnd), flag, MF_UNCHECKED);
    else
        CheckMenuItem(GetMenu(hwnd), flag, MF_CHECKED);
    InvalidateRect(hwnd, NULL, false);
}


/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LRESULT CALLBACK
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    INT xpos, ypos;

    switch (message)
    {
    case WM_CREATE:
        return true;

    case WM_SIZE:
        xpos = LOWORD(lParam);
        ypos = HIWORD(lParam);
        Resize(xpos, ypos);
        InvalidateRect(hwnd, NULL, false);
        return true;

    case WM_LBUTTONDOWN:
        buttondown = true;
        return true;

    case WM_LBUTTONUP:
        if (!buttondown)
            break;
        buttondown = false;
        xpos = LOWORD(lParam);
        ypos = HIWORD(lParam);
        RECT rect;
        GetClientRect(hwnd, &rect);
        AddPoint(xpos, ypos);
        InvalidateRect(hwnd, NULL, false);
        return true;

    case WM_COMMAND: {
        INT flag = LOWORD(wParam);
        switch(flag)
        {
        case MM_SHOWDASHSTROKE:
            HandleCheckUncheck(flag, hwnd);
            return true;
        
        case MM_SHOWHATCHBRUSHSTROKE:
            HandleCheckUncheck(flag, hwnd);
            return true;
            
        case MM_SHOWTEXTUREFILL:
            HandleCheckUncheck(flag, hwnd);
            return true;

        case MM_SHOWTRANSSOLIDFILL:
            HandleCheckUncheck(flag, hwnd);
            return true;
        
        case MM_SHOWTRANSGRADFILL:
            HandleCheckUncheck(flag, hwnd);
            return true;

        case MM_SHOWBGGRADFILL:
            HandleCheckUncheck(flag, hwnd);
            return true;

        case MM_CHANGETEXTUREFILL: {
            OPENFILENAME ofn;       // common dialog box structure
            char szFile[260];       // buffer for file name
            szFile[0] = 0;

            ZeroMemory(&ofn, sizeof(OPENFILENAME));
            ofn.lStructSize = sizeof(OPENFILENAME);
            ofn.hwndOwner = hwnd;
            ofn.lpstrFile = szFile;
            ofn.nMaxFile = sizeof(szFile);
            ofn.lpstrFilter = "Images\0*.*\0";
            ofn.nFilterIndex = 0;
            ofn.lpstrFileTitle = NULL;
            ofn.nMaxFileTitle = 0;
            ofn.lpstrInitialDir = NULL;
            ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
            char curdir[260];
            GetCurrentDirectory(sizeof(curdir), curdir);
            if (GetOpenFileName(&ofn)==TRUE)
            {
                WCHAR wchar[256];
                MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, ofn.lpstrFile, -1, wchar, 256);
                ChangeTexture(wchar);
                SetCurrentDirectory(curdir);
                InvalidateRect(hwnd, NULL, false);
            }
            else
            {
                printf("%d", CommDlgExtendedError());
            }
            return true;}
        
        case MM_OPENFILE: {
            OPENFILENAME ofn;       // common dialog box structure
            char szFile[260];       // buffer for file name
            szFile[0] = 0;

            ZeroMemory(&ofn, sizeof(OPENFILENAME));
            ofn.lStructSize = sizeof(OPENFILENAME);
            ofn.hwndOwner = hwnd;
            ofn.lpstrFile = szFile;
            ofn.nMaxFile = sizeof(szFile);
            ofn.lpstrFilter = "All\0*.*\0Text\0*.TXT\0";
            ofn.nFilterIndex = 1;
            ofn.lpstrFileTitle = NULL;
            ofn.nMaxFileTitle = 0;
            ofn.lpstrInitialDir = NULL;
            ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
            char curdir[260];
            GetCurrentDirectory(sizeof(curdir), curdir);
            if (GetOpenFileName(&ofn)==TRUE)
            {
                OpenPath(ofn.lpstrFile);
                SetCurrentDirectory(curdir);
                InvalidateRect(hwnd, NULL, false);
            }
            else
            {
                printf("%d", CommDlgExtendedError());
            }
            return true;}
            
        case MM_SAVEFILE: {
            OPENFILENAME ofn;       // common dialog box structure
            char szFile[260];       // buffer for file name
            szFile[0] = 0;

            ZeroMemory(&ofn, sizeof(OPENFILENAME));
            ofn.lStructSize = sizeof(OPENFILENAME);
            ofn.hwndOwner = hwnd;
            ofn.lpstrFile = szFile;
            ofn.nMaxFile = sizeof(szFile);
            ofn.lpstrFilter = "All\0*.*\0Text\0*.TXT\0";
            ofn.nFilterIndex = 1;
            ofn.lpstrFileTitle = NULL;
            ofn.nMaxFileTitle = 0;
            ofn.lpstrInitialDir = NULL;
            ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
            char curdir[260];
            GetCurrentDirectory(sizeof(curdir), curdir);
            if (GetOpenFileName(&ofn)==TRUE)
            {
                SavePath(ofn.lpstrFile);
                SetCurrentDirectory(curdir);
                InvalidateRect(hwnd, NULL, false);
            }
            else
            {
                printf("%d", CommDlgExtendedError());
            }
            return true;}
            
        case MM_PRINT:
            Print(hwnd, flatness, CalcFlags(hwnd));
            return true;

        case MM_CLOSEPATH:
            ClosePath();
            InvalidateRect(hwnd, NULL, false);
            return true;

        case MM_CLEARPATH:
            ClearPath();
            InvalidateRect(hwnd, NULL, false);
            return true;

        case MM_USEASCLIPPATH: {
            ClipPath(CalcFlags(hwnd) & PtBezierFlag);
            InvalidateRect(hwnd, NULL, false);
            return true;}

        case MM_CLEARCLIPPATH:
            ClearClipPath();
            InvalidateRect(hwnd, NULL, false);
            return true;

        case MM_LINEMODE:
            CheckMenuItem(GetMenu(hwnd), MM_LINEMODE, MF_CHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_BEZIERMODE, MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, false);
            return true;

        case MM_BEZIERMODE:
            CheckMenuItem(GetMenu(hwnd), MM_LINEMODE, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_BEZIERMODE, MF_CHECKED);
            InvalidateRect(hwnd, NULL, false);
            return true;

        case MM_OBEFOREMODE:
            if (GetMenuState(GetMenu(hwnd), MM_OBEFOREMODE, MF_BYCOMMAND) & MF_CHECKED)
                CheckMenuItem(GetMenu(hwnd), MM_OBEFOREMODE, MF_UNCHECKED);
            else
                CheckMenuItem(GetMenu(hwnd), MM_OBEFOREMODE, MF_CHECKED);
            InvalidateRect(hwnd, NULL, false);
            return true;

        case MM_OAFTERMODE:
            if (GetMenuState(GetMenu(hwnd), MM_OAFTERMODE, MF_BYCOMMAND) & MF_CHECKED)
                CheckMenuItem(GetMenu(hwnd), MM_OAFTERMODE, MF_UNCHECKED);
            else
                CheckMenuItem(GetMenu(hwnd), MM_OAFTERMODE, MF_CHECKED);
            InvalidateRect(hwnd, NULL, false);
            return true;

        case MM_FLATNESS_1:
        case MM_FLATNESS_2:
        case MM_FLATNESS_3:
        case MM_FLATNESS_4: {
            CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_1, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_2, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_3, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_4, MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, false);
            switch (LOWORD(wParam))
            {
            case MM_FLATNESS_1:
                flatness = 10.0f;
                CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_1, MF_CHECKED);
                return true;
            case MM_FLATNESS_2:
                flatness = 1.0f;
                CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_2, MF_CHECKED);
                return true;
            case MM_FLATNESS_3:
                flatness = 0.25f;
                CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_3, MF_CHECKED);
                return true;
            case MM_FLATNESS_4:
                flatness = 0.1f;
                CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_4, MF_CHECKED);
                return true;
            }
        }

        case MM_COLORMODE_NOCHANGE:
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_NOCHANGE, MF_CHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_TRANS50, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_GRADTRANS, MF_UNCHECKED);
            SetColorMode(0);
            InvalidateRect(hwnd, NULL, false);
            return true;
        case MM_COLORMODE_TRANS50:
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_NOCHANGE, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_TRANS50, MF_CHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_GRADTRANS, MF_UNCHECKED);
            SetColorMode(1);
            InvalidateRect(hwnd, NULL, false);
            return true;
        case MM_COLORMODE_GRADTRANS:
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_NOCHANGE, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_TRANS50, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_GRADTRANS, MF_CHECKED);
            SetColorMode(2);
            InvalidateRect(hwnd, NULL, false);
            return true;

        default:
            break;
        }
        break;}
        
    case WM_KEYUP:
        if(!( ((CHAR)wParam=='q') || 
              ((CHAR)wParam=='Q') ) )
        {
            break;
        }

    case WM_DESTROY:
        CleanUp();
        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    case WM_PAINT:
        DrawPath(hwnd, NULL, NULL, flatness, CalcFlags(hwnd));
        return true;

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(BOOL debug)
{
    debug = FALSE;
    WNDCLASS wc;

    //ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    //wc.hbrBackground    = ghbrWhite;
    wc.hbrBackground    = NULL;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |
        WS_CAPTION      |
        WS_THICKFRAME   |
        WS_MAXIMIZEBOX  |
        WS_BORDER       |
        WS_MINIMIZEBOX  |
        WS_CLIPCHILDREN |
        WS_VISIBLE      |
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL);

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }

    SetFocus(ghwndMain);

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
    
    BOOL wantDebugWindow = FALSE;

    CoInitialize(NULL);

    // Parse arguments

    for (argc--, argv++ ; argc && '-' == **argv ; argc--, argv++ )
    {
        switch ( *(++(*argv)) )
        {
        case 'd':
        case 'D':
            wantDebugWindow = TRUE;
            break;
        }
    }

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp(wantDebugWindow))
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(101));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    CoUninitialize();
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\perftest\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\perftest\debug.h ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   debug.h
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

#if DBG

#define ASSERT(cond) { if (!(cond)) DebugBreak(); }

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define ASSERT(cond)

#endif // !DBG

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\perftest\perfdraw.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   perfdraw.cpp
*
* Abstract:
*
*   Contains all the tests for any routines that 'Draw'.
*
\**************************************************************************/

#include "perftest.h"

// Global array for holding line vertices:

Point SweepLines[2000];

int Initialize_256_Pixel_Sweep_Lines()
{
    int c = 0;
    int i;

    for (i = 0; i < 510; i += 4)
    {
        SweepLines[c].X = 255;
        SweepLines[c].Y = 255;
        c++;
        SweepLines[c].X = i;
        SweepLines[c].Y = 0;
        c++;
    }
    for (i = 0; i < 510; i += 4)
    {
        SweepLines[c].X = 255;
        SweepLines[c].Y = 255;
        c++;
        SweepLines[c].X = 510;
        SweepLines[c].Y = i;
        c++;
    }
    for (i = 0; i < 510; i += 4)
    {
        SweepLines[c].X = 255;
        SweepLines[c].Y = 255;
        c++;
        SweepLines[c].X = 510 - i;
        SweepLines[c].Y = 510;
        c++;
    }
    for (i = 0; i < 510; i += 4)
    {
        SweepLines[c].X = 255;
        SweepLines[c].Y = 255;
        c++;
        SweepLines[c].X = 0;
        SweepLines[c].Y = 510 - i;
        c++;
    }

    return(c / 2);
}

float Draw_Lines_PerPixel_Nominal_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    int i;

    int lines = Initialize_256_Pixel_Sweep_Lines();

    if (g)
    {
        Pen pen(Color::Red, 1);
    
        StartTimer();
    
        do {
            for (i = 0; i < lines; i++)
            {
                g->DrawLine(&pen, SweepLines[i*2].X, SweepLines[i*2].Y, 
                                  SweepLines[i*2+1].X, SweepLines[i*2+1].Y);
            }
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        POINT points[2000];

        for (i = 0; i < lines * 2 + 1; i++)
        {
            points[i].x = SweepLines[i].X;
            points[i].y = SweepLines[i].Y;
        }

        HPEN hpen = CreatePen(PS_SOLID, 1, RGB(0xff, 0, 0));
        HGDIOBJ oldPen = SelectObject(hdc, hpen);

        StartTimer();

        do {
            for (i = 0; i < lines; i++)
            {
                Polyline(hdc, &points[i*2], 2);
            }

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldPen);
    }

    UINT pixels = 256 * lines * iterations;

    return(pixels / seconds / KILO);        // Kilo-pixels per second
}

float Draw_Lines_PerPixel_Nominal_Solid_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    int i;

    if (!g) return(0);          // There is no GDI equivalent

    int lines = Initialize_256_Pixel_Sweep_Lines();

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    Pen pen(Color::Red, 1);

    StartTimer();

    do {
        for (i = 0; i < lines; i++)
        {
            g->DrawLine(&pen, SweepLines[i*2].X, SweepLines[i*2].Y, 
                              SweepLines[i*2+1].X, SweepLines[i*2+1].Y);
        }

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 256 * lines * iterations;

    return(pixels / seconds / KILO);        // Kilo-pixels per second
}

float Draw_Lines_PerPixel_Nominal_Solid_Opaque_Antialiased_Quality(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    int i;

    if (!g) return(0);          // There is no GDI equivalent

    int lines = Initialize_256_Pixel_Sweep_Lines();

    g->SetSmoothingMode(SmoothingModeAntiAlias);
    g->SetCompositingQuality(CompositingQualityHighQuality);

    Pen pen(Color::Red, 1);

    StartTimer();

    do {
        for (i = 0; i < lines; i++)
        {
            g->DrawLine(&pen, SweepLines[i*2].X, SweepLines[i*2].Y, 
                              SweepLines[i*2+1].X, SweepLines[i*2+1].Y);
        }

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 256 * lines * iterations;

    return(pixels / seconds / KILO);        // Kilo-pixels per second
}

float Draw_Lines_PerPixel_Wide_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    int i;

    int lines = Initialize_256_Pixel_Sweep_Lines();

    if (g)
    {
        Pen pen(Color::Red, 2);
    
        StartTimer();
    
        do {
            for (i = 0; i < lines; i++)
            {
                g->DrawLine(&pen, SweepLines[i*2].X, SweepLines[i*2].Y, 
                                  SweepLines[i*2+1].X, SweepLines[i*2+1].Y);
            }
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        POINT points[2000];

        for (i = 0; i < lines * 2 + 1; i++)
        {
            points[i].x = SweepLines[i].X;
            points[i].y = SweepLines[i].Y;
        }

        HPEN hpen = CreatePen(PS_SOLID, 2, RGB(0xff, 0, 0));
        HGDIOBJ oldPen = SelectObject(hdc, hpen);

        StartTimer();

        do {
            for (i = 0; i < lines; i++)
            {
                Polyline(hdc, &points[i*2], 2);
            }

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldPen);
    }

    UINT pixels = 256 * lines * iterations;

    return(pixels / seconds / KILO);        // Kilo-pixels per second
}

float Draw_Lines_PerPixel_Wide_Solid_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    int i;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    int lines = Initialize_256_Pixel_Sweep_Lines();

    Pen pen(Color::Red, 2);

    StartTimer();

    do {
        for (i = 0; i < lines; i++)
        {
            g->DrawLine(&pen, SweepLines[i*2].X, SweepLines[i*2].Y, 
                              SweepLines[i*2+1].X, SweepLines[i*2+1].Y);
        }

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 256 * lines * iterations;

    return(pixels / seconds / KILO);        // Kilo-pixels per second
}

float Draw_Lines_PerPixel_Wide_Solid_Opaque_Antialiased_Quality(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    int i;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);
    g->SetCompositingQuality(CompositingQualityHighQuality);

    int lines = Initialize_256_Pixel_Sweep_Lines();

    Pen pen(Color::Red, 2);

    StartTimer();

    do {
        for (i = 0; i < lines; i++)
        {
            g->DrawLine(&pen, SweepLines[i*2].X, SweepLines[i*2].Y, 
                              SweepLines[i*2+1].X, SweepLines[i*2+1].Y);
        }

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 256 * lines * iterations;

    return(pixels / seconds / KILO);        // Kilo-pixels per second
}

float Draw_Lines_PerLine_Nominal_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        StartTimer();
    
        do {
            Pen pen(Color::Red, 1);
            g->DrawLine(&pen, 255, 255, 256, 256);  // 2 pixels long
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        StartTimer();

        do {
            POINT points[] = { 255, 255, 256, 256 };

            HPEN hpen = CreatePen(PS_SOLID, 1, RGB(255, 0, 0));
            HGDIOBJ oldPen = SelectObject(hdc, hpen);

            Polyline(hdc, points, 2);

            SelectObject(hdc, oldPen);
            DeleteObject(hpen);

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    return(iterations / seconds / KILO);    // Kilo-lines per second
}

float Draw_Lines_PerLine_Nominal_Solid_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    StartTimer();

    do {
        Pen pen(Color::Red, 1);
        g->DrawLine(&pen, 255, 255, 256, 256);  // 2 pixels long

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);    // Kilo-lines per second
}

float Draw_Lines_PerLine_Wide_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        StartTimer();
    
        do {
            Pen pen(Color::Red, 2);
            g->DrawLine(&pen, 255, 255, 256, 256);  // 2 pixels long
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        StartTimer();
    
        do {
            POINT points[] = { 255, 255, 256, 256 };

            HPEN hpen = CreatePen(PS_SOLID, 2, RGB(255, 0, 0));
            HGDIOBJ oldPen = SelectObject(hdc, hpen);

            Polyline(hdc, points, 2);

            SelectObject(hdc, oldPen);
            DeleteObject(hpen);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    return(iterations / seconds / KILO);    // Kilo-lines per second
}

float Draw_Lines_PerLine_Wide_Solid_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    StartTimer();

    do {
        Pen pen(Color::Red, 2);
        g->DrawLine(&pen, 255, 255, 256, 256);  // 2 pixels long

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);    // Kilo-lines per second
}

float Draw_Ellipse_PerCall_Big_Nominal_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        StartTimer();
    
        do {
            Pen pen(Color::Red, 0.1f);
            g->DrawEllipse(&pen, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HGDIOBJ hbrush = GetStockObject(NULL_BRUSH);
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

        StartTimer();

        do {
            HPEN hpen = CreatePen(PS_SOLID, 0, RGB(255, 0, 0));
            HGDIOBJ oldPen = SelectObject(hdc, hpen);

            Ellipse(hdc, 0, 0, 512, 512);

            SelectObject(hdc, oldPen);
            DeleteObject(hpen);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        DeleteObject(hbrush);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Draw_Ellipse_PerCall_Big_WideLine_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        StartTimer();
    
        do {
            Pen pen(Color::Red, 5);
            g->DrawEllipse(&pen, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HGDIOBJ hbrush = GetStockObject(NULL_BRUSH);
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

        StartTimer();
    
        do {
            HPEN hpen = CreatePen(PS_SOLID, 5, RGB(255, 0, 0));
            HGDIOBJ oldPen = SelectObject(hdc, hpen);

            Ellipse(hdc, 0, 0, 512, 512);

            SelectObject(hdc, oldPen);
            DeleteObject(hpen);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        DeleteObject(hbrush);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Draw_Ellipse_PerCall_Small_Nominal_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        HGDIOBJ hbrush = GetStockObject(NULL_BRUSH);
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

        StartTimer();
    
        do {
            Pen pen(Color::Red, 0.1f);
            g->DrawEllipse(&pen, 64, 64, 64, 64);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HGDIOBJ hbrush = GetStockObject(NULL_BRUSH);
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

        StartTimer();
    
        do {
            HPEN hpen = CreatePen(PS_SOLID, 0, RGB(255, 0, 0));
            HGDIOBJ oldPen = SelectObject(hdc, hpen);

            Ellipse(hdc, 64, 64, 128, 128);

            SelectObject(hdc, oldPen);
            DeleteObject(hpen);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        DeleteObject(hbrush);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Draw_Ellipse_PerCall_Small_WideLine_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        StartTimer();
    
        do {
            Pen pen(Color::Red, 5);
            g->DrawEllipse(&pen, 64, 64, 64, 64);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HGDIOBJ hbrush = GetStockObject(NULL_BRUSH);
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

        StartTimer();
    
        do {
            HPEN hpen = CreatePen(PS_SOLID, 5, RGB(255, 0, 0));
            HGDIOBJ oldPen = SelectObject(hdc, hpen);

            Ellipse(hdc, 64, 64, 128, 128);

            SelectObject(hdc, oldPen);
            DeleteObject(hpen);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        DeleteObject(hbrush);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Draw_Pie_PerCall_Nominal(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    StartTimer();

    do {
        Pen pen(Color::Red, 0.1f);
        g->DrawPie(&pen, 0, 0, 512, 512, 90, 120);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

////////////////////////////////////////////////////////////////////////////////
// Add tests for this file here.  Always use the 'T' macro for adding entries.
// The parameter meanings are as follows:
//
// Parameter
// ---------
//     1     UniqueIdentifier - Must be a unique number assigned to no other test
//     2     Priority - On a scale of 1 to 5, how important is the test?
//     3     Function - Function name
//     4     Comment - Anything to describe the test

Test DrawTests[] = 
{
    T(1000, 1, Draw_Lines_PerPixel_Nominal_Solid_Opaque_Aliased                        , "Kpixels/s"),
    T(1001, 1, Draw_Lines_PerPixel_Nominal_Solid_Opaque_Antialiased                    , "Kpixels/s"),
    T(1002, 1, Draw_Lines_PerPixel_Wide_Solid_Opaque_Aliased                           , "Kpixels/s"),
    T(1003, 1, Draw_Lines_PerPixel_Wide_Solid_Opaque_Antialiased                       , "Kpixels/s"),
    T(1004, 1, Draw_Lines_PerLine_Nominal_Solid_Opaque_Aliased                         , "Klines/s"),
    T(1005, 1, Draw_Lines_PerLine_Nominal_Solid_Opaque_Antialiased                     , "Klines/s"),
    T(1006, 1, Draw_Lines_PerLine_Wide_Solid_Opaque_Aliased                            , "Klines/s"),
    T(1007, 1, Draw_Lines_PerLine_Wide_Solid_Opaque_Antialiased                        , "Klines/s"),
    T(1008, 1, Draw_Ellipse_PerCall_Big_Nominal_Aliased                                , "Kcalls/s"),
    T(1009, 1, Draw_Ellipse_PerCall_Big_WideLine_Aliased                               , "Kcalls/s"),
    T(1010, 1, Draw_Pie_PerCall_Nominal                                                , "Kcalls/s"),
    T(1011, 1, Draw_Ellipse_PerCall_Small_Nominal_Aliased                              , "Kcalls/s"),
    T(1012, 1, Draw_Ellipse_PerCall_Small_WideLine_Aliased                             , "Kcalls/s"),
    T(1013, 1, Draw_Lines_PerPixel_Nominal_Solid_Opaque_Antialiased_Quality            , "Kpixels/s"),
    T(1014, 1, Draw_Lines_PerPixel_Wide_Solid_Opaque_Antialiased_Quality               , "Kpixels/s"),
};

INT DrawTests_Count = sizeof(DrawTests) / sizeof(DrawTests[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\perftest\perfimage.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   perfimage.cpp
*
* Abstract:
*
*   Contains all the tests for any routines that do imaging functionality.
*
\**************************************************************************/

#include "perftest.h"

float Image_Draw_PerPixel_Identity_NoDestinationRectangle(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(512, 512, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 512, 512);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerPixel_Identity(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(512, 512, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 512, 512);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_Identity(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Image_Draw_PerPixel_CachedBitmap(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(512, 512, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 512, 512);

    CachedBitmap *cb = new CachedBitmap(&bitmap, g);

    StartTimer();

    do {
        g->DrawCachedBitmap(cb, 0, 0);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    delete cb;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_CachedBitmap(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    CachedBitmap *cb = new CachedBitmap(&bitmap, g);

    StartTimer();

    do {
        g->DrawCachedBitmap(cb, 0, 0);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    delete cb;

    return(iterations / seconds / KILO);           // Kilo-calls per second
}


float Image_Draw_PerPixel_HighQualityBilinear_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeHighQualityBilinear);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_HighQualityBilinear_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeHighQualityBilinear);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Image_Draw_PerPixel_HighQualityBicubic_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeHighQualityBicubic);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_HighQualityBicubic_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeHighQualityBicubic);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}


float Image_Draw_PerPixel_Bilinear_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBilinear);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_Bilinear_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBilinear);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Image_Draw_PerPixel_Bilinear_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBilinear);
    g->RotateTransform(0.2f);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(512, 512, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 512, 512);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 10, 10);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_Bilinear_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBilinear);
    g->RotateTransform(0.2f);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 10, 10, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Image_Draw_PerPixel_Bicubic_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBicubic);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_Bicubic_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBicubic);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Image_Draw_PerPixel_Bicubic_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBicubic);
    g->RotateTransform(0.2f);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(512, 512, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 512, 512);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 10, 10);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_Bicubic_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBicubic);
    g->RotateTransform(0.2f);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 10, 10, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}


// Nearest Neighbor routines
float Image_Draw_PerPixel_NearestNeighbor_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeNearestNeighbor);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_NearestNeighbor_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeNearestNeighbor);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Image_Draw_PerPixel_NearestNeighbor_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeNearestNeighbor);
    g->RotateTransform(0.2f);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(512, 512, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 512, 512);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 10, 10);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_NearestNeighbor_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeNearestNeighbor);
    g->RotateTransform(0.2f);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 10, 10, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}



float Image_Draw_PerPixel_Identity_Recolored_Matrix(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(512, 512, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 512, 512);

    StartTimer();

    do {
        ImageAttributes imageAttributes;
        ColorMatrix colorMatrix = { .25f, .25f, .25f, 0, 0,
                                    .25f, .25f, .25f, 0, 0,
                                    .25f, .25f, .25f, 0, 0,
                                       0,    0,    0, 1, 0,
                                     .1f,  .1f,  .1f, 0, 1 };  // Gray it

        imageAttributes.SetColorMatrix(&colorMatrix);

        g->DrawImage(&bitmap, RectF(0, 0, 512, 512), 0, 0, 512, 512, 
                     UNITPIXEL, &imageAttributes);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_Identity_Recolored_Matrix(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    StartTimer();

    do {
        ImageAttributes imageAttributes;
        ColorMatrix colorMatrix = { .25f, .25f, .25f, 0, 0,
                                    .25f, .25f, .25f, 0, 0,
                                    .25f, .25f, .25f, 0, 0,
                                       0,    0,    0, 1, 0,
                                     .1f,  .1f,  .1f, 0, 1 };  // Gray it

        imageAttributes.SetColorMatrix(&colorMatrix);

        g->DrawImage(&bitmap, RectF(0, 0, 1, 1), 0, 0, 1, 1, 
                     UNITPIXEL, &imageAttributes);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);
}

float Image_Draw_PerPixel_Scaled_2x_Recolored_Matrix(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        ImageAttributes imageAttributes;
        ColorMatrix colorMatrix = { .25f, .25f, .25f, 0, 0,
                                    .25f, .25f, .25f, 0, 0,
                                    .25f, .25f, .25f, 0, 0,
                                       0,    0,    0, 1, 0,
                                     .1f,  .1f,  .1f, 0, 1 };  // Gray it

        imageAttributes.SetColorMatrix(&colorMatrix);

        g->DrawImage(&bitmap, RectF(0, 0, 512, 512), 0, 0, 256, 256, 
                     UNITPIXEL, &imageAttributes);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

////////////////////////////////////////////////////////////////////////////////
// Add tests for this file here.  Always use the 'T' macro for adding entries.
// The parameter meanings are as follows:
//
// Parameter
// ---------
//     1     UniqueIdentifier - Must be a unique number assigned to no other test
//     2     Priority - On a scale of 1 to 5, how important is the test?
//     3     Function - Function name
//     4     Comment - Anything to describe the test

Test ImageTests[] = 
{
    T(2000, 1, Image_Draw_PerPixel_Identity                                            , "Mpixels/s"),
    T(2001, 1, Image_Draw_PerCall_Identity                                             , "Kcalls/s"),
    T(2002, 1, Image_Draw_PerPixel_Bilinear_Scaled                                     , "Mpixels/s"),
    T(2003, 1, Image_Draw_PerCall_Bilinear_Scaled                                      , "Kcalls/s"),
    T(2004, 1, Image_Draw_PerPixel_Bilinear_Rotated                                    , "Mpixels/s"),
    T(2005, 1, Image_Draw_PerCall_Bilinear_Rotated                                     , "Kcalls/s"),
    T(2006, 1, Image_Draw_PerPixel_Bicubic_Scaled                                      , "Mpixels/s"),
    T(2007, 1, Image_Draw_PerCall_Bicubic_Scaled                                       , "Kcalls/s"),
    T(2008, 1, Image_Draw_PerPixel_Bicubic_Rotated                                     , "Mpixels/s"),
    T(2009, 1, Image_Draw_PerCall_Bicubic_Rotated                                      , "Kcalls/s"),
    T(2010, 1, Image_Draw_PerPixel_Identity_NoDestinationRectangle                     , "Mpixels/s"),
    T(2011, 1, Image_Draw_PerPixel_Identity_Recolored_Matrix                           , "Mpixels/s"),
    T(2012, 1, Image_Draw_PerPixel_Scaled_2x_Recolored_Matrix                          , "Mpixels/s"),
    T(2013, 1, Image_Draw_PerCall_Identity_Recolored_Matrix                            , "Kcalls/s"),
    T(2014, 1, Image_Draw_PerPixel_NearestNeighbor_Scaled                              , "Mpixels/s"),
    T(2015, 1, Image_Draw_PerCall_NearestNeighbor_Scaled                               , "Kcalls/s"),
    T(2016, 1, Image_Draw_PerPixel_NearestNeighbor_Rotated                             , "Mpixels/s"),
    T(2017, 1, Image_Draw_PerCall_NearestNeighbor_Rotated                              , "Kcalls/s"),
    T(2018, 1, Image_Draw_PerPixel_HighQualityBilinear_Scaled                          , "Mpixels/s"),
    T(2019, 1, Image_Draw_PerCall_HighQualityBilinear_Scaled                           , "Kcalls/s"),    
    T(2020, 1, Image_Draw_PerPixel_HighQualityBicubic_Scaled                           , "Mpixels/s"),
    T(2021, 1, Image_Draw_PerCall_HighQualityBicubic_Scaled                            , "Kcalls/s"),    
    T(2022, 1, Image_Draw_PerPixel_CachedBitmap                                        , "Mpixels/s"),
    T(2023, 1, Image_Draw_PerCall_CachedBitmap                                         , "Kcalls/s"),    
};

INT ImageTests_Count = sizeof(ImageTests) / sizeof(ImageTests[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\perftest\perfother.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   perfother.cpp
*
* Abstract:
*
*   Contains all the tests for anything 'miscellaneous'.
*
\**************************************************************************/

#include "perftest.h"

float Other_Graphics_Create_FromHwnd_PerCall(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        StartTimer();
    
        do {
            Graphics g(ghwndMain);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        StartTimer();

        do {
            HDC hdc = GetDC(ghwndMain);
            ReleaseDC(ghwndMain, hdc);

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    return(iterations / seconds / KILO);       // Kilo-calls per second
}

float Other_Graphics_Create_FromScreenHdc_PerCall(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);

    HDC hdc = GetDC(ghwndMain);

    StartTimer();

    do {
        Graphics g(hdc);

        ASSERT(g.GetLastStatus() == Ok);

    } while (!EndTimer());

    GetTimer(&seconds, &iterations);

    ReleaseDC(ghwndMain, hdc);

    return(iterations / seconds / KILO);       // Kilo-calls per second
}

////////////////////////////////////////////////////////////////////////////////
// Add tests for this file here.  Always use the 'T' macro for adding entries.
// The parameter meanings are as follows:
//
// Parameter
// ---------
//     1     UniqueIdentifier - Must be a unique number assigned to no other test
//     2     Priority - On a scale of 1 to 5, how important is the test?
//     3     Function - Function name
//     4     Comment - Anything to describe the test

Test OtherTests[] = 
{
    T(5000, 1, Other_Graphics_Create_FromHwnd_PerCall                   , "Kcalls/s"),
    T(5001, 1, Other_Graphics_Create_FromScreenHdc_PerCall              , "Kcalls/s"),
};

INT OtherTests_Count = sizeof(OtherTests) / sizeof(OtherTests[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\perftest\perffill.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   perffill.cpp
*
* Abstract:
*
*   Contains all the tests for any routines that 'Fill'.
*
\**************************************************************************/

#include "perftest.h"

float Fill_Ellipse_PerCall_Big_Solid(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        StartTimer();
    
        do {
            SolidBrush brush(Color::Red);
            g->FillEllipse(&brush, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HGDIOBJ hpen = GetStockObject(NULL_PEN);
        HGDIOBJ oldPen = SelectObject(hdc, hpen);

        StartTimer();
    
        do {
            HBRUSH hbrush = CreateSolidBrush(RGB(255, 0, 0));
            HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

            Ellipse(hdc, 0, 0, 512, 512);

            SelectObject(hdc, oldBrush);
            DeleteObject(hbrush);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldPen);
        DeleteObject(hpen);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Ellipse_PerCall_Small_Solid(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        StartTimer();
    
        do {
            SolidBrush brush(Color::Red);
            g->FillEllipse(&brush, 64, 64, 64, 64);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HGDIOBJ hpen = GetStockObject(NULL_PEN);
        HGDIOBJ oldPen = SelectObject(hdc, hpen);

        StartTimer();
    
        do {
            HBRUSH hbrush = CreateSolidBrush(RGB(255, 0, 0));
            HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

            Ellipse(hdc, 64, 64, 128, 128);

            SelectObject(hdc, oldBrush);
            DeleteObject(hbrush);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldPen);
        DeleteObject(hpen);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    SolidBrush brush(Color::Red);

    StartTimer();

    do {
        g->FillRectangle(&brush, 10, 10, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerPixel_Solid_Opaque_Antialiased_Integer(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    SolidBrush brush(Color::Red);

    StartTimer();

    do {
        g->FillRectangle(&brush, 10, 10, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerPixel_Solid_Opaque_Antialiased_HalfInteger(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    SolidBrush brush(Color::Red);

    StartTimer();

    do {
        g->FillRectangle(&brush, 10.5f, 10.5f, 512.0f, 512.0f);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        StartTimer();
    
        do {
            SolidBrush brush(Color::Red);
    
            g->FillRectangle(&brush, 20, 20, 1, 1);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        StartTimer();
    
        do {
            RECT rect = { 20, 20, 21, 21 };

            HBRUSH hbrush = CreateSolidBrush(RGB(255, 0, 0));

            FillRect(hdc, &rect, hbrush);

            DeleteObject(hbrush);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        SolidBrush brush(Color::Red);
        PointF points[] = { PointF(0, 0), PointF(512, 0), 
                            PointF(513, 512), PointF(1, 512) };
    
        StartTimer();
    
        do {
            g->FillPolygon(&brush, points, 4);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HBRUSH hbrush = CreateSolidBrush(RGB(255, 0, 0));
        HGDIOBJ hpen = GetStockObject(NULL_PEN);

        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);
        HGDIOBJ oldPen = SelectObject(hdc, hpen);

        POINT points[] = { 0, 0, 512, 0, 513, 512, 1, 512 };

        StartTimer();

        do {
            Polygon(hdc, points, 4);

        } while (!EndTimer());

        GdiFlush();

        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        SelectObject(hdc, oldPen);

        DeleteObject(hbrush);
        DeleteObject(hpen);
    }

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_CompatibleDIB(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    HDC screenDc = gScreen->GetHDC();
    HBITMAP bitmap = CreateCompatibleDIB2(screenDc, 520, 520);
    HDC dc = CreateCompatibleDC(screenDc);
    SelectObject(dc, bitmap);
    Graphics g(dc);

    SolidBrush brush(Color::Red);
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    BitBlt(screenDc, 0, 0, 520, 520, dc, 0, 0, SRCCOPY);

    gScreen->ReleaseHDC(screenDc);
    DeleteObject(dc);
    DeleteObject(bitmap);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_15bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat16bppRGB555);
    Graphics g(&bitmap);

    SolidBrush brush(Color::Red);
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_16bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat16bppRGB565);
    Graphics g(&bitmap);

    SolidBrush brush(Color::Red);
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_24bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat24bppRGB);
    Graphics g(&bitmap);

    SolidBrush brush(Color::Red);
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_32bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat32bppRGB);
    Graphics g(&bitmap);

    SolidBrush brush(Color::Red);
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    SolidBrush brush(Color(0x80, 0xff, 0, 0));
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Quality(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetCompositingQuality(CompositingQualityHighQuality);

    SolidBrush brush(Color(0x80, 0xff, 0, 0));
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_CompatibleDIB(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    HDC screenDc = gScreen->GetHDC();
    HBITMAP bitmap = CreateCompatibleDIB2(screenDc, 520, 520);
    HDC dc = CreateCompatibleDC(screenDc);
    SelectObject(dc, bitmap);
    Graphics g(dc);

    SolidBrush brush(Color(0x80, 0xff, 0, 0));
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    BitBlt(screenDc, 0, 0, 520, 520, dc, 0, 0, SRCCOPY);

    gScreen->ReleaseHDC(screenDc);
    DeleteObject(dc);
    DeleteObject(bitmap);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_15bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat16bppRGB555);
    Graphics g(&bitmap);

    SolidBrush brush(Color(0x80, 0xff, 0, 0));
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_16bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat16bppRGB565);
    Graphics g(&bitmap);

    SolidBrush brush(Color(0x80, 0xff, 0, 0));
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_24bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat24bppRGB);
    Graphics g(&bitmap);

    SolidBrush brush(Color(0x80, 0xff, 0, 0));
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_32bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat32bppRGB);
    Graphics g(&bitmap);

    SolidBrush brush(Color(0x80, 0xff, 0, 0));
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerCall_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        StartTimer();
    
        do {
            SolidBrush brush(Color::Red);
            PointF points[] = { PointF(20, 20), PointF(21, 20), 
                                PointF(21, 21), PointF(20, 21) };
    
            g->FillPolygon(&brush, points, 4);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        StartTimer();

        HGDIOBJ hpen = GetStockObject(NULL_PEN);
        HGDIOBJ oldPen = SelectObject(hdc, hpen);

        do {
            HBRUSH hbrush = CreateSolidBrush(RGB(255, 0, 0));
            HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

            POINT points[] = { 20, 20, 21, 20, 21, 21, 20, 21 };

            Polygon(hdc, points, 4);

            SelectObject(hdc, oldBrush);
            DeleteObject(hbrush);

        } while (!EndTimer());

        GdiFlush();

        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldPen);
        DeleteObject(hpen);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Trapezoid_PerPixel_Texture_Identity_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);  // No GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    Bitmap bitmap(L"winnt256.bmp");
    TextureBrush brush(&bitmap);
    PointF points[] = { PointF(10, 10), PointF(522, 10), 
                        PointF(523, 522), PointF(11, 522) };

    StartTimer();

    do {
        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Texture_Scaled_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);  // No GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    Bitmap bitmap(L"winnt256.bmp");
    TextureBrush brush(&bitmap);
    PointF points[] = { PointF(10, 10), PointF(522, 10), 
                        PointF(523, 522), PointF(11, 522) };

    Matrix matrix(0.5, 0, 0, 0.5, 0, 0);
    brush.SetTransform(&matrix);

    StartTimer();

    do {
        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Antialiased_Quality(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);
    g->SetCompositingQuality(CompositingQualityHighQuality);
    
    SolidBrush brush(Color::Red);
    PointF points[] = { PointF(10, 10), PointF(522, 10), 
                        PointF(523, 522), PointF(11, 522) };

    StartTimer();

    do {
        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);
    
    SolidBrush brush(Color::Red);
    PointF points[] = { PointF(10, 10), PointF(522, 10), 
                        PointF(523, 522), PointF(11, 522) };

    StartTimer();

    do {
        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerCall_Solid_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);
    
    StartTimer();

    do {
        SolidBrush brush(Color::Red);
        PointF points[] = { PointF(20, 20), PointF(21, 20), 
                            PointF(21, 21), PointF(20, 21) };

        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);
    
    Color color(0x80, 0x80, 0, 0);
    SolidBrush brush(color);
    PointF points[] = { PointF(10, 10), PointF(522, 10), 
                        PointF(523, 522), PointF(11, 522) };

    StartTimer();

    do {
        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerCall_Solid_Transparent_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    StartTimer();

    do {
        Color color(0x80, 0x80, 0, 0);
        SolidBrush brush(color);
        PointF points[] = { PointF(20, 20), PointF(21, 20), 
                            PointF(21, 21), PointF(20, 21) };

        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_Hatch_Opaque(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        HatchBrush brush(HatchStyleDiagonalCross, Color::Red, Color::Black);
    
        StartTimer();
    
        do {
            g->FillRectangle(&brush, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HBRUSH hbrush = CreateHatchBrush(HS_DIAGCROSS, RGB(0xff, 0, 0));
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);
    
        StartTimer();
    
        do {
            PatBlt(hdc, 0, 0, 512, 512, PATCOPY);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        DeleteObject(hbrush);
    }

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerPixel_Hatch_Transparent(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        HatchBrush brush(HatchStyleDiagonalCross, Color::Red, Color(0, 0, 0, 0));
    
        StartTimer();
    
        do {
            g->FillRectangle(&brush, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HBRUSH hbrush = CreateHatchBrush(HS_DIAGCROSS, RGB(0xff, 0, 0));
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

        SetBkMode(hdc, TRANSPARENT);
    
        StartTimer();
    
        do {
            PatBlt(hdc, 0, 0, 512, 512, PATCOPY);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        DeleteObject(hbrush);
    }

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_Hatch(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    StartTimer();

    do {
        HatchBrush brush(HatchStyleForwardDiagonal, Color::Red, Color::Black);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_Texture_Big(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap bitmap(L"winnt256.bmp");
    TextureBrush brush(&bitmap);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerPixel_Texture_Small(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap bitmap(L"winnt256.bmp");
    Bitmap texture(32, 32, PixelFormat32bppRGB);
    Graphics gTexture(&texture);
    gTexture.DrawImage(&bitmap, Rect(0, 0, 32, 32));

    TextureBrush brush(&texture);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_Texture(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    StartTimer();

    do {
        Bitmap bitmap(L"winnt256.bmp");
        TextureBrush brush(&bitmap);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_Texture_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Matrix matrix(0.5, 0, 0, 0.5, 0, 0);

    Bitmap bitmap(L"winnt256.bmp");
    TextureBrush brush(&bitmap);
    brush.SetTransform(&matrix);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_Texture_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Matrix matrix(0.5, 0, 0, 0.5, 0, 0);

    StartTimer();

    do {
        Bitmap bitmap(L"winnt256.bmp");
        TextureBrush brush(&bitmap);
        brush.SetTransform(&matrix);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_Texture_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Matrix matrix(0.707f, 0.707f, -0.707f, 0.707f, 0, 0);

    Bitmap bitmap(L"winnt256.bmp");
    TextureBrush brush(&bitmap);
    brush.SetTransform(&matrix);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_Texture_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Matrix matrix(0.707f, 0.707f, -0.707f, 0.707f, 0, 0);

    StartTimer();

    do {
        Bitmap bitmap(L"winnt256.bmp");
        TextureBrush brush(&bitmap);
        brush.SetTransform(&matrix);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

#if !USE_NEW_APIS
    
    float Fill_Rectangle_PerPixel_RectangleGradient(Graphics *g, HDC hdc)
    {
        UINT iterations;
        float seconds;
    
        if (!g) return(0);          // There is no GDI equivalent
    
        Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
    
        RectangleGradientBrush brush(RectF(0, 0, 512, 512), colors, WrapModeClamp);
    
        StartTimer();
    
        do {
            g->FillRectangle(&brush, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    
        UINT pixels = 512 * 512 * iterations;
    
        return(pixels / seconds / MEGA);        // Mega-pixels per second
    }
    
    float Fill_Rectangle_PerCall_RectangleGradient(Graphics *g, HDC hdc)
    {
        UINT iterations;
        float seconds;
    
        if (!g) return(0);          // There is no GDI equivalent
    
        Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
    
        StartTimer();
    
        do {
            RectangleGradientBrush brush(RectF(0, 0, 512, 512), colors, WrapModeClamp);
    
            g->FillRectangle(&brush, 20, 20, 1, 1);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    
        return(iterations / seconds / KILO);           // Kilo-calls per second
    }
    
    float Fill_Rectangle_PerPixel_RectangleGradient_BlendFactors(Graphics *g, HDC hdc)
    {
        UINT iterations;
        float seconds;
    
        if (!g) return(0);          // There is no GDI equivalent
    
        Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
        REAL blendFactors[] = { 0.0f, 0.0168160f, 0.0333130f, 0.0844290f, 0.139409f,
                                0.210211f, 0.295801f, 0.393017f, 0.5f, 0.606983f,
                                1.0f };
        REAL blendPositions[] = { 0.0f, 0.0625f, 0.125f, 0.1875f, 0.25f,
                                  0.3125f, 0.375f, 0.4375f, 0.5f, 0.5625f, 
                                  1.0f };
    
        RectangleGradientBrush brush(RectF(0, 0, 512, 512), colors, WrapModeClamp);
        brush.SetHorizontalBlend(blendFactors, blendPositions, 11);
    
        StartTimer();
    
        do {
            g->FillRectangle(&brush, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    
        UINT pixels = 512 * 512 * iterations;
    
        return(pixels / seconds / MEGA);        // Mega-pixels per second
    }
    
    float Fill_Rectangle_PerCall_RectangleGradient_BlendFactors(Graphics *g, HDC hdc)
    {
        UINT iterations;
        float seconds;
    
        if (!g) return(0);          // There is no GDI equivalent
    
        Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
        REAL blendFactors[] = { 0.0f, 0.0168160f, 0.0333130f, 0.0844290f, 0.139409f,
                                0.210211f, 0.295801f, 0.393017f, 0.5f, 0.606983f,
                                1.0f };
        REAL blendPositions[] = { 0.0f, 0.0625f, 0.125f, 0.1875f, 0.25f,
                                  0.3125f, 0.375f, 0.4375f, 0.5f, 0.5625f, 
                                  1.0f };
    
        StartTimer();
    
        do {
            RectangleGradientBrush brush(RectF(0, 0, 512, 512), colors, WrapModeClamp);
            brush.SetHorizontalBlend(blendFactors, blendPositions, 11);
    
            g->FillRectangle(&brush, 20, 20, 1, 1);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    
        return(iterations / seconds / KILO);           // Kilo-calls per second
    }
    
    float Fill_Rectangle_PerPixel_RadialGradient(Graphics *g, HDC hdc)
    {
        UINT iterations;
        float seconds;
    
        if (!g) return(0);          // There is no GDI equivalent
    
        RadialGradientBrush brush(RectF(0, 0, 512, 512), Color::Black, Color::Red, WrapModeTile);
    
        StartTimer();
    
        do {
            g->FillRectangle(&brush, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    
        UINT pixels = 512 * 512 * iterations;
    
        return(pixels / seconds / MEGA);        // Mega-pixels per second
    }
    
    float Fill_Rectangle_PerCall_RadialGradient(Graphics *g, HDC hdc)
    {
        UINT iterations;
        float seconds;
    
        if (!g) return(0);          // There is no GDI equivalent
    
        StartTimer();
    
        do {
            RadialGradientBrush brush(RectF(0, 0, 512, 512), Color::Black, Color::Red, WrapModeTile);
    
            g->FillRectangle(&brush, 20, 20, 1, 1);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    
        return(iterations / seconds / KILO);           // Kilo-calls per second
    }

#endif

float Fill_Rectangle_PerPixel_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    // LinearGradientBrush brush(PointF(128, 128), PointF(256, 256), 
    //                         Color::Red, Color::Black, WrapModeTileFlipX);

    LinearGradientBrush brush(PointF(0, 0), PointF(512, 512), Color::Red, Color::Black);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    StartTimer();

    do {
        LinearGradientBrush brush(PointF(0, 0), PointF(512, 512), Color::Red, Color::Black);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_LinearGradient_PresetColors(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    INT i;

    if (!g) return(0);          // There is no GDI equivalent

    Color colors[12];
    REAL blendPositions[] = { 0.0f, 0.0625f, 0.125f, 0.1875f, 0.25f,
                              0.3125f, 0.375f, 0.4375f, 0.5f, 0.5625f, 
                              1.0f };
    for (i = 0; i < 12; i += 2)
    {
        colors[i] = Color::Red;
        colors[i + 1] = Color::Black;
    }

    LinearGradientBrush brush(PointF(0, 0), PointF(512, 512), Color::Red, Color::Black);
    brush.SetInterpolationColors(colors, blendPositions, 11);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_LinearGradient_PresetColors(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    INT i;

    if (!g) return(0);          // There is no GDI equivalent

    Color colors[12];
    REAL blendPositions[] = { 0.0f, 0.0625f, 0.125f, 0.1875f, 0.25f,
                              0.3125f, 0.375f, 0.4375f, 0.5f, 0.5625f, 
                              1.0f };
    for (i = 0; i < 12; i += 2)
    {
        colors[i] = Color::Red;
        colors[i + 1] = Color::Black;
    }

    StartTimer();

    do {
        LinearGradientBrush brush(PointF(0, 0), PointF(512, 512), Color::Red, Color::Black);
        brush.SetInterpolationColors(colors, blendPositions, 11);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_LinearGradient_BlendFactors(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    REAL blendFactors[] = { 0.0f, 0.0168160f, 0.0333130f, 0.0844290f, 0.139409f,
                            0.210211f, 0.295801f, 0.393017f, 0.5f, 0.606983f,
                            1.0f };
    REAL blendPositions[] = { 0.0f, 0.0625f, 0.125f, 0.1875f, 0.25f,
                              0.3125f, 0.375f, 0.4375f, 0.5f, 0.5625f, 
                              1.0f };

    LinearGradientBrush brush(PointF(0, 0), PointF(512, 512), Color::Red, Color::Black);
    brush.SetBlend(blendFactors, blendPositions, 11);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_LinearGradient_BlendFactors(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    REAL blendFactors[] = { 0.0f, 0.0168160f, 0.0333130f, 0.0844290f, 0.139409f,
                            0.210211f, 0.295801f, 0.393017f, 0.5f, 0.606983f,
                            1.0f };
    REAL blendPositions[] = { 0.0f, 0.0625f, 0.125f, 0.1875f, 0.25f,
                              0.3125f, 0.375f, 0.4375f, 0.5f, 0.5625f, 
                              1.0f };

    StartTimer();

    do {
        LinearGradientBrush brush(PointF(0, 0), PointF(512, 512), Color::Red, Color::Black);
        brush.SetBlend(blendFactors, blendPositions, 11);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_PathGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Red, Color::Red, Color::Red };
    INT count = 4;

    PathGradientBrush brush(points, 4);
    brush.SetCenterColor(Color::Black);
    brush.SetSurroundColors(colors, &count);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_PathGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Red, Color::Red, Color::Red };
    INT count = 4;

    StartTimer();

    do {
        PathGradientBrush brush(points, 4);
        brush.SetCenterColor(Color::Black);
        brush.SetSurroundColors(colors, &count);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_PathGradient_LotsaTriangles(Graphics *g, HDC hdc)
{
    UINT iterations;
    INT count;
    INT i;
    float seconds;
    float pi;
    float angle;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[50];
    Color colors[50];

    pi = static_cast<float>(acos(-1.0f));

    for (angle = 0, count = 0; angle < 2*pi; angle += (pi / 20), count++)
    {
        points[count].X = 256 + 512 * static_cast<float>(cos(angle));
        points[count].Y = 256 + 512 * static_cast<float>(sin(angle));
    }

    for (i = 0; i < count; i++)
    {
        colors[i] = Color::Red;
    }

    PathGradientBrush brush(points, count);
    brush.SetCenterColor(Color::Black);
    brush.SetSurroundColors(colors, &count);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_PathGradient_LotsaTriangles(Graphics *g, HDC hdc)
{
    UINT iterations;
    INT count;
    INT i;
    float seconds;
    float pi;
    float angle;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[50];
    Color colors[50];

    pi = static_cast<float>(acos(-1.0f));

    for (angle = 0, count = 0; angle < 2*pi; angle += (pi / 20), count++)
    {
        points[count].X = 256 + 512 * static_cast<float>(cos(angle));
        points[count].Y = 256 + 512 * static_cast<float>(sin(angle));
    }

    for (i = 0; i < count; i++)
    {
        colors[i] = Color::Red;
    }

    StartTimer();

    do {
        PathGradientBrush brush(points, count);
        brush.SetCenterColor(Color::Black);
        brush.SetSurroundColors(colors, &count);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_PathGradient_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Red, Color::Red, Color::Red };
    INT count = 4;

    PathGradientBrush brush(points, 4);
    brush.SetCenterColor(Color::Black);
    brush.SetSurroundColors(colors, &count);
    brush.SetFocusScales(0.2f, 0.2f);
    brush.SetCenterPoint(PointF(200, 200));

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_PathGradient_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Red, Color::Red, Color::Red };
    INT count = 4;

    StartTimer();

    do {
        PathGradientBrush brush(points, 4);
        brush.SetCenterColor(Color::Black);
        brush.SetSurroundColors(colors, &count);
        brush.SetFocusScales(0.2f, 0.2f);
        brush.SetCenterPoint(PointF(200, 200));

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_PathGradient_Multicolored(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
    INT count = 4;

    PathGradientBrush brush(points, 4);
    brush.SetCenterColor(Color::Black);
    brush.SetSurroundColors(colors, &count);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_PathGradient_Multicolored(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
    INT count = 4;

    StartTimer();

    do {
        PathGradientBrush brush(points, 4);
        brush.SetCenterColor(Color::Black);
        brush.SetSurroundColors(colors, &count);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_PathGradient_Multicolored_LotsaTriangles(Graphics *g, HDC hdc)
{
    UINT iterations;
    INT count;
    INT i;
    float seconds;
    float pi;
    float angle;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[50];
    Color colors[50];

    pi = static_cast<float>(acos(-1.0f));

    // Create 40 points:

    for (angle = 0, count = 0; angle < 2*pi; angle += (pi / 20), count++)
    {
        points[count].X = 256 + 512 * static_cast<float>(cos(angle));
        points[count].Y = 256 + 512 * static_cast<float>(sin(angle));
    }

    for (i = 0; i < count; i += 2)
    {
        colors[i] = Color::Red;
        colors[i + 1] = Color::Blue;
    }

    PathGradientBrush brush(points, count);
    brush.SetCenterColor(Color::Black);
    brush.SetSurroundColors(colors, &count);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PathGradient_Multicolored_LotsaTriangles(Graphics *g, HDC hdc)
{
    UINT iterations;
    INT count;
    INT i;
    float seconds;
    float pi;
    float angle;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[50];
    Color colors[50];

    pi = static_cast<float>(acos(-1.0f));

    // Create 40 points:

    for (angle = 0, count = 0; angle < 2*pi; angle += (pi / 20), count++)
    {
        points[count].X = 256 + 512 * static_cast<float>(cos(angle));
        points[count].Y = 256 + 512 * static_cast<float>(sin(angle));
    }

    for (i = 0; i < count; i += 2)
    {
        colors[i] = Color::Red;
        colors[i + 1] = Color::Blue;
    }

    StartTimer();

    do {
        PathGradientBrush brush(points, count);
        brush.SetCenterColor(Color::Black);
        brush.SetSurroundColors(colors, &count);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_PathGradient_Multicolored_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
    INT count = 4;

    PathGradientBrush brush(points, 4);
    brush.SetCenterColor(Color::Black);
    brush.SetSurroundColors(colors, &count);
    brush.SetFocusScales(0.2f, 0.2f);
    brush.SetCenterPoint(PointF(200, 200));

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_PathGradient_Multicolored_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
    INT count = 4;

    StartTimer();

    do {
        PathGradientBrush brush(points, 4);
        brush.SetCenterColor(Color::Black);
        brush.SetSurroundColors(colors, &count);
        brush.SetFocusScales(0.2f, 0.2f);
        brush.SetCenterPoint(PointF(200, 200));

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Path_PerCall_Solid_Complex_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    FontFamily family(L"Times New Roman");
    GraphicsPath path(FillModeWinding);

    PointF origin1(20, 20);
    path.AddString(L"GDI+", wcslen(L"GDI+"), &family, 0, 200,
                   origin1, NULL);

    PointF origin2(20, 220);
    path.AddString(L"Rocks!", wcslen(L"Rocks!"), &family, FontStyleItalic, 200,
                   origin2, NULL);

    if (g)
    {
        SolidBrush brush(Color::Silver);
    
        StartTimer();
    
        do {
            g->FillPath(&brush, &path);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        PathData pathData;
        INT i;

        INT count = path.GetPointCount();
        PointF *pointF = new PointF[count];
        BYTE *types = new BYTE[count];
        POINT *point = new POINT[count];

        // ACK - these should NOT be public!
        pathData.Points = pointF;
        pathData.Types = types;
        pathData.Count = count;

        path.GetPathData(&pathData);

        for (i = 0; i < count; i++)
        {
            point[i].x = (INT) (pointF[i].X + 0.5f);
            point[i].y = (INT) (pointF[i].Y + 0.5f);
        }

        for (i = 0; i < count; i++)
        {
            BYTE type = types[i] & PathPointTypePathTypeMask;

            if (type == PathPointTypeStart)
                type = PT_MOVETO;

            else if (type == PathPointTypeLine)
                type = PT_LINETO;

            else if (type == PathPointTypeBezier)
                type = PT_BEZIERTO;
            else
            {
                ASSERT(FALSE);
            }

            if (types[i] & PathPointTypeCloseSubpath)
                type |= PT_CLOSEFIGURE;

            types[i] = type;
        }

        HBRUSH hbrush = CreateSolidBrush(RGB(255, 0, 0));
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

        HGDIOBJ hpen = GetStockObject(NULL_PEN);
        HGDIOBJ oldPen = SelectObject(hdc, hpen);

        BeginPath(hdc);
        PolyDraw(hdc, point, types, count);
        EndPath(hdc);

        StartTimer();
    
        do {
            SaveDC(hdc);
            FillPath(hdc);
            RestoreDC(hdc, -1);
    
        } while (!EndTimer());

        AbortPath(hdc);

        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        DeleteObject(hbrush);

        SelectObject(hdc, oldPen);
        DeleteObject(hpen);

        // Clear these so that the PathData destructor doesn't cause trouble...
        pathData.Points = NULL;
        pathData.Types = NULL;
        pathData.Count = 0;

        delete[] pointF;
        delete[] types;
        delete[] point;
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Path_PerCall_Solid_Complex_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    FontFamily family(L"Times New Roman");
    GraphicsPath path(FillModeWinding);

    PointF origin1(20, 20);
    path.AddString(L"GDI+", wcslen(L"GDI+"), &family, 0, 200,
                   origin1, NULL);

    PointF origin2(20, 220);
    path.AddString(L"Rocks!", wcslen(L"Rocks!"), &family, FontStyleItalic, 200,
                   origin2, NULL);

    SolidBrush brush(Color::Silver);

    StartTimer();

    do {
        g->FillPath(&brush, &path);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Path_PerCall_Solid_Complex_Antialiased_Transparent(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    FontFamily family(L"Times New Roman");
    GraphicsPath path(FillModeWinding);

    PointF origin1(20, 20);
    path.AddString(L"GDI+", wcslen(L"GDI+"), &family, 0, 200,
                   origin1, NULL);

    PointF origin2(20, 220);
    path.AddString(L"Rocks!", wcslen(L"Rocks!"), &family, FontStyleItalic, 200,
                   origin2, NULL);

    SolidBrush brush(Color(0x80, 0xff, 0, 0));

    StartTimer();

    do {
        g->FillPath(&brush, &path);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

////////////////////////////////////////////////////////////////////////////////
// Add tests for this file here.  Always use the 'T' macro for adding entries.
// The parameter meanings are as follows:
//
// Parameter
// ---------
//     1     UniqueIdentifier - Must be a unique number assigned to no other test
//     2     Priority - On a scale of 1 to 5, how important is the test?
//     3     Function - Function name
//     4     Comment - Anything to describe the test

Test FillTests[] = 
{
    T(3000, 1, Fill_Rectangle_PerPixel_Solid_Opaque_Aliased                            , "Mpixels/s"),
    T(3001, 1, Fill_Rectangle_PerCall_Solid_Opaque_Aliased                             , "Kcalls/s"),
    T(3002, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased                            , "Mpixels/s"),
    T(3003, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_CompatibleDIB              , "Mpixels/s"),
    T(3004, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_15bpp               , "Mpixels/s"),
    T(3005, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_16bpp               , "Mpixels/s"),
    T(3006, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_24bpp               , "Mpixels/s"),
    T(3007, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_32bpp               , "Mpixels/s"),
    T(3008, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased                       , "Mpixels/s"),
    T(3009, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Quality               , "Mpixels/s"),
    T(3010, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_CompatibleDIB         , "Mpixels/s"),
    T(3011, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_15bpp          , "Mpixels/s"),
    T(3012, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_16bpp          , "Mpixels/s"),
    T(3013, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_24bpp          , "Mpixels/s"),
    T(3014, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_32bpp          , "Mpixels/s"),
    T(3015, 1, Fill_Trapezoid_PerCall_Solid_Opaque_Aliased                             , "Kcalls/s"),
    T(3016, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Antialiased                        , "Mpixels/s"),
    T(3017, 1, Fill_Trapezoid_PerCall_Solid_Opaque_Antialiased                         , "Kcalls/s"),
    T(3018, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Antialiased                   , "Mpixels/s"),
    T(3019, 1, Fill_Trapezoid_PerCall_Solid_Transparent_Antialiased                    , "Kcalls/s"),
    T(3020, 1, Fill_Rectangle_PerPixel_Hatch_Opaque                                    , "Mpixels/s"),
    T(3021, 1, Fill_Rectangle_PerCall_Hatch                                            , "Kcalls/s"),
    T(3022, 1, Fill_Rectangle_PerPixel_Texture_Big                                     , "Mpixels/s"),
    T(3023, 1, Fill_Rectangle_PerCall_Texture                                          , "Kcalls/s"),
    T(3024, 1, Fill_Rectangle_PerPixel_Texture_Scaled                                  , "Mpixels/s"),
    T(3025, 1, Fill_Rectangle_PerCall_Texture_Scaled                                   , "Kcalls/s"),
    T(3026, 1, Fill_Rectangle_PerPixel_Texture_Rotated                                 , "Mpixels/s"),
    T(3027, 1, Fill_Rectangle_PerCall_Texture_Rotated                                  , "Kcalls/s"),
#if !USE_NEW_APIS
    T(3028, 1, Fill_Rectangle_PerPixel_RectangleGradient                               , "Mpixels/s"),
    T(3029, 1, Fill_Rectangle_PerCall_RectangleGradient                                , "Kcalls/s"),
    T(3030, 1, Fill_Rectangle_PerPixel_RectangleGradient_BlendFactors                  , "Mpixels/s"),
    T(3031, 1, Fill_Rectangle_PerCall_RectangleGradient_BlendFactors                   , "Kcalls/s"),
    T(3038, 1, Fill_Rectangle_PerPixel_RadialGradient                                  , "Mpixels/s"),
    T(3039, 1, Fill_Rectangle_PerCall_RadialGradient                                   , "Kcalls/s"),
#endif
    T(3032, 1, Fill_Rectangle_PerPixel_LinearGradient                                  , "Mpixels/s"),
    T(3033, 1, Fill_Rectangle_PerCall_LinearGradient                                   , "Kcalls/s"),
    T(3034, 1, Fill_Rectangle_PerPixel_LinearGradient_PresetColors                     , "Mpixels/s"),
    T(3035, 1, Fill_Rectangle_PerCall_LinearGradient_PresetColors                      , "Kcalls/s"),
    T(3036, 1, Fill_Rectangle_PerPixel_LinearGradient_BlendFactors                     , "Mpixels/s"),
    T(3037, 1, Fill_Rectangle_PerCall_LinearGradient_BlendFactors                      , "Kcalls/s"),
    T(3040, 1, Fill_Rectangle_PerPixel_PathGradient                                    , "Mpixels/s"),
    T(3041, 1, Fill_Rectangle_PerCall_PathGradient                                     , "Kcalls/s"),
    T(3042, 1, Fill_Rectangle_PerPixel_PathGradient_LotsaTriangles                     , "Mpixels/s"),
    T(3043, 1, Fill_Rectangle_PerCall_PathGradient_LotsaTriangles                      , "Kcalls/s"),
    T(3044, 1, Fill_Rectangle_PerPixel_PathGradient_Scaled                             , "Mpixels/s"),
    T(3045, 1, Fill_Rectangle_PerCall_PathGradient_Scaled                              , "Kcalls/s"),
    T(3046, 1, Fill_Rectangle_PerPixel_PathGradient_Multicolored                       , "Mpixels/s"),
    T(3047, 1, Fill_Rectangle_PerCall_PathGradient_Multicolored                        , "Kcalls/s"),
    T(3048, 1, Fill_Rectangle_PerPixel_PathGradient_Multicolored_LotsaTriangles        , "Mpixels/s"),
    T(3049, 1, Fill_Rectangle_PathGradient_Multicolored_LotsaTriangles                 , "Kcalls/s"),
    T(3050, 1, Fill_Rectangle_PerPixel_PathGradient_Multicolored_Scaled                , "Mpixels/s"),
    T(3051, 1, Fill_Rectangle_PerCall_PathGradient_Multicolored_Scaled                 , "Kcalls/s"),
    T(3052, 1, Fill_Trapezoid_PerPixel_Texture_Scaled_Opaque_Antialiased               , "Mpixels/s"),
    T(3053, 1, Fill_Trapezoid_PerPixel_Texture_Identity_Opaque_Antialiased             , "Mpixels/s"),
    T(3054, 1, Fill_Rectangle_PerPixel_Solid_Opaque_Antialiased_Integer                , "Mpixels/s"),
    T(3055, 1, Fill_Rectangle_PerPixel_Solid_Opaque_Antialiased_HalfInteger            , "Mpixels/s"),
    T(3056, 1, Fill_Rectangle_PerPixel_Hatch_Transparent                               , "Mpixels/s"),
    T(3057, 1, Fill_Ellipse_PerCall_Big_Solid                                          , "Mpixels/s"),
    T(3058, 1, Fill_Ellipse_PerCall_Small_Solid                                        , "Mpixels/s"),
    T(3059, 1, Fill_Rectangle_PerPixel_Texture_Small                                   , "Mpixels/s"),
    T(3060, 1, Fill_Path_PerCall_Solid_Complex_Aliased                                 , "Kcalls/s"),
    T(3061, 1, Fill_Path_PerCall_Solid_Complex_Antialiased                             , "Kcalls/s"),
    T(3062, 1, Fill_Path_PerCall_Solid_Complex_Antialiased_Transparent                 , "Kcalls/s"),
    T(3063, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Antialiased_Quality                , "Mpixels/s"),
};

INT FillTests_Count = sizeof(FillTests) / sizeof(FillTests[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\perftest\perfreport.cpp ===
/******************************Module*Header*******************************\
* Module Name: perfreport.cpp
*
* Copyright (c) 1991-2000 Microsoft Corporation
*
* Outputs the report file for this platform.
*
\**************************************************************************/

#include "perftest.h"
#include <time.h>

/***************************************************************************\
* GetOutputFileName
*
\***************************************************************************/

VOID GetOutputFileName(TCHAR *fileName)
{
   // Get OS Version Information

   OSVERSIONINFO osVer;
   osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
   GetVersionEx(&osVer);

   switch (osVer.dwPlatformId) 
   {
   case VER_PLATFORM_WIN32_WINDOWS:
      _stprintf(&fileName[0], 
                _T("WIN9X%d.TXT"),
                osVer.dwBuildNumber & 0x0000FFFF);
      break;

   case VER_PLATFORM_WIN32_NT:
      _stprintf(&fileName[0], 
                _T("WINNT%d%02d.TXT"), 
                osVer.dwMajorVersion,
                osVer.dwMinorVersion);
      break;

   default:
      _stprintf(&fileName[0], _T("Unknown.Txt"));
   }
}

/***************************************************************************\
* DetectMMX
*
* Detects whether the processor supports MMX.
*
\***************************************************************************/

BOOL
DetectMMX()
{
    BOOL hasMMX = FALSE;

#if defined(_X86_)
    __try
    {
        __asm emms
        hasMMX = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
#endif

    return hasMMX;
}

/***************************************************************************\
* CreatePerformanceReport
*
* Writes the test results to a file.
*
\***************************************************************************/

VOID CreatePerformanceReport(TestResult* results, BOOL ExcelOut)
{
    TCHAR fileName[MAX_PATH];

    GetOutputFileName(fileName);
   
    OSVERSIONINFO osVer;
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osVer);
    
    FILE* outfile;
    
    outfile = _tfopen(fileName, _T("w"));
    
    if (!outfile) 
    {
       MessageF(_T("Can't create: %s"), &fileName[0]);
       return;
    }
    
    TCHAR timeStr[MAX_PATH];
    time_t ltime;
    struct tm tmtime;
    
    time(&ltime);
    tmtime = *localtime(&ltime);
    _tcsftime(&timeStr[0], MAX_PATH, _T("%B %d, %Y, %I:%M:%S %p"), &tmtime);

    if (ExcelOut) 
        _ftprintf(outfile, _T("GDI+ Performance Report\n")
                        _T("=======================\n")
                        _T("\n")
                        _T("Machine Name:\t%s\n")
                        _T("OS:\t\t%s %d.%02d %c%s%c\n")
                        _T("Processor:\t%s\n")
                        _T("MMX:\t\t%s\n")
                        _T("Video Driver:\t%s\n")
                        _T("Report Date:\t%s\n"),
                          machineName,
                          osVer.dwPlatformId == VER_PLATFORM_WIN32_NT ?
                             _T("Windows NT") : _T("Windows 9x"),
                          osVer.dwMajorVersion,
                          osVer.dwMinorVersion,
                          (osVer.szCSDVersion[0]) ? '[' : ' ',
                          &osVer.szCSDVersion[0],
                          (osVer.szCSDVersion[0]) ? '[' : ' ',
                          processor,
                          DetectMMX()?"Yes":"No",
                          &deviceName[0],
                          &timeStr[0]);
    else
        _ftprintf(outfile, _T("GDI+ Performance Report\n")
                        _T("=======================\n")
                        _T("\n")
                        _T("Machine Name:\t%s\n")
                        _T("OS:\t\t%s %d.%02d %c%s%c\n")
                        _T("Processor:\t%s\n")
                        _T("MMX:\t\t%s\n")
                        _T("Video Driver:\t%s\n")
                        _T("Report Date:\t%s\n"),
                          &machineName[0],
                          osVer.dwPlatformId == VER_PLATFORM_WIN32_NT ?
                             _T("Windows NT") : _T("Windows 9x"),
                          osVer.dwMajorVersion,
                          osVer.dwMinorVersion,
                          (osVer.szCSDVersion[0]) ? '[' : ' ',
                          &osVer.szCSDVersion[0],
                          (osVer.szCSDVersion[0]) ? '[' : ' ',
                          processor,
                          DetectMMX()?"Yes":"No",
                          &deviceName[0],
                          &timeStr[0]);
    
    // Go through the results matrix and output everything:

    for (INT destinationIndex = 0; 
         destinationIndex < Destination_Count; 
         destinationIndex++)
    {
        if (!DestinationList[destinationIndex].Enabled)
            continue;

        _ftprintf(outfile, _T("---------------------------------------------------------------------\n"));

        if (destinationIndex == Destination_Screen_Current)
        {
            HDC hdc = GetDC(NULL);
            _ftprintf(outfile, 
                      _T("\n%s %lix%lix%libpp\n"), 
                      DestinationList[destinationIndex].Description,
                      GetDeviceCaps(hdc, HORZRES),
                      GetDeviceCaps(hdc, VERTRES),
                      GetDeviceCaps(hdc, BITSPIXEL));
            ReleaseDC(NULL, hdc);
        }
        else
        {
            _ftprintf(outfile, _T("\n%s\n"), DestinationList[destinationIndex].Description);
        }

        for (INT stateIndex = 0; 
             stateIndex < State_Count; 
             stateIndex++) 
        {
            if (!StateList[stateIndex].Enabled) 
                continue;

            _ftprintf(outfile, _T("\n%s\n\n"), StateList[stateIndex].Description);
            
            for (INT testIndex = 0; 
                 testIndex < Test_Count; 
                 testIndex++) 
            {
                if (!TestList[testIndex].Enabled) 
                    continue;

                if (ApiList[Api_Gdi].Enabled)
                {
                    _ftprintf(outfile, 
                              _T("%10.03f %10.03f  %2li %3li %s - %s\n"), 
                              results[ResultIndex(destinationIndex, Api_GdiPlus, stateIndex, testIndex)].Score,
                              results[ResultIndex(destinationIndex, Api_Gdi, stateIndex, testIndex)].Score,
                              TestList[testIndex].TestEntry->Priority,
                              TestList[testIndex].TestEntry->UniqueIdentifier,
                              TestList[testIndex].TestEntry->Description,
                              TestList[testIndex].TestEntry->Comment);
                }
                else
                {
                    _ftprintf(outfile, 
                              _T("%10.03f  %2li %3li %s %s\n"),
                              results[ResultIndex(destinationIndex, Api_GdiPlus, stateIndex, testIndex)].Score,
                              TestList[testIndex].TestEntry->Priority,
                              TestList[testIndex].TestEntry->UniqueIdentifier,
                              TestList[testIndex].TestEntry->Description,
                              TestList[testIndex].TestEntry->Comment);
                }
            }
        }
    }

    fclose(outfile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\polytest\debug.h ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   debug.h
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

#if DBG

#define ASSERT(cond) { if (!(cond)) DebugBreak(); }

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define ASSERT(cond)

#endif // !DBG

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\perftest\perftest.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   perftest.cpp
*
* Abstract:
*
*   Contains the UI and initialization code for the GDI+ performance test.
*
* Revision History:
*
*   01/03/2000 ericvan
*       Created it.
*
\**************************************************************************/

#include "perftest.h"
#include <winuser.h>

#include "../gpinit.inc"

///////////////////////////////////////////////////////////////////////////////

// Test settings:

BOOL AutoRun = FALSE;           // TRUE if invoked from command-line
BOOL ExcelOut = FALSE;          // Should we format our output for Excel?
BOOL Regressions = FALSE;       // We're running the check-in regressions
BOOL TestRender = FALSE;        // Only draw one iteration, for test purposes
BOOL Icecap = FALSE;            // Start/stop profiling before and after every test
BOOL FoundIcecap = FALSE;       // True if we could find ICECAP.DLL

// Windows state:

HINSTANCE ghInstance = NULL;    // Handle to the Application Instance
HBRUSH ghbrWhite = NULL;        // white brush handle for background
HWND ghwndMain = NULL;
HWND ghwndStatus = NULL;

// Information about the system:

LPTSTR processor = NULL;
TCHAR osVer[MAX_PATH];
TCHAR deviceName[MAX_PATH];
TCHAR machineName[MAX_PATH];

// Test data:

TestConfig *TestList;       // Allocation used for sorting tests
TestResult *ResultsList;    // Allocation to track test results

Config ApiList[Api_Count] =
{
    { _T("1 - Api - GDI+") },    
    { _T("1 - Api - GDI") }      
}; 

Config DestinationList[Destination_Count] =
{
    { _T("2 - Destination - Screen - Current") },
    { _T("2 - Destination - Screen - 800x600x8bppDefaultPalette") },
    { _T("2 - Destination - Screen - 800x600x8bppHalftonePalette") },
    { _T("2 - Destination - Screen - 800x600x16bpp") },
    { _T("2 - Destination - Screen - 800x600x24bpp") },
    { _T("2 - Destination - Screen - 800x600x32bpp") },
    { _T("2 - Destination - CompatibleBitmap - 8bpp") },
    { _T("2 - Destination - DIB - 15bpp") },
    { _T("2 - Destination - DIB - 16bpp") },
    { _T("2 - Destination - DIB - 24bpp") },
    { _T("2 - Destination - DIB - 32bpp") },
    { _T("2 - Destination - Bitmap - 32bpp ARGB") },
    { _T("2 - Destination - Bitmap - 32bpp PARGB (office cached format)") },
}; 

Config StateList[State_Count] =
{
    { _T("3 - State - Default") },
    { _T("3 - State - Antialias") },
}; 

TestGroup TestGroups[] = 
{
    DrawTests,  DrawTests_Count,
    FillTests,  FillTests_Count,
    ImageTests, ImageTests_Count,
    TextTests,  TextTests_Count,
    OtherTests, OtherTests_Count,
};

INT TestGroups_Count = sizeof(TestGroups) / sizeof(TestGroups[0]);
                        // Number of test groups

INT Test_Count;         // Total number of tests across all groups
 
/***************************************************************************\
* RegressionsInit
*
* Sets the state for running the standard regressions.
*
\***************************************************************************/

void RegressionsInit()
{
    INT i;

    DestinationList[Destination_Screen_Current].Enabled = TRUE;
    DestinationList[Destination_Bitmap_32bpp_ARGB].Enabled = TRUE;

    StateList[State_Default].Enabled = TRUE;

    ApiList[Api_GdiPlus].Enabled = TRUE;
    ApiList[Api_Gdi].Enabled = TRUE;

    for (i = 0; i < Test_Count; i++)
    {
        TestList[i].Enabled = TRUE;
    }
}
 
/***************************************************************************\
* RestoreInit
*
* Load the 'perftest.ini' file to retrieve all the saved test settings.
*
\***************************************************************************/

void RestoreInit()
{
    INT i;
    FILE* outfile;

    outfile = _tfopen(_T("perftest.ini"), _T("r"));
   
    if (!outfile) 
    {
        // may not have been created yet, first run?!

        return;
    }

   _ftscanf(outfile, _T("%d\n"), &ExcelOut);

    INT switchType = -1;
    while (!feof(outfile)) 
    {
        int tmp = -9999;

        _ftscanf(outfile, _T("%d\n"), &tmp);

        // Tags are indicated by negative numbers:

        if (tmp < 0) 
        {
            switchType = tmp;
        }
        else
        {
            // We've figured out the type, now process it:

            switch(switchType)
            {
            case -1: 
                // Tests are indexed by their unique identifier, because 
                // they're added to very frequently:
    
                for (i = 0; i < Test_Count; i++)
                {
                    if (TestList[i].TestEntry->UniqueIdentifier == tmp)
                    {
                        TestList[i].Enabled = TRUE;
                    }
                }
                break;
                
            case -2: 
                if (tmp < Destination_Count)
                    DestinationList[tmp].Enabled = TRUE; 
                break;
    
            case -3: 
                if (tmp < State_Count)
                    StateList[tmp].Enabled = TRUE; 
                break;
    
            case -4: 
                if (tmp < Api_Count)
                    ApiList[tmp].Enabled = TRUE; 
                break;
            }
        }
    }

    fclose(outfile);
}

/***************************************************************************\
* SaveInit
*
* Save all the current test settings into a 'perftest.ini' file.
*
\***************************************************************************/

void SaveInit()
{
   INT i;
   FILE* outfile;

   outfile = _tfopen(_T("perftest.ini"), _T("w"));
   
   if (!outfile) 
   {
      MessageF(_T("Can't create: perftest.ini"));
      return;
   }

   // I purposefully do not save the state of 'Icecap' or 'TestRender'
   // because they're too annoying when on accidentally.

   _ftprintf(outfile, _T("%d\n"), ExcelOut);

   _ftprintf(outfile, _T("-1\n")); // Test List

   for (i=0; i<Test_Count; i++) 
   {
       // Tests are indexed by their unique identifier, because 
       // they're added to very frequently:

       if (TestList[i].Enabled)
           _ftprintf(outfile, _T("%d\n"), TestList[i].TestEntry->UniqueIdentifier);
   }

   _ftprintf(outfile, _T("-2\n")); // Destination List
   
   for (i=0; i<Destination_Count; i++) 
   {
       if (DestinationList[i].Enabled) 
           _ftprintf(outfile, _T("%d\n"), i);
   }
           
   _ftprintf(outfile, _T("-3\n")); // State List
   
   for (i=0; i<State_Count; i++)
   {
       if (StateList[i].Enabled)
           _ftprintf(outfile, _T("%d\n"), i);
   }
   
   _ftprintf(outfile, _T("-4\n")); // Api List

   for (i=0; i<Api_Count; i++) 
   {
       if (ApiList[i].Enabled)
           _ftprintf(outfile, _T("%d\n"), i);
   }

   fclose(outfile);
}

/***************************************************************************\
* CmdArgument
*
* search for string and return just after it.
*
\***************************************************************************/

LPSTR CmdArgument(LPSTR arglist, LPSTR arg)
{
    LPSTR str = strstr(arglist, arg);

    if (str)
        return str + strlen(arg);
    else
        return NULL;
}

/***************************************************************************\
* MessageF
*
* Display a message in a pop-up dialog
*
\***************************************************************************/

VOID
MessageF(
    LPTSTR fmt,
    ...
    )

{
    TCHAR buf[1024];
    va_list arglist;

    va_start(arglist, fmt);
    _vstprintf(buf, fmt, arglist);
    va_end(arglist);

    MessageBox(ghwndMain, &buf[0], _T("PerfTest"), MB_OK | MB_ICONEXCLAMATION);
}

/***************************************************************************\
* UpdateList
*
* Update the active tests according to whatever is enabled in the list-
* boxes.
*
\***************************************************************************/

void
UpdateList(
    HWND hwnd
    )
{
    INT i;

    HWND hwndIcecap = GetDlgItem(hwnd, IDC_ICECAP);
    Icecap= 
      (SendMessage(hwndIcecap, BM_GETCHECK, 0, 0) == BST_CHECKED);
    DeleteObject(hwndIcecap);

    HWND hwndTestRender = GetDlgItem(hwnd, IDC_TESTRENDER);
    TestRender= 
      (SendMessage(hwndTestRender, BM_GETCHECK, 0, 0) == BST_CHECKED);
    DeleteObject(hwndTestRender);

    HWND hwndExcel = GetDlgItem(hwnd, IDC_EXCELOUT);
    ExcelOut= 
      (SendMessage(hwndExcel, BM_GETCHECK, 0, 0) == BST_CHECKED);
    DeleteObject(hwndExcel);
    
    // iterate through test case list and flag enabled/disabled
    
    HWND hwndList = GetDlgItem(hwnd, IDC_TESTLIST);
    
    for (i=0; i<Api_Count; i++)
        ApiList[i].Enabled =
            (SendMessage(hwndList,
                       LB_FINDSTRINGEXACT,
                       -1,
                       (LPARAM) ApiList[i].Description) != LB_ERR);
    
    for (i=0; i<Destination_Count; i++)
        DestinationList[i].Enabled =
            (SendMessage(hwndList,
                       LB_FINDSTRINGEXACT,
                       -1,
                       (LPARAM) DestinationList[i].Description) != LB_ERR);
    
    for (i=0; i<State_Count; i++)
        StateList[i].Enabled =
            (SendMessage(hwndList,
                        LB_FINDSTRINGEXACT,
                        0,
                        (LPARAM) StateList[i].Description) != LB_ERR);
    
    for (i=0; i<Test_Count; i++)
        TestList[i].Enabled =
            (SendMessage(hwndList,
                         LB_FINDSTRINGEXACT,
                         -1,
                         (LPARAM) TestList[i].TestEntry->Description) != LB_ERR);
    
    DeleteObject(hwndList);
}

/***************************************************************************\
* MainWindowProc
*
* Windows call-back procedure.
*
\***************************************************************************/

LRESULT
MainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {
    case WM_CREATE:
        if (Regressions)
            RegressionsInit();
        else
            RestoreInit();
        break;

    case WM_DISPLAYCHANGE:
    case WM_SIZE:
       TCHAR windText[MAX_PATH];

       GetWindowText(ghwndStatus, &windText[0], MAX_PATH);
       DestroyWindow(ghwndStatus);

       ghwndStatus = CreateStatusWindow(WS_CHILD | WS_VISIBLE,
                                _T("Performance Test Application"),
                                ghwndMain,
                                -1);
       SetWindowText(ghwndStatus, &windText[0]);
       break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {

        case IDM_QUIT:
            if (!Regressions)
            {
                UpdateList(hwnd);
                SaveInit();
            }

            exit(0);
            break;

        default:
            MessageBox(hwnd,
                       _T("Help Me - I've Fallen and Can't Get Up!"), 
                       _T("Help!"),
                       MB_OK);
            break;
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        DeleteObject(ghbrWhite);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/***************************************************************************\
* GetSystemInformation
*
* Initializes some globals describing the current system.
*
\***************************************************************************/

void
GetSystemInformation()
{
    // Getting machine name assumes we have TCP/IP setup.  However, this
    // is true in all of our cases.

    LPCTSTR TCPIP_PARAMS_KEY = 
       _T("System\\CurrentControlSet\\Services\\Tcpip\\Parameters");
    DWORD size;
    HKEY hKeyHostname;
    DWORD type;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                     TCPIP_PARAMS_KEY, 
                     0, 
                     KEY_READ, 
                     &hKeyHostname) == ERROR_SUCCESS)
    {
        size = sizeof(machineName);

        if (RegQueryValueEx(hKeyHostname,
                        _T("Hostname"),
                        NULL,
                        (LPDWORD)&type,
                        (LPBYTE)&machineName[0], 
                        (LPDWORD)&size) == ERROR_SUCCESS)
        {
            if (type != REG_SZ) 
            {
                lstrcpy(&machineName[0], _T("Unknown"));
            }
        }

        RegCloseKey(hKeyHostname);
    }

    OSVERSIONINFO osver;
    osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osver);
    _stprintf(&osVer[0], _T("%s %d.%02d"),
                   osver.dwPlatformId == VER_PLATFORM_WIN32_NT ?
                   _T("Windows NT") : _T("Windows 9x"),
                   osver.dwMajorVersion,
                   osver.dwMinorVersion);

    SYSTEM_INFO sysinfo;
    GetSystemInfo(&sysinfo);
    if (osver.dwPlatformId = VER_PLATFORM_WIN32_NT) 
    {
        // we are assuming wProcessorArchitecture==PROCESSOR_ARCHITECTURE_INTEL

        // WinNT processor

        switch (sysinfo.wProcessorLevel)
        {
        case 3: processor = _T("Intel 80386"); break;
        case 4: processor = _T("Intel 80486"); break;
        case 5: processor = _T("Intel Pentium"); break;
        case 6: processor = _T("Intel Pentium Pro or Pentium II"); break;
        default: processor = _T("???"); break;
        }
    }
    else    // win 9x
    {
        switch (sysinfo.dwProcessorType) 
        {
        case PROCESSOR_INTEL_386: processor = _T("Intel 80386"); break;
        case PROCESSOR_INTEL_486: processor = _T("Intel 80486"); break;
        case PROCESSOR_INTEL_PENTIUM: processor = _T("Intel Pentium"); break;
        default: processor = _T("???");
        }
    }
    // Query the driver name:

    DEVMODE devMode;
    devMode.dmSize = sizeof(DEVMODE);
    devMode.dmDriverExtra = 0;

    INT result = EnumDisplaySettings(NULL, ENUM_CURRENT_SETTINGS, &devMode);

    _tcscpy(deviceName, (result) ? (TCHAR*) &devMode.dmDeviceName[0] : _T("Unknown"));
}

INT CurrentTestIndex;
CHAR CurrentTestDescription[2048];

ICCONTROLPROFILEFUNC ICStartProfile=NULL, ICStopProfile=NULL;
ICCOMMENTMARKPROFILEFUNC ICCommentMarkProfile=NULL;

/***************************************************************************\
* LoadIcecap
*
* Try to dynamically load ICECAP.DLL
* If we fail, disable the check box
*
\***************************************************************************/

void LoadIcecap(HWND checkBox)
{
    if (!FoundIcecap)
    {
        HMODULE module = LoadLibraryA("icecap.dll");
        
        if (module)
        {
            ICStartProfile = (ICCONTROLPROFILEFUNC) GetProcAddress(module, "StartProfile");
            ICStopProfile = (ICCONTROLPROFILEFUNC) GetProcAddress(module, "StopProfile");
            ICCommentMarkProfile = (ICCOMMENTMARKPROFILEFUNC) GetProcAddress(module, "CommentMarkProfile");
            
            if (ICStartProfile && ICStopProfile && ICCommentMarkProfile)
            {
                EnableWindow(checkBox, TRUE);
                FoundIcecap = TRUE;
                return;
            }
        }
        
        EnableWindow(checkBox, FALSE);
        Icecap = FALSE;
    }
}

/***************************************************************************\
* DialogProc
*
* Dialog call-back procedure.
*
\***************************************************************************/

INT_PTR
DialogProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {

    case WM_INITDIALOG:
    {
       {
         INT i;
         HWND hwndTemp;
         HWND hwndTemp2;
         TCHAR fileName[MAX_PATH];

         hwndTemp = GetDlgItem(hwnd, IDC_PROCESSOR);
         SetWindowText(hwndTemp, processor);
         DeleteObject(hwndTemp);


         hwndTemp = GetDlgItem(hwnd, IDC_FILE);

         GetOutputFileName(fileName);
         SetWindowText(hwndTemp, fileName);
         DeleteObject(hwndTemp);

         hwndTemp = GetDlgItem(hwnd, IDC_OS);
         SetWindowText(hwndTemp, &osVer[0]);
         DeleteObject(hwndTemp);

         hwndTemp = GetDlgItem(hwnd, IDC_VDRIVER);
         SetWindowText(hwndTemp, deviceName);
         DeleteObject(hwndTemp);

         hwndTemp = GetDlgItem(hwnd, IDC_ICECAP);
         LoadIcecap(hwndTemp);
         SendMessage(hwndTemp, BM_SETCHECK, (WPARAM) (Icecap ?
                                                      BST_CHECKED :
                                                      BST_UNCHECKED), 0);
         DeleteObject(hwndTemp);

         hwndTemp = GetDlgItem(hwnd, IDC_TESTRENDER);
         SendMessage(hwndTemp, BM_SETCHECK, (WPARAM) (TestRender ?
                                                      BST_CHECKED :
                                                      BST_UNCHECKED), 0);
         DeleteObject(hwndTemp);

         hwndTemp = GetDlgItem(hwnd, IDC_EXCELOUT);
         SendMessage(hwndTemp, BM_SETCHECK, (WPARAM) (ExcelOut ?
                                                      BST_CHECKED :
                                                      BST_UNCHECKED), 0);
         DeleteObject(hwndTemp);
           
         // populate the perf test scenarios
         
         hwndTemp = GetDlgItem(hwnd, IDC_TESTLIST);
         hwndTemp2 = GetDlgItem(hwnd, IDC_SKIPLIST);

         for (i=0; i<Api_Count; i++)
         {
             if (ApiList[i].Description)
             {
                SendMessage(ApiList[i].Enabled ? hwndTemp : hwndTemp2, 
                            LB_ADDSTRING, 
                            0, 
                            (LPARAM) ApiList[i].Description);
             }
         }

         for (i=0; i<Destination_Count; i++)
         {
             if (DestinationList[i].Description)
             {
                SendMessage(DestinationList[i].Enabled ? hwndTemp : hwndTemp2, 
                            LB_ADDSTRING, 
                            0, 
                            (LPARAM) DestinationList[i].Description);
             }
         }
         
         for (i=0; i<State_Count; i++)
         {
             if (StateList[i].Description)
             {
                SendMessage(StateList[i].Enabled ? hwndTemp : hwndTemp2,
                            LB_ADDSTRING,
                            0,
                            (LPARAM) StateList[i].Description);
             }
         }
         
         for (i=0; i<Test_Count; i++)
         {
             if (TestList[i].TestEntry->Description)
             {
                SendMessage(TestList[i].Enabled ? hwndTemp : hwndTemp2,
                            LB_ADDSTRING,
                            0,
                            (LPARAM) TestList[i].TestEntry->Description);
             }
         }
         
         DeleteObject(hwndTemp);

         return FALSE;
       }
    }
    break;

    case WM_COMMAND:
        WORD wCommand = LOWORD(wParam);
        switch(wCommand)
        {
            case IDOK:
            {
               UpdateList(hwnd);
    
               ShowWindow(hwnd, SW_HIDE);
    
               // start running the tests
    
               {
                  TestSuite testSuite;
                  testSuite.Run(ghwndMain);
               }
    
               ShowWindow(hwnd, SW_SHOW);
               
               return TRUE;
            }
        break;
           
        case IDC_ADDTEST:
           {
              TCHAR temp[MAX_PATH];
              HWND hwndTestList = GetDlgItem(hwnd, IDC_TESTLIST);
              HWND hwndNopeList = GetDlgItem(hwnd, IDC_SKIPLIST);

              LRESULT curSel = SendMessage(hwndNopeList, LB_GETCURSEL, 0, 0);
              if (curSel != LB_ERR) 
              {
                 SendMessage(hwndNopeList, 
                             LB_GETTEXT, 
                             (WPARAM) curSel, 
                             (LPARAM) &temp[0]);

                 SendMessage(hwndNopeList,
                             LB_DELETESTRING,
                             (WPARAM) curSel,
                             0);

                 SendMessage(hwndTestList,
                             LB_ADDSTRING,
                             0,
                             (LPARAM) &temp[0]);
              }

              DeleteObject(hwndTestList);
              DeleteObject(hwndNopeList);
           }
           break;

        case IDC_DELTEST:
           {
              TCHAR temp[MAX_PATH];
              HWND hwndTestList = GetDlgItem(hwnd, IDC_TESTLIST);
              HWND hwndNopeList = GetDlgItem(hwnd, IDC_SKIPLIST);

              LRESULT curSel = SendMessage(hwndTestList, LB_GETCURSEL, 0, 0);
              if (curSel != LB_ERR) 
              {
                 SendMessage(hwndTestList, 
                             LB_GETTEXT, 
                             (WPARAM) curSel, 
                             (LPARAM) &temp[0]);

                 SendMessage(hwndTestList,
                             LB_DELETESTRING,
                             (WPARAM) curSel,
                             0);

                 SendMessage(hwndNopeList,
                             LB_ADDSTRING,
                             0,
                             (LPARAM) &temp[0]);
              }

              DeleteObject(hwndTestList);
              DeleteObject(hwndNopeList);
           }
           break;

        case IDC_DELALLTEST:
        case IDC_ADDALLTEST:
           {
               TCHAR temp[MAX_PATH];
               HWND hwndTestList;
               HWND hwndNopeList;

               if (wCommand == IDC_DELALLTEST)
               {
                   hwndTestList = GetDlgItem(hwnd, IDC_TESTLIST);
                   hwndNopeList = GetDlgItem(hwnd, IDC_SKIPLIST);
               }
               else
               {
                   hwndTestList = GetDlgItem(hwnd, IDC_SKIPLIST);
                   hwndNopeList = GetDlgItem(hwnd, IDC_TESTLIST);
               }

               LRESULT count = SendMessage(hwndTestList, LB_GETCOUNT, 0, 0);
               LRESULT curSel;

               for (curSel = count - 1; curSel >= 0; curSel--)
               {
                  SendMessage(hwndTestList, 
                              LB_GETTEXT, 
                              (WPARAM) curSel, 
                              (LPARAM) &temp[0]);

                  SendMessage(hwndTestList,
                              LB_DELETESTRING,
                              (WPARAM) curSel,
                              0);

                  SendMessage(hwndNopeList,
                              LB_ADDSTRING,
                              0,
                              (LPARAM) &temp[0]);
               }

               DeleteObject(hwndTestList);
               DeleteObject(hwndNopeList);
            }
            break;
        
        case IDCANCEL:
           if (!Regressions)
           {
               UpdateList(hwnd);
               SaveInit();
           }

           exit(-1);
           return TRUE;

        case WM_CLOSE:
           if (!Regressions)
           {
               UpdateList(hwnd);
               SaveInit();
           }

           DestroyWindow(hwnd);
           return TRUE;

        }
        break;
    }

    return FALSE;
}

/***************************************************************************\
* TestComparison
*
* Comparitor function for sorting the tests by Description.
*
\***************************************************************************/

int _cdecl TestComparison(const void *a, const void *b)
{
    const TestConfig* testA = static_cast<const TestConfig*>(a);
    const TestConfig* testB = static_cast<const TestConfig*>(b);

    return(_tcscmp(testA->TestEntry->Description, testB->TestEntry->Description));
}

/***************************************************************************\
* InitializeTests()
*
* Initializes test state.
*
\***************************************************************************/

BOOL InitializeTests()
{
    INT i;
    INT j;
    TestConfig* testList;

    // Count the total number of tests:

    Test_Count = 0;
    for (i = 0; i < TestGroups_Count; i++)
    {
        Test_Count += TestGroups[i].Count;
    }

    // Create one tracking array:

    TestList = static_cast<TestConfig*>
                                (malloc(sizeof(TestConfig) * Test_Count));
    if (TestList == NULL)
        return(FALSE);

    // Initialize the tracking array and sort it by description:

    testList = TestList;
    for (i = 0; i < TestGroups_Count; i++)
    {
        for (j = 0; j < TestGroups[i].Count; j++)
        {
            testList->Enabled = FALSE;
            testList->TestEntry = &TestGroups[i].Tests[j];
            testList++;
        }
    }

    qsort(TestList, Test_Count, sizeof(TestList[0]), TestComparison);

    // Now do some validation, by verifying that there is no repeated
    // uniqueness number:

    for (i = 0; i < Test_Count; i++)
    {
        for (j = i + 1; j < Test_Count; j++)
        {
            if (TestList[i].TestEntry->UniqueIdentifier == 
                TestList[j].TestEntry->UniqueIdentifier)
            {
                MessageF(_T("Oops, there are two test functions with the same unique identifier: %li.  Please fix."),
                         TestList[i].TestEntry->UniqueIdentifier);

                return(FALSE);
            }
        }
    }

    // Allocate our 3 dimensional results array:

    ResultsList = static_cast<TestResult*>
                    (malloc(sizeof(TestResult) * ResultCount()));
    if (ResultsList == NULL)
        return(FALSE);

    for (i = 0; i < ResultCount(); i++)
    {
        ResultsList[i].Score = 0.0f;
    }

    return(TRUE);
}

/***************************************************************************\
* UninitializeTests()
*
* Initializes tests.
*
\***************************************************************************/

VOID UninitializeTests()
{
    free(ResultsList);
    free(TestList);
}

/***************************************************************************\
* InitializeApplication()
*
* Initializes app.
*
\***************************************************************************/

BOOL InitializeApplication(VOID)
{
    WNDCLASS wc;

    if (!InitializeTests())
    {
        return(FALSE);
    }

    GetSystemInformation();

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));
    
    wc.style            = 0;
    wc.lpfnWndProc      = MainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = NULL;        
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = NULL;        
    wc.lpszClassName    = _T("TestClass");

    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }

    ghwndMain = CreateWindowEx(
        0,
        _T("TestClass"),
        _T("GDI+ Performance Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_VISIBLE      |  
        WS_MAXIMIZE     |
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL);

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }

    SetFocus(ghwndMain);

    ghwndStatus = CreateStatusWindow(WS_CHILD|WS_VISIBLE,
                                    _T("Performance Test Application"),
                                    ghwndMain,
                                    -1);
    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[]
    )
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
    
    INT curarg = 1;
    while (curarg < argc) 
    {
        if (CmdArgument(argv[curarg],"/?") || 
            CmdArgument(argv[curarg],"/h") ||
            CmdArgument(argv[curarg],"/H")) 
        {
       
            MessageF(_T("GDI+ Perf Test\n")
                    _T("==============\n")
                    _T("\n")
                    _T("/b    Run batch mode\n")
                    _T("/e    Excel output format\n")
                    _T("/r    Regressions\n"));

            exit(-1);
        }

        if (CmdArgument(argv[curarg],"/b"))
            AutoRun = TRUE;
    
        if (CmdArgument(argv[curarg],"/e"))
            ExcelOut = TRUE;

        if (CmdArgument(argv[curarg],"/r"))
            Regressions = TRUE;
    
        curarg++;
    }

    ghInstance = GetModuleHandle(NULL);

    if (!InitializeApplication())
    {
        return(0);
    }

    // turn batching off to get true timing per call

    GdiSetBatchLimit(1);

    if (AutoRun) 
    {
        // start running the tests
           
        TestSuite testSuite;
        testSuite.Run(ghwndMain);
    }
    else
    {
        HWND hwndDlg = CreateDialog(ghInstance,
                                    MAKEINTRESOURCE(IDD_STARTDIALOG),
                                    ghwndMain,
                                    &DialogProc);
        while (GetMessage(&msg, NULL, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    UninitializeTests();

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\perftest\perfsuite.cpp ===
/******************************Module*Header*******************************\
* Module Name: perfsuite.cpp
*
* Copyright (c) 1991-1999 Microsoft Corporation
*
* Contains the test prototypes and includes
*
\**************************************************************************/

#include "perftest.h"
#include <winuser.h>

/***************************************************************************\
* TestSuite::TestSuite
*
\***************************************************************************/

TestSuite::TestSuite()
{
}

/***************************************************************************\
* TestSuite::~TestSuite
*
\***************************************************************************/

TestSuite::~TestSuite()
{
}

/***************************************************************************\
* TestSuite::InitializeDestination
*
* Create the destination to be used by the tests.  Could be a particular
* format for the screen, a bitmap, or a DIB.
*
* Returns:
*
*   *bitmapResult - if a GDI+ Bitmap is to be used (use g.GetHDC() to draw
*                   to via GDI)
*   *hbitmapResult - if a GDI bitmap is to be used (use Graphics(hdc) to
*                   draw to via GDI+)
*   both NULL - if the screen is to be used
*
\***************************************************************************/

BOOL 
TestSuite::InitializeDestination(
    DestinationType destinationIndex,
    Bitmap **bitmapResult,
    HBITMAP *hbitmapResult
    )
{
    Graphics *g = NULL;
    HDC hdc = 0;
    INT screenDepth = 0;
    PixelFormat bitmapFormat = PixelFormatMax;
    ULONG *bitfields;
    Bitmap *bitmap;
    HBITMAP hbitmap;

    union 
    {
        BITMAPINFO bitmapInfo;
        BYTE padding[sizeof(BITMAPINFO) + 3*sizeof(RGBQUAD)];
    };

    // Clear all state remembered or returned:

    ModeSet = FALSE;
    
    bitmap = NULL;
    hbitmap = NULL;

    HalftonePalette = NULL;
    
    // Initialize our DIB format in case we use it:

    RtlZeroMemory(&bitmapInfo, sizeof(bitmapInfo));

    bitmapInfo.bmiHeader.biSize   = sizeof(BITMAPINFOHEADER);
    bitmapInfo.bmiHeader.biWidth  = TestWidth;
    bitmapInfo.bmiHeader.biHeight = TestHeight;
    bitmapInfo.bmiHeader.biPlanes = 1;
    bitfields = reinterpret_cast<ULONG*>(&bitmapInfo.bmiColors[0]);

    // First handle any destinations that need to change the color depth:

    switch (destinationIndex)
    {
    case Destination_Screen_Current:
        break;
    
    case Destination_Screen_800_600_8bpp_HalftonePalette:
        HalftonePalette = DllExports::GdipCreateHalftonePalette();
        if (!HalftonePalette)
        {
            return FALSE;
        }
        screenDepth = 8;
        break;
    
    case Destination_Screen_800_600_8bpp_DefaultPalette:
        screenDepth = 8;
        break;

    case Destination_Screen_800_600_16bpp:
        screenDepth = 16;
        break;

    case Destination_Screen_800_600_24bpp:
        screenDepth = 24;
        break;

    case Destination_Screen_800_600_32bpp:
        screenDepth = 32;
        break;

    case Destination_CompatibleBitmap_8bpp:

        // We want to emulate a compatible bitmap at 8bpp.  Because of palette
        // issues, we really have to switch to 8bpp mode to do that.

        screenDepth = 8;
        break;

    case Destination_DIB_15bpp:
        bitmapInfo.bmiHeader.biBitCount    = 16;
        bitmapInfo.bmiHeader.biCompression = BI_BITFIELDS;
        bitfields[0]                       = 0x7c00;
        bitfields[1]                       = 0x03e0;
        bitfields[2]                       = 0x001f;
        break;

    case Destination_DIB_16bpp:
        bitmapInfo.bmiHeader.biBitCount    = 16;
        bitmapInfo.bmiHeader.biCompression = BI_BITFIELDS;
        bitfields[0]                       = 0xf800;
        bitfields[1]                       = 0x07e0;
        bitfields[2]                       = 0x001f;
        break;

    case Destination_DIB_24bpp:
        bitmapInfo.bmiHeader.biBitCount    = 24;
        bitmapInfo.bmiHeader.biCompression = BI_RGB;
        break;

    case Destination_DIB_32bpp:
        bitmapInfo.bmiHeader.biBitCount    = 32;
        bitmapInfo.bmiHeader.biCompression = BI_RGB;
        break;

    case Destination_Bitmap_32bpp_ARGB:
        bitmapFormat = PixelFormat32bppARGB;
        break;
    
    case Destination_Bitmap_32bpp_PARGB:
        bitmapFormat = PixelFormat32bppPARGB;
        break;
        
    default:
        return FALSE;
    }

    // Now that we've figured out what to do, actually create our stuff:

    if (bitmapInfo.bmiHeader.biBitCount != 0)
    {
        // It's a DIB:

        VOID* drawBits;
        HDC hdcScreen = GetDC(NULL);
        hbitmap = CreateDIBSection(hdcScreen,
                                   &bitmapInfo,
                                   DIB_RGB_COLORS,
                                   (VOID**) &drawBits,
                                   NULL,
                                   0);
        ReleaseDC(NULL, hdcScreen);

        if (!hbitmap)
            return(FALSE);
    }
    else if (bitmapFormat != PixelFormatMax)
    {
        // It's a Bitmap:

        bitmap = new Bitmap(TestWidth, TestHeight, bitmapFormat);
        if (!bitmap)
            return(FALSE);
    }
    else
    {
        // It's to the screen (or a weird 8bpp compatible bitmap):
    
        if (screenDepth != 0)
        {
            // We have to do a mode change:

            DEVMODE devMode;
    
            devMode.dmSize       = sizeof(DEVMODE);
            devMode.dmBitsPerPel = screenDepth;
            devMode.dmPelsWidth  = TestWidth;
            devMode.dmPelsHeight = TestHeight;
            devMode.dmFields     = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
    
            // Note that we invoke CDS_FULLSCREEN to tell the system that
            // the mode change is temporary (and so that User won't resize
            // all the windows on the desktop):
    
            if (ChangeDisplaySettings(&devMode, CDS_FULLSCREEN) 
                    != DISP_CHANGE_SUCCESSFUL)
            {
                return(FALSE);
            }

            // Remember that the mode was set:

            ModeSet = TRUE;
            
            // Wait several seconds to allow other OS threads to page in and
            // repaint the task bar, etc.  We don't want that polluting our 
            // perf numbers.
     
            Sleep(5000);
        }
        
        // Handle that 8bpp comaptible bitmap special case:
        
        if (destinationIndex == Destination_CompatibleBitmap_8bpp)
        {
            HDC hdcScreen = GetDC(NULL);
            hbitmap = CreateCompatibleBitmap(hdcScreen, TestWidth, TestHeight);
            ReleaseDC(NULL, hdcScreen);

            if (!hbitmap)
                return(FALSE);
        }
    }

    *hbitmapResult = hbitmap;
    *bitmapResult = bitmap;

    return(TRUE);
}

/***************************************************************************\
* TestSuite::UninitializeDestination
*
\***************************************************************************/

VOID
TestSuite::UninitializeDestination(
    DestinationType destinationIndex,
    Bitmap *bitmap,
    HBITMAP hbitmap
    )
{
    if (ModeSet)
    {
        ChangeDisplaySettings(NULL, 0);
    }
    
    if (HalftonePalette)
    {
        DeleteObject(HalftonePalette);
    }

    DeleteObject(hbitmap);
    delete bitmap;
}

/***************************************************************************\
* TestSuite::InitializeApi
*
* If 'Api_GdiPlus', returns a 'Graphics*' that can be used to render to
* the specified surface.
*
* If 'Api_Gdi', returns an 'HDC' that can be use to render to the specified
* surface.
*
* The surface is tried in the following order:
*
*   1. Bitmap* (if non-NULL)
*   2. HBITMAP (if non-NULL)
*   3. HWND
*
\***************************************************************************/

BOOL
TestSuite::InitializeApi(
    ApiType apiIndex,
    Bitmap *bitmap,
    HBITMAP hbitmap,
    HWND hwnd,
    Graphics **gResult,
    HDC *hdcResult)
{
    Graphics *g = NULL;
    HDC hdc = NULL;

    OldPalette = NULL;
    
    if (bitmap != NULL)
    {
        g = new Graphics(bitmap);
        if (!g)
            return(FALSE);

        if (apiIndex == Api_Gdi)
        {
            hdc = g->GetHDC();
            if (!hdc)
            {
                delete g;
                return(FALSE);
            }
        }
    }
    else if (hbitmap != NULL)
    {
        HDC hdcScreen = GetDC(hwnd);
        hdc = CreateCompatibleDC(hdcScreen);
        SelectObject(hdc, hbitmap);
        ReleaseDC(hwnd, hdcScreen);

        if (apiIndex == Api_GdiPlus)
        {
            g = new Graphics(hdc);
            if (!g)
            {
                DeleteObject(hdc);
                return(FALSE);
            }
        }
    }
    else
    {
        
        hdc = GetDC(hwnd);
        if (!hdc)
            return(FALSE);

        if (HalftonePalette)
        {
            OldPalette = SelectPalette(hdc, HalftonePalette, FALSE);
            RealizePalette(hdc);   
        }
        
        if (apiIndex == Api_GdiPlus)
        {
            g = new Graphics(hdc);
            if (!g)
                return(FALSE);
        }
    }

    *gResult = g;
    *hdcResult = hdc;

    return(TRUE);
}

/***************************************************************************\
* TestSuite::UninitializeApi
*
\***************************************************************************/

VOID
TestSuite::UninitializeApi(
    ApiType apiIndex,
    Bitmap *bitmap,
    HBITMAP hbitmap,
    HWND hwnd,
    Graphics *g,
    HDC hdc)
{
    if (bitmap != NULL)
    {
        if (apiIndex == Api_Gdi)
            g->ReleaseHDC(hdc);

        delete g;
    }
    else if (hbitmap != NULL)
    {
        if (apiIndex == Api_GdiPlus)
            delete g;

        DeleteObject(hdc);
    }
    else
    {
        if (apiIndex == Api_GdiPlus)
            delete g;
        
        if (OldPalette)
        {
            SelectPalette(hdc, OldPalette, FALSE);
            OldPalette = NULL;
        }
        
        ReleaseDC(hwnd, hdc);
    }
}

/***************************************************************************\
* TestSuite::InitializeState
*
\***************************************************************************/

BOOL
TestSuite::InitializeState(
    ApiType apiIndex,
    StateType stateIndex,
    Graphics *g,
    HDC hdc)
{
    if (apiIndex == Api_GdiPlus)
    {
        SavedState = g->Save();
        if (!SavedState)
            return(FALSE);

        switch (stateIndex)
        {
        case State_Antialias:
            g->SetSmoothingMode(SmoothingModeAntiAlias);
            g->SetTextRenderingHint(TextRenderingHintAntiAlias); 
            break;
        }
    }
    else
    {
        // Do stuff to 'hdc'
    }

    return(TRUE);
}

/***************************************************************************\
* TestSuite::UninitializeState
*
\***************************************************************************/

VOID
TestSuite::UninitializeState(
    ApiType apiIndex,
    StateType stateIndex,
    Graphics *g,
    HDC hdc)
{
    if (apiIndex == Api_GdiPlus)
    {
        g->Restore(SavedState);
    }
    else
    {
        // Do stuff to 'hdc'
    }
}

/***************************************************************************\
* TestSuite::Run
*
\***************************************************************************/

void TestSuite::Run(HWND hwnd)
{
    INT i;
    Graphics *g;
    HDC hdc;
    INT destinationIndex;
    INT apiIndex;
    INT stateIndex;
    INT testIndex;
    TCHAR string[2048];
    Bitmap *bitmap;
    HBITMAP hbitmap;
    
    CurrentTestIndex=0;

    // Maximize the window:

    ShowWindow(hwnd, SW_MAXIMIZE);

    // Zero out the results matrix

    for (i = 0; i < ResultCount(); i++)
    {
        ResultsList[i].Score = 0;
    }

    // Go through the matrix of tests to find stuff to run

    for (destinationIndex = 0;
         destinationIndex < Destination_Count; 
         destinationIndex++)
    {
        if (!DestinationList[destinationIndex].Enabled)
            continue;

        if (!InitializeDestination((DestinationType) destinationIndex, &bitmap, &hbitmap))
            continue;

        for (apiIndex = 0;
             apiIndex < Api_Count;
             apiIndex++)
        {
            if (!ApiList[apiIndex].Enabled)
                continue;

            if (!InitializeApi((ApiType) apiIndex, bitmap, hbitmap, hwnd, &g, &hdc))
                continue;

            for (stateIndex = 0;
                 stateIndex < State_Count;
                 stateIndex++)
            {
                if (!StateList[stateIndex].Enabled)
                    continue;

                if (!InitializeState((ApiType) apiIndex, (StateType) stateIndex, g, hdc))
                    continue;
    
                for (testIndex = 0;
                     testIndex < Test_Count;
                     testIndex++)
                {
                    if (!TestList[testIndex].Enabled)
                        continue;
    
                    _stprintf(string, 
                              _T("[%s] [%s] [%s] [%s]"),
                              ApiList[apiIndex].Description,
                              DestinationList[destinationIndex].Description,
                              StateList[stateIndex].Description,
                              TestList[testIndex].TestEntry->Description);

                    SetWindowText(hwnd, string); 
                    
                    if (Icecap && FoundIcecap)
                    {
                        // Save the test information so that we can
                        // add it to the profile
                        
                        CurrentTestIndex++;

                        #if UNICODE
                            
                            WideCharToMultiByte(
                                CP_ACP,
                                0,
                                string,
                                -1,
                                CurrentTestDescription,
                                2048,
                                NULL,
                                NULL);

                        #else
                        
                            strncpy(CurrentTestDescription, string, 2048);

                        #endif
                    }

                    // Woo hoo, everything is now set up and we're ready
                    // to run a test!

                    if (apiIndex == Api_GdiPlus)
                    {
                        GraphicsState oldState = g->Save();

                        ResultsList[ResultIndex(destinationIndex, 
                                                apiIndex, 
                                                stateIndex, 
                                                testIndex)].Score
                            = TestList[testIndex].TestEntry->Function(g, NULL);

                        g->Restore(oldState);
                    }
                    else
                    {
                        SaveDC(hdc);

                        ResultsList[ResultIndex(destinationIndex, 
                                                apiIndex, 
                                                stateIndex, 
                                                testIndex)].Score
                            = TestList[testIndex].TestEntry->Function(NULL, hdc);

                        RestoreDC(hdc, -1);
                    }

                    // Copy the result to the screen if it was from a bitmap:

                    if (bitmap)
                    {
                        Graphics gScreen(hwnd);
                        gScreen.DrawImage(bitmap, 0, 0);
                    }
                    else if (hbitmap)
                    {
                        // This will use the source 'hdc', which may have a
                        // transform set on it.  Oh well!

                        HDC hdcScreen = GetDC(hwnd);
                        BitBlt(hdcScreen, 0, 0, TestWidth, TestHeight, hdc, 0, 0, SRCCOPY);
                        ReleaseDC(hwnd, hdcScreen);
                    }
                }

                UninitializeState((ApiType) apiIndex, (StateType) stateIndex, g, hdc);
            }

            UninitializeApi((ApiType) apiIndex, bitmap, hbitmap, hwnd, g, hdc);
        }

        UninitializeDestination((DestinationType) destinationIndex, bitmap, hbitmap);
    }

    // We're done!

    CreatePerformanceReport(ResultsList, ExcelOut);
}

/******************************Public*Routine******************************\
* bFillBitmapInfo
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of the display.
*
* This is done by creating a compatible bitmap and calling GetDIBits
* to return the color masks.  This is done with two calls.  The first
* call passes in biBitCount = 0 to GetDIBits which will fill in the
* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
* in the BITMAPINFO filled in by the first call) will return the color
* table or bitmasks, as appropriate.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*
*  20-Jan-2000 [gilmanw]
* Removed code to set color table for 8bpp and less DIBs since calling
* code will not create such DIBs.
*
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillBitmapInfo(HDC hdc, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    //
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.
    //

    if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //

        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if ( pbmi->bmiHeader.biCompression == BI_BITFIELDS )
        {
            //
            // Call a second time to get the color masks.
            // It's a GetDIBits Win32 "feature".
            //

            GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                      DIB_RGB_COLORS);
        }

        bRet = TRUE;

        DeleteObject(hbm);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* CreateCompatibleDIB2
*
* Create a DIB section with a optimal format w.r.t. the specified device.
*
* Parameters
*
*     hdc
*
*         Specifies display DC used to determine format.  Must be a direct DC
*         (not an info or memory DC).
*
*     width
*
*         Specifies the width of the bitmap.
*
*     height
*
*         Specifies the height of the bitmap.
*
* Return Value
*
*     The return value is the handle to the bitmap created.  If the function
*     fails, the return value is NULL.
*
* Comments
*
*     For devices that are <= 8bpp, a normal compatible bitmap is
*     created (i.e., CreateCompatibleBitmap is called).  I have a
*     different version of this function that will create <= 8bpp
*     DIBs.  However, DIBs have the property that their color table
*     has precedence over the palette selected into the DC whereas
*     a bitmap from CreateCompatibleBitmap uses the palette selected
*     into the DC.  Therefore, in the interests of keeping this
*     version as close to CreateCompatibleBitmap as possible, I'll
*     revert to CreateCompatibleBitmap for 8bpp or less.
*
* History:
*  19-Jan-2000 [gilmanw]
* Adapted original "fastdib" version for maximum compatibility with
* CreateCompatibleBitmap.
*
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HBITMAP 
CreateCompatibleDIB2(HDC hdc, int width, int height)
{
    HBITMAP hbmRet = (HBITMAP) NULL;
    BYTE aj[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) aj;

    //
    // Redirect 8 bpp or lower to CreateCompatibleBitmap.
    //

    if ( (GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES)) <= 8 )
    {
        return CreateCompatibleBitmap(hdc, width, height);
    }

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        return hbmRet;
    }

    memset(aj, 0, sizeof(aj));
    if ( bFillBitmapInfo(hdc, pbmi) )
    {
        VOID *pvBits;

        //
        // Change bitmap size to match specified dimensions.
        //

        pbmi->bmiHeader.biWidth = width;
        pbmi->bmiHeader.biHeight = height;
        if (pbmi->bmiHeader.biCompression == BI_RGB)
        {
            pbmi->bmiHeader.biSizeImage = 0;
        }
        else
        {
            if ( pbmi->bmiHeader.biBitCount == 16 )
                pbmi->bmiHeader.biSizeImage = width * height * 2;
            else if ( pbmi->bmiHeader.biBitCount == 32 )
                pbmi->bmiHeader.biSizeImage = width * height * 4;
            else
                pbmi->bmiHeader.biSizeImage = 0;
        }
        pbmi->bmiHeader.biClrUsed = 0;
        pbmi->bmiHeader.biClrImportant = 0;

        //
        // Create the DIB section.  Let Win32 allocate the memory and return
        // a pointer to the bitmap surface.
        //

        hbmRet = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, &pvBits, NULL, 0);
    }

    return hbmRet;
}

////////////////////////////////////////////////////////////////////////
//
// Timer Utility Functions
//
////////////////////////////////////////////////////////////////////////

LONGLONG StartCounter;      // Timer global, to be set by StartTimer()

LONGLONG MinimumCount;      // Minimum number of performance counter ticks
                            //   that must elapse before a test is considered
                            //   'done'
                            
LONGLONG CountsPerSecond;   // Frequency of the performance counter

UINT Iterations;            // Timer global, to be set by StartTimer() and
                            //   incremented for every call to EndTimer()

UINT MinIterations;         // Minimum number of iterations of the test to
                            //   be done

/***************************************************************************\
* StartTimer
*
* Called by timing routine to start the timer.
*
\***************************************************************************/

void StartTimer()
{
    if (Icecap && FoundIcecap)
    {
        ICStartProfile(PROFILE_GLOBALLEVEL, PROFILE_CURRENTID);
        ICCommentMarkProfile(CurrentTestIndex, CurrentTestDescription);
    }

    // Disable the cursor so that it doesn't interfere with the timing:

    ShowCursor(FALSE);

    if (TestRender)
    {
        // Rig it so that we do only one iteration of the test.

        MinIterations = 0;
        MinimumCount = 0;
    }
    else
    {
        // Somewhat randomly choose 1 second as the minimum counter time:
    
        QueryPerformanceFrequency(reinterpret_cast<LARGE_INTEGER*>(&CountsPerSecond));
        MinimumCount = CountsPerSecond;
    
        // Okay, start timing!
    
        Iterations = 0;
        QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&StartCounter));
    }
}

/***************************************************************************\
* EndTimer
*
* Called by timing routine to see if it's okay to stop timing.  Timing
* can stop if 2 conditions are satisfied:
*
*   1.  We've gone the minimum time duration (to ensure that we good
*       good accuracy from the timer functions we're using)
*   2.  We've done the minimum number of iterations (to ensure, if the
*       routine being timed is very very slow, that we do more than
*       one iteration)
*
\***************************************************************************/

BOOL EndTimer()
{
    LONGLONG counter;

    // Always do at least MIN_ITERATIONS iterations (and only check
    // the timer that frequently as well):

    Iterations++;
    if (Iterations & MinIterations)
        return(FALSE);

    // Query the performance counter, and bail if for some bizarre reason
    // this computer doesn't support a high resolution timer (which I think
    // all do now-a-days):

    if (!QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&counter)))
        return(TRUE);

    // Ensure that we get good timer accuracy by going for the minimum
    // amount of time:

    if ((counter - StartCounter) <= MinimumCount)
        return(FALSE);

    ShowCursor(TRUE);

    if (Icecap && FoundIcecap)
    {
        ICStopProfile(PROFILE_GLOBALLEVEL, PROFILE_CURRENTID);
    }

    // Okay, you can stop timing!

    return(TRUE);
}

/***************************************************************************\
* GetTimer
*
* Should only be called after EndTimer() returns TRUE.  Returns the
* time in seconds, and the number of iterations benchmarked.
*
\***************************************************************************/

void GetTimer(float* seconds, UINT* iterations)
{
    LONGLONG counter;

    // Note that we re-check the timer here to account for any
    // flushes that the caller may have needed to have done after
    // the EndTimer() call:

    QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&counter));

    if ((TestRender) || (CountsPerSecond == 0))
    {
        // Either the timer doesn't work, or we're doing a 'test render':

        *seconds = 1000000.0f;
        *iterations = 1;
    }
    else
    {
        // Woo hoo, we're done!

        *seconds = static_cast<float>(counter - StartCounter) / CountsPerSecond;
        *iterations = Iterations;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\perftest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by perftest.rc
//
#define IDD_STARTDIALOG                 100
#define IDC_ACCURACY                    1000
#define IDC_OS                          1002
#define IDC_PROCESSOR                   1003
#define IDC_VDRIVER                     1004
#define IDC_FILE                        1005
#define IDC_RESLIST                     1006
#define IDC_HIGHPRIORITY                1007
#define IDC_FLUSH                       1008
#define IDC_EXCELOUT                    1009
#define IDC_ICECAP                      1010
#define IDC_SKIPLIST                    1012
#define IDC_TESTLIST                    1013
#define IDC_ADDTEST                     1014
#define IDC_DELTEST                     1015
#define IDC_DELALLTEST                  1016
#define IDC_ADDALLTEST                  1017
#define IDC_TESTRENDER                  1018
#define IDM_QUIT                        40000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         41000
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#define SAMPLE_BITMAP                   8000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\perftest\perftext.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   perftext.cpp
*
* Abstract:
*
*   Contains all the tests for any routines that do text functionality.
*
\**************************************************************************/

#include "perftest.h"

WCHAR TestStringW[] = L"The quick brown fox jumps over the lazy dog.";
CHAR TestStringA[] = "The quick brown fox jumps over the lazy dog.";
INT TestString_Count = sizeof(TestStringW) / sizeof(TestStringW[0]) - 1;

float Text_Draw_PerCall_30pt_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        FontFamily fontFamily(L"Arial");
        Font font(&fontFamily, 30);
        StringFormat stringFormat(0);
        SolidBrush brush(Color::Red);
        PointF origin(0, 0);

        StartTimer();
    
        do {
            PointF origin(64, 64);
            g->DrawString(L"A", 1, &font, origin, &stringFormat, &brush);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HFONT font = CreateFont(30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, _T("Arial"));
        HGDIOBJ oldFont = SelectObject(hdc, font);

        SetTextColor(hdc, RGB(0xff, 0, 0));
        SetBkMode(hdc, TRANSPARENT);

        StartTimer();

        do {
            TextOut(hdc, 0, 0, _T("A"), 1);

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    return(iterations / seconds / KILO);       // Calls per second
}

float Text_Draw_PerGlyph_30pt_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        FontFamily fontFamily(L"Arial");
        Font font(&fontFamily, 30);
        StringFormat stringFormat(0);
        SolidBrush brush(Color::Red);
        PointF origin(0, 0);

        // Don't count font realization towards per-glyph time:
        g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

        StartTimer();
    
        do {
            PointF origin(64, 64);
            g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HFONT font = CreateFont(30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, _T("Arial"));
        HGDIOBJ oldFont = SelectObject(hdc, font);

        SetTextColor(hdc, RGB(0xff, 0, 0));
        SetBkMode(hdc, TRANSPARENT);
        TextOutA(hdc, 0, 0, TestStringA, TestString_Count);

        StartTimer();

        do {
            TextOutA(hdc, 0, 0, TestStringA, TestString_Count);

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerGlyph_30pt_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0); // No GDI equivalent

    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    LinearGradientBrush brush(Point(0, 0), Point(512, 512), Color::Red, Color::Blue);
    PointF origin(0, 0);

    // Don't count font realization towards per-glyph time:
    g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerCall_30pt_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0); // No GDI equivalent

    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    LinearGradientBrush brush(Point(0, 0), Point(512, 512), Color::Red, Color::Blue);
    PointF origin(0, 0);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(L"A", 1, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerCall_30pt_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        g->SetTextRenderingHint(TextRenderingHintAntiAlias);

        FontFamily fontFamily(L"Arial");
        Font font(&fontFamily, 30);
        StringFormat stringFormat(0);
        SolidBrush brush(Color::Red);
        PointF origin(0, 0);

        StartTimer();
    
        do {
            PointF origin(64, 64);
            g->DrawString(L"A", 1, &font, origin, &stringFormat, &brush);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HFONT font = CreateFont(30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ANTIALIASED_QUALITY, 0, _T("Arial"));
        HGDIOBJ oldFont = SelectObject(hdc, font);

        SetTextColor(hdc, RGB(0xff, 0, 0));
        SetBkMode(hdc, TRANSPARENT);

        StartTimer();

        do {
            TextOut(hdc, 0, 0, _T("A"), 1);

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    return(iterations / seconds / KILO);       // Calls per second
}

float Text_Draw_PerGlyph_30pt_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        g->SetTextRenderingHint(TextRenderingHintAntiAlias);

        FontFamily fontFamily(L"Arial");
        Font font(&fontFamily, 30);
        StringFormat stringFormat(0);
        SolidBrush brush(Color::Red);
        PointF origin(0, 0);

        // Don't count font realization towards per-glyph time:
        g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

        StartTimer();
    
        do {
            PointF origin(64, 64);
            g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HFONT font = CreateFont(30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ANTIALIASED_QUALITY, 0, _T("Arial"));
        HGDIOBJ oldFont = SelectObject(hdc, font);

        SetTextColor(hdc, RGB(0xff, 0, 0));
        SetBkMode(hdc, TRANSPARENT);
        TextOutA(hdc, 0, 0, TestStringA, TestString_Count);

        StartTimer();

        do {
            TextOutA(hdc, 0, 0, TestStringA, TestString_Count);

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerGlyph_30pt_Antialiased_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0); // No GDI equivalent

    g->SetTextRenderingHint(TextRenderingHintAntiAlias);
    
    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    LinearGradientBrush brush(Point(0, 0), Point(512, 512), Color::Red, Color::Blue);
    PointF origin(0, 0);

    // Don't count font realization towards per-glyph time:
    g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerCall_30pt_Antialiased_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0); // No GDI equivalent

    g->SetTextRenderingHint(TextRenderingHintAntiAlias);

    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    LinearGradientBrush brush(Point(0, 0), Point(512, 512), Color::Red, Color::Blue);
    PointF origin(0, 0);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(L"A", 1, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerCall_30pt_Cleartype(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);      // No accessible GDI equivalent

    g->SetTextRenderingHint(TextRenderingHintClearTypeGridFit);

    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    SolidBrush brush(Color::Red);
    PointF origin(0, 0);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(L"A", 1, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);       // Calls per second
}

float Text_Draw_PerGlyph_30pt_Cleartype(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);      // No accessible GDI equivalent

    g->SetTextRenderingHint(TextRenderingHintClearTypeGridFit);

    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    SolidBrush brush(Color::Red);
    PointF origin(0, 0);

    // Don't count font realization towards per-glyph time:
    g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerGlyph_30pt_Cleartype_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0); // No GDI equivalent

    g->SetTextRenderingHint(TextRenderingHintClearTypeGridFit);
    
    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    LinearGradientBrush brush(Point(0, 0), Point(512, 512), Color::Red, Color::Blue);
    PointF origin(0, 0);

    // Don't count font realization towards per-glyph time:
    g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerCall_30pt_Cleartype_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0); // No GDI equivalent

    g->SetTextRenderingHint(TextRenderingHintClearTypeGridFit);

    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    LinearGradientBrush brush(Point(0, 0), Point(512, 512), Color::Red, Color::Blue);
    PointF origin(0, 0);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(L"A", 1, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

////////////////////////////////////////////////////////////////////////////////
// Add tests for this file here.  Always use the 'T' macro for adding entries.
// The parameter meanings are as follows:
//
// Parameter
// ---------
//     1     UniqueIdentifier - Must be a unique number assigned to no other test
//     2     Priority - On a scale of 1 to 5, how important is the test?
//     3     Function - Function name
//     4     Comment - Anything to describe the test

Test TextTests[] = 
{
    T(4000, 1, Text_Draw_PerCall_30pt_Aliased, "Kcalls/s"),
    T(4001, 1, Text_Draw_PerGlyph_30pt_Aliased, "Kglyphs/s"),
    T(4002, 1, Text_Draw_PerCall_30pt_LinearGradient, "Kcalls/s"),
    T(4003, 1, Text_Draw_PerGlyph_30pt_LinearGradient, "Kglyphs/s"),
    T(4004, 1, Text_Draw_PerCall_30pt_Antialiased, "Kcalls/s"),
    T(4005, 1, Text_Draw_PerGlyph_30pt_Antialiased, "Kglyphs/s"),
    T(4006, 1, Text_Draw_PerCall_30pt_Antialiased_LinearGradient, "Kcalls/s"),
    T(4007, 1, Text_Draw_PerGlyph_30pt_Antialiased_LinearGradient, "Kglyphs/s"),
    T(4008, 1, Text_Draw_PerCall_30pt_Cleartype, "Kcalls/s"),
    T(4009, 1, Text_Draw_PerGlyph_30pt_Cleartype, "Kglyphs/s"),
    T(4010, 1, Text_Draw_PerCall_30pt_Cleartype_LinearGradient, "Kcalls/s"),
    T(4011, 1, Text_Draw_PerGlyph_30pt_Cleartype_LinearGradient, "Kglyphs/s"),
};

INT TextTests_Count = sizeof(TextTests) / sizeof(TextTests[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\polytest\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991-2000 Microsoft Corporation
\***************************************************************************/

#define ACCELS 3
#define POLYTESTICON 4

#define MM_REDRAW                   0x8000
#define MM_TIME                     0x8001
#define MM_POINTS                   0x8002
                                    
#define MM_DRAW                     0x8100
#define MM_WIDENPATH                0x8101
#define MM_FILL                     0x8102
#define MM_POLYGON                  0x8103
#define MM_BEZIER                   0x8104
#define MM_RECTANGLE                0x8105
#define MM_ELLIPSE                  0x8106
#define MM_TEXTPATH                 0x8107
#define MM_LINES                    0x8108
                                    
#define MM_ANTIALIAS                0x8200
#define MM_WINDING                  0x8201
#define MM_SPINE                    0x8202
#define MM_GDI                      0x8203
#define MM_CLIPGRID                 0x8204
#define MM_RANDOMTEST               0x8205
#define MM_ANCHORS                  0x8206
#define MM_TRANSFORMOVERLAY         0x8207
#define MM_SCALINGONLY              0x8208
#define MM_RESETTRANSFORM           0x8209
#define MM_EDITTRANSFORM            0x820a
#define MM_GAMMACORRECT             0x820b
                                    
#define MM_WIDTH                    0x8300
#define MM_MITERLIMIT               0x8301
#define MM_CAP_ROUND                0x8302
#define MM_CAP_FLAT                 0x8303
#define MM_CAP_SQUARE               0x8304
#define MM_CAP_TRIANGLE             0x8305
#define MM_JOIN_ROUND               0x8306
#define MM_JOIN_BEVEL               0x8307
#define MM_JOIN_MITER               0x8308
#define MM_STYLE_SOLID              0x8309
#define MM_STYLE_DASH               0x830a
#define MM_STYLE_DOT                0x830b
#define MM_STYLE_DASHDOT            0x830c
#define MM_STYLE_DASHDOTDOT         0x830d
#define MM_ALPHA                    0x830e
#define MM_ALIGNMENT_CENTER         0x830f
#define MM_ALIGNMENT_INSET          0x8310
#define MM_COMPOUND                 0x8314
                                    
#define MM_BRUSH_SOLID              0x8400
#define MM_BRUSH_TEXTURE            0x8401
#define MM_BRUSH_TEXTURE_32x32      0x8402
#define MM_BRUSH_TEXTURE_1x1        0x8403
#define MM_BRUSH_LINEAR             0x8404
#define MM_BRUSH_PATHGRADIENT       0x8405
#define MM_WRAP_TILE                0x8406
#define MM_WRAP_CLAMP               0x8407
#define MM_WRAP_FLIPX               0x8408
#define MM_WRAP_FLIPY               0x8409
#define MM_WRAP_FLIPXY              0x840a
#define MM_DYNAMICBRUSHRECTANGLE    0x840b
#define MM_EDITBRUSHSHAPE           0x840c
                                
#define SAMPLE_BITMAP               0x9000
                                    
#define IDD_OK                      0xa000
#define IDD_WIDTH                   0xa001
#define IDD_ALPHA                   0xa002
                                    
#define IDD_POINT1X                 0xa003
#define IDD_POINT1Y                 0xa004
#define IDD_POINT2X                 0xa005
#define IDD_POINT2Y                 0xa006
#define IDD_POINT3X                 0xa007
#define IDD_POINT3Y                 0xa008
#define IDD_POINT4X                 0xa009
#define IDD_POINT4Y                 0xa00a
                                    
#define IDD_M11                     0xa100
#define IDD_M12                     0xa101
#define IDD_M21                     0xa102
#define IDD_M22                     0xa103
#define IDD_M31                     0xa104
#define IDD_M32                     0xa105
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\perftest\perftest.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   perftest.h
*
* Abstract:
*
*   This is the common include module for the GDI+ performance tests.
*
\**************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <math.h>            // sin & cos
#include <tchar.h>
#include <commctrl.h>
#include <objbase.h>

#if 0

    // So that we can continue testing the old drawing functionality for
    // a while, don't use the new API headers yet:
    
    #define RenderingHintAntiAlias      RenderingModeAntiAlias
    #define TextRenderingHintAntiAlias  TextAntiAlias
    #define TextRenderingHintClearType  TextClearType
    #define PixelFormatMax              PIXFMT_MAX
    #define PixelFormat32bppARGB        PIXFMT_32BPP_ARGB
    #define PixelFormat32bppPARGB       PIXFMT_32BPP_PARGB
    #define PixelFormat32bppRGB         PIXFMT_32BPP_RGB
    #define PixelFormat16bppRGB555      PIXFMT_16BPP_RGB555
    #define PixelFormat16bppRGB565      PIXFMT_16BPP_RGB565
    #define PixelFormat24bppRGB         PIXFMT_24BPP_RGB
    #define LinearGradientBrush         LineGradientBrush
    #define InterpolationModeBicubic    InterpolateBicubic
    #define InterpolationModeBilinear   InterpolateBilinear
    #define UNITPIXEL                   PageUnitPixel
    
#else
    
    #define USE_NEW_APIS 1
    #define USE_NEW_APIS2 1
    
    #define UNITPIXEL                   UnitPixel
    
#endif

#include <gdiplus.h>

using namespace Gdiplus;

#include "resource.h"
#include "debug.h"

// Handy window handle:

extern HWND ghwndMain;

// Dimensions of any bitmap destinations:

#define TestWidth 800
#define TestHeight 600

//--------------------------------------------------------------------------
// Types
//
// Enums for test permutations
//--------------------------------------------------------------------------

enum DestinationType 
{
    Destination_Screen_Current,
    Destination_Screen_800_600_8bpp_DefaultPalette,
    Destination_Screen_800_600_8bpp_HalftonePalette,
    Destination_Screen_800_600_16bpp,
    Destination_Screen_800_600_24bpp,
    Destination_Screen_800_600_32bpp,
    Destination_CompatibleBitmap_8bpp,
    Destination_DIB_15bpp,
    Destination_DIB_16bpp,
    Destination_DIB_24bpp,
    Destination_DIB_32bpp,
    Destination_Bitmap_32bpp_ARGB,
    Destination_Bitmap_32bpp_PARGB,

    Destination_Count                // Must be last entry, used for count
};

enum ApiType
{
    Api_GdiPlus,
    Api_Gdi,

    Api_Count                        // Must be last entry, used for count
};

enum StateType
{
    State_Default,
    State_Antialias,

    State_Count                      // Must be last entry, used for count
};
   
typedef float (*TESTFUNCTION)(Graphics *, HDC); 

struct Test 
{
    INT          UniqueIdentifier;
    INT          Priority;
    TESTFUNCTION Function;
    LPCTSTR      Description;
    LPCTSTR      Comment;
};

struct Config
{
    LPCTSTR     Description;
    BOOL        Enabled;
};

struct TestConfig
{
    BOOL        Enabled;
    Test*       TestEntry;          // Points to static entry describing test
};

extern TestConfig *TestList;        // Sorted test list
extern Config ApiList[];
extern Config DestinationList[];
extern Config StateList[];

//--------------------------------------------------------------------------
// Test groupings
//
//--------------------------------------------------------------------------

#define T(uniqueIdentifier, priority, function, comment) \
    { uniqueIdentifier, priority, function, _T(#function), _T(comment) }

struct TestGroup
{
    Test*   Tests;
    INT     Count;
};

extern Test DrawTests[];
extern Test FillTests[];
extern Test ImageTests[];
extern Test TextTests[];
extern Test OtherTests[];

extern INT DrawTests_Count;
extern INT FillTests_Count;
extern INT ImageTests_Count;
extern INT TextTests_Count;
extern INT OtherTests_Count;

extern INT Test_Count;      // Total number of tests

//--------------------------------------------------------------------------
// TestResult -
//
// Structure for maintaining test result information.  The data is kept
// as a multi-dimensional array, and the following routines are used 
// for access.
//--------------------------------------------------------------------------

struct TestResult 
{
    float Score;
};

inline INT ResultIndex(INT destinationIndex, INT apiIndex, INT stateIndex, INT testIndex)
{
    return(((testIndex * State_Count + stateIndex) * Api_Count + apiIndex) * 
            Destination_Count + destinationIndex);
}

inline INT ResultCount()
{
    return(Destination_Count * Api_Count * State_Count * Test_Count);
}

extern TestResult *ResultsList;     // Allocation to track test results

//--------------------------------------------------------------------------
// TestSuite - 
//
// Class that abstracts all the state setup for running all the tests.
//--------------------------------------------------------------------------

class TestSuite
{
private:

    // Save Destination state:

    BOOL ModeSet;                   // Was a mode set?
    HPALETTE HalftonePalette, OldPalette;

    // Saved State state:

    GraphicsState SavedState;

public:

    BOOL InitializeDestination(DestinationType, Bitmap**, HBITMAP*);
    VOID UninitializeDestination(DestinationType, Bitmap *, HBITMAP);

    BOOL InitializeApi(ApiType, Bitmap *, HBITMAP, HWND, Graphics **, HDC *);
    VOID UninitializeApi(ApiType, Bitmap *, HBITMAP, HWND, Graphics *, HDC);

    BOOL InitializeState(ApiType, StateType, Graphics*, HDC);
    VOID UninitializeState(ApiType, StateType, Graphics*, HDC);

    TestSuite();
   ~TestSuite();

    VOID Run(HWND hwnd);
};

///////////////////////////////////////////////////////////////////////////
// Test settings:

extern BOOL AutoRun;
extern BOOL ExcelOut;
extern BOOL Icecap;
extern BOOL FoundIcecap;
extern BOOL TestRender;
extern INT CurrentTestIndex;
extern CHAR CurrentTestDescription[];

extern LPTSTR processor;
extern TCHAR osVer[MAX_PATH];
extern TCHAR deviceName[MAX_PATH];
extern TCHAR machineName[MAX_PATH];

///////////////////////////////////////////////////////////////////////////
// IceCAP API functions

#define PROFILE_GLOBALLEVEL 1
#define PROFILE_CURRENTID ((unsigned long)0xFFFFFFFF)

typedef int (_stdcall *ICCOMMENTMARKPROFILEFUNC)(long lMarker, const char *szComment);

typedef int (_stdcall *ICCONTROLPROFILEFUNC)(int nLevel, unsigned long dwId);

extern ICCONTROLPROFILEFUNC ICStartProfile, ICStopProfile;
extern ICCOMMENTMARKPROFILEFUNC ICCommentMarkProfile;

///////////////////////////////////////////////////////////////////////////
// Worker routines

VOID MessageF(LPTSTR fmt, ...);
HBITMAP CreateCompatibleDIB2(HDC hdc, int width, int height);
VOID CreatePerformanceReport(TestResult *results, BOOL useExcel);
VOID GetOutputFileName(TCHAR*);

///////////////////////////////////////////////////////////////////////////
// Timer utility functions

#define MIN_ITERATIONS 16   // Must be power of two
#define MIN_DURATION 200    // Minimum time duration, in milliseconds
#define MEGA 1000000        // Handy constant for computing megapixels
#define KILO 1000           // Handy constant for computing kilopixels

void StartTimer();
BOOL EndTimer();
void GetTimer(float* seconds, UINT* iterations);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\pseudotest\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\pseudotest\test.cpp ===
//
// GDI+ test program
//

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <windows.h>
#include <objbase.h>
#include <tchar.h>
#include <Commctrl.h>

#include "Gdiplus.h"

// Use the given namespace
using namespace Gdiplus;

HINSTANCE appInstance;  // handle to the application instance
HWND hwndMain;          // handle to application's main window
HWND hStatusWnd;        // Status window

//
// Display an error message dialog and quit
//

VOID Error(PCSTR fmt,...)
{
    va_list arglist;
    va_start(arglist, fmt);
    vfprintf(stderr, fmt, arglist);
    va_end(arglist);

    exit(-1);
}

#define CHECKERROR(e) \
{ \
    if (!(e)) \
    { \
        Error("Error on line %d\n", __LINE__); \
    } \
}

//
// Perform GDI+ tests
//

VOID DrawImages(Graphics *g)
{
    RadialGradientBrush gradBrush2(
        RectF(0,0,200,200),
        Color(0,128,255),
        Color(200,20,97)
        );
    GraphicsPath aPath(FillModeWinding);
    aPath.AddRectangle(Rect(48,0,70,30));
/*
    aPath.AddRectangle(Rect(0,80,20,50));
    aPath.AddBezier(
        PointF(20,20),
        PointF(60,30),
        PointF(80,80),
        PointF(30,100));
*/
//    Region aRegion(&aPath);

    GraphicsPath aPath2;
    Region aRegion3(&aPath2);
    Region aRegion4(&aPath2);
    Region aRegion5(&aPath2);
    Region aRegion6(&aPath2);
    g->FillPath(&gradBrush2,&aPath);
//    aPath2.AddArc(140,100,30,50,50,77);
//    aPath2.AddPie(100,200,76,20,0,200);
//    Region aRegion2(&aPath2);
//    aPath2.AddLine(100,100,130,130);
//    aPath2.AddLine(130,130,200,225);
//    aPath2.AddRectangle(Rect(350,300,60,70));
//    aPath2.AddBezier(200,225,230,250,270,200,290,300);

/*    
    SolidBrush aBrush(Color (255,0,0));
    SolidBrush aBrush2(Color(20,40,250));
    SolidBrush aBrush3(Color(20,200,30));
    SolidBrush aBrush4(Color(140,200,250));
    SolidBrush aBrushA(Color(150,200,50,130));
    SolidBrush aBrushA2(Color(80,15,150,4));
    
    Bitmap bitmap(L"c:\\frisbee.bmp");
    TextureBrush aBrushBitmap(&bitmap);
    
    HatchBrush aHatchBrush(
        HatchStyleDiagonalCross,
        Color(0,255,0),
        Color(0,0,255));
    HatchBrush aHatchBrushT(
        HatchStyleDiagonalCross,
        Color(0,255,0),
        Color(0,0,0,0));
    
    RadialGradientBrush gradBrush(
        RectF(0,0,50,50),
        Color(255,0,255),
        Color(0,0,255)
        );
    RadialGradientBrush gradBrush2(
        RectF(0,0,200,200),
        Color(0,128,255),
        Color(200,20,97)
        );
    RadialGradientBrush gradBrushA(
        RectF(0,0,200,200),
        Color(80,0,0,255),
        Color(170,0,255,0)
        );
    RadialGradientBrush gradBrushHuge(
        RectF(0,0,400,400),
        Color(80,0,0,255),
        Color(170,0,255,0)
        );

    Color colors[4] = {
        Color(0,0,0),
        Color(255,0,0),
        Color(0,255,0),
        Color(0,0,255)
        };
    RectangleGradientBrush gradBrushRect(
        RectF(0,0,500,500),
        colors,
        WrapModeTile
        );
        
    Pen aPen(Color(40,80,160),3,UnitWorld);
    Pen aPen2(&gradBrushRect,8,UnitWorld);
    Pen aPen3(Color(0,0,0),0,UnitWorld);
    Pen aPen4(Color(0,0,0),15,UnitWorld);
    // aPen4.SetDashStyle(DashStyleDash);
    aPen4.SetLineCap(LineCapRound,LineCapRound,LineCapRound);

    GraphicsPath aPath(FillModeWinding);
    aPath.AddRectangle(Rect(48,0,70,30));
    aPath.AddRectangle(Rect(0,80,20,50));
    aPath.AddBezier(
        PointF(20,20),
        PointF(60,30),
        PointF(80,80),
        PointF(30,100));
    Region aRegion(&aPath);

    GraphicsPath aPath2;
    aPath2.AddArc(140,100,30,50,50,77);
    aPath2.AddPie(100,200,76,20,0,200);
    Region aRegion2(&aPath2);
    aPath2.AddLine(100,100,130,130);
    aPath2.AddLine(130,130,200,225);
    aPath2.AddRectangle(Rect(350,300,60,70));
    aPath2.AddBezier(200,225,230,250,270,200,290,300);
    Region aRegion3(&aPath2);
    
    Region aRegion4(&aPath2);
    aRegion4.Or(&aRegion);
*/
    
//    g->DrawPath(&aPen,&aPath);
//    g->FillPath(&gradBrush2,&aPath);
//    g->FillPath(&aBrush2,&aPath);
/*
    g->FillEllipse(&gradBrushA,20,40,150,130);
*/
/*
    g->FillRectangle(&gradBrushA,48,0,70,30);
    g->FillPath(&gradBrush2,&aPath);
    g->FillRectangle(&gradBrush,0,50,50,50);
    g->FillRectangle(&gradBrush,90,90,30,30);
    g->TranslateWorldTransform(50,50);
    g->FillRectangle(&gradBrushA,0,130,20,20);
*/
/*
    g->FillRectangle(&aBrushBitmap,0,0,400,400);
    g->FillRegion(&aBrush2,&aRegion4);
    g->TranslateWorldTransform(100,100);
    g->FillPath(&gradBrushRect,&aPath2);
*/
    //////////// Final Test Case ///////////////
/*
    g->FillRectangle(&gradBrushHuge,0,0,400,400);
    g->FillRectangle(&aBrushA2,0,81,30,20);
    g->FillRectangle(&aBrushA2,81,0,20,30);
    g->FillRectangle(&aBrushA,0,0,100,100);
    g->FillRectangle(&aBrushA,110,110,5,5);
    g->TranslateWorldTransform(50,50);
    g->FillPath(&gradBrush2,&aPath);
*/
    //////////// Solid Test Case ///////////////
/*
    g->FillRectangle(&aBrush3,0,0,400,400);
    g->FillRectangle(&aBrush2,0,81,30,20);
    g->FillRectangle(&aBrush2,81,0,20,30);
    g->FillRectangle(&aBrush,0,0,100,100);
    g->FillRectangle(&aBrush,110,110,5,5);
*/
/*
    g->TranslateWorldTransform(40,40);
    g->FillPath(&aBrush,&aPath);
    g->FillPath(&aBrush2,&aPath2);
    g->DrawPath(&aPen2,&aPath2);
    g->TranslateWorldTransform(110,35);
    g->FillPath(&aBrush3,&aPath);
    g->DrawPath(&aPen,&aPath);
    g->DrawEllipse(&aPen3,100,20,90,50);
    g->DrawRectangle(&aPen4,10,200,90,30);
    g->DrawBezier(&aPen4,10,300,80,360,180,350,250,280);
*/
}

VOID RecordMetafile(HWND hwnd)
{
    HDC aDC = GetDC(hwnd);
    Metafile *  recording = new Metafile(L"c:\\TestEmfP.Emf", 
        aDC, NULL, PageUnitInch, NULL);
    Graphics *  gMeta = Graphics::GetFromImage(recording);
    DrawImages(gMeta);
    delete gMeta;
    delete recording;
    ReleaseDC(hwnd,aDC);
}

VOID DoTest(HWND hwnd,HDC hdc)
{
    Graphics *  gScreen = Graphics::GetFromHwnd(hwnd);
    DrawImages(gScreen);
/*
    Metafile * playback = new Metafile(L"c:\\TestEmfP.Emf");
    GpRectF playbackRect;
    gScreen->GetVisibleClipBounds(playbackRect);
    playbackRect.Width -= 10;
    playbackRect.Height -= 10;

    gScreen->DrawImage(playback, playbackRect);
    delete playback;
*/

    delete gScreen;
}


//
// Window callback procedure
//

LRESULT CALLBACK
MainWndProc(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    static BOOL once = FALSE;

    switch (uMsg)
    {
    case WM_ACTIVATE:
        if (!once)
        {
            once = TRUE;
            RecordMetafile(hwnd);
        }
        break;
    case WM_PAINT:
        {
            HDC hdc;
            PAINTSTRUCT ps;
            ps.fErase = TRUE;

            hdc = BeginPaint(hwnd, &ps);

            DoTest(hwnd, hdc);
            EndPaint(hwnd, &ps);
        }
        break;

    case WM_DESTROY:

        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(VOID)
{
    WNDCLASS wc;
    _TCHAR classname[] = _T("PseudoTestClass");

    appInstance = GetModuleHandle(NULL);

    wc.style            = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc      = MainWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = appInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) GetStockObject(WHITE_BRUSH);  
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = classname;

    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }

    hwndMain =
      CreateWindowEx(
        0,
        classname,
        _T("PseudoDriver Functionality Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_MAXIMIZE     |
        WS_SYSMENU,
        80,
        70,
        512,
        512,
        NULL,
        NULL,
        appInstance,
        NULL);

    if (hwndMain == NULL)
    {
        return(FALSE);
    }

/*
    hStatusWnd = CreateStatusWindow(WS_CHILD | WS_VISIBLE,
                                     _T("Functionality Test App"),
                                     hwndMain,
                                     -1);
*/

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    if (!bInitApp())
    {
        return(0);
    }
    ShowWindow(hwndMain,SW_RESTORE);

    haccel = LoadAccelerators(appInstance, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\quadtest\precomp.hpp ===
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <math.h>
#include <windows.h>

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\polytest\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains all the code necessary for a simple GDI+ primitive
* test.
*
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1991-2000 Microsoft Corporation
*
\**************************************************************************/

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <windows.h>
#include <objbase.h>
#include <mmsystem.h>
#include <gdiplus.h>

using namespace Gdiplus;

#include "wndstuff.h"

#include "../gpinit.inc"

#define HIT_DISTANCE 16
#define ABS(x) (((x) >= 0) ? (x) : -(x))
#define ROUND(x) ((INT) floor(x + 0.5f))

// We set the GDI transform to a 16x scaling transform, and the mode to
// GM_ADVANCED, so that we can get full fractional accuracy on the points
// that we feed to GDI:

#define GDI_FIXEDPOINT_SCALE 16

// State for tracking the primitive vertices and transform:

const INT PrimitivePointsMax = 64;
INT PrimitivePointsCount = 4;
PointF PrimitivePoints[PrimitivePointsMax] = { PointF(100, 100), 
                                               PointF(100, 400), 
                                               PointF(400, 400), 
                                               PointF(400, 100) };
Matrix *PrimitiveTransform;
Matrix *PrimitiveInverseTransform;
INT PrimitiveDragVertex = -1;
BOOL IsAddingPoints = FALSE;

// State for tracking the location of the transform overlay:

const REAL OverlayDimension = 100;
PointF OverlayPoints[3];            // 3 device-space representing overlay,
                                    //   where [1] is the elbow
PointF OverlayOffset;               // World-space coordinate of overlay elbow
INT OverlayDragVertex = -1;

// Miscellaneous state:

INT WindowWidth;
INT WindowHeight;

// Settings:

BOOL DoFill = FALSE;
BOOL DoDraw = TRUE;
BOOL DoAntialias = FALSE;
BOOL DoGammaCorrect = FALSE;
BOOL DoGdi = FALSE;
BOOL DoClipGrid = FALSE;
BOOL DoRandomTest = FALSE;
BOOL DoWindingFill = FALSE;
BOOL DoAnchors = TRUE;
BOOL DoSpine = FALSE;
BOOL DoWiden = FALSE;
BOOL DoCompound = FALSE;
BOOL DoTransformOverlay = FALSE;
BOOL DoScalingOnly = FALSE;
BOOL DoShape = FALSE;
BOOL DoBrushRect = FALSE;

REAL RenderMiterLimit = 10;
INT RenderWidth = 1;
INT RenderAlpha = 255;

LinearGradientBrush *LinearBrush;
GraphicsPath *PathGradientPath;

Brush *RenderBrush;
Pen *RenderPen;
Region *RenderRegion;

HRGN RenderHrgn;
HBRUSH RenderHbrush;
HPEN RenderHpen;

WORD MmWrapMode = MM_WRAP_TILE;
WORD MmBrushType = MM_BRUSH_SOLID;
WORD MmEndCap = MM_CAP_FLAT;
WORD MmJoin = MM_JOIN_MITER;
WORD MmDashStyle = MM_STYLE_SOLID;
WORD MmAlignment = MM_ALIGNMENT_CENTER;
WORD MmPrimitive = MM_POLYGON;

// Other useful globals:

HINSTANCE ghInstance;
HWND      ghwndMain;
HBRUSH    ghbrWhite;

FARPROC glpfnEnterWidth;
FARPROC glpfnEnterAlpha;
FARPROC glpfnEnterPoints;
FARPROC glpfnEnterTransform;

/***************************************************************************\
* Creates the GDI+ brush to be used.
*
\***************************************************************************/

VOID
CreateBrush_Gdiplus()
{
    WrapMode wrapMode;
    INT i;

    // Delete the old brush:

    delete RenderBrush;

    LinearBrush = NULL;
    RenderBrush = NULL;

    // Create the new one:

    Bitmap bitmap(L"winnt256.bmp");

    switch (MmWrapMode)
    {
    case MM_WRAP_TILE: wrapMode = WrapModeTile; break;
    case MM_WRAP_CLAMP: wrapMode = WrapModeClamp; break;
    case MM_WRAP_FLIPX: wrapMode = WrapModeTileFlipX; break;
    case MM_WRAP_FLIPY: wrapMode = WrapModeTileFlipY; break;
    case MM_WRAP_FLIPXY: wrapMode = WrapModeTileFlipXY; break;
    }

    switch (MmBrushType)
    {
    case MM_BRUSH_SOLID:
        RenderBrush = new SolidBrush(Color(128, 128, 128));
        break;

    case MM_BRUSH_TEXTURE:
        RenderBrush = new TextureBrush(&bitmap, wrapMode);
        break;

    case MM_BRUSH_TEXTURE_32x32:
        {
            Bitmap texture(32, 32, PixelFormat32bppARGB);
            Graphics g(&texture);
            g.DrawImage(&bitmap, Rect(0, 0, 32, 32));
    
            TextureBrush *brush = new TextureBrush(&texture, wrapMode);

            // Set a translate:

            Matrix matrix(1, 0, 0, 1, 100, 100);
            brush->SetTransform(&matrix);

            RenderBrush = brush;
        }
        break;

    case MM_BRUSH_TEXTURE_1x1:
        {
            SolidBrush solidBrush(Color::Green);
            Bitmap texture(1, 1, PixelFormat32bppARGB);
            Graphics g(&texture);
            g.FillRectangle(&solidBrush, 0, 0, 1, 1);

            TextureBrush *brush = new TextureBrush(&texture, wrapMode);

            // Set a translate:

            Matrix matrix(1, 0, 0, 1, 100, 100);
            brush->SetTransform(&matrix);

            RenderBrush = brush;
        }
        break;

    case MM_BRUSH_LINEAR:
        {
            LinearGradientBrush *brush = new LinearGradientBrush(
                Point(100, 100), 
                Point(100, 300),
                Color::Red, 
                Color::Black
            );
            brush->SetWrapMode(wrapMode);
    
            RenderBrush = brush;
            LinearBrush = brush;
        }
        break;

    case MM_BRUSH_PATHGRADIENT:
        {
            PathGradientBrush *brush;
            INT count;

            if (PathGradientPath != NULL)
            {
                brush = new PathGradientBrush(PathGradientPath);
                count = PathGradientPath->GetPointCount();
            }
            else
            {
                // Substitute a default path for now:

                PointF points[] = { PointF(100, 100), PointF(100, 300),
                                    PointF(300, 300), PointF(30, 100) };

                brush = new PathGradientBrush(points, 4);
                count = 4;
            }

            Color *colors = new Color[count];

            for (i = 0; i < count; i += 2)
            {
                colors[i] = Color::Green;
                colors[i+1] = Color::Red;
            }
            brush->SetSurroundColors(colors, &count);

            delete [] colors;
    
            brush->SetCenterPoint(OverlayOffset);
            brush->SetCenterColor(Color::Black);

            RenderBrush = brush;
        }
        break;
    }
}

/***************************************************************************\
* Creates the GDI brush to be used.
*
\***************************************************************************/

VOID
CreateBrush_Gdi()
{
    DeleteObject(RenderHbrush);

    RenderHbrush = CreateSolidBrush(RGB(128, 128, 128));
}

/***************************************************************************\
* Creates the GDI and GDI+ brushes to be used.
*
\***************************************************************************/

VOID
CreateBrushes()
{
    CreateBrush_Gdiplus();
    CreateBrush_Gdi();
}

/***************************************************************************\
* Creates the GDI+ pen to be used.
*
\***************************************************************************/

VOID
CreatePen_Gdiplus()
{
    DashCap dashCap;
    LineCap lineCap;
    LineJoin lineJoin;
    DashStyle dashStyle;
    PenAlignment alignment;

    delete RenderPen;

    RenderPen = new Pen(Color((BYTE) RenderAlpha, 255, 0, 0), (REAL) RenderWidth);

    switch (MmEndCap)
    {
    case MM_CAP_ROUND: lineCap = LineCapRound; dashCap = DashCapRound; break;
    case MM_CAP_SQUARE: lineCap = LineCapSquare; dashCap = DashCapFlat; break;
    case MM_CAP_FLAT: lineCap = LineCapFlat; dashCap = DashCapFlat; break;
    case MM_CAP_TRIANGLE: lineCap = LineCapTriangle; dashCap = DashCapTriangle; break;
    }
    RenderPen->SetEndCap(lineCap);
    RenderPen->SetStartCap(lineCap);
    RenderPen->SetDashCap(dashCap);

    switch (MmJoin)
    {
    case MM_JOIN_ROUND: lineJoin = LineJoinRound; break;
    case MM_JOIN_BEVEL: lineJoin = LineJoinBevel; break;
    case MM_JOIN_MITER: lineJoin = LineJoinMiter; break;
    }
    RenderPen->SetLineJoin(lineJoin);

    switch (MmDashStyle)
    {
    case MM_STYLE_SOLID: dashStyle = DashStyleSolid; break;
    case MM_STYLE_DASH: dashStyle = DashStyleDash; break;
    case MM_STYLE_DOT: dashStyle = DashStyleDot; break;
    case MM_STYLE_DASHDOT: dashStyle = DashStyleDashDot; break;
    case MM_STYLE_DASHDOTDOT: dashStyle = DashStyleDashDotDot; break;
    }
    RenderPen->SetDashStyle(dashStyle);

    switch (MmAlignment)
    {
    case MM_ALIGNMENT_CENTER: alignment = PenAlignmentCenter; break;
    case MM_ALIGNMENT_INSET: alignment = PenAlignmentInset; break;
    }
    RenderPen->SetAlignment(alignment);

    RenderPen->SetMiterLimit(RenderMiterLimit);

    // We should add a 'compound array' UI to make this more flexible.
    // But for now, we only ever create one type of compound line:

    if (DoCompound)
    {
        REAL compoundArray[] = { 0.0f, 0.2f, 0.8f, 1.0f };
        RenderPen->SetCompoundArray(compoundArray, 4);
    }
}

/***************************************************************************\
* Creates the GDI pen to be used.
*
\***************************************************************************/

VOID
CreatePen_Gdi()
{
    DWORD lineCap;
    DWORD lineJoin;
    DWORD dashStyle;
    LOGBRUSH logBrush;

    DeleteObject(RenderHpen);

    switch (MmEndCap)
    {
    case MM_CAP_ROUND: lineCap = PS_ENDCAP_ROUND; break;
    case MM_CAP_SQUARE: lineCap = PS_ENDCAP_SQUARE; break;
    case MM_CAP_FLAT: lineCap = PS_ENDCAP_FLAT; break;
    case MM_CAP_TRIANGLE: lineCap = PS_ENDCAP_SQUARE; break;    // No equivalent
    }

    switch (MmJoin)
    {
    case MM_JOIN_ROUND: lineJoin = PS_JOIN_ROUND; break;
    case MM_JOIN_BEVEL: lineJoin = PS_JOIN_BEVEL; break;
    case MM_JOIN_MITER: lineJoin = PS_JOIN_MITER; break;
    }

    switch (MmDashStyle)
    {
    case MM_STYLE_SOLID: dashStyle = PS_SOLID; break;
    case MM_STYLE_DASH: dashStyle = PS_DASH; break;
    case MM_STYLE_DOT: dashStyle = PS_DOT; break;
    case MM_STYLE_DASHDOT: dashStyle = PS_DASHDOT; break;
    case MM_STYLE_DASHDOTDOT: dashStyle = PS_DASHDOTDOT; break;
    }

    logBrush.lbStyle = BS_SOLID;
    logBrush.lbColor = RGB(255, 0, 0);
    logBrush.lbHatch = 0;

    RenderHpen = ExtCreatePen(lineCap | lineJoin | dashStyle | PS_GEOMETRIC,
                              GDI_FIXEDPOINT_SCALE * RenderWidth,
                              &logBrush,
                              0,
                              NULL);
}

/***************************************************************************\
* Creates the GDI+ and GDI pens to be used.
*
\***************************************************************************/

VOID
CreatePens()
{
    CreatePen_Gdiplus();
    CreatePen_Gdi();
}

/***************************************************************************\
* Creates the GDI+ clip region to be used.
*
\***************************************************************************/

VOID
CreateRegion_Gdiplus()
{
    INT x;
    INT y;

    delete RenderRegion;
    
    RenderRegion = new Region();
    
    for (x = 0; x < WindowWidth; x += 128)
    {
        for (y = 0; y < WindowHeight; y += 128)
        {
            RenderRegion->Exclude(Rect(x + 64, y, 64, 64));
            RenderRegion->Exclude(Rect(x, y + 64, 64, 64));
        }
    }
}

/***************************************************************************\
* Creates the GDI clip region to be used.
*
\***************************************************************************/

VOID
CreateRegion_Gdi()
{
    INT x;
    INT y;
    HRGN hrgn;

    DeleteObject(RenderHrgn);

    RenderHrgn = CreateRectRgn(0, 0, WindowWidth, WindowHeight);

    hrgn = CreateRectRgn(0, 0, 0, 0);

    for (x = 0; x < WindowWidth; x += 128)
    {
        for (y = 0; y < WindowHeight; y += 128)
        {
            SetRectRgn(hrgn, x + 64, y, x + 128, y + 64);
            CombineRgn(RenderHrgn, RenderHrgn, hrgn, RGN_DIFF);

            SetRectRgn(hrgn, x, y + 64, x + 64, y + 128);
            CombineRgn(RenderHrgn, RenderHrgn, hrgn, RGN_DIFF);
        }
    }

    DeleteObject(hrgn);
}

/***************************************************************************\
* Free all our global objects.
*
\***************************************************************************/

VOID
DeleteObjects_Gdiplus()
{
    delete RenderRegion;
    delete RenderBrush;
    delete RenderPen;

    delete PrimitiveTransform;
    delete PrimitiveInverseTransform;
}

/***************************************************************************\
* Free all our global objects.
*
\***************************************************************************/

VOID
DeleteObjects_Gdi()
{
    DeleteObject(RenderHrgn);
    DeleteObject(RenderHbrush);
    DeleteObject(RenderHpen);
}

/***************************************************************************\
* Draw the control points
*
\***************************************************************************/

VOID
DrawAnchors(
    Graphics *g,
    PointF* points,
    INT count
    )
{
    SolidBrush blueBrush(Color(150, 128, 128, 128));

    for (; count != 0; count--, points++)
    {
        PointF point(*points);

        PrimitiveTransform->TransformPoints(&point, 1);

        g->FillRectangle(&blueBrush, RectF(point.X - 2, point.Y - 2, 5, 5));
    }
}

/***************************************************************************\
* DrawTransformOverlay
*
\***************************************************************************/

VOID
DrawTransformOverlay(
    Graphics *g
    )
{
    Pen pen(Color::Purple, 1);
    SolidBrush brush(Color::Purple);

    g->DrawLine(&pen, OverlayPoints[1].X, OverlayPoints[1].Y,
                      OverlayPoints[0].X, OverlayPoints[0].Y);
    g->DrawLine(&pen, OverlayPoints[1].X, OverlayPoints[1].Y,
                      OverlayPoints[2].X, OverlayPoints[2].Y);

    g->FillRectangle(&brush, RectF(OverlayPoints[0].X - 2, 
                                   OverlayPoints[0].Y - 2, 
                                   5, 
                                   5));

    g->FillRectangle(&brush, RectF(OverlayPoints[2].X - 2, 
                                   OverlayPoints[2].Y - 2, 
                                   5, 
                                   5));
}

/***************************************************************************\
* Render_Gdiplus
*
\***************************************************************************/

INT
Render_Gdiplus(
    Graphics *g,
    PointF *points,
    INT count
    )
{
    INT i;
    INT pointsUsed;

//    if (DoBrushRect)
//    {
//        LinearBrush->SetLinearPoints(points[0], points[1]);
//    }

    RectF rect(points[0].X, points[0].Y, 
               points[1].X - points[0].X, points[1].Y - points[0].Y);

    Pen spinePen(Color(0, 128, 0), 0);
    GraphicsPath shapePath;

    switch (MmPrimitive)
    {
        case MM_POLYGON:
        {
            shapePath.AddPolygon(points, count);
            if (!DoShape)
            {
                if (DoFill)
                    g->FillPolygon(RenderBrush, points, count, (DoWindingFill) 
                                                        ? FillModeWinding
                                                        : FillModeAlternate);
                if (DoDraw)
                    g->DrawPolygon(RenderPen, points, count);
                if (DoSpine)
                    g->DrawPolygon(&spinePen, points, count);
            }

            pointsUsed = count;
            break;
        }

        case MM_LINES:
        {
            shapePath.AddLines(points, count);
            if (!DoShape)
            {
                if (DoDraw)
                    g->DrawLines(RenderPen, points, count);
                if (DoSpine)
                    g->DrawLines(&spinePen, points, count);
            }

            pointsUsed = count;
            break;
        }
    
        case MM_BEZIER:
        {
            GraphicsPath path;
            path.AddBeziers(points, count);

            shapePath.AddPath(&path, FALSE);
            if (!DoShape)
            {
                if (DoFill)
                    g->FillPath(RenderBrush, &path);
                if (DoDraw)
                    g->DrawPath(RenderPen, &path);
                if (DoSpine)
                    g->DrawPath(&spinePen, &path);
            }

            pointsUsed = count;
            break;
        }
    
        case MM_RECTANGLE:
        {
            shapePath.AddRectangle(rect);
            if (!DoShape)
            {
                if (DoFill)
                    g->FillRectangle(RenderBrush, rect);
                if (DoDraw)
                    g->DrawRectangle(RenderPen, rect);
                if (DoSpine)
                    g->DrawRectangle(&spinePen, rect);
            }

            pointsUsed = 2;
            break;
        }
    
        case MM_ELLIPSE:
        {
            shapePath.AddEllipse(rect);
            if (!DoShape)
            {
                if (DoFill)
                    g->FillEllipse(RenderBrush, rect);  
                if (DoDraw)
                    g->DrawEllipse(RenderPen, rect);
                if (DoSpine)
                    g->DrawEllipse(&spinePen, rect);
            }

            pointsUsed = 2;
            break;
        }
    
        case MM_TEXTPATH:
        {
            WCHAR string[] = L"GDI+ Rules!";
            GraphicsPath path((DoWindingFill) ? FillModeWinding
                                              : FillModeAlternate);

            FontFamily family(L"Times New Roman");
            PointF origin(points[0].X, points[0].Y);
    
            path.AddString(
                string, 
                wcslen(string), 
                &family, 
                0, 
                200, 
                origin, 
                NULL
            );

            shapePath.AddPath(&path, FALSE);
            if (!DoShape)
            {
                if (DoFill)
                    g->FillPath(RenderBrush, &path);
                if (DoDraw)
                    g->DrawPath(RenderPen, &path);
                if (DoSpine)
                    g->DrawPath(&spinePen, &path);
            }

            pointsUsed = 1;
            break;
        }
    }

    if (DoShape)
    {
        // Recreate the path to be use for the path-gradient brush, 
        // using the new shape data:

        delete PathGradientPath;
        PathGradientPath = shapePath.Clone();

        // Recreate the brush and do a complete fill of the window using
        // the specified brush:

        CreateBrushes();

        if (DoFill)
            g->FillRectangle(RenderBrush, -262144, -262144, 524288, 524288);
        if (DoDraw)
            g->DrawPath(RenderPen, &shapePath);
        if (DoSpine)
            g->DrawPath(&spinePen, &shapePath);
    }

    if (DoWiden)
    {
        Pen widenPen(Color::Black, 0);

        shapePath.Widen(RenderPen, NULL);

        g->DrawPath(&widenPen, &shapePath);
    }

    return(pointsUsed);
}

/***************************************************************************\
* Render_Gdi
*
\***************************************************************************/

INT
Render_Gdi(
    HDC hdc,
    PointF *primitivePoints,
    INT count
    )
{
    BOOL drawSpine;
    HGDIOBJ oldPen;
    HGDIOBJ oldBrush;
    HPEN hpenSpine;
    INT pointsUsed;
    POINT points[PrimitivePointsMax];
    INT i;

    // Convert to integer, the preferred GDI format.  Remember that we've
    // set the transform to scale down by 16, so we have to multiply by
    // 16 here.  We've done this so that we can specify 28.4 directly to
    // GDI:

    for (i = 0; i < count; i++)
    {
        points[i].x = ROUND(GDI_FIXEDPOINT_SCALE * primitivePoints[i].X);
        points[i].y = ROUND(GDI_FIXEDPOINT_SCALE * primitivePoints[i].Y);
    }

    hpenSpine = CreatePen(PS_SOLID, 0, RGB(0, 128, 0));

    for (drawSpine = FALSE; drawSpine != TRUE; drawSpine = TRUE)
    {
        if (drawSpine)
        {
            oldPen = SelectObject(hdc, hpenSpine);
            oldBrush = SelectObject(hdc, GetStockObject(NULL_BRUSH));
        }
        else
        {
            oldPen = SelectObject(hdc,                                             
                    (DoDraw) ? RenderHpen : GetStockObject(NULL_PEN));     
            oldBrush = SelectObject(hdc,                                           
                    (DoFill) ? RenderHbrush : GetStockObject(NULL_BRUSH)); 
        }

        switch (MmPrimitive)
        {
            case MM_POLYGON:
            {
                Polygon(hdc, points, count);

                pointsUsed = count;
                break;
            }

            case MM_LINES:
            {
                Polyline(hdc, points, count);

                pointsUsed = count;
                break;
            }
        
            case MM_BEZIER:
            {
                // Don't use StrokeAndFillPath because GDI would close the
                // stroke:

                BeginPath(hdc);
                PolyBezier(hdc, points, count);
                EndPath(hdc);
                FillPath(hdc);

                BeginPath(hdc);
                PolyBezier(hdc, points, count);
                EndPath(hdc);
                StrokePath(hdc);

                pointsUsed = count;
                break;
            }
        
            case MM_RECTANGLE:
            {
                Rectangle(hdc, points[0].x, points[0].y, points[1].x, points[1].y);

                pointsUsed = 2;
                break;
            }
        
            case MM_ELLIPSE:
            {
                Ellipse(hdc, points[0].x, points[0].y, points[1].x, points[1].y);

                pointsUsed = 2;
                break;
            }
        
            case MM_TEXTPATH:
            {
                LOGFONT logFont;
                memset(&logFont, 0, sizeof(logFont));

                // Don't forget to multiply the height by 16, because
                // we're using a scaling transform with GDI so that we
                // can spit out 28.4 coordinates:

                logFont.lfHeight = - GDI_FIXEDPOINT_SCALE * 200;   
                strcpy(logFont.lfFaceName, "Times New Roman");

                SetBkMode(hdc, TRANSPARENT);

                HFONT font = CreateFontIndirect(&logFont);
                HGDIOBJ oldFont = SelectObject(hdc, font);
    
                WCHAR string[] = L"GDI+ Rules!";
                BeginPath(hdc);
                ExtTextOutW(hdc, points[0].x, points[0].y, 0, NULL, string, 
                            wcslen(string), NULL);
                EndPath(hdc);
                StrokeAndFillPath(hdc);

                SelectObject(hdc, oldFont);
                DeleteObject(font);

                pointsUsed = 1;
            }
        }

        SelectObject(hdc, oldBrush);
        SelectObject(hdc, oldPen);
    }

    DeleteObject(hpenSpine);

    return(pointsUsed);
}

/***************************************************************************\
* PrepareContext_Gdiplus
*
\***************************************************************************/

VOID
PrepareContext_Gdiplus(
    Graphics *g
    )
{
    g->SetSmoothingMode((DoAntialias) ? SmoothingModeAntiAlias
                                      : SmoothingModeNone);
    
    g->SetCompositingQuality((DoGammaCorrect) ? 
        CompositingQualityGammaCorrected : CompositingQualityAssumeLinear);

    if (DoClipGrid)
    {
        g->SetClip(RenderRegion);
    }

    g->SetTransform(PrimitiveTransform);
}

/***************************************************************************\
* PrepareContext_Gdi
*
\***************************************************************************/

VOID
PrepareContext_Gdi(
    HDC hdc
    )
{
    REAL m[6];
    XFORM xform;

    SetMiterLimit(hdc, RenderMiterLimit, NULL);

    SetPolyFillMode(hdc, (DoWindingFill) ? WINDING : ALTERNATE);

    if (DoClipGrid)
    {
        SelectClipRgn(hdc, RenderHrgn);
    }

    // Setup the transform:

    PrimitiveTransform->GetElements(m);

    // Scale the transform down by 16 so that we can give GDI 28.4 
    // coordinates directly as integers:

    xform.eM11 = m[0] / GDI_FIXEDPOINT_SCALE;
    xform.eM12 = m[1] / GDI_FIXEDPOINT_SCALE;
    xform.eM21 = m[2] / GDI_FIXEDPOINT_SCALE;
    xform.eM22 = m[3] / GDI_FIXEDPOINT_SCALE;
    xform.eDx = m[4];
    xform.eDy = m[5];

    SetGraphicsMode(hdc, GM_ADVANCED);

    SetWorldTransform(hdc, &xform);
}

/***************************************************************************\
* GenerateRandomPoints
*
\***************************************************************************/

INT
GenerateRandomPoints(
    PointF *randomPoints,
    INT maxPoints
    )
{
    INT randomPointsCount;
    INT i;

    // Make 1 in 32 have lotsa randomPoints:

    if ((rand() & 31) == 0)
    {
        randomPointsCount = rand() & 511;
    }
    else
    {
        randomPointsCount = (rand() & 7) + 1;
    }

    randomPointsCount = min(randomPointsCount, maxPoints);

    // !!! Need to randomize

    switch (rand() & 3)
    {
    case 0:     // Trivially clipped
        for (i = 0; i < randomPointsCount; i++)
        {
            randomPoints[i].X = (rand() % (16 * WindowWidth * 16)) / 16.0f;
            randomPoints[i].Y = (rand() % (16 * WindowHeight)) / 16.0f;
        }
        break;

    case 1:     // Really small
        for (i = 0; i < randomPointsCount; i++)
        {
            randomPoints[i].X = (rand() & 127) / 16.0f + 32;
            randomPoints[i].Y = (rand() & 127) / 16.0f + 32;
        }
        break;

    default:     // Big space, with at least one point inside window:
        randomPoints[0].X = (rand() % (16 * WindowWidth)) / 16.0f;
        randomPoints[0].Y = (rand() % (16 * WindowHeight)) / 16.0f;

        if (0)
        {
            for (i = 1; i < randomPointsCount; i++)
            {
                // Once in a while, make the points REALLY REALLY big:

                randomPoints[i].X = (REAL) (rand() * rand() * rand());
                randomPoints[i].Y = (REAL) (rand() * rand() * rand());
            }
        }
        else
        {
            for (i = 1; i < randomPointsCount; i++)
            {
                randomPoints[i].X = (rand() % 1000000 - 500000) / 16.0f;
                randomPoints[i].Y = (rand() % 1000000 - 500000) / 16.0f;
            }
        }
        break;
    }

    return(randomPointsCount);
}

/***************************************************************************\
* Draw
*
\***************************************************************************/

VOID
Draw(
    HDC hdc,
    BOOL doTime = FALSE
    )
{
    CHAR stringBuffer[200];
    LONGLONG startCounter;
    LONGLONG endCounter;
    LONGLONG counterFrequency;
    INT pointsUsed;
    INT repetitions = (doTime) ? 10 : 1;
    INT i;

    // Clear the window:

    HGDIOBJ hbrush = GetStockObject(WHITE_BRUSH);
    HGDIOBJ holdBrush = SelectObject(hdc, hbrush);
    PatBlt(hdc, -10000, -10000, 20000, 20000, PATCOPY);
    SelectObject(hdc, holdBrush);
    DeleteObject(hbrush);

    QueryPerformanceCounter((LARGE_INTEGER*) &startCounter);

    // Draw the stuff:

    if (DoGdi)
    {
        SaveDC(hdc);

        PrepareContext_Gdi(hdc);

        for (i = 0; i < repetitions; i++)
        {
            pointsUsed = Render_Gdi(hdc, PrimitivePoints, PrimitivePointsCount);
        }

        RestoreDC(hdc, -1);
    }
    else
    {
        Graphics g(hdc);
        PrepareContext_Gdiplus(&g);

        if (!DoRandomTest)
        {
            for (i = 0; i < repetitions; i++)
            {
                pointsUsed = Render_Gdiplus(&g, PrimitivePoints, PrimitivePointsCount);
            }
        }
        else
        {
            PointF points[512];
            INT count;

            // To get faster 'test' rendering (by avoiding clears between
            // successive tests), always draw in a batch of '20':

            for (i = 0; i < 20; i++)
            {
                count = GenerateRandomPoints(points, 512);
                pointsUsed = Render_Gdiplus(&g, points, count);
            }
        }
    }

    // Display the time:

    QueryPerformanceCounter((LARGE_INTEGER*) &endCounter);
    QueryPerformanceFrequency((LARGE_INTEGER*) &counterFrequency);

    float seconds = (float)(endCounter - startCounter) / counterFrequency;
    INT milliseconds = (INT) (seconds * 1000 + 0.5f);

    if (doTime)
    {
        sprintf(stringBuffer, "%li repetitions: %li ms", repetitions, milliseconds);
    }
    else
    {
        sprintf(stringBuffer, "Rasterization time: %li ms", milliseconds);
    }

    SetBkMode(hdc, TRANSPARENT);
    ExtTextOut(hdc, 0, 0, 0, NULL, stringBuffer, strlen(stringBuffer), NULL);

    if (!DoRandomTest)
    {
        // Now that we're out of the timing loop, draw our control points:
    
        Graphics g(hdc);

        if (DoAnchors)
        {
            DrawAnchors(&g, PrimitivePoints, pointsUsed);
        }
    
        if (DoTransformOverlay)
        {
            DrawTransformOverlay(&g);
        }
    }
}

/***************************************************************************\
* EnterWidth
*
* Dialog for entering pen width.
\***************************************************************************/

INT_PTR EnterWidth(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    BOOL    bTrans;

    switch (message)
    {
    case WM_INITDIALOG:
        SetDlgItemInt(hDlg, IDD_WIDTH, RenderWidth, TRUE);
        return(TRUE);

    case WM_COMMAND:
        if (wParam == IDD_OK)
        {
            RenderWidth = GetDlgItemInt(hDlg, IDD_WIDTH, &bTrans, TRUE);
            EndDialog(hDlg, wParam);
            InvalidateRect(ghwndMain, NULL, TRUE);
        }
        break;

    case WM_SETFOCUS:
        SetFocus(GetDlgItem(hDlg, IDD_WIDTH));
        return(FALSE);

    default:
        return(FALSE);
    }

    return(TRUE);
}

/***************************************************************************\
* EnterAlpha
*
* Dialog for entering pen alpha.
\***************************************************************************/

INT_PTR EnterAlpha(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    BOOL    bTrans;

    switch (message)
    {
    case WM_INITDIALOG:
        SetDlgItemInt(hDlg, IDD_ALPHA, RenderAlpha, TRUE);
        return(TRUE);

    case WM_COMMAND:
        if (wParam == IDD_OK)
        {
            RenderAlpha = GetDlgItemInt(hDlg, IDD_ALPHA, &bTrans, TRUE);
            EndDialog(hDlg, wParam);
            InvalidateRect(ghwndMain, NULL, TRUE);
        }
        break;

    case WM_SETFOCUS:
        SetFocus(GetDlgItem(hDlg, IDD_ALPHA));
        return(FALSE);

    default:
        return(FALSE);
    }

    return(TRUE);
}

/***************************************************************************\
* EnterPoints
*
* Dialog for entering points.
\***************************************************************************/

INT_PTR EnterPoints(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    BOOL    bTrans;
    INT     i;

    switch (message)
    {
    case WM_INITDIALOG:
        SetDlgItemInt(hDlg, IDD_POINT1X, ROUND(PrimitivePoints[0].X), TRUE);
        SetDlgItemInt(hDlg, IDD_POINT1Y, ROUND(PrimitivePoints[0].Y), TRUE);
        SetDlgItemInt(hDlg, IDD_POINT2X, ROUND(PrimitivePoints[1].X), TRUE);
        SetDlgItemInt(hDlg, IDD_POINT2Y, ROUND(PrimitivePoints[1].Y), TRUE);
        SetDlgItemInt(hDlg, IDD_POINT3X, ROUND(PrimitivePoints[2].X), TRUE);
        SetDlgItemInt(hDlg, IDD_POINT3Y, ROUND(PrimitivePoints[2].Y), TRUE);
        SetDlgItemInt(hDlg, IDD_POINT4X, ROUND(PrimitivePoints[3].X), TRUE);
        SetDlgItemInt(hDlg, IDD_POINT4Y, ROUND(PrimitivePoints[3].Y), TRUE);
        return(TRUE);

    case WM_COMMAND:
        if (wParam == IDD_OK)
        {
            PrimitivePoints[0].X = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT1X, &bTrans, TRUE);
            PrimitivePoints[0].Y = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT1Y, &bTrans, TRUE);
            PrimitivePoints[1].X = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT2X, &bTrans, TRUE);
            PrimitivePoints[1].Y = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT2Y, &bTrans, TRUE);
            PrimitivePoints[2].X = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT3X, &bTrans, TRUE);
            PrimitivePoints[2].Y = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT3Y, &bTrans, TRUE);
            PrimitivePoints[3].X = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT4X, &bTrans, TRUE);
            PrimitivePoints[3].Y = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT4Y, &bTrans, TRUE);

            EndDialog(hDlg, wParam);
            InvalidateRect(ghwndMain, NULL, TRUE);
        }
        break;

    case WM_SETFOCUS:
        SetFocus(GetDlgItem(hDlg, IDD_POINT1X));
        return(FALSE);

    default:
        return(FALSE);
    }

    return(TRUE);
}

/***************************************************************************\
* EnterTransform
*
* Dialog for entering arbitrary transforms.
\***************************************************************************/

INT_PTR EnterTransform(
    HWND    hDlg,
    WORD    message,
    WPARAM  wParam,
    LONG    lParam)
{
    BOOL    bTrans;
    REAL    m[6];

    PrimitiveTransform->GetElements(m);

    switch (message)
    {
    case WM_INITDIALOG:
        SetDlgItemInt(hDlg, IDD_M11, ROUND(m[0] * 1000.0f), TRUE);
        SetDlgItemInt(hDlg, IDD_M12, ROUND(m[1] * 1000.0f), TRUE);
        SetDlgItemInt(hDlg, IDD_M21, ROUND(m[2] * 1000.0f), TRUE);
        SetDlgItemInt(hDlg, IDD_M22, ROUND(m[3] * 1000.0f), TRUE);
        SetDlgItemInt(hDlg, IDD_M31, ROUND(m[4] * 1000.0f), TRUE);
        SetDlgItemInt(hDlg, IDD_M32, ROUND(m[5] * 1000.0f), TRUE);
        return(TRUE);

    case WM_COMMAND:
        if (wParam == IDD_OK)
        {
            m[0] = ((INT) GetDlgItemInt(hDlg, IDD_M11, &bTrans, TRUE)) / 1000.0f;
            m[1] = ((INT) GetDlgItemInt(hDlg, IDD_M12, &bTrans, TRUE)) / 1000.0f;
            m[2] = ((INT) GetDlgItemInt(hDlg, IDD_M21, &bTrans, TRUE)) / 1000.0f;
            m[3] = ((INT) GetDlgItemInt(hDlg, IDD_M22, &bTrans, TRUE)) / 1000.0f;
            m[4] = ((INT) GetDlgItemInt(hDlg, IDD_M31, &bTrans, TRUE)) / 1000.0f;
            m[5] = ((INT) GetDlgItemInt(hDlg, IDD_M32, &bTrans, TRUE)) / 1000.0f;

            PrimitiveTransform->SetElements(m[0], m[1], m[2], m[3], m[4], m[5]);
            PrimitiveInverseTransform->SetElements(m[0], m[1], m[2], m[3], m[4], m[5]);
            PrimitiveInverseTransform->Invert();

            // Calculate the new world-space elbow location:

            OverlayOffset.X = OverlayPoints[1].X;
            OverlayOffset.Y = OverlayPoints[1].Y;
            PrimitiveInverseTransform->TransformPoints(&OverlayOffset);

            // Now calculate the new device-space end-points, by initializing
            // in world-space and then converting back to device-space:

            OverlayPoints[0].X = OverlayOffset.X + OverlayDimension;
            OverlayPoints[0].Y = OverlayOffset.Y;

            OverlayPoints[2].X = OverlayOffset.X;
            OverlayPoints[2].Y = OverlayOffset.Y - OverlayDimension;

            PrimitiveTransform->TransformPoints(&OverlayPoints[0]);
            PrimitiveTransform->TransformPoints(&OverlayPoints[2]);

            // We're done; force a redraw:

            EndDialog(hDlg, wParam);
            InvalidateRect(ghwndMain, NULL, TRUE);
        }
        break;

    case WM_SETFOCUS:
        SetFocus(GetDlgItem(hDlg, IDD_OK));
        return(FALSE);

    default:
        return(FALSE);
    }

    return(TRUE);
}

/***************************************************************************\
* ComputeOverlayTransformFromPoints
*
\***************************************************************************/

VOID
ComputeOverlayTransformFromPoints()
{
    REAL dx1 = OverlayPoints[0].X - OverlayPoints[1].X;
    REAL dy1 = OverlayPoints[0].Y - OverlayPoints[1].Y;

    REAL dx2 = OverlayPoints[1].X - OverlayPoints[2].X;
    REAL dy2 = OverlayPoints[1].Y - OverlayPoints[2].Y;

    REAL xMid = (REAL) (WindowWidth >> 1);
    REAL yMid = (REAL) (WindowHeight >> 1);

    RectF srcRect(OverlayOffset.X, OverlayOffset.Y, OverlayDimension, OverlayDimension);

    // The order is upper-left, upper-right, lower-left corner:

    PointF dstPoints[] = { PointF(xMid, yMid),
                           PointF(xMid + dx1, yMid + dy1),
                           PointF(xMid + dx2, yMid + dy2) };

    delete PrimitiveTransform;
    PrimitiveTransform = new Matrix(srcRect, dstPoints);

    delete PrimitiveInverseTransform;
    PrimitiveInverseTransform = PrimitiveTransform->Clone();
    PrimitiveInverseTransform->Invert();
}

/***************************************************************************\
* CreateOverlayTransform
*
\***************************************************************************/

VOID
CreateOverlayTransform()
{
    REAL xMid = (REAL) (WindowWidth >> 1);
    REAL yMid = (REAL) (WindowHeight >> 1);

    OverlayPoints[0].X = xMid + OverlayDimension;
    OverlayPoints[0].Y = yMid;
    OverlayPoints[1].X = xMid;
    OverlayPoints[1].Y = yMid;
    OverlayPoints[2].X = xMid;
    OverlayPoints[2].Y = yMid - OverlayDimension;

    OverlayOffset.X = xMid;
    OverlayOffset.Y = yMid;

    ComputeOverlayTransformFromPoints();
}

/***************************************************************************\
* UpdateOverlay
*
\***************************************************************************/

VOID
UpdateOverlay(
    REAL x,
    REAL y
    )
{
    if (OverlayDragVertex == 1)
    {
        // The root of the overlay is being moved, so we move the overlay
        // as a whole:

        REAL dx = x - OverlayPoints[1].X;
        REAL dy = y - OverlayPoints[1].Y;

        OverlayPoints[0].X += dx;
        OverlayPoints[0].Y += dy;
        OverlayPoints[1].X = x;
        OverlayPoints[1].Y = y;
        OverlayPoints[2].X += dx;
        OverlayPoints[2].Y += dy;
    }
    else
    {
        OverlayPoints[OverlayDragVertex].X = x;
        OverlayPoints[OverlayDragVertex].Y = y;

        ComputeOverlayTransformFromPoints();
    }
}

/***************************************************************************\
* RecenterOverlay
*
\***************************************************************************/

VOID
RecenterOverlay()
{
    REAL xMid = (REAL) (WindowWidth >> 1);
    REAL yMid = (REAL) (WindowHeight >> 1);

    REAL dx = xMid - OverlayPoints[1].X;
    REAL dy = yMid - OverlayPoints[1].Y;

    // Center the transform around the new world-space focus point:

    OverlayOffset.X = OverlayPoints[1].X;
    OverlayOffset.Y = OverlayPoints[1].Y;

    if (PrimitiveInverseTransform != NULL)
    {
        PrimitiveInverseTransform->TransformPoints(&OverlayOffset, 1);
    }

    // Bring the overlay control back to the middle of the screen:

    OverlayPoints[0].X += dx;
    OverlayPoints[0].Y += dy;
    OverlayPoints[1].X = xMid;
    OverlayPoints[1].Y = yMid;
    OverlayPoints[2].X += dx;
    OverlayPoints[2].Y += dy;

    ComputeOverlayTransformFromPoints();
}

/***************************************************************************\
* FindNearest
*
\***************************************************************************/

INT
FindNearest(
    REAL x,                         // Device space
    REAL y,
    const PointF *points,           // World space
    INT count,
    const Matrix *matrix = NULL     // World-to-device transform
    )
{
    INT i;
    REAL d;
    REAL minDistance;
    INT vertex;

    PointF inputPoint(x, y);

    // Find the nearest vertex, using a simple Manhattan metric.

    minDistance = 100000;

    for (i = 0; i < count; i++)
    {
        PointF point(points[i]);

        // For the distance metric, we want to be doing our calculations
        // in device space:

        if (matrix)
        {
            matrix->TransformPoints(&point, 1);
        }

        d = ABS(x - point.X) + ABS(y - point.Y);

        if (d < minDistance)
        {
            minDistance = d;
            vertex = i;
        }
    }

    return((minDistance < HIT_DISTANCE) ? vertex : -1);
}

/***************************************************************************\
* MainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LRESULT
MainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PointF point;
    LONG i;
    LONG d;
    LONG minDistance;
    LONG vertex;
    HDC hdc;
    PAINTSTRUCT ps;

    HMENU hmenu = GetMenu(hwnd);
    WORD mmCommand = LOWORD(wParam);

    switch (message)
    {
    case WM_CREATE:
        glpfnEnterWidth = (FARPROC) MakeProcInstance(EnterWidth, ghwndMain);
        glpfnEnterAlpha = (FARPROC) MakeProcInstance(EnterAlpha, ghwndMain);
        glpfnEnterPoints = (FARPROC) MakeProcInstance(EnterPoints, ghwndMain);
        glpfnEnterTransform = (FARPROC) MakeProcInstance(EnterTransform, ghwndMain);

        SetTimer(hwnd, 1, 80, NULL);
        break;

    case WM_COMMAND:

        switch(mmCommand)
        {
        case MM_RANDOMTEST:
            DoRandomTest = !DoRandomTest;
            if (!DoRandomTest)
                InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_WIDTH:
            DialogBox(ghInstance, "Width", ghwndMain, (DLGPROC) glpfnEnterWidth);
            CreatePens();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_ALPHA:
            DialogBox(ghInstance, "Alpha", ghwndMain, (DLGPROC) glpfnEnterAlpha);
            CreatePens();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_POINTS:
            DialogBox(ghInstance, "Points", ghwndMain, (DLGPROC) glpfnEnterPoints);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_EDITTRANSFORM:
            DialogBox(ghInstance, "Transform", ghwndMain, (DLGPROC) glpfnEnterTransform);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_REDRAW:
            hdc = GetDC(hwnd);
            Draw(hdc);
            ReleaseDC(hwnd, hdc);
            break;

        case MM_TIME:
            hdc = GetDC(hwnd);
            Draw(hdc, TRUE);
            ReleaseDC(hwnd, hdc);
            break;

        case MM_CLIPGRID:
            DoClipGrid = !DoClipGrid;
            CheckMenuItem(hmenu, mmCommand, DoClipGrid ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_ANTIALIAS:
            DoAntialias = !DoAntialias;
            CheckMenuItem(hmenu, mmCommand, DoAntialias ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_GAMMACORRECT:
            DoGammaCorrect = !DoGammaCorrect;
            CheckMenuItem(hmenu, mmCommand, DoGammaCorrect ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_WINDING:
            DoWindingFill = !DoWindingFill;
            CheckMenuItem(hmenu, mmCommand, DoWindingFill ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_SPINE:
            DoSpine = !DoSpine;
            CheckMenuItem(hmenu, mmCommand, DoSpine ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_WIDENPATH:
            DoWiden = !DoWiden;
            CheckMenuItem(hmenu, mmCommand, DoWiden ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_ANCHORS:
            DoAnchors = !DoAnchors;
            CheckMenuItem(hmenu, mmCommand, DoAnchors ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_TRANSFORMOVERLAY:
            DoTransformOverlay = !DoTransformOverlay;
            CheckMenuItem(hmenu, mmCommand, DoTransformOverlay ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_SCALINGONLY:
            DoScalingOnly = !DoScalingOnly;
            CheckMenuItem(hmenu, mmCommand, DoScalingOnly ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_RESETTRANSFORM:
            CreateOverlayTransform();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_FILL:
            DoFill = !DoFill;
            CheckMenuItem(hmenu, mmCommand, DoFill ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_DRAW:
            DoDraw = !DoDraw;
            CheckMenuItem(hmenu, mmCommand, DoDraw ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_POLYGON:
        case MM_LINES:
        case MM_BEZIER:
        case MM_RECTANGLE:
        case MM_ELLIPSE:
        case MM_TEXTPATH:
            CheckMenuItem(hmenu, MmPrimitive, MF_UNCHECKED);
            MmPrimitive = mmCommand;
            CheckMenuItem(hmenu, MmPrimitive, MF_CHECKED);

            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_COMPOUND:
            DoCompound = !DoCompound;
            CheckMenuItem(hmenu, mmCommand, DoCompound ? MF_CHECKED : MF_UNCHECKED);
            CreatePens();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_STYLE_SOLID:
        case MM_STYLE_DASH:
        case MM_STYLE_DOT:
        case MM_STYLE_DASHDOT:
        case MM_STYLE_DASHDOTDOT:
            CheckMenuItem(hmenu, MmDashStyle, MF_UNCHECKED);
            MmDashStyle = mmCommand;
            CheckMenuItem(hmenu, MmDashStyle, MF_CHECKED);

            CreatePens();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_CAP_FLAT:
        case MM_CAP_SQUARE:
        case MM_CAP_ROUND:
        case MM_CAP_TRIANGLE:
            CheckMenuItem(hmenu, MmEndCap, MF_UNCHECKED);
            MmEndCap = mmCommand;
            CheckMenuItem(hmenu, MmEndCap, MF_CHECKED);

            CreatePens();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_JOIN_ROUND:
        case MM_JOIN_MITER:
        case MM_JOIN_BEVEL:
            CheckMenuItem(hmenu, MmJoin, MF_UNCHECKED);
            MmJoin = mmCommand;
            CheckMenuItem(hmenu, MmJoin, MF_CHECKED);

            CreatePens();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_ALIGNMENT_CENTER: 
        case MM_ALIGNMENT_INSET: 
            CheckMenuItem(hmenu, MmAlignment, MF_UNCHECKED);
            MmAlignment = mmCommand;
            CheckMenuItem(hmenu, MmAlignment, MF_CHECKED);

            CreatePens();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_WRAP_TILE:
        case MM_WRAP_CLAMP:
        case MM_WRAP_FLIPX:
        case MM_WRAP_FLIPY:
        case MM_WRAP_FLIPXY:
            CheckMenuItem(hmenu, MmWrapMode, MF_UNCHECKED);
            MmWrapMode = mmCommand;
            CheckMenuItem(hmenu, MmWrapMode, MF_CHECKED);

            CreateBrushes();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_BRUSH_SOLID:
        case MM_BRUSH_TEXTURE:
        case MM_BRUSH_TEXTURE_32x32:
        case MM_BRUSH_TEXTURE_1x1:
        case MM_BRUSH_LINEAR:
        case MM_BRUSH_PATHGRADIENT:
            CheckMenuItem(hmenu, MmBrushType, MF_UNCHECKED);
            MmBrushType = mmCommand;
            CheckMenuItem(hmenu, MmBrushType, MF_CHECKED);

            CreateBrushes();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_DYNAMICBRUSHRECTANGLE:
            DoBrushRect = !DoBrushRect;
            CheckMenuItem(hmenu, mmCommand, DoBrushRect ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_EDITBRUSHSHAPE:
            DoShape = !DoShape;
            CheckMenuItem(hmenu, mmCommand, DoShape ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_GDI:
            DoGdi = !DoGdi;
            CheckMenuItem(hmenu, mmCommand, DoGdi ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        default:
            break;
        }
        break;

    case WM_SIZE:
        WindowWidth = (short)LOWORD(lParam);
        WindowHeight = (short)HIWORD(lParam);

        CreateRegion_Gdiplus();
        CreateRegion_Gdi();
        RecenterOverlay();

        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_LBUTTONDOWN:
        point.X = (REAL)(short)LOWORD(lParam);
        point.Y = (REAL)(short)HIWORD(lParam);

        // First, try to find a hit with the overlay.  Then try a hit with
        // the primitive points, in world space:

        OverlayDragVertex = -1;
        PrimitiveDragVertex = -1;

        if (DoTransformOverlay)
        {
            OverlayDragVertex = FindNearest(point.X, point.Y, OverlayPoints, 3);
        }

        if (OverlayDragVertex == -1)
        {
            PrimitiveDragVertex = FindNearest(point.X, point.Y, PrimitivePoints, 
                                  PrimitivePointsCount, PrimitiveTransform);
        }

        // The first left-click disables 'adding points' mode:

        IsAddingPoints = FALSE;

        break;

    case WM_RBUTTONDOWN:
        point.X = (REAL)(short)LOWORD(lParam);
        point.Y = (REAL)(short)HIWORD(lParam);
        PrimitiveInverseTransform->TransformPoints(&point, 1);

        // If we were in 'adding points' mode (which occurs when we're
        // right-clicking in succession), simply add the point to the
        // list.  
        //
        // If we're not in 'adding points' mode, reset the point list 
        // and switch us to 'adding points' mode:

        if (!IsAddingPoints)
        {
            IsAddingPoints = TRUE;
            PrimitivePointsCount = 0;
        }

        // Add this point to the list:

        if (PrimitivePointsCount < PrimitivePointsMax)
        {
            PrimitivePoints[PrimitivePointsCount] = point;
            PrimitivePointsCount++;

            // If this was the first point, make all the points the same
            // (in part to make 'ellipse' and 'rectangle' properly empty):

            if (PrimitivePointsCount == 1)
            {
                for (i = 1; i < PrimitivePointsMax; i++)
                {
                    PrimitivePoints[i] = PrimitivePoints[0];
                }
            }

            hdc = GetDC(hwnd);
            Draw(hdc);
            ReleaseDC(hwnd, hdc);
        }

        break;

    case WM_MOUSEMOVE:
        point.X = (REAL)(short)LOWORD(lParam);
        point.Y = (REAL)(short)HIWORD(lParam);

        // Overlay hit-testing works in screen space:
        
        if (OverlayDragVertex != -1)
        {
            // To prevent extraneous redraws, redraw only if the new point
            // is different:

            if ((OverlayPoints[OverlayDragVertex].X != point.X) ||
                (OverlayPoints[OverlayDragVertex].Y != point.Y))
            {
                UpdateOverlay(point.X, point.Y);
    
                hdc = GetDC(hwnd);
                Draw(hdc);
                ReleaseDC(hwnd, hdc);
            }
        }

        // Primitive hit-testing works in world space:

        PrimitiveInverseTransform->TransformPoints(&point, 1);

        if (PrimitiveDragVertex != -1)
        {
            // To prevent extraneous redraws, redraw only if the new point
            // is different:

            if ((PrimitivePoints[PrimitiveDragVertex].X != point.X) ||
                (PrimitivePoints[PrimitiveDragVertex].Y != point.Y))
            {
                PrimitivePoints[PrimitiveDragVertex] = point;
    
                hdc = GetDC(hwnd);
                Draw(hdc);
                ReleaseDC(hwnd, hdc);
            }
        }
        
        break;

    case WM_LBUTTONUP:
        PrimitiveDragVertex = -1;
        OverlayDragVertex = -1;

        RecenterOverlay();
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        Draw(hdc);
        ReleaseDC(hwnd, hdc);

        break;

    case WM_TIMER:
        if (DoRandomTest)
        {
            hdc = GetDC(hwnd);
            Draw(hdc);
            ReleaseDC(hwnd, hdc);
        }

        break;

    case WM_DESTROY:
        DeleteObjects_Gdiplus();
        DeleteObjects_Gdi();

        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/***************************************************************************\
* InitializeApplication()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL InitializeApplication(VOID)
{
    WNDCLASS wc;

    ghbrWhite = (HBRUSH) GetStockObject(WHITE_BRUSH);

    wc.style            = 0;
    wc.lpfnWndProc      = MainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(ghInstance, MAKEINTRESOURCE(POLYTESTICON));
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = "MainMenu";
    wc.lpszClassName    = "TestClass";
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        "TestClass",
        "PolyTest",
        (                      
            WS_OVERLAPPED   |  
            WS_CAPTION      |  
            WS_BORDER       |  
            WS_THICKFRAME   |  
            WS_MAXIMIZEBOX  |  
            WS_MINIMIZEBOX  |  
            WS_CLIPCHILDREN |  
            WS_VISIBLE      |  
            WS_SYSMENU         
        ),
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL
        );
    if (ghwndMain == NULL)
    {
        return(FALSE);
    }
    SetFocus(ghwndMain);

    // Create our initialize stuff:

    CreateBrushes();
    CreatePens();
    CreateOverlayTransform();

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }

    ghInstance = GetModuleHandle(NULL);

    if (!InitializeApplication())
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(ACCELS));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\samples\shapes\debug.h ===
/******************************Module*Header*******************************\
* Module Name: debug.h
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

extern void LBprintf(PCH, ...);
extern void LBreset(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\quadtest\quadtest.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   QuadTest.cpp
*
* Abstract:
*
*   Test app for quad transform
*
* Usage:
*   QuadTest
*
*
* Revision History:
*
*   03/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <windows.h>
#include <objbase.h>

#include <gdiplus.h>

// Use the given namespace
using namespace Gdiplus;

CHAR* programName;          // program name
HINSTANCE appInstance;      // handle to the application instance
HWND hwndMain;              // handle to application's main window
SIZE srcSize;               // source bitmap size
SIZE dstSize;               // destination bitmap size
SIZE wndSizeExtra;          // extra pixels for window decorations
BOOL isDragging = FALSE;    // used to handle mouse dragging
INT knobSize = 6;           // mesh control point knob size

BOOL showMesh = TRUE;

POINT pts[5];
INT   index = -1;
Rect srcRect;
Point ptsF[5];
Point pt00, pt10, pt20, pt30;
Point bPts[4];

class QuadGraphics : public Graphics
{
public:

    QuadGraphics(HDC hdc) : Graphics(hdc)
    {
    }

    QuadGraphics(HWND hwnd) : Graphics(hwnd)
    {
    }

    Status DrawWarpedLine(
        const Pen* pen,
        Point& pt1,
        Point& pt2,
        Point* points,
        INT count,
        Rect srcRect
        )
    {
        return SetStatus(DllExports::GdipDrawWarpedLine(
                GetNativeGraphics(),
                GetNativePen(pen),
                pt1.X,
                pt1.Y,
                pt2.X,
                pt2.Y,
                points,
                count,
                &srcRect
                )
            );
    }
    
    Status DrawWarpedBezier(
        const Pen* pen,
        Point& pt1,
        Point& pt2,
        Point& pt3,
        Point& pt4,
        Point* points,
        INT count,
        Rect srcRect
        )
    {
        return SetStatus(DllExports::GdipDrawWarpedBezier(
                GetNativeGraphics(),
                GetNativePen(pen),
                pt1.X,
                pt1.Y,
                pt2.X,
                pt2.Y,
                pt3.X,
                pt3.Y,
                pt4.X,
                pt4.Y,
                points,
                count,
                &srcRect
                )
            );
    }
};

//
// Display an error message dialog and quit
//

VOID
Error(
    const CHAR* fmt,
    ...
    )

{
    va_list arglist;

    va_start(arglist, fmt);
    vfprintf(stderr, fmt, arglist);
    va_end(arglist);

    exit(-1);
}


//
// Create a new mesh object
//

VOID
CreateMesh()
{
    srcSize.cx = 300;
    srcSize.cy = 300;

    dstSize = srcSize;
    INT offset = 10;
    pts[0].x = offset;
    pts[0].y = offset;
    pts[1].x = srcSize.cx - offset;
    pts[1].y = offset;
    pts[2].x = srcSize.cx - offset;
    pts[2].y = srcSize.cy - offset;
    pts[3].x = offset;
    pts[3].y = srcSize.cy - offset;
    pts[4] = pts[0];

    srcRect.X = (REAL) pts[0].x;
    srcRect.Y = (REAL) pts[0].y;
    srcRect.Width = (REAL) pts[2].x - pts[0].x;
    srcRect.Height = (REAL) pts[2].y - pts[0].y;

    ptsF[0].X = (REAL) pts[0].x;
    ptsF[0].Y = (REAL) pts[0].y;
    ptsF[1].X = (REAL) pts[1].x;
    ptsF[1].Y = (REAL) pts[1].y;
    ptsF[2].X = (REAL) pts[3].x;
    ptsF[2].Y = (REAL) pts[3].y;
    ptsF[3].X = (REAL) pts[2].x;
    ptsF[3].Y = (REAL) pts[2].y;

    pt00 = ptsF[0];
    pt10 = ptsF[1];
    pt20 = ptsF[2];
    pt30 = ptsF[3];

    bPts[0].X = (REAL) 2*offset;
    bPts[0].Y = (REAL) srcSize.cy/2;
    bPts[1].X = (REAL) srcSize.cx/2;
    bPts[1].Y = 0;
    bPts[2].X = (REAL) srcSize.cx;
    bPts[2].Y = (REAL) srcSize.cy/2;
    bPts[3].X = (REAL) 3*srcSize.cx/4;
    bPts[3].Y = (REAL) 3*srcSize.cy/4;
}

//
// Draw mesh
//

#define MESHCOLOR   RGB(255, 0, 0)

VOID
DrawMesh(
    HDC hdc
    )
{
    static HPEN meshPen = NULL;
    static HBRUSH meshBrush = NULL;

    if (meshPen == NULL)
        meshPen = CreatePen(PS_SOLID, 1, MESHCOLOR);

    SelectObject(hdc, meshPen);

    // Draw horizontal meshes

    INT i, j, rows, cols, pointCount;
    POINT* points;

    // Draw knobs

    // Create the brush to draw the mesh if necessary

    if (meshBrush == NULL)
        meshBrush = CreateSolidBrush(MESHCOLOR);

    Polyline(hdc, pts, 5);
    
    for (j=0; j < 4; j++)
    {
        RECT rect;

        rect.left = pts[j].x - knobSize/2;
        rect.top = pts[j].y - knobSize/2;
        rect.right = rect.left + knobSize;
        rect.bottom = rect.top + knobSize;

        FillRect(hdc, &rect, meshBrush);

    }
}


VOID
DoGDIPlusDrawing(
    HWND hwnd,
    HDC hdc
    )
{

//    QuadGraphics *g = Graphics::GetFromHwnd(hwnd);
    QuadGraphics *g = new QuadGraphics(hwnd);

    REAL width = 1;
    Color color(0, 0, 0);
    SolidBrush brush(color);
    Pen pen(&brush, width);

    ptsF[0].X = (REAL) pts[0].x;
    ptsF[0].Y = (REAL) pts[0].y;
    ptsF[1].X = (REAL) pts[1].x;
    ptsF[1].Y = (REAL) pts[1].y;
    ptsF[2].X = (REAL) pts[3].x;
    ptsF[2].Y = (REAL) pts[3].y;
    ptsF[3].X = (REAL) pts[2].x;
    ptsF[3].Y = (REAL) pts[2].y;

    g->DrawWarpedLine(&pen, pt00, pt30, ptsF, 4, srcRect);
    g->DrawWarpedLine(&pen, pt10, pt20, ptsF, 4, srcRect);
    g->DrawWarpedBezier(&pen, bPts[0], bPts[1], bPts[2], bPts[3],
                    ptsF, 4, srcRect);
    delete g;
}

//
// Handle window repaint event
//

VOID
DoPaint(
    HWND hwnd
    )

{
    HDC hdc;
    PAINTSTRUCT ps;
    RECT rect;
    INT width, height;

    // Determine if we need to perform warping operation

    GetClientRect(hwnd, &rect);
    width = rect.right;
    height = rect.bottom;

    hdc = BeginPaint(hwnd, &ps);

    HBRUSH brush = CreateSolidBrush(RGB(255, 255, 255));
    HBRUSH savedBrush = (HBRUSH) SelectObject(hdc, brush);
    Rectangle(hdc, 0, 0, width, height);

    DoGDIPlusDrawing(hwnd, hdc);

    // Draw to offscreen DC to reduce flashing

    DrawMesh(hdc);
    SelectObject(hdc, savedBrush);
    DeleteObject(brush);

    EndPaint(hwnd, &ps);
}


//
// Handle WM_SIZING message
//

BOOL
DoWindowSizing(
    HWND hwnd,
    RECT* rect,
    INT side
    )

{
    INT w = rect->right - rect->left - wndSizeExtra.cx;
    INT h = rect->bottom - rect->top - wndSizeExtra.cy;

    if (w >= srcSize.cx && h >= srcSize.cy)
        return FALSE;

    // Window width is too small

    if (w < srcSize.cx)
    {
        INT dx = srcSize.cx + wndSizeExtra.cx;

        switch (side)
        {
        case WMSZ_LEFT:
        case WMSZ_TOPLEFT:
        case WMSZ_BOTTOMLEFT:
            rect->left = rect->right - dx;
            break;
        
        default:
            rect->right = rect->left + dx;
            break;
        }
    }

    // Window height is too small

    if (h < srcSize.cy)
    {
        INT dy = srcSize.cy + wndSizeExtra.cy;

        switch (side)
        {
        case WMSZ_TOP:
        case WMSZ_TOPLEFT:
        case WMSZ_TOPRIGHT:
            rect->top = rect->bottom - dy;
            break;
        
        default:
            rect->bottom = rect->top + dy;
            break;
        }
    }

    return TRUE;
}


//
// Handle left mouse-down event
//

VOID
DoMouseDown(
    HWND hwnd,
    INT x,
    INT y
    )

{
    // Figure out if the click happened in a mesh control knob

    INT i, j, rows, cols;
    POINT pt;
    RECT rect;

    GetClientRect(hwnd, &rect);

    for(i = 0; i < 4; i++)
    {
        pt = pts[i];
        pt.x -= knobSize/2;
        pt.y -= knobSize/2;

        if (x >= pt.x && x < pt.x+knobSize &&
            y >= pt.y && y < pt.y+knobSize)
        {
            index = i;
            SetCapture(hwnd);
            isDragging = TRUE;
            return;
        }
    }

    index = -1;

}


//
// Handle mouse-move event
//

VOID
DoMouseMove(
    HWND hwnd,
    INT x,
    INT y
    )

{
    // We assume isDragging is true here.

    RECT rect;
    INT w, h;

    GetClientRect(hwnd, &rect);
    w = rect.right;
    h = rect.bottom;

    if (x < 0 || x >= w || y < 0 || y >= h)
        return;

    pts[index].x = x;
    pts[index].y = y;

    if(index == 0)
        pts[4] = pts[0];

    InvalidateRect(hwnd, NULL, FALSE);
}


//
// Handle menu command
//

VOID
DoCommand(
    HWND hwnd,
    INT command
    )
{
    InvalidateRect(hwnd, NULL, FALSE);
}


//
// Handle popup menu
//

VOID
DoPopupMenu(
    HWND hwnd,
    INT x,
    INT y
    )
{
    HMENU menu;
    DWORD result;
    POINT pt;

    GetCursorPos(&pt);
    menu = LoadMenu(appInstance, MAKEINTRESOURCE(IDM_MAINMENU));

    result = TrackPopupMenu(
                GetSubMenu(menu, 0),
                TPM_CENTERALIGN | TPM_TOPALIGN |
                    TPM_NONOTIFY | TPM_RETURNCMD |
                    TPM_RIGHTBUTTON,
                pt.x,
                pt.y,
                0,
                hwnd,
                NULL);

    if (result == 0)
        return;

    DoCommand(hwnd, LOWORD(result));
}


//
// Window callback procedure
//

LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

{
    INT x, y;

    switch (uMsg)
    {
    case WM_PAINT:

        DoPaint(hwnd);
        break;

    case WM_LBUTTONDOWN:

        if (showMesh)
        {
            x = (SHORT) LOWORD(lParam);
            y = (SHORT) HIWORD(lParam);
            DoMouseDown(hwnd, x, y);
        }
        break;

    case WM_LBUTTONUP:

        if (isDragging)
        {
            ReleaseCapture();
            isDragging = FALSE;
            InvalidateRect(hwnd, NULL, FALSE);
        }
        break;

    case WM_MOUSEMOVE:

        if (isDragging)
        {
            x = (SHORT) LOWORD(lParam);
            y = (SHORT) HIWORD(lParam);
            DoMouseMove(hwnd, x, y);
        }
        break;

    case WM_SIZING:

        if (DoWindowSizing(hwnd, (RECT*) lParam, wParam))
            return TRUE;
        else
            return DefWindowProc(hwnd, uMsg, wParam, lParam);

    case WM_SIZE:

        InvalidateRect(hwnd, NULL, FALSE);
        break;

    case WM_CHAR:

        switch ((CHAR) wParam)
        {
        case 'r':   // reset

            DoCommand(hwnd, IDC_RESETMESH);
            break;

        case ' ':   // show/hide mesh

            DoCommand(hwnd, IDC_TOGGLEMESH);
            break;

        case '1':   // restore 1-to-1 scale

            DoCommand(hwnd, IDC_SHRINKTOFIT);
            break;
        
        case '<':   // decrease mesh density

            DoCommand(hwnd, IDC_SPARSEMESH);
            break;

        case '>':   // increase mesh density

            DoCommand(hwnd, IDC_DENSEMESH);
            break;

        case 'f':   // toggle live feedback

            DoCommand(hwnd, IDC_LIVEFEEDBACK);
            break;
        }

        break;

    case WM_RBUTTONDOWN:

        x = (SHORT) LOWORD(lParam);
        y = (SHORT) HIWORD(lParam);
        DoPopupMenu(hwnd, x, y);
        break;

    case WM_DESTROY:

        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//
// Create main application window
//

VOID
CreateMainWindow(
    VOID
    )

#define MYWNDCLASSNAME L"QuadTest"

{
    //
    // Register window class if necessary
    //

    static BOOL wndclassRegistered = FALSE;

    if (!wndclassRegistered)
    {
        WNDCLASS wndClass =
        {
            0,
            MyWindowProc,
            0,
            0,
            appInstance,
            LoadIcon(NULL, IDI_APPLICATION),
            LoadCursor(NULL, IDC_ARROW),
            NULL,
            NULL,
            MYWNDCLASSNAME
        };

        RegisterClass(&wndClass);
        wndclassRegistered = TRUE;
    }
    
    wndSizeExtra.cx = 2*GetSystemMetrics(SM_CXSIZEFRAME);
    wndSizeExtra.cy = 2*GetSystemMetrics(SM_CYSIZEFRAME) + GetSystemMetrics(SM_CYCAPTION);

    hwndMain = CreateWindow(
                    MYWNDCLASSNAME,
                    MYWNDCLASSNAME,
                    WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    srcSize.cx + wndSizeExtra.cx,
                    srcSize.cy + wndSizeExtra.cy,
                    NULL,
                    NULL,
                    appInstance,
                    NULL);
}

//
// Main program entrypoint
//

INT _cdecl
main(
    INT argc,
    CHAR **argv
    )

{
    programName = *argv++;
    argc--;
    appInstance = GetModuleHandle(NULL);

    // Initialize mesh configuration

    CreateMesh();

    // Create the main application window

    CreateMainWindow();

    // Main message loop

    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\quadtest\resource.h ===
#define IDM_MAINMENU            1000
#define     IDC_TOGGLEMESH      1001
#define     IDC_RESETMESH       1002
#define     IDC_SHRINKTOFIT     1003
#define     IDC_DENSEMESH       1004
#define     IDC_SPARSEMESH      1005
#define     IDC_LIVEFEEDBACK    1006
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\reversi\rev.cpp ===
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <objbase.h>
#include <windows.h>
#include <math.h>
#include <float.h>
#include <gdiplus.h>

#include <port1632.h>
#include <process.h>
#include "reversi.h"

using namespace Gdiplus;

VOID NEAR PASCAL paintmove(BYTE b[BoardSize], INT move, INT friendly,
        INT enemy);
BOOL NEAR PASCAL msgcheck(VOID);

extern INT     moves[61];
extern INT     BestMove[max_depth+2];
extern HWND    hWin;
extern HDC     hDisp;
extern INT     depth;
extern INT     direc[];
extern Graphics* g;


/*       Indexes for computing scores and whether or not a player has       */
/*       any pieces on the board.  Very order dependant.                    */

BYTE PieceFlags[] = {   0x00 ,      /* Ignore sides */
                        0x00 ,      /* Ignore blanks */
                        0x01 ,      /* Human has a piece */
                        0x02 ,      /* Computer has a piece */
                    };

                    
INT Scores[] = { 0, 0 };
INT humanScore = 0;
INT compScroe = 0;

 

BYTE FinalComp[] = {0, 0, -1, 1 };   /* Table for compute # computer pieces */

BYTE FinalHuman[] = {0, 0, 1, -1};   /* Table for compute # human pieces    */

/*
 *       The scoring tables are used to evaluate the board
 *       position.  The corners of the board change value
 *       according to whether a given square is occupied or
 *       not.  This can be done dynamically, saving ~ 1K
 *       worth of data space but costing an as of yet
 *       undetermined performance hit.
 */

#define B11     11    /* Offsets to particular squares */
#define B18     18 
#define B81     81 
#define B88     88 

#define maskb11     0x08    /* Masks used for indexing into Scoring tables. */
#define maskb18     0x04
#define maskb81     0x02
#define maskb88     0x01


INT NEAR PASCAL finalscore(
BYTE b[],
INT friendly,
INT enemy)
{
    INT i;
    INT count=0;

    for (i=11 ; i<=88 ; i++) {
        if (b[i] == friendly) count++;
        else if (b[i] == enemy) count--;
    }
    if (count > 0)
        return(win +  count);
    else if (count < 0)
        return(loss + count);
    else
        return(0);
}



INT NEAR PASCAL legalcheck(
BYTE b[],
INT move,
INT friendly,
INT enemy)
{
   INT sq,d;
   INT *p;

   if (b[move] == empty) {
      p=direc;
      while ((d = *p++) != 0) {
          sq=move;
          if (b[sq += d] == enemy) {
             while(b[sq += d] == enemy)
                ;
             if (b[sq] == friendly) return(1);
          }
      }
   }
   return(0);
}


VOID NEAR PASCAL makemove(
BYTE b[],
INT move,
INT friendly,
INT enemy)
{
   INT sq,d;
   INT *p;

   if (move != PASS) {
      p=direc;
      while ((d = *p++) != 0) {
          sq=move;
          if (b[sq += d] == enemy) {
             while(b[sq += d] == enemy)
                ;
             if (b[sq] == friendly)
                while(b[sq -= d] == enemy)
                   b[sq]=friendly;
          }
      }
      b[move]=friendly;
   }
}


/*

   calculate the value of board

*/
INT NEAR PASCAL score(
BYTE b[],
INT friendly,
INT enemy)
{
    INT *pvalue;
    BYTE *pb;
    INT fpoints=0;
    INT epoints=0;
    INT ecount=0;
    BYTE bv;
    INT v,b11,b18,b81,b88;

    static INT value[79] = {     99, -8,  8,  6,  6,  8, -8, 99,000,
                                000, -8,-24, -4, -3, -3, -4,-24, -8,000,
                                000,  8, -4,  7,  4,  4,  7, -4,  8,000,
                                000,  6, -3,  4,  0,  0,  4, -3,  6,000,
                                000,  6, -3,  4,  0,  0,  4, -3,  6,000,
                                000,  8, -4,  7,  4,  4,  7, -4,  8,000,
                                000, -8,-24, -4, -3, -3, -4,-24, -8,000,
                                000, 99, -8,  8,  6,  6,  8, -8, 99,infin};

    static INT value2[79]= {     99, -8,  8,  6,  6,  8, -8, 99,000,
                                000, -8,-24,  0,  1,  1,  0,-24, -8,000,
                                000,  8,  0,  7,  4,  4,  7,  0,  8,000,
                                000,  6,  1,  4,  1,  1,  4,  1,  6,000,
                                000,  6,  1,  4,  1,  1,  4,  1,  6,000,
                                000,  8,  0,  7,  4,  4,  7,  0,  8,000,
                                000, -8,-24,  0,  1,  1,  1,-24, -8,000,
                                000, 99, -8,  8,  6,  6,  8, -8, 99,infin};

    pb = &b[11];
    b11 = *pb;
    b18 = b[18];
    b81 = b[81];
    b88 = b[88];

    if ((b11 != empty) || (b18 != empty) || (b81 != empty) || (b88 != empty)) {
        pvalue = value2;

        if (b11 == empty) {
                value2[12-11] = -8;  value2[21-11] = -8;  value2[22-11] = -24;
        } else {
                value2[12-11] = 12;  value2[21-11] = 12;  value2[22-11] = 8;
        }

        if (b18 == empty) {
                value2[17-11] = -8;  value2[28-11] = -8;  value2[27-11] = -24;
        } else {
                value2[17-11] = 12;  value2[28-11] = 12;  value2[27-11] = 8;
        }

        if (b81 == empty) {
                value2[82-11] = -8;  value2[71-11] = -8;  value2[72-11] = -24;
        } else {
                value2[82-11] = 12;  value2[71-11] = 12;  value2[72-11] = 8;
        }

        if (b88 == empty) {
                value2[87-11] = -8;  value2[78-11] = -8;  value2[77-11] = -24;
        } else {
                value2[87-11] = 12;  value2[78-11] = 12;  value2[77-11] = 8;
        }
    } else {
        pvalue = value;
    }

    while((v=*pvalue++) != infin) {
       bv = *pb++;
       if (bv == friendly)
           fpoints += v;
       else if (bv == enemy) {
                   epoints += v;
           ecount++;
       }

    }
    if (!ecount)          /* any enemy pieces on the board? */
       return(win);       /* if not, we just won!                 */
    else
       return(fpoints-epoints);
}



INT NEAR PASCAL minmax(
BYTE b[max_depth + 2][100],
INT move,
INT friendly,
INT enemy,
INT ply,
INT vmin,
INT vmax)
{
    BYTE *pCurrent, *pPrevious, *pSource, *pDest;
    INT *pMoves;
    INT *pBestMove;
    INT i;
    INT sq, value, cur_move;

    pPrevious = &b[ply][0];
    pCurrent =  &b[ply+1][0];

    pSource = &b[ply][11];
    pDest =   &b[ply+1][11];
    for (i=11 ; i<=88 ; i++) *pDest++=*pSource++;

    pBestMove = &BestMove[ply];
    if (move == PASS) {
        if (ply == depth) {
            pMoves = moves;
            while((sq = *pMoves++) != 0) {
                if (legalcheck(pCurrent,sq,enemy,friendly))
                    return(score(pCurrent,friendly,enemy));
            }
            return(finalscore(pCurrent,friendly,enemy));
        }
    }
    else {
        if (ply == 0) {
            g = new Graphics(hWin);
            paintmove(pCurrent,move,friendly,enemy);
            delete g;
            g = NULL;
        }
        else {
            makemove(pCurrent,move,friendly,enemy);
            if (ply == depth) return(score(pCurrent,friendly,enemy));
        }
    }
    pMoves = moves;
    cur_move = PASS;
    *pBestMove = PASS;
    while((sq = *pMoves++) != 0) {
        if (legalcheck(pCurrent,sq,enemy,friendly)) {
           cur_move = sq;
           value = minmax(b,cur_move,enemy,friendly,ply+1,-vmax,-vmin);
           if (value > vmin) {
              vmin = value;
              *pBestMove = cur_move;
              if (value >= vmax) goto cutoff;   /* alpha-beta cutoff */
           }
        }
    }
    if (cur_move == PASS) {
       if (move == PASS)        /* two passes in a row mean game is over */
          return(finalscore(pCurrent,friendly,enemy));
       else {
          value = minmax(b,PASS,enemy,friendly,ply+1,-vmax,-vmin);
          if (value > vmin) vmin = value;
       }
    }
cutoff:
    return(-vmin);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\samples\shapes\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	shapes.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information


// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\reversi\reversi.h ===
#define BoardSize           100 
#define edge                0
#define empty               1
#define human               2
#define computer            3
#define infin               32767
#define win                 32000
#define loss                (-32000)
#define max_depth           6

#define PASS                20
#define NEW                 25
#define BSkill              40
#define EASY                41
#define MEDIUM              42
#define HARD                44
#define VHARD               46
#define HINT                50
#define EXIT                52


/* Menu ID's */

#define MN_HELP_INDEX       30
#define MN_HELP_KEYBOARD    31
#define MN_HELP_COMMANDS    32
#define MN_HELP_PLAYING     33
#define MN_HELP_RULES       34
#define MN_HELP_USINGHELP   35
#define MN_HELP_ABOUT       36
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\samples\shapes\shapes.h ===
/**************************************************************************\
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Shapes Sample Header File
*
* Abstract:
*
*   Decribes the shapes classes.
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

#include <objbase.h>

#include <Gdiplus.h>
#include <tchar.h>

using namespace Gdiplus;

#ifndef ASSERT
    #define ASSERT(cond)    if (!(cond)) { DebugBreak(); }
#endif

#define numberof(x) (sizeof(x)/sizeof(x[0]))


/**************************************************************************\
*
* Class Description:
*
* Shape Class
* Defines the basic functionnality of a shape.
* Contains a Pen, a Fill Brush, and a Text Brush
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

class Shape
{
public:
    Shape(Pen   *in_Pen = NULL,         // Pen we want to draw with
          Brush *in_Brush = NULL,       // Brush we want to fill with
          Brush *in_TextBrush = NULL,   // TextBrush we want to write with
          TCHAR* in_Text = NULL,        // Text we want to write
          TCHAR* in_FontFamily = NULL   // Font we want to use
          );

    virtual ~Shape();

    // Drawing methods
    VOID Draw(Graphics *g);             // Draw the shape
	VOID SetPen(Pen *in_Pen);           // Set the Drawing Pen
    VOID SetBrush(Brush *in_Brush);     // Set the Fill Brush
    VOID SetTextBrush(Brush *in_Brush); // Set the Text Brush

    // Transformations
	VOID SetSize(REAL sizeX, REAL sizeY);   // Set the size of the shape
	VOID SetAngle(REAL angle);              // Set the rotation angle
	VOID SetPosition(REAL posX, REAL posY); // Set the center of the shape

protected:
	// Don't do anything in the base class...
    // These are not pure because the derived classes don't need to
    // implement them. Shape class can also be used to have a text label only
	virtual VOID DrawShape(Graphics *g) {}; // Draw the shape
	virtual VOID FillShape(Graphics *g) {}; // Fill the shape
    virtual VOID DrawText(Graphics* g);     // Draw the text

    // Calculate the transformation matrix
	virtual VOID RecalcObjectMatrix();

    // Set the points to the default of the shape
    virtual VOID ResetPoints() {};

    // Data Members
protected:
    Pen      *m_Pen;                    // Pen for the outline of the shape
    Brush    *m_Brush;	                // Brush for the inside of the shape

    // Text Attributes
    Brush    *m_TextBrush;              // Brush for the text
    TCHAR    *m_szName;                 // Label that will be written
    Font     *m_Font;                   // Font used for the label

    // Shape Attributes
    GpMatrix  m_ObjectMatrix;           // Matrix that will transform the shape
	REAL	  m_Angle;                  // Rotation angle of the shape
	REAL      m_SizeX, m_SizeY;         // Size of the shape
	REAL      m_PosX, m_PosY;           // Position of the center of the shape

    // Control Points
	PointF   *m_Points;     			// The points that control the shape
	INT       m_NPoints;	        	// The number of points
};


/***************************************************************************\
 A Rectangular shape, with a diameter of 1
\***************************************************************************/
class RectShape : public Shape
{
public:
    RectShape(Pen   *in_Pen = NULL,
              Brush *in_Brush = NULL,
              Brush *in_TextBrush = NULL,
              TCHAR* in_Text = NULL,
              TCHAR* in_FontFamily = NULL
              )
			  : Shape(in_Pen, in_Brush, in_TextBrush, in_Text, in_FontFamily)
	{
        // We have two control points
		m_NPoints = 2 ;
		m_Points = new PointF[m_NPoints] ;
        ResetPoints();
	};

protected:
    VOID ResetPoints();
private:
	VOID DrawShape(Graphics *g);
	VOID FillShape(Graphics *g);
};

/***************************************************************************\
 An elliptical shape, with a diameter of 1
\***************************************************************************/
class EllipseShape : public Shape
{
public:
    EllipseShape(Pen   *in_Pen = NULL,
                 Brush *in_Brush = NULL,
                 Brush *in_TextBrush = NULL,
                 TCHAR* in_Text = NULL,
                 TCHAR* in_FontFamily = NULL
                 )
			     : Shape(in_Pen, in_Brush, in_TextBrush, in_Text, in_FontFamily)
	{
        // We have two control points
		m_NPoints = 2 ;
		m_Points = new PointF[m_NPoints] ;
        ResetPoints();
	};


protected:
    VOID ResetPoints();
private:
	VOID DrawShape(Graphics *g);
	VOID FillShape(Graphics *g);
};

/***************************************************************************\
 An 90 degree pie shape, of size 1
\***************************************************************************/
class PieShape : public Shape
{
public:
    PieShape(Pen   *in_Pen = NULL,
             Brush *in_Brush = NULL,
             Brush *in_TextBrush = NULL,
             TCHAR* in_Text = NULL,
             TCHAR* in_FontFamily = NULL
             )
			 : Shape(in_Pen, in_Brush, in_TextBrush, in_Text, in_FontFamily)
             , m_PieAngle(360)
	{
        // We have two control points
		m_NPoints = 2 ;
		m_Points = new PointF[m_NPoints] ;
        ResetPoints();
	};

    // New method. Set the pie angle default is 360 degrees
    VOID SetPieAngle(REAL PieAngle) { m_PieAngle = PieAngle; };


protected:
    VOID ResetPoints();
private:
	VOID DrawShape(Graphics *g);
	VOID FillShape(Graphics *g);

    // Data Members
    REAL m_PieAngle;        // The angle of the pie slice we want
};

/***************************************************************************\
 An generic polygon shape. This class doesn't have any point information
\***************************************************************************/
class PolygonShape : public Shape
{
// A polygon shape cannot be instantiated
protected:
    PolygonShape(Pen   *in_Pen = NULL,
                 Brush *in_Brush = NULL,
                 Brush *in_TextBrush = NULL,
                 TCHAR* in_Text = NULL,
                 TCHAR* in_FontFamily = NULL
                 )
                 : Shape(in_Pen, in_Brush, in_TextBrush, in_Text, in_FontFamily)
	{
    };

private:
	VOID DrawShape(Graphics *g);
	VOID FillShape(Graphics *g);
};

/***************************************************************************\
 An regualar polygon shape, of size 1
\***************************************************************************/
class RegularPolygonShape : public PolygonShape
{
public:
    RegularPolygonShape(INT    in_Edges = 6,        // The number of edges
                                                    // we want to have
                        Pen   *in_Pen = NULL,
                        Brush *in_Brush = NULL,
                        Brush *in_TextBrush = NULL,
                        TCHAR* in_Text = NULL,
                        TCHAR* in_FontFamily = NULL
                        )
			            : PolygonShape(in_Pen, in_Brush, in_TextBrush, in_Text, in_FontFamily)
	{
        ASSERT(in_Edges > 0);
		m_NPoints = in_Edges ;
        m_Points = new PointF[m_NPoints];
        ResetPoints() ;
    };

protected:
    VOID ResetPoints();
};


/***************************************************************************\
 An star shape, of size 1
\***************************************************************************/
class StarShape : public PolygonShape
{
public:
    StarShape(INT    in_Edges = 6,                  // The number of edges
                                                    // we want to have
              Pen   *in_Pen = NULL,
              Brush *in_Brush = NULL,
              Brush *in_TextBrush = NULL,
              TCHAR* in_Text = NULL,
              TCHAR* in_FontFamily = NULL
              )
			  : PolygonShape(in_Pen, in_Brush, in_TextBrush, in_Text, in_FontFamily)
	{
        ASSERT(in_Edges > 0);
		m_NPoints = 2*in_Edges ;        // We always have twices as many
                                        // points as we have edges
        m_Points = new PointF[m_NPoints];
        ResetPoints() ;
    };

protected:
    VOID ResetPoints();
};

/***************************************************************************\
 An Cross.
\***************************************************************************/
class CrossShape : public PolygonShape
{
public:
    CrossShape(Pen   *in_Pen = NULL,
               Brush *in_Brush = NULL,
               Brush *in_TextBrush = NULL,
               TCHAR* in_Text = NULL,
               TCHAR* in_FontFamily = NULL
               )
			   : PolygonShape(in_Pen, in_Brush, in_TextBrush, in_Text, in_FontFamily)
	{
		m_NPoints = 12 ;
		m_Points = new PointF[m_NPoints] ;
        ResetPoints();
	};

protected:
    VOID ResetPoints();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\reversi\reversi.cpp ===
/****************************************************************************/
/*                                                                          */
/*  Windows Reversi -                                                       */
/*                                                                          */
/*      Originally written by Chris Peters                                  */
/*                                                                          */
/****************************************************************************/

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <objbase.h>
#include <windows.h>
#include <math.h>
#include <float.h>

#include "windows.h"
#include <port1632.h>
#include <process.h>
#include <stdlib.h>
#include "reversi.h"
#include <gdiplus.h>

using namespace Gdiplus;

/* Exported procedures called from other modules */
LRESULT APIENTRY ReversiWndProc(HWND, UINT, WPARAM, LPARAM);
VOID APIENTRY InverseMessage(HWND, UINT, UINT_PTR, DWORD);
INT_PTR APIENTRY AboutDlgProc(HWND, UINT, WPARAM, LPARAM);

PWSTR    pDisplayMessage;
Brush  *brBlack;
Brush  *brPat;
Brush  *brWhite;
Brush  *brRed;
Brush  *brGreen;
Brush  *brBlue;
Brush  *brHuman;
Brush  *brComputer;
HBRUSH       hbrWhite;
HBRUSH       hbrGreen;

HANDLE  hInst;
HANDLE  curIllegal;
HANDLE  curLegal;
HANDLE  curThink;
HANDLE  curBlank;
BOOL    fThinking = FALSE;
BOOL    fCheated = FALSE;
INT     direc[9] = {9, 10, 11, 1, -1, -9, -10, -11, 0};
WORD     prevCheck;
BYTE    board[max_depth+2][BoardSize];
INT     fPass;
INT     flashtimes;
INT     count;
INT     MessageOn;
INT     charheight;
INT     charwidth;
INT     xscr;
WCHAR    strBuf[80];
BOOL    bMouseDownInReversi = FALSE;
INT     xExt;
INT     yExt;
INT     Bx;
INT     By;
INT     ASPECT;
INT     COLOR;
INT     TXMIN;
INT     TYMIN = 45;
INT     dimension;
BOOL    ffirstmove;

WCHAR    szReversi[20];
WCHAR    szReversiPractice[40];
WCHAR    szPass[30];
WCHAR    szMustPass[30];
WCHAR    szTie[30];
WCHAR    szLoss[30];
WCHAR    szWon[30];
WCHAR    szWonPost[30];
WCHAR    szLossPost[30];
WCHAR    szAbout[20];
WCHAR    szIllegal[70];
WCHAR    szNoPass[70];
WCHAR    szHelpFile[15];

HANDLE  hAccel;

POINT   MousePos;

INT     depth;
INT     BestMove[max_depth+2];
HDC     hDisp;
HWND    hWin;
Graphics *g;

INT     moves[61] = {11,18,81,88, 13,31,16,61,
                     38,83,68,86, 14,41,15,51,
                     48,84,58,85, 33,36,63,66,
                     34,35,43,46, 53,56,64,65,
                     24,25,42,47, 52,57,74,75,
                     23,26,32,37, 62,67,73,76,
                     12,17,21,28, 71,78,82,87,
                     22,27,72,77,
              0};


INT NEAR PASCAL minmax(BYTE b[max_depth + 2][100], INT move, INT friendly,
    INT enemy, INT ply, INT vmin, INT vmax);
VOID NEAR PASCAL makemove(BYTE b[], INT move, INT friendly, INT enemy);
INT NEAR PASCAL legalcheck(BYTE b[], INT move, INT friendly, INT enemy);


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  UpdateCursor() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* To use UpdateCursor,  set the global var MousePos.x and MousePos.y and make
 * the call.  The cursor will appear at the new position
 */

VOID NEAR PASCAL UpdateCursor(
HWND    hwnd)
{
  POINT curpoint;

  curpoint.x = MousePos.x;
  curpoint.y = MousePos.y;
  ClientToScreen(hwnd, (LPPOINT)&curpoint);
  SetCursorPos(curpoint.x, curpoint.y);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  checkdepth() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL checkdepth(
HWND hWindow,
WORD  d)
{
  HMENU hMenu;

  hMenu = GetMenu(hWindow);
  CheckMenuItem(hMenu, prevCheck, MF_UNCHECKED);
  CheckMenuItem(hMenu, d, MF_CHECKED);
  prevCheck = d;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  clearboard() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL clearboard(
BYTE b[max_depth+2][BoardSize])
{
  register INT  i,j;
  INT           k;

  for (i=0; i<=max_depth ; i++)
      for (j=0 ; j<=99 ; j++)
          b[i][j] = edge;

    for (i=0 ; i<=max_depth ; i++)
      {
        for (j=11 ; j<=81 ; j=j+10)
            for (k=j ; k<j+8 ; k++)
                b[i][k] = empty;

        b[i][45]=computer;
        b[i][54]=computer;
        b[i][44]=human;
        b[i][55]=human;
      }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevCreate() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called on WM_CREATE messages. */

VOID NEAR PASCAL RevCreate(
register HWND   hWindow)

{
  register HDC  hDC;
  TEXTMETRIC    charsize;           /* characteristics of the characters */

  MessageOn   = FALSE;
  hDC = GetDC(hWindow);
  GetTextMetrics(hDC, (LPTEXTMETRIC)&charsize);

  charheight = charsize.tmHeight;
  charwidth = charsize.tmAveCharWidth;

  ReleaseDC(hWindow, hDC);

  if (COLOR == TRUE)
    {
      brComputer = brBlue;
      brHuman = brRed;
    }
  else
    {
      brComputer = brBlack;
      brHuman = brWhite;
    }

  TXMIN = 45 * ASPECT;

  clearboard(board);

  /* Okay to pass on first move */
  fPass = PASS;
  depth = 1;
  prevCheck = EASY;
  ffirstmove = TRUE;
  checkdepth(hWindow, prevCheck);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  printboard() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL printboard(
BYTE b[max_depth+2][BoardSize])

{
  register INT  i,j;
  INT sq;

  for (i=0; i < 8; i++)
    {
      for (j=0; j < 8; j++)
        {
          if ((sq = (INT)b[0][i*10+j+11]) != empty)
            {
              Brush *brush;
              
              if (sq == computer)
                  brush = brComputer;
              else
                  brush = brHuman;
              
              g->FillEllipse(brush,
                             Bx+2*ASPECT+i*xExt,
                             By+2+j*yExt,
                             xExt-4*ASPECT,
                             yExt-4);
            }
        }
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ClearMessageTop() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ClearMessageTop(
Graphics *graphics)
{
   if (MessageOn == TRUE)
   {
      flashtimes = count + 1;
      graphics->FillRectangle((COLOR) ? brGreen : brWhite, 0, 0, xscr, charheight);
      MessageOn = FALSE;
   }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ShowMessageTop() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ShowMessageTop(
Graphics *graphics,
PWSTR    string
)
{
  INT   dx;

  pDisplayMessage = string;
  ClearMessageTop(graphics);
  RectF rect(0, 0, xscr, charheight);
  graphics->FillRectangle(brWhite, rect);
  Font font((HFONT)NULL);
  graphics->DrawStringI((LPWSTR)string,
                       NULL,
                       0,
                       0,
                       NULL, 0,
                       brBlue);
  MessageOn = TRUE;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  drawboard() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL drawboard(
BYTE b[max_depth+2][BoardSize])
{
  register INT  i;
  INT           lcx,lcy;
  register INT  xdimension;
  INT           xLineExt,yLineExt;

  yLineExt = 8 * yExt;
  xLineExt = 8 * xExt;
  xdimension = dimension * ASPECT;

  g->FillRectangle(brBlack, Bx+2*xdimension, By+2*dimension, xLineExt, yLineExt);
  g->FillRectangle(brPat, Bx, By, xLineExt, yLineExt);

  for (i=Bx; i <= Bx + xLineExt; i += xExt)
     g->FillRectangle(brGreen, i, By, ASPECT, yLineExt);

  for (i=By; i <= By + yLineExt; i += yExt)
     g->FillRectangle(brGreen, Bx, i, xLineExt, 1);

  lcx = Bx+xLineExt;
  lcy = By+yLineExt;

  for (i=1; i < xdimension; ++i)
      g->FillRectangle(brPat, lcx+i, By+i/ASPECT, 1, yLineExt);

  /* Fill in bottom edge of puzzle. */
  for (i=1; i < dimension; ++i)
      g->FillRectangle(brPat, Bx+i*ASPECT, lcy+i, xLineExt, 1);

  Pen pen(brBlack, 1.0f, UnitWorld);

  g->DrawLine(&pen, lcx, By, lcx+xdimension, By+dimension);
  g->DrawLine(&pen, lcx+xdimension, By+dimension, lcx+xdimension, lcy+dimension);
  g->DrawLine(&pen, lcx+xdimension, lcy+dimension, Bx+xdimension, lcy+dimension);
  g->DrawLine(&pen, Bx+xdimension, lcy+dimension, Bx, lcy);
  g->DrawLine(&pen, lcx+xdimension, lcy+dimension, lcx, lcy);

  printboard(b);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevPaint() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called on WM_PAINT messages. */

VOID NEAR PASCAL RevPaint(
HWND    hWindow,
Graphics *graphics)

{
  register INT  Tx, Ty;
  INT           xLineExt, yLineExt;
  RECT          lpSize;

  /* Since it is easy to resize we'll do it on every repaint */
  g = graphics;
  hWin  = hWindow;
  //SetBkMode(hDisp, OPAQUE);
  GetClientRect(hWindow, (LPRECT)&lpSize);
  xscr = Tx = lpSize.right - lpSize.left;
  Ty = lpSize.bottom - lpSize.top;

  /* Dont go below minimum size */
  if (Tx < Ty*ASPECT)
    {
      if (Tx < TXMIN)
          Tx = TXMIN;
      xExt = Tx / (9 + 1);
      yExt = xExt / ASPECT;
    }
  else
    {
      if (Ty < TYMIN)
          Ty = TYMIN;
      yExt = Ty / (9 + 1);
      xExt = yExt * ASPECT;
    }
  yLineExt = 8 * yExt;
  xLineExt = 8 * xExt;
  dimension = yLineExt/30;

  Bx = (Tx > xLineExt) ? (Tx - xLineExt) / 2 : 0;
  By = (Ty > yLineExt) ? (Ty - yLineExt) / 2 : 0;

  RECT rect;
  GetClientRect(hWindow, &rect);

  g->FillRectangle(brWhite,
				   rect.left, 
				   rect.top, 
				   rect.right-rect.left, 
				   rect.bottom-rect.top);

  drawboard(board);

  if (MessageOn)
    {
      ShowMessageTop(graphics, pDisplayMessage);
      //PatBlt(hDC, 0, 0, xscr, charheight, DSTINVERT);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FlashMessageTop() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL FlashMessageTop(
HWND    hWindow)
{
  flashtimes = 0;
  count = 4;
  SetTimer(hWindow, 666, 200, InverseMessage);    /* Timer ID is 666 */
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMessage() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevMessage(
HWND            hWindow,
Graphics       *graphics,
register WCHAR   *pS,
INT              n,
WCHAR            *pchPostStr)
{
  register WCHAR *pch;

  pch = strBuf;
  while (*pS)
      *pch++ = *pS++;

  if (n)
    {
      if (n / 10)
          *pch++ = (CHAR)(n / 10 + L'0');
      *pch++ = (CHAR)(n % 10 + L'0');
    }

  if (pchPostStr)
    {
      while (*pchPostStr)
          *pch++ = *pchPostStr++;
    }
  *pch = L'\0';

  ShowMessageTop(graphics, strBuf);
  FlashMessageTop(hWindow);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  flashsqr() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL flashsqr(
register Graphics *graphics,
INT             x1,
INT             y1,
INT             Ex,
INT             Ey,
INT             color,
BOOL            fBlankSquare,
INT             n)

{
  register INT  i;

// !! ??
//  if (fBlankSquare)
//      SelectObject(hDC, GetStockObject(NULL_PEN));

  SetCursor((HICON)curBlank);

  for (i=0; i < n; ++i)
    {
      if (color == 1)
          color = 2;
      else
          color = 1;

      Brush *brush;

      if (color == 1)
          brush = brComputer;
      else
          brush = brHuman;

      graphics->FillEllipse(brush, x1, y1, Ex, Ey);
    }

  if (fBlankSquare)
    {
      graphics->FillEllipse(brPat, x1, y1, Ex, Ey);
    }
  else
      SetCursor((HICON)curThink);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMouseMove() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevMouseMove(
POINT   point)

{
  INT     move;
  INT     Si, Sj;
  INT     yLineExt = 8 * yExt;
  INT     xLineExt = 8 * xExt;
  HANDLE  cur;

  MousePos.x = point.x;
  MousePos.y = point.y;

  if(xExt ==0 || yExt == 0)
      return;

  cur = curIllegal;

  if ((point.x > Bx) && (point.x < (Bx+xLineExt)) && (point.y > By) && (point.y < (By+yLineExt)))
    {
      Si = (point.x - Bx) / xExt;
      Sj = (point.y - By) / yExt;
      move = Si * 10 + Sj + 11;
      if (legalcheck(board[0], move, human, computer))
          cur = curLegal;
    }
  SetCursor((HICON)cur);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ShowBestMove() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ShowBestMove(
HWND hwnd)

{
  HDC           hdc;
  INT           sq;
  register INT  x, y;
  INT           *pMoves;
  BOOL          bDone;

  if (fPass == PASS && !ffirstmove)
      return;

  if (!fCheated)
      SetWindowText(hwnd, (LPWSTR)szReversiPractice);

  fCheated = TRUE;
  SetCursor((HICON)curThink);
  fThinking = TRUE;

  if (ffirstmove)
    {
      /* HACK: Hardcode the first move hint. */
      x = 4;
      y = 2;
    }
  else
    {
      if (depth == 1)
        {
          bDone = FALSE;
          pMoves = moves;
          sq = *pMoves;
          while (!bDone)
            {
              sq = *pMoves;
              if (legalcheck(board[0], sq, human, computer))
                  bDone = TRUE;
              else
                  pMoves++;
            }
          y = (sq - 11) % 10;
          x = (sq - 11) / 10;
        }
      else
        {
          minmax(board, BestMove[0],  computer, human, 1, -infin, infin);
          y = (BestMove[1] - 11) % 10;
          x = (BestMove[1] - 11) / 10;
        }
    }

  MousePos.x = (x * xExt) + Bx + xExt/2;
  MousePos.y = (y * yExt) + By + yExt/2;

  UpdateCursor(hwnd);

  Graphics graphics(hwnd);
  
  x = x * xExt + Bx + 2 * ASPECT;
  y = y * yExt + By + 2;

  flashsqr(&graphics, x, y, xExt - 4 * ASPECT, yExt - 4, computer, TRUE, 3);

  fThinking = FALSE;

  RevMouseMove(MousePos);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  gameover() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Find a human reply to the computers move.
 * As a side effect set flag fPass if the human
 * has a legal move.
 */

VOID NEAR PASCAL gameover(
register HWND   hWindow,
Graphics       *g,
BYTE            b[max_depth + 2][BoardSize],
INT             r)

{
  register INT  i;
  INT           cc;
  INT           hc;
  INT           sq;
  INT           reply2;
  INT           *pMoves;

  pMoves = moves;
  fPass = PASS;
  reply2 = PASS;
  while ((sq = *pMoves++) != 0)
    {
      if (legalcheck(b[0], sq, human, computer))
          fPass = sq;
      else if (legalcheck(b[0], sq, computer, human))
          reply2 = sq;
    }

  if (fPass == PASS)
    {
      if ((r == PASS) || (reply2 == PASS))
        {
          hc = 0;
          cc = 0;
          for (i=11; i <= 88; i++)
            {
              if (b[0][i] == human)
                  hc++;
              else if (b[0][i] == computer)
                  cc++;
            }

          if (hc > cc)
              RevMessage(hWindow, g, szWon, hc-cc, szWonPost);
          else if (hc < cc)
              RevMessage(hWindow, g, szLoss, cc-hc, szLossPost);
          else
              RevMessage(hWindow, g, szTie, 0, NULL);
        }
      else
        {
          RevMessage(hWindow, g, szMustPass, 0, NULL);
        }
    }
  else if (r == PASS)
    {
      RevMessage(hWindow, g, szPass, 0, NULL);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  paintmove() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Make a move and show the results. */

VOID NEAR PASCAL paintmove(
BYTE    b[BoardSize],
INT     move,
INT    friendly,
INT    enemy)
{
  INT           d;
  INT           sq;
  INT           *p;
  register INT  i,j;
  INT           color;

  if (move != PASS)
    {
      Brush *brush;

      if (friendly == computer)
        {
          brush = brComputer;
          color = 1;
        }
      else
        {
          brush = brHuman;
          color = 2;
        }

      i = ((move - 11) / 10) * xExt + Bx + 2 * ASPECT;
      j = ((move - 11) % 10) * yExt + By + 2;

      Pen pen(brush, 1.0f, UnitWorld);

      g->DrawEllipse(&pen, i, j, xExt - 4 * ASPECT, yExt - 4);
      flashsqr(g, i, j, xExt - 4 * ASPECT, yExt - 4, color, FALSE, 4);

      p = direc;
      while ((d = *p++) != 0)
        {
          sq=move;
          if (b[sq += d] == enemy)
           {
             while(b[sq += d] == enemy)
                ;
             if (b[sq] == (BYTE)friendly)
               {
                 while(b[sq -= d] == enemy)
                   {
                     board[0][sq] = b[sq] = friendly;
                     i = ((sq - 11)/10)*xExt+Bx+2*ASPECT;
                     j = ((sq - 11)%10)*yExt+By+2;
                     g->FillEllipse(brush, i, j, xExt-4*ASPECT, yExt-4);
                   }
               }
           }
        }
      b[move]=friendly;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMenu() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called on WM_COMMAND messages. */

VOID NEAR PASCAL RevMenu(
register HWND   hWindow,
INT             idval)

{
  HDC           hDC;
  register INT  cmd;

  if (fThinking)
      return;

  hWin = hWindow;

  switch (idval)
    {
      case EXIT:
          PostMessage(hWindow, WM_CLOSE, 0, 0L);
          break;

      case MN_HELP_ABOUT:
          DialogBox((HINSTANCE)hInst, MAKEINTRESOURCE(3), hWindow, AboutDlgProc);
          break;

      case MN_HELP_INDEX:
          //TEMPFIX WinHelp(hWindow, (LPSTR)szHelpFile, HELP_INDEX, 0L);
          break;

      case MN_HELP_USINGHELP:
          //TEMPFIX WinHelp(hWindow, (LPSTR)NULL, HELP_HELPONHELP, 0L);
          break;

      case MN_HELP_KEYBOARD:
          cmd = 0x1e;
          goto HelpCommon;

      case MN_HELP_COMMANDS:
          cmd = 0x20;
          goto HelpCommon;

      case MN_HELP_PLAYING:
          cmd = 0x21;
          goto HelpCommon;

      case MN_HELP_RULES:
          cmd = 0x22;
HelpCommon:
          //TEMPFIX WinHelp(hWindow, (LPSTR)szHelpFile, HELP_CONTEXT, (DWORD)cmd);
          break;

      case HINT:
          ShowBestMove(hWindow);
          return;
          break;

      case NEW:
          SetWindowText(hWindow , (LPWSTR)szReversi);
          ffirstmove = TRUE;
          g = new Graphics(hWindow);
          fCheated = FALSE;
          ClearMessageTop(g);
          fPass = PASS;
          clearboard(board);
          drawboard(board);
          delete g;
          g = NULL;
          break;

      case EASY:
          depth = 1;                      /* MUST BE AT LEAST 1.  */
          checkdepth(hWindow, EASY);      /* KEEP HANDS OFF!      */
          break;

      case MEDIUM:
          depth = 2;
          checkdepth(hWindow, MEDIUM);
          break;

      case HARD:
          depth = 4;
          checkdepth(hWindow, HARD);
          break;

      case VHARD:
          depth = 6;
          checkdepth(hWindow, VHARD);
          break;

      case PASS:
          if (fPass == PASS)
            {
              g = new Graphics(hWindow);
              fThinking = TRUE;
              ClearMessageTop(g);
              SetCursor((HICON)curThink);
              delete g;
              g = NULL;
              minmax(board, PASS, human, computer, 0, -infin, infin);
              g = new Graphics(hWindow);
              paintmove(board[0], BestMove[0], (BYTE)computer, (BYTE)human);
              gameover(hWindow, g, board, BestMove[0]);
              SetCursor((HICON)curIllegal);
              fThinking = FALSE;
              delete g;
              g = NULL;
            }
          else
              MessageBox(hWindow, (LPWSTR)szNoPass, (LPWSTR)szReversi, MB_OK | MB_ICONASTERISK);
          break;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  msgcheck() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called by ASM routine to allow other tasks to run. */

BOOL NEAR PASCAL msgcheck()
{
  MSG msg;

  if (PeekMessage((LPMSG)&msg, NULL, 0, 0, TRUE))
    {
      if (msg.message == WM_QUIT)
        exit(0);

      if (TranslateAccelerator(msg.hwnd, (HACCEL)hAccel, (LPMSG)&msg) == 0)
        {
          TranslateMessage((LPMSG)&msg);
          DispatchMessage((LPMSG)&msg);
        }

      return(TRUE);
    }
  return(FALSE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevInit() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL NEAR PASCAL RevInit(
HANDLE hInstance)

{
  register PWNDCLASS    pRevClass;
  HDC                   hdc;
  static INT rgpat[] = { 170, 85, 170, 85, 170, 85, 170, 85 };

  brWhite = new SolidBrush(Color::White);
  brBlack = new SolidBrush(Color::Black);
  Bitmap *bmdel = new Bitmap(8, 8, 4, PIXFMT_1BPP_INDEXED, (BYTE*)rgpat);
  brPat   = new TextureBrush((Bitmap *)bmdel);
  
  if (!brPat)
      return(FALSE);
  
  delete bmdel;
  
  ffirstmove = TRUE;
  hdc = GetDC((HWND)NULL);

  COLOR = GetDeviceCaps(hdc, NUMCOLORS) > 2;

  if (GetDeviceCaps(hdc, VERTRES) == 200)
      ASPECT = 2;
  else
      ASPECT = 1;
  ReleaseDC((HWND)NULL, hdc);

  brRed    = new SolidBrush(Color::Red);
  brGreen  = new SolidBrush(Color::Green);
  brBlue   = new SolidBrush(Color::Blue);

  LOGBRUSH logbrush;
  logbrush.lbStyle = BS_SOLID;
  logbrush.lbColor = Color::White;
  logbrush.lbHatch = 0;
  hbrWhite = CreateBrushIndirect(&logbrush);

  logbrush.lbColor = Color::Green;
  hbrGreen = CreateBrushIndirect(&logbrush);
  
  if (!brRed || !brGreen || !brBlue || !hbrWhite || !hbrGreen)
      return(FALSE);

  LoadStringW((HINSTANCE)hInstance, 3,  (LPWSTR)szReversi, 20);
  LoadStringW((HINSTANCE)hInstance, 4,  (LPWSTR)szReversiPractice, 40);
  LoadStringW((HINSTANCE)hInstance, 5,  (LPWSTR)szPass, 30);
  LoadStringW((HINSTANCE)hInstance, 6,  (LPWSTR)szMustPass, 30);
  LoadStringW((HINSTANCE)hInstance, 7,  (LPWSTR)szTie, 30);
  LoadStringW((HINSTANCE)hInstance, 8,  (LPWSTR)szLoss, 30);
  LoadStringW((HINSTANCE)hInstance, 9,  (LPWSTR)szWon, 30);
  LoadStringW((HINSTANCE)hInstance, 10, (LPWSTR)szAbout, 20);
  LoadStringW((HINSTANCE)hInstance, 11, (LPWSTR)szLossPost, 30);
  LoadStringW((HINSTANCE)hInstance, 12, (LPWSTR)szWonPost, 30);
  LoadStringW((HINSTANCE)hInstance, 13, (LPWSTR)szIllegal, 70);
  LoadStringW((HINSTANCE)hInstance, 14, (LPWSTR)szNoPass, 70);
  LoadStringW((HINSTANCE)hInstance, 15, (LPWSTR)szHelpFile, 15);

  hAccel = LoadAccelerators((HINSTANCE)hInstance, (LPWSTR)"MAINACC");
  pRevClass = (PWNDCLASS)((CHAR *)LocalAlloc(LMEM_ZEROINIT, sizeof(WNDCLASS)));
  if (!pRevClass)
      return(FALSE);

  curLegal   = LoadCursorW(NULL, IDC_CROSS);
  curIllegal = LoadCursorW(NULL, IDC_ARROW);
  curThink   = LoadCursorW(NULL, IDC_WAIT);
  curBlank   = LoadCursorW((HINSTANCE)hInstance, MAKEINTRESOURCE(1));
  if (!curLegal || !curIllegal || !curThink || !curBlank)
      return(FALSE);
  pRevClass->hIcon = LoadIcon((HINSTANCE)hInstance, MAKEINTRESOURCE(3));

  pRevClass->lpszClassName = (LPWSTR)"Reversi";
  pRevClass->hbrBackground = ((COLOR) ? hbrGreen : hbrWhite);
  pRevClass->lpfnWndProc   = ReversiWndProc;
  pRevClass->lpszMenuName  = MAKEINTRESOURCE(1);
  pRevClass->hInstance    = (HINSTANCE)hInstance;
  pRevClass->style         = CS_VREDRAW | CS_HREDRAW | CS_BYTEALIGNCLIENT;

  if (!RegisterClass((LPWNDCLASS)pRevClass))
    {
      LocalFree((HANDLE)pRevClass);
      return(FALSE);
    }
  LocalFree((HANDLE)pRevClass);

  return(TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMouseClick() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevMouseClick(
HWND  hWnd,
POINT point)
{
  INT     move;
  INT     Si, Sj;
  INT     yLineExt = 8 * yExt;
  INT     xLineExt = 8 * xExt;
  HDC     hDC;

  MousePos.x = point.x;
  MousePos.y = point.y;

  if (xExt == 0 || yExt == 0)
      return;

  if ((point.x > Bx) && (point.x < (Bx+xLineExt)) && (point.y > By) && (point.y < (By+yLineExt)))
    {
      Si = (point.x - Bx) / xExt;
      Sj = (point.y - By) / yExt;
      move = Si * 10 + Sj + 11;
      if (legalcheck(board[0], move, human, computer))
        {
          board[0][move] = human;
          ffirstmove = FALSE;
          fThinking = TRUE;
          SetCursor((HICON)curThink);

          Graphics *gtemp;
          gtemp = g = new Graphics(hWnd);
          ClearMessageTop(g);

          minmax(board, move, human, computer, 0, -infin, infin);
          makemove(board[0], move, human, computer);

          g = gtemp;

          paintmove(board[0], BestMove[0], computer, human);
          gameover(hWnd, g, board, BestMove[0]);

          delete g;
          g = NULL;
          
          SetCursor((HICON)curIllegal);
          fThinking = FALSE;
        }
      else
          MessageBox(hWnd, (LPWSTR)szIllegal, (LPWSTR)szReversi, MB_OK | MB_ICONASTERISK);
   }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Next() -                                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL Next(
register INT *px,
register INT *py)

{
  (*px)++;
  if (*px > 7)
    {
      *px = 0;
      (*py)++;
      if (*py > 7)
          *py = 0;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Previous() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL Previous(
register INT *px,
register INT *py)
{
  (*px)--;
  if (*px < 0)
    {
      *px = 7;
      (*py)--;
      if (*py < 0)
          *py = 7;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ShowNextMove() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ShowNextMove(
HWND    hwnd,
BOOL    fforward)
{
  INT       x, y;
  INT       potentialmove;
  BOOL      done;

  /* What out for infinite loops. */
  if (fPass == PASS && !ffirstmove)
      return;

  x = (MousePos.x - Bx) / xExt;
  y = (MousePos.y - By) / yExt;

  done = FALSE;
  while (!done)
    {
      do
        {
          if (fforward)
              Next(&x, &y);
          else
              Previous(&x, &y);
        }
      while ((board[0][potentialmove = (x * 10 + y + 11)]) != empty);

      fThinking = TRUE;
      if (legalcheck(board[0], potentialmove, human, computer))
          done = TRUE;

      fThinking = FALSE;
    }

  MousePos.x = x * xExt + Bx + xExt / 2;
  MousePos.y = y * yExt + By + yExt / 2;

  UpdateCursor(hwnd);
  RevMouseMove(MousePos);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevChar() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevChar(
HWND            hwnd,
register WORD   code)
{
  INT   a;
  POINT curpoint;

  curpoint.x = curpoint.y = 1;
  switch (code)
    {
      case 0x27:
          MousePos.x += xExt;
          break;

      case 0x28:
          MousePos.y += yExt;
          break;

      case 0x25:
          curpoint.x = (MousePos.x - Bx)/xExt;
          MousePos.x -= xExt;
          break;

      case 0x26:
          curpoint.y = (MousePos.y - By)/yExt;
          MousePos.y -= yExt;
          break;

      case 0x24:
          curpoint.y = (MousePos.y - By)/yExt;
          curpoint.x = (MousePos.x - Bx)/xExt;
          MousePos.y -= yExt;
          MousePos.x -= xExt;
          break;

      case 0x21:
          curpoint.y = (MousePos.y - By)/yExt;
          MousePos.y -= yExt;
          MousePos.x += xExt;
          break;

      case 0x23:
          curpoint.x = (MousePos.x - Bx)/xExt;
          MousePos.y += yExt;
          MousePos.x -= xExt;
          break;

      case 0x22:
          MousePos.y += yExt;
          MousePos.x += xExt;
          break;

      case 0x0020:
      case 0x000D:
          if (!fThinking)
              RevMouseClick(hwnd, MousePos);
          return;

      case 0x0009:
          if (fThinking)
              break;
          if (GetKeyState(VK_SHIFT) < 0)
              ShowNextMove(hwnd, FALSE);    /* look backwards */
          else
              ShowNextMove(hwnd, TRUE);     /* look forwards */
          return;

      default:
          return;
    }

  if (((a = ((MousePos.x - Bx) / xExt)) >7) || a <= 0)
      MousePos.x = Bx + xExt / 2;             /* wrap around horizontally */

  if (a > 8 || (curpoint.x == 0 && a == 0))
      MousePos.x = (7*xExt) + Bx + xExt / 2 ;

  if ( ((a = ((MousePos.y - By) / yExt)) >7) || a <= 0)
      MousePos.y = By + yExt / 2;

  if ( a > 8 || (curpoint.y == 0 && a == 0))
      MousePos.y = (7*yExt) + By + yExt / 2;

  MousePos.x = ((MousePos.x - Bx) / xExt) * xExt + Bx + xExt / 2;
  MousePos.y = ((MousePos.y - By) / yExt) * yExt + By + yExt / 2;
  UpdateCursor(hwnd);
  RevMouseMove(MousePos);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  InverseMessage() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID APIENTRY InverseMessage(
register HWND   hWindow,
UINT            message,
UINT_PTR        wParam,
DWORD           lParam)
{
  HDC   hDC;

  message;
  wParam;
  lParam;

  if (flashtimes <= count)
    {

     // !! THIS STILL NEEDS WORK: How to do Inversion?
     //Graphics graphics(hWindow);
     // graphics.FillRectangle(hDC, 0, 0, xscr, charheight, DSTINVERT);
     // flashtimes++;
     // ReleaseDC(hWindow, hDC);
    }
  else
      KillTimer(hWindow, 666);

  return;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ReversiWndProc() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LRESULT APIENTRY ReversiWndProc(
HWND            hWnd,
register UINT   message,
WPARAM          wParam,
LPARAM          lParam)
{
  HMENU         hm;
  PAINTSTRUCT   ps;
  POINT         curpoint;

  switch (message)
    {
      case WM_COMMAND:
          RevMenu(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
          break;

      case WM_INITMENU:                 /* disable the menu if thinking */
          hm = GetMenu(hWnd);
          if (fThinking)
            {
              EnableMenuItem(hm, 0, MF_DISABLED | MF_BYPOSITION);
              EnableMenuItem(hm, 1, MF_DISABLED | MF_BYPOSITION);
            }
          else
            {
              EnableMenuItem(hm, 0, MF_ENABLED | MF_BYPOSITION);
              EnableMenuItem(hm, 1, MF_ENABLED | MF_BYPOSITION);
            }
          break;

      case WM_CREATE:
          RevCreate(hWnd);
          hWin = hWnd;
          break;

      case WM_CLOSE:
          if (hDisp)
              ReleaseDC(hWnd, hDisp);
          return(DefWindowProc(hWnd, message, wParam, lParam));

      case WM_DESTROY:
          if (MGetModuleUsage(hInst) == 1)
            {
              delete brGreen;
              delete brPat;
              delete brRed;
              delete brBlue;
            }

          /* In case WinHelp keys off hWindow, we need to do the HELP_QUIT
           * here instead of when there is just one instance of help...
           */
          //TEMPFIX WinHelp(hWnd, (LPSTR)szHelpFile, HELP_QUIT, 0L);

          PostQuitMessage(0);
          break;

      case WM_KEYDOWN:
          if (IsIconic(hWnd))
              return 0L;
          RevChar(hWnd, (WORD)wParam);
          break;

      case WM_ACTIVATE:
          if (!GetSystemMetrics(SM_MOUSEPRESENT))
            {
              if (GET_WM_ACTIVATE_STATE(wParam, lParam))
                {
                  if (GET_WM_ACTIVATE_HWND(wParam, lParam) != hWnd)
                    {
                      curpoint.x = MousePos.x;
                      curpoint.y = MousePos.y;
                      ClientToScreen(hWnd, (LPPOINT)&curpoint);
                      SetCursorPos(curpoint.x, curpoint.y);
                      RevMouseMove(MousePos);
                      ShowCursor(GET_WM_ACTIVATE_STATE(wParam, lParam));
                    }
                }
              else
                  ShowCursor((BOOL) wParam);
            }
          if (wParam && (!HIWORD(lParam)))
              SetFocus(hWnd);
          break;

      case WM_PAINT:
          BeginPaint(hWnd, (LPPAINTSTRUCT)&ps);
          {
             Graphics graphics(ps.hdc);
			 RECT rect;
			 GetClientRect(hWnd, &rect);
		     RectF rectf(rect.left, 
						 rect.top, 
						 rect.right-rect.left, 
						 rect.bottom-rect.top);
			 graphics.SetClip(rectf);
             RevPaint(hWnd, &graphics);
          }
          EndPaint(hWnd, (LPPAINTSTRUCT)&ps);
          break;

      case WM_MOUSEMOVE:
		  {
		  POINT pt;

		  LONG2POINT(lParam, pt);		/* convert LONG lParam to POINT structure*/
          if (!fThinking)
#ifdef ORGCODE		
              RevMouseMove(MAKEPOINT(lParam));
#else
              RevMouseMove(pt);
#endif
          else
              SetCursor((HICON)curThink);
          break;
		  }
      case WM_LBUTTONDOWN:
          SetCapture(hWnd);
          bMouseDownInReversi = TRUE;
          break;

      case WM_LBUTTONUP:
		  {
		  POINT pt;

		  LONG2POINT(lParam, pt);		/* convert LONG lParam to POINT structure*/

          ReleaseCapture();
          if (!fThinking && bMouseDownInReversi)
#ifdef ORGCODE
              RevMouseClick(hWnd, MAKEMPOINT(lParam));
#else
              RevMouseClick(hWnd, pt);
#endif
          bMouseDownInReversi = FALSE;
          break;
		  }
      case WM_TIMER:
          /* This should never be called. */
          break;

      case WM_VSCROLL:
      case WM_HSCROLL:
              break;

      default:
          return(DefWindowProc(hWnd, message, wParam, lParam));
          break;
      }
  return(0L);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AboutDlgProc()                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR APIENTRY AboutDlgProc(
HWND          hDlg,
UINT          message,
WPARAM        wParam,
LPARAM        lParam)

{
  if (message == WM_COMMAND)
    {
      EndDialog(hDlg, TRUE);
      return(TRUE);
    }
  if (message == WM_INITDIALOG)
      return(TRUE);
  else
      return(FALSE);
  UNREFERENCED_PARAMETER(wParam);	
  UNREFERENCED_PARAMETER(lParam);	
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WinMain() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

MMain(hInstance, hPrev, lpszCmdLine, cmdShow) /* { */
  HWND hWnd;
  MSG   msg;

  _argc;
  _argv;

  hInst = hInstance;
  if (!hPrev)
    {
      if (!RevInit(hInstance))
          return(FALSE);
    }
  else
    {
      if (fThinking)
          return FALSE;
#ifdef WIN16
      GetInstanceData(hPrev, (PSTR)&hbrBlack,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrPat,             sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrWhite,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrRed,             sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrBlue,            sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrGreen,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrComputer,        sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrHuman,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&curIllegal,         sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&curLegal,           sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&curThink,           sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&curBlank,           sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&prevCheck,          sizeof(prevCheck));
      GetInstanceData(hPrev, (PSTR)&depth,              sizeof(depth));
      GetInstanceData(hPrev, (PSTR)direc,               sizeof(direc));
      GetInstanceData(hPrev, (PSTR)moves,               sizeof(moves));
      GetInstanceData(hPrev, (PSTR)szReversi,           20);
      GetInstanceData(hPrev, (PSTR)szReversiPractice,   40);
      GetInstanceData(hPrev, (PSTR)szPass,              10);
      GetInstanceData(hPrev, (PSTR)szMustPass,          20);
      GetInstanceData(hPrev, (PSTR)szTie,               15);
      GetInstanceData(hPrev, (PSTR)szLoss,              15);
      GetInstanceData(hPrev, (PSTR)szWon,               15);
      GetInstanceData(hPrev, (PSTR)szAbout,             20);
      GetInstanceData(hPrev, (PSTR)&COLOR,              sizeof(INT));
      GetInstanceData(hPrev, (PSTR)&ASPECT,             sizeof(INT));
      GetInstanceData(hPrev, (PSTR)&hAccel,             2);
      GetInstanceData(hPrev, (PSTR)szIllegal,           70);
      GetInstanceData(hPrev, (PSTR)szNoPass,            70);
      GetInstanceData(hPrev, (PSTR)szHelpFile,          15);
#endif /* WIN16 */
    }

  TYMIN = 45;
  fThinking = FALSE;

  hWnd = CreateWindow((LPWSTR) "Reversi",
                fCheated ? (LPWSTR)szReversiPractice : (LPWSTR)szReversi,
                WS_TILEDWINDOW,
                CW_USEDEFAULT,
                0,
                (GetSystemMetrics(SM_CXSCREEN) >> 1),
                (GetSystemMetrics(SM_CYSCREEN) * 4 / 5),
                (HWND)NULL,
                (HMENU)NULL,
                (HINSTANCE)hInstance,
                NULL);

  if (!hWnd)
      return(FALSE);

  ShowWindow(hWnd, cmdShow);
  UpdateWindow(hWnd);

  /* Messaging Loop. */
  while (GetMessage((LPMSG)&msg, NULL, 0, 0))
    {
      if (!TranslateAccelerator(msg.hwnd, (HACCEL)hAccel, (LPMSG)&msg))
        {
          TranslateMessage((LPMSG)&msg);
          DispatchMessage((LPMSG)&msg);
        }
    }
  return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\samples\shapes\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\samples\shapes\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#define MM_NEW          0x8001
#define MM_EXIT         0x8002
#define MM_TEST         0x8003

VOID Test(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\samples\shapes\test.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998 Microsoft Corporation
*
* Module Name:
*
*   Test Cases to test our shapes
*
* Abstract:
*
*   This module will create some shapes. Save them to a metafile
*   and draw them in our window
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

#include "stdafx.h"
#include "shapes.h"

#define METAFILENAME L"MetaFile Sample.emf"


// Animate a shape. Fixed Size
VOID AnimateShape(Shape *shape, Graphics *g)
{
    // Validate Parameters
    if(shape != NULL && g != NULL)
    {
        // Draw a set of rotated shapes... From bigger to smaller
        // For now the size if fixed
        for(INT i = 18; i>0; i--)
        {
            shape->SetSize(10.0f*i, 10.0f*i);
            shape->SetAngle(i*10.0f);
            shape->Draw(g);

            // It important to flush to have a nice animation...
            g->Flush();
            Sleep(50);
        }
    }
}

// Draw some solid shapes
VOID TestSolidShapes(Graphics *g)
{
    // Validate Parameters
    if(g == NULL)
        return;

    // Create some brushes
    SolidBrush black(Color::Black);
    SolidBrush white(Color::White);
    SolidBrush transRed(Color(128, 255, 0, 0));
	SolidBrush transPink(Color(60, 255, 128, 255));

	// Create some pens
    Pen blackPen(Color::Black, 5);
	Pen bluePen(Color(255, 0, 0, 255), 10);
	Pen greenPen(Color(255, 0, 255, 0), 3);
    
    // Create some different shapes
    RectShape rect(&bluePen, &black, &black, L"Rectangle", L"Comic Sans MS");
    rect.SetPosition(50, 100);
    rect.SetSize(50, 50);
    rect.SetAngle(45);

    StarShape star(5, NULL, &transRed, &black, L"Star");
    star.SetPosition(150, 50);
    star.SetSize(50, 50);
    star.SetAngle(30);

    PieShape pie(&blackPen, &transPink, &black, L"Pie");
    pie.SetPosition(250, 50);
	pie.SetSize(100, 200);
    pie.SetAngle(-30);
    pie.SetPieAngle(90);

    EllipseShape circle(&greenPen, &white, &black, L"Ellipse");
    circle.SetPosition(400, 100);
    circle.SetSize(50, 200);

    RegularPolygonShape pentagon(5, NULL, &transPink, &black, L"Pentagon");
    pentagon.SetPosition(550, 50);
    pentagon.SetSize(100, 100);
    pentagon.SetAngle(14);

    CrossShape cross(&greenPen, &transRed, &black, L"Cross");
    cross.SetPosition(550, 150);
    cross.SetSize(50, 50);
    cross.SetAngle(30);
    
    // Draw all shapes
    rect.Draw(g);
    star.Draw(g);
    pie.Draw(g);
    circle.Draw(g);
    cross.Draw(g);
    pentagon.Draw(g);
}


// Draw some gradient shapes
VOID TestGradientShapes(Graphics *g)
{
    // Validate Parameters
    if(g == NULL)
        return;

    SolidBrush black(Color::Black);
	
    // Create the four exterior colors that will control the gradient
    Color gradColor[4] = {
		Color(128, 255, 0, 0),
		Color(255, 255, 255, 0),
		Color(128, 0, 255, 0),
		Color(128, 0, 0, 255)
	};


    // Do a linear gradient Brush and Pen
    LinearGradientBrush linearGradientBrush(Point(-100, -100), 
        Point(100, 100),
        Color(255, 0, 0, 255),
        Color(128, 255, 0, 0)
        );

    RegularPolygonShape polygon(10,
        NULL,
        &linearGradientBrush,
        &black,
        L"Gradient Polygons",
        L"Times New Roman"
        );

    polygon.SetSize(100, 100);
    polygon.SetPosition(500, 300);
    polygon.Draw(g);

    Pen gradPen(&linearGradientBrush);
    gradPen.SetWidth(20);

    // Make the line intersection round
    gradPen.SetLineJoin(LineJoinRound);

    // Draw a triangle. And then draw it animated
    RegularPolygonShape triangle(3, &gradPen, NULL);
    triangle.SetSize(100, 100);
    triangle.SetPosition(500, 300);
    triangle.SetAngle(180);
    triangle.Draw(g);
    triangle.SetPosition(500, 700);
    AnimateShape(&triangle, g);


    // Do a Path gradient brush, with colors at the four corners of a polygon
    Point Squarepoints[4] =
    { 
        Point(-100, -100), 
        Point(-100,100),
        Point(100,100),
        Point(100,-100)
    };

    INT size = numberof(gradColor);

	PathGradientBrush gradBrush(Squarepoints,
        numberof(Squarepoints),
        WrapModeClamp); // WrapModeExtrapolate is no longer supported.

    gradBrush.SetSurroundColors(gradColor, &size );
    gradBrush.SetCenterColor(Color(128, 128, 128, 64));
	
    // Draw an animated star
    StarShape star(12, NULL, &gradBrush);
    star.SetPosition(200, 300);
    AnimateShape(&star, g);

    // Draw some text now
    Shape Text(NULL, NULL, &black, L"Gradient Animated Star", L"Comic Sans MS");
    Text.SetPosition(100, 400);
    Text.Draw(g);
}


// Draw some textures shapes
VOID TestTextureShapes(Graphics *g)
{
    // Verify parameters
    if(g == NULL)
        return;

    SolidBrush black(Color::Black);

    // Load the texture
    Image texture(L"Texture.bmp");
    if(texture.GetLastStatus() != Ok)
        return;

    // Create a brush out of the texture
    TextureBrush textureBrush(&texture, WrapModeTile);

    // Draw an animated star
    StarShape star(6, NULL);
    star.SetPosition(150, 600);
    star.SetBrush(&textureBrush);
    AnimateShape(&star, g);

    // Draw some text now
    Shape Text(NULL, NULL, &black, L"Textured Animated Star", L"Comic Sans MS");
    Text.SetPosition(100, 750);
    Text.Draw(g);

    // Draw a polygon with a thick pen and a Clamped texture
    textureBrush.SetWrapMode(WrapModeClamp);
    Pen texturePen(&textureBrush);
    texturePen.SetWidth(30);
    RegularPolygonShape polygon(10, &texturePen, NULL, &black, L"Textured Polygon", L"Times New Roman");
    polygon.SetSize(100, 100);
    polygon.SetPosition(500, 500);
    polygon.Draw(g);
}

// Draw some hatched shapes
VOID TestHatchShapes(Graphics *g)
{
    // Verify parameters
    if(g == NULL)
        return;

    SolidBrush black(Color::Black);

    // Silver on Blue vertical hatch
    HatchBrush brush(HatchStyleVertical, Color::Silver, Color::Blue);

    Pen pen(&brush, 3.0f);
    pen.SetLineJoin(LineJoinRound);

    HatchBrush crossBrush(HatchStyleCross, Color::Fuchsia, Color::Red);

    StarShape star(8, &pen, &crossBrush, &black, L"Hatched Star");
    star.SetPosition(800, 75);
    star.SetSize(100, 100);
    star.Draw(g);

    pen.SetWidth(10);
    RegularPolygonShape line(2, &pen, NULL, &black, L"Hatched Line");
    line.SetPosition(800, 250);
    line.SetSize(100, 200);
    line.SetAngle(10);
    line.Draw(g);

    HatchBrush diagBrush(HatchStyleDiagonalCross, Color::Green, Color::White);
    CrossShape cross(NULL, &diagBrush, &black, L"Hatched Cross");
    cross.SetPosition(800, 400);
    cross.SetSize(50, 50);
    cross.Draw(g);
}


// Overall test
VOID TestRoutine(Graphics *g)
{
    // Verify parameters
    if(g == NULL)
        return;

    // Test some simple solid shapes
	TestSolidShapes(g);

    // Test some shapes with a gradient brush
	TestGradientShapes(g);

    // Test some shapes with some texture brushes
    TestTextureShapes(g);

    // Test some hatch pens and brushes
    TestHatchShapes(g);

    // Flush the graphics to make sure everything is displayed
    g->Flush();
}


// Draw to a metafile
VOID TestMetaFile(HDC hdc)
{
    // Create a metafile from the DC. We want to encompass the full region of the window
    // We want the units to be Pixels
    Metafile meta(METAFILENAME, hdc, RectF( 0.0f, 0.0f, 1600.0f, 1200.0f), MetafileFrameUnitPixel);

    // Create a graphics context for this metafile
    Graphics g(&meta);

    // Draw into the metafile
    TestRoutine(&g);
}


// Test routine
// Draw to a window
// Draw to a metafile
// Read the metafile, and draw it in our window with an offset
VOID Test(HWND hwnd)
{
    Graphics* g = Graphics::FromHWND(hwnd);
    TestRoutine(g);

    HDC dc = GetDC(hwnd);
    TestMetaFile(dc);
    ReleaseDC(hwnd, dc);

    Metafile meta(METAFILENAME);
    g->DrawImage(&meta, 100.0f, 100.0f);
    delete g;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\samples\shapes\shapes.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998 Microsoft Corporation
*
* Module Name:
*
*   Shapes Sample Classes Implementation
*
* Abstract:
*
*   This module implements the different shape classes that will be
*   used.
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

#include "stdafx.h"
#include "shapes.h"

#include <math.h>       // For sin and cos

/**************************************************************************\
*
* Function Description:
*
* Shape Constructor
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

Shape::Shape(Pen   *in_Pen,
             Brush *in_Brush,
             Brush *in_TextBrush,
             TCHAR* in_Text,
             TCHAR* in_FontFamily)
            : m_TextBrush(NULL)
            , m_Brush(NULL)
            , m_Pen(NULL)
            , m_Font(NULL)
            , m_szName(in_Text)
            , m_Points(NULL)
            , m_NPoints(0)
            , m_Angle(0)
            , m_SizeX(1.0f)
            , m_SizeY(1.0f)
            , m_PosX(0.0f)
            , m_PosY(0.0f)

{
    SetPen(in_Pen);
    SetBrush(in_Brush);
    SetTextBrush(in_TextBrush);

    // If we have a text brush then create a font for it
    if(m_TextBrush != NULL && m_szName != NULL)
    {
        if(in_FontFamily == NULL)
        {
            in_FontFamily = _T("Arial");
        }
        FontFamily fontFamily(in_FontFamily); 
        m_Font = new Font(&fontFamily, 12.0, 0, UnitWorld);
    }
}

/**************************************************************************\
*
* Function Description:
*
* Shape Desctuctor
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

Shape::~Shape()
{
    // Delete the font if allocated
    if(m_Font != NULL)
    {
        delete m_Font;
    }

    // Delete the control points
    if(m_Points != NULL)
    {
        delete m_Points;
        m_NPoints=0;
    }

    // Remove the brushes and pen
    SetPen(NULL);
    SetBrush(NULL);
    SetTextBrush(NULL);
}


/**************************************************************************\
*
* Function Description:
*
* Shape::SetPen
*
* Notes:
*   We clone the object to make sure that the Shape will be able to live
*   even if the pen is destroyed or modified
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::SetPen(Pen *in_Pen)
{
    // Remove the old pen
    if(m_Pen != NULL)
    {
        delete m_Pen;
        m_Pen = NULL;
    }

    // Set the new pen
    if(in_Pen != NULL)
    {
        m_Pen = in_Pen->Clone();
    }
}

/**************************************************************************\
*
* Function Description:
*
* Shape::SetBrush
*
* Notes:
*   We clone the object to make sure that the Shape will be able to live
*   even if the pen is destroyed or modified
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::SetBrush(Brush *in_Brush)
{
    // Remove the old brush
    if(m_Brush != NULL)
    {
        delete m_Brush;
        m_Brush = NULL;
    }

    // Set the new brush
    if(in_Brush != NULL)
    {
        m_Brush = in_Brush->Clone();
    }
}

/**************************************************************************\
*
* Function Description:
*
* Shape::SetBrush
*
* Notes:
*   We clone the object to make sure that the Shape will be able to live
*   even if the pen is destroyed or modified
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::SetTextBrush(Brush *in_Brush)
{
    // Remove the old brush
    if(m_TextBrush != NULL)
    {
        delete m_TextBrush;
        m_TextBrush = NULL;
    }

    // Set the new brush
    if(in_Brush != NULL)
    {
        m_TextBrush = in_Brush->Clone();
    }
}

/**************************************************************************\
*
* Function Description:
*
* Shape::Draw
*
* Notes:
*   Called to draw the shape.
*
* Parameters:
*   Graphics | *g | A pointer to a graphics object that we will be drawing
*                   into
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::Draw(Graphics *g)
{
    // Validate Parameters
    ASSERT(g != NULL);

    // Transform the world to map to the object
    g->SetTransform(&m_ObjectMatrix);

    // If we have a pen then draw the outline
    if(m_Pen != NULL)
    {
        // Call the derive class
        DrawShape(g);
    }

    // If we have a brush then draw the outline
    if(m_Brush != NULL)
    {
        // Call the derive class
        FillShape(g);
    }

    // Reset the world transform
    g->ResetTransform();

    // If we have a text brush then draw the outline
    if(m_TextBrush != NULL)
    {
        DrawText(g);
    }
}

/**************************************************************************\
*
* Function Description:
*
* Shape::Draw
*
* Notes:
*   Called to draw the text associated with the shape
*
* Parameters:
*   Graphics | *g | A pointer to a graphics object that we will be drawing
*                   into
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::DrawText(Graphics* g)
{
    // Validate Parameters
    ASSERT(g != NULL);

    // Set the text position to be 30 pixels right of the shape, based on its
    // size
    g->DrawString(m_szName,
                  _tcslen(m_szName),
                  m_Font,
                  PointF(m_PosX + m_SizeX / 2 + 30, m_PosY ),
                  m_TextBrush);
}


/**************************************************************************\
*
* Function Description:
*
* Shape::SetSize
*
* Notes:
*   Set the size of the shape in X and Y
*   The control points are then transformed with that scale, in order to
*   keep the pensize.
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::SetSize(REAL sizeX, REAL sizeY)
{
    // Don't do useless work
    if(m_SizeX == sizeX && m_SizeY == sizeY)
        return;

    // Save the new size
    m_SizeX = sizeX;
    m_SizeY = sizeY;

    // Reset the points to their default
    ResetPoints() ;

    // Scale the points according to the scale factor;
    if(m_NPoints != 0)
    {
        GpMatrix ScaleMatrix;
        ScaleMatrix.Scale(m_SizeX, m_SizeY);
        ScaleMatrix.TransformPoints(m_Points, m_NPoints);
    }

}

/**************************************************************************\
*
* Function Description:
*
* Shape::SetAngle
*
* Notes:
*   Set the rotation angle of the shape in degrees
*   The rotation is always applied before the translation
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::SetAngle(REAL Angle)
{
    // Don't do useless work
    if(m_Angle ==Angle)
        return;

    // Save the Angle
    m_Angle = Angle;

    // Recalculate the transformation matrix
    RecalcObjectMatrix();
}

/**************************************************************************\
*
* Function Description:
*
* Shape::SetPosition
*
* Notes:
*   Set the position of the center of the shape in X and Y
*   The translation is always applied after the rotation
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::SetPosition(REAL posX, REAL posY)
{
    // Don't do useless work
    if(m_PosX == posX && m_PosY == posY)
        return;

    // Save the new position
    m_PosX = posX;
    m_PosY = posY;

    // Recalculate the transformation matrix
    RecalcObjectMatrix();
}


/**************************************************************************\
*
* Function Description:
*
* Shape::RecalcObjectMatrix
*
* Notes:
*   Invalidate the Object Matrix
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::RecalcObjectMatrix()
{
    m_ObjectMatrix.Reset();
    m_ObjectMatrix.Translate(m_PosX, m_PosY);
    m_ObjectMatrix.Rotate(m_Angle);
}


/***************************************************************************\
 A Rectangular shape, of size 1
\***************************************************************************/
VOID RectShape::DrawShape(Graphics *g)
{
    g->DrawRectangle(m_Pen,
        m_Points[0].X,                  // Top Left Corner
        m_Points[0].Y,
        m_Points[1].X - m_Points[0].X,  // Width
        m_Points[1].Y - m_Points[0].Y   // Height
        );
}
VOID RectShape::FillShape(Graphics *g)
{
    g->FillRectangle(m_Brush,
        m_Points[0].X,                  // Top Left Corner
        m_Points[0].Y,
        m_Points[1].X - m_Points[0].X,  // Width
        m_Points[1].Y - m_Points[0].Y   // Height
        );
}


// Set the points to have a square of size 1
VOID RectShape::ResetPoints()
{
    ASSERT(m_Points != NULL && m_NPoints == 2);
    m_Points[0].X = -0.5f;
    m_Points[0].Y = -0.5f;
    m_Points[1].X =  0.5f;
    m_Points[1].Y = 0.5f;
}


/***************************************************************************\
 An elliptical shape, of diameter 1
\***************************************************************************/
VOID EllipseShape::DrawShape(Graphics *g)
{
    g->DrawEllipse(m_Pen,
        m_Points[0].X,                  // X pos
        m_Points[0].Y,                  // Y pos
        m_Points[1].X - m_Points[0].X,  // Width
        m_Points[1].Y - m_Points[0].Y   // Height
        );
}

VOID EllipseShape::FillShape(Graphics *g)
{
    g->FillEllipse(m_Brush,
        m_Points[0].X,                  // X pos
        m_Points[0].Y,                  // Y pos
        m_Points[1].X - m_Points[0].X,  // Width
        m_Points[1].Y - m_Points[0].Y   // Height
        );
}

VOID EllipseShape::ResetPoints()
{
    ASSERT(m_Points != NULL && m_NPoints == 2);
    m_Points[0].X = -0.5f;
    m_Points[0].Y = -0.5f;
    m_Points[1].X =  0.5f;
    m_Points[1].Y =  0.5f;
}


/***************************************************************************\
 An pie shape, of size approx 1.
\***************************************************************************/
VOID PieShape::DrawShape(Graphics *g)
{
    g->DrawPie(m_Pen,
        m_Points[0].X, // X pos
        m_Points[0].Y, // Y pos
        m_Points[1].X - m_Points[0].X, // Width
        m_Points[1].Y - m_Points[0].Y, // Height
        0,          // Start Angle (rotation takes care of that)
        m_PieAngle  // Total angle of the pie
        );
}

VOID PieShape::FillShape(Graphics *g)
{
    g->FillPie(m_Brush,
        m_Points[0].X, // X pos
        m_Points[0].Y, // Y pos
        m_Points[1].X - m_Points[0].X, // Width
        m_Points[1].Y - m_Points[0].Y, // Height
        0,          // Start Angle (rotation takes care of that)
        m_PieAngle  // Total angle of the pie
        );
}

VOID PieShape::ResetPoints()
{
    ASSERT(m_Points != NULL && m_NPoints == 2);
    m_Points[0].X = -0.5f;
    m_Points[0].Y = -0.5f;
    m_Points[1].X =  0.5f;
    m_Points[1].Y =  0.5f;
}


/***************************************************************************\
 An generic polygon shape
\***************************************************************************/
VOID PolygonShape::DrawShape(Graphics *g)
{
    g->DrawPolygon(m_Pen, m_Points, m_NPoints);
}

VOID PolygonShape::FillShape(Graphics *g)
{
    g->FillPolygon(m_Brush, m_Points, m_NPoints);
}


/***************************************************************************\
 An regular polygon shape, of size 1
\***************************************************************************/
VOID RegularPolygonShape::ResetPoints()
{
    // Need to have an even number of points!!!
    ASSERT(m_Points != NULL && m_NPoints > 0);

    REAL s, c, theta;
    const REAL pi = 3.1415926535897932f;

    // Start with the angle representing (0,1)
    theta = -pi/2;

    // Calculate the increment between points
    REAL increment = (2.0f * pi) / m_NPoints;

    // Create a star shape.
    for(INT i = 0; i < m_NPoints;)
    {
        // Calculate the outer point
        s = sinf(theta);
        c = cosf(theta);
        m_Points[i].X = c*0.5f;
        m_Points[i++].Y = s*0.5f;
        theta += increment;
    }
}

/***************************************************************************\
 An star shape, of size 1
\***************************************************************************/
VOID StarShape::ResetPoints()
{
    // Need to have an even number of points!!!
    ASSERT(m_Points != NULL && ((m_NPoints & 0x1) == 0));

    REAL s, c, theta;
    const REAL pi = 3.1415926535897932f;

    // Start with the angle representing -90 degrees (0, 1)
    theta = -pi/2;

    // Calculate the increment between points
    REAL increment = (2.0f * pi) / m_NPoints;

    // Create a star shape.
    for(INT i = 0; i < m_NPoints;)
    {
        // Calculate the outer point
        s = sinf(theta);
        c = cosf(theta);
        m_Points[i].X = c*0.5f;
        m_Points[i++].Y = s*0.5f;
        theta += increment;

        // Calculate the inflexion point
        s = sinf(theta);
        c = cosf(theta);
        m_Points[i].X = c*0.25f;
        m_Points[i++].Y = s*0.25f;
        theta += increment;
    }
}

/***************************************************************************\
 An cross shape, of size 1.
\***************************************************************************/
VOID CrossShape::ResetPoints()
{
    ASSERT(m_Points != NULL && m_NPoints == 12);
    m_Points[0].X = -1.0f/6.0f;
    m_Points[0].Y = -0.5f;
    m_Points[1].X =  1.0f/6.0f;
    m_Points[1].Y = -0.5f;

    m_Points[2].X =  1.0f/6.0f;
    m_Points[2].Y = -1.0f/6.0f;

    m_Points[3].X =  0.5f;
    m_Points[3].Y = -1.0f/6.0f;
    m_Points[4].X =  0.5f;
    m_Points[4].Y =  1.0f/6.0f;

    m_Points[5].X =  1.0f/6.0f;
    m_Points[5].Y =  1.0f/6.0f;

    m_Points[6].X =  1.0f/6.0f;
    m_Points[6].Y =  0.5f;
    m_Points[7].X = -1.0f/6.0f;
    m_Points[7].Y =  0.5f;

    m_Points[8].X = -1.0f/6.0f;
    m_Points[8].Y =  1.0f/6.0f;

    m_Points[9].X =  -0.5f;
    m_Points[9].Y =   1.0f/6.0f;
    m_Points[10].X = -0.5f;
    m_Points[10].Y = -1.0f/6.0f;

    m_Points[11].X = -1.0f/6.0f;
    m_Points[11].Y = -1.0f/6.0f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpletest\test.cpp ===
//
// GDI+ test program
//

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <windows.h>
#include <objbase.h>

#include "Gdiplus.h"

// Use the given namespace
using namespace Gdiplus;

CHAR* programName;      // program name
HINSTANCE appInstance;  // handle to the application instance
HWND hwndMain;          // handle to application's main window
INT argCount;           // command line argument count
CHAR** argArray;        // command line arguments


//
// Display an error message dialog and quit
//

VOID
Error(
    PCSTR fmt,
    ...
    )

{
    va_list arglist;

    va_start(arglist, fmt);
    vfprintf(stderr, fmt, arglist);
    va_end(arglist);

    exit(-1);
}

#define CHECKERROR(e) \
        { \
            if (!(e)) \
            { \
                Error("Error on line %d\n", __LINE__); \
            } \
        }

//
// Perform GDI+ tests
//

VOID
DoTest(
    HWND hwnd,
    HDC hdc
    )
{
  {
    Graphics *g = Graphics::GetFromHwnd(hwnd);

    Rect rect(0, 0, 120, 100);
    Region *region = new Region(rect);

    g->SetClip(region);

    delete region; 
    delete g;
  }
  {
    Graphics* g = Graphics::GetFromHwnd(hwnd);

    // Scale everything up by 1.5
    g->SetPageTransform(PageUnitDisplay, 1.5);

    Color red(255, 0, 0);

    SolidBrush redBrush(red);
    g->FillRectangle(&redBrush, 20, 20, 50, 50);

    Color alphacolor(128, 0, 255, 0);
    SolidBrush alphaBrush(alphacolor);
    g->FillRectangle(&alphaBrush, 10, 10, 40, 40);

    Point points[10];
    points[0].X = 50;
    points[0].Y = 50;
    points[1].X = 100;
    points[1].Y = 50;
    points[2].X = 120;
    points[2].Y = 120;
    points[3].X = 50;
    points[3].Y = 100;

    Color blue(128, 0, 0, 255);
    SolidBrush blueBrush(blue);
    g->FillPolygon(&blueBrush, (Point*)&points[0], 4);

    // Currently only Geometric pen works for lines. - ikkof 1/6/99.

    REAL width = 4;
    Color black(0,0,0);
    SolidBrush blackBrush(black);
    Pen blackPen(&blackBrush, width);
    g->DrawPolygon(&blackPen, (Point*)&points[0], 4);
//    g->DrawLines(&blackPen, points, 4, FALSE);

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellow(128, 255, 255, 0);
    SolidBrush yellowBrush(yellow);
    GraphicsPath* path = new GraphicsPath(FillModeAlternate);    
    path->AddBeziers((Point*)&points[0], 4);

    Region * region = new Region(path);
    g->FillRegion(&yellowBrush, region);
//    g->FillPath(&yellowBrush, path);
    g->DrawPath(&blackPen, path);
    delete path;
    delete region;

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 32, 32);
    Color* colors[4];

    colors[0] = new Color(255, 255, 255, 255);
    colors[1] = new Color(255, 255, 0, 0);
    colors[2] = new Color(255, 0, 255, 0);
    colors[3] = new Color(255, 0, 0, 255);
    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors[0], WrapModeTile);

    delete colors[0];
    delete colors[1];
    delete colors[2];
    delete colors[3];

    g->FillRectangle(&rectGrad, 200, 20, 100, 80);

    // Change the wrapping mode and fill.

    rectGrad.SetWrapMode(WrapModeTileFlipXY);
    g->FillRectangle(&rectGrad, 350, 20, 100, 80);
    g->DrawRectangle(&blackPen, brushRect);

    // Create a radial gradient brush.

    Color centerColor(255, 255, 255, 255);
    Color boundaryColor(255, 0, 0, 0);
    brushRect.X = 380;
    brushRect.Y = 130;
    RadialGradientBrush radGrad(brushRect, centerColor,
                        boundaryColor, WrapModeClamp);

    g->FillRectangle(&radGrad, 320, 120, 120, 100);

    // Load bmp files.

    WCHAR *filename = L"winnt256.bmp";
    Bitmap *bitmap = new Bitmap(filename);

    // Create a texture brush.
/*
    Rect copyRect;
    copyRect.X = 60;
    copyRect.Y = 60;
    copyRect.Width = 80;
    copyRect.Height = 60;
    Bitmap *copiedBitmap = bitmap->CopyArea(&copyRect, Bm32bppARGB);

    if(copiedBitmap)
    {
        // Create a texture brush.

        Texture textureBrush = Texture(copiedBitmap, WrapModeTile);
        copiedBitmap->Dispose();

        // Create a radial gradient pen.

        GeometricPen gradPen(width, &rectGrad);

        points[0].X = 50;
        points[0].Y = 300;
        points[1].X = 100;
        points[1].Y = 300;
        points[2].X = 120;
        points[2].Y = 370;
        points[3].X = 50;
        points[3].Y = 350;
        g->FillPolygon(&textureBrush, (Point*)&points[0], 4);
        g->DrawPolygon(&gradPen, (Point*)&points[0], 4);

        points[0].X = 100;
        points[0].Y = 160;
        points[1].X = -50;
        points[1].Y = 160;
        points[2].X = 150;
        points[2].Y = 350;
        points[3].X = 200;
        points[3].Y = 220;
        path = new Path(FillModeAlternate);
        path->AddBeziers((Point*)&points[0], 4);
        g->FillPath(&textureBrush, path);
//        g->FillPath(&rectGrad, path);
        g->DrawPath(&gradPen, path);

        delete path;
    }

    Rectangle destRect(220, 300, 180, 120);
    Rectangle srcRect;
    srcRect.X = 20;
    srcRect.Y = 20;
    srcRect.Width = 180;
    srcRect.Height = 180;
    g->DrawImage(bitmap, &destRect);
//    g->DrawImage(bitmap, destRect, srcRect);

    bitmap->Dispose();
/
 //   TestPath2(g);
 //   TestPrimitives(g);

    delete g;

    // TODO:  Mem leaks on other allocated memory.

/*
  {
    GeometricPen *pen = 
            new GeometricPen((REAL)1.0, (Gdiplus::Brush*)0);


    Rectangle rectf;

    Point pointf(1.0, 2.0);
  }


  {
    Gdiplus::GeometricPen *pen =
            new Gdiplus::GeometricPen((REAL)1.0, (Gdiplus::Brush*)0);


    Gdiplus::Rectangle rectf;

    Gdiplus::Point pointf(1.0, 2.0);
  }
  */
  }

}


//
// Window callback procedure
//

LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

{
    switch (uMsg)
    {
    case WM_PAINT:
        {
            HDC hdc;
            PAINTSTRUCT ps;

            hdc = BeginPaint(hwnd, &ps);
            DoTest(hwnd, hdc);
            EndPaint(hwnd, &ps);
        }
        break;

    case WM_DESTROY:

        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//
// Create main application window
//

VOID
CreateMainWindow(
    VOID
    )

#define MYWNDCLASSNAME TEXT("GdiplusDllTest")

{
    //
    // Register window class if necessary
    //

    static BOOL wndclassRegistered = FALSE;

    if (!wndclassRegistered)
    {
        WNDCLASS wndClass =
        {
            CS_HREDRAW|CS_VREDRAW,
            MyWindowProc,
            0,
            0,
            appInstance,
            NULL,
            LoadCursor(NULL, IDC_ARROW),
            (HBRUSH) (COLOR_WINDOW+1),
            NULL,
            MYWNDCLASSNAME
        };

        RegisterClass(&wndClass);
        wndclassRegistered = TRUE;
    }

    hwndMain = CreateWindow(
                    MYWNDCLASSNAME,
                    MYWNDCLASSNAME,
                    WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    NULL,
                    NULL,
                    appInstance,
                    NULL);
}


//
// Main program entrypoint
//

INT _cdecl
main(
    INT argc,
    CHAR **argv
    )

{
    programName = *argv++;
    argc--;
    appInstance = GetModuleHandle(NULL);
    argCount = argc;
    argArray = argv;

    //
    // Create the main application window
    //

    CreateMainWindow();

    //
    // Main message loop
    //

    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\samples\shapes\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

#include "stdafx.h"
// for Win95 compile
//#undef UNICODE
//#undef _UNICODE

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <gdiplus.h>

#include "wndstuff.h"

#include "../../gpinit.inc"


HINSTANCE ghInstance;
HWND ghwndMain;
HWND ghwndDebug;
HWND ghwndList;
HBRUSH ghbrWhite;

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LRESULT
_stdcall lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{

    switch (message)
    {
    case WM_CREATE:
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case MM_TEST:
            Test(hwnd);
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
//        UninitializeEngine();

        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/******************************Public*Routine******************************\
* DebugWndProc
*
* List box is maintained here.
*
\**************************************************************************/

LRESULT FAR PASCAL DebugWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT    rcl;
    LRESULT lRet = 0;

// Process window message.

    switch (message)
    {
    case WM_SIZE:
        lRet = (LONG) DefWindowProc(ghwndList, message, wParam, lParam);
        GetClientRect(ghwndMain, &rcl);
        MoveWindow(
            ghwndList,
            rcl.left, rcl.top,
            (rcl.right - rcl.left), (rcl.bottom - rcl.top),
            TRUE
            );
        UpdateWindow(ghwndList);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        lRet = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    }

    return lRet;
}

/******************************Public*Routine******************************\
* LBprintf
*
* ListBox printf implementation.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBprintf(PCH msg, ...)
{
    if (ghwndList)
    {
        va_list ap;
        char buffer[256];

        va_start(ap, msg);

        vsprintf(buffer, msg, ap);

        SendMessage(ghwndList, LB_ADDSTRING, (WPARAM) 0, (LPARAM) buffer);
        SendMessage(ghwndList, WM_SETREDRAW, (WPARAM) TRUE, (LPARAM) 0);
        InvalidateRect(ghwndList, NULL, TRUE);
        UpdateWindow(ghwndList);

        va_end(ap);
    }
}

/******************************Public*Routine******************************\
* LBreset
*
* Reset ListBox state (clear).
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBreset()
{
    if (ghwndList)
        SendMessage(ghwndList, LB_RESETCONTENT, (WPARAM) FALSE, (LPARAM) 0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(BOOL debug)
{
    WNDCLASS wc;

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_VISIBLE      |  
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL);

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }

    if (debug)
    {
        RECT rcl;

        memset(&wc, 0, sizeof(wc));
        wc.style = 0;
        wc.lpfnWndProc = DebugWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = ghInstance;
        wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = ghbrWhite;
        wc.lpszClassName = _T("DebugWClass");
        RegisterClass(&wc);

        ghwndDebug = CreateWindow(
            _T("DebugWClass"),
            _T("Debug output"),
            WS_OVERLAPPEDWINDOW|WS_MAXIMIZE,
            600,
            70,
            300,
            500,
            NULL,
            NULL,
            ghInstance,
            NULL
            );

        if (ghwndDebug)
        {
            ShowWindow(ghwndDebug, SW_NORMAL);
            UpdateWindow(ghwndDebug);

        // Create the list box to fill the main window.

            GetClientRect(ghwndDebug, &rcl);

            ghwndList = CreateWindow(
                _T("LISTBOX"),
                _T("Debug output"),
                WS_CHILD | WS_VISIBLE | WS_VSCROLL
                | WS_HSCROLL | LBS_NOINTEGRALHEIGHT,
                rcl.left, rcl.top,
                (rcl.right - rcl.left), (rcl.bottom - rcl.top),
                ghwndDebug,
                NULL,
                ghInstance,
                NULL
                );

            if (ghwndList)
            {
                SendMessage(
                    ghwndList,
                    WM_SETFONT,
                    (WPARAM) GetStockObject(ANSI_FIXED_FONT),
                    (LPARAM) FALSE
                    );

                LBreset();

                ShowWindow(ghwndList, SW_NORMAL);
                UpdateWindow(ghwndList);
            }
        }

    }

    SetFocus(ghwndMain);

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/


_cdecl main(
    INT   argc,
    PTCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
    
    BOOL wantDebugWindow = FALSE;

    CoInitialize(NULL);

    // Parse arguments

    for (argc--, argv++ ; argc && '-' == **argv ; argc--, argv++ )
    {
        switch ( *(++(*argv)) )
        {
        case 'd':
        case 'D':
            wantDebugWindow = TRUE;
            break;
        }
    }

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp(wantDebugWindow))
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    CoUninitialize();
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\ddhelper.cpp ===
// File:	ddhelper.cpp
// Author:	Michael Marr    (mikemarr)

#include "StdAfx.h"
#include "DDHelper.h"
#include "Blt.h"

const PALETTEENTRY g_peZero = {0, 0, 0, 0};
const GUID g_guidNULL = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};

const DDPIXELFORMAT g_rgDDPF[iPF_Total] = {
	{sizeof(DDPIXELFORMAT), 0, 0, 0, 0x00, 0x00, 0x00, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED1, 0, 1, 0x00, 0x00, 0x00, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED2, 0, 2, 0x00, 0x00, 0x00, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED4, 0, 4, 0x00, 0x00, 0x00, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED8, 0, 8, 0x00, 0x00, 0x00, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 8, 0xE0, 0x1C, 0x03, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_ALPHAPIXELS, 0, 16, 0xF00, 0xF0, 0xF, 0xF000},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 16, 0xF800, 0x07E0, 0x001F, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 16, 0x001F, 0x07E0, 0xF800, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 16, 0x7C00, 0x03E0, 0x001F, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_ALPHAPIXELS, 0, 16, 0x7C00, 0x03E0, 0x001F, 0x8000},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 24, 0xFF0000, 0xFF00, 0xFF, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 24, 0xFF, 0xFF00, 0xFF0000, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 32, 0xFF0000, 0xFF00, 0xFF, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 32, 0xFF, 0xFF00, 0xFF0000, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_ALPHAPIXELS, 0, 32, 0xFF0000, 0xFF00, 0xFF, 0xFF000000},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_ALPHAPIXELS, 0, 32, 0xFF, 0xFF00, 0xFF0000, 0xFF000000},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 24, 0xFF0000, 0xFF00, 0xFF, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 32, 0xFF0000, 0xFF00, 0xFF, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 32, 0xFF, 0xFF00, 0xFF0000, 0x00}
};

/*
const GUID *g_rgpDDPFGUID[iPF_Total] = {
	&g_guidNULL,
	&DDPF_RGB1, &DDPF_RGB2, &DDPF_RGB4, &DDPF_RGB8,
	&DDPF_RGB332, &DDPF_ARGB4444, &DDPF_RGB565, &DDPF_BGR565, &DDPF_RGB555,
	&DDPF_ARGB1555, &DDPF_RGB24, &DDPF_BGR24, &DDPF_RGB32, &DDPF_BGR32,
	&DDPF_ARGB32, &DDPF_ABGR32, &DDPF_RGB24, &DDPF_RGB32, &DDPF_BGR32
};

DWORD
GetPixelFormat(const GUID *pGUID)
{
	for (DWORD i = 0; i < iPF_RGBTRIPLE; i++) {
		if ((pGUID == g_rgpDDPFGUID[i]) ||
			IsEqualGUID(*pGUID, *g_rgpDDPFGUID[i]))
			return i;
	}
	return iPF_NULL;
}

*/
const CPixelInfo g_rgPIXI[iPF_Total] = {
	CPixelInfo(0), CPixelInfo(1), CPixelInfo(2), CPixelInfo(4), CPixelInfo(8),
	CPixelInfo(8, 0xE0, 0x1C, 0x03, 0x00),
	CPixelInfo(16, 0xF00, 0xF0, 0xF, 0xF000),
	CPixelInfo(16, 0xF800, 0x07E0, 0x001F, 0x00),
	CPixelInfo(16, 0x001F, 0x07E0, 0xF800, 0x00),
	CPixelInfo(16, 0x7C00, 0x03E0, 0x001F, 0x00),
	CPixelInfo(16, 0x7C00, 0x03E0, 0x001F, 0x8000),
	CPixelInfo(24, 0xFF0000, 0xFF00, 0xFF, 0x00),
	CPixelInfo(24, 0xFF, 0xFF00, 0xFF0000, 0x00),
	CPixelInfo(32, 0xFF0000, 0xFF00, 0xFF, 0x00),
	CPixelInfo(32, 0xFF, 0xFF00, 0xFF0000, 0x00),
	CPixelInfo(32, 0xFF0000, 0xFF00, 0xFF, 0xFF000000),
	CPixelInfo(32, 0xFF, 0xFF00, 0xFF0000, 0xFF000000),
	CPixelInfo(24, 0xFF0000, 0xFF00, 0xFF, 0x00),
	CPixelInfo(32, 0xFF0000, 0xFF00, 0xFF, 0x00),
	CPixelInfo(32, 0xFF, 0xFF00, 0xFF0000, 0x00)
};


DWORD
GetPixelFormat(const DDPIXELFORMAT &ddpf)
{
	for (DWORD i = 0; i < iPF_RGBTRIPLE; i++) {
		if (ddpf == g_rgDDPF[i])
			return i;
	}
	return iPF_NULL;
}

DWORD
GetPixelFormat(const CPixelInfo &pixi)
{
	for (DWORD i = 0; i < iPF_RGBTRIPLE; i++)
		if (pixi == g_rgPIXI[i])
			return i;
	return iPF_NULL;
}


DWORD g_rgdwBPPToPalFlags[9] = {
	0, DDPCAPS_1BIT, DDPCAPS_2BIT, 0, DDPCAPS_4BIT,
	0, 0, 0, DDPCAPS_8BIT};
DWORD g_rgdwBPPToPixFlags[9] = {
	0, DDPF_PALETTEINDEXED1, DDPF_PALETTEINDEXED2, 0, 
	DDPF_PALETTEINDEXED4, 0, 0, 0, DDPF_PALETTEINDEXED8};

DWORD
PaletteToPixelFlags(DWORD dwFlags)
{
	if (dwFlags & DDPCAPS_8BIT) return DDPF_PALETTEINDEXED8;
	if (dwFlags & DDPCAPS_4BIT) return DDPF_PALETTEINDEXED4;
	if (dwFlags & DDPCAPS_2BIT) return DDPF_PALETTEINDEXED2;
	if (dwFlags & DDPCAPS_1BIT) return DDPF_PALETTEINDEXED1;
	return 0;
}

DWORD
PixelToPaletteFlags(DWORD dwFlags)
{
	if (dwFlags & DDPF_PALETTEINDEXED8) return DDPCAPS_8BIT;
	if (dwFlags & DDPF_PALETTEINDEXED4) return DDPCAPS_4BIT;
	if (dwFlags & DDPF_PALETTEINDEXED2) return DDPCAPS_2BIT;
	if (dwFlags & DDPF_PALETTEINDEXED1) return DDPCAPS_1BIT;
	return 0;
}

BYTE
PixelFlagsToBPP(DWORD dwFlags)
{
	if (dwFlags & DDPF_PALETTEINDEXED8) return (BYTE) 8;
	if (dwFlags & DDPF_PALETTEINDEXED4) return (BYTE) 4;
	if (dwFlags & DDPF_PALETTEINDEXED2) return (BYTE) 2;
	if (dwFlags & DDPF_PALETTEINDEXED1) return (BYTE) 1;
	return (BYTE) 0;
}

BYTE
PaletteFlagsToBPP(DWORD dwFlags)
{
	if (dwFlags & DDPCAPS_8BIT) return (BYTE) 8;
	if (dwFlags & DDPCAPS_4BIT) return (BYTE) 4;
	if (dwFlags & DDPCAPS_2BIT) return (BYTE) 2;
	if (dwFlags & DDPCAPS_1BIT) return (BYTE) 1;
	return (BYTE) 0;
}


HRESULT
CreatePlainSurface(IDirectDraw *pDD, DWORD nWidth, DWORD nHeight, 
				   const DDPIXELFORMAT &ddpf, IDirectDrawPalette *pddp,
				   DWORD dwTransColor, bool bTransparent,
				   IDirectDrawSurface **ppdds)
{
	if (!pDD || !ppdds)
		return E_INVALIDARG;

	HRESULT hr;
	DDSURFACEDESC ddsd;
	INIT_DXSTRUCT(ddsd);
    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS | DDSD_PIXELFORMAT;
	ddsd.dwWidth = nWidth;
	ddsd.dwHeight = nHeight;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
	ddsd.ddpfPixelFormat = ddpf;

	LPDIRECTDRAWSURFACE pdds;
	if (FAILED(hr = pDD->CreateSurface(&ddsd, &pdds, NULL)))
		return hr;

	// attach palette if it exists
	if (pddp && FAILED(hr = pdds->SetPalette(pddp))) {
		pdds->Release();
		return hr;
	}

	// set the source color key
	if (bTransparent) {
		DDCOLORKEY ddck = {dwTransColor, dwTransColor};
		if (FAILED(hr = pdds->SetColorKey(DDCKEY_SRCBLT, &ddck))) {
			pdds->Release();
			return hr;
		}
	}

	*ppdds = pdds;

	return hr;
}


HRESULT
CreatePalette(IDirectDraw *pDD, const BYTE *pPalette, DWORD cEntries, 
			  BYTE nBPPTarget, const CPixelInfo &pixiPalFmt, 
			  IDirectDrawPalette **ppddp)
{
	if (!ppddp)
		return E_POINTER;

	if (!pDD || !pPalette || (cEntries > 256) || (nBPPTarget == 0) || (nBPPTarget > 8))
		return E_INVALIDARG;

	HRESULT hr;
	PALETTEENTRY rgpe[256];

	if ((pixiPalFmt != g_rgPIXI[iPF_PALETTEENTRY]) || (cEntries < (DWORD(1) << nBPPTarget))) {
		// copy info to palette
		if (FAILED(hr = BltFastRGBToRGB(pPalette, 0, (LPBYTE) rgpe, 0, cEntries, 
							1, pixiPalFmt, g_rgPIXI[iPF_PALETTEENTRY])))
			return hr;
		// zero out extra palette entries
		ZeroDWORDAligned((LPDWORD) rgpe + cEntries, 256 - cEntries);
		pPalette = (const BYTE *) rgpe;
	}

	DWORD dwPalFlags = BPPToPaletteFlags(nBPPTarget) | DDPCAPS_ALLOW256;
	return pDD->CreatePalette(dwPalFlags, (LPPALETTEENTRY) pPalette, ppddp, NULL);
}


HRESULT
ClearToColor(LPRECT prDst, LPDIRECTDRAWSURFACE pdds, DWORD dwColor)
{
	HRESULT hr;
	MMASSERT(pdds);
	
	DDBLTFX ddbfx;
	INIT_DXSTRUCT(ddbfx);
	ddbfx.dwFillColor = dwColor;
	
	RECT rDst;
	if (prDst == NULL) {
		::GetSurfaceDimensions(pdds, &rDst);
		prDst = &rDst;
	}

	hr = pdds->Blt(prDst, NULL, NULL, DDBLT_COLORFILL | DDBLT_ASYNC, &ddbfx);

	if (hr == E_NOTIMPL) {
		// fill by hand
		DDSURFACEDESC(ddsd);
		INIT_DXSTRUCT(ddsd);
		CHECK_HR(hr = pdds->Lock(&rDst, &ddsd, DDLOCK_WAIT, NULL));
		CHECK_HR(hr = DrawFilledBox(ddsd, rDst, dwColor));
e_Exit:
		pdds->Unlock(ddsd.lpSurface);
		return hr;
	} else {
		return hr;
	}
}


// blue is assumed to have a weight of 1.f
#define fSimpleRedWeight 2.1f
#define fSimpleGreenWeight 2.4f
#define fMaxColorDistance ((1.f + fSimpleRedWeight + fSimpleGreenWeight) * float(257 * 256))

static inline float
_ColorDistance(const PALETTEENTRY &pe1, const PALETTEENTRY &pe2)
{
	float fTotal, fTmpR, fTmpG, fTmpB;
	fTmpR = (float) (pe1.peRed - pe2.peRed);
	fTotal = fSimpleRedWeight * fTmpR * fTmpR;
	fTmpG = (float) (pe1.peGreen - pe2.peRed);
	fTotal += fSimpleGreenWeight * fTmpG * fTmpG;
	fTmpB = (float) (pe1.peBlue - pe2.peRed);
	// blue is assumed to have a weight of 1.f
	fTotal += fTmpB * fTmpB;

	return fTotal;
}

DWORD
SimpleFindClosestIndex(const PALETTEENTRY *rgpePalette, DWORD cEntries, 
					   const PALETTEENTRY &peQuery)
{
	MMASSERT(rgpePalette);

	float fTmp, fMinDistance = fMaxColorDistance;
	DWORD nMinIndex = cEntries;

	for (DWORD i = 0; i < cEntries; i++) {
		const PALETTEENTRY &peTmp = rgpePalette[i];
		if (!(peTmp.peFlags & (PC_RESERVED | PC_EXPLICIT))) {
			if ((fTmp = _ColorDistance(peTmp, peQuery)) < fMinDistance) {
				// check for exact match
				if (fTmp == 0.f)
					return i;
				nMinIndex = i;
				fMinDistance = fTmp;
			}
		}
	}
	MMASSERT(nMinIndex < cEntries);
	return nMinIndex;
}


// Function: GetColors
//    Compute packed/indexed color values for the given surface that most closely
//  matches the given color values.  Alpha can be expressed by using the peFlags
//  field.
HRESULT
GetColors(LPDIRECTDRAWSURFACE pdds, const PALETTEENTRY *rgpeQuery, 
		  DWORD cEntries, LPDWORD pdwColors)
{
	HRESULT hr;
	if (!pdwColors)
		return E_POINTER;
	if (!pdds || !rgpeQuery || (cEntries == 0))
		return E_INVALIDARG;

	DDSURFACEDESC ddsd;
	ddsd.dwSize = sizeof(DDSURFACEDESC);

	if (FAILED(hr = pdds->GetSurfaceDesc(&ddsd)))
		return hr;

	CPixelInfo pixi(ddsd.ddpfPixelFormat);

	if (pixi.IsRGB()) {
		for (DWORD i = 0; i < cEntries; i++)
			pdwColors[i] = pixi.Pack(rgpeQuery[i]);
	} else {
		LPDIRECTDRAWPALETTE pddp = NULL;
		PALETTEENTRY rgpe[256];
		if (FAILED(hr = pdds->GetPalette(&pddp)) ||
			FAILED(hr = pddp->GetEntries(0, 0, 256, rgpe)))
			return hr;
		for (DWORD i = 0; i < cEntries; i++) {
                        // what if the palette is not 8 bit?
			pdwColors[i] = SimpleFindClosestIndex(rgpe, 256, rgpeQuery[i]);
		}
	}

	return S_OK;
}


HRESULT
GetSurfaceDimensions(LPDIRECTDRAWSURFACE pdds, LPRECT prDim)
{
	MMASSERT(pdds && prDim);

	HRESULT hr;
	DDSURFACEDESC ddsd;
	ddsd.dwSize = sizeof(DDSURFACEDESC);
	if (FAILED(hr = pdds->GetSurfaceDesc(&ddsd))) {
		return hr;
	}
	prDim->left = prDim->top = 0;
	prDim->right = (long) ddsd.dwWidth;
	prDim->bottom = (long) ddsd.dwHeight;

	return S_OK;
}


HRESULT
CopyPixels8ToDDS(const BYTE *pSrcPixels, RECT rSrc, long nSrcPitch, 
				 LPDIRECTDRAWSURFACE pddsDst, DWORD nXPos, DWORD nYPos)
{
	if (!pddsDst || !pSrcPixels)
		return E_INVALIDARG;

	HRESULT hr;

	bool bLocked = FALSE;

	DDSURFACEDESC ddsd;
	INIT_DXSTRUCT(ddsd);

	DWORD nSrcWidth = rSrc.right - rSrc.left;
	DWORD nSrcHeight = rSrc.bottom - rSrc.top;
	LPBYTE pDstPixels = NULL;

	RECT rDst = {nXPos, nYPos, nXPos + nSrcWidth, nYPos + nSrcHeight};

	// lock the surface for writing
	if (FAILED(hr = pddsDst->Lock(&rDst, &ddsd, DDLOCK_WAIT, NULL)))
		return hr;
	bLocked = TRUE;

	// check that the surface is the right size for the copy
	if (((ddsd.dwWidth - nXPos) < nSrcWidth) || 
		((ddsd.dwHeight - nYPos) < nSrcHeight) ||
		(ddsd.ddpfPixelFormat.dwRGBBitCount != 8))
	{
		hr = E_INVALIDARG;
		goto e_CopyPixelsToDDS;
	}

	//
	// copy the pixels
	//
	pDstPixels = (LPBYTE) ddsd.lpSurface;
	
	// position the source pixel pointer
	pSrcPixels += rSrc.top * nSrcPitch + rSrc.left;

	hr = BltFast(pSrcPixels, nSrcPitch, pDstPixels, ddsd.lPitch, 
			nSrcWidth, nSrcHeight);
	
e_CopyPixelsToDDS:
	if (bLocked)
		pddsDst->Unlock(ddsd.lpSurface);

	return hr;
}


HRESULT
CreateSurfaceWithText(LPDIRECTDRAW pDD, LPDIRECTDRAWPALETTE pddp, 
					  bool bTransparent, DWORD iTrans, 
					  const char *szText, HFONT hFont, 
					  bool bShadowed, SIZE *psiz, 
					  LPDIRECTDRAWSURFACE *ppdds)
{
	MMASSERT(ppdds && psiz);
	// check arguments
	if ((szText == NULL) || (szText[0] == '\0') || (hFont == NULL) || (pDD == NULL) ||
		(iTrans >= 256))
		return E_INVALIDARG;

	HRESULT hr;
	HDC hDC = NULL;
	HGDIOBJ hOldFont = NULL, hOldDIB = NULL;
	LPDIRECTDRAWSURFACE pdds = NULL;
	BOOL b = FALSE;
	SIZE sizText;
	RECT rText;
	DDCOLORKEY ddck;

	ddck.dwColorSpaceLowValue = ddck.dwColorSpaceHighValue = iTrans;

	if (bTransparent == FALSE)
		iTrans = 0;

	int cTextLength = strlen(szText);

	//
	// compute the size and create the DDS
	//
	hr = E_FAIL;

		// open the DC
	b =(((hDC = GetDC(NULL)) == NULL) ||
		// select the font into the DC
		((hOldFont = SelectObject(hDC, hFont)) == NULL) ||
		// compute the size of the fontified string in pixels
		(GetTextExtentPoint32(hDC, szText, cTextLength, &sizText) == 0)) ||
		// set the size of the rect
		((SetRect(&rText, 0, 0, GetClosestMultipleOf4(sizText.cx, TRUE), 
			GetClosestMultipleOf4(sizText.cy, TRUE)) == 0) ||
		// create the DDS based on the extent
		FAILED(hr = CreatePlainSurface(pDD, rText.right, rText.bottom, 
						g_rgDDPF[iPF_Palette8], pddp, iTrans, bTransparent, &pdds)) ||
		// clear the surface to the transparency color
		FAILED(hr = ClearToColor(&rText, pdds, iTrans)));

	int nXOffset = (rText.right - sizText.cx) >> 1;
	int nYOffset = (rText.bottom - sizText.cy) >> 1;

	// update the size
	sizText.cx = rText.right;
	sizText.cy = rText.bottom;

	// clean up the DC
	if (hDC) {
		if (hOldFont) {
			// select the old object back into the DC
			SelectObject(hDC, hOldFont);
			hOldFont = NULL;
		}
		ReleaseDC(NULL, hDC);
		hDC = NULL;
	}

	if (b)
		return hr;

	//
	// output the font to the DDS
	//
#ifdef __GetDCWorksOnOffscreenSurfaces

		// open the DC on the surface
	b =(FAILED(hr = pdds->GetDC(&hDC)) ||
		// select in the font
		((hOldFont = SelectObject(hDC, hFont)) == NULL) ||
		// set the color of the text (the background is transparent)
		(SetTextColor(hDC, RGB(255,255,255)) == CLR_INVALID) ||
		(SetBkMode(hDC, TRANSPARENT) == 0) ||
		// output the text to the surface
		(ExtTextOut(hDC, 0, 0, 0, &rText, szText, cTextLength, NULL) == 0));

	// clean up the DC again
	if (hDC) {
		pdds->ReleaseDC(hDC);
		hDC = NULL;
	}
	if (b) {
		MMRELEASE(pdds);
		return (hr == S_OK ? E_FAIL : hr);
	}

#else

	HBITMAP hDIB = NULL;
	LPBYTE pDIBPixels = NULL;
	PALETTEENTRY rgpe[256];
	HDC hdcMem = NULL;
	PALETTEENTRY &peTrans = rgpe[iTrans];

	MMASSERT((hOldDIB == NULL) && (hOldFont == NULL));

	// get the DC again
	hDC = GetDC(NULL);
	MMASSERT(hDC != NULL);

		// get the palette entries for the DIB section
	b =(FAILED(hr = pddp->GetEntries(0, 0, 256, rgpe)) ||
		// create an empty DIB section
		FAILED(hr = CreatePlainDIBSection(hDC, rText.right, rText.bottom, 8, 
						rgpe, &hDIB, &pDIBPixels)) ||
		// create a memory DC
		((hdcMem = CreateCompatibleDC(hDC)) == NULL) ||
		// select DIB section and font into DC
		((hOldDIB = SelectObject(hdcMem, hDIB)) == NULL) ||
		((hOldFont = SelectObject(hdcMem, hFont)) == NULL) ||
		(SetBkColor(hdcMem, RGB(peTrans.peRed, peTrans.peGreen, peTrans.peBlue)) == CLR_INVALID) ||
		(SetBkMode(hdcMem, OPAQUE) == 0));

	UINT fuOptions = ETO_OPAQUE;
	if (!b && bShadowed) {
			// set the color of the shadow text
		b =((SetTextColor(hdcMem, RGB(0,0,0)) == CLR_INVALID) ||		// black
			// output the shadow text
			(ExtTextOut(hdcMem, nXOffset + 2, nYOffset + 2, fuOptions, &rText, szText, 
				cTextLength, NULL) == 0) ||
			(SetBkMode(hdcMem, TRANSPARENT) == 0));
		fuOptions = 0;		// transparent
	}

	if (!b) {
			// set the color of the foreground text
		b =((SetTextColor(hdcMem, RGB(255,255,255)) == CLR_INVALID) ||	// white
			// output the foreground text to the surface
			(ExtTextOut(hdcMem, nXOffset, nYOffset, fuOptions, &rText, szText, 
				cTextLength, NULL) == 0));
	}

	if (hdcMem) {
		if (hOldDIB)
			SelectObject(hdcMem, hOldDIB);
		if (hOldFont)
			SelectObject(hdcMem, hOldFont);
		ReleaseDC(NULL, hdcMem);
		hdcMem = NULL;
	}
	ReleaseDC(NULL, hDC);

	if (!b) {
		// copy the DIB pixels into the DDS
		hr = CopyPixels8ToDDS(pDIBPixels, rText, rText.right, pdds, 0, 0);
	}

	// clean up the DIB that we created
	if (hDIB) {
		DeleteObject(hDIB);
		pDIBPixels = NULL;
	}

	if (b || FAILED(hr))
		return (FAILED(hr) ? hr : E_FAIL);

#endif

	*psiz = sizText;
	*ppdds = pdds;

	return S_OK;
}

HRESULT
CreatePlainDIBSection(HDC hDC, DWORD nWidth, DWORD nHeight, DWORD nBPP, 
					  const PALETTEENTRY *rgpePalette, HBITMAP *phbm, LPBYTE *ppPixels)
{
	MMASSERT(rgpePalette && ppPixels && phbm);
	HRESULT hr = S_OK;
	if (nBPP != 8) {
		return E_INVALIDARG;
	}
	DWORD i, cPalEntries = (1 << nBPP);
	HBITMAP hbm = NULL;

	// allocate bitmap info structure
	BITMAPINFO *pbmi = NULL;
	pbmi = (BITMAPINFO *) new BYTE[sizeof(BITMAPINFOHEADER) + cPalEntries * sizeof(RGBQUAD)];
	if (pbmi == NULL)
		return E_OUTOFMEMORY;

	// specify bitmip info
	pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	pbmi->bmiHeader.biPlanes = 1;
	pbmi->bmiHeader.biSizeImage = 0;
	pbmi->bmiHeader.biClrUsed = 0;
	pbmi->bmiHeader.biClrImportant = 0;
	pbmi->bmiHeader.biBitCount = (WORD) nBPP;
	pbmi->bmiHeader.biCompression = BI_RGB;
	pbmi->bmiHeader.biWidth = (LONG) nWidth;
	pbmi->bmiHeader.biHeight = -(LONG) nHeight;

	// copy palette into bmi
	for(i = 0; i < cPalEntries; i++) {
		pbmi->bmiColors[i].rgbRed = rgpePalette[i].peRed;
		pbmi->bmiColors[i].rgbGreen= rgpePalette[i].peGreen;
		pbmi->bmiColors[i].rgbBlue = rgpePalette[i].peBlue;
		pbmi->bmiColors[i].rgbReserved = 0;
	}

	// create bitmap
	LPVOID pvBits = NULL;
	hbm = ::CreateDIBSection(hDC, pbmi, DIB_RGB_COLORS, &pvBits, NULL, 0);
	if (hbm == NULL) {
		hr = E_FAIL;
		goto e_CreatePlainDIBSection;
	}

	*phbm = hbm;
	*ppPixels = (LPBYTE) pvBits;

e_CreatePlainDIBSection:
	MMDELETE(pbmi);

	return hr;
}


bool
ClipRect(const RECT &rTarget, RECT &rSrc)
{
	MMASSERT((rTarget.left <= rTarget.right) && (rTarget.top <= rTarget.bottom) &&
		(rSrc.left <= rSrc.right) && (rSrc.top <= rSrc.bottom));

	CLAMPMIN(rSrc.left, rTarget.left);
	CLAMPMIN(rSrc.top, rTarget.top);
	CLAMPMAX(rSrc.right, rTarget.right);
	CLAMPMAX(rSrc.bottom, rTarget.bottom);

	// make sure we still have a valid rectangle
	CLAMPMIN(rSrc.right, rSrc.left);
	CLAMPMIN(rSrc.bottom, rSrc.top);

	return ((rSrc.left != rSrc.right) && (rSrc.top != rSrc.bottom));
}

bool
ClipRect(long nWidth, long nHeight, RECT &rSrc)
{
	MMASSERT((rSrc.left <= rSrc.right) && (rSrc.top <= rSrc.bottom));

	CLAMPMIN(rSrc.left, 0);
	CLAMPMIN(rSrc.top, 0);
	CLAMPMAX(rSrc.right, nWidth);
	CLAMPMAX(rSrc.bottom, nHeight);

	// make sure we still have a valid rectangle
	CLAMPMIN(rSrc.right, rSrc.left);
	CLAMPMIN(rSrc.bottom, rSrc.top);

	return ((rSrc.left != rSrc.right) && (rSrc.top != rSrc.bottom));
}




// Function: CreatePaletteFromSystem
//    This function creates a DDPalette from the current system palette
HRESULT
CreatePaletteFromSystem(HDC hDC, IDirectDraw *pDD, IDirectDrawPalette **ppddp)
{
	HRESULT hr = E_INVALIDARG;
	if (ppddp == NULL)
		return E_POINTER;

	if ((hDC == NULL) || (pDD == NULL))
		return E_INVALIDARG;

	PALETTEENTRY rgPE[256];
	DWORD cEntries = 0, i;

	if ((cEntries = ::GetSystemPaletteEntries(hDC, 0, 256, rgPE)) == 0)
		return E_INVALIDARG;

	// fill palette entries
	for (i = 0; i < cEntries; i++)
		rgPE[i].peFlags = PC_NOCOLLAPSE;
	for (; i < 256; i++) {
		rgPE[i].peRed = rgPE[i].peGreen = rgPE[i].peBlue = 0;
		rgPE[i].peFlags = PC_NOCOLLAPSE;
	}
	
	if (FAILED(hr = pDD->CreatePalette(DDPCAPS_8BIT | DDPCAPS_INITIALIZE, rgPE, ppddp, NULL)))
		return hr;

	return S_OK;
}


HRESULT
DrawPoints(LPBYTE pPixels, DWORD nWidth, DWORD nHeight, DWORD nPitch,
		   DWORD nBytesPerPixel, const Point2 *rgpnt, DWORD cPoints, 
		   DWORD dwColor, DWORD nRadius)
{
	MMASSERT(pPixels && rgpnt && cPoints && nWidth && nHeight && 
		(nPitch >= nWidth) && INRANGE(nBytesPerPixel, 1, 4));

	RECT rSafe = {nRadius, nRadius, nWidth - nRadius, nHeight - nRadius};

	for (DWORD i = 0; i < cPoints; i++) {
		const Point2 &pnt = rgpnt[i];
		// REVIEW: HACK! for now
		POINT pt;
		pt.x = long(pnt.x);
		pt.y = long(pnt.y);
		if (IsInside(pt.x, pt.y, rSafe)) {
			DWORD nX = pt.x - nRadius, nY = pt.y - nRadius;
			DWORD nSize = nRadius * 2 + 1;
			g_rgColorFillFn[nBytesPerPixel](
				pPixels + PixelOffset(nX, nY, nPitch, nBytesPerPixel),
				nPitch, nSize, nSize, dwColor);
		} else {
			// REVIEW: clip the point for now
		}
	}

	return S_OK;
}


HRESULT
DrawBox(LPBYTE pPixels, DWORD nWidth, DWORD nHeight, DWORD nPitch,
		DWORD nBytesPerPixel, const RECT &rSrc, DWORD dwColor, DWORD nThickness)
{
	MMASSERT(pPixels && nWidth && nHeight && (nPitch >= nWidth) && 
		nThickness && INRANGE(nBytesPerPixel, 1, 4));

	RECT r = rSrc;
	if (ClipRect(long(nWidth), long(nHeight), r)) {
		// compute pixel offset
		pPixels += PixelOffset(r.left, r.top, nPitch, nBytesPerPixel);
		DWORD nBoxWidth = r.right - r.left;
		DWORD nBoxHeight = r.bottom - r.top;
		
		// top
		g_rgColorFillFn[nBytesPerPixel](pPixels, nPitch, nBoxWidth, 1, dwColor);
		// left
		g_rgColorFillFn[nBytesPerPixel](pPixels, nPitch, 1, nBoxHeight, dwColor);
		// right
		g_rgColorFillFn[nBytesPerPixel](pPixels + nBoxWidth * nBytesPerPixel, nPitch, 1, nBoxHeight, dwColor);
		// bottom
		g_rgColorFillFn[nBytesPerPixel](pPixels + nBoxHeight * nPitch, nPitch, nBoxWidth, 1, dwColor);
	}

	return S_OK;
}

HRESULT
DrawFilledBox(LPBYTE pPixels, DWORD nWidth, DWORD nHeight, DWORD nPitch,
		DWORD nBytesPerPixel, const RECT &rSrc, DWORD dwColor)
{
	HRESULT hr;
	MMASSERT(pPixels && nWidth && nHeight && (nPitch >= nWidth) && INRANGE(nBytesPerPixel, 1, 4));

	RECT r = rSrc;
	if (ClipRect(long(nWidth), long(nHeight), r)) {
		pPixels += PixelOffset(r.left, r.top, nPitch, nBytesPerPixel);
		DWORD nBoxWidth = r.right - r.left;
		DWORD nBoxHeight = r.bottom - r.top;
		hr = g_rgColorFillFn[nBytesPerPixel](pPixels, nPitch, nBoxWidth, nBoxHeight, dwColor);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\blt.cpp ===
// File:	Blt.cpp
// Author:	Michael Marr    (mikemarr)
//
// History:
// -@- 09/23/97 (mikemarr) copied to DXCConv from d2d\mmimage
// -@- 10/28/97 (mikemarr) added colorfill routines
//
// Notes:
//    Asserts can not be used because the code may be executing on
//  pixels in the front buffer.  If there is an assertion failure,
//  GDI might lock up.

#include "stdafx.h"
#include "PalMap.h"
#include "Blt.h"

ColorFillFn g_rgColorFillFn[5] = {
	NULL, ColorFill8, ColorFill16, ColorFill24, ColorFill32
};

HasPixelFn g_rgHasPixelFn[5] = {
	NULL, HasPixel8, HasPixel16, HasPixel24, HasPixel32
};


// Function: ColorFill
//    These functions are designed for small color fills...
HRESULT
ColorFill8(BYTE *pDstPixels, DWORD nDstPitch, 
		   DWORD nWidth, DWORD nHeight, DWORD dwColor)
{
	BYTE iColor = (BYTE) dwColor;
	DWORD i, j;
	for (i = 0; i < nHeight; i++) {
		for (j = 0; j < nWidth; j++)
			pDstPixels[j] = iColor;
		pDstPixels += nDstPitch;
	}
	return S_OK;
}

HRESULT
ColorFill16(BYTE *pDstPixels, DWORD nDstPitch, 
			DWORD nWidth, DWORD nHeight, DWORD dwColor)
{
	WORD wColor = (WORD) dwColor;
	DWORD i, j;
	for (i = 0; i < nHeight; i++) {
		WORD *pwDstPixels = (WORD *) pDstPixels;
		for (j = 0; j < nWidth; j++)
			*pwDstPixels++ = wColor;
		pDstPixels += nDstPitch;
	}
	return S_OK;
}

HRESULT
ColorFill24(BYTE *pDstPixels, DWORD nDstPitch, 
			DWORD nWidth, DWORD nHeight, DWORD dwColor)
{
	BYTE c0 = (BYTE) dwColor;
	BYTE c1 = (BYTE) (dwColor >> 8);
	BYTE c2 = (BYTE) (dwColor >> 16);
	DWORD i, j;
	for (i = 0; i < nHeight; i++) {
		BYTE *pDstNext = pDstPixels + nDstPitch;
		for (j = 0; j < nWidth; j++) {
			pDstPixels[0] = c0;
			pDstPixels[1] = c1;
			pDstPixels[2] = c2;
			pDstPixels += 3;
		}
		pDstPixels = pDstNext;
	}
	return S_OK;
}

HRESULT
ColorFill32(BYTE *pDstPixels, DWORD nDstPitch, 
			DWORD nWidth, DWORD nHeight, DWORD dwColor)
{
	DWORD i, j;
	for (i = 0; i < nHeight; i++) {
		DWORD *pdwDstPixels = (DWORD *) pDstPixels;
		for (j = 0; j < nWidth; j++)
			*pdwDstPixels++ = dwColor;
		pDstPixels += nDstPitch;
	}
	return S_OK;
}


HRESULT 
HasPixel8(const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
		  DWORD nSrcWidth, DWORD nHeight, BOOL *pb)
{
	BYTE iPixel = (BYTE) dwPixel;
	if (nSrcPitch == nSrcWidth) {
		// do a flat search thru contiguous memory
		*pb = (memchr(pSrcPixels, iPixel, nSrcPitch * nHeight) != NULL);
	} else {
		// do search line by line
		for (; nHeight; nHeight--) {
			if (memchr(pSrcPixels, iPixel, nSrcWidth) != NULL) {
				*pb = TRUE;
				return S_OK;
			}
			pSrcPixels += nSrcPitch;
		}
		*pb = FALSE;
	}
	return S_OK;
}

HRESULT 
HasPixel16(const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
		   DWORD nSrcWidth, DWORD nHeight, BOOL *pb)
{
	WORD wPixel = (WORD) dwPixel;
	for (; nHeight; nHeight--) {
		const WORD *pPixels = (const WORD *) pSrcPixels;
		const WORD *pLimit = pPixels + nSrcWidth;
		while (pPixels != pLimit) {
			if (*pPixels++ == wPixel) {
				*pb = TRUE;
				return S_OK;
			}
		}
		pSrcPixels += nSrcPitch;
	}
	*pb = FALSE;
	return S_OK;
}

HRESULT 
HasPixel24(const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
		   DWORD nSrcWidth, DWORD nHeight, BOOL *pb)
{
	// REVIEW: only works on little endian machines
	BYTE c0 = (BYTE) dwPixel;
	BYTE c1 = (BYTE) (dwPixel >> 8);
	BYTE c2 = (BYTE) (dwPixel >> 16);
	DWORD nWidth = nSrcWidth * 3;
	for (; nHeight; nHeight--) {
		const BYTE *pPixels = pSrcPixels;
		const BYTE *pLimit = pPixels + nWidth;
		while (pPixels != pLimit) {
			if ((pPixels[0] == c0) && (pPixels[1] == c1) && (pPixels[2] == c2)) {
				*pb = TRUE;
				return S_OK;
			}
			pPixels += 3;
		}
		pSrcPixels += nSrcPitch;
	}
	*pb = FALSE;
	return S_OK;
}

HRESULT 
HasPixel32(const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
		   DWORD nSrcWidth, DWORD nHeight, BOOL *pb)
{
	for (; nHeight; nHeight--) {
		const DWORD *pPixels = (const DWORD *) pSrcPixels;
		const DWORD *pLimit = pPixels + nSrcWidth;
		while (pPixels != pLimit) {
			if (*pPixels++ == dwPixel) {
				*pb = TRUE;
				return S_OK;
			}
		}
		pSrcPixels += nSrcPitch;
	}
	*pb = FALSE;
	return S_OK;
}


HRESULT 
BltFast(const BYTE *pSrcPixels, DWORD nSrcPitch,
		BYTE *pDstPixels, DWORD nDstPitch, DWORD nSrcWidth, DWORD nHeight)
{
	if (nSrcWidth == nDstPitch) {
		// do a flat copy
		memcpy(pDstPixels, pSrcPixels, nSrcPitch * nHeight);
	} else {
		LPBYTE pPixelLimit = pDstPixels + nDstPitch * nHeight;
		// copy each row
		for (; pDstPixels != pPixelLimit; ) {
			memcpy(pDstPixels, pSrcPixels, nSrcWidth);
			pDstPixels += nDstPitch;
			pSrcPixels += nSrcPitch;
		}
	}
	return S_OK;
}


HRESULT 
BltFast8CK(const BYTE *pSrcPixels, DWORD nSrcPitch,
		   BYTE *pDstPixels, DWORD nDstPitch, 
		   DWORD nSrcWidth, DWORD nHeight, DWORD dwTrans)
{
	if ((nSrcWidth == 0) || (nHeight == 0))
		return S_OK;

	DWORD nRemainder = (nSrcWidth & 0x7);
	DWORD nAligned = (nSrcWidth & ~0x7);
	const BYTE *pSrcLineStart = pSrcPixels;
	const BYTE *pPixelLimit = pSrcPixels + (nHeight * nSrcPitch);
	DWORD nSrcAlignedPitch = nSrcPitch + nAligned;
	DWORD nDstAlignedPitch = nDstPitch + nAligned;
	pSrcPixels += nAligned;
	pDstPixels += nAligned;
	BYTE iTrans = BYTE(dwTrans), uch;

	do {
		switch (nRemainder) {
		do {
			case 0:	pDstPixels -= 8; pSrcPixels -= 8;
					if ((uch = pSrcPixels[7]) != iTrans) pDstPixels[7] = uch;
			case 7:	if ((uch = pSrcPixels[6]) != iTrans) pDstPixels[6] = uch;
			case 6:	if ((uch = pSrcPixels[5]) != iTrans) pDstPixels[5] = uch;
			case 5:	if ((uch = pSrcPixels[4]) != iTrans) pDstPixels[4] = uch;
			case 4:	if ((uch = pSrcPixels[3]) != iTrans) pDstPixels[3] = uch;
			case 3:	if ((uch = pSrcPixels[2]) != iTrans) pDstPixels[2] = uch;
			case 2:	if ((uch = pSrcPixels[1]) != iTrans) pDstPixels[1] = uch;
			case 1:	if ((uch = pSrcPixels[0]) != iTrans) pDstPixels[0] = uch;
		} while (pSrcPixels != pSrcLineStart);
		}
		pSrcLineStart += nSrcPitch;
		pSrcPixels += nSrcAlignedPitch;
		pDstPixels += nDstAlignedPitch;
	} while (pSrcLineStart != pPixelLimit);

	return S_OK;
}


HRESULT 
BltFastMirrorY(const BYTE *pSrcPixels, DWORD nSrcPitch, 
			   BYTE *pDstPixels, DWORD nDstPitch, DWORD nSrcWidth, DWORD nHeight)
{
	LPBYTE pPixelLimit = pDstPixels + nDstPitch * nHeight;
	// set the src pixels to point to the last line of the bitmap
	pSrcPixels += nSrcPitch * (nHeight - 1);

	// copy each row
	for (; pDstPixels != pPixelLimit; ) {
		memcpy(pDstPixels, pSrcPixels, nSrcWidth);
		pDstPixels += nDstPitch;
		pSrcPixels -= nSrcPitch;
	}
	return S_OK;
}


HRESULT 
BltFastRGBToRGB(const BYTE *pSrcPixels, DWORD nSrcPitch,
				BYTE *pDstPixels, DWORD nDstPitch, 
				DWORD nWidth, DWORD nHeight,
				const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst)
{
	if (pixiSrc.nBPP == 24) {
		if (pixiDst.nBPP == 16)
			return BltFast24To16(pSrcPixels, nSrcPitch, pDstPixels, nDstPitch,
					nWidth, nHeight, pixiSrc, pixiDst);
		if (pixiDst.nBPP == 32)
			return BltFast24To32(pSrcPixels, nSrcPitch, pDstPixels, nDstPitch,
					nWidth, nHeight, pixiSrc, pixiDst);
	} else if (pixiSrc.nBPP == 32) {
		if (pixiDst.nBPP == 32)
			return BltFast32To32(pSrcPixels, nSrcPitch, pDstPixels, nDstPitch,
					nWidth, nHeight, pixiSrc, pixiDst);
	}
	return E_NOTIMPL;
}


HRESULT
BltFast32To32(const BYTE *pSrcPixels, DWORD nSrcPitch,
			  BYTE *pDstPixels, DWORD nDstPitch, 
			  DWORD nWidth, DWORD nHeight,
			  const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst)
{
	if (nSrcPitch == 0)
		nSrcPitch = nWidth * 4;
	if (nDstPitch == 0)
		nDstPitch = nWidth * 4;
	DWORD nDeltaSrcPitch = nSrcPitch - (nWidth * 4);
	const BYTE *pPixelLimit = pSrcPixels + nSrcPitch * nHeight;
	DWORD iRed = pixiSrc.iRed, iBlue = pixiSrc.iBlue;
	// copy each row
	for (; pSrcPixels != pPixelLimit; ) {
		LPDWORD pdwDstPixel = (LPDWORD) pDstPixels;
		for (DWORD i = nWidth; i != 0; i--) {
			*pdwDstPixel++ = pixiDst.Pack(pSrcPixels[iRed], pSrcPixels[1], pSrcPixels[iBlue], pSrcPixels[3]);
			pSrcPixels += 4;
		}
		pDstPixels += nDstPitch;
		pSrcPixels += nDeltaSrcPitch;
	}
	return S_OK;
}


HRESULT
BltFast24To16(const BYTE *pSrcPixels, DWORD nSrcPitch,
			  BYTE *pDstPixels, DWORD nDstPitch, 
			  DWORD nWidth, DWORD nHeight,
			  const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst)
{
	if (nSrcPitch == 0)
		nSrcPitch = nWidth * 3;
	if (nDstPitch == 0)
		nDstPitch = nWidth * 2;
	DWORD nDeltaSrcPitch = nSrcPitch - (nWidth * 3);
	const BYTE *pPixelLimit = pSrcPixels + nSrcPitch * nHeight;
	DWORD iRed = pixiSrc.iRed, iBlue = pixiSrc.iBlue;
	// copy each row
	for (; pSrcPixels != pPixelLimit; ) {
		LPWORD pwDstPixel = (LPWORD) pDstPixels;
		for (DWORD i = nWidth; i != 0; i--) {
			*pwDstPixel++ = pixiDst.Pack16(pSrcPixels[iRed], pSrcPixels[1], pSrcPixels[iBlue]);
			pSrcPixels += 3;
		}
		pDstPixels += nDstPitch;
		pSrcPixels += nDeltaSrcPitch;
	}
	return S_OK;
}


HRESULT
BltFast24To32(const BYTE *pSrcPixels, DWORD nSrcPitch,
			  BYTE *pDstPixels, DWORD nDstPitch, 
			  DWORD nWidth, DWORD nHeight,
			  const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst)
{
	if (nSrcPitch == 0)
		nSrcPitch = nWidth * 3;
	if (nDstPitch == 0)
		nDstPitch = nWidth * 4;
	DWORD nDeltaSrcPitch = nSrcPitch - (nWidth * 3);
	DWORD iRed = pixiSrc.iRed, iBlue = pixiSrc.iBlue;
	// copy each row
	const BYTE *pPixelLimit = pSrcPixels + nSrcPitch * nHeight;
	for (; pSrcPixels != pPixelLimit; ) {
		LPDWORD pdwDstPixel = (LPDWORD) pDstPixels;
		for (DWORD i = nWidth; i != 0; i--) {
			*pdwDstPixel++ = pixiDst.Pack(pSrcPixels[iRed], pSrcPixels[1], pSrcPixels[iBlue]);
			pSrcPixels += 3;
		}
		pDstPixels += nDstPitch;
		pSrcPixels += nDeltaSrcPitch;
	}
	return S_OK;
}



HRESULT 
BltFast8To4(const BYTE *pSrcPixels, DWORD nSrcPitch,
			BYTE *pDstPixels, DWORD nDstPitch,
			DWORD nWidth, DWORD nHeight, DWORD nOffset)
{
	return E_NOTIMPL;
}


HRESULT 
BltFast8To2(const BYTE *pSrcPixels, DWORD nSrcPitch,
			BYTE *pDstPixels, DWORD nDstPitch,
			DWORD nWidth, DWORD nHeight, DWORD nOffset)
{
	return E_NOTIMPL;
}


HRESULT 
BltFast8To1(const BYTE *pSrcPixels, long nSrcPitch,
			BYTE *pDstPixels, long nDstPitch,
			DWORD nWidth, DWORD nHeight, DWORD nOffset)
{
	HRESULT hr = E_NOTIMPL;

	return hr;
}


HRESULT
BltFast8To8T(const BYTE *pSrcPixel, long nSrcPitch, BYTE *pDstPixel, long nDstPitch,
			DWORD nWidth, DWORD nHeight, const BYTE *pIndexMap)
{
	if ((nWidth == 0) || (nHeight == 0))
		return S_OK;

	DWORD nRemainder = (nWidth & 0x7);
	DWORD nAligned = (nWidth & ~0x7);
	const BYTE *pSrcLineStart = pSrcPixel;
	const BYTE *pPixelLimit = pSrcPixel + (nHeight * nSrcPitch);
	DWORD nSrcAlignedPitch = nSrcPitch + nAligned;
	DWORD nDstAlignedPitch = nDstPitch + nAligned;
	pSrcPixel += nAligned;
	pDstPixel += nAligned;

	do {
		switch (nRemainder) {
		do {
			case 0:	pDstPixel -= 8; pSrcPixel -= 8;
					pDstPixel[7] = pIndexMap[pSrcPixel[7]];
			case 7: pDstPixel[6] = pIndexMap[pSrcPixel[6]];
			case 6:	pDstPixel[5] = pIndexMap[pSrcPixel[5]];
			case 5: pDstPixel[4] = pIndexMap[pSrcPixel[4]];
			case 4:	pDstPixel[3] = pIndexMap[pSrcPixel[3]];
			case 3: pDstPixel[2] = pIndexMap[pSrcPixel[2]];
			case 2:	pDstPixel[1] = pIndexMap[pSrcPixel[1]];
			case 1: pDstPixel[0] = pIndexMap[pSrcPixel[0]];
		} while (pSrcPixel != pSrcLineStart);
		}
		pSrcLineStart += nSrcPitch;
		pSrcPixel += nSrcAlignedPitch;
		pDstPixel += nDstAlignedPitch;
	} while (pSrcLineStart != pPixelLimit);

	return S_OK;
}

HRESULT
BltFast8To16T(const BYTE *pSrcPixel, long nSrcPitch, BYTE *pDstPixel, long nDstPitch,
			 DWORD nWidth, DWORD nHeight, const BYTE *pIndexMap)
{
#ifdef _DEBUG
	if ((long(pDstPixel) & 0x1) || (nDstPitch & 0x1) || (nWidth == 0) || (nHeight == 0))
		return E_INVALIDARG;
#endif
	DWORD nRemainder = (nWidth & 0x7);
	DWORD nAligned = (nWidth & ~0x7);
	const BYTE *pSrcLineStart = pSrcPixel;
	const BYTE *pPixelLimit = pSrcPixel + (nHeight * nSrcPitch);
	DWORD nSrcAlignedPitch = nSrcPitch + nAligned;
	DWORD nDstAlignedPitch = (nDstPitch >> 1) + nAligned;
	pSrcPixel += nAligned;
	WORD *pDstPixel16 = ((WORD *) pDstPixel) + nAligned;
	MapEntry16 *pIndexMap16 = (MapEntry16 *) pIndexMap;

	do {
		switch (nRemainder) {
		do {
			case 0:	pDstPixel16 -= 8; pSrcPixel -= 8;
					pDstPixel16[7] = pIndexMap16[pSrcPixel[7]];
			case 7: pDstPixel16[6] = pIndexMap16[pSrcPixel[6]];
			case 6:	pDstPixel16[5] = pIndexMap16[pSrcPixel[5]];
			case 5: pDstPixel16[4] = pIndexMap16[pSrcPixel[4]];
			case 4:	pDstPixel16[3] = pIndexMap16[pSrcPixel[3]];
			case 3: pDstPixel16[2] = pIndexMap16[pSrcPixel[2]];
			case 2:	pDstPixel16[1] = pIndexMap16[pSrcPixel[1]];
			case 1: pDstPixel16[0] = pIndexMap16[pSrcPixel[0]];
		} while (pSrcPixel != pSrcLineStart);
		}
		pSrcLineStart += nSrcPitch;
		pSrcPixel += nSrcAlignedPitch;
		pDstPixel16 += nDstAlignedPitch;
	} while (pSrcLineStart != pPixelLimit);

	return S_OK;
}

HRESULT
BltFast8To24T(const BYTE *pSrcPixels, long nSrcPitch, BYTE *pDstPixels, long nDstPitch,
			 DWORD nWidth, DWORD nHeight, const BYTE *pIndexMap)
{
	MapEntry24 *pIndexMap24 = (MapEntry24 *) pIndexMap;
	BYTE *pDstPixelsLimit = pDstPixels + nDstPitch * nHeight;
	int nDstWidth = nWidth * 3;
		
	for (; pDstPixels != pDstPixelsLimit; ) {
		const BYTE *pSrcPixel = pSrcPixels;
		BYTE *pDstPixel = pDstPixels;
		BYTE *pDstPixelLimit = pDstPixel + nDstWidth;
		for (; pDstPixel != pDstPixelLimit; ) {
			MapEntry24 mePixel = pIndexMap24[*pSrcPixel++];
			*pDstPixel++ = (BYTE) (mePixel);
			*pDstPixel++ = (BYTE) (mePixel >> 8);
			*pDstPixel++ = (BYTE) (mePixel >> 16);
		}
		pDstPixels += nDstPitch;
		pSrcPixels += nSrcPitch;
	}
	return S_OK;
}

HRESULT
BltFast8To32T(const BYTE *pSrcPixels, long nSrcPitch, BYTE *pDstPixels, long nDstPitch,
			 DWORD nWidth, DWORD nHeight, const BYTE *pIndexMap)
{
#ifdef _DEBUG
	if ((long(pDstPixels) & 0x3) != 0)
		return E_INVALIDARG;
#endif

	MapEntry32 *pIndexMap32 = (MapEntry32 *) pIndexMap;
	int nDstPitch32 = nDstPitch >> 2;
	DWORD *pDstPixels32 = (DWORD *) pDstPixels;
	DWORD *pDstPixelsLimit = pDstPixels32 + nDstPitch32 * nHeight;
		
	for (; pDstPixels32 != pDstPixelsLimit; ) {
		const BYTE *pSrcPixel = pSrcPixels;
		DWORD *pDstPixel = pDstPixels32;
		DWORD *pDstPixelLimit = pDstPixel + nWidth;
		for (; pDstPixel != pDstPixelLimit; ) {
			*pDstPixel++ = pIndexMap32[*pSrcPixel++];
		}
		pDstPixels32 += nDstPitch32;
		pSrcPixels += nSrcPitch;
	}
	return S_OK;
}


//
// RLE
//

HRESULT 
BltFastRLE8(DWORD nXPos, DWORD nYPos, const BYTE *pSrcPixels, long nSrcPitch,
			BYTE *pDstPixels, long nDstPitch, const LPRECT prSrcRect)
{
	return E_NOTIMPL;
}

HRESULT
BltFastRLE8To8T(DWORD nXPos, DWORD nYPos, const BYTE *pSrcPixels, long nSrcPitch,
				BYTE *pDstPixels, long nDstPitch, const LPRECT prSrcRect, 
				const BYTE *pIndexMap)
{
	return E_NOTIMPL;
}

HRESULT
BltFastRLE8To16T(DWORD nXPos, DWORD nYPos, const BYTE *pSrcPixels, long nSrcPitch,
				 BYTE *pDstPixels, long nDstPitch, const LPRECT prSrcRect,
				 const BYTE *pIndexMap)
{
	return E_NOTIMPL;
}

HRESULT
BltFastRLE8To24T(DWORD nXPos, DWORD nYPos, const BYTE *pSrcPixels, long nSrcPitch,
				 BYTE *pDstPixels, long nDstPitch, const LPRECT prSrcRect, 
				 const BYTE *pIndexMap)
{
	return E_NOTIMPL;
}

HRESULT
BltFastRLE8To32T(DWORD nXPos, DWORD nYPos, const BYTE *pSrcPixels, long nSrcPitch,
				 BYTE *pDstPixels, long nDstPitch, const LPRECT prSrcRect,
				 const BYTE *pIndexMap)
{
	return E_NOTIMPL;
}

/*
// Function: Write4BitRow
//    This function packs a buffer of unsigned char's representing
//  4 bit numbers into a packed unsigned char buffer.  It is assumed
//  that the bytes in the src have the uppermost 4 bits zeroed out.
void *
Write4BitRow(void *pDst, const void *pSrc, unsigned int cCount)
{
	// use an inverse Duff machine
	int nRemainder = cCount & 0x07;
	int nAligned = cCount - nRemainder;
	const unsigned char *puchSrc = (const unsigned char *) pSrc + nAligned;
	unsigned char *puchDst = (unsigned char *) pDst + (nAligned >> 1);
	unsigned char uchCompositionBuf = 0;

	switch (nRemainder) {
	do {
			puchDst -= 4; puchSrc -= 8;
			uchCompositionBuf = puchSrc[7];
	case 7: puchDst[3] = (puchSrc[6] << 4) | uchCompositionBuf;
	case 6:	uchCompositionBuf = puchSrc[5];
	case 5: puchDst[2] = (puchSrc[4] << 4) | uchCompositionBuf;
	case 4:	uchCompositionBuf = puchSrc[3];
	case 3: puchDst[1] = (puchSrc[2] << 4) | uchCompositionBuf;
	case 2:	uchCompositionBuf = puchSrc[1];
	case 1: puchDst[0] = (puchSrc[0] << 4) | uchCompositionBuf;
	case 0: ;
	} while (puchDst != (unsigned char *) pDst);
	} 

	return pDst;
}

// Function: Write2BitRow
//    This function packs a buffer of unsigned char's representing
//  2 bit numbers into a packed unsigned char buffer.  It is assumed
//  that the bytes in the src have the uppermost 6 bits zeroed out.
void *
Write2BitRow(void *pDst, const void *pSrc, unsigned int cCount)
{
	// use an inverse Duff machine
	int nRemainder = cCount & 0x07;
	int nAligned = cCount - nRemainder;
	const unsigned char *puchSrc = (const unsigned char *) pSrc + nAligned;
	unsigned char *puchDst = (unsigned char *) pDst + (nAligned >> 2);
	unsigned char uchCompositionBuf = 0;

	switch (nRemainder) {
	do {
			puchDst -= 2; puchSrc -= 8;
			uchCompositionBuf = puchSrc[7];
	case 7: uchCompositionBuf |= (puchSrc[6] << 2);
	case 6:	uchCompositionBuf |= (puchSrc[5] << 4);
	case 5: puchDst[1] = (puchSrc[4] << 6) | uchCompositionBuf;
	case 4:	uchCompositionBuf = puchSrc[3];
	case 3: uchCompositionBuf |= (puchSrc[2] << 2);
	case 2:	uchCompositionBuf |= (puchSrc[1] << 4);
	case 1: puchDst[0] = (puchSrc[0] << 6) | uchCompositionBuf;
	case 0: ;
	} while (puchDst != (unsigned char *) pDst);
	} 

	return pDst;
}

// Function: Write1BitRow
//    This function packs a buffer of unsigned char's representing
//  1 bit numbers into a packed unsigned char buffer.  It is assumed
//  that the bytes in the src have the uppermost 7 bits zeroed out.
void *
Write1BitRow(void *pDst, const void *pSrc, unsigned int cCount)
{
	// use an inverse Duff machine
	int nRemainder = cCount & 0x07;
	int nAligned = cCount - nRemainder;
	const unsigned char *puchSrc = (const unsigned char *) pSrc + nAligned;
	unsigned char *puchDst = (unsigned char *) pDst + (nAligned >> 3);
	unsigned char uchCompositionBuf = 0;

	switch (nRemainder) {
	do {
			puchDst -= 1; puchSrc -= 8;
			uchCompositionBuf = puchSrc[7];
	case 7: uchCompositionBuf |= (puchSrc[6] << 1);
	case 6:	uchCompositionBuf |= (puchSrc[5] << 2);
	case 5: uchCompositionBuf |= (puchSrc[4] << 3);
	case 4:	uchCompositionBuf |= (puchSrc[3] << 4);
	case 3: uchCompositionBuf |= (puchSrc[2] << 5);
	case 2:	uchCompositionBuf |= (puchSrc[1] << 6);
	case 1: puchDst[0] = (puchSrc[0] << 7) | uchCompositionBuf;
	case 0: ;
	} while (puchDst != (unsigned char *) pDst);
	} 

	return pDst;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\ddhelper.h ===
#ifndef _DDHelper_h
#define _DDHelper_h

// File:	DDHelper.h
// Author:	Michael Marr    (mikemarr)
//
// Description:
//    These are some useful helper functions for sanitizing interactions
//  with DirectDraw
// 
// History:
// -@- 03/06/97 (mikemarr) created
// -@- 10/07/97 (mikemarr) snarfed from \d2d\mmimage\include
// -@- 10/07/97 (mikemarr) trimmed
// -@- 10/14/97 (mikemarr) added arrays for pixel format mgmt
// -@- 10/28/97 (mikemarr) added PixelOffset macro
// -@- 10/28/97 (mikemarr) added GetColor function

#ifndef __DDRAW_INCLUDED__
#include <ddraw.h>
#endif

#ifndef _PixInfo_h
#include "PixInfo.h"
#endif

#ifndef _Point_h
#include "Point.h"
#endif

typedef enum {
	iPF_NULL = 0, iPF_Palette1, iPF_Palette2, iPF_Palette4, iPF_Palette8,
	iPF_RGB332, iPF_ARGB4444, iPF_RGB565, iPF_BGR565, iPF_RGB555,
	iPF_ARGB5551, iPF_RGB24, iPF_BGR24, iPF_RGB32, iPF_BGR32,
	iPF_ARGB, iPF_ABGR, iPF_RGBTRIPLE, iPF_RGBQUAD, iPF_PALETTEENTRY,
	iPF_Total
} PixelFormatIndex;

extern const DDPIXELFORMAT g_rgDDPF[iPF_Total];
DWORD	GetPixelFormat(const DDPIXELFORMAT &ddpf);

extern const CPixelInfo g_rgPIXI[iPF_Total];
DWORD	GetPixelFormat(const CPixelInfo &pixi);

/*
extern const GUID g_rgDDPFGUID[iPF_Total];
DWORD	GetPixelFormat(const GUID &guid);
*/

extern const PALETTEENTRY g_peZero;

inline BOOL 
operator==(const DDPIXELFORMAT &ddpf1, const DDPIXELFORMAT &ddpf2)
{
	return (ddpf1.dwRGBBitCount == ddpf2.dwRGBBitCount) &&
		(ddpf1.dwRBitMask == ddpf2.dwRBitMask) && 
		(ddpf1.dwGBitMask == ddpf2.dwGBitMask) && 
		(ddpf1.dwBBitMask == ddpf2.dwBBitMask) && 
		(ddpf1.dwRGBAlphaBitMask == ddpf2.dwRGBAlphaBitMask) &&
		(ddpf1.dwFlags == ddpf2.dwFlags);
}

#define AllFieldsDefined(dxstruct, flags) (((dxstruct).dwFlags & (flags)) == (flags))
#define AnyFieldsDefined(dxstruct, flags) (((dxstruct).dwFlags & (flags)) != 0)

extern DWORD g_rgdwBPPToPalFlags[9];
extern DWORD g_rgdwBPPToPixFlags[9];

inline DWORD
BPPToPaletteFlags(DWORD nBPP)
{
	return (nBPP <= 8 ? g_rgdwBPPToPalFlags[nBPP] : 0);
}

inline DWORD
BPPToPixelFlags(DWORD nBPP)
{
	return (nBPP <= 8 ? g_rgdwBPPToPixFlags[nBPP] : 0);
}

DWORD		PaletteToPixelFlags(DWORD dwPaletteFlags);
DWORD		PixelToPaletteFlags(DWORD dwPaletteFlags);
BYTE		PixelFlagsToBPP(DWORD dwFlags);
BYTE		PaletteFlagsToBPP(DWORD dwFlags);

HRESULT		CreatePlainSurface(IDirectDraw *pDD, DWORD nWidth, DWORD nHeight, 
				const DDPIXELFORMAT &ddpf, IDirectDrawPalette *pddp,
				DWORD dwTransColor, bool bTransparent,
				IDirectDrawSurface **ppdds);

inline
HRESULT		CreatePlainSurface(IDirectDraw *pDD, DWORD nWidth, DWORD nHeight, 
				const CPixelInfo &pixiPixFmt, IDirectDrawPalette *pddp,
				DWORD dwTransColor, bool bTransparent,
				IDirectDrawSurface **ppdds)
{
	DDPIXELFORMAT ddpf;
	pixiPixFmt.GetDDPF(ddpf);

	return CreatePlainSurface(pDD, nWidth, nHeight, ddpf, 
		pddp, dwTransColor, bTransparent, ppdds);
}

HRESULT		CreatePalette(IDirectDraw *pDD, const BYTE *pPalette, DWORD cEntries, 
				BYTE nBPPTarget, const CPixelInfo &pixiPalFmt, 
				IDirectDrawPalette **ppddp);

// Notes: luminance ~= (77r + 151g + 28b)/256
#define nREDWEIGHT 77
#define nGREENWEIGHT 151
#define nBLUEWEIGHT 28

#define nMAXPALETTEENTRIES 256

HRESULT		ClearToColor(LPRECT prDst, LPDIRECTDRAWSURFACE pdds, DWORD dwColor);

DWORD		SimpleFindClosestIndex(const PALETTEENTRY *rgpePalette, DWORD cEntries, 
				const PALETTEENTRY &peQuery);

HRESULT		GetColors(LPDIRECTDRAWSURFACE pdds, const PALETTEENTRY *rgpeQuery, DWORD cEntries,
				LPDWORD pdwColors);

HRESULT		CreateSurfaceWithText(LPDIRECTDRAW pDD, LPDIRECTDRAWPALETTE pddp, 
				DWORD iTransp, const char *szText, HFONT hFont, BOOL bShadowed,
				SIZE *psiz, LPDIRECTDRAWSURFACE *ppdds);

HRESULT		CreatePlainDIBSection(HDC hDC, DWORD nWidth, DWORD nHeight, DWORD nBPP, 
				const PALETTEENTRY *rgpePalette, HBITMAP *phbm, LPBYTE *ppPixels);

HRESULT		GetSurfaceDimensions(LPDIRECTDRAWSURFACE pdds, LPRECT prDimensions);

HRESULT		CreatePaletteFromSystem(HDC hDC, IDirectDraw *pDD, 
				IDirectDrawPalette **ppddp);


// Robust Drawing Routines
HRESULT		DrawPoints(LPBYTE pPixels, DWORD nWidth, DWORD nHeight, DWORD nPitch, DWORD nBytesPerPixel, 
				const Point2 *rgpnt, DWORD cPoints, 
				DWORD dwColor, DWORD nRadius);

HRESULT		DrawBox(LPBYTE pPixels, DWORD nWidth, DWORD nHeight, DWORD nPitch,
				DWORD nBytesPerPixel, const RECT &r, DWORD dwColor, DWORD nThickness);

HRESULT		DrawFilledBox(LPBYTE pPixels, DWORD nWidth, DWORD nHeight, DWORD nPitch,
				DWORD nBytesPerPixel, const RECT &r, DWORD dwColor);

inline HRESULT
DrawPoints(DDSURFACEDESC &ddsd,	const Point2 *rgpnt, DWORD cPoints, 
		   DWORD dwColor, DWORD nRadius) 
{
	return DrawPoints((LPBYTE) ddsd.lpSurface, ddsd.dwWidth, ddsd.dwHeight, 
			(DWORD) ddsd.lPitch, (ddsd.ddpfPixelFormat.dwRGBBitCount + 7) >> 3,
			rgpnt, cPoints, dwColor, nRadius);
}

inline HRESULT
DrawBox(DDSURFACEDESC &ddsd, const RECT &r, DWORD dwColor, DWORD nThickness)
{
	return DrawBox((LPBYTE) ddsd.lpSurface, ddsd.dwWidth, ddsd.dwHeight, 
			(DWORD) ddsd.lPitch, (ddsd.ddpfPixelFormat.dwRGBBitCount + 7) >> 3,
			r, dwColor, nThickness);
}

inline HRESULT
DrawFilledBox(DDSURFACEDESC &ddsd, const RECT &r, DWORD dwColor)
{
	return DrawFilledBox((LPBYTE) ddsd.lpSurface, ddsd.dwWidth, ddsd.dwHeight, 
			(DWORD) ddsd.lPitch, (ddsd.ddpfPixelFormat.dwRGBBitCount + 7) >> 3,
			r, dwColor);
}

#define PixelOffset(_nX, _nY, _nPitch, _cBytesPerPixel) ((_nPitch * _nY) + (_cBytesPerPixel * _nX))

//
// RECT functions
//

// Function: ClipRect
//    Returns TRUE for a non-trivial intersection.
bool		ClipRect(const RECT &rTarget, RECT &rSrc);
bool		ClipRect(long nWidth, long nHeight, LPRECT prSrc);

// Function: IsInside
//    Returns true if the given point is inside the rectangle
inline bool
IsInside(long nX, long nY, const RECT &r)
{
	return ((nX >= r.left) && (nX < r.right) && (nY >= r.top) && (nY < r.bottom));
}

inline bool
IsInside(long nX, long nY, const SIZE &siz)
{
	return ((nX >= 0) && (nX < siz.cx) && (nY >= 0) && (nY < siz.cy));
}

inline bool
IsFullSize(DWORD nWidth, DWORD nHeight, const RECT &r)
{
	return ((r.right == (long) nWidth) && (r.bottom == (long) nHeight) &&
			(r.left == 0) && (r.top == 0));
}

inline bool
IsSameSize(DWORD nWidth, DWORD nHeight, const RECT &r)
{
	return ((r.right - r.left) == (long) nWidth) && 
		((r.bottom - r.top) == (long) nHeight);
}

inline bool
IsSameSize(const RECT &r1, const RECT &r2)
{
	return ((r1.right - r1.left) == (r2.right - r2.left)) &&
		((r1.bottom - r1.top) == (r2.bottom - r2.top));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\dxtpriv.h ===
//depot/Lab06_N/root/public/internal/mshtml/inc/dxtpriv.h#1 - add change 5035 (text)
/*******************************************************************************
* DXVector.h *
*------------*
*   Description:
*       This is the header file for the matrix classes.
*
*******************************************************************************/
#ifndef __DXTPRIV_H_
#define __DXTPRIV_H_

#ifndef _INC_MATH
#include <math.h>
#endif

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

//=== Class, Enum, Struct and Union Declarations ===================
class CDXMatrix4x4F;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================
float det4x4( CDXMatrix4x4F *pIn );
float det3x3( float a1, float a2, float a3, float b1, float b2, float b3, 
              float c1, float c2, float c3 );
float det2x2( float a, float b, float c, float d );

/*** CDX2DXForm ************
*   This class implements basic matrix operation based on the GDI XFORM
*   structure.
*/
//const DX2DXFORM g_DX2DXFORMIdentity = { 1., 0., 0., 1., 0., 0., DX2DXO_IDENTITY };

class CDX2DXForm : public DX2DXFORM
{
  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDX2DXForm() { SetIdentity(); }
    CDX2DXForm( const CDX2DXForm& Other ) { memcpy( this, &Other, sizeof(*this) ); }
    CDX2DXForm( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); }

    /*--- methods ---*/
    void DetermineOp( void );
    void Set( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); DetermineOp(); }
    void ZeroMatrix( void ) { memset( this, 0, sizeof( *this ) ); }
    void SetIdentity( void ) {  
        eM11 = 1.;
        eM12 = 0.;
        eM21 = 0.;
        eM22 = 1.;
        eDx = 0.;
        eDy = 0.;
        eOp = DX2DXO_IDENTITY;
    }
    BOOL IsIdentity() const { return eOp == DX2DXO_IDENTITY; }
    void Scale( float sx, float sy );
    void Rotate( float Rotation );
    void Translate( float dx, float dy );
    BOOL Invert();
    void TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const;
    void TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const;
    void GetMinMaxScales( float& MinScale, float& MaxScale );

    /*--- operators ---*/
    DXFPOINT operator*( const DXFPOINT& v ) const;
    CDX2DXForm operator*( const CDX2DXForm& Other ) const;
};

//=== CDX2DXForm methods ==============================================================
inline void CDX2DXForm::DetermineOp( void )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        if( ( eM11 == 1. ) && ( eM22 == 1. ) )
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_IDENTITY):(DX2DXO_TRANSLATE);
        }
        else
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_SCALE):(DX2DXO_SCALE_AND_TRANS);
        }
    }
    else
    {
        eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_GENERAL):(DX2DXO_GENERAL_AND_TRANS);
    }
} /* CDX2DXForm::DetermineOp */

inline float DXSq( float f ) { return f * f; }

// This function computes the Min and Max scale that a matrix represents.
// In other words, what is the maximum/minimum length that a line of length 1
// could get stretched/shrunk to if the line was transformed by this matrix.
//
// The function uses eigenvalues; and returns two float numbers. Both are
// non-negative; and MaxScale >= MinScale.
// 
inline void CDX2DXForm::GetMinMaxScales( float& MinScale, float& MaxScale )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        // Let MinScale = abs(eM11)
        if (eM11 < 0)
            MinScale = -eM11;
        else
            MinScale = eM11;

        // Let MaxScale = abs(eM22)
        if (eM22 < 0)
            MaxScale = -eM22;
        else
            MaxScale = eM22;

        // Swap Min/Max if necessary
        if (MinScale > MaxScale)
        {
            float flTemp = MinScale;
            MinScale = MaxScale;
            MaxScale = flTemp;
        }
    }
    else
    {
        float t1 = DXSq(eM11) + DXSq(eM12) + DXSq(eM21) + DXSq(eM22);
        if( t1 == 0. )
        {
            MinScale = MaxScale = 0;
        }
        else
        {
            float t2 = (float)sqrt( (DXSq(eM12 + eM21) + DXSq(eM11 - eM22)) *
                                    (DXSq(eM12 - eM21) + DXSq(eM11 + eM22)) );

            // Due to floating point error; t1 may end up less than t2;
            // but that would mean that the min scale was small (relative
            // to max scale)
            if (t1 <= t2)
                MinScale = 0;
            else
                MinScale = (float)sqrt( (t1 - t2) * .5f );

            MaxScale = (float)sqrt( (t1 + t2) * .5f );
        }
    }
} /* CDX2DXForm::GetMinMaxScales */

inline void CDX2DXForm::Rotate( float Rotation )
{
    double Angle = Rotation * (3.1415926535/180.0);
    float CosZ   = (float)cos( Angle );
    float SinZ   = (float)sin( Angle );
    if (CosZ > 0.0F && CosZ < 0.0000005F)
    {
        CosZ = .0F;
    }
    if (SinZ > -0.0000005F && SinZ < .0F)
    {
        SinZ = .0F;
    }

    float M11 = ( CosZ * eM11 ) + ( SinZ * eM21 ); 
    float M21 = (-SinZ * eM11 ) + ( CosZ * eM21 );
    float M12 = ( CosZ * eM12 ) + ( SinZ * eM22 ); 
    float M22 = (-SinZ * eM12 ) + ( CosZ * eM22 );
    eM11 = M11; eM21 = M21; eM12 = M12; eM22 = M22;
    DetermineOp();
} /* CDX2DXForm::Rotate */

inline void CDX2DXForm::Scale( float sx, float sy )
{
    eM11 *= sx;
    eM12 *= sx;
    eDx  *= sx;
    eM21 *= sy;
    eM22 *= sy;
    eDy  *= sy;
    DetermineOp();
} /* CDX2DXForm::Scale */

inline void CDX2DXForm::Translate( float dx, float dy )
{
    eDx += dx;
    eDy += dy;
    DetermineOp();
} /* CDX2DXForm::Translate */

inline void CDX2DXForm::TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const
{
    ResultBnds = Bnds;
    if( eOp != DX2DXO_IDENTITY )
    {
        ResultBnds.u.D[DXB_X].Min = (long)(( eM11 * Bnds.u.D[DXB_X].Min ) + ( eM12 * Bnds.u.D[DXB_Y].Min ) + eDx);
        ResultBnds.u.D[DXB_X].Max = (long)(( eM11 * Bnds.u.D[DXB_X].Max ) + ( eM12 * Bnds.u.D[DXB_Y].Max ) + eDx);
        ResultBnds.u.D[DXB_Y].Min = (long)(( eM21 * Bnds.u.D[DXB_X].Min ) + ( eM22 * Bnds.u.D[DXB_Y].Min ) + eDy);
        ResultBnds.u.D[DXB_Y].Max = (long)(( eM21 * Bnds.u.D[DXB_X].Max ) + ( eM22 * Bnds.u.D[DXB_Y].Max ) + eDy);
    }
} /* CDX2DXForm::TransformBounds */

inline void CDX2DXForm::TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const
{
    ULONG i;
    switch( eOp )
    {
      case DX2DXO_IDENTITY:
        memcpy( OutPnts, InPnts, ulCount * sizeof( DXFPOINT ) );
        break;
      case DX2DXO_TRANSLATE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x + eDx;
            OutPnts[i].y = InPnts[i].y + eDy;
        }
        break;
      case DX2DXO_SCALE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x * eM11;
            OutPnts[i].y = InPnts[i].y * eM22;
        }
        break;
      case DX2DXO_SCALE_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = (InPnts[i].x * eM11) + eDx;
            OutPnts[i].y = (InPnts[i].y * eM22) + eDy;
        }
        break;
      case DX2DXO_GENERAL:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 );
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 );
        }
        break;
      case DX2DXO_GENERAL_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 ) + eDx;
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 ) + eDy;
        }
        break;
      default:
        _ASSERT( 0 );   // invalid operation id
    }
} /* CDX2DXForm::TransformPoints */

inline DXFPOINT CDX2DXForm::operator*( const DXFPOINT& v ) const
{
    DXFPOINT NewPnt;
    NewPnt.x = ( v.x * eM11 ) + ( v.y * eM12 ) + eDx;
    NewPnt.y = ( v.x * eM21 ) + ( v.y * eM22 ) + eDy;
    return NewPnt;
} /* CDX2DXForm::operator* */

inline CDX2DXForm CDX2DXForm::operator*( const CDX2DXForm& Other ) const
{
    DX2DXFORM x;
    x.eM11 = ( eM11 * Other.eM11 ) + ( eM12 * Other.eM21 );
    x.eM12 = ( eM11 * Other.eM12 ) + ( eM12 * Other.eM22 );
    x.eDx  = ( eM11 * Other.eDx  ) + ( eM12 * Other.eDy  ) + eDx;

    x.eM21 = ( eM21 * Other.eM11 ) + ( eM22 * Other.eM21 );
    x.eM22 = ( eM21 * Other.eM12 ) + ( eM22 * Other.eM22 );
    x.eDy  = ( eM21 * Other.eDx  ) + ( eM22 * Other.eDy  ) + eDy;
    return x;
} /* CDX2DXForm::operator*= */

inline BOOL CDX2DXForm::Invert()
{
    switch( eOp )
    {
    case DX2DXO_IDENTITY:
        break;
    case DX2DXO_TRANSLATE:
        eDx = -eDx;
        eDy = -eDy;
        break;
    case DX2DXO_SCALE:

        if (eM11 == 0.0 || eM22 == 0.0)
            return false;
        eM11 = 1.0f / eM11;
        eM22 = 1.0f / eM22;
        break;

    case DX2DXO_SCALE_AND_TRANS:
        {
            if (eM11 == 0.0f || eM22 == 0.0f)
                return false;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM11 and b is eDx
            float flOneOverA = 1.0f / eM11;
            eDx = -eDx * flOneOverA;
            eM11 = flOneOverA;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM22 and b is eDy

            flOneOverA = 1.0f / eM22;
            eDy = -eDy * flOneOverA;
            eM22 = flOneOverA;
            break;
        }

    case DX2DXO_GENERAL:
    case DX2DXO_GENERAL_AND_TRANS:
        {
            // The inverse of A=  |a b| is | d -c|*(1/Det) where Det is the determinant of A
            //                    |c d|    |-b  a|
            // Det(A) = ad - bc

            // Compute determininant
            float flDet = (eM11 * eM22 -  eM12 * eM21);
            if (flDet == 0.0f)
                return FALSE;

            float flCoef = 1.0f / flDet;

            // Remember old value of eM11
            float flM11Original = eM11;

            eM11 = flCoef * eM22;
            eM12 = -flCoef * eM12;
            eM21 = -flCoef * eM21;
            eM22 = flCoef * flM11Original;

            // If we have a translation; then we need to 
            // compute new values for that translation
            if (eOp == DX2DXO_GENERAL_AND_TRANS)
            {
                // Remember original value of eDx
                float eDxOriginal = eDx;

                eDx = -eM11 * eDx - eM12 * eDy;
                eDy = -eM21 * eDxOriginal - eM22 * eDy;
            }
        }
        break;

    default:
        _ASSERT( 0 );   // invalid operation id
    }

    // We don't need to call DetermineOp here
    // because the op doesn't change when inverted
    // i.e. a scale remains a scale, etc.

    return true;
} /* CDX2DXForm::Invert */

/*** CDXMatrix4x4F ************
*   This class implements basic matrix operation based on a 4x4 array.
*/
//const float g_DXMat4X4Identity[4][4] =
//{
//    { 1.0, 0. , 0. , 0.  },
//    { 0. , 1.0, 0. , 0.  },
//    { 0. , 0. , 1.0, 0.  },
//    { 0. , 0. , 0. , 1.0 }
//};

class CDXMatrix4x4F
{
public:
  /*=== Member Data ===*/
    float m_Coeff[4][4];

  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDXMatrix4x4F() { SetIdentity(); }
    CDXMatrix4x4F( const CDXMatrix4x4F& Other )
        { CopyMemory( (void *)&m_Coeff, (void *)&Other.m_Coeff, sizeof(m_Coeff) ); }
    CDXMatrix4x4F( DX2DXFORM& XForm );

    /*--- operations ---*/
    void ZeroMatrix( void ) { memset( m_Coeff, 0, sizeof( m_Coeff ) ); }
    void SetIdentity( void ) {
        memset( m_Coeff, 0, sizeof( m_Coeff ) );
        m_Coeff[0][0] = m_Coeff[1][1] = m_Coeff[2][2] = m_Coeff[3][3] = 1.0;
    }
    void SetCoefficients( float Coeff[4][4] ) { memcpy( m_Coeff, Coeff, sizeof( m_Coeff )); }
    void GetCoefficients( float Coeff[4][4] ) { memcpy( Coeff, m_Coeff, sizeof( m_Coeff )); }

    //BOOL IsIdentity();
    void Scale( float sx, float sy, float sz );
    void Rotate( float rx, float ry, float rz );
    void Translate( float dx, float dy, float dz );
    BOOL Invert();
    BOOL GetInverse( CDXMatrix4x4F *pIn );
    void Transpose();
    void GetTranspose( CDXMatrix4x4F *pIn );
    void GetAdjoint( CDXMatrix4x4F *pIn );
    HRESULT InitFromSafeArray( SAFEARRAY *psa );
    HRESULT GetSafeArray( SAFEARRAY **ppsa ) const;
    void TransformBounds( DXBNDS& Bnds, DXBNDS& ResultBnds );

    /*--- operators ---*/
    CDXDVec operator*( CDXDVec& v) const;
    CDXCVec operator*( CDXCVec& v) const;
    CDXMatrix4x4F operator*(CDXMatrix4x4F Matrix) const;
    void operator*=(CDXMatrix4x4F Matrix) const;
    void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix);
    void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix);
    void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix);
    BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const;
    BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const;
};

inline CDXMatrix4x4F::CDXMatrix4x4F( DX2DXFORM& XForm )
{
    SetIdentity();
    m_Coeff[0][0] = XForm.eM11;
    m_Coeff[0][1] = XForm.eM12;
    m_Coeff[1][0] = XForm.eM21;
    m_Coeff[1][1] = XForm.eM22;
    m_Coeff[0][3] = XForm.eDx;
    m_Coeff[1][3] = XForm.eDy;
}

// Additional Operations

inline void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix)
{
    CopyMemory( (void *)m_Coeff, (const void *)srcMatrix.m_Coeff, sizeof(srcMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator= */

inline BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const
{
    return !memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator== */

inline BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const
{
    return memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator!= */

inline void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix)
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] += otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator+= */

inline void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix) 
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] -= otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator-= */

inline CDXDVec CDXMatrix4x4F::operator*(CDXDVec& v) const
{
    CDXDVec t;
    float temp;
    temp = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[0] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[1] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[2] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    t[3] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    return t;
} /* CDXMatrix4x4F::operator*(DXDVEC) */

inline CDXCVec CDXMatrix4x4F::operator*(CDXCVec& v) const
{
    CDXCVec t;
    t[0] = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[1] = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[2] = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[3] = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    return t;
} /* CDXMatrix4x4F::operator*(DXCVEC) */

inline CDXMatrix4x4F CDXMatrix4x4F::operator*(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    return t;
} /* CDXMatrix4x4F::operator*(CDXMatrix4x4F) */
            
inline void CDXMatrix4x4F::operator*=(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    CopyMemory( (void *)m_Coeff, (void *)t.m_Coeff, sizeof(m_Coeff) );
} /* CDXMatrix4x4F::operator*=(CDXMatrix4x4F) */
            

inline void CDXMatrix4x4F::Scale( float sx, float sy, float sz )
{
    if( sx != 1. )
    {
        m_Coeff[0][0] *= sx;
        m_Coeff[0][1] *= sx;
        m_Coeff[0][2] *= sx;
        m_Coeff[0][3] *= sx;
    }
    if( sy != 1. )
    {
        m_Coeff[1][0] *= sy;
        m_Coeff[1][1] *= sy;
        m_Coeff[1][2] *= sy;
        m_Coeff[1][3] *= sy;
    }
    if( sz != 1. )
    {
        m_Coeff[2][0] *= sz;
        m_Coeff[2][1] *= sz;
        m_Coeff[2][2] *= sz;
        m_Coeff[2][3] *= sz;
    }
} /* CDXMatrix4x4F::Scale */

inline void CDXMatrix4x4F::Translate( float dx, float dy, float dz )
{
    float a, b, c, d;
    a = b = c = d = 0;
    if( dx != 0. )
    {
        a += m_Coeff[0][0]*dx;
        b += m_Coeff[0][1]*dx;
        c += m_Coeff[0][2]*dx;
        d += m_Coeff[0][3]*dx;
    }
    if( dy != 0. )
    {
        a += m_Coeff[1][0]*dy;
        b += m_Coeff[1][1]*dy;
        c += m_Coeff[1][2]*dy;
        d += m_Coeff[1][3]*dy;
    }
    if( dz != 0. )
    {
        a += m_Coeff[2][0]*dz;
        b += m_Coeff[2][1]*dz;
        c += m_Coeff[2][2]*dz;
        d += m_Coeff[2][3]*dz;
    }
    m_Coeff[3][0] += a;
    m_Coeff[3][1] += b;
    m_Coeff[3][2] += c;
    m_Coeff[3][3] += d;
} /* CDXMatrix4x4F::Translate */

inline void CDXMatrix4x4F::Rotate( float rx, float ry, float rz )
{
    const float l_dfCte = (const float)(3.1415926535/180.0);

    float lAngleY = 0.0;
    float lAngleX = 0.0;
    float lAngleZ = 0.0;
    float lCosX = 1.0;
    float lSinX = 0.0;
    float lCosY = 1.0;
    float lSinY = 0.0;
    float lCosZ = 1.0;
    float lSinZ = 0.0;

    // calculate rotation angle sines and cosines
    if( rx != 0 )
    {
        lAngleX = rx * l_dfCte;
        lCosX = (float)cos(lAngleX);
        lSinX = (float)sin(lAngleX);
        if (lCosX > 0.0F && lCosX < 0.0000005F)
        {
            lCosX = .0F;
        }
        if (lSinX > -0.0000005F && lSinX < .0F)
        {
            lSinX = .0F;
        }
    }
    if( ry != 0 )
    {
        lAngleY = ry * l_dfCte;
        lCosY = (float)cos(lAngleY);
        lSinY = (float)sin(lAngleY);
        if (lCosY > 0.0F && lCosY < 0.0000005F)
        {
            lCosY = .0F;
        }
        if (lSinY > -0.0000005F && lSinY < .0F)
        {
            lSinY = .0F;
        }
    }
    if( rz != 0 )
    {
        lAngleZ = rz * l_dfCte;
        lCosZ = (float)cos(lAngleZ);
        lSinZ = (float)sin(lAngleZ);
        if (lCosZ > 0.0F && lCosZ < 0.0000005F)
        {
            lCosZ = .0F;
        }
        if (lSinZ > -0.0000005F && lSinZ < .0F)
        {
            lSinZ = .0F;
        }
    }

    float u, v;
    int i;

    //--- X Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[1][i]; 
        v = m_Coeff[2][i];
        m_Coeff[1][i] = lCosX*u+lSinX*v; 
        m_Coeff[2][i] = -lSinX*u+lCosX*v;
    }

    //--- Y Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[2][i];
        m_Coeff[0][i] = lCosY*u-lSinY*v; 
        m_Coeff[2][i] = lSinY*u+lCosY*v;
    }

    //--- Z Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[1][i];
        m_Coeff[0][i] = lCosZ*u+lSinZ*v; 
        m_Coeff[1][i] = -lSinZ*u+lCosZ*v;
    }
}

/*
inline BOOL CDXMatrix4x4F::IsIdentity()
{
    return  !memcmp( m_Coeff, g_DXMat4X4Identity, sizeof(g_DXMat4X4Identity) );
} /* CDXMatrix4x4F::IsIdentity */


/*
   Uses Gaussian elimination to invert the 4 x 4 non-linear matrix in t and
   return the result in Mx.  The matrix t is destroyed in the process.
*/
inline BOOL CDXMatrix4x4F::Invert()
{
    int i,j,k,Pivot;
    float PValue;
    CDXMatrix4x4F Mx;
    Mx.SetIdentity();

/* Find pivot element.  Use partial pivoting by row */
    for( i = 0;i < 4; i++ )
    {
        Pivot = 0;
        for( j = 0; j < 4; j++ )
        {
            if( fabs(m_Coeff[i][j]) > fabs(m_Coeff[i][Pivot]) ) Pivot = j;
        }

        if( m_Coeff[i][Pivot] == 0.0 )
        {
            ZeroMatrix();   /* Singular Matrix */
            return FALSE; 
        }

/* Normalize */
        PValue = m_Coeff[i][Pivot];
        for( j = 0; j < 4; j++ )
        {
            m_Coeff[i][j] /= PValue;
            Mx.m_Coeff[i][j] /= PValue;
        }

/* Zeroing */
        for( j = 0; j < 4; j++ )
        {
            if( j != i )
            {
                PValue = m_Coeff[j][Pivot];
                for( k = 0; k < 4; k++ )
                {
                    m_Coeff[j][k] -= PValue*m_Coeff[i][k];
                    Mx.m_Coeff[j][k] -= PValue*Mx.m_Coeff[i][k];
                }
            }
        }
    }

/* Reorder rows */
    for( i = 0; i < 4; i++ )
    {
        if( m_Coeff[i][i] != 1.0 )
        {
            for( j = i + 1; j < 4; j++ )
                if( m_Coeff[j][i] == 1.0 ) break;
            if( j >= 4 )
            {
                ZeroMatrix();
                return FALSE;
            }

            //--- swap rows i and j of original
            for( k = 0; k < 4; k++ )
            {
                m_Coeff[i][k] += m_Coeff[j][k];
                m_Coeff[j][k] = m_Coeff[i][k] - m_Coeff[j][k];
                m_Coeff[i][k] -= m_Coeff[j][k];
            }
            
            //--- swap rows i and j of result
            for( k = 0; k < 4; k++ )
            {
                Mx.m_Coeff[i][k] += Mx.m_Coeff[j][k];
                Mx.m_Coeff[j][k] = Mx.m_Coeff[i][k] - Mx.m_Coeff[j][k];
                Mx.m_Coeff[i][k] -= Mx.m_Coeff[j][k];
            }
        }
    }
    *this = Mx;
    return TRUE;
} /* CDXMatrix4x4F::Invert */

inline void CDXMatrix4x4F::Transpose()
{
    float temp;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */

inline void CDXMatrix4x4F::GetTranspose( CDXMatrix4x4F *m )
{
    float temp;

    (*this) = *m;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */


/*
Matrix Inversion
by Richard Carling
from "Graphics Gems", Academic Press, 1990
*/

#define SMALL_NUMBER    1.e-8
/* 
 *   inverse( original_matrix, inverse_matrix )
 * 
 *    calculate the inverse of a 4x4 matrix
 *
 *     -1     
 *     A  = ___1__ adjoint A
 *         det A
 */

inline BOOL CDXMatrix4x4F::GetInverse( CDXMatrix4x4F *pIn )
{
    int i, j;
    float det;

    /* calculate the adjoint matrix */

    GetAdjoint( pIn );

    /*  calculate the 4x4 determinant
     *  if the determinant is zero, 
     *  then the inverse matrix is not unique.
     */

    det = det4x4( pIn );

    if( fabs( det ) < SMALL_NUMBER )
    {
        //  Non-singular matrix, no inverse!
        return FALSE;;
    }

    /* scale the adjoint matrix to get the inverse */

    for( i = 0; i < 4; i++ )
        for( j = 0; j < 4; j++ )
            m_Coeff[i][j] = m_Coeff[i][j] / det;

    return TRUE;
}


/* 
 *   adjoint( original_matrix, inverse_matrix )
 * 
 *     calculate the adjoint of a 4x4 matrix
 *
 *      Let  a   denote the minor determinant of matrix A obtained by
 *           ij
 *
 *      deleting the ith row and jth column from A.
 *
 *                    i+j
 *     Let  b   = (-1)    a
 *          ij            ji
 *
 *    The matrix B = (b  ) is the adjoint of A
 *                     ij
 */
inline void CDXMatrix4x4F::GetAdjoint( CDXMatrix4x4F *pIn )
{
    float a1, a2, a3, a4, b1, b2, b3, b4;
    float c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid  */
    /* selecting correct values  */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1];
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];


    /* row column labeling reversed since we transpose rows & columns */

    m_Coeff[0][0]  =   det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4);
    m_Coeff[1][0]  = - det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4);
    m_Coeff[2][0]  =   det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4);
    m_Coeff[3][0]  = - det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4);
        
    m_Coeff[0][1]  = - det3x3( b1, b3, b4, c1, c3, c4, d1, d3, d4);
    m_Coeff[1][1]  =   det3x3( a1, a3, a4, c1, c3, c4, d1, d3, d4);
    m_Coeff[2][1]  = - det3x3( a1, a3, a4, b1, b3, b4, d1, d3, d4);
    m_Coeff[3][1]  =   det3x3( a1, a3, a4, b1, b3, b4, c1, c3, c4);
        
    m_Coeff[0][2]  =   det3x3( b1, b2, b4, c1, c2, c4, d1, d2, d4);
    m_Coeff[1][2]  = - det3x3( a1, a2, a4, c1, c2, c4, d1, d2, d4);
    m_Coeff[2][2]  =   det3x3( a1, a2, a4, b1, b2, b4, d1, d2, d4);
    m_Coeff[3][2]  = - det3x3( a1, a2, a4, b1, b2, b4, c1, c2, c4);
        
    m_Coeff[0][3]  = - det3x3( b1, b2, b3, c1, c2, c3, d1, d2, d3);
    m_Coeff[1][3]  =   det3x3( a1, a2, a3, c1, c2, c3, d1, d2, d3);
    m_Coeff[2][3]  = - det3x3( a1, a2, a3, b1, b2, b3, d1, d2, d3);
    m_Coeff[3][3]  =   det3x3( a1, a2, a3, b1, b2, b3, c1, c2, c3);
}
/*
 * float = det4x4( matrix )
 * 
 * calculate the determinant of a 4x4 matrix.
 */
inline float det4x4( CDXMatrix4x4F *pIn )
{
    float ans;
    float a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid selecting */
    /*  correct elements */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1]; 
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];

    ans = a1 * det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4 )
        - b1 * det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4 )
        + c1 * det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4 )
        - d1 * det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4 );
    return ans;
}

/*
 * float = det3x3(  a1, a2, a3, b1, b2, b3, c1, c2, c3 )
 * 
 * calculate the determinant of a 3x3 matrix
 * in the form
 *
 *     | a1,  b1,  c1 |
 *     | a2,  b2,  c2 |
 *     | a3,  b3,  c3 |
 */

inline float det3x3( float a1, float a2, float a3, 
                     float b1, float b2, float b3, 
                     float c1, float c2, float c3 )
{
    float ans;

    ans = a1 * det2x2( b2, b3, c2, c3 )
        - b1 * det2x2( a2, a3, c2, c3 )
        + c1 * det2x2( a2, a3, b2, b3 );
    return ans;
}

/*
 * float = det2x2( float a, float b, float c, float d )
 * 
 * calculate the determinant of a 2x2 matrix.
 */
inline float det2x2( float a, float b, float c, float d )
{
    float ans = a * d - b * c;
    return ans;
}

inline HRESULT CDXMatrix4x4F::InitFromSafeArray( SAFEARRAY * /*pSA*/ )
{
    HRESULT hr = S_OK;
#if 0
    long *pData;

    if( !pSA || ( pSA->cDims != 1 ) ||
         ( pSA->cbElements != sizeof(float) ) ||
         ( pSA->rgsabound->lLbound   != 1 ) ||
         ( pSA->rgsabound->cElements != 8 ) 
      )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = SafeArrayAccessData(pSA, (void **)&pData);

        if( SUCCEEDED( hr ) )
        {
            for( int i = 0; i < 4; ++i )
            {
                m_Bounds[i].Min = pData[i];
                m_Bounds[i].Max = pData[i+4];
                m_Bounds[i].SampleRate = SampleRate;
            }

            hr = SafeArrayUnaccessData( pSA );
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::InitFromSafeArray */

inline HRESULT CDXMatrix4x4F::GetSafeArray( SAFEARRAY ** /*ppSA*/ ) const
{
    HRESULT hr = S_OK;
#if 0
    SAFEARRAY *pSA;

    if( !ppSA )
    {
        hr = E_POINTER;
    }
    else
    {
        SAFEARRAYBOUND rgsabound;
        rgsabound.lLbound   = 1;
        rgsabound.cElements = 16;

        if( !(pSA = SafeArrayCreate( VT_I4, 1, &rgsabound ) ) )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            long *pData;
            hr = SafeArrayAccessData( pSA, (void **)&pData );

            if( SUCCEEDED( hr ) )
            {
                for( int i = 0; i < 4; ++i )
                {
                    pData[i]   = m_Bounds[i].Min;
                    pData[i+4] = m_Bounds[i].Max;
                }

                hr = SafeArrayUnaccessData( pSA );
            }
        }

        if( SUCCEEDED( hr ) )
        {
            *ppSA = pSA;
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::GetSafeArray */

inline void CDXMatrix4x4F::TransformBounds( DXBNDS& /*Bnds*/, DXBNDS& /*ResultBnds*/ )
{

} /* CDXMatrix4x4F::TransformBounds */



#endif   // __DXTPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\dxtransp.h ===
//depot/Lab06_N/root/public/internal/mshtml/inc/dxtransp.h#1 - add change 5035 (text)

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtransp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxtransp_h__
#define __dxtransp_h__

/* Forward Declarations */ 

#ifndef __IDXRasterizer_FWD_DEFINED__
#define __IDXRasterizer_FWD_DEFINED__
typedef interface IDXRasterizer IDXRasterizer;
#endif 	/* __IDXRasterizer_FWD_DEFINED__ */


#ifndef __IDXTLabel_FWD_DEFINED__
#define __IDXTLabel_FWD_DEFINED__
typedef interface IDXTLabel IDXTLabel;
#endif 	/* __IDXTLabel_FWD_DEFINED__ */


#ifndef __IDX2DDebug_FWD_DEFINED__
#define __IDX2DDebug_FWD_DEFINED__
typedef interface IDX2DDebug IDX2DDebug;
#endif 	/* __IDX2DDebug_FWD_DEFINED__ */


#ifndef __IDX2D_FWD_DEFINED__
#define __IDX2D_FWD_DEFINED__
typedef interface IDX2D IDX2D;
#endif 	/* __IDX2D_FWD_DEFINED__ */


#ifndef __IDXGradient2_FWD_DEFINED__
#define __IDXGradient2_FWD_DEFINED__
typedef interface IDXGradient2 IDXGradient2;
#endif 	/* __IDXGradient2_FWD_DEFINED__ */


#ifndef __IDXWarp_FWD_DEFINED__
#define __IDXWarp_FWD_DEFINED__
typedef interface IDXWarp IDXWarp;
#endif 	/* __IDXWarp_FWD_DEFINED__ */


#ifndef __IDXTClipOrigin_FWD_DEFINED__
#define __IDXTClipOrigin_FWD_DEFINED__
typedef interface IDXTClipOrigin IDXTClipOrigin;
#endif 	/* __IDXTClipOrigin_FWD_DEFINED__ */


#ifndef __DXWarp_FWD_DEFINED__
#define __DXWarp_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXWarp DXWarp;
#else
typedef struct DXWarp DXWarp;
#endif /* __cplusplus */

#endif 	/* __DXWarp_FWD_DEFINED__ */


#ifndef __DXTLabel_FWD_DEFINED__
#define __DXTLabel_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTLabel DXTLabel;
#else
typedef struct DXTLabel DXTLabel;
#endif /* __cplusplus */

#endif 	/* __DXTLabel_FWD_DEFINED__ */


#ifndef __DXRasterizer_FWD_DEFINED__
#define __DXRasterizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXRasterizer DXRasterizer;
#else
typedef struct DXRasterizer DXRasterizer;
#endif /* __cplusplus */

#endif 	/* __DXRasterizer_FWD_DEFINED__ */


#ifndef __DX2D_FWD_DEFINED__
#define __DX2D_FWD_DEFINED__

#ifdef __cplusplus
typedef class DX2D DX2D;
#else
typedef struct DX2D DX2D;
#endif /* __cplusplus */

#endif 	/* __DX2D_FWD_DEFINED__ */


/* header files for imported files */
#include "dxtrans.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dxtransp_0000 */
/* [local] */ 






typedef 
enum DXRASTERFILL
    {	DXRASTER_PEN	= 0,
	DXRASTER_BRUSH	= 1,
	DXRASTER_BACKGROUND	= 2
    }	DXRASTERFILL;

typedef struct DXRASTERSCANINFO
    {
    ULONG ulIndex;
    ULONG Row;
    const BYTE __RPC_FAR *pWeights;
    const DXRUNINFO __RPC_FAR *pRunInfo;
    ULONG cRunInfo;
    }	DXRASTERSCANINFO;

typedef struct DXRASTERPOINTINFO
    {
    DXOVERSAMPLEDESC Pixel;
    ULONG ulIndex;
    BYTE Weight;
    }	DXRASTERPOINTINFO;

typedef struct DXRASTERRECTINFO
    {
    ULONG ulIndex;
    RECT Rect;
    BYTE Weight;
    }	DXRASTERRECTINFO;



extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0000_v0_0_s_ifspec;

#ifndef __IDXRasterizer_INTERFACE_DEFINED__
#define __IDXRasterizer_INTERFACE_DEFINED__

/* interface IDXRasterizer */
/* [object][hidden][unique][uuid][local] */ 


EXTERN_C const IID IID_IDXRasterizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B635-C37D-11d1-905E-00C04FD9189D")
    IDXRasterizer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSurface( 
            /* [in] */ IDXSurface __RPC_FAR *pDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFill( 
            /* [in] */ ULONG ulIndex,
            /* [in] */ IDXSurface __RPC_FAR *pSurface,
            /* [in] */ const POINT __RPC_FAR *ppt,
            /* [in] */ DXSAMPLE FillColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFill( 
            /* [in] */ ULONG ulIndex,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
            /* [out] */ POINT __RPC_FAR *ppt,
            /* [out] */ DXSAMPLE __RPC_FAR *pFillColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginRendering( 
            /* [in] */ ULONG ulTimeOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndRendering( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderScan( 
            /* [in] */ const DXRASTERSCANINFO __RPC_FAR *pScanInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPixel( 
            /* [in] */ DXRASTERPOINTINFO __RPC_FAR *pPointInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FillRect( 
            /* [in] */ const DXRASTERRECTINFO __RPC_FAR *pRectInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBounds( 
            /* [out] */ DXBNDS __RPC_FAR *pBounds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXRasterizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXRasterizer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXRasterizer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSurface )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IDXRasterizer __RPC_FAR * This,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFill )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ ULONG ulIndex,
            /* [in] */ IDXSurface __RPC_FAR *pSurface,
            /* [in] */ const POINT __RPC_FAR *ppt,
            /* [in] */ DXSAMPLE FillColor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFill )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ ULONG ulIndex,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
            /* [out] */ POINT __RPC_FAR *ppt,
            /* [out] */ DXSAMPLE __RPC_FAR *pFillColor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginRendering )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ ULONG ulTimeOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndRendering )( 
            IDXRasterizer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RenderScan )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ const DXRASTERSCANINFO __RPC_FAR *pScanInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPixel )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ DXRASTERPOINTINFO __RPC_FAR *pPointInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FillRect )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ const DXRASTERRECTINFO __RPC_FAR *pRectInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBounds )( 
            IDXRasterizer __RPC_FAR * This,
            /* [out] */ DXBNDS __RPC_FAR *pBounds);
        
        END_INTERFACE
    } IDXRasterizerVtbl;

    interface IDXRasterizer
    {
        CONST_VTBL struct IDXRasterizerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXRasterizer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXRasterizer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXRasterizer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXRasterizer_SetSurface(This,pDXSurface)	\
    (This)->lpVtbl -> SetSurface(This,pDXSurface)

#define IDXRasterizer_GetSurface(This,ppDXSurface)	\
    (This)->lpVtbl -> GetSurface(This,ppDXSurface)

#define IDXRasterizer_SetFill(This,ulIndex,pSurface,ppt,FillColor)	\
    (This)->lpVtbl -> SetFill(This,ulIndex,pSurface,ppt,FillColor)

#define IDXRasterizer_GetFill(This,ulIndex,ppSurface,ppt,pFillColor)	\
    (This)->lpVtbl -> GetFill(This,ulIndex,ppSurface,ppt,pFillColor)

#define IDXRasterizer_BeginRendering(This,ulTimeOut)	\
    (This)->lpVtbl -> BeginRendering(This,ulTimeOut)

#define IDXRasterizer_EndRendering(This)	\
    (This)->lpVtbl -> EndRendering(This)

#define IDXRasterizer_RenderScan(This,pScanInfo)	\
    (This)->lpVtbl -> RenderScan(This,pScanInfo)

#define IDXRasterizer_SetPixel(This,pPointInfo)	\
    (This)->lpVtbl -> SetPixel(This,pPointInfo)

#define IDXRasterizer_FillRect(This,pRectInfo)	\
    (This)->lpVtbl -> FillRect(This,pRectInfo)

#define IDXRasterizer_GetBounds(This,pBounds)	\
    (This)->lpVtbl -> GetBounds(This,pBounds)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXRasterizer_SetSurface_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pDXSurface);


void __RPC_STUB IDXRasterizer_SetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetSurface_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXRasterizer_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_SetFill_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ ULONG ulIndex,
    /* [in] */ IDXSurface __RPC_FAR *pSurface,
    /* [in] */ const POINT __RPC_FAR *ppt,
    /* [in] */ DXSAMPLE FillColor);


void __RPC_STUB IDXRasterizer_SetFill_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetFill_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ ULONG ulIndex,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
    /* [out] */ POINT __RPC_FAR *ppt,
    /* [out] */ DXSAMPLE __RPC_FAR *pFillColor);


void __RPC_STUB IDXRasterizer_GetFill_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_BeginRendering_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ ULONG ulTimeOut);


void __RPC_STUB IDXRasterizer_BeginRendering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_EndRendering_Proxy( 
    IDXRasterizer __RPC_FAR * This);


void __RPC_STUB IDXRasterizer_EndRendering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_RenderScan_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ const DXRASTERSCANINFO __RPC_FAR *pScanInfo);


void __RPC_STUB IDXRasterizer_RenderScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_SetPixel_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ DXRASTERPOINTINFO __RPC_FAR *pPointInfo);


void __RPC_STUB IDXRasterizer_SetPixel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_FillRect_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ const DXRASTERRECTINFO __RPC_FAR *pRectInfo);


void __RPC_STUB IDXRasterizer_FillRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetBounds_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [out] */ DXBNDS __RPC_FAR *pBounds);


void __RPC_STUB IDXRasterizer_GetBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXRasterizer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtransp_0278 */
/* [local] */ 

typedef 
enum DX2DXFORMOPS
    {	DX2DXO_IDENTITY	= 0,
	DX2DXO_TRANSLATE	= DX2DXO_IDENTITY + 1,
	DX2DXO_SCALE	= DX2DXO_TRANSLATE + 1,
	DX2DXO_SCALE_AND_TRANS	= DX2DXO_SCALE + 1,
	DX2DXO_GENERAL	= DX2DXO_SCALE_AND_TRANS + 1,
	DX2DXO_GENERAL_AND_TRANS	= DX2DXO_GENERAL + 1
    }	DX2DXFORMOPS;

typedef struct DX2DXFORM
    {
    FLOAT eM11;
    FLOAT eM12;
    FLOAT eM21;
    FLOAT eM22;
    FLOAT eDx;
    FLOAT eDy;
    DX2DXFORMOPS eOp;
    }	DX2DXFORM;

typedef struct DX2DXFORM __RPC_FAR *PDX2DXFORM;

typedef 
enum DX2DPOLYDRAW
    {	DX2D_WINDING_FILL	= 1L << 0,
	DX2D_NO_FLATTEN	= 1L << 1,
	DX2D_DO_GRID_FIT	= 1L << 2,
	DX2D_IS_RECT	= 1L << 3,
	DX2D_STROKE	= 1L << 4,
	DX2D_FILL	= 1L << 5,
	DX2D_UNUSED	= 0xffffffc0
    }	DX2DPOLYDRAW;

typedef struct DXFPOINT
    {
    FLOAT x;
    FLOAT y;
    }	DXFPOINT;

typedef 
enum DX2DPEN
    {	DX2D_PEN_DEFAULT	= 0,
	DX2D_PEN_WIDTH_IN_DISPLAY_COORDS	= 1L << 0,
	DX2D_PEN_UNUSED	= 0xfffffffe
    }	DX2DPEN;

typedef struct DXPEN
    {
    DXSAMPLE Color;
    float Width;
    DWORD Style;
    IDXSurface __RPC_FAR *pTexture;
    DXFPOINT TexturePos;
    DWORD dwFlags;
    }	DXPEN;

typedef struct DXBRUSH
    {
    DXSAMPLE Color;
    IDXSurface __RPC_FAR *pTexture;
    DXFPOINT TexturePos;
    }	DXBRUSH;

typedef 
enum DX2DGRADIENT
    {	DX2DGRAD_DEFAULT	= 0,
	DX2DGRAD_CLIPGRADIENT	= 1,
	DX2DGRAD_UNUSED	= 0xfffffffe
    }	DX2DGRADIENT;

typedef 
enum DXLOGFONTENUM
    {	DXLF_HEIGHT	= 1,
	DXLF_WIDTH	= 2,
	DXLF_ESC	= 4,
	DXLF_ORIENTATION	= 8,
	DXLF_WEIGHT	= 16,
	DXLF_ITALIC	= 32,
	DXLF_UNDERLINE	= 64,
	DXLF_STRIKEOUT	= 128,
	DXLF_CHARSET	= 256,
	DXLF_OUTPREC	= 512,
	DXLF_CLIPPREC	= 1024,
	DXLF_QUALITY	= 2048,
	DXLF_PITCHANDFAM	= 4096,
	DXLF_FACENAME	= 8192,
	DXLF_ALL	= 0x3fff
    }	DXLOGFONTENUM;

#ifndef _WINGDI_
typedef struct tagLOGFONTA
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    }	LOGFONTA;

typedef struct tagLOGFONTW
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    }	LOGFONTW;

typedef LOGFONTA LOGFONT;

#endif


extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0278_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0278_v0_0_s_ifspec;

#ifndef __IDXTLabel_INTERFACE_DEFINED__
#define __IDXTLabel_INTERFACE_DEFINED__

/* interface IDXTLabel */
/* [object][hidden][unique][uuid] */ 


EXTERN_C const IID IID_IDXTLabel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0C17F0E-AE41-11d1-9A3B-0000F8756A10")
    IDXTLabel : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFontHandle( 
            /* [in] */ HFONT hFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFontHandle( 
            /* [out] */ HFONT __RPC_FAR *phFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTextString( 
            /* [in] */ LPCWSTR pString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextString( 
            /* [out] */ LPWSTR __RPC_FAR *ppString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillColor( 
            /* [out] */ DXSAMPLE __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFillColor( 
            /* [in] */ DXSAMPLE newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundColor( 
            /* [out] */ DXSAMPLE __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundColor( 
            /* [in] */ DXSAMPLE newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTexturePosition( 
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTexturePosition( 
            /* [in] */ long x,
            /* [in] */ long y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMatrix( 
            /* [out] */ PDX2DXFORM pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMatrix( 
            /* [in] */ const PDX2DXFORM pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogfont( 
            /* [in] */ const LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogfont( 
            /* [out] */ LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteWithRasterizer( 
            /* [in] */ IDXRasterizer __RPC_FAR *pRasterizer,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaselineOffset( 
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py,
            /* [out] */ long __RPC_FAR *pdx,
            /* [out] */ long __RPC_FAR *pdy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTLabelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTLabel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTLabel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFontHandle )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ HFONT hFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFontHandle )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ HFONT __RPC_FAR *phFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTextString )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ LPCWSTR pString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTextString )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFillColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ DXSAMPLE __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFillColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ DXSAMPLE newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackgroundColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ DXSAMPLE __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackgroundColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ DXSAMPLE newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTexturePosition )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTexturePosition )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMatrix )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ PDX2DXFORM pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMatrix )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ const PDX2DXFORM pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogfont )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ const LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogfont )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecuteWithRasterizer )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ IDXRasterizer __RPC_FAR *pRasterizer,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBaselineOffset )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py,
            /* [out] */ long __RPC_FAR *pdx,
            /* [out] */ long __RPC_FAR *pdy);
        
        END_INTERFACE
    } IDXTLabelVtbl;

    interface IDXTLabel
    {
        CONST_VTBL struct IDXTLabelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTLabel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTLabel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTLabel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTLabel_SetFontHandle(This,hFont)	\
    (This)->lpVtbl -> SetFontHandle(This,hFont)

#define IDXTLabel_GetFontHandle(This,phFont)	\
    (This)->lpVtbl -> GetFontHandle(This,phFont)

#define IDXTLabel_SetTextString(This,pString)	\
    (This)->lpVtbl -> SetTextString(This,pString)

#define IDXTLabel_GetTextString(This,ppString)	\
    (This)->lpVtbl -> GetTextString(This,ppString)

#define IDXTLabel_GetFillColor(This,pVal)	\
    (This)->lpVtbl -> GetFillColor(This,pVal)

#define IDXTLabel_SetFillColor(This,newVal)	\
    (This)->lpVtbl -> SetFillColor(This,newVal)

#define IDXTLabel_GetBackgroundColor(This,pVal)	\
    (This)->lpVtbl -> GetBackgroundColor(This,pVal)

#define IDXTLabel_SetBackgroundColor(This,newVal)	\
    (This)->lpVtbl -> SetBackgroundColor(This,newVal)

#define IDXTLabel_GetTexturePosition(This,px,py)	\
    (This)->lpVtbl -> GetTexturePosition(This,px,py)

#define IDXTLabel_SetTexturePosition(This,x,y)	\
    (This)->lpVtbl -> SetTexturePosition(This,x,y)

#define IDXTLabel_GetMatrix(This,pXform)	\
    (This)->lpVtbl -> GetMatrix(This,pXform)

#define IDXTLabel_SetMatrix(This,pXform)	\
    (This)->lpVtbl -> SetMatrix(This,pXform)

#define IDXTLabel_SetLogfont(This,plf,dwFlags)	\
    (This)->lpVtbl -> SetLogfont(This,plf,dwFlags)

#define IDXTLabel_GetLogfont(This,plf,dwFlags)	\
    (This)->lpVtbl -> GetLogfont(This,plf,dwFlags)

#define IDXTLabel_ExecuteWithRasterizer(This,pRasterizer,pClipBnds,pPlacement)	\
    (This)->lpVtbl -> ExecuteWithRasterizer(This,pRasterizer,pClipBnds,pPlacement)

#define IDXTLabel_GetBaselineOffset(This,px,py,pdx,pdy)	\
    (This)->lpVtbl -> GetBaselineOffset(This,px,py,pdx,pdy)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTLabel_SetFontHandle_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ HFONT hFont);


void __RPC_STUB IDXTLabel_SetFontHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetFontHandle_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ HFONT __RPC_FAR *phFont);


void __RPC_STUB IDXTLabel_GetFontHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetTextString_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ LPCWSTR pString);


void __RPC_STUB IDXTLabel_SetTextString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetTextString_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppString);


void __RPC_STUB IDXTLabel_GetTextString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetFillColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ DXSAMPLE __RPC_FAR *pVal);


void __RPC_STUB IDXTLabel_GetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetFillColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ DXSAMPLE newVal);


void __RPC_STUB IDXTLabel_SetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetBackgroundColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ DXSAMPLE __RPC_FAR *pVal);


void __RPC_STUB IDXTLabel_GetBackgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetBackgroundColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ DXSAMPLE newVal);


void __RPC_STUB IDXTLabel_SetBackgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetTexturePosition_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *px,
    /* [out] */ long __RPC_FAR *py);


void __RPC_STUB IDXTLabel_GetTexturePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetTexturePosition_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ long x,
    /* [in] */ long y);


void __RPC_STUB IDXTLabel_SetTexturePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetMatrix_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ PDX2DXFORM pXform);


void __RPC_STUB IDXTLabel_GetMatrix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetMatrix_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ const PDX2DXFORM pXform);


void __RPC_STUB IDXTLabel_SetMatrix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetLogfont_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ const LOGFONT __RPC_FAR *plf,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTLabel_SetLogfont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetLogfont_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ LOGFONT __RPC_FAR *plf,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTLabel_GetLogfont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_ExecuteWithRasterizer_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ IDXRasterizer __RPC_FAR *pRasterizer,
    /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
    /* [in] */ const DXVEC __RPC_FAR *pPlacement);


void __RPC_STUB IDXTLabel_ExecuteWithRasterizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetBaselineOffset_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *px,
    /* [out] */ long __RPC_FAR *py,
    /* [out] */ long __RPC_FAR *pdx,
    /* [out] */ long __RPC_FAR *pdy);


void __RPC_STUB IDXTLabel_GetBaselineOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTLabel_INTERFACE_DEFINED__ */


#ifndef __IDX2DDebug_INTERFACE_DEFINED__
#define __IDX2DDebug_INTERFACE_DEFINED__

/* interface IDX2DDebug */
/* [object][hidden][unique][uuid][local] */ 


EXTERN_C const IID IID_IDX2DDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03BB2457-A279-11d1-81C6-0000F87557DB")
    IDX2DDebug : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDC( 
            HDC hDC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDC( 
            HDC __RPC_FAR *phDC) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDX2DDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDX2DDebug __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDX2DDebug __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDX2DDebug __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDC )( 
            IDX2DDebug __RPC_FAR * This,
            HDC hDC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDC )( 
            IDX2DDebug __RPC_FAR * This,
            HDC __RPC_FAR *phDC);
        
        END_INTERFACE
    } IDX2DDebugVtbl;

    interface IDX2DDebug
    {
        CONST_VTBL struct IDX2DDebugVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDX2DDebug_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDX2DDebug_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDX2DDebug_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDX2DDebug_SetDC(This,hDC)	\
    (This)->lpVtbl -> SetDC(This,hDC)

#define IDX2DDebug_GetDC(This,phDC)	\
    (This)->lpVtbl -> GetDC(This,phDC)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDX2DDebug_SetDC_Proxy( 
    IDX2DDebug __RPC_FAR * This,
    HDC hDC);


void __RPC_STUB IDX2DDebug_SetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2DDebug_GetDC_Proxy( 
    IDX2DDebug __RPC_FAR * This,
    HDC __RPC_FAR *phDC);


void __RPC_STUB IDX2DDebug_GetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDX2DDebug_INTERFACE_DEFINED__ */


#ifndef __IDX2D_INTERFACE_DEFINED__
#define __IDX2D_INTERFACE_DEFINED__

/* interface IDX2D */
/* [object][hidden][unique][uuid][local] */ 


EXTERN_C const IID IID_IDX2D;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EFD02A9-A996-11d1-81C9-0000F87557DB")
    IDX2D : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTransformFactory( 
            IDXTransformFactory __RPC_FAR *pTransFact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransformFactory( 
            IDXTransformFactory __RPC_FAR *__RPC_FAR *ppTransFact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSurface( 
            IUnknown __RPC_FAR *pSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClipRect( 
            RECT __RPC_FAR *pClipRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClipRect( 
            RECT __RPC_FAR *pClipRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorldTransform( 
            const DX2DXFORM __RPC_FAR *pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorldTransform( 
            DX2DXFORM __RPC_FAR *pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPen( 
            const DXPEN __RPC_FAR *pPen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPen( 
            DXPEN __RPC_FAR *pPen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBrush( 
            const DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBrush( 
            DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundBrush( 
            const DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundBrush( 
            DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFont( 
            HFONT hFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFont( 
            HFONT __RPC_FAR *phFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Blt( 
            IUnknown __RPC_FAR *punkSrc,
            const RECT __RPC_FAR *pSrcRect,
            const POINT __RPC_FAR *pDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AAPolyDraw( 
            const DXFPOINT __RPC_FAR *pPos,
            const BYTE __RPC_FAR *pTypes,
            ULONG ulCount,
            ULONG SubSampRes,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AAText( 
            DXFPOINT Pos,
            LPWSTR pString,
            ULONG ulCount,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRadialGradientBrush( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinearGradientBrush( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDX2DVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDX2D __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDX2D __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDX2D __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTransformFactory )( 
            IDX2D __RPC_FAR * This,
            IDXTransformFactory __RPC_FAR *pTransFact);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTransformFactory )( 
            IDX2D __RPC_FAR * This,
            IDXTransformFactory __RPC_FAR *__RPC_FAR *ppTransFact);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSurface )( 
            IDX2D __RPC_FAR * This,
            IUnknown __RPC_FAR *pSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IDX2D __RPC_FAR * This,
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClipRect )( 
            IDX2D __RPC_FAR * This,
            RECT __RPC_FAR *pClipRect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClipRect )( 
            IDX2D __RPC_FAR * This,
            RECT __RPC_FAR *pClipRect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWorldTransform )( 
            IDX2D __RPC_FAR * This,
            const DX2DXFORM __RPC_FAR *pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWorldTransform )( 
            IDX2D __RPC_FAR * This,
            DX2DXFORM __RPC_FAR *pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPen )( 
            IDX2D __RPC_FAR * This,
            const DXPEN __RPC_FAR *pPen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPen )( 
            IDX2D __RPC_FAR * This,
            DXPEN __RPC_FAR *pPen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBrush )( 
            IDX2D __RPC_FAR * This,
            const DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBrush )( 
            IDX2D __RPC_FAR * This,
            DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackgroundBrush )( 
            IDX2D __RPC_FAR * This,
            const DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackgroundBrush )( 
            IDX2D __RPC_FAR * This,
            DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFont )( 
            IDX2D __RPC_FAR * This,
            HFONT hFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFont )( 
            IDX2D __RPC_FAR * This,
            HFONT __RPC_FAR *phFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Blt )( 
            IDX2D __RPC_FAR * This,
            IUnknown __RPC_FAR *punkSrc,
            const RECT __RPC_FAR *pSrcRect,
            const POINT __RPC_FAR *pDest);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AAPolyDraw )( 
            IDX2D __RPC_FAR * This,
            const DXFPOINT __RPC_FAR *pPos,
            const BYTE __RPC_FAR *pTypes,
            ULONG ulCount,
            ULONG SubSampRes,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AAText )( 
            IDX2D __RPC_FAR * This,
            DXFPOINT Pos,
            LPWSTR pString,
            ULONG ulCount,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRadialGradientBrush )( 
            IDX2D __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLinearGradientBrush )( 
            IDX2D __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDX2DVtbl;

    interface IDX2D
    {
        CONST_VTBL struct IDX2DVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDX2D_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDX2D_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDX2D_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDX2D_SetTransformFactory(This,pTransFact)	\
    (This)->lpVtbl -> SetTransformFactory(This,pTransFact)

#define IDX2D_GetTransformFactory(This,ppTransFact)	\
    (This)->lpVtbl -> GetTransformFactory(This,ppTransFact)

#define IDX2D_SetSurface(This,pSurface)	\
    (This)->lpVtbl -> SetSurface(This,pSurface)

#define IDX2D_GetSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,riid,ppSurface)

#define IDX2D_SetClipRect(This,pClipRect)	\
    (This)->lpVtbl -> SetClipRect(This,pClipRect)

#define IDX2D_GetClipRect(This,pClipRect)	\
    (This)->lpVtbl -> GetClipRect(This,pClipRect)

#define IDX2D_SetWorldTransform(This,pXform)	\
    (This)->lpVtbl -> SetWorldTransform(This,pXform)

#define IDX2D_GetWorldTransform(This,pXform)	\
    (This)->lpVtbl -> GetWorldTransform(This,pXform)

#define IDX2D_SetPen(This,pPen)	\
    (This)->lpVtbl -> SetPen(This,pPen)

#define IDX2D_GetPen(This,pPen)	\
    (This)->lpVtbl -> GetPen(This,pPen)

#define IDX2D_SetBrush(This,pBrush)	\
    (This)->lpVtbl -> SetBrush(This,pBrush)

#define IDX2D_GetBrush(This,pBrush)	\
    (This)->lpVtbl -> GetBrush(This,pBrush)

#define IDX2D_SetBackgroundBrush(This,pBrush)	\
    (This)->lpVtbl -> SetBackgroundBrush(This,pBrush)

#define IDX2D_GetBackgroundBrush(This,pBrush)	\
    (This)->lpVtbl -> GetBackgroundBrush(This,pBrush)

#define IDX2D_SetFont(This,hFont)	\
    (This)->lpVtbl -> SetFont(This,hFont)

#define IDX2D_GetFont(This,phFont)	\
    (This)->lpVtbl -> GetFont(This,phFont)

#define IDX2D_Blt(This,punkSrc,pSrcRect,pDest)	\
    (This)->lpVtbl -> Blt(This,punkSrc,pSrcRect,pDest)

#define IDX2D_AAPolyDraw(This,pPos,pTypes,ulCount,SubSampRes,dwFlags)	\
    (This)->lpVtbl -> AAPolyDraw(This,pPos,pTypes,ulCount,SubSampRes,dwFlags)

#define IDX2D_AAText(This,Pos,pString,ulCount,dwFlags)	\
    (This)->lpVtbl -> AAText(This,Pos,pString,ulCount,dwFlags)

#define IDX2D_SetRadialGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetRadialGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#define IDX2D_SetLinearGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetLinearGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDX2D_SetTransformFactory_Proxy( 
    IDX2D __RPC_FAR * This,
    IDXTransformFactory __RPC_FAR *pTransFact);


void __RPC_STUB IDX2D_SetTransformFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetTransformFactory_Proxy( 
    IDX2D __RPC_FAR * This,
    IDXTransformFactory __RPC_FAR *__RPC_FAR *ppTransFact);


void __RPC_STUB IDX2D_GetTransformFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetSurface_Proxy( 
    IDX2D __RPC_FAR * This,
    IUnknown __RPC_FAR *pSurface);


void __RPC_STUB IDX2D_SetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetSurface_Proxy( 
    IDX2D __RPC_FAR * This,
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppSurface);


void __RPC_STUB IDX2D_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetClipRect_Proxy( 
    IDX2D __RPC_FAR * This,
    RECT __RPC_FAR *pClipRect);


void __RPC_STUB IDX2D_SetClipRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetClipRect_Proxy( 
    IDX2D __RPC_FAR * This,
    RECT __RPC_FAR *pClipRect);


void __RPC_STUB IDX2D_GetClipRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetWorldTransform_Proxy( 
    IDX2D __RPC_FAR * This,
    const DX2DXFORM __RPC_FAR *pXform);


void __RPC_STUB IDX2D_SetWorldTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetWorldTransform_Proxy( 
    IDX2D __RPC_FAR * This,
    DX2DXFORM __RPC_FAR *pXform);


void __RPC_STUB IDX2D_GetWorldTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetPen_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXPEN __RPC_FAR *pPen);


void __RPC_STUB IDX2D_SetPen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetPen_Proxy( 
    IDX2D __RPC_FAR * This,
    DXPEN __RPC_FAR *pPen);


void __RPC_STUB IDX2D_GetPen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_SetBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_GetBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetBackgroundBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_SetBackgroundBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetBackgroundBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_GetBackgroundBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetFont_Proxy( 
    IDX2D __RPC_FAR * This,
    HFONT hFont);


void __RPC_STUB IDX2D_SetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetFont_Proxy( 
    IDX2D __RPC_FAR * This,
    HFONT __RPC_FAR *phFont);


void __RPC_STUB IDX2D_GetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_Blt_Proxy( 
    IDX2D __RPC_FAR * This,
    IUnknown __RPC_FAR *punkSrc,
    const RECT __RPC_FAR *pSrcRect,
    const POINT __RPC_FAR *pDest);


void __RPC_STUB IDX2D_Blt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_AAPolyDraw_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXFPOINT __RPC_FAR *pPos,
    const BYTE __RPC_FAR *pTypes,
    ULONG ulCount,
    ULONG SubSampRes,
    DWORD dwFlags);


void __RPC_STUB IDX2D_AAPolyDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_AAText_Proxy( 
    IDX2D __RPC_FAR * This,
    DXFPOINT Pos,
    LPWSTR pString,
    ULONG ulCount,
    DWORD dwFlags);


void __RPC_STUB IDX2D_AAText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetRadialGradientBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDX2D_SetRadialGradientBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetLinearGradientBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDX2D_SetLinearGradientBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDX2D_INTERFACE_DEFINED__ */


#ifndef __IDXGradient2_INTERFACE_DEFINED__
#define __IDXGradient2_INTERFACE_DEFINED__

/* interface IDXGradient2 */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXGradient2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d0ef2a80-61dc-11d2-b2eb-00a0c936b212")
    IDXGradient2 : public IDXGradient
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRadialGradient( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinearGradient( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGradient2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXGradient2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXGradient2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXGradient2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSize )( 
            IDXGradient2 __RPC_FAR * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGradient )( 
            IDXGradient2 __RPC_FAR * This,
            DXSAMPLE StartColor,
            DXSAMPLE EndColor,
            BOOL bHorizontal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSize )( 
            IDXGradient2 __RPC_FAR * This,
            /* [out] */ SIZE __RPC_FAR *pOutSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRadialGradient )( 
            IDXGradient2 __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLinearGradient )( 
            IDXGradient2 __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDXGradient2Vtbl;

    interface IDXGradient2
    {
        CONST_VTBL struct IDXGradient2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGradient2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXGradient2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXGradient2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXGradient2_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)


#define IDXGradient2_SetGradient(This,StartColor,EndColor,bHorizontal)	\
    (This)->lpVtbl -> SetGradient(This,StartColor,EndColor,bHorizontal)

#define IDXGradient2_GetOutputSize(This,pOutSize)	\
    (This)->lpVtbl -> GetOutputSize(This,pOutSize)


#define IDXGradient2_SetRadialGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetRadialGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#define IDXGradient2_SetLinearGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetLinearGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXGradient2_SetRadialGradient_Proxy( 
    IDXGradient2 __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXGradient2_SetRadialGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXGradient2_SetLinearGradient_Proxy( 
    IDXGradient2 __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXGradient2_SetLinearGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXGradient2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtransp_0282 */
/* [local] */ 

typedef 
enum DXFILTERTYPE
    {	DXFILTER_NEAREST	= 0,
	DXFILTER_BILINEAR	= DXFILTER_NEAREST + 1,
	DXFILTER_CUBIC	= DXFILTER_BILINEAR + 1,
	DXFILTER_BSPLINE	= DXFILTER_CUBIC + 1,
	DXFILTER_NUM_FILTERS	= DXFILTER_BSPLINE + 1
    }	DXFILTERTYPE;



extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0282_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0282_v0_0_s_ifspec;

#ifndef __IDXWarp_INTERFACE_DEFINED__
#define __IDXWarp_INTERFACE_DEFINED__

/* interface IDXWarp */
/* [object][hidden][unique][uuid] */ 


EXTERN_C const IID IID_IDXWarp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B7BCEBE0-6797-11d2-A484-00C04F8EFB69")
    IDXWarp : public IDXTScaleOutput
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFilterType( 
            /* [in] */ DXFILTERTYPE eType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterType( 
            /* [out] */ DXFILTERTYPE __RPC_FAR *peType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMapping( 
            /* [in] */ const DX2DXFORM __RPC_FAR *pXForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMapping( 
            /* [out] */ DX2DXFORM __RPC_FAR *pXForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputSurface( 
            /* [in] */ IDXSurface __RPC_FAR *pSurf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultColor( 
            /* [in] */ DXSAMPLE color) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXWarpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXWarp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXWarp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXWarp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSize )( 
            IDXWarp __RPC_FAR * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFilterType )( 
            IDXWarp __RPC_FAR * This,
            /* [in] */ DXFILTERTYPE eType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFilterType )( 
            IDXWarp __RPC_FAR * This,
            /* [out] */ DXFILTERTYPE __RPC_FAR *peType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMapping )( 
            IDXWarp __RPC_FAR * This,
            /* [in] */ const DX2DXFORM __RPC_FAR *pXForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMapping )( 
            IDXWarp __RPC_FAR * This,
            /* [out] */ DX2DXFORM __RPC_FAR *pXForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInputSurface )( 
            IDXWarp __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pSurf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultColor )( 
            IDXWarp __RPC_FAR * This,
            /* [in] */ DXSAMPLE color);
        
        END_INTERFACE
    } IDXWarpVtbl;

    interface IDXWarp
    {
        CONST_VTBL struct IDXWarpVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXWarp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXWarp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXWarp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXWarp_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)


#define IDXWarp_SetFilterType(This,eType)	\
    (This)->lpVtbl -> SetFilterType(This,eType)

#define IDXWarp_GetFilterType(This,peType)	\
    (This)->lpVtbl -> GetFilterType(This,peType)

#define IDXWarp_SetMapping(This,pXForm)	\
    (This)->lpVtbl -> SetMapping(This,pXForm)

#define IDXWarp_GetMapping(This,pXForm)	\
    (This)->lpVtbl -> GetMapping(This,pXForm)

#define IDXWarp_SetInputSurface(This,pSurf)	\
    (This)->lpVtbl -> SetInputSurface(This,pSurf)

#define IDXWarp_SetDefaultColor(This,color)	\
    (This)->lpVtbl -> SetDefaultColor(This,color)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXWarp_SetFilterType_Proxy( 
    IDXWarp __RPC_FAR * This,
    /* [in] */ DXFILTERTYPE eType);


void __RPC_STUB IDXWarp_SetFilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXWarp_GetFilterType_Proxy( 
    IDXWarp __RPC_FAR * This,
    /* [out] */ DXFILTERTYPE __RPC_FAR *peType);


void __RPC_STUB IDXWarp_GetFilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXWarp_SetMapping_Proxy( 
    IDXWarp __RPC_FAR * This,
    /* [in] */ const DX2DXFORM __RPC_FAR *pXForm);


void __RPC_STUB IDXWarp_SetMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXWarp_GetMapping_Proxy( 
    IDXWarp __RPC_FAR * This,
    /* [out] */ DX2DXFORM __RPC_FAR *pXForm);


void __RPC_STUB IDXWarp_GetMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXWarp_SetInputSurface_Proxy( 
    IDXWarp __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pSurf);


void __RPC_STUB IDXWarp_SetInputSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXWarp_SetDefaultColor_Proxy( 
    IDXWarp __RPC_FAR * This,
    /* [in] */ DXSAMPLE color);


void __RPC_STUB IDXWarp_SetDefaultColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXWarp_INTERFACE_DEFINED__ */


#ifndef __IDXTClipOrigin_INTERFACE_DEFINED__
#define __IDXTClipOrigin_INTERFACE_DEFINED__

/* interface IDXTClipOrigin */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTClipOrigin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE1663D8-0988-4C48-9FD6-DB4450885668")
    IDXTClipOrigin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClipOrigin( 
            DXVEC __RPC_FAR *pvecClipOrigin) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTClipOriginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTClipOrigin __RPC_FAR * This,
