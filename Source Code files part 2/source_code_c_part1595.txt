SC_SETSTATE(pSpxConnFile, 0);
                }
#if 0
                //
                // Make sure that this connection got a local disconnect if it was an SPXI
                // connection earlier, in response to a TDI_DISCONNECT_RELEASE.
                //

                CTEAssert(pSpxConnFile->scf_RefTypes[CFREF_DISCWAITSPX] == 0);
#endif

                SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_LISTENING);
                SPX_LISTEN_SETSTATE(pSpxConnFile, (delayAccept ? SPX_LISTEN_RECDREQ : 0));

                if (!delayAccept)
                {
                        spxConnAcceptCr(
                                        pSpxConnFile,
                                        pSpxAddr,
                                        lockHandleDev,
                                        lockHandle,
                                        lockHandleConn);
                }
                else
                {
                        //      Release the locks.
                        CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
                        CTEFreeLock (&pSpxAddr->sa_Lock, lockHandle);
                        CTEFreeLock (&SpxDevice->dev_Lock, lockHandleDev);

                        //      Complete the listen irp. Note reference is not removed. Done when
                        //      accept is posted.
                        SpxCompleteRequest(pListenReq);
                }
        } else {
        ++SpxDevice->dev_Stat.NoListenFailures;
    }

        //      Deref the address
        SpxAddrDereference (pSpxAddr, AREF_LOOKUP);
        return;
}




VOID
spxConnHandleSessPktFromClient(
    IN  PIPXSPX_HDR         pIpxSpxHdr,
        IN  PIPX_LOCAL_TARGET   pRemoteAddr,
        IN      PSPX_CONN_FILE          pSpxConnFile
        )
/*++

Routine Description:

        Packet received from the client side of the connection.
        Handles:
                Session Negotiate
                Sends Session Setup, when recd, handles SS Ack

        STATE MACHINE:

                                                RR
                                           /  \
                                          /    \ ReceivedAck(SPX1Connection)
                                         /              \
                                        /                \--------> ACTIVE
                               /                     ^
                        Send  /                                  |
                        ACK  /                                   |
                                /                                        |
                           / RecvNeg/NoNeg           |
                          /  SendSS                              |
                        SA--------->SS---------------+
                              ^         |          SSAckRecv
                                  |     |
                              +-----+
                                        RecvNeg

        RR - Received Connect Request
        SA - Sent CR Ack
        SS - Sent Session Setup

        We move from SA to SS when connection is not negotiatiable and we
        immediately send the SS, or when we receive negotiate packet and send the neg
    ack and the session setup.

        Note we could receive a negotiate packet when in SS, as our ack to the
        negotiate could have been dropped. We deal with this.

Arguments:


Return Value:


--*/

{
        PNDIS_PACKET            pSnAckPkt, pSsPkt = NULL;
        PSPX_SEND_RESD          pSendResd, pSsSendResd;
        USHORT                  srcConnId, destConnId, pktLen, seqNum = 0, negSize, ackNum, allocNum;
        CTELockHandle           lockHandleConn, lockHandleAddr, lockHandleDev;
        BOOLEAN                 locksHeld = FALSE;

        GETSHORT2SHORT(&pktLen, &pIpxSpxHdr->hdr_PktLen);
        GETSHORT2SHORT(&destConnId, &pIpxSpxHdr->hdr_DestConnId);
        GETSHORT2SHORT(&seqNum, &pIpxSpxHdr->hdr_SeqNum);
        GETSHORT2SHORT(&ackNum, &pIpxSpxHdr->hdr_AckNum);
        GETSHORT2SHORT(&allocNum, &pIpxSpxHdr->hdr_AllocNum);

        //      We keep and use the remote id in the net format. This maintains the
        //      0x0 and 0xFFFF to be as in the host format.
        srcConnId       = *(USHORT UNALIGNED *)&pIpxSpxHdr->hdr_SrcConnId;

         //     If spx2 we convert neg size field too
        if (pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_SPX2)
        {
                GETSHORT2SHORT(&negSize, &pIpxSpxHdr->hdr_NegSize);
                CTEAssert(negSize > 0);
        }

        //      Grab all three locks
        CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
        CTEGetLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, &lockHandleAddr);
        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
        locksHeld = TRUE;

        DBGPRINT(CONNECT, INFO,
                        ("spxConnHandleSessPktFromClient: %lx\n", pSpxConnFile));

        //      Check substate
        switch (SPX_LISTEN_STATE(pSpxConnFile))
        {
        case SPX_LISTEN_RECDREQ:

                //      Do nothing.
                break;

        case SPX_LISTEN_SETUP:

                //      Is this a setup ack? If so, yippee. Our ack to a negotiate packet
                //      could have been dropped, and so we could also get a negotiate packet
                //      in that case. If that happens, fall through.
                //      Verify Ss Ack
                if (!SPX2_CONN(pSpxConnFile) ||
                        (pktLen != MIN_IPXSPX2_HDRSIZE) ||
                        ((pIpxSpxHdr->hdr_ConnCtrl &
                                (SPX_CC_SYS | SPX_CC_SPX2)) !=
                                        (SPX_CC_SYS | SPX_CC_SPX2))     ||
                        (pIpxSpxHdr->hdr_DataType != 0) ||
                        (srcConnId == 0) ||
                        (srcConnId == 0xFFFF) ||
                        (srcConnId  != pSpxConnFile->scf_RemConnId) ||
                        (destConnId == 0) ||
                        (destConnId == 0xFFFF) ||
                        (destConnId != pSpxConnFile->scf_LocalConnId) ||
                        (seqNum != 0))
                {
                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxConnSysPacket: VerifySSACK Failed Checking SN %lx.%lx\n",
                                                srcConnId, destConnId));

                        //      Fall through to see if this is a neg packet
                        if (!(SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_NEG)))
                        {
                                break;
                        }
                }
                else
                {
                        DBGPRINT(CONNECT, DBG,
                                        ("spxConnHandleSessPktFromClient: Recd SSACK %lx\n",
                                                pSpxConnFile));

                        spxConnCompleteConnect(
                                pSpxConnFile,
                                lockHandleDev,
                                lockHandleAddr,
                                lockHandleConn);

                        locksHeld  = FALSE;
                        break;
                }

        case SPX_LISTEN_SENTACK:

                //      We expect a negotiate packet.
                //      We should have asked for SPX2/NEG to begin with.
                //      Verify Sn
                if (((pSpxConnFile->scf_Flags & (SPX_CONNFILE_SPX2 | SPX_CONNFILE_NEG)) !=
                                                                                (SPX_CONNFILE_SPX2 | SPX_CONNFILE_NEG)) ||
                        ((pIpxSpxHdr->hdr_ConnCtrl &
                                (SPX_CC_ACK | SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2)) !=
                                        (SPX_CC_ACK | SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2))   ||
                        (pIpxSpxHdr->hdr_DataType != 0) ||
                        (srcConnId == 0) ||
                        (srcConnId == 0xFFFF) ||
                        (srcConnId  != pSpxConnFile->scf_RemConnId) ||
                        (destConnId == 0) ||
                        (destConnId == 0xFFFF) ||
                        (destConnId != pSpxConnFile->scf_LocalConnId) ||
                        (seqNum != 0) ||
                        ((negSize < SPX_NEG_MIN) ||
                         (negSize > SPX_NEG_MAX)))
                {
                        DBGPRINT(RECEIVE, ERR,
                                        ("SpxConnSysPacket: VerifySN Failed %lx.%lx\n",
                                                srcConnId, destConnId));

                        break;
                }

                //      Remember max packet size in connection.
                pSpxConnFile->scf_MaxPktSize = negSize;
                CTEAssert(negSize > 0);

                //      Build sn ack, abort if we fail
                SpxPktBuildSnAck(
                        pSpxConnFile,
                        &pSnAckPkt,
                        SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY);

                if (pSnAckPkt == NULL)
                {
                        spxConnAbortConnect(
                                pSpxConnFile,
                                STATUS_INSUFFICIENT_RESOURCES,
                                lockHandleDev,
                                lockHandleAddr,
                                lockHandleConn);

                        locksHeld  = FALSE;
                        break;
                }

                DBGPRINT(CONNECT, DBG,
                                ("spxConnHandleSessPktFromClient: Sending SNACK %lx\n",
                                        pSpxConnFile));

                //      Queue in the packet.
                SpxConnQueueSendPktTail(pSpxConnFile, pSnAckPkt);

                //      The session packet should already be on queue.
                if (!spxConnGetPktByType(
                                pSpxConnFile,
                                SPX_TYPE_SS,
                                FALSE,
                                &pSsPkt))
                {
                        KeBugCheck(0);
                }

                DBGPRINT(CONNECT, DBG,
                                ("spxConnHandleSessPktFromClient: Sending SS %lx\n",
                                        pSpxConnFile));

                pSsSendResd     = (PSPX_SEND_RESD)(pSsPkt->ProtocolReserved);

                //      We need to resend the packet
                if ((pSsSendResd->sr_State & SPX_SENDPKT_IPXOWNS) != 0)
                {
                        //      Try next time.
                        pSsPkt = NULL;
                }
                else
                {
                        //      Set the size to the neg size indicated in connection.
                        //      This could be lower than the size the packet was build
                        //      with originally. But will never be higher.
                        pSsSendResd->sr_State   |= SPX_SENDPKT_IPXOWNS;
                        spxConnSetNegSize(
                                pSsPkt,
                                pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE);
                }

                //      If we are actually LISTEN_SETUP, then send the ss packet also.
                //      We need to start the connect timer to resend the ss pkt.
                if (SPX_LISTEN_STATE(pSpxConnFile) == SPX_LISTEN_SENTACK)
                {
                        if ((pSpxConnFile->scf_CTimerId =
                                        SpxTimerScheduleEvent(
                                                spxConnConnectTimer,
                                                PARAM(CONFIG_CONNECTION_TIMEOUT) * HALFSEC_TO_MS_FACTOR,
                                                pSpxConnFile)) == 0)
                        {
                                spxConnAbortConnect(
                                        pSpxConnFile,
                                        STATUS_INSUFFICIENT_RESOURCES,
                                        lockHandleDev,
                                        lockHandleAddr,
                                        lockHandleConn);

                                locksHeld  = FALSE;
                                break;
                        }

                        //      Reference connection for the timer
                        SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);

                        SPX_LISTEN_SETSTATE(pSpxConnFile, SPX_LISTEN_SETUP);
                        SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER);
                        pSpxConnFile->scf_CRetryCount   = PARAM(CONFIG_CONNECTION_COUNT);
                }
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
                CTEFreeLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
                CTEFreeLock(&SpxDevice->dev_Lock, lockHandleDev);
                locksHeld  = FALSE;

                //      Send ack packet
                pSendResd       = (PSPX_SEND_RESD)(pSnAckPkt->ProtocolReserved);
                SPX_SENDPACKET(pSpxConnFile, pSnAckPkt, pSendResd);

                //      If we have to send the session setup packet, send that too.
                if (pSsPkt != NULL)
                {
                        pSendResd       = (PSPX_SEND_RESD)(pSsPkt->ProtocolReserved);
                        SPX_SENDPACKET(pSpxConnFile, pSsPkt, pSendResd);
                }

                break;

        default:

                //      Ignore
                DBGPRINT(RECEIVE, DBG,
                                ("SpxConnSysPacket: UNKNOWN %lx.%lx\n",
                                        srcConnId, destConnId));

                break;
        }

        if (locksHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
                CTEFreeLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
                CTEFreeLock(&SpxDevice->dev_Lock, lockHandleDev);
        }

        return;
}




VOID
spxConnHandleSessPktFromSrv(
    IN  PIPXSPX_HDR         pIpxSpxHdr,
        IN  PIPX_LOCAL_TARGET   pRemoteAddr,
        IN      PSPX_CONN_FILE          pSpxConnFile
        )
/*++

Routine Description:

        Packet received from the server side of the connection. This will both
        release the lock and dereference the connection as it sees fit.

        STATE MACHINE:

                                                SR--CTimerExpires-->IDLE
                                           /| \
                                          / |  \ ReceivedAck(SPX1Connection)
                                         /      |       \
                                        /       |        \--------> ACTIVE
                        (Neg)  /    |                ^
                        Send  /         |RecvAck                 |
                        SN       /      |NoNeg                   |
                                /               |                                |
                           /            |                                |
                          /             v                                |
                        SN--------->WS---------------+
                          RecvSNAck                RecvSS

        SR - Sent Connect request
        SN - Sent Session Negotiate
        WS - Waiting for session setup packet

Arguments:


Return Value:


--*/
{
        PSPX_SEND_RESD          pSendResd;
        BOOLEAN                         fNeg, fSpx2;
        USHORT                          srcConnId, destConnId,
                                                pktLen, seqNum, negSize = 0, ackNum, allocNum;
        CTELockHandle           lockHandleConn, lockHandleAddr, lockHandleDev;
        BOOLEAN                         cTimerCancelled = FALSE, fAbort = FALSE, locksHeld = FALSE;
        PNDIS_PACKET        pSsAckPkt, pSnPkt, pPkt = NULL;

        //      We should get a CR Ack, or if our substate is sent session neg
        //      we should get a session neg ack, or if we are waiting for session
        //      setup, we should get one of those.

        fSpx2   = (BOOLEAN)(pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_SPX2);
        fNeg    = (BOOLEAN)(fSpx2 && (pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_NEG));

        GETSHORT2SHORT(&pktLen, &pIpxSpxHdr->hdr_PktLen);
        GETSHORT2SHORT(&destConnId, &pIpxSpxHdr->hdr_DestConnId);
        GETSHORT2SHORT(&seqNum, &pIpxSpxHdr->hdr_SeqNum);
        GETSHORT2SHORT(&ackNum, &pIpxSpxHdr->hdr_AckNum);
        GETSHORT2SHORT(&allocNum, &pIpxSpxHdr->hdr_AllocNum);

        //      We keep and use the remote id in the net format. This maintains the
        //      0x0 and 0xFFFF to be as in the host format.
        srcConnId       = *(USHORT UNALIGNED *)&pIpxSpxHdr->hdr_SrcConnId;

        //      If spx2 we convert neg size field too
        if (pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_SPX2)
        {
                GETSHORT2SHORT(&negSize, &pIpxSpxHdr->hdr_NegSize);
                CTEAssert(negSize > 0);
        }

        //      Grab all three locks
        CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
        CTEGetLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, &lockHandleAddr);
        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
        locksHeld = TRUE;

        DBGPRINT(CONNECT, INFO,
                        ("spxConnHandleSessPktFromSrv: %lx\n", pSpxConnFile));

        //      Check substate
        switch (SPX_CONNECT_STATE(pSpxConnFile))
        {
        case SPX_CONNECT_SENTREQ:

                //      Check if this qualifies as the ack.
                //      Verify CR Ack
                if ((pIpxSpxHdr->hdr_DataType != 0)     ||
                        (srcConnId == 0) ||
                        (srcConnId == 0xFFFF) ||
                        (destConnId == 0) ||
                        (destConnId == 0xFFFF) ||
                        (seqNum != 0) ||
                        (ackNum != 0) ||
                        ((pktLen  != MIN_IPXSPX_HDRSIZE) &&
                                ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_SPX2) &&
                                 (pktLen  != MIN_IPXSPX2_HDRSIZE))) ||
                        ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_SPX2) &&
                                ((negSize < SPX_NEG_MIN) ||
                                 (negSize > SPX_NEG_MAX))))
                {
                        DBGPRINT(CONNECT, ERR,
                                        ("spxConnHandleSessPktFromSrv: CRAck Invalid %lx %lx.%lx.%lx\n",
                                                pSpxConnFile,
                                                pktLen, negSize, pIpxSpxHdr->hdr_ConnCtrl));

                        break;
                }

                //      From current spx code base:
                //      Do we need to send an ack to this ack? In case of SPX only?
                //      What if this ack is dropped? We need to send an ack, if in future
                //      we get CONNECT REQ Acks, until we reach active?
                //      * If they want an ack schedule it. The normal case is for this not
                //      * to happen, but some Novell mainframe front ends insist on having
                //      * this. And technically, it is OK for them to do this.

                DBGPRINT(CONNECT, INFO,
                                ("spxConnHandleSessPktFromSrv: Recd CRACK %lx\n", pSpxConnFile));

                //      Grab the remote alloc num/conn id (in net format)
        pSpxConnFile->scf_SendSeqNum    = 0;
                pSpxConnFile->scf_RecvSeqNum    = 0;
                pSpxConnFile->scf_RecdAckNum    = 0;
                pSpxConnFile->scf_RemConnId         = srcConnId;
                pSpxConnFile->scf_RecdAllocNum  = allocNum;

        // If we have been looking for network 0, which means the
        // packets were sent on all NIC IDs, update our local
        // target now that we have received a response.

#if     defined(_PNP_POWER)
                if (pSpxConnFile->scf_LocalTarget.NicHandle.NicId == (USHORT)ITERATIVE_NIC_ID) {
#else
                if (*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0) {
#endif  _PNP_POWER
            pSpxConnFile->scf_LocalTarget = *pRemoteAddr;
                        pSpxConnFile->scf_AckLocalTarget= *pRemoteAddr;
        }

                DBGPRINT(CONNECT, INFO,
                                ("spxConnHandleSessPktFromSrv: %lx CONN L.R %lx.%lx\n",
                                        pSpxConnFile,
                                        pSpxConnFile->scf_LocalConnId,
                                        pSpxConnFile->scf_RemConnId));

                if (!fSpx2 || !fNeg)
                {
                        cTimerCancelled = SpxTimerCancelEvent(
                                                                pSpxConnFile->scf_CTimerId, FALSE);

                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER);

                        if ((pSpxConnFile->scf_WTimerId =
                                        SpxTimerScheduleEvent(
                                                spxConnWatchdogTimer,
                                                PARAM(CONFIG_KEEPALIVE_TIMEOUT) * HALFSEC_TO_MS_FACTOR,
                                                pSpxConnFile)) == 0)
                        {
                                fAbort = TRUE;
                                break;
                        }

                        //      Reference transferred to watchdog timer.
            if (cTimerCancelled)
                        {
                                cTimerCancelled = FALSE;
                        }
                        else
                        {
                                //      Reference connection for the timer
                                SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
                        }

                        SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
                        pSpxConnFile->scf_WRetryCount = PARAM(CONFIG_KEEPALIVE_COUNT);
                }

                //      Set max packet size, assume not spx2 or !neg, so pass in FALSE
                SPX_MAX_PKT_SIZE(pSpxConnFile, FALSE, FALSE, pIpxSpxHdr->hdr_SrcNet);

                DBGPRINT(CONNECT, DBG,
                                ("spxConnHandleSessPSrv: Accept connect req on %lx.%lx.%lx.%lx!\n",
                                        pSpxConnFile, pSpxConnFile->scf_LocalConnId,
                                        pSpxConnFile->scf_RecdAllocNum, pSpxConnFile->scf_MaxPktSize));

                if (!fSpx2)
                {
                        //      Reset spx2 flags.
                        SPX_CONN_RESETFLAG(pSpxConnFile, (SPX_CONNFILE_SPX2     | SPX_CONNFILE_NEG));

                        //      Complete connect request, this free the lock.
                        //      Cancels tdi timer too. Sets all necessary flags.
                        spxConnCompleteConnect(
                                pSpxConnFile,
                                lockHandleDev,
                                lockHandleAddr,
                                lockHandleConn);

                        locksHeld  = FALSE;
                        break;
                }

                if (!fNeg)
                {
                        //      Goto W_SETUP
                        //      Reset all connect related flags, also spx2/neg flags.
                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_NEG);
                        SPX_CONNECT_SETSTATE(pSpxConnFile, SPX_CONNECT_W_SETUP);
                        break;
                }

                //      Reset max packet size. SPX2 and NEG.
                SPX_MAX_PKT_SIZE(pSpxConnFile, TRUE, TRUE, pIpxSpxHdr->hdr_SrcNet);

                CTEAssert(negSize > 0);
                CTEAssert(pSpxConnFile->scf_MaxPktSize > 0);
                pSpxConnFile->scf_MaxPktSize =
                        MIN(negSize, pSpxConnFile->scf_MaxPktSize);

                pSpxConnFile->scf_MaxPktSize = (USHORT)
                        MIN(pSpxConnFile->scf_MaxPktSize, PARAM(CONFIG_MAX_PACKET_SIZE));

                //      For SPX2 with negotiation, we set up sneg packet and move to
                //      SPX_CONNECT_NEG.
                SpxPktBuildSn(
                        pSpxConnFile,
                        &pSnPkt,
                        SPX_SENDPKT_IPXOWNS);

                if (pSnPkt == NULL)
                {
                        fAbort = TRUE;
                        break;
                }

                //      Queue in packet
                SpxConnQueueSendPktTail(pSpxConnFile, pSnPkt);

                DBGPRINT(CONNECT, DBG,
                                ("spxConnHandleSessPktFromSrv: Sending SN %lx\n",
                                        pSpxConnFile));

                //      Reset retry count for connect timer
                pSpxConnFile->scf_CRetryCount   = PARAM(CONFIG_CONNECTION_COUNT);

                //      Change state.
                SPX_CONNECT_SETSTATE(pSpxConnFile, SPX_CONNECT_NEG);

                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
                CTEFreeLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
                CTEFreeLock(&SpxDevice->dev_Lock, lockHandleDev);
                locksHeld = FALSE;

                //      Send the packet
                pSendResd       = (PSPX_SEND_RESD)(pSnPkt->ProtocolReserved);
                SPX_SENDPACKET(pSpxConnFile, pSnPkt, pSendResd);
                break;

        case SPX_CONNECT_NEG:

                //      We expect a session neg ack.
                //      We should have asked for SPX2/NEG to begin with.
                //      Verify SN Ack
                if (((pSpxConnFile->scf_Flags & (SPX_CONNFILE_SPX2 | SPX_CONNFILE_NEG)) !=
                                                                                (SPX_CONNFILE_SPX2 | SPX_CONNFILE_NEG)) ||
                        (pktLen != MIN_IPXSPX2_HDRSIZE) ||
                        ((pIpxSpxHdr->hdr_ConnCtrl &
                                (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2)) !=
                                        (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2))        ||
                        (pIpxSpxHdr->hdr_DataType != 0) ||
                        (srcConnId == 0) ||
                        (srcConnId == 0xFFFF) ||
                        (srcConnId  != pSpxConnFile->scf_RemConnId) ||
                        (destConnId == 0) ||
                        (destConnId == 0xFFFF) ||
                        (destConnId != pSpxConnFile->scf_LocalConnId) ||
                        (seqNum != 0))
                {
                        DBGPRINT(RECEIVE, ERR,
                                        ("SpxConnSysPacket: VerifySNACK Failed %lx.%lx\n",
                                                srcConnId, destConnId));

                        break;
                }

                DBGPRINT(CONNECT, DBG,
                                ("spxConnHandleSessPktFromSrv: Recd SNACK %lx %lx.%lx\n",
                                pSpxConnFile, negSize, pSpxConnFile->scf_MaxPktSize));

                if (negSize > pSpxConnFile->scf_MaxPktSize)
                        negSize = pSpxConnFile->scf_MaxPktSize;

                //      Get the size to use
                if (negSize <= pSpxConnFile->scf_MaxPktSize)
                {
                        pSpxConnFile->scf_MaxPktSize = negSize;
                        if (!spxConnGetPktByType(
                                        pSpxConnFile,
                                        SPX_TYPE_SN,
                                        FALSE,
                                        &pPkt))
                        {
                                KeBugCheck(0);
                        }

                        SpxConnDequeueSendPktLock(pSpxConnFile, pPkt);

                        pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
                        if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) != 0)
                        {
                                //      Set abort flag and reference conn for the pkt.
                                pSendResd->sr_State     |= SPX_SENDPKT_ABORT;
                                SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
                        }
                        else
                        {
                                //      Free the negotiate packet
                                SpxPktSendRelease(pPkt);
                        }

                        CTEAssert(pSpxConnFile->scf_Flags & SPX_CONNFILE_C_TIMER);
                        cTimerCancelled = SpxTimerCancelEvent(
                                                                pSpxConnFile->scf_CTimerId, FALSE);
                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER);

                        //      Start the watchdog timer, if fail, we abort.
                        if ((pSpxConnFile->scf_WTimerId =
                                        SpxTimerScheduleEvent(
                                                spxConnWatchdogTimer,
                                                PARAM(CONFIG_KEEPALIVE_TIMEOUT) * HALFSEC_TO_MS_FACTOR,
                                                pSpxConnFile)) == 0)
                        {
                                //      Complete cr with error.
                                fAbort = TRUE;
                                break;
                        }

                        //      Reference goes to watchdog timer.
            if (cTimerCancelled)
                        {
                                cTimerCancelled = FALSE;
                        }
                        else
                        {
                                //      Reference connection for the timer
                                SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
                        }

                        //      We move to the W_SETUP state.
                        SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
                        pSpxConnFile->scf_WRetryCount   = PARAM(CONFIG_KEEPALIVE_COUNT);

                        SPX_CONNECT_SETSTATE(pSpxConnFile, SPX_CONNECT_W_SETUP);
                }

                break;

        case SPX_CONNECT_W_SETUP:

                //      Does this qualify as a session setup packet?
                //      Verify SS
                if (!SPX2_CONN(pSpxConnFile) ||
                        ((pIpxSpxHdr->hdr_ConnCtrl &
                                (SPX_CC_ACK | SPX_CC_SYS | SPX_CC_SPX2)) !=
                                        (SPX_CC_ACK | SPX_CC_SYS | SPX_CC_SPX2))        ||
                        (pIpxSpxHdr->hdr_DataType != 0) ||
                        (srcConnId == 0) ||
                        (srcConnId == 0xFFFF) ||
                        (srcConnId  != pSpxConnFile->scf_RemConnId) ||
                        (destConnId == 0) ||
                        (destConnId == 0xFFFF) ||
                        (destConnId != pSpxConnFile->scf_LocalConnId) ||
                        (seqNum != 0) ||
                        ((negSize < SPX_NEG_MIN) ||
                         (negSize > SPX_NEG_MAX)))
                {
                        DBGPRINT(RECEIVE, ERR,
                                        ("SpxConnSysPacket: VerifySS Failed %lx.%lx, %lx %lx.%lx\n",
                                                srcConnId, destConnId, negSize,
                                                pIpxSpxHdr->hdr_ConnCtrl,
                                                (SPX_CC_ACK | SPX_CC_SYS | SPX_CC_SPX2)));

                        break;
                }

                DBGPRINT(CONNECT, DBG,
                                ("spxConnHandleSessPktFromSrv: Recd SS %lx\n", pSpxConnFile));

                //      Copy remote address over into connection (socket could change)
                SpxCopyIpxAddr(pIpxSpxHdr, pSpxConnFile->scf_RemAddr);

                //      Remember max packet size in connection.
                pSpxConnFile->scf_MaxPktSize = negSize;

                //      Build ss ack, abort if we fail
                SpxPktBuildSsAck(
                        pSpxConnFile,
                        &pSsAckPkt,
                        SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY | SPX_SENDPKT_ABORT);

                if (pSsAckPkt == NULL)
                {
                        fAbort = TRUE;
                        break;
                }

                DBGPRINT(CONNECT, DBG,
                                ("spxConnHandleSessPktFromSrv: Sending SSACK %lx\n",
                                        pSpxConnFile));

                SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);

                //      We dont queue in the pkt as its already marked as abort.
                //      Queue in the packet.
                //      SpxConnQueueSendPktTail(pSpxConnFile, pSsAckPkt);

                //      Complete connect, this releases lock.
                spxConnCompleteConnect(
                        pSpxConnFile,
                        lockHandleDev,
                        lockHandleAddr,
                        lockHandleConn);

                locksHeld = FALSE;

                //      Send ack packet
                pSendResd       = (PSPX_SEND_RESD)(pSsAckPkt->ProtocolReserved);
                SPX_SENDPACKET(pSpxConnFile, pSsAckPkt, pSendResd);
                break;

        default:

                //      Ignore
                DBGPRINT(RECEIVE, DBG,
                                ("SpxConnSysPacket: UNKNOWN %lx.%lx\n",
                                        srcConnId, destConnId));

                break;
        }

        if (fAbort)
        {
                spxConnAbortConnect(
                        pSpxConnFile,
                        STATUS_INSUFFICIENT_RESOURCES,
                        lockHandleDev,
                        lockHandleAddr,
                        lockHandleConn);

                locksHeld  = FALSE;
        }

        if (locksHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
                CTEFreeLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
                CTEFreeLock(&SpxDevice->dev_Lock, lockHandleDev);
        }

        if (cTimerCancelled)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}




VOID
spxConnAbortConnect(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      NTSTATUS                        Status,
        IN      CTELockHandle           LockHandleDev,
        IN      CTELockHandle           LockHandleAddr,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:

        This routine abort a connection (both client and server side) in the middle
        of a connection establishment.

        !!! Called with connection lock held, releases lock before return !!!

Arguments:


Return Value:


--*/
{
        PSPX_SEND_RESD          pSendResd;
        PNDIS_PACKET            pPkt;
        PREQUEST                        pRequest  = NULL;
        int                             numDerefs = 0;


        DBGPRINT(CONNECT, DBG,
                        ("spxConnAbortConnect: %lx\n", pSpxConnFile));

#if DBG
        if (!SPX_CONN_CONNECTING(pSpxConnFile) && !SPX_CONN_LISTENING(pSpxConnFile))
        {
                KeBugCheck(0);
        }
#endif

    if (Status == STATUS_INSUFFICIENT_RESOURCES) {  // others should be counted elsewhere
        ++SpxDevice->dev_Stat.LocalResourceFailures;
    }

        //      Free up all the packets
        while ((pSendResd   = pSpxConnFile->scf_SendListHead) != NULL)
        {
                pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                pSendResd, NDIS_PACKET, ProtocolReserved);

                SpxConnDequeueSendPktLock(pSpxConnFile, pPkt);
                if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0)
                {
                        //      Free the packet
                        SpxPktSendRelease(pPkt);
                }
                else
                {
                        //      Set abort flag and reference conn for the pkt.
                        pSendResd->sr_State     |= SPX_SENDPKT_ABORT;
                        SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
                }
        }


        //      Cancel all timers
        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_T_TIMER))
        {
                if (SpxTimerCancelEvent(pSpxConnFile->scf_TTimerId, FALSE))
                {
                        numDerefs++;
                }
                SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_T_TIMER);
        }

        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER))
        {
                if (SpxTimerCancelEvent(pSpxConnFile->scf_CTimerId, FALSE))
                {
                        numDerefs++;
                }
                SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER);
        }

        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER))
        {
                if (SpxTimerCancelEvent(pSpxConnFile->scf_WTimerId, FALSE))
                {
                        numDerefs++;
                }
                SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
        }

        //      We could be called from disconnect for an accept in which case there
        //      will be no queued request. But we need to remove the reference if there
        //      is no request (an accept/listen irp) and listen state is on.
        CTEAssert(IsListEmpty(&pSpxConnFile->scf_DiscLinkage));
        if (!IsListEmpty(&pSpxConnFile->scf_ReqLinkage))
        {
                pRequest = LIST_ENTRY_TO_REQUEST(pSpxConnFile->scf_ReqLinkage.Flink);
                RemoveEntryList(REQUEST_LINKAGE(pRequest));
                REQUEST_STATUS(pRequest)                = Status;
                REQUEST_INFORMATION(pRequest)   = 0;

                //      Save req in conn for deref to complete.
                pSpxConnFile->scf_ConnectReq = pRequest;

                numDerefs++;
        }
        else if (SPX_CONN_LISTENING(pSpxConnFile))
        {
                numDerefs++;
        }

        //      Bug #20999
        //      Race condition was an abort came in from timer, but the connect state
        //      was left unchanged. Due to an extra ref on the connection from the
        //      aborted cr, the state remained so, and then the cr ack came in, and
        //      a session neg was built and queued on the connection. Although it should
        //      not have been. And we hit the assert in deref where the connection is
        //      being reinitialized. Since this can be called for both listening and
        //      connecting connections, do the below.
        SPX_LISTEN_SETSTATE(pSpxConnFile, 0);
        if (SPX_CONN_CONNECTING(pSpxConnFile))
        {
                SPX_CONNECT_SETSTATE(pSpxConnFile, 0);
        }

        CTEFreeLock (&pSpxConnFile->scf_Lock, LockHandleConn);
        CTEFreeLock (pSpxConnFile->scf_AddrFile->saf_AddrLock, LockHandleAddr);
        CTEFreeLock (&SpxDevice->dev_Lock, LockHandleDev);

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}



VOID
spxConnCompleteConnect(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      CTELockHandle           LockHandleDev,
        IN      CTELockHandle           LockHandleAddr,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:

        This routine completes a connection (both client and server side)
        !!! Called with connection lock held, releases lock before return !!!

Arguments:


Return Value:


--*/
{
        PREQUEST                        pRequest;
        PSPX_SEND_RESD          pSendResd;
        PNDIS_PACKET            pPkt;
        int                             numDerefs = 0;

        DBGPRINT(CONNECT, INFO,
                        ("spxConnCompleteConnect: %lx\n", pSpxConnFile));

#if DBG
        if (!SPX_CONN_CONNECTING(pSpxConnFile) && !SPX_CONN_LISTENING(pSpxConnFile))
        {
                DBGBRK(FATAL);
        }
#endif

        //      Free up all the packets
        while ((pSendResd = pSpxConnFile->scf_SendListHead) != NULL)
        {
                pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                pSendResd, NDIS_PACKET, ProtocolReserved);

                SpxConnDequeueSendPktLock(pSpxConnFile, pPkt);
                if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0)
                {
                        //      Free the packet
                        SpxPktSendRelease(pPkt);
                }
                else
                {
                        //      Set abort flag and reference conn for the pkt.
                        pSendResd->sr_State     |= SPX_SENDPKT_ABORT;
                        SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
                }
        }


        //      Cancel tdi connect timer if we are connecting.
        switch (SPX_MAIN_STATE(pSpxConnFile))
        {
        case SPX_CONNFILE_CONNECTING:

                if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_T_TIMER))
                {
                        if (SpxTimerCancelEvent(pSpxConnFile->scf_TTimerId, FALSE))
                        {
                                numDerefs++;
                        }
                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_T_TIMER);
                }

                if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER))
                {
                        if (SpxTimerCancelEvent(pSpxConnFile->scf_CTimerId, FALSE))
                        {
                                numDerefs++;
                        }
                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER);
                }

                if (pSpxConnFile->scf_CRetryCount == (LONG)(PARAM(CONFIG_CONNECTION_COUNT))) {
                        ++SpxDevice->dev_Stat.ConnectionsAfterNoRetry;
        } else {
            ++SpxDevice->dev_Stat.ConnectionsAfterRetry;
        }

                //      Reset all connect related flags
                SPX_MAIN_SETSTATE(pSpxConnFile, 0);
                SPX_CONNECT_SETSTATE(pSpxConnFile, 0);
                break;

        case SPX_CONNFILE_LISTENING:

                if (pSpxConnFile->scf_Flags     & SPX_CONNFILE_C_TIMER)
                {
                        if (SpxTimerCancelEvent(pSpxConnFile->scf_CTimerId, FALSE))
                        {
                                numDerefs++;
                        }
                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER);
                }

                SPX_MAIN_SETSTATE(pSpxConnFile, 0);
                SPX_LISTEN_SETSTATE(pSpxConnFile, 0);
                break;

        default:

                KeBugCheck(0);

        }

        SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_ACTIVE);
        SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);
        SPX_RECV_SETSTATE(pSpxConnFile, SPX_RECV_IDLE);

    ++SpxDevice->dev_Stat.OpenConnections;

        //      Initialize timer values
        pSpxConnFile->scf_BaseT1                =
        pSpxConnFile->scf_AveT1                 = PARAM(CONFIG_INITIAL_RETRANSMIT_TIMEOUT);
        pSpxConnFile->scf_DevT1                 = 0;
        pSpxConnFile->scf_RRetryCount   = PARAM(CONFIG_REXMIT_COUNT);

        pRequest = LIST_ENTRY_TO_REQUEST(pSpxConnFile->scf_ReqLinkage.Flink);
        RemoveEntryList(REQUEST_LINKAGE(pRequest));
        REQUEST_STATUS(pRequest)                = STATUS_SUCCESS;
        REQUEST_INFORMATION(pRequest)   = 0;

        //      When we complete the request, we essentially transfer the reference
        //      to the fact that the connection is active. This will be taken away
        //      when a Disconnect happens on the connection and we transition from
        //      ACTIVE to DISCONN.
        //      numDerefs++;

        CTEFreeLock (&pSpxConnFile->scf_Lock, LockHandleConn);
        CTEFreeLock (pSpxConnFile->scf_AddrFile->saf_AddrLock, LockHandleAddr);
        CTEFreeLock (&SpxDevice->dev_Lock, LockHandleDev);

        //      Complete request
        SpxCompleteRequest(pRequest);

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}




BOOLEAN
spxConnAcceptCr(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      PSPX_ADDR                       pSpxAddr,
        IN      CTELockHandle           LockHandleDev,
        IN      CTELockHandle           LockHandleAddr,
        IN      CTELockHandle           LockHandleConn
        )
{
        PNDIS_PACKET    pSsPkt, pCrAckPkt;
        PSPX_SEND_RESD  pSendResd;

        BOOLEAN fNeg    = SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_NEG);
        BOOLEAN fSpx2   = SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_SPX2);

        DBGPRINT(CONNECT, DBG,
                        ("spxConnAcceptCr: %lx.%d.%d\n",
                                pSpxConnFile, fSpx2, fNeg));

        //      Build and queue in packet.
        SpxPktBuildCrAck(
                pSpxConnFile,
                pSpxAddr,
                &pCrAckPkt,
                SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY,
                fNeg,
                fSpx2);

        if ((pCrAckPkt  != NULL) &&
                (pSpxConnFile->scf_LocalConnId != 0))
        {
                //      Queue in the packet.
                SpxConnQueueSendPktTail(pSpxConnFile, pCrAckPkt);
        }
        else
        {
                goto AbortConnect;
        }


        //      Start the timer
        if ((pSpxConnFile->scf_WTimerId =
                        SpxTimerScheduleEvent(
                                spxConnWatchdogTimer,
                                PARAM(CONFIG_KEEPALIVE_TIMEOUT) * HALFSEC_TO_MS_FACTOR,
                                pSpxConnFile)) != 0)
        {
                //      Reference connection for the timer
                SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
                SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
                pSpxConnFile->scf_WRetryCount   = PARAM(CONFIG_KEEPALIVE_COUNT);
        }
        else
        {
                goto AbortConnect;
        }


        //      We start the connect timer for retrying ss which we send out now
        //      if we are not negotiating.
        if (fSpx2)
        {
                //      Build the session setup packet also for spx2.
                SpxPktBuildSs(
                        pSpxConnFile,
                        &pSsPkt,
                        (USHORT)(fNeg ? 0 : SPX_SENDPKT_IPXOWNS));

                if (pSsPkt != NULL)
                {
                        SpxConnQueueSendPktTail(pSpxConnFile, pSsPkt);
                }
                else
                {
                        goto AbortConnect;
                }

                if (!fNeg)
                {
                        if ((pSpxConnFile->scf_CTimerId =
                                        SpxTimerScheduleEvent(
                                                spxConnConnectTimer,
                                                PARAM(CONFIG_CONNECTION_TIMEOUT) * HALFSEC_TO_MS_FACTOR,
                                                pSpxConnFile)) != 0)
                        {
                                SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER);
                                pSpxConnFile->scf_CRetryCount = PARAM(CONFIG_CONNECTION_COUNT);

                                //      Reference connection for the timer
                                SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
                        }
                        else
                        {
                                goto AbortConnect;
                        }
                }
        }

        CTEAssert((fNeg && fSpx2) || (!fSpx2 && !fNeg));

        //      For a SPX connection, we immediately become active. This happens
        //      in the completeConnect routine. !!Dont change it here!!
        if (!fSpx2)
        {
                spxConnCompleteConnect(
                        pSpxConnFile,
                        LockHandleDev,
                        LockHandleAddr,
                        LockHandleConn);
        }
        else
        {
                SPX_LISTEN_SETSTATE(
                        pSpxConnFile, (fNeg ? SPX_LISTEN_SENTACK : SPX_LISTEN_SETUP));

                CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
                CTEFreeLock (&pSpxAddr->sa_Lock, LockHandleAddr);
                CTEFreeLock (&SpxDevice->dev_Lock, LockHandleDev);
        }

        //      Send the CR Ack packet!
        pSendResd       = (PSPX_SEND_RESD)(pCrAckPkt->ProtocolReserved);
        SPX_SENDPACKET(pSpxConnFile, pCrAckPkt, pSendResd);

        if (fSpx2 && !fNeg)
        {
                pSendResd = (PSPX_SEND_RESD)(pSsPkt->ProtocolReserved);
                SPX_SENDPACKET(pSpxConnFile, pSsPkt, pSendResd);
        }

        return(TRUE);


AbortConnect:

        spxConnAbortConnect(
                pSpxConnFile,
                STATUS_INSUFFICIENT_RESOURCES,
                LockHandleDev,
                LockHandleAddr,
                LockHandleConn);

        return (FALSE);
}



BOOLEAN
SpxConnPacketize(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      BOOLEAN                         fNormalState,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:

        The caller needs to set the state to packetize before calling this
        routine. This can be called when SEND state is RENEG also.

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

        fNormalState - If true, it will assume it can release lock to send,
                                   else, it just builds pkts without releasing lock and
                                   releases lock at end. Used after reneg changes size.

Return Value:


--*/
{
        PLIST_ENTRY             p;
        PNDIS_PACKET    pPkt;
        PSPX_SEND_RESD  pSendResd;
        USHORT                  windowSize;
        ULONG                   dataLen;
        USHORT                  sendFlags;
        int                             numDerefs = 0;
        BOOLEAN                 fFirstPass = TRUE, fSuccess = TRUE;
        PREQUEST                pRequest;

#if DBG
        if ((SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_PACKETIZE) &&
        fNormalState)
        {
                DBGBRK(FATAL);
                KeBugCheck(0);
        }
#endif

        //      Build all of the packets.  The firsttime flag is used so
        //      that if we get a 0 byte send, we will send it.  The firsttime
        //      flag will be set and we will build the packet and send it.
        //
        //      FOR SPX1, we cannot trust the remote window size. So we only send
        //      stuff if window size is greater than 0 *AND* we do not have any pending
        //      sends. Dont get in here if we are ABORT. Dont want to be handling any
        //      more requests.
        while((SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_ABORT)  &&
                  ((pRequest = pSpxConnFile->scf_ReqPkt) != NULL)       &&
                  ((pSpxConnFile->scf_ReqPktSize > 0) || fFirstPass))
        {
                fFirstPass      = FALSE;
                windowSize      = pSpxConnFile->scf_RecdAllocNum -
                                                pSpxConnFile->scf_SendSeqNum + 1;

                DBGPRINT(SEND, DBG,
                                ("SpxConnPacketize: WINDOW %lx for %lx\n",
                                        windowSize, pSpxConnFile));


                DBGPRINT(SEND, DBG,
                                ("REMALLOC %lx SENDSEQ %lx\n",
                        pSpxConnFile->scf_RecdAllocNum,
                    pSpxConnFile->scf_SendSeqNum));


                CTEAssert(windowSize >= 0);

                //      Disconnect/Orderly release is not subject to window closure.
                if ((pSpxConnFile->scf_ReqPktType == SPX_REQ_DATA) &&
                        ((windowSize == 0)  ||
                         (!SPX2_CONN(pSpxConnFile) &&
                             (pSpxConnFile->scf_SendSeqListHead != NULL))))
                {
                        break;
                }

                if (pSpxConnFile->scf_ReqPktType == SPX_REQ_DATA)
                {
                        CTEAssert(pRequest == pSpxConnFile->scf_ReqPkt);

                        //      Get data length
                        dataLen = (ULONG)MIN(pSpxConnFile->scf_ReqPktSize,
                                                                 (pSpxConnFile->scf_MaxPktSize -
                                                                  ((SPX2_CONN(pSpxConnFile) ?
                                                                        MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE))));

                        DBGPRINT(SEND, DBG,
                                        ("SpxConnPacketize: %lx Sending %lx Size %lx Req %lx.%lx\n",
                                                pSpxConnFile,
                                                pSpxConnFile->scf_SendSeqNum,
                                                dataLen,
                        pSpxConnFile->scf_ReqPkt,
                                                pSpxConnFile->scf_ReqPktSize));

                        //      Build data packet. Handles 0-length for data. Puts in seq num in
                        //      send resd section of packet also.
                        sendFlags =
                                (USHORT)((fNormalState ? SPX_SENDPKT_IPXOWNS : 0)       |
                                                 SPX_SENDPKT_REQ                                                        |
                                                 SPX_SENDPKT_SEQ                                |
                                                 ((!SPX2_CONN(pSpxConnFile) || (windowSize == 1)) ?
                                                        SPX_SENDPKT_ACKREQ : 0));

                        if (dataLen == pSpxConnFile->scf_ReqPktSize)
                        {
                                //      Last packet of send, ask for a ack.
                                sendFlags |= (SPX_SENDPKT_LASTPKT | SPX_SENDPKT_ACKREQ);
                                if ((pSpxConnFile->scf_ReqPktFlags & TDI_SEND_PARTIAL) == 0)
                                        sendFlags |= SPX_SENDPKT_EOM;
                        }

                        SpxPktBuildData(
                                pSpxConnFile,
                                &pPkt,
                                sendFlags,
                                (USHORT)dataLen);
                }
                else
                {
                        dataLen = 0;

                        DBGPRINT(SEND, DBG,
                                        ("Building DISC packet on %lx ReqPktSize %lx\n",
                                                pSpxConnFile, pSpxConnFile->scf_ReqPktSize));

                        //      Build informed disc/orderly rel packet, associate with request
                        SpxPktBuildDisc(
                                pSpxConnFile,
                                pRequest,
                                &pPkt,
                                (USHORT)((fNormalState ? SPX_SENDPKT_IPXOWNS : 0) | SPX_SENDPKT_REQ |
                                                SPX_SENDPKT_SEQ | SPX_SENDPKT_LASTPKT),
                                (UCHAR)((pSpxConnFile->scf_ReqPktType == SPX_REQ_ORDREL) ?
                                                        SPX2_DT_ORDREL : SPX2_DT_IDISC));
                }

                if (pPkt != NULL)
                {
                        //      If we were waiting to send an ack, we don't have to as we are
                        //      piggybacking it now. Cancel ack timer, get out.
                        if (fNormalState && SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ACKQ))
                        {
                                DBGPRINT(SEND, DBG,
                                                ("SpxConnPacketize: Piggyback happening for %lx.%lx\n",
                                                        pSpxConnFile, pSpxConnFile->scf_RecvSeqNum));

                                //      We are sending data, allow piggybacks to happen.
                                SPX_CONN_RESETFLAG2(pSpxConnFile, SPX_CONNFILE2_IMMED_ACK);

                SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_ACKQ);
                                if (SpxTimerCancelEvent(pSpxConnFile->scf_ATimerId, FALSE))
                                {
                                        numDerefs++;
                                }
                        }

                        if (pSpxConnFile->scf_ReqPktType != SPX_REQ_DATA)
                        {
                                //      For a disconnect set the state
                                if (pSpxConnFile->scf_ReqPktType == SPX_REQ_ORDREL)
                                {
                                        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_ODISC))
                                        {
                                                SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_DISCONN);
                                                SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_SENT_ORDREL);
                                                numDerefs++;
                                        }
                                        else if (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_POST_ORDREL)
                                        {
                                                CTEAssert((SPX_MAIN_STATE(pSpxConnFile) ==
                                                                                                                SPX_CONNFILE_ACTIVE) ||
                                  (SPX_MAIN_STATE(pSpxConnFile) ==
                                                                                                                SPX_CONNFILE_DISCONN));

                                                SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_SENT_ORDREL);
                                        }
                                        else
                                        {
                                                CTEAssert(
                                                        (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_SENT_ORDREL));
                                        }
                                }
                                else
                                {
                                        CTEAssert(SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN);
                                        CTEAssert(SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_POST_IDISC);

                                        //      Note we have send the idisc here.
                                        SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_SENT_IDISC);
                                }
                        }
                }
                else
                {
                        fSuccess = FALSE;
                        break;
                }


                //      Queue in packet, reference request for the packet
                SpxConnQueueSendSeqPktTail(pSpxConnFile, pPkt);
                REQUEST_INFORMATION(pRequest)++;

                pSpxConnFile->scf_ReqPktSize    -= dataLen;
                pSpxConnFile->scf_ReqPktOffset  += dataLen;

                DBGPRINT(SEND, INFO,
                                ("SpxConnPacketize: Req %lx Size after pkt %lx.%lx\n",
                                        pSpxConnFile->scf_ReqPkt, pSpxConnFile->scf_ReqPktSize,
                                        dataLen));

                //      Even if window size if zero, setup next request is current one
                //      is done. We are here only after we have packetized this send req.
                if (pSpxConnFile->scf_ReqPktSize == 0)
                {
                        //      This request has been fully packetized. Either go on to
                        //      next request or we are done packetizing.
                        p = REQUEST_LINKAGE(pRequest);
                        if (p->Flink == &pSpxConnFile->scf_ReqLinkage)
                        {
                                DBGPRINT(SEND, INFO,
                                                ("SpxConnPacketize: Req %lx done, no more\n",
                                                        pRequest));

                                pSpxConnFile->scf_ReqPkt                = NULL;
                                pSpxConnFile->scf_ReqPktSize    = 0;
                                pSpxConnFile->scf_ReqPktOffset  = 0;
                                pRequest = NULL;
                        }
                        else
                        {
                                pRequest = LIST_ENTRY_TO_REQUEST(p->Flink);
                if (REQUEST_MINOR_FUNCTION(pRequest) != TDI_DISCONNECT)
                                {
                                        PTDI_REQUEST_KERNEL_SEND                pParam;

                                        pParam  = (PTDI_REQUEST_KERNEL_SEND)REQUEST_PARAMETERS(pRequest);

                                        DBGPRINT(SEND, DBG,
                                                        ("SpxConnPacketize: Req done, setting next %lx.%lx\n",
                                                                pRequest, pParam->SendLength));

                                        DBGPRINT(SEND, INFO,
                                                        ("-%lx-\n",
                                                                pRequest));

                                        //      Set parameters in connection for another go.
                                        pSpxConnFile->scf_ReqPkt                = pRequest;
                                        pSpxConnFile->scf_ReqPktOffset  = 0;
                                        pSpxConnFile->scf_ReqPktFlags   = pParam->SendFlags;
                                        pSpxConnFile->scf_ReqPktType    = SPX_REQ_DATA;

                                        if ((pSpxConnFile->scf_ReqPktSize = pParam->SendLength) == 0)
                                        {
                                                //      Another zero length send.
                                                fFirstPass = TRUE;
                                        }
                                }
                                else
                                {
                                        PTDI_REQUEST_KERNEL_DISCONNECT  pParam;

                                        pParam  =
                                                (PTDI_REQUEST_KERNEL_DISCONNECT)REQUEST_PARAMETERS(pRequest);

                                        pSpxConnFile->scf_ReqPkt                = pRequest;
                                        pSpxConnFile->scf_ReqPktOffset  = 0;
                                        pSpxConnFile->scf_ReqPktSize    = 0;
                                        fFirstPass                                              = TRUE;
                                        pSpxConnFile->scf_ReqPktType    = SPX_REQ_DISC;
                                        if (pParam->RequestFlags == TDI_DISCONNECT_RELEASE)
                                        {
                                                pSpxConnFile->scf_ReqPktType    = SPX_REQ_ORDREL;
                                        }
                                }
                        }
                }

        if (fNormalState)
                {
                        //      Send the packet if we are not at the reneg state
                        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
                        pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
            ++SpxDevice->dev_Stat.DataFramesSent;
            ExInterlockedAddLargeStatistic(
                &SpxDevice->dev_Stat.DataFrameBytesSent,
                dataLen);

                        SPX_SENDPACKET(pSpxConnFile, pPkt, pSendResd);
                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                }

                //      Check if retry timer needs to be started.
                if (!(SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER)))
                {
                        if ((pSpxConnFile->scf_RTimerId =
                                        SpxTimerScheduleEvent(
                                                spxConnRetryTimer,
                                                pSpxConnFile->scf_BaseT1,
                                                pSpxConnFile)) != 0)
                        {
                                SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER);
                                pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);

                                //      Reference connection for the timer
                                SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
                        }
                        else
                        {
                                DBGPRINT(SEND, ERR,
                                                ("SpxConnPacketize: Failed to start retry timer\n"));

                                fSuccess = FALSE;
                                break;
                        }
                }
        }

        //      Dont overwrite an error state.
        if (((fNormalState) &&
                 (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_PACKETIZE)) ||
                ((SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_RETRY3) &&
                 (pSpxConnFile->scf_SendSeqListHead == NULL)))
        {
                if (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_RETRY3)
                {
                        DBGPRINT(SEND, ERR,
                                        ("COULD NOT PACKETIZE AFTER RENEG %lx\n", pSpxConnFile));

                        SpxConnFileTransferReference(
                                pSpxConnFile,
                                CFREF_ERRORSTATE,
                                CFREF_VERIFY);

                        numDerefs++;
                }

                SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);
        }

        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return(fSuccess);
}




VOID
SpxConnQueueRecv(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      PREQUEST                        pRequest
        )
/*++

Routine Description:


Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        PTDI_REQUEST_KERNEL_RECEIVE             pParam;
        NTSTATUS                                                status = STATUS_PENDING;

        if (IsListEmpty(&pSpxConnFile->scf_RecvLinkage))
        {
                pParam  = (PTDI_REQUEST_KERNEL_RECEIVE)REQUEST_PARAMETERS(pRequest);
                pSpxConnFile->scf_CurRecvReq            = pRequest;
                pSpxConnFile->scf_CurRecvOffset         = 0;
                pSpxConnFile->scf_CurRecvSize           = pParam->ReceiveLength;
        }

        DBGPRINT(RECEIVE, DBG,
                        ("spxConnQueueRecv: %lx.%lx\n", pRequest, pParam->ReceiveLength));

        //      Reference connection for this recv.
        SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);

        InsertTailList(
                &pSpxConnFile->scf_RecvLinkage,
                REQUEST_LINKAGE(pRequest));

        //      RECV irps have no creation references.
        REQUEST_INFORMATION(pRequest) = 0;
        REQUEST_STATUS(pRequest)          = STATUS_SUCCESS;

        //      State to receive_posted if we are idle.
        if (SPX_RECV_STATE(pSpxConnFile) == SPX_RECV_IDLE)
        {
                SPX_RECV_SETSTATE(pSpxConnFile, SPX_RECV_POSTED);
        }

        return;
}




VOID
spxConnCompletePended(
        IN      PSPX_CONN_FILE  pSpxConnFile
        )
{
        CTELockHandle           lockHandleInter;
        LIST_ENTRY                      ReqList, *p;
        PREQUEST                        pRequest;

        InitializeListHead(&ReqList);

        DBGPRINT(RECEIVE, DBG,
                        ("spxConnCompletePended: PENDING RECV REQUESTS IN DONE LIST! %lx\n",
                                pSpxConnFile));

        CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
        p = pSpxConnFile->scf_RecvDoneLinkage.Flink;
        while (p != &pSpxConnFile->scf_RecvDoneLinkage)
        {
                pRequest = LIST_ENTRY_TO_REQUEST(p);
                p = p->Flink;

                RemoveEntryList(REQUEST_LINKAGE(pRequest));
                InsertTailList(
                        &ReqList,
                        REQUEST_LINKAGE(pRequest));
        }
        CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);

        while (!IsListEmpty(&ReqList))
        {
                p = RemoveHeadList(&ReqList);
                pRequest = LIST_ENTRY_TO_REQUEST(p);

                DBGPRINT(TDI, DBG,
                                ("SpxConnDiscPkt: PENDING REQ COMP %lx with %lx.%lx\n",
                                        pRequest, REQUEST_STATUS(pRequest),
                                        REQUEST_INFORMATION(pRequest)));


#if DBG
                        if (REQUEST_MINOR_FUNCTION(pRequest) == TDI_RECEIVE)
                        {
                                if ((REQUEST_STATUS(pRequest) == STATUS_SUCCESS) &&
                                        (REQUEST_INFORMATION(pRequest) == 0))
                                {
                                        DBGPRINT(TDI, DBG,
                                                        ("SpxReceiveComplete: Completing %lx with %lx.%lx\n",
                                                                pRequest, REQUEST_STATUS(pRequest),
                                                                REQUEST_INFORMATION(pRequest)));
                                }
                        }
#endif

                SpxCompleteRequest(pRequest);
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}



VOID
SpxConnQWaitAck(
        IN      PSPX_CONN_FILE          pSpxConnFile
        )
/*++

Routine Description:


Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        //      If we are not already in ack queue, queue ourselves in starting
        //      ack timer.
        if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ACKQ))
        {
                //      First start ack timer.
                if ((pSpxConnFile->scf_ATimerId =
                                SpxTimerScheduleEvent(
                                        spxConnAckTimer,
                                        100,
                                        pSpxConnFile)) != 0)
                {
                        //      Reference connection for timer
                        SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
                        SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_ACKQ);
            ++SpxDevice->dev_Stat.PiggybackAckQueued;
                }
        }

        return;
}





VOID
SpxConnSendAck(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:


Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        PSPX_SEND_RESD  pSendResd;
        PNDIS_PACKET    pPkt = NULL;

        DBGPRINT(SEND, DBG,
                        ("spxConnSendAck: ACKING on %lx.%lx\n",
                                pSpxConnFile, pSpxConnFile->scf_RecvSeqNum));

        //      Build an ack packet, queue it in non-sequenced queue. Only if we are
        //      active.
        if (SPX_CONN_ACTIVE(pSpxConnFile))
        {
                SpxPktBuildAck(
                        pSpxConnFile,
                        &pPkt,
                        SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY,
                        FALSE,
                        0);

                if (pPkt != NULL)
                {
                        SpxConnQueueSendPktTail(pSpxConnFile, pPkt);
                }
                else
                {
                        //      Log error
                        DBGPRINT(SEND, ERR,
                                        ("SpxConnSendAck: Could not allocate!\n"));
                }
        }
#if DBG
        else
        {
                DBGPRINT(SEND, DBG,
                                ("SpxConnSendAck: WHEN NOT ACTIVE STATE@!@\n"));
        }
#endif

        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

        //      Send it.
        if (pPkt != NULL)
        {
                pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);

                //      Send the packet
                SPX_SENDACK(pSpxConnFile, pPkt, pSendResd);
        }

        return;
}




VOID
SpxConnSendNack(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      USHORT                          NumToSend,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:


Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        PSPX_SEND_RESD  pSendResd;
        PNDIS_PACKET    pPkt = NULL;

        DBGPRINT(SEND, DBG,
                        ("spxConnSendNack: NACKING on %lx.%lx\n",
                                pSpxConnFile, pSpxConnFile->scf_RecvSeqNum));

        //      Build an nack packet, queue it in non-sequenced queue. Only if we are
        //      active.
        if (SPX_CONN_ACTIVE(pSpxConnFile))
        {
                SpxPktBuildAck(
                        pSpxConnFile,
                        &pPkt,
                        SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY,
                        TRUE,
                        NumToSend);

                if (pPkt != NULL)
                {
                        SpxConnQueueSendPktTail(pSpxConnFile, pPkt);
                }
                else
                {
                        //      Log error
                        DBGPRINT(SEND, ERR,
                                        ("SpxConnSendAck: Could not allocate!\n"));
                }
        }
#if DBG
        else
        {
                DBGPRINT(SEND, DBG,
                                ("SpxConnSendAck: WHEN NOT ACTIVE STATE@!@\n"));
        }
#endif

        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

        //      Send it.
        if (pPkt != NULL)
        {
                pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);

                //      Send the packet
                SPX_SENDACK(pSpxConnFile, pPkt, pSendResd);
        }

        return;
}





BOOLEAN
SpxConnProcessAck(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      PIPXSPX_HDR                     pIpxSpxHdr,
        IN      CTELockHandle           lockHandle
        )
/*++

Routine Description:

        !!!MUST BE CALLED WITH THE CONNECTION LOCK HELD!!!

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        PNDIS_PACKET    pPkt;
        PREQUEST                pRequest;
        PSPX_SEND_RESD  pSendResd;
        CTELockHandle   interLockHandle;
        USHORT                  seqNum = 0, ackNum;
        int                             numDerefs = 0;
        BOOLEAN                 fLastPkt, lockHeld = TRUE, fAbort = FALSE,
                                        fResetRetryTimer, fResendPkt = FALSE, fResetSendQueue = FALSE;
        PNDIS_BUFFER    NdisBuf, NdisBuf2;
        ULONG           BufLen = 0;

        if (pIpxSpxHdr != NULL)
        {
                GETSHORT2SHORT(&seqNum, &pIpxSpxHdr->hdr_SeqNum);
                GETSHORT2SHORT(&ackNum, &pIpxSpxHdr->hdr_AckNum);

                //      Ack numbers should already be set in connection!
                if (SPX2_CONN(pSpxConnFile))
                {
                        switch (SPX_SEND_STATE(pSpxConnFile))
                        {
                        case SPX_SEND_RETRYWD:

                                //      Did we receive an ack for pending data? If so, we goto
                                //      idle and process the ack.
                                if (((pSendResd = pSpxConnFile->scf_SendSeqListHead) != NULL) &&
                                         (UNSIGNED_GREATER_WITH_WRAP(
                                                        pSpxConnFile->scf_RecdAckNum,
                                                        pSendResd->sr_SeqNum)))
                                {
                                        DBGPRINT(SEND, ERR,
                                                        ("SpxConnProcessAck: Data acked RETRYWD %lx.%lx!\n",
                                                                pSpxConnFile, pSendResd->sr_SeqNum));

                                        SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);
                    SpxConnFileTransferReference(
                                                pSpxConnFile,
                        CFREF_ERRORSTATE,
                        CFREF_VERIFY);

                                        numDerefs++;
                                }
                                else
                                {
                                        //      Ok, we received an ack for our probe retry, goto
                                        //      renegotiate packet size.
                                        //      For this both sides must have negotiated size to begin with.
                                        //      If they did not, we go on to retrying the data packet.
                                        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_NEG))
                                        {
                                                pSpxConnFile->scf_RRetryCount = SPX_DEF_RENEG_RETRYCOUNT;
                                                if ((ULONG)pSpxConnFile->scf_MaxPktSize <=
                                                                (SpxMaxPktSize[0] + MIN_IPXSPX2_HDRSIZE))
                                                {
                                                        pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);

                                                        DBGPRINT(SEND, DBG3,
                                                                        ("SpxConnProcessAck: %lx MIN RENEG SIZE\n",
                                                                                pSpxConnFile));
                                                }
                                                SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RENEG);

                                                DBGPRINT(SEND, DBG3,
                                                                ("SpxConnProcessAck: %lx CONNECTION ENTERING RENEG\n",
                                                                        pSpxConnFile));
                                        }
                                        else
                                        {
                                                DBGPRINT(SEND, ERR,
                                                                ("spxConnRetryTimer: NO NEG FLAG SET: %lx - %lx\n",
                                                                        pSpxConnFile,
                                                                        pSpxConnFile->scf_Flags));

                                                //      Reset count to be
                                                pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);
                                                SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RETRY3);
                                        }
                                }

                                break;

                        case SPX_SEND_RENEG:

                                //      We better have a data packet in the list.
                                CTEAssert(pSpxConnFile->scf_SendSeqListHead);

#if DBG
                                if ((pIpxSpxHdr->hdr_ConnCtrl &
                                                (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2)) ==
                        (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2))
                                {
                                        DBGPRINT(SEND, DBG3,
                                                        ("SpxConnProcessAck: %lx.%lx.%lx RENEGACK SEQNUM %lx ACKNUM %lx EXPSEQ %lx\n",
                                                                pSpxConnFile,
                                                                pIpxSpxHdr->hdr_ConnCtrl,
                                SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_RENEG_PKT),
                                                                seqNum,
                                                                ackNum,
                                                                (pSpxConnFile->scf_SendSeqListHead->sr_SeqNum + 1)));
                                }
#endif

                                //      Verify we received an RR ack. If so, we set state to
                                //      SEND_RETRY3. First repacketize if we need to.
                                if ((SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_RENEG_PKT))       &&
                                        ((pIpxSpxHdr->hdr_ConnCtrl &
                                                (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2)) ==
                        (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2)))
                                {
                                        DBGPRINT(SEND, DBG3,
                                                        ("SpxConnProcessAck: RENEG! NEW %lx.%lx!\n",
                                                                pSpxConnFile, pSpxConnFile->scf_MaxPktSize));

                                        //      Dont allow anymore reneg packet acks to be looked at.
                                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_RENEG_PKT);
                                        pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);

                                        //      Also set the new send sequence number.
                                        pSpxConnFile->scf_SendSeqNum =
                                                (USHORT)(pSpxConnFile->scf_SendSeqListTail->sr_SeqNum + 1);

                                        //      Get the max packet size we will really use. Retry timer
                                        //      could have sent other sizes by now, so we can't depend
                                        //      on whats set.
                                        //      Remember max packet size in connection.
                                        GETSHORT2SHORT(
                                                &pSpxConnFile->scf_MaxPktSize, &pIpxSpxHdr->hdr_NegSize);

                                        //      Basic sanity checking on the max packet size.
                                        if (pSpxConnFile->scf_MaxPktSize < SPX_NEG_MIN)
                                                pSpxConnFile->scf_MaxPktSize = SPX_NEG_MIN;

                                        //      Get ready to reset the send queue.
                                        fResetSendQueue = TRUE;

                                        DBGPRINT(SEND, DBG3,
                                                        ("SpxConnProcessAck: RENEG DONE : RETRY3 %lx.%lx MP %lx!\n",
                                                                pSpxConnFile,
                                                                pSpxConnFile->scf_SendSeqNum,
                                                                pSpxConnFile->scf_MaxPktSize));

                                        SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RETRY3);
                                }
                                else
                                {
                                        DBGPRINT(SEND, DBG3,
                                                        ("SpxConnProcessAck: DUPLICATE RENEG ACK %lx!\n",
                                                                pSpxConnFile));
                                }

                                break;

                        case SPX_SEND_RETRY:
                        case SPX_SEND_RETRY2:
                        case SPX_SEND_RETRY3:

                                if (((pSendResd = pSpxConnFile->scf_SendSeqListHead) != NULL) &&
                                         (UNSIGNED_GREATER_WITH_WRAP(
                                                        pSpxConnFile->scf_RecdAckNum,
                                                        pSendResd->sr_SeqNum)))
                                {
                                        DBGPRINT(SEND, DBG,
                                                        ("SpxConnProcessAck: Data acked %lx.%lx!\n",
                                                                pSpxConnFile, SPX_SEND_STATE(pSpxConnFile)));

#if DBG
                                        if (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_RETRY3)
                                        {
                                                DBGPRINT(SEND, DBG3,
                                                                ("SpxConnProcessAck: CONN RESTORED %lx.%lx!\n",
                                                                        pSpxConnFile, pSendResd->sr_SeqNum));
                                        }
#endif

                                        SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);
                    SpxConnFileTransferReference(
                                                pSpxConnFile,
                        CFREF_ERRORSTATE,
                        CFREF_VERIFY);

                                        numDerefs++;
                                }

                                break;

                        case SPX_SEND_WD:

                                //      Ok, we received an ack for our watchdog. Done.
                                SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);
                                numDerefs++;

                                SpxConnFileTransferReference(
                                        pSpxConnFile,
                                        CFREF_ERRORSTATE,
                                        CFREF_VERIFY);

                                break;

                        default:

                                break;
                        }

#if DBG
                        if (seqNum != 0)
                        {
                                //      We have a nack, which contains an implicit ack.
                                //      Instead of nack processing, what we do is we resend a
                                //      packet left unacked after ack processing. ONLY if we
                                //      either enter the loop below (fResetRetryTimer is FALSE)
                                //      or if seqNum is non-zero (SPX2 only NACK)
                        }
#endif
                }
        }

        //      Once our numbers are updated, we check to see if any of our packets
        //      have been acked.
        fResetRetryTimer = TRUE;
        while (((pSendResd = pSpxConnFile->scf_SendSeqListHead) != NULL)        &&
                        ((SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE)                ||
                         (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_PACKETIZE)   ||
                         fResetSendQueue)                                                                                       &&
                         (UNSIGNED_GREATER_WITH_WRAP(
                                pSpxConnFile->scf_RecdAckNum,
                                pSendResd->sr_SeqNum)))
        {
                //      Reset retry timer
                if (fResetRetryTimer)
                {
                        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER))
                        {
                                //      This will either successfully restart or not affect the timer
                                //      if it is currently running.
                                SpxTimerCancelEvent(
                                        pSpxConnFile->scf_RTimerId,
                                        TRUE);

                                pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);
                        }

                        fResetRetryTimer = FALSE;
                }

                //      Update the retry seq num.
                pSpxConnFile->scf_RetrySeqNum = pSendResd->sr_SeqNum;

                pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                pSendResd, NDIS_PACKET, ProtocolReserved);

                pRequest = pSendResd->sr_Request;

#if DBG
                if (fResetSendQueue)
                {
                        DBGPRINT(SEND, ERR,
                                        ("SpxConnProcessAck: Data acked RENEG %lx.%lx!\n",
                                                pSpxConnFile, SPX_SEND_STATE(pSpxConnFile)));
                }
#endif

                DBGPRINT(SEND, DBG,
                                ("%lx Acked\n", pSendResd->sr_SeqNum));

                DBGPRINT(SEND, DBG,
                                ("SpxConnProcessAck: %lx Seq %lx Acked Sr %lx Req %lx %lx.%lx\n",
                                        pSpxConnFile,
                                        pSendResd->sr_SeqNum,
                                        pSendResd,
                                        pRequest, REQUEST_STATUS(pRequest),
                                        REQUEST_INFORMATION(pRequest)));

                //      If this packet is the last one comprising this request, remove request
                //      from queue. Calculate retry time.
                fLastPkt = (BOOLEAN)((pSendResd->sr_State & SPX_SENDPKT_LASTPKT) != 0);
                if ((pSendResd->sr_State & SPX_SENDPKT_ACKREQ) &&
                        ((pSendResd->sr_State & SPX_SENDPKT_REXMIT) == 0) &&
                        ((pSendResd->sr_SeqNum + 1) == pSpxConnFile->scf_RecdAckNum))
                {
                        LARGE_INTEGER   li, ntTime;
                        int                             value;

                        //      This is the packet which is being acked. Adjust round trip
                        //      timer.
                        li = pSendResd->sr_SentTime;
                        if (li.LowPart && li.HighPart)
                        {
                                KeQuerySystemTime(&ntTime);

                                //      Get the difference
                                ntTime.QuadPart = ntTime.QuadPart - li.QuadPart;

                                //      Convert to milliseconds. If the highpart is 0, we
                                //      take a shortcut.
                                if (ntTime.HighPart == 0)
                                {
                                        value   = ntTime.LowPart/10000;
                                }
                                else
                                {
                                        ntTime  = SPX_CONVERT100NSTOCENTISEC(ntTime);
                                        value   = ntTime.LowPart << 4;
                                }

                                                                //
                                // 55280
                                // calculate only if required.
                                //
                                if (0 == PARAM(CONFIG_DISABLE_RTT)) {
                                   //      Set new time
                                   SpxCalculateNewT1(pSpxConnFile, value);
                                }
                        }
                }

                if (fLastPkt)
                {
                        //      Set status
                        REQUEST_STATUS(pRequest) = STATUS_SUCCESS;
                        RemoveEntryList(REQUEST_LINKAGE(pRequest));

                        //      Remove creation reference
                        --(REQUEST_INFORMATION(pRequest));

                        DBGPRINT(SEND, DBG,
                                        ("SpxConnProcessAck: LASTSEQ # %lx for Req %lx with %lx.%lx\n",
                                                pSendResd->sr_SeqNum,
                                                pRequest, REQUEST_STATUS(pRequest),
                                                REQUEST_INFORMATION(pRequest)));

                        CTEAssert(REQUEST_INFORMATION(pRequest) != 0);
                }

                //      Dequeue the packet
                CTEAssert((pSendResd->sr_State & SPX_SENDPKT_SEQ) != 0);
                SpxConnDequeueSendPktLock(pSpxConnFile, pPkt);

                if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0)
                {
                        //      Dereference request for the dequeing of the packet
                        --(REQUEST_INFORMATION(pRequest));

                        DBGPRINT(SEND, DBG,
                                        ("SpxConnProcessAck: Request %lx with %lx.%lx\n",
                                                pRequest, REQUEST_STATUS(pRequest),
                                                REQUEST_INFORMATION(pRequest)));

                        //      Free the packet
                        SpxPktSendRelease(pPkt);
                }
                else
                {
                        //      Packet owned by IPX. What do we do now? Set acked pkt so request
                        //      gets dereferenced in send completion. Note that the packet is already
                        //      off the queue and is floating at this point.

                        DBGPRINT(SEND, DBG,
                                        ("SpxConnProcessAck: IPXOWNS Pkt %lx with %lx.%lx\n",
                                                pPkt, pRequest, REQUEST_STATUS(pRequest)));

                        pSendResd->sr_State |=  SPX_SENDPKT_ACKEDPKT;
                }

                if (SPX2_CONN(pSpxConnFile) &&
                        (REQUEST_MINOR_FUNCTION(pRequest) == TDI_DISCONNECT) &&
                        (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_SENT_ORDREL))
                {
                        SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_ORDREL_ACKED);

                        //      If we had received an ordrel in the meantime, we need
                        //      to disconnect.
                        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_ODISC))
                        {
                                fAbort = TRUE;
                        }
                }

                //      All packets comprising a request have been acked!
                if (REQUEST_INFORMATION(pRequest) == 0)
                {
                        CTELockHandle                           lockHandleInter;

                        if (REQUEST_MINOR_FUNCTION(pRequest) != TDI_DISCONNECT)
                        {
                                PTDI_REQUEST_KERNEL_SEND                pParam;

                                pParam  = (PTDI_REQUEST_KERNEL_SEND)
                                                        REQUEST_PARAMETERS(pRequest);

                                REQUEST_INFORMATION(pRequest) = pParam->SendLength;

                                DBGPRINT(SEND, DBG,
                                                ("SpxSendComplete: QForComp Request %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

                                //      Request is done. Move to completion list.
                                CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
                                InsertTailList(
                                        &pSpxConnFile->scf_ReqDoneLinkage,
                                        REQUEST_LINKAGE(pRequest));

                                //      If connection is not already in recv queue, put it in
                                //      there.
                                SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                        }
                        else
                        {
                                DBGPRINT(SEND, DBG,
                                                ("SpxSendComplete: DISC Request %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

                                //      Set the request in the connection, and deref for it.
                                InsertTailList(
                                        &pSpxConnFile->scf_DiscLinkage,
                                        REQUEST_LINKAGE(pRequest));

                                numDerefs++;

                        }
                }
#if DBG
                else if (fLastPkt)
                {
                        DBGPRINT(RECEIVE, DBG,
                                        ("spxConnProcessAck: ReqFloating %lx.%lx\n",
                                                pSpxConnFile, pRequest));
                }
#endif
        }

        //      See if we reset the send queue and repacketize.
        if (fResetSendQueue)
        {
                //      Reset send queue and repacketize only if pkts left unacked.
                if (pSpxConnFile->scf_SendSeqListHead)
                {
                        DBGPRINT(SEND, DBG3,
                                        ("SpxConnProcessAck: Resetting send queue %lx.%lx!\n",
                                                pSpxConnFile, pSpxConnFile->scf_MaxPktSize));

                        spxConnResetSendQueue(pSpxConnFile);

                        DBGPRINT(SEND, DBG3,
                                        ("SpxConnProcessAck: Repacketizing %lx.%lx!\n",
                                                pSpxConnFile, pSpxConnFile->scf_MaxPktSize));

                        SpxConnPacketize(pSpxConnFile, FALSE, lockHandle);
                        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                }
                else
                {
                        //      We just go back to idle state now.
                        DBGPRINT(SEND, ERR,
                                        ("SpxConnProcessAck: All packets acked reneg ack! %lx.%lx!\n",
                                                pSpxConnFile, pSpxConnFile->scf_MaxPktSize));

                        SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);
                        numDerefs++;

                        SpxConnFileTransferReference(
                                pSpxConnFile,
                                CFREF_ERRORSTATE,
                                CFREF_VERIFY);
                }
        }

        //      See if we resend a packet.
        if ((seqNum != 0)                                                                                               &&
                !fAbort                                                                                                         &&
        ((pSendResd = pSpxConnFile->scf_SendSeqListHead) != NULL)   &&
        (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE)                         &&
                ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0))
        {
                PIPXSPX_HDR             pSendHdr;

                pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                pSendResd, NDIS_PACKET, ProtocolReserved);

                //
                // Get the MDL that points to the IPX/SPX header. (the second one)
                //
         
                NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
                NdisGetNextBuffer(NdisBuf, &NdisBuf2);
                NdisQueryBuffer(NdisBuf2, (PUCHAR) &pSendHdr, &BufLen);

#if OWN_PKT_POOLS
                pSendHdr        = (PIPXSPX_HDR)((PBYTE)pPkt                     +
                                                                        NDIS_PACKET_SIZE                +
                                                                        sizeof(SPX_SEND_RESD)   +
                                                                        IpxInclHdrOffset);
#endif 
                //      Set ack bit in packet. pSendResd initialized at beginning.
                pSendHdr->hdr_ConnCtrl |= SPX_CC_ACK;

                //      We are going to resend this packet
                pSendResd->sr_State |= (SPX_SENDPKT_IPXOWNS |
                                                                SPX_SENDPKT_ACKREQ      |
                                                                SPX_SENDPKT_REXMIT);

                fResendPkt = TRUE;
        }

        //      Push into packetize only if we received an ack. And if there arent any
        //      packets already waiting. Probably retransmit happening.
        if (!fAbort                                                                                                                     &&
                SPX_CONN_ACTIVE(pSpxConnFile)                                                                   &&
                (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE)                                 &&
                (pSpxConnFile->scf_ReqPkt != NULL)                                                              &&
                (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_PKTQ))                               &&
                ((pSpxConnFile->scf_SendSeqListHead) == NULL)                                   &&
                (!SPX2_CONN(pSpxConnFile)                                                                       ||
                 ((SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_ORDREL_ACKED)       &&
                  (SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_SENT_ORDREL))))
        {
                DBGPRINT(RECEIVE, DBG,
                                ("spxConnProcessAck: Recd ack pktizng\n", pSpxConnFile));

                SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_PKTQ);
                SpxConnFileLockReference(pSpxConnFile, CFREF_PKTIZE);

                CTEGetLock(&SpxGlobalQInterlock, &interLockHandle);
                SPX_QUEUE_TAIL_PKTLIST(pSpxConnFile);
                CTEFreeLock(&SpxGlobalQInterlock, interLockHandle);
        }
        else if (fAbort)
        {
                //      Set IDISC flag so Abortive doesnt reindicate.
                SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC);
                spxConnAbortiveDisc(
                        pSpxConnFile,
                        STATUS_SUCCESS,
                        SPX_CALL_RECVLEVEL,
                        lockHandle,
                        FALSE);     // [SA] bug #15249

                lockHeld = FALSE;
        }

        if (lockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
        }

        if (fResendPkt)
        {
                DBGPRINT(SEND, DBG3,
                                ("SpxConnProcessAck: Resend pkt on %lx.%lx\n",
                                        pSpxConnFile, pSendResd->sr_SeqNum));

        ++SpxDevice->dev_Stat.DataFramesResent;
        ExInterlockedAddLargeStatistic(
            &SpxDevice->dev_Stat.DataFrameBytesResent,
            pSendResd->sr_Len - (SPX2_CONN(pSpxConnFile) ? MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE));

                SPX_SENDPACKET(pSpxConnFile, pPkt, pSendResd);
        }

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return(TRUE);
}




VOID
SpxConnProcessRenegReq(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      PIPXSPX_HDR                     pIpxSpxHdr,
        IN  PIPX_LOCAL_TARGET   pRemoteAddr,
        IN      CTELockHandle           lockHandle
        )
/*++

Routine Description:

        !!!MUST BE CALLED WITH THE CONNECTION LOCK HELD!!!

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        USHORT                  seqNum, ackNum, allocNum, maxPktSize;
        PSPX_SEND_RESD  pSendResd;
        PNDIS_PACKET    pPkt = NULL;

        //      The remote sent us a renegotiate request. We need to send an ack back
        //      ONLY if we have not acked a data packet with that same sequence number.
        //      This is guaranteed by the fact that we will not accept the reneg request
        //      if we have already acked a data packet with the same seq num, as our
        //      receive seq number would be incremented already.
        //
        //      Note that if we have pending send packets we may end up doing a reneg
        //      also.

        GETSHORT2SHORT(&seqNum, &pIpxSpxHdr->hdr_SeqNum);
        GETSHORT2SHORT(&ackNum, &pIpxSpxHdr->hdr_AckNum);
        GETSHORT2SHORT(&allocNum, &pIpxSpxHdr->hdr_AllocNum);
        GETSHORT2SHORT(&maxPktSize, &pIpxSpxHdr->hdr_PktLen);

        //      If the received seq num is less than the expected receive sequence number
        //      we ignore this request.
        if (!UNSIGNED_GREATER_WITH_WRAP(
                        seqNum,
                        pSpxConnFile->scf_RecvSeqNum) &&
                (seqNum != pSpxConnFile->scf_RecvSeqNum))
        {
                DBGPRINT(SEND, DBG3,
                                ("SpxConnProcessRenegReq: %lx ERROR RENSEQ %lx RECVSEQ %lx %lx\n",
                                        pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum));

                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
                return;
        }

        DBGPRINT(SEND, DBG3,
                        ("SpxConnProcessRenegReq: %lx RENSEQ %lx RECVSEQ %lx MAXPKT %lx\n",
                                pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum, maxPktSize));

        //      Set ack numbers for connection.
        SPX_SET_ACKNUM(
                pSpxConnFile, ackNum, allocNum);

        SpxCopyIpxAddr(pIpxSpxHdr, pSpxConnFile->scf_RemAckAddr);
        pSpxConnFile->scf_AckLocalTarget        = *pRemoteAddr;

        //      Set RenegAckAckNum before calling buildrrack. If a previous reneg
        //      request was received with a greater maxpktsize, send an ack with
        //      that maxpktsize.
        if (!SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_RENEGRECD))
        {
                pSpxConnFile->scf_RenegAckAckNum = pSpxConnFile->scf_RecvSeqNum;
                pSpxConnFile->scf_RenegMaxPktSize= maxPktSize;
        SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_RENEGRECD);

                DBGPRINT(SEND, DBG3,
                                ("SpxConnProcessRenegReq: %lx SENT ALLOC NUM CURRENT %lx\n",
                                        pSpxConnFile,
                                        pSpxConnFile->scf_SentAllocNum));

                //      Adjust sentallocnum now that recvseqnum might have moved up.
                pSpxConnFile->scf_SentAllocNum   +=
                        (seqNum - pSpxConnFile->scf_RenegAckAckNum);

                DBGPRINT(SEND, DBG3,
                                ("SpxConnProcessRenegReq: %lx SENT ALLOC NUM ADJUSTED %lx\n",
                                        pSpxConnFile,
                                        pSpxConnFile->scf_SentAllocNum));
        }

        //      The recvseqnum for the reneg is always >= the renegackacknum.
    pSpxConnFile->scf_RecvSeqNum         = seqNum;

        DBGPRINT(SEND, DBG3,
                        ("SpxConnProcessRenegReq: %lx RESET RECVSEQ %lx SavedACKACK %lx\n",
                                pSpxConnFile,
                                pSpxConnFile->scf_RecvSeqNum,
                                pSpxConnFile->scf_RenegAckAckNum));

        //      Build and send an ack.
        SpxPktBuildRrAck(
                pSpxConnFile,
                &pPkt,
                SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY,
                pSpxConnFile->scf_RenegMaxPktSize);

        if (pPkt != NULL)
        {
                SpxConnQueueSendPktTail(pSpxConnFile, pPkt);
        }
#if DBG
        else
        {
                //      Log error
                DBGPRINT(SEND, ERR,
                                ("SpxConnSendRenegReqAck: Could not allocate!\n"));
        }
#endif


        //      Check if we are an ack/nack packet in which case call process
        //      ack. Note that the spx2 orderly release ack is a normal spx2 ack.
        SpxConnProcessAck(pSpxConnFile, NULL, lockHandle);

        if (pPkt != NULL)
        {
                pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);

                //      Send the packet
                SPX_SENDACK(pSpxConnFile, pPkt, pSendResd);
        }

        return;
}




VOID
SpxConnProcessOrdRel(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      CTELockHandle           lockHandle
        )
/*++

Routine Description:

        !!!MUST BE CALLED WITH THE CONNECTION LOCK HELD!!!

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        PSPX_SEND_RESD                  pSendResd;
    PVOID                                       pDiscHandlerCtx;
    PTDI_IND_DISCONNECT         pDiscHandler    = NULL;
        int                                             numDerefs               = 0;
        PNDIS_PACKET                    pPkt                    = NULL;
        BOOLEAN                                 lockHeld                = TRUE, fAbort = FALSE;

        if (SPX_CONN_ACTIVE(pSpxConnFile))
        {
                if (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_ORDREL_ACKED)
                {
                        fAbort = TRUE;
                }

                //      Send an ack if one was asked for. And we are done with this pkt
                //      Update seq numbers and stuff.
                SPX_SET_RECVNUM(pSpxConnFile, FALSE);

                //      Build and send an ack for this. Ordinary spx2 ack.
                SpxPktBuildAck(
                        pSpxConnFile,
                        &pPkt,
                        SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY | SPX_SENDPKT_ABORT,
                        FALSE,
                        0);

                if (pPkt != NULL)
                {
                        //      We don't queue this pkt in as we have the ABORT flag set in
                        //      the packet, which implies the pkt is already dequeued.
                        //      SpxConnQueueSendPktTail(pSpxConnFile, pPkt);

                        //      Reference conn for the pkt.
                        SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
                }

                //      Get disconnect handler if we have one. And have not indicated
                //      abortive disconnect on this connection to afd.

                //
                // Bug #14354 - odisc and idisc cross each other, leading to double disc to AFD
                //
                if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_ODISC) &&
                    !SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC))
                {
                        //      Yeah, we set the flag regardless of whether a handler is
                        //      present.
                        pDiscHandler   =pSpxConnFile->scf_AddrFile->saf_DiscHandler;
                        pDiscHandlerCtx=pSpxConnFile->scf_AddrFile->saf_DiscHandlerCtx;
                        SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_IND_ODISC);
                }

                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

                //      Indicate disconnect to afd.
                if (pDiscHandler != NULL)
                {
                        (*pDiscHandler)(
                                pDiscHandlerCtx,
                                pSpxConnFile->scf_ConnCtx,
                                0,                                                              // Disc data
                                NULL,
                                0,                                                              // Disc info
                                NULL,
                                TDI_DISCONNECT_RELEASE);
                }

                //      We abort any receives here if !fAbort else we abort conn.
                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);

                if (fAbort)
                {
                        //      Set IDISC flag so Abortive doesnt reindicate.
                        SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC);
                        spxConnAbortiveDisc(
                                pSpxConnFile,
                                STATUS_SUCCESS,
                                SPX_CALL_RECVLEVEL,
                                lockHandle,
                                FALSE);     // [SA] bug #15249

                        lockHeld = FALSE;
                }
                else
                {
                        //      Go through and kill all pending requests.
                        spxConnAbortRecvs(
                                pSpxConnFile,
                                STATUS_REMOTE_DISCONNECT,
                                SPX_CALL_RECVLEVEL,
                                lockHandle);

                        lockHeld = FALSE;
                }
        }

        if (lockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
        }

        if (pPkt != NULL)
        {
                pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);

                //      Send the packet
                SPX_SENDACK(pSpxConnFile, pPkt, pSendResd);
        }

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}




VOID
SpxConnProcessIDisc(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      CTELockHandle           lockHandle
        )
/*++

Routine Description:

        !!!MUST BE CALLED WITH THE CONNECTION LOCK HELD!!!

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        PSPX_SEND_RESD                  pSendResd;
        PNDIS_PACKET                    pPkt    = NULL;
        PNDIS_BUFFER    NdisBuf, NdisBuf2;
        ULONG           BufLen = 0;

        SPX_SET_RECVNUM(pSpxConnFile, FALSE);

        //      Build and send an ack for the idisc. Need to modify data type
        //      and reset sys bit on ack.
        //      BUG #12344 - Fixing this led to the problem where we queue in
        //      the pkt below, but AbortSends could already have been called
        //      => this packet stays on queue without a ref, conn gets freed
        //      underneath, and in the sendcomplete we crash when this send
        //      completes.
        //
        //      Fix is to setup this pkt as a aborted pkt to start with.

        SpxPktBuildAck(
                pSpxConnFile,
                &pPkt,
                SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY | SPX_SENDPKT_ABORT,
                FALSE,
                0);

        if (pPkt != NULL)
        {
                PIPXSPX_HDR             pSendHdr;

                pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
                
                //
                // Get the MDL that points to the IPX/SPX header. (the second one)
                //
                 
                NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
                NdisGetNextBuffer(NdisBuf, &NdisBuf2);
                NdisQueryBuffer(NdisBuf2, (PUCHAR) &pSendHdr, &BufLen);

#if OWN_PKT_POOLS

                pSendHdr        = (PIPXSPX_HDR)((PBYTE)pPkt                     +
                                                                        NDIS_PACKET_SIZE                +
                                                                        sizeof(SPX_SEND_RESD)   +
                                                                        IpxInclHdrOffset);
#endif 
                pSendHdr->hdr_ConnCtrl &= ~SPX_CC_SYS;
                pSendHdr->hdr_DataType  = SPX2_DT_IDISC_ACK;

                //      We don't queue this pkt in as we have the ABORT flag set in
                //      the packet, which implies the pkt is already dequeued.
                //      SpxConnQueueSendPktTail(pSpxConnFile, pPkt);

                //      Reference conn for the pkt.
                SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
        }

        //      We better not have any received pkts, we ignore disconnect
        //      pkts when that happens.
        CTEAssert(pSpxConnFile->scf_RecvListTail == NULL);
        CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);

#if DBG
        if (pSpxConnFile->scf_SendSeqListHead != NULL)
        {
                DBGPRINT(CONNECT, DBG1,
                                ("SpxConnDiscPacket: DATA/DISC %lx.%lx.%lx\n",
                                        pSpxConnFile,
                                        pSpxConnFile->scf_SendListHead,
                                        pSpxConnFile->scf_SendSeqListHead));
        }
#endif

        //      Call abortive disconnect on connection.

        //
        // [SA] bug #15249
        // This is an informed disconnect, hence pass DISCONNECT_RELEASE to AFD (TRUE in last param)
        //
        //
        // We pass true only in the case of an SPX connection. SPX2 connections follow the
        // exact semantics of Informed Disconnect.
        //
		if (!SPX2_CONN(pSpxConnFile)) {
            spxConnAbortiveDisc(
                    pSpxConnFile,
                    STATUS_REMOTE_DISCONNECT,
                    SPX_CALL_RECVLEVEL,
                    lockHandle,
                    TRUE);
        } else {
            spxConnAbortiveDisc(
                    pSpxConnFile,
                    STATUS_REMOTE_DISCONNECT,
                    SPX_CALL_RECVLEVEL,
                    lockHandle,
                    FALSE);
        }

        if (pPkt != NULL)
        {
                pSendResd       = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);

                //      Send the packet
                SPX_SENDACK(pSpxConnFile, pPkt, pSendResd);
        }

        return;
}




VOID
spxConnResetSendQueue(
        IN      PSPX_CONN_FILE          pSpxConnFile
        )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
        PSPX_SEND_RESD  pSendResd;
        PREQUEST                pRequest;
        PNDIS_PACKET    pPkt;

        pSendResd = pSpxConnFile->scf_SendSeqListHead;
        CTEAssert(pSendResd != NULL);

        pRequest        = pSendResd->sr_Request;

        //      Reset the current send request values
        pSpxConnFile->scf_ReqPkt                = pSendResd->sr_Request;
        pSpxConnFile->scf_ReqPktOffset  = pSendResd->sr_Offset;
        pSpxConnFile->scf_ReqPktType    = SPX_REQ_DATA;

        if (REQUEST_MINOR_FUNCTION(pRequest) != TDI_DISCONNECT)
        {
                PTDI_REQUEST_KERNEL_SEND                pParam;

                pParam  = (PTDI_REQUEST_KERNEL_SEND)REQUEST_PARAMETERS(pRequest);

                DBGPRINT(SEND, DBG3,
                                ("spxConnResetSendQueue: %lx.%lx.%lx Reset SEND Req to %lx.%lx\n",
                                        pSpxConnFile, pSpxConnFile->scf_Flags, pSpxConnFile->scf_Flags2,
                                        pRequest, pParam->SendLength));

                //      Set parameters in connection for another go. Size parameter is
                //      original size - offset at this point.
                pSpxConnFile->scf_ReqPktFlags   = pParam->SendFlags;
                pSpxConnFile->scf_ReqPktSize    = pParam->SendLength -
                                                                                  pSpxConnFile->scf_ReqPktOffset;
        }
        else
        {
                PTDI_REQUEST_KERNEL_DISCONNECT  pParam;

                DBGPRINT(SEND, ERR,
                                ("spxConnResetSendQueue: %lx.%lx.%lx Reset DISC Req to %lx\n",
                                        pSpxConnFile, pSpxConnFile->scf_Flags, pSpxConnFile->scf_Flags2,
                                        pRequest));

                DBGPRINT(SEND, ERR,
                                ("spxConnResetSendQueue: DISC Request %lx with %lx.%lx\n",
                                        pRequest, REQUEST_STATUS(pRequest),
                                        REQUEST_INFORMATION(pRequest)));

                pParam  =
                        (PTDI_REQUEST_KERNEL_DISCONNECT)REQUEST_PARAMETERS(pRequest);

                pSpxConnFile->scf_ReqPktOffset  = 0;
                pSpxConnFile->scf_ReqPktSize    = 0;
                pSpxConnFile->scf_ReqPktType    = SPX_REQ_DISC;
                if (pParam->RequestFlags == TDI_DISCONNECT_RELEASE)
                {
                        pSpxConnFile->scf_ReqPktType    = SPX_REQ_ORDREL;
                }
        }

        DBGPRINT(SEND, DBG3,
                        ("spxConnResetSendQueue: Seq Num for %lx is now %lx\n",
                                pSpxConnFile, pSpxConnFile->scf_SendSeqNum));

        //      When we are trying to abort a pkt and it is in use by ipx, we simply let
        //      it float.
        do
        {
                pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                pSendResd, NDIS_PACKET, ProtocolReserved);

                CTEAssert((pSendResd->sr_State & SPX_SENDPKT_REQ) != 0);
                pRequest        = pSendResd->sr_Request;

                CTEAssert(REQUEST_INFORMATION(pRequest) != 0);

                SpxConnDequeueSendPktLock(pSpxConnFile, pPkt);
                if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0)
                {
                        if (--(REQUEST_INFORMATION(pRequest)) == 0)
                        {
                                DBGPRINT(SEND, DBG,
                                                ("SpxSendComplete: DISC Request %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

                                KeBugCheck(0);
                        }

                        //      Free the packet
                        SpxPktSendRelease(pPkt);
                }
                else
                {
                        //      We let send completion know that this packet is to be aborted.
                        pSendResd->sr_State     |= SPX_SENDPKT_ABORT;
                        SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
                }

        } while ((pSendResd = pSpxConnFile->scf_SendSeqListHead) != NULL);

        return;
}




VOID
spxConnAbortSendPkt(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      PSPX_SEND_RESD          pSendResd,
        IN      SPX_CALL_LEVEL          CallLevel,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:

        Called to abort either a sequenced or a non-sequenced packet ONLY from
        send completion.

Arguments:


Return Value:


--*/
{
        LIST_ENTRY              ReqList, *p;
        PREQUEST                pRequest;
        PNDIS_PACKET    pPkt;
        int                             numDerefs = 0;

        InitializeListHead(&ReqList);

        pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                        pSendResd, NDIS_PACKET, ProtocolReserved);

        if ((pSendResd->sr_State & SPX_SENDPKT_REQ) != 0)
        {
                pRequest        = pSendResd->sr_Request;

                CTEAssert(REQUEST_INFORMATION(pRequest) != 0);
                CTEAssert((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0);
                if (--(REQUEST_INFORMATION(pRequest)) == 0)
                {
                        //      Remove request from list its on
                        //      BUG #11626 - request is already removed from list.
                        //      RemoveEntryList(REQUEST_LINKAGE(pRequest));

                        if (REQUEST_MINOR_FUNCTION(pRequest) != TDI_DISCONNECT)
                        {
                                DBGPRINT(SEND, DBG,
                                                ("SpxSendAbort: QForComp Request %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

                                if (CallLevel == SPX_CALL_RECVLEVEL)
                                {
                                        CTELockHandle           lockHandleInter;

                                        //      Request is done. Move to completion list.
                                        CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
                                        InsertTailList(
                                                &pSpxConnFile->scf_ReqDoneLinkage,
                                                REQUEST_LINKAGE(pRequest));

                                        //      If connection is not already in recv queue, put it in
                                        //      there.
                                        SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                        CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                                }
                                else
                                {
                                        InsertTailList(
                                                &ReqList,
                                                REQUEST_LINKAGE(pRequest));
                                }
                        }
                        else
                        {
                                DBGPRINT(SEND, DBG,
                                                ("SpxSendComplete: DISC Request %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

                                //      Set the request in the connection, and deref for it.
                                InsertTailList(
                                        &pSpxConnFile->scf_DiscLinkage,
                                        REQUEST_LINKAGE(pRequest));

                                numDerefs++;
                        }
                }
        }

        //      Release
        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

        //      Free the packet
        SpxPktSendRelease(pPkt);
        SpxConnFileDereference(pSpxConnFile, CFREF_ABORTPKT);

        if (!IsListEmpty(&ReqList))
        {
                p = RemoveHeadList(&ReqList);
                pRequest = LIST_ENTRY_TO_REQUEST(p);

                SpxCompleteRequest(pRequest);
                numDerefs++;
        }

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}




VOID
spxConnAbortSends(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      NTSTATUS                        Status,
        IN      SPX_CALL_LEVEL          CallLevel,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
        LIST_ENTRY              ReqList, *p;
        PSPX_SEND_RESD  pSendResd;
        PREQUEST                pRequest;
        PNDIS_PACKET    pPkt;
        int                             numDerefs = 0;

        InitializeListHead(&ReqList);

        //      We better be in disconnect state, abortive/informed/orderly initiate.
        CTEAssert(SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN);

        //      Reset the current send request values
        pSpxConnFile->scf_ReqPkt                = NULL;
        pSpxConnFile->scf_ReqPktOffset  = 0;
        pSpxConnFile->scf_ReqPktSize    = 0;
        pSpxConnFile->scf_ReqPktType    = SPX_REQ_DATA;

        //      First go through the non-seq pkt queue.Just set abort flag if owned by ipx
        while ((pSendResd   = pSpxConnFile->scf_SendListHead) != NULL)
        {
                pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                pSendResd, NDIS_PACKET, ProtocolReserved);

                CTEAssert((pSendResd->sr_State & SPX_SENDPKT_REQ) == 0);

                SpxConnDequeueSendPktLock(pSpxConnFile, pPkt);
                if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0)
                {
                        //      Free the packet
                        SpxPktSendRelease(pPkt);
                }
                else
                {
                        //      Set abort flag and reference conn for the pkt if its not already.
                        //      We only do this check for the non-sequenced packets.
                        //      BUG #12344 (see SpxRecvDiscPacket())
                        if ((pSendResd->sr_State & SPX_SENDPKT_ABORT) == 0)
                        {
                                pSendResd->sr_State     |= SPX_SENDPKT_ABORT;
                                SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
                        }
                }
        }

        //      When we are trying to abort a pkt and it is in use by ipx, we simply let
        //      it float.
        while ((pSendResd   = pSpxConnFile->scf_SendSeqListHead) != NULL)
        {
                pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                pSendResd, NDIS_PACKET, ProtocolReserved);

                CTEAssert((pSendResd->sr_State & SPX_SENDPKT_REQ) != 0);
                pRequest        = pSendResd->sr_Request;

                CTEAssert(REQUEST_INFORMATION(pRequest) != 0);

                SpxConnDequeueSendPktLock(pSpxConnFile, pPkt);
                if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0)
                {
                        if (--(REQUEST_INFORMATION(pRequest)) == 0)
                        {
                                //      Remove request from list its on
                                RemoveEntryList(REQUEST_LINKAGE(pRequest));

                                //      Set status
                                REQUEST_STATUS(pRequest)                = Status;
                                REQUEST_INFORMATION(pRequest)   = 0;

                                if (REQUEST_MINOR_FUNCTION(pRequest) != TDI_DISCONNECT)
                                {
                                        DBGPRINT(SEND, DBG,
                                                        ("SpxSendAbort: QForComp Request %lx with %lx.%lx\n",
                                                                pRequest, REQUEST_STATUS(pRequest),
                                                                REQUEST_INFORMATION(pRequest)));

                                        if (CallLevel == SPX_CALL_RECVLEVEL)
                                        {
                                                CTELockHandle           lockHandleInter;

                                                //      Request is done. Move to completion list.
                                                CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
                                                InsertTailList(
                                                        &pSpxConnFile->scf_ReqDoneLinkage,
                                                        REQUEST_LINKAGE(pRequest));

                                                //      If connection is not already in recv queue, put it in
                                                //      there.
                                                SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                                CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                                        }
                                        else
                                        {
                                                InsertTailList(
                                                        &ReqList,
                                                        REQUEST_LINKAGE(pRequest));
                                        }
                                }
                                else
                                {
                                        DBGPRINT(SEND, DBG,
                                                        ("SpxSendComplete: DISC Request %lx with %lx.%lx\n",
                                                                pRequest, REQUEST_STATUS(pRequest),
                                                                REQUEST_INFORMATION(pRequest)));

                                        //      Set the request in the connection, and deref for it.
                                        InsertTailList(
                                                &pSpxConnFile->scf_DiscLinkage,
                                                REQUEST_LINKAGE(pRequest));

                                        numDerefs++;
                                }
                        }

                        //      Free the packet
                        SpxPktSendRelease(pPkt);
                }
                else
                {
                        //      We let send completion know that this packet is to be aborted.
                        pSendResd->sr_State     |= SPX_SENDPKT_ABORT;
                        SpxConnFileLockReference(pSpxConnFile, CFREF_ABORTPKT);
                }
        }

        //      If retry timer state is on, then we need to reset and deref.
        if ((SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_IDLE) &&
                (SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_PACKETIZE) &&
                (SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_WD))
        {
                DBGPRINT(SEND, DBG1,
                                ("spxConnAbortSends: When SEND ERROR STATE %lx.%lx\n",
                                        pSpxConnFile, SPX_SEND_STATE(pSpxConnFile)));

                SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);

                SpxConnFileTransferReference(
                        pSpxConnFile,
                        CFREF_ERRORSTATE,
                        CFREF_VERIFY);

                numDerefs++;
        }

        //      Remove creation references on all sends.
        if (!IsListEmpty(&pSpxConnFile->scf_ReqLinkage))
        {
                p                = pSpxConnFile->scf_ReqLinkage.Flink;
                while (p != &pSpxConnFile->scf_ReqLinkage)
                {
                        pRequest = LIST_ENTRY_TO_REQUEST(p);
                        p                = p->Flink;

                        //      Remove request from list its on. Its complete or abort list for it.
                        RemoveEntryList(REQUEST_LINKAGE(pRequest));

                        //      Set status
                        REQUEST_STATUS(pRequest)                = Status;

                        DBGPRINT(SEND, DBG1,
                                        ("SpxSendAbort: %lx Aborting Send Request %lx with %lx.%lx\n",
                                                pSpxConnFile, pRequest, REQUEST_STATUS(pRequest),
                                                REQUEST_INFORMATION(pRequest)));

                        if (--(REQUEST_INFORMATION(pRequest)) == 0)
                        {
                                if (REQUEST_MINOR_FUNCTION(pRequest) != TDI_DISCONNECT)
                                {
                                        DBGPRINT(SEND, DBG,
                                                        ("SpxSendAbort: QForComp Request %lx with %lx.%lx\n",
                                                                pRequest, REQUEST_STATUS(pRequest),
                                                                REQUEST_INFORMATION(pRequest)));

                                        if (CallLevel == SPX_CALL_RECVLEVEL)
                                        {
                                                CTELockHandle           lockHandleInter;

                                                //      Request is done. Move to completion list.
                                                CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
                                                InsertTailList(
                                                        &pSpxConnFile->scf_ReqDoneLinkage,
                                                        REQUEST_LINKAGE(pRequest));

                                                //      If connection is not already in recv queue, put it in
                                                //      there.
                                                SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                                CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                                         }
                                        else
                                        {
                                                InsertTailList(
                                                        &ReqList,
                                                        REQUEST_LINKAGE(pRequest));
                                        }
                                }
                                else
                                {
                                        DBGPRINT(SEND, DBG1,
                                                        ("SpxSendComplete: DISC Request %lx with %lx.%lx\n",
                                                                pRequest, REQUEST_STATUS(pRequest),
                                                                REQUEST_INFORMATION(pRequest)));

                                        //      Set the request in the connection, and deref for it.
                                        InsertTailList(
                                                &pSpxConnFile->scf_DiscLinkage,
                                                REQUEST_LINKAGE(pRequest));

                                        numDerefs++;
                                }
                        }
#if DBG
                        else
                        {
                                //      Let it float,
                                DBGPRINT(SEND, DBG1,
                                                ("SpxSendAbort: %lx Floating Send %lx with %lx.%lx\n",
                                                        pSpxConnFile, pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));
                        }
#endif
                }
        }

        //      Release
        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
        while (!IsListEmpty(&ReqList))
        {
                p = RemoveHeadList(&ReqList);
                pRequest = LIST_ENTRY_TO_REQUEST(p);

                SpxCompleteRequest(pRequest);
                numDerefs++;
        }

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}




VOID
spxConnAbortRecvs(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      NTSTATUS                        Status,
        IN      SPX_CALL_LEVEL          CallLevel,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
        LIST_ENTRY              ReqList, *p;
        PREQUEST                pRequest;
    PSPX_RECV_RESD      pRecvResd;
        PNDIS_PACKET    pNdisPkt;
        PNDIS_BUFFER    pNdisBuffer;
        PBYTE                   pData;
        ULONG                   dataLen;
        int                             numDerefs = 0;

        InitializeListHead(&ReqList);

        //      We better be in disconnect state, abortive/informed/orderly initiate.
        //      Reset the current receive request values
        pSpxConnFile->scf_CurRecvReq    = NULL;
        pSpxConnFile->scf_CurRecvOffset = 0;
        pSpxConnFile->scf_CurRecvSize   = 0;

        //      If we have any buffered data, abort it.
        //      Buffered data that is 0 bytes long (only eom) may not have a ndis
        //      buffer associated with it.
        while ((pRecvResd = pSpxConnFile->scf_RecvListHead) != NULL)
        {
        if ((pSpxConnFile->scf_RecvListHead = pRecvResd->rr_Next) == NULL)
                {
                        pSpxConnFile->scf_RecvListTail = NULL;
                }

                pNdisPkt = (PNDIS_PACKET)
                                        CONTAINING_RECORD(pRecvResd, NDIS_PACKET, ProtocolReserved);

                DBGPRINT(RECEIVE, DBG1,
                                ("spxConnAbortRecvs: %lx in bufferlist on %lx\n",
                                        pSpxConnFile, pNdisPkt));

                NdisUnchainBufferAtFront(pNdisPkt, &pNdisBuffer);
                if (pNdisBuffer != NULL)
                {
                        NdisQueryBuffer(pNdisBuffer, &pData, &dataLen);
                        CTEAssert(pData != NULL);
                        CTEAssert((LONG)dataLen >= 0);

                        SpxFreeMemory(pData);
                        NdisFreeBuffer(pNdisBuffer);
                }

                //      Packet consumed. Free it up.
                numDerefs++;

                //      Free the ndis packet
                SpxPktRecvRelease(pNdisPkt);
        }

        //      If packets are on this queue, they are waiting for transfer data to
        //      complete. Can't do much about that, just go and remove creation refs
        //      on the receives.
        if (!IsListEmpty(&pSpxConnFile->scf_RecvLinkage))
        {
                p                = pSpxConnFile->scf_RecvLinkage.Flink;
                while (p != &pSpxConnFile->scf_RecvLinkage)
                {
                        pRequest = LIST_ENTRY_TO_REQUEST(p);
                        p                = p->Flink;

                        //      Remove request from list its on
                        RemoveEntryList(REQUEST_LINKAGE(pRequest));

                        //      Set status
                        REQUEST_STATUS(pRequest)                = Status;

                        DBGPRINT(RECEIVE, DBG1,
                                        ("SpxRecvAbort: Aborting Recv Request %lx with %lx.%lx\n",
                                                pRequest, REQUEST_STATUS(pRequest),
                                                REQUEST_INFORMATION(pRequest)));

                        if (REQUEST_INFORMATION(pRequest) == 0)
                        {
                                DBGPRINT(RECEIVE, DBG,
                                                ("SpxRecvAbort: QForComp Request %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

                                if (CallLevel == SPX_CALL_RECVLEVEL)
                                {
                                        CTELockHandle           lockHandleInter;

                                        //      Request is done. Move to completion list.
                                        CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
                                        InsertTailList(
                                                &pSpxConnFile->scf_RecvDoneLinkage,
                                                REQUEST_LINKAGE(pRequest));

                                        //      If connection is not already in recv queue, put it in
                                        //      there.
                                        SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                        CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                                }
                                else
                                {
                                        InsertTailList(
                                                &ReqList,
                                                REQUEST_LINKAGE(pRequest));
                                }
                        }
#if DBG
                        else
                        {
                                //      Let it float,
                                DBGPRINT(SEND, DBG1,
                                                ("SpxSendAbort: %lx Floating Send %lx with %lx.%lx\n",
                                                        pSpxConnFile, pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));
                        }
#endif
                }
        }

        //      Release
        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
        while (!IsListEmpty(&ReqList))
        {
                p = RemoveHeadList(&ReqList);
                pRequest = LIST_ENTRY_TO_REQUEST(p);

                numDerefs++;

                SpxCompleteRequest(pRequest);
        }

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}



#if 0

VOID
spxConnResendPkts(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
        PNDIS_PACKET    pPkt;
        PSPX_SEND_RESD  pSendResd;
        USHORT                  startSeqNum;
        BOOLEAN                 fLockHeld = TRUE, fDone = FALSE;

        pSendResd = pSpxConnFile->scf_SendSeqListHead;
        if (pSendResd)
        {
                startSeqNum = pSendResd->sr_SeqNum;
                DBGPRINT(SEND, DBG,
                                ("spxConnResendPkts: StartSeqNum %lx for resend on %lx\n",
                                        startSeqNum, pSpxConnFile));

                while (spxConnGetPktBySeqNum(pSpxConnFile, startSeqNum++, &pPkt))
                {
                        CTEAssert(pPkt != NULL);

                        pSendResd = (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
                        if (!(pSendResd->sr_State & SPX_SENDPKT_IPXOWNS))
                        {
                                DBGPRINT(SEND, DBG,
                                                ("spxConnResendPkts: Pkt %lx.%lx resent on %lx\n",
                                                        pPkt, (startSeqNum - 1), pSpxConnFile));

                                //      We are going to send this packet
                                pSendResd->sr_State |= (SPX_SENDPKT_IPXOWNS |
                                                                                SPX_SENDPKT_REXMIT);
                        }
                        else
                        {
                                DBGPRINT(SEND, DBG,
                                                ("spxConnResendPkts: Pkt %lx.%lx owned by ipx on %lx\n",
                                                        pPkt, (startSeqNum - 1), pSpxConnFile));
                                break;
                        }
                        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
                        fLockHeld = FALSE;

                        //      If pkt has the ack bit set, we break.
                        fDone = ((pSendResd->sr_State & SPX_SENDPKT_ACKREQ) != 0);

                        //      Send the packet
                        SPX_SENDPACKET(pSpxConnFile, pPkt, pSendResd);
                        if (fDone)
                        {
                                break;
                        }

                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                        fLockHeld = TRUE;
                }
        }

        if (fLockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
        }

        return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxconn.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxconn.h				

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

    Sanjay Anand (SanjayAn) 5-July-1995
    Bug fixes - tagged [SA]

--*/

//	Minimum value for RTT in ms.
//	Have these be a derivate of registry values.
#define	SPX_T1_MIN					200
#define	MAX_RETRY_DELAY				5000	//	5 seconds
#define	SPX_DEF_RENEG_RETRYCOUNT	1		//  All reneg pkts except min sent once

//	Some types
typedef enum
{
	SPX_CALL_RECVLEVEL,
	SPX_CALL_TDILEVEL
} SPX_CALL_LEVEL;

typedef enum
{
	SPX_REQ_DATA,
	SPX_REQ_ORDREL,
	SPX_REQ_DISC

} SPX_SENDREQ_TYPE;

// This structure is pointed to by the FsContext field in the FILE_OBJECT
// for this Connection.

#define CFREF_CREATE     	0
#define CFREF_VERIFY     	1
#define CFREF_INDICATION 	2
#define CFREF_BYCTX			3
#define CFREF_BYID			4
#define CFREF_ADDR			5
#define CFREF_REQ			6
#define CFREF_TIMER			7
#define	CFREF_PKTIZE		8
#define	CFREF_RECV			9
#define	CFREF_ABORTPKT		10
#define	CFREF_ERRORSTATE	11
#define	CFREF_FINDROUTE		12

//
// New state added to reflect an SPXI connection which is waiting for
// a local disconnect after having indicated a RELEASE to AFD.
//
#define	CFREF_DISCWAITSPX   13

#define CFREF_TOTAL  		14

#define CFMAX_STATES        20

typedef struct _SPX_CONN_FILE
{

#if DBG
    ULONG 	scf_RefTypes[CFREF_TOTAL];

#if 0
//
// Disabled for now - to enable logging of states, move this array *after* the Type/Size;
// a change in their offset can cause problems since we assume the offset to be less than
// the size of an AddressFile structure. (see SpxTdiQueryInformation)
//
    ULONG   scf_StateBuffer[CFMAX_STATES];
    ULONG   scf_NextStatePtr;
#endif

#endif

    CSHORT 					scf_Type;
    CSHORT 					scf_Size;

	// number of references to this object.
    ULONG 					scf_RefCount;

    // Linkage in device address file list. The connection can be on the device
	// connection list, address inactive/listen/active list.
    struct _SPX_CONN_FILE *	scf_Next;
	struct _SPX_CONN_FILE * scf_AssocNext;
    struct _SPX_CONN_FILE *	scf_GlobalActiveNext;

	// Queued in a global list, stays here from creation to destroy.
    struct _SPX_CONN_FILE *	scf_GlobalNext;
    struct _SPX_CONN_FILE *	scf_PktNext;
    struct _SPX_CONN_FILE *	scf_ProcessRecvNext;

    // the current state of the connection. One main state and multiple substates.
    ULONG 					scf_Flags;

	//	More information
	ULONG					scf_Flags2;

#if DBG
	//	Save the state of flags/flags2 before reinit. Overwritten every reinit.
	ULONG					scf_GhostFlags;
	ULONG					scf_GhostFlags2;
	ULONG					scf_GhostRefCount;
	PREQUEST				scf_GhostDiscReq;
#endif

	//	Connection retry counts, or watchdog timer count when the connection goes
	//	active
	union
	{
		LONG				scf_CRetryCount;
		LONG				scf_WRetryCount;
	};
	LONG					scf_RRetryCount;
	USHORT					scf_RRetrySeqNum;

	union
	{
		ULONG				scf_CTimerId;
		ULONG				scf_RTimerId;	//	Only after we turn active
	};

	ULONG					scf_WTimerId;		//	Watchdog timer
	ULONG					scf_TTimerId;		//	TDI Connect/Disconnect timer
	ULONG					scf_ATimerId;		//	Ack timer id

	//	Variables used to manage the Retry timer tick value
	//	Note our timer subsytem fires at 100ms granularity.
	int						scf_BaseT1;
	int						scf_AveT1;
	int						scf_DevT1;

	//	Stored in HOST-ORDER
	//	LOCAL variables
	USHORT					scf_LocalConnId;
	USHORT					scf_SendSeqNum;				// Debug dw +9a
	USHORT					scf_SentAllocNum;			// 		 dw +9c

	//	REMOTE variables
	USHORT					scf_RecvSeqNum;				// 		 dw +9e
	USHORT					scf_RecdAckNum;				//		 dw +a0
	USHORT					scf_RecdAllocNum;			// 		 dw +a2

	//	RETRY sequence number
	USHORT					scf_RetrySeqNum;

	//	Saved ack number to be used in building the reneg ack packet.
	//	Note that our RecvSeqNum which we normally use is overwritten
	//	when we receive a renegotiate request.
	USHORT					scf_RenegAckAckNum;

	//	Stored in NETWORK-ORDER. scf_RemAckAddr contains the remote address
	//	for a data packet that had the ack bit set, buildAck will use this
	//	address.
	BYTE			 		scf_RemAddr[12];
	BYTE			 		scf_RemAckAddr[12];
	USHORT                  scf_RemConnId;				// Debug  dw +be

	//	Maximum packet size (or size of first) reneg packet.
	USHORT					scf_RenegMaxPktSize;

	//	Local target to use in when sending acks. This is set to received
	//	data's indicated local target.
	IPX_LOCAL_TARGET		scf_AckLocalTarget;

	//	Maximum packet size to use for this connection
	USHORT					scf_MaxPktSize;
	UCHAR					scf_DataType;

	//	Local target to use in sends, initialized upon connect indication
	//	or when find_route completes
	IPX_LOCAL_TARGET		scf_LocalTarget;

	// Connection lock
    CTELock  				scf_Lock;

    // address to which we are bound
    struct _SPX_ADDR_FILE *	scf_AddrFile;

	// Connection context
	CONNECTION_CONTEXT		scf_ConnCtx;

#ifdef ISN_NT
	// easy backlink to file object.
    PFILE_OBJECT 			scf_FileObject;
#endif

	// LIST_ENTRY of disconnect irps waiting for completion. There could be
	// multiple disconnect inform irps.
	LIST_ENTRY				scf_DiscLinkage;

	// LIST_ENTRY of send requests (intially contains connect/listen/accept also)
	// on this connection.
	LIST_ENTRY				scf_ReqLinkage;

	//	Queue for completed requests awaiting completion
	LIST_ENTRY				scf_ReqDoneLinkage;
	LIST_ENTRY				scf_RecvDoneLinkage;

	//	Queue for pending receives
	LIST_ENTRY				scf_RecvLinkage;
	PREQUEST				scf_CurRecvReq;
	ULONG					scf_CurRecvOffset;
	ULONG					scf_CurRecvSize;

	//	Current request packetize info
	PREQUEST				scf_ReqPkt;
	ULONG					scf_ReqPktOffset;
	ULONG					scf_ReqPktSize;
	ULONG					scf_ReqPktFlags;
	SPX_SENDREQ_TYPE		scf_ReqPktType;

	// Single linked list of sequenced send/disc packets
	PSPX_SEND_RESD 			scf_SendSeqListHead;
	PSPX_SEND_RESD 			scf_SendSeqListTail;

	// Single linked list of send (unsequenced) packets
	PSPX_SEND_RESD			scf_SendListHead;
	PSPX_SEND_RESD			scf_SendListTail;

	// Single linked list of buffered recv packets.
	PSPX_RECV_RESD			scf_RecvListHead;
	PSPX_RECV_RESD			scf_RecvListTail;

	// Connect request
    PREQUEST 				scf_ConnectReq;

    // This holds the request used to close this address file,
    // for pended completion. We also pend cleanup requests for connections.
    PREQUEST 				scf_CleanupReq;
    PREQUEST 				scf_CloseReq;

#if DBG

	//	Packet being indicated, seq num, flags/flags2
	USHORT					scf_PktSeqNum;
	ULONG					scf_PktFlags;
	ULONG					scf_PktFlags2;

	ULONG					scf_IndBytes;
	ULONG					scf_IndLine;
#endif

#if DBG_WDW_CLOSE

	//	Keep track of how long the window was closed on this connection.
	ULONG					scf_WdwCloseAve;
	LARGE_INTEGER			scf_WdwCloseTime;	//	Time when wdw was closed
#endif

	// device to which we are attached.
    struct _DEVICE *		scf_Device;

} SPX_CONN_FILE, *PSPX_CONN_FILE;


//	Basic states
//  Least significant byte of flags is used.
//	Mutually exclusive states are coded as numbers, others are bit flags.
//	Only main states are currently in form of numbers. Also, send and receive.
//
//	Once we go active, we need SEND/RECEIVE/DISC substates to be mutually
//	exclusive with each other. As all three could be active at the same time.

//  Connection MAIN states. These are all mutually exclusive.
#define SPX_CONNFILE_MAINMASK	0x00000007
#define	SPX_CONNFILE_ACTIVE		0x00000001
#define	SPX_CONNFILE_CONNECTING	0x00000002
#define	SPX_CONNFILE_LISTENING	0x00000003
#define SPX_CONNFILE_DISCONN	0x00000004

//  Connecting states (VALID when CONNFILE_CONNECTING)
#define	SPX_CONNECT_MASK		0x000000F0
#define	SPX_CONNECT_SENTREQ		0x00000010
#define	SPX_CONNECT_NEG			0x00000020
#define	SPX_CONNECT_W_SETUP		0x00000030

//  Listening states (VALID when CONNFILE_LISTENING)
#define	SPX_LISTEN_MASK			0x000000F0
#define	SPX_LISTEN_RECDREQ      0x00000010
#define	SPX_LISTEN_SENTACK     	0x00000020
#define	SPX_LISTEN_NEGACK	    0x00000030
#define	SPX_LISTEN_SETUP	    0x00000040

//	Connection SUB states
//	Send machine states	 (VALID when CONNFILE_ACTIVE)
#define	SPX_SEND_MASK			0x000000F0
#define	SPX_SEND_IDLE			0x00000000
#define	SPX_SEND_PACKETIZE		0x00000010
#define	SPX_SEND_RETRY			0x00000020
#define	SPX_SEND_RETRYWD		0x00000030
#define	SPX_SEND_RENEG			0x00000040
#define	SPX_SEND_RETRY2			0x00000050
#define	SPX_SEND_RETRY3			0x00000060
#define	SPX_SEND_WD				0x00000070	//	We dont reneg pkt size on wdog
											//  Also we change to this state only
											//	2nd time wdog fires w/out ack.
#define	SPX_SEND_NAK_RECD		0x00000080

//	Receive machine states (VALID when CONNFILE_ACTIVE)
#define	SPX_RECV_MASK			0x00000F00
#define	SPX_RECV_IDLE			0x00000000
#define	SPX_RECV_POSTED			0x00000100
#define	SPX_RECV_PROCESS_PKTS	0x00000200

//	Disconnect states (VALID when CONNFILE_DISCONN/CONNFILE_ACTIVE)
//	These are valid when either ACTIVE/DISCONN is set. We use these when
//	active for a orderly release, i.e. we receive pkt from remote, but we
//	stay active (setting SPX_DISC_RECV_ORDREL) until our client posts a
//	disconnect, which is when we move to disconnecting.
#define	SPX_DISC_MASK			0x0000F000
#define SPX_DISC_IDLE			0x00000000
#define SPX_DISC_ABORT			0x00001000
#define	SPX_DISC_SENT_IDISC		0x00002000
#define	SPX_DISC_POST_ORDREL    0x00003000
#define	SPX_DISC_SENT_ORDREL    0x00004000
#define	SPX_DISC_ORDREL_ACKED	0x00005000
#define	SPX_DISC_POST_IDISC		0x00006000

// [SA] bug #14655 added flag to indicate that SpxConnInactivate already called for
// this disconnecting connection
//
#define SPX_DISC_INACTIVATED    0x00007000

//	The following are not mutually exclusive.
#define SPX_CONNFILE_RECVQ    	0x00010000	// Process completed receives/pkts
#define SPX_CONNFILE_RENEG_SIZE 0x00020000	// Size changed in renegotiate pkt
#define	SPX_CONNFILE_ACKQ		0x00040000	// Waiting to piggyback ack queue
#define	SPX_CONNFILE_PKTQ		0x00080000	// Waiting to packetize queue

#define	SPX_CONNFILE_ASSOC		0x00100000 	// associated
#define SPX_CONNFILE_NEG		0x00200000	// CR had neg set (for delayed accept)
#define	SPX_CONNFILE_SPX2		0x00400000
#define	SPX_CONNFILE_STREAM		0x00800000
#define	SPX_CONNFILE_R_TIMER	0x01000000	// Retry timer (only after ACTIVE)
#define	SPX_CONNFILE_C_TIMER	0x01000000	// Connect timer
#define SPX_CONNFILE_W_TIMER	0x02000000	// Watchdog timer
#define SPX_CONNFILE_T_TIMER 	0x04000000  // tdi connect/disc timer specified
#define SPX_CONNFILE_RENEG_PKT	0x08000000	// Renegotiate changed size, repacketize
#define	SPX_CONNFILE_IND_IDISC	0x10000000	// Indicated abortive disc to afd
#define	SPX_CONNFILE_IND_ODISC	0x20000000	// Indicated orderly release to afd

#define	SPX_CONNFILE_STOPPING	0x40000000
#define SPX_CONNFILE_CLOSING   	0x80000000  // closing

#define	SPX_CONNFILE2_PKT_NOIND	0x00000001
#define SPX_CONNFILE2_RENEGRECD	0x00000002	// A renegotiate was received.
											// scf_RenegAckAckNum set.
#define	SPX_CONNFILE2_PKT		0x00000004
#define SPX_CONNFILE2_FINDROUTE	0x00000010	// A find route in progress on conn.
#define SPX_CONNFILE2_NOACKWAIT	0x00000020	// Dont delay acks on connection, option
#define	SPX_CONNFILE2_IMMED_ACK	0x00000040	// Send an immediate ack,no back traffic
#define	SPX_CONNFILE2_IPXHDR	0x00000080	// Pass ipxhdr in receives

//
// [SA] Saves the IDisc flag passed to AbortiveDisc; this is TRUE only if there was
// a remote disconnect on an SPX connection (in which case, we indicate TDI_DISCONNECT_RELEASE
// else we indicate TDI_DISCONNECT_ABORT)
//
#define SPX_CONNFILE2_IDISC     0x00000100

//
// Indicates an SPXI connfile waiting for a local disconnect in response
// to a TDI_DISCONNECT_RELEASE to AFD.
//
#define SPX_CONNFILE2_DISC_WAIT     0x00000200

//	FindRoute request structure
typedef struct _SPX_FIND_ROUTE_REQUEST
{
	//	!!!!This must be the first element in the structure
	IPX_FIND_ROUTE_REQUEST	fr_FindRouteReq;
	PVOID					fr_Ctx;

} SPX_FIND_ROUTE_REQUEST, *PSPX_FIND_ROUTE_REQUEST;

typedef struct _SPX_CONNFILE_LIST
{
	PSPX_CONN_FILE	pcl_Head;
	PSPX_CONN_FILE	pcl_Tail;

} SPX_CONNFILE_LIST, *PSPX_CONNFILE_LIST;

//	Exported routines

NTSTATUS
SpxConnOpen(
    IN 	PDEVICE 			pDevice,
	IN	CONNECTION_CONTEXT	pConnCtx,
    IN 	PREQUEST 			pRequest);
	
NTSTATUS
SpxConnCleanup(
    IN PDEVICE 	Device,
    IN PREQUEST Request);

NTSTATUS
SpxConnClose(
    IN PDEVICE 	Device,
    IN PREQUEST Request);

NTSTATUS
SpxConnDisAssociate(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
spxConnDisAssoc(
	IN	PSPX_CONN_FILE	pSpxConnFile,
	IN	CTELockHandle	LockHandleConn);

VOID
SpxConnStop(
	IN	PSPX_CONN_FILE	pSpxConnFile);

NTSTATUS
SpxConnAssociate(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
SpxConnConnect(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
SpxConnListen(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
SpxConnAccept(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
SpxConnAction(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
SpxConnDisconnect(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
SpxConnSend(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

NTSTATUS
SpxConnRecv(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest);

VOID
SpxConnFileRefByCtxLock(
	IN	PSPX_ADDR_FILE		pSpxAddrFile,
	IN	CONNECTION_CONTEXT	Ctx,
	OUT	PSPX_CONN_FILE	*	ppSpxConnFile,
	OUT	NTSTATUS		*	pStatus);

NTSTATUS
SpxConnFileVerify (
    IN PSPX_CONN_FILE pConnFile);

VOID
SpxConnFileDeref(
    IN PSPX_CONN_FILE pSpxConnFile);

VOID
SpxConnConnectFindRouteComplete(
	IN	PSPX_CONN_FILE			pSpxConnFile,
    IN 	PSPX_FIND_ROUTE_REQUEST	pFrReq,
    IN 	BOOLEAN 				FoundRoute,
	IN	CTELockHandle			LockHandle);

VOID
SpxConnActiveFindRouteComplete(
	IN	PSPX_CONN_FILE			pSpxConnFile,
    IN 	PSPX_FIND_ROUTE_REQUEST	pFrReq,
    IN 	BOOLEAN 				FoundRoute,
	IN	CTELockHandle			LockHandle);

BOOLEAN
SpxConnPacketize(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	BOOLEAN				fNormalState,
	IN	CTELockHandle		LockHandleConn);

#if DBG
VOID
SpxConnFileRef(
    IN PSPX_CONN_FILE pSpxConnFile);

VOID
SpxConnFileLockRef(
    IN PSPX_CONN_FILE pSpxConnFile);
#endif

VOID
SpxConnFileRefByIdLock (
	IN	USHORT				ConnId,
    OUT PSPX_CONN_FILE 	* 	ppSpxConnFile,
	OUT	PNTSTATUS  			pStatus);

BOOLEAN
SpxConnDequeuePktLock(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN 	PNDIS_PACKET		pPkt);

VOID
SpxConnSendAck(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	CTELockHandle		LockHandleConn);

VOID
SpxConnSendNack(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	USHORT				NumToSend,
	IN	CTELockHandle		LockHandleConn);

BOOLEAN
SpxConnProcessAck(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	PIPXSPX_HDR			pAckHdr,
	IN	CTELockHandle		lockHandle);

VOID
SpxConnProcessRenegReq(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	PIPXSPX_HDR			pIpxSpxHdr,
	IN  PIPX_LOCAL_TARGET   pRemoteAddr,
	IN	CTELockHandle		lockHandle);

VOID
SpxConnProcessIDisc(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	CTELockHandle		lockHandle);

VOID
SpxConnProcessOrdRel(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	CTELockHandle		lockHandle);

BOOLEAN
SpxConnDequeueRecvPktLock(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN 	PNDIS_PACKET		pPkt);

BOOLEAN
SpxConnDequeueSendPktLock(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN 	PNDIS_PACKET		pPkt);

//	LOCAL functions
VOID
spxConnHandleConnReq(
    IN  PIPXSPX_HDR         pIpxSpxHdr,
	IN  PIPX_LOCAL_TARGET   pRemoteAddr);

VOID
spxConnHandleSessPktFromClient(
    IN  PIPXSPX_HDR         pIpxSpxHdr,
	IN  PIPX_LOCAL_TARGET   pRemoteAddr,
	IN	PSPX_CONN_FILE		pSpxConnFile);

VOID
spxConnHandleSessPktFromSrv(
    IN  PIPXSPX_HDR         pIpxSpxHdr,
	IN  PIPX_LOCAL_TARGET   pRemoteAddr,
	IN	PSPX_CONN_FILE		pSpxConnFile);

ULONG
spxConnConnectTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown);

ULONG
spxConnWatchdogTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown);

ULONG
spxConnRetryTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown);

ULONG
spxConnAckTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown);

VOID
spxConnCompletePended(
	IN	PSPX_CONN_FILE	pSpxConnFile);

VOID
SpxConnQWaitAck(
	IN	PSPX_CONN_FILE		pSpxConnFile);

USHORT
spxConnGetId(
	VOID);

VOID
spxConnInsertIntoActiveList(
	IN	PSPX_ADDR		pSpxAddr,
	IN	PSPX_CONN_FILE	pSpxConnFile);

VOID
spxConnInsertIntoInactiveList(
	IN	PSPX_ADDR		pSpxAddr,
	IN	PSPX_CONN_FILE	pSpxConnFile);

NTSTATUS
spxConnRemoveFromGlobalList(
	IN	PSPX_CONN_FILE	pSpxConnFile);

VOID
spxConnInsertIntoGlobalList(
	IN	PSPX_CONN_FILE	pSpxConnFile);

NTSTATUS
spxConnRemoveFromGlobalActiveList(
	IN	PSPX_CONN_FILE	pSpxConnFile);

VOID
spxConnPushIntoPktList(
	IN	PSPX_CONN_FILE	pSpxConnFile);

VOID
spxConnPopFromPktList(
	IN	PSPX_CONN_FILE	* ppSpxConnFile);

VOID
spxConnPushIntoRecvList(
	IN	PSPX_CONN_FILE	pSpxConnFile);

VOID
spxConnPopFromRecvList(
	IN	PSPX_CONN_FILE	* ppSpxConnFile);

VOID
spxConnInsertIntoGlobalActiveList(
	IN	PSPX_CONN_FILE	pSpxConnFile);

VOID
spxConnInsertIntoListenList(
	IN	PSPX_ADDR		pSpxAddr,
	IN	PSPX_CONN_FILE	pSpxConnFile);

NTSTATUS
spxConnRemoveFromList(
	IN	PSPX_CONN_FILE *	ppConnListHead,
	IN	PSPX_CONN_FILE		pConnRemove);

NTSTATUS
spxConnRemoveFromAssocList(
	IN	PSPX_CONN_FILE *	ppConnListHead,
	IN	PSPX_CONN_FILE		pConnRemove);

VOID
spxConnInactivate(
	IN	PSPX_CONN_FILE		pSpxConnFile);

BOOLEAN
spxConnGetPktByType(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	ULONG				PktType,
	IN	BOOLEAN				fSeqList,
	IN 	PNDIS_PACKET	*	ppPkt);

BOOLEAN
spxConnGetPktBySeqNum(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	USHORT				SeqNum,
	IN 	PNDIS_PACKET	*	ppPkt);

VOID
spxConnResendPkts(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	CTELockHandle		LockHandleConn);

BOOLEAN
spxConnCheckNegSize(
	IN	PUSHORT		pNegSize);

VOID
spxConnSetNegSize(
	IN OUT	PNDIS_PACKET		pPkt,
	IN		ULONG				Size);

BOOLEAN
spxConnAcceptCr(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	PSPX_ADDR			pSpxAddr,
	IN	CTELockHandle		LockHandleDev,
	IN	CTELockHandle		LockHandleAddr,
	IN	CTELockHandle		LockHandleConn);

VOID
spxConnAbortConnect(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	NTSTATUS			Status,
	IN	CTELockHandle		LockHandleDev,
	IN	CTELockHandle		LockHandleAddr,
	IN	CTELockHandle		LockHandleConn);

VOID
spxConnCompleteConnect(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	CTELockHandle		LockHandleDev,
	IN	CTELockHandle		LockHandleAddr,
	IN	CTELockHandle		LockHandleConn);

VOID
SpxConnQueueRecv(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	PREQUEST			pRequest);

NTSTATUS
spxConnProcessRecv(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	PREQUEST			pRequest,
	IN	SPX_CALL_LEVEL		CallLevel,
	IN	CTELockHandle		LockHandleConn);

VOID
spxConnProcessIndData(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	SPX_CALL_LEVEL		CallLevel,
	IN	CTELockHandle		LockHandleConn);

NTSTATUS
spxConnOrderlyDisc(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	NTSTATUS			Status,
    IN 	PREQUEST 			pRequest,
	IN	CTELockHandle		LockHandleConn);

NTSTATUS
spxConnInformedDisc(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	NTSTATUS			Status,
    IN 	PREQUEST 			pRequest,
	IN	CTELockHandle		LockHandleConn);

VOID
spxConnAbortiveDisc(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	NTSTATUS			Status,
	IN	SPX_CALL_LEVEL		CallLevel,
	IN	CTELockHandle		LockHandleConn,
    IN BOOLEAN              Flag); // [SA] Bug #15249

VOID
spxConnAbortRecvs(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	NTSTATUS			Status,
	IN	SPX_CALL_LEVEL		CallLevel,
	IN	CTELockHandle		LockHandleConn);

VOID
spxConnAbortSends(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	NTSTATUS			Status,
	IN	SPX_CALL_LEVEL		CallLevel,
	IN	CTELockHandle		LockHandleConn);

VOID
spxConnResetSendQueue(
	IN	PSPX_CONN_FILE		pSpxConnFile);

VOID
spxConnAbortSendPkt(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	PSPX_SEND_RESD		pSendResd,
	IN	SPX_CALL_LEVEL		CallLevel,
	IN	CTELockHandle		LockHandleConn);

BOOLEAN
CheckSentPacket(
    PNDIS_PACKET npkt,
    UINT        hlen,
    UINT        len);


//
//	MACROS
//
#define SHIFT100000 16

#define	SPX_CONVERT100NSTOCENTISEC(Li)								\
		RtlExtendedMagicDivide((Li), Magic100000, SHIFT100000)

#define	UNSIGNED_BETWEEN_WITH_WRAP(Low, High, Target)				\
		((Low <= High) ? ((Target >= Low) && (Target <= High))	:	\
						 ((Target >= Low) || (Target <= High)))

//	This is with the assumption that the window size will never be greater
//	than the difference of 0x8000 and 0x1000. If High is < 1000 and Low
//	is > 8000 then we can assume a wrap happened. Otherwise, we assume no
//	wrap and do a straight compare.
#define	MAX_WINDOW_SIZE			0x6000
#define	DEFAULT_WINDOW_SIZE		8

#define UNSIGNED_GREATER_WITH_WRAP(High, Low)						\
		(((High < 0x1000) && (Low > 0x8000)) ? TRUE : (High > Low))

#define	SPX_SET_ACKNUM(pSpxConnFile, RecdAckNum, RecdAllocNum)					\
		{																		\
			DBGPRINT(SEND, DBG,													\
					("SPX_SET_ACKNUM: %lx.%lx = %lx.%lx (%s.%d)\n",				\
	                    (RecdAckNum), (RecdAllocNum),							\
                        ((pSpxConnFile)->scf_RecdAckNum),						\
                        ((pSpxConnFile)->scf_RecdAllocNum),						\
						__FILE__, __LINE__));									\
																				\
			if (UNSIGNED_GREATER_WITH_WRAP((RecdAckNum),						\
											((pSpxConnFile)->scf_RecdAckNum)))	\
			{																	\
                (pSpxConnFile)->scf_RecdAckNum = (RecdAckNum);					\
			}																	\
																				\
			if (UNSIGNED_GREATER_WITH_WRAP((RecdAllocNum),						\
											((pSpxConnFile)->scf_RecdAllocNum)))\
			{																	\
                (pSpxConnFile)->scf_RecdAllocNum = (RecdAllocNum);				\
			}																	\
		}

#define	BEGIN_PROCESS_PACKET(pSpxConnFile, seqNum)								\
		{																		\
			SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_PKT);					\
		}																		

#define	END_PROCESS_PACKET(pSpxConnFile, fBuffered, fSuccess)					\
		{																		\
			SPX_CONN_RESETFLAG2(pSpxConnFile,									\
								(SPX_CONNFILE2_PKT |SPX_CONNFILE2_RENEGRECD));	\
			if (fSuccess)														\
			{																	\
				SPX_CONN_RESETFLAG2(pSpxConnFile, SPX_CONNFILE2_PKT_NOIND);		\
				SPX_SET_RECVNUM(pSpxConnFile, fBuffered);						\
			}																	\
		}

#define	INCREMENT_WINDOW(pSpxConnFile)											\
		((pSpxConnFile)->scf_SentAllocNum++)		

#define	ADD_TO_WINDOW(pSpxConnFile, numPkts)									\
		((pSpxConnFile)->scf_SentAllocNum += (numPkts))		

#if DBG_WDW_CLOSE
#define	SPX_SET_RECVNUM(pSpxConnFile, fBuffered)								\
		{																		\
			(pSpxConnFile)->scf_RecvSeqNum++;									\
			if (!fBuffered)														\
				(pSpxConnFile)->scf_SentAllocNum++;								\
																				\
			if (fBuffered &&													\
				(UNSIGNED_GREATER_WITH_WRAP(									\
	                (pSpxConnFile)->scf_RecvSeqNum,								\
                    (pSpxConnFile)->scf_SentAllocNum)))							\
			{																	\
				KeQuerySystemTime(												\
					(PLARGE_INTEGER)&pSpxConnFile->scf_WdwCloseTime);			\
			}																	\
		}
#else
#define	SPX_SET_RECVNUM(pSpxConnFile, fBuffered)								\
		{																		\
			(pSpxConnFile)->scf_RecvSeqNum++;									\
			if (!fBuffered)														\
				(pSpxConnFile)->scf_SentAllocNum++;								\
		}
#endif


#define	SPX_CONN_SETNEXT_CUR_RECV(pSpxConnFile, pRequest)						\
		{																		\
			RemoveEntryList(REQUEST_LINKAGE((pRequest)));						\
			pSpxConnFile->scf_CurRecvReq		= NULL;							\
			pSpxConnFile->scf_CurRecvOffset		= 0;							\
			pSpxConnFile->scf_CurRecvSize		= 0;							\
			if (!IsListEmpty(&(pSpxConnFile)->scf_RecvLinkage))					\
			{																	\
				PTDI_REQUEST_KERNEL_RECEIVE	 	_p;								\
				DBGPRINT(RECEIVE, DBG,											\
						("spxConnProcessRecv: CURRECV %lx\n", pRequest));		\
																				\
				(pSpxConnFile)->scf_CurRecvReq =								\
					LIST_ENTRY_TO_REQUEST(										\
								(pSpxConnFile)->scf_RecvLinkage.Flink);			\
																				\
				_p 	= (PTDI_REQUEST_KERNEL_RECEIVE)								\
						REQUEST_PARAMETERS((pSpxConnFile)->scf_CurRecvReq);		\
																				\
				(pSpxConnFile)->scf_CurRecvOffset	= 0;						\
				(pSpxConnFile)->scf_CurRecvSize	= 	(_p)->ReceiveLength;		\
			}																	\
			if ((SPX_RECV_STATE(pSpxConnFile) == SPX_RECV_IDLE)	||				\
				(SPX_RECV_STATE(pSpxConnFile) == SPX_RECV_POSTED))				\
			{																	\
				SPX_RECV_SETSTATE(												\
					pSpxConnFile,												\
					(pSpxConnFile->scf_CurRecvReq == NULL) ?					\
						SPX_RECV_IDLE : SPX_RECV_POSTED);						\
			}																	\
		}

#define	SPX_INSERT_ADDR_ACTIVE(pSpxAddr, pSpxConnFile)							\
		{																		\
			(pSpxConnFile)->scf_Next 		= (pSpxAddr)->sa_ActiveConnList;	\
			(pSpxAddr)->sa_ActiveConnList	= pSpxConnFile;						\
		}																		

#define	SPX_INSERT_ADDR_INACTIVE(pSpxAddr, pSpxConnFile)						\
		{																		\
			(pSpxConnFile)->scf_Next 		= (pSpxAddr)->sa_InactiveConnList;	\
			(pSpxAddr)->sa_InactiveConnList	= pSpxConnFile;						\
		}
																				
#define	SPX_INSERT_ADDR_LISTEN(pSpxAddr, pSpxConnFile)							\
		{																		\
			(pSpxConnFile)->scf_Next 		= (pSpxAddr)->sa_ListenConnList;	\
			(pSpxAddr)->sa_ListenConnList	= pSpxConnFile;						\
		}


//
//	STATE MANIPULATION
//

#if 0
//
// Disabled for now
//
#define SPX_STORE_LAST_STATE(pSpxConnFile) \
        (pSpxConnFile)->scf_StateBuffer[(pSpxConnFile)->scf_NextStatePtr++] =   \
            (pSpxConnFile)->scf_Flags;                                          \
         (pSpxConnFile)->scf_NextStatePtr %= CFMAX_STATES;
#else

#define SPX_STORE_LAST_STATE(pSpxConnFile)

#endif

#define	SPX_MAIN_STATE(pSpxConnFile)                                         	\
		((pSpxConnFile)->scf_Flags & SPX_CONNFILE_MAINMASK)

// #define	SPX_CONN_IDLE(pSpxConnFile)												\
// 	((BOOLEAN)(SPX_MAIN_STATE(pSpxConnFile) == 0))

#define	SPX_CONN_IDLE(pSpxConnFile)												\
	((BOOLEAN)((SPX_MAIN_STATE(pSpxConnFile) == 0) || \
               ((SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) && \
                (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED))))

#define	SPX_CONN_ACTIVE(pSpxConnFile)											\
		((BOOLEAN)(SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_ACTIVE))
		
#define	SPX_CONN_CONNECTING(pSpxConnFile)										\
		((BOOLEAN)(SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_CONNECTING))
		
#define	SPX_CONN_LISTENING(pSpxConnFile)										\
		((BOOLEAN)(SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_LISTENING))
		
#define	SPX_CONN_DISC(pSpxConnFile)												\
		((BOOLEAN)(SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN))

#if DBG

#define	SPX_MAIN_SETSTATE(pSpxConnFile, newState)                             	\
		{																		\
            SPX_STORE_LAST_STATE(pSpxConnFile)                                                              \
			(pSpxConnFile)->scf_Flags = 										\
			(((pSpxConnFile)->scf_Flags & ~SPX_CONNFILE_MAINMASK) | (newState));\
		}

#else

#define	SPX_MAIN_SETSTATE(pSpxConnFile, newState)                             	\
		{																		\
			(pSpxConnFile)->scf_Flags = 										\
			(((pSpxConnFile)->scf_Flags & ~SPX_CONNFILE_MAINMASK) | (newState));\
		}

#endif

#define	SPX_CONN_FLAG(pSpxConnFile, Flag)										\
		((BOOLEAN)(((pSpxConnFile)->scf_Flags & (Flag)) != 0))

#define	SPX_CONN_FLAG2(pSpxConnFile, Flag)										\
		((BOOLEAN)(((pSpxConnFile)->scf_Flags2 & (Flag)) != 0))

#if DBG

#define	SPX_CONN_SETFLAG(pSpxConnFile, Flag)									\
        SPX_STORE_LAST_STATE(pSpxConnFile)                                                              \
		((pSpxConnFile)->scf_Flags |= (Flag))
#else

#define	SPX_CONN_SETFLAG(pSpxConnFile, Flag)									\
		((pSpxConnFile)->scf_Flags |= (Flag))

#endif

#define	SPX_CONN_SETFLAG2(pSpxConnFile, Flag)									\
		((pSpxConnFile)->scf_Flags2 |= (Flag))

#define	SPX_CONN_RESETFLAG(pSpxConnFile, Flag)									\
		((pSpxConnFile)->scf_Flags &= ~(Flag))

#define	SPX_CONN_RESETFLAG2(pSpxConnFile, Flag)									\
		((pSpxConnFile)->scf_Flags2 &= ~(Flag))

#define SPX2_CONN(pSpxConnFile)													\
		(SPX_CONN_FLAG((pSpxConnFile), SPX_CONNFILE_SPX2))

#define	SPX_CONN_STREAM(pSpxConnFile)											\
		(SPX_CONN_FLAG((pSpxConnFile), SPX_CONNFILE_STREAM))

#define	SPX_CONN_MSG(pSpxConnFile)												\
		(!SPX_CONN_FLAG((pSpxConnFile), SPX_CONNFILE_STREAM))

#define	SPX_LISTEN_STATE(pSpxConnFile)                                         	\
		((pSpxConnFile)->scf_Flags & SPX_LISTEN_MASK)

#define	SPX_CONNECT_STATE(pSpxConnFile)                                         \
		((pSpxConnFile)->scf_Flags & SPX_CONNECT_MASK)

#define	SPX_SEND_STATE(pSpxConnFile)                                         	\
		((pSpxConnFile)->scf_Flags & SPX_SEND_MASK)

#define	SPX_RECV_STATE(pSpxConnFile)                                         	\
		((pSpxConnFile)->scf_Flags & SPX_RECV_MASK)

#define	SPX_DISC_STATE(pSpxConnFile)                                        	\
		((pSpxConnFile)->scf_Flags & SPX_DISC_MASK)

#if DBG

#define	SPX_LISTEN_SETSTATE(pSpxConnFile, newState)                             \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("LISTEN: %x -> %x\n",										\
					SPX_LISTEN_STATE(pSpxConnFile), (newState)));				\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
            SPX_STORE_LAST_STATE(pSpxConnFile)                                                              \
			pSpxConnFile->scf_Flags = 											\
				(((pSpxConnFile)->scf_Flags & ~SPX_LISTEN_MASK) | (newState));	\
		}

#define	SPX_CONNECT_SETSTATE(pSpxConnFile, newState)                            \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("CONNECT: %x -> %x\n",										\
					SPX_CONNECT_STATE(pSpxConnFile), (newState)));				\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
            SPX_STORE_LAST_STATE(pSpxConnFile)                                                              \
			(pSpxConnFile)->scf_Flags = 										\
				(((pSpxConnFile)->scf_Flags & ~SPX_CONNECT_MASK) | (newState));	\
		}

#define	SPX_SEND_SETSTATE(pSpxConnFile, newState)                               \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("SEND: %x -> %x\n",										\
					SPX_SEND_STATE(pSpxConnFile), (newState)));					\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
            SPX_STORE_LAST_STATE(pSpxConnFile)                                                              \
			(pSpxConnFile)->scf_Flags = 										\
				(((pSpxConnFile)->scf_Flags & ~SPX_SEND_MASK) | (newState));	\
		}

#define	SPX_RECV_SETSTATE(pSpxConnFile, newState)                               \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("RECV: %x -> %x\n",										\
					SPX_RECV_STATE(pSpxConnFile), (newState)));					\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
            SPX_STORE_LAST_STATE(pSpxConnFile)                                                              \
			(pSpxConnFile)->scf_Flags = 											\
				(((pSpxConnFile)->scf_Flags & ~SPX_RECV_MASK) | (newState));		\
		}

#define	SPX_DISC_SETSTATE(pSpxConnFile, newState)                               \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("DISC: %x -> %x\n",										\
					SPX_DISC_STATE(pSpxConnFile), (newState)));					\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
            SPX_STORE_LAST_STATE(pSpxConnFile)                                                              \
			(pSpxConnFile)->scf_Flags = 											\
				(((pSpxConnFile)->scf_Flags & ~SPX_DISC_MASK) | (newState));		\
		}

#else

#define	SPX_LISTEN_SETSTATE(pSpxConnFile, newState)                             \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("LISTEN: %x -> %x\n",										\
					SPX_LISTEN_STATE(pSpxConnFile), (newState)));				\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
			pSpxConnFile->scf_Flags = 											\
				(((pSpxConnFile)->scf_Flags & ~SPX_LISTEN_MASK) | (newState));	\
		}

#define	SPX_CONNECT_SETSTATE(pSpxConnFile, newState)                            \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("CONNECT: %x -> %x\n",										\
					SPX_CONNECT_STATE(pSpxConnFile), (newState)));				\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
			(pSpxConnFile)->scf_Flags = 										\
				(((pSpxConnFile)->scf_Flags & ~SPX_CONNECT_MASK) | (newState));	\
		}

#define	SPX_SEND_SETSTATE(pSpxConnFile, newState)                               \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("SEND: %x -> %x\n",										\
					SPX_SEND_STATE(pSpxConnFile), (newState)));					\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
			(pSpxConnFile)->scf_Flags = 										\
				(((pSpxConnFile)->scf_Flags & ~SPX_SEND_MASK) | (newState));	\
		}

#define	SPX_RECV_SETSTATE(pSpxConnFile, newState)                               \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("RECV: %x -> %x\n",										\
					SPX_RECV_STATE(pSpxConnFile), (newState)));					\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
			(pSpxConnFile)->scf_Flags = 											\
				(((pSpxConnFile)->scf_Flags & ~SPX_RECV_MASK) | (newState));		\
		}

#define	SPX_DISC_SETSTATE(pSpxConnFile, newState)                               \
		{																		\
			DBGPRINT(STATE, INFO,												\
					("DISC: %x -> %x\n",										\
					SPX_DISC_STATE(pSpxConnFile), (newState)));					\
			DBGPRINT(STATE, INFO,												\
					("FILE: %s - %d\n", __FILE__, __LINE__));					\
			(pSpxConnFile)->scf_Flags = 											\
				(((pSpxConnFile)->scf_Flags & ~SPX_DISC_MASK) | (newState));		\
		}
#endif  //DBG
#define	SpxConnQueueSendPktTail(pSpxConnFile, pPkt)						\
		{																\
			PSPX_SEND_RESD	_pSendResd;									\
			_pSendResd	= (PSPX_SEND_RESD)((pPkt)->ProtocolReserved);	\
			_pSendResd->sr_Next = NULL;									\
			if ((pSpxConnFile)->scf_SendListTail != NULL)				\
			{															\
				(pSpxConnFile)->scf_SendListTail->sr_Next = _pSendResd;	\
				(pSpxConnFile)->scf_SendListTail			= _pSendResd;\
			}															\
			else														\
			{															\
				(pSpxConnFile)->scf_SendListTail	=					\
				(pSpxConnFile)->scf_SendListHead	= _pSendResd;		\
			}															\
		}																

#define	SpxConnQueueSendPktHead(pSpxConnFile, pPkt)						\
		{																\
			PSPX_SEND_RESD	_pSendResd;									\
			_pSendResd	= (PSPX_SEND_RESD)((pPkt)->ProtocolReserved);	\
			_pSendResd->sr_Next = NULL;									\
			if ((pSpxConnFile)->scf_SendListTail != NULL)				\
			{															\
				_pSendResd->sr_Next	= (pSpxConnFile)->scf_SendListHead;	\
			}															\
			else														\
			{															\
				(pSpxConnFile)->scf_SendListTail	= _pSendResd;		\
			}															\
			(pSpxConnFile)->scf_SendListHead	= _pSendResd;			\
		}																

#define	SpxConnQueueSendSeqPktTail(pSpxConnFile, pPkt)					\
		{																\
			PSPX_SEND_RESD	_pSendResd;									\
			_pSendResd	= (PSPX_SEND_RESD)((pPkt)->ProtocolReserved);	\
			_pSendResd->sr_Next = NULL;									\
			if ((pSpxConnFile)->scf_SendSeqListTail != NULL)			\
			{															\
				(pSpxConnFile)->scf_SendSeqListTail->sr_Next = _pSendResd;\
				(pSpxConnFile)->scf_SendSeqListTail			= _pSendResd;\
			}															\
			else														\
			{															\
				(pSpxConnFile)->scf_SendSeqListTail	=					\
				(pSpxConnFile)->scf_SendSeqListHead	= _pSendResd;		\
			}															\
		}																

#define	SpxConnQueueSendSeqPktHead(pSpxConnFile, pPkt)					\
		{																\
			PSPX_SEND_RESD	_pSendResd;									\
			_pSendResd	= (PSPX_SEND_RESD)((pPkt)->ProtocolReserved);	\
			_pSendResd->sr_Next = NULL;									\
			if ((pSpxConnFile)->scf_SendSeqListTail != NULL)			\
			{															\
				_pSendResd->sr_Next	= (pSpxConnFile)->scf_SendSeqListHead;\
			}															\
			else														\
			{															\
				(pSpxConnFile)->scf_SendSeqListTail	= _pSendResd;		\
			}															\
			(pSpxConnFile)->scf_SendSeqListHead	= _pSendResd;			\
		}																

#define	SpxConnQueueRecvPktTail(pSpxConnFile, pPkt)						\
		{																\
			PSPX_RECV_RESD	_pRecvResd;									\
			_pRecvResd	= (PSPX_RECV_RESD)((pPkt)->ProtocolReserved);	\
			_pRecvResd->rr_Next = NULL;									\
			if ((pSpxConnFile)->scf_RecvListTail != NULL)				\
			{															\
				(pSpxConnFile)->scf_RecvListTail->rr_Next = _pRecvResd;	\
				(pSpxConnFile)->scf_RecvListTail			= _pRecvResd;\
			}															\
			else														\
			{															\
				(pSpxConnFile)->scf_RecvListTail	=					\
				(pSpxConnFile)->scf_RecvListHead	= _pRecvResd;		\
			}															\
		}																

#define	SpxConnQueueRecvPktHead(pSpxConnFile, pPkt)						\
		{																\
			PSPX_RECV_RESD	_pRecvResd;									\
			_pRecvResd	= (PSPX_RECV_RESD)((pPkt)->ProtocolReserved);	\
			_pRecvResd->rr_Next = NULL;									\
			if ((pSpxConnFile)->scf_RecvListTail != NULL)				\
			{															\
				_pRecvResd->rr_Next	= (pSpxConnFile)->scf_RecvListHead;	\
			}															\
			else														\
			{															\
				(pSpxConnFile)->scf_RecvListTail	= _pRecvResd;		\
			}															\
			(pSpxConnFile)->scf_RecvListHead	= _pRecvResd;			\
		}																

#if DBG
#define SpxConnFileReference(_ConnFile, _Type)			\
		{												\
			(VOID)SPX_ADD_ULONG ( 				\
				&(_ConnFile)->scf_RefTypes[_Type], 		\
				1, 										\
				&SpxGlobalInterlock); 					\
			SpxConnFileRef (_ConnFile);					\
		}

#define SpxConnFileLockReference(_ConnFile, _Type)			\
		{													\
			(VOID)SPX_ADD_ULONG ( 					\
				&(_ConnFile)->scf_RefTypes[_Type], 			\
				1, 											\
				&SpxGlobalInterlock); 						\
			SpxConnFileLockRef (_ConnFile);					\
		}

#define SpxConnFileDereference(_ConnFile, _Type) 			\
		{													\
			(VOID)SPX_ADD_ULONG ( 					\
				&(_ConnFile)->scf_RefTypes[_Type], 			\
				(ULONG)-1, 									\
				&SpxGlobalInterlock); 						\
			SpxConnFileDeref (_ConnFile);					\
		}

#define	SpxConnFileReferenceByCtx(_pAddrFile, _Ctx, _ppConnFile, _pStatus)			\
		{																			\
			CTELockHandle	_lockHandle;											\
			CTEGetLock((_pAddrFile)->saf_AddrLock, &(_lockHandle));					\
			SpxConnFileRefByCtxLock((_pAddrFile), (_Ctx), (_ppConnFile),(_pStatus));\
			CTEFreeLock((_pAddrFile)->saf_AddrLock, (_lockHandle)); 				\
		}

#define	SpxConnFileReferenceByCtxLock(_pAddrFile, _Ctx, _ppConnFile, _pStatus)		\
		SpxConnFileRefByCtxLock((_pAddrFile), (_Ctx), (_ppConnFile),(_pStatus));

#define	SpxConnFileReferenceById(_ConnId, _ppConnFile, _pStatus)		\
		{																\
			CTELockHandle	_l;											\
			CTEGetLock(&SpxDevice->dev_Lock, &(_l));					\
			SpxConnFileRefByIdLock(_ConnId, _ppConnFile, _pStatus);		\
			CTEFreeLock(&SpxDevice->dev_Lock, _l);						\
		}

#define SpxConnFileTransferReference(_ConnFile, _OldType, _NewType)			\
		{																	\
			(VOID)SPX_ADD_ULONG ( 									\
				&(_ConnFile)->scf_RefTypes[_NewType], 						\
				1, 															\
				&SpxGlobalInterlock); 										\
			(VOID)SPX_ADD_ULONG ( 									\
				&(_ConnFile)->scf_RefTypes[_OldType], 						\
				(ULONG)-1, 													\
				&SpxGlobalInterlock);										\
		}

#else  // DBG

#define SpxConnFileReference(_ConnFile, _Type) 	\
			SPX_ADD_ULONG( 				\
				&(_ConnFile)->scf_RefCount, 	\
				1, 								\
				&(_ConnFile)->scf_Lock)

#define SpxConnFileLockReference(_ConnFile, _Type) \
			SPX_ADD_ULONG( 				\
				&(_ConnFile)->scf_RefCount, 	\
				1, 								\
				&(_ConnFile)->scf_Lock);

#define SpxConnFileDereference(_ConnFile, _Type) 			\
		{													\
			SpxConnFileDeref(_ConnFile);					\
		}

#define	SpxConnFileReferenceByCtx(_pAddrFile, _Ctx, _ppConnFile, _pStatus)			\
		{																			\
			CTELockHandle	_lockHandle;											\
			CTEGetLock((_pAddrFile)->saf_AddrLock, &(_lockHandle));				\
			SpxConnFileRefByCtxLock((_pAddrFile), (_Ctx), (_ppConnFile),(_pStatus));\
			CTEFreeLock((_pAddrFile)->saf_AddrLock, (_lockHandle)); 				\
		}

#define	SpxConnFileReferenceByCtxLock(_pAddrFile, _Ctx, _ppConnFile, _pStatus)		\
		SpxConnFileRefByCtxLock((_pAddrFile), (_Ctx), (_ppConnFile),(_pStatus));

#define	SpxConnFileReferenceById(_ConnId, _ppConnFile, _pStatus)					\
		{																			\
			CTELockHandle	_lockHandle;											\
			CTEGetLock(&SpxDevice->dev_Lock, &(_lockHandle));						\
			SpxConnFileRefByIdLock(_ConnId, _ppConnFile, _pStatus);					\
			CTEFreeLock(&SpxDevice->dev_Lock, (_lockHandle));						\
		}

#define SpxConnFileTransferReference(_ConnFile, _OldType, _NewType)

#endif // DBG


//	Set the packet size. If we are spx1 or spx2 and !neg, check if we are different
//	nets, set to min then, else use the size indicated by IPX. If we are spx2, just
//	set it to our local max.
//
//	Also always even out packet size and round down. This solves an issue with
//	data size needing to be even for some novell 802.2 clients.
//
//	Fix after beta2 for tokring using receive size. Only if spx2 and neg.
#if     defined(_PNP_POWER)
#define	SPX_MAX_PKT_SIZE(pSpxConnFile, fSpx2Neg, fSpx2, pRemNet)		    \
		{																	\
           if (!fSpx2 && PARAM(CONFIG_BACKCOMP_SPX))  {                     \
                (pSpxConnFile)->scf_MaxPktSize = SPX_MAX_PACKET;			\
           }                                                                \
           else {                                                           \
			IPX_LINE_INFO	_i;												\
																			\
			(VOID)(*IpxQuery)(												\
				IPX_QUERY_LINE_INFO,										\
				&(pSpxConnFile)->scf_LocalTarget.NicHandle, 				\
				&(_i),														\
				sizeof(IPX_LINE_INFO),										\
				NULL);														\
																			\
			(pSpxConnFile)->scf_MaxPktSize = (USHORT) (_i).MaximumPacketSize;		\
			if (!fSpx2Neg)													\
			{																\
				(pSpxConnFile)->scf_MaxPktSize = (USHORT) (_i).MaximumSendSize;       \
			}																\
																			\
			if ((pSpxConnFile)->scf_MaxPktSize < SPX_MAX_PACKET)			\
			{																\
                (pSpxConnFile)->scf_MaxPktSize = SPX_MAX_PACKET;			\
			}																\
                															\
			DBGPRINT(CONNECT, DBG,											\
					("SPX_MAX_PKT_SIZE: Nets %lx.%lx Max Pkt %d\n",			\
						(*(UNALIGNED ULONG *)(pRemNet)),					\
						*(UNALIGNED ULONG *)SpxDevice->dev_Network,			\
						(pSpxConnFile)->scf_MaxPktSize));					\
			DBGPRINT(CONNECT, DBG,											\
					("%s : %d.%d\n", __FILE__, __LINE__, fSpx2Neg));		\
																			\
			if ((!fSpx2Neg) &&												\
				((*(UNALIGNED ULONG *)(pRemNet)) !=	0)	&&					\
				((*(UNALIGNED ULONG *)SpxDevice->dev_Network) != 0) &&		\
				((*(UNALIGNED ULONG *)(pRemNet)) !=							\
					*(UNALIGNED ULONG *)SpxDevice->dev_Network))			\
			{																\
				if (PARAM(CONFIG_ROUTER_MTU) != 0)							\
				{															\
					DBGPRINT(CONNECT, ERR,									\
							("SPX_MAX_PKT_SIZE: PARAM %lx Max Pkt %lx\n",	\
	                            PARAM(CONFIG_ROUTER_MTU),					\
								(pSpxConnFile)->scf_MaxPktSize));			\
																			\
					(pSpxConnFile)->scf_MaxPktSize =						\
						(USHORT)(MIN(PARAM(CONFIG_ROUTER_MTU),				\
									(ULONG)((pSpxConnFile)->scf_MaxPktSize)));\
				}															\
				else														\
				{															\
					(pSpxConnFile)->scf_MaxPktSize = SPX_MAX_PACKET;		\
				}															\
																			\
				DBGPRINT(CONNECT, DBG,										\
						("SPX_MAX_PKT_SIZE: Nets %lx.%lx Max Pkt %d\n",		\
							(*(UNALIGNED ULONG *)(pRemNet)),				\
							*(UNALIGNED ULONG *)SpxDevice->dev_Network,		\
							(pSpxConnFile)->scf_MaxPktSize));				\
				DBGPRINT(CONNECT, DBG,										\
						("SPX_MAX_PKT_SIZE: LineInfo Pkt %d\n",				\
	                        (_i).MaximumSendSize));							\
			}	 															\
           }                                                                \
			(pSpxConnFile)->scf_MaxPktSize &= ~((USHORT)1);					\
			DBGPRINT(CONNECT, DBG,											\
					("SPX_MAX_PKT_SIZE: %lx.%d\n",							\
	                    (pSpxConnFile)->scf_MaxPktSize,						\
                        (pSpxConnFile)->scf_MaxPktSize));					\
		}
#else
#define	SPX_MAX_PKT_SIZE(pSpxConnFile, fSpx2Neg, fSpx2, pRemNet)		    \
		{																	\
           if (!fSpx2 && PARAM(CONFIG_BACKCOMP_SPX))  {                     \
                (pSpxConnFile)->scf_MaxPktSize = SPX_MAX_PACKET;			\
           }                                                                \
           else {                                                           \
			IPX_LINE_INFO	_i;												\
																			\
			(VOID)(*IpxQuery)(												\
				IPX_QUERY_LINE_INFO,										\
				(pSpxConnFile)->scf_LocalTarget.NicId,						\
				&(_i),														\
				sizeof(IPX_LINE_INFO),										\
				NULL);														\
																			\
			(pSpxConnFile)->scf_MaxPktSize = (_i).MaximumPacketSize;		\
			if (!fSpx2Neg)													\
			{																\
				(pSpxConnFile)->scf_MaxPktSize = (_i).MaximumSendSize;       \
			}																\
																			\
			if ((pSpxConnFile)->scf_MaxPktSize < SPX_MAX_PACKET)			\
			{																\
                (pSpxConnFile)->scf_MaxPktSize = SPX_MAX_PACKET;			\
			}																\
                															\
			DBGPRINT(CONNECT, DBG,											\
					("SPX_MAX_PKT_SIZE: Nets %lx.%lx Max Pkt %d\n",			\
						(*(UNALIGNED ULONG *)(pRemNet)),					\
						*(UNALIGNED ULONG *)SpxDevice->dev_Network,			\
						(pSpxConnFile)->scf_MaxPktSize));					\
			DBGPRINT(CONNECT, DBG,											\
					("%s : %d.%d\n", __FILE__, __LINE__, fSpx2Neg));		\
																			\
			if ((!fSpx2Neg) &&												\
				((*(UNALIGNED ULONG *)(pRemNet)) !=	0)	&&					\
				((*(UNALIGNED ULONG *)SpxDevice->dev_Network) != 0) &&		\
				((*(UNALIGNED ULONG *)(pRemNet)) !=							\
					*(UNALIGNED ULONG *)SpxDevice->dev_Network))			\
			{																\
				if (PARAM(CONFIG_ROUTER_MTU) != 0)							\
				{															\
					DBGPRINT(CONNECT, ERR,									\
							("SPX_MAX_PKT_SIZE: PARAM %lx Max Pkt %lx\n",	\
	                            PARAM(CONFIG_ROUTER_MTU),					\
								(pSpxConnFile)->scf_MaxPktSize));			\
																			\
					(pSpxConnFile)->scf_MaxPktSize =						\
						(USHORT)(MIN(PARAM(CONFIG_ROUTER_MTU),				\
									(ULONG)((pSpxConnFile)->scf_MaxPktSize)));\
				}															\
				else														\
				{															\
					(pSpxConnFile)->scf_MaxPktSize = SPX_MAX_PACKET;		\
				}															\
																			\
				DBGPRINT(CONNECT, DBG,										\
						("SPX_MAX_PKT_SIZE: Nets %lx.%lx Max Pkt %d\n",		\
							(*(UNALIGNED ULONG *)(pRemNet)),				\
							*(UNALIGNED ULONG *)SpxDevice->dev_Network,		\
							(pSpxConnFile)->scf_MaxPktSize));				\
				DBGPRINT(CONNECT, DBG,										\
						("SPX_MAX_PKT_SIZE: LineInfo Pkt %d\n",				\
	                        (_i).MaximumSendSize));							\
			}	 															\
           }                                                                \
			(pSpxConnFile)->scf_MaxPktSize &= ~((USHORT)1);					\
			DBGPRINT(CONNECT, DBG,											\
					("SPX_MAX_PKT_SIZE: %lx.%d\n",							\
	                    (pSpxConnFile)->scf_MaxPktSize,						\
                        (pSpxConnFile)->scf_MaxPktSize));					\
		}
#endif  _PNP_POWER


#if DBG
#define	SPX_SENDPACKET(pSpxConnFile, pNdisPkt, pSendResd)					\
		{																	\
			NDIS_STATUS	_n;													\
																			\
			++SpxDevice->dev_Stat.PacketsSent;								\
																			\
			_n = (*IpxSendPacket)(											\
			        &(pSpxConnFile)->scf_LocalTarget,               		\
					(pNdisPkt),												\
					(pSendResd)->sr_Len,									\
					(pSendResd)->sr_HdrLen);								\
																			\
			if (_n != NDIS_STATUS_PENDING)									\
			{																\
                if (_n != NDIS_STATUS_SUCCESS)                              \
                {                                                           \
				   DBGPRINT(SEND, ERR,								   		\
						("SPX_SENDPACKET: Failed with %lx in %s.%lx\n",		\
							_n, __FILE__, __LINE__));						\
                }                                                           \
																			\
				SpxSendComplete(											\
					(pNdisPkt),												\
					_n);									                \
			}																\
		}

#define	SPX_SENDACK(pSpxConnFile, pNdisPkt, pSendResd)						\
		{																	\
			NDIS_STATUS	_n;													\
																			\
			++SpxDevice->dev_Stat.PacketsSent;								\
                                                                            \
			_n = (*IpxSendPacket)(											\
			        &(pSpxConnFile)->scf_AckLocalTarget,               		\
					(pNdisPkt),												\
					(pSendResd)->sr_Len,									\
					(pSendResd)->sr_HdrLen);								\
																			\
			if (_n != NDIS_STATUS_PENDING)									\
			{																\
                if (_n != NDIS_STATUS_SUCCESS)                              \
                {                                                           \
				DBGPRINT(SEND, ERR,								   			\
						("SPX_SENDPACKET: Failed with %lx in %s.%lx\n",		\
							_n, __FILE__, __LINE__));						\
                }                                                           \
																			\
				SpxSendComplete(											\
					(pNdisPkt),												\
					_n);									\
			}																\
		}

#else  // DBG
#define	SPX_SENDPACKET(pSpxConnFile, pNdisPkt, pSendResd)					\
		{																	\
			NDIS_STATUS	_n;													\
																			\
			++SpxDevice->dev_Stat.PacketsSent;								\
																			\
			_n = (*IpxSendPacket)(											\
			        &(pSpxConnFile)->scf_LocalTarget,               		\
					(pNdisPkt),												\
					(pSendResd)->sr_Len,									\
					(pSendResd)->sr_HdrLen);								\
																			\
			if (_n != NDIS_STATUS_PENDING)									\
			{																\
				SpxSendComplete(											\
					(pNdisPkt),												\
					_n);									                \
			}																\
		}
#define	SPX_SENDACK(pSpxConnFile, pNdisPkt, pSendResd)						\
		{																	\
			NDIS_STATUS	_n;													\
																			\
			++SpxDevice->dev_Stat.PacketsSent;								\
																			\
			_n = (*IpxSendPacket)(											\
			        &(pSpxConnFile)->scf_AckLocalTarget,               		\
					(pNdisPkt),												\
					(pSendResd)->sr_Len,									\
					(pSendResd)->sr_HdrLen);								\
																			\
			if (_n != NDIS_STATUS_PENDING)									\
			{																\
				SpxSendComplete(											\
					(pNdisPkt),												\
					_n);									                \
			}																\
		}

#endif // DBG

#define	SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile)							\
		{																	\
			if (!SPX_CONN_FLAG(												\
					(pSpxConnFile),											\
					SPX_CONNFILE_RECVQ))									\
			{																\
				SPX_CONN_SETFLAG((pSpxConnFile), SPX_CONNFILE_RECVQ);		\
				SpxConnFileLockReference(pSpxConnFile, CFREF_RECV);			\
				SPX_QUEUE_TAIL_RECVLIST(pSpxConnFile);						\
			}																\
		}

#define	SPX_QUEUE_TAIL_PKTLIST(pSpxConnFile)									\
		{																		\
            if (SpxPktConnList.pcl_Tail)										\
			{																	\
                SpxPktConnList.pcl_Tail->scf_PktNext 	= pSpxConnFile;			\
                SpxPktConnList.pcl_Tail			  		= pSpxConnFile;			\
			}																	\
			else																\
			{																	\
                SpxPktConnList.pcl_Tail =										\
                SpxPktConnList.pcl_Head = pSpxConnFile;							\
			}																	\
		}																		
																				
#define	SPX_QUEUE_TAIL_RECVLIST(pSpxConnFile)									\
		{																		\
            if (SpxRecvConnList.pcl_Tail)										\
			{																	\
                SpxRecvConnList.pcl_Tail->scf_ProcessRecvNext	= pSpxConnFile;	\
                SpxRecvConnList.pcl_Tail			  			= pSpxConnFile;	\
			}																	\
			else																\
			{																	\
                SpxRecvConnList.pcl_Tail =										\
                SpxRecvConnList.pcl_Head = pSpxConnFile;						\
			}																	\
		}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxconn.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxconn.c

Abstract:

    This module contains code which implements the CONNECTION object.
    Routines are provided to create, destroy, reference, and dereference,
    transport connection objects.

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

    Sanjay Anand (SanjayAn) 5-July-1995
    Bug fixes - tagged [SA]

--*/

#include "precomp.h"

extern POBJECT_TYPE *IoFileObjectType;

#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpxConnOpen)
#endif

//	Define module number for event logging entries
#define	FILENUM		SPXCONN

VOID
SpxFindRouteComplete (
    IN PIPX_FIND_ROUTE_REQUEST FindRouteRequest,
    IN BOOLEAN FoundRoute);


NTSTATUS
SpxConnOpen(
	IN 	PDEVICE 			pDevice,
	IN	CONNECTION_CONTEXT	ConnCtx,
	IN 	PREQUEST 			pRequest
    )
	
/*++

Routine Description:

	This routine is used to create a connection object and associate the
	passed ConnectionContext with it.

Arguments:

	pConnCtx - The TDI ConnectionContext to be associated with object

Return Value:

	STATUS_SUCCESS if connection was successfully opened
	Error otherwise.

--*/

{
	NTSTATUS		status = STATUS_SUCCESS;
	PSPX_CONN_FILE	pSpxConnFile;

#ifdef ISN_NT
    PIRP Irp = (PIRP)pRequest;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
#endif


	// Allocate memory for a connection object
	if ((pSpxConnFile = SpxAllocateZeroedMemory(sizeof(SPX_CONN_FILE))) == NULL)
	{
		return(STATUS_INSUFFICIENT_RESOURCES);
	}

	//	Initialize values
	pSpxConnFile->scf_Flags 	= 0;
	pSpxConnFile->scf_Type 		= SPX_CONNFILE_SIGNATURE;
	pSpxConnFile->scf_Size 		= sizeof (SPX_CONN_FILE);

	CTEInitLock (&pSpxConnFile->scf_Lock);

	pSpxConnFile->scf_ConnCtx		= ConnCtx;
	pSpxConnFile->scf_Device		= pDevice;

	//	Initialize list for requests.
	InitializeListHead(&pSpxConnFile->scf_ReqLinkage);
	InitializeListHead(&pSpxConnFile->scf_RecvLinkage);
	InitializeListHead(&pSpxConnFile->scf_RecvDoneLinkage);
	InitializeListHead(&pSpxConnFile->scf_ReqDoneLinkage);
	InitializeListHead(&pSpxConnFile->scf_DiscLinkage);

#ifdef ISN_NT
	// easy backlink to file object.
	pSpxConnFile->scf_FileObject	= IrpSp->FileObject;
#endif

	//	For connections we go from 0->0 with flags indicating if a close
	//	happened.
	pSpxConnFile->scf_RefCount		= 0;

	//	Insert into a global connection list.
	spxConnInsertIntoGlobalList(pSpxConnFile);

#if DBG

	//	Initialize this to 0xFFFF so we dont hit assert on first packet.
	pSpxConnFile->scf_PktSeqNum 	= 0xFFFF;

#endif

	//	Set values in the request.
	REQUEST_OPEN_CONTEXT(pRequest) 	= (PVOID)pSpxConnFile;
	REQUEST_OPEN_TYPE(pRequest) 	= (PVOID)TDI_CONNECTION_FILE;

	DBGPRINT(CREATE, INFO,
			("SpxConnOpen: Opened %lx\n", pSpxConnFile));

	ASSERT(status == STATUS_SUCCESS);
	return(status);
}




NTSTATUS
SpxConnCleanup(
    IN PDEVICE 	Device,
    IN PREQUEST Request
    )

/*++

Routine Description:


Arguments:

    Request - the close request.

Return Value:

    STATUS_SUCCESS if all is well, STATUS_INVALID_HANDLE if the
    request does not point to a real connection

--*/

{
	NTSTATUS		status;
	CTELockHandle	lockHandle;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(Request);

	//	Verify connection file
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		DBGBRK(FATAL);
		return (status);
	}

	DBGPRINT(CREATE, INFO,
			("SpxConnFileCleanup: %lx.%lx when %lx\n",
				pSpxConnFile, Request, pSpxConnFile->scf_RefCount));

	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
    pSpxConnFile->scf_CleanupReq = Request;
	CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

	//	We have a reference, so it wont go to zero until stop returns. Therefore
	//	deref can expect flag to be set.
	SpxConnStop(pSpxConnFile);
    SpxConnFileDereference (pSpxConnFile, CFREF_VERIFY);

    //
    // If this is a connection which is waiting for a local disconnect,
    // deref it since we dont expect a disconnect after a cleanup.
    //

	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
    if (SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_DISC_WAIT)) {

        CTEAssert(  (SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
                    (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED) &&
                    SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC));

        CTEAssert(pSpxConnFile->scf_RefTypes[CFREF_DISCWAITSPX]);

        SPX_CONN_RESETFLAG2(pSpxConnFile, SPX_CONNFILE2_DISC_WAIT);

	    CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

        KdPrint(("Deref for DISCWAIT on connfile: %lx\n", pSpxConnFile));

        SpxConnFileDereference (pSpxConnFile, CFREF_DISCWAITSPX);
    } else {
	    CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
    }


    return STATUS_PENDING;
}




NTSTATUS
SpxConnClose(
    IN PDEVICE 	Device,
    IN PREQUEST Request
    )

/*++

Routine Description:


Arguments:

    Request - the close request.

Return Value:

    STATUS_SUCCESS if all is well, STATUS_INVALID_HANDLE if the
    request does not point to a real connection

--*/

{
	NTSTATUS		status;
	CTELockHandle	lockHandle;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(Request);

	//	Verify connection file
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		DBGBRK(FATAL);
		return (status);
	}

	DBGPRINT(CREATE, INFO,
			("SpxConnFileClose: %lx when %lx\n",
				pSpxConnFile, pSpxConnFile->scf_RefCount));

	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
    pSpxConnFile->scf_CloseReq = Request;
	SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_CLOSING);
	CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

    SpxConnFileDereference (pSpxConnFile, CFREF_VERIFY);
    return STATUS_PENDING;
}




VOID
SpxConnStop(
	IN	PSPX_CONN_FILE	pSpxConnFile
	)
/*++

Routine Description:

	!!!Connection must have a reference when this is called!!!

Arguments:


Return Value:


--*/
{
	CTELockHandle	lockHandle;

	DBGPRINT(CREATE, INFO,
			("SpxConnFileStop: %lx when %lx.%lx\n",
				pSpxConnFile, pSpxConnFile->scf_RefCount,
				pSpxConnFile->scf_Flags));

	//	Call disconnect and disassociate
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
	if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_STOPPING))
	{
        SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_STOPPING);
		if (!SPX_CONN_IDLE(pSpxConnFile))
		{
			spxConnAbortiveDisc(
				pSpxConnFile,
				STATUS_LOCAL_DISCONNECT,
				SPX_CALL_TDILEVEL,
				lockHandle,
                FALSE);     // [SA] Bug #15249

		}
		else
		{
			//	Disassociate if we are associated.
			spxConnDisAssoc(pSpxConnFile, lockHandle);
		}

		//	Lock released at this point.
	}
	else
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
	}
	return;
}




NTSTATUS
SpxConnAssociate(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)

/*++

Routine Description:

	This routine moves the connection from the device list to the inactive
	connection list in the address of the address file specified. The address
	file is pointed to by the connection and is referenced for the associate.

Arguments:


Return Value:


--*/

{
	NTSTATUS		status;
	PSPX_ADDR_FILE	pSpxAddrFile;
	CTELockHandle	lockHandle1, lockHandle2;

	BOOLEAN			derefAddr 	= FALSE, derefConn = FALSE;
	PFILE_OBJECT	pFileObj 	= NULL;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);
	HANDLE			AddrObjHandle =
	((PTDI_REQUEST_KERNEL_ASSOCIATE)(REQUEST_PARAMETERS(pRequest)))->AddressHandle;

	do
	{
		// Get the handle to the address object from the irp and map it to
		// the corres. file object.
		status = ObReferenceObjectByHandle(
					AddrObjHandle,
					0,
					*IoFileObjectType,
					pRequest->RequestorMode,
					(PVOID *)&pFileObj,
					NULL);

		if (!NT_SUCCESS(status))
			break;

		if (pFileObj->DeviceObject != SpxDevice->dev_DevObj || pFileObj->FsContext2 != (PVOID)TDI_TRANSPORT_ADDRESS_FILE ) {
		   ObDereferenceObject(pFileObj);
		   status = STATUS_INVALID_HANDLE;
		   break;
		}

		pSpxAddrFile = pFileObj->FsContext;
		// ASSERT(pFileObj->FsContext2 == (PVOID)TDI_TRANSPORT_ADDRESS_FILE);

		//	Verify address file/connection file
		if ((status = SpxAddrFileVerify(pSpxAddrFile)) != STATUS_SUCCESS) {
                   ObDereferenceObject(pFileObj);
		   break;
		}


		derefAddr = TRUE;

		if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS) {
		   ObDereferenceObject(pFileObj);  
		   break;
		}


		derefConn = TRUE;

		//	Grab the addres file lock, then the connection lock for associate.
		CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandle1);
		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle2);
		if (!SPX_CONN_FLAG(pSpxConnFile, (SPX_CONNFILE_CLOSING 		|
										  SPX_CONNFILE_STOPPING   	|
										  SPX_CONNFILE_ASSOC))
			&&
			!(pSpxAddrFile->saf_Flags & SPX_ADDRFILE_CLOSING))
		{
			derefAddr = FALSE;
            SpxAddrFileTransferReference(
				pSpxAddrFile, AFREF_VERIFY, AFREF_CONN_ASSOC);

			//	Queue in the inactive list in the address
			pSpxConnFile->scf_Next	= pSpxAddrFile->saf_Addr->sa_InactiveConnList;
            pSpxAddrFile->saf_Addr->sa_InactiveConnList	= pSpxConnFile;

			//	Queue in the assoc list in the address file
			pSpxConnFile->scf_AssocNext		= pSpxAddrFile->saf_AssocConnList;
            pSpxAddrFile->saf_AssocConnList	= pSpxConnFile;

			//	Remember the addrfile in the connection
			pSpxConnFile->scf_AddrFile	= pSpxAddrFile;
			SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_ASSOC);

			status = STATUS_SUCCESS;

			DBGPRINT(CREATE, INFO,
					("SpxConnAssociate: %lx with address file %lx\n",
						pSpxConnFile, pSpxAddrFile));
		}
		else
		{
			status = STATUS_INVALID_PARAMETER;
		}
		CTEFreeLock (&pSpxConnFile->scf_Lock, lockHandle2);
		CTEFreeLock (pSpxAddrFile->saf_AddrLock, lockHandle1);

		// Dereference the file object corres. to the address object
		ObDereferenceObject(pFileObj);

	} while (FALSE);

	if (derefAddr)
	{
		SpxAddrFileDereference(pSpxAddrFile, AFREF_VERIFY);
	}

	if (derefConn)
	{
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	return(status);
}




NTSTATUS
SpxConnDisAssociate(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
	NTSTATUS		status;
	CTELockHandle	lockHandle;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

	//	Verify connection file
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
		return (status);

	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
	if (!SPX_CONN_IDLE(pSpxConnFile)
		||
		(!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC)))
	{
		status = STATUS_INVALID_CONNECTION;
	}
	CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

	//	Unlink it if ok.
	if (NT_SUCCESS(status))
	{
		SpxConnStop(pSpxConnFile);
	}

	SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	return(status);
}




NTSTATUS
spxConnDisAssoc(
	IN	PSPX_CONN_FILE	pSpxConnFile,
	IN	CTELockHandle	LockHandleConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS		status = STATUS_SUCCESS;
	CTELockHandle	lockHandleAddr;
	PSPX_ADDR_FILE	pSpxAddrFile;

	if (SPX_CONN_IDLE(pSpxConnFile)
		&&
		(SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC)))
	{
		pSpxAddrFile				= pSpxConnFile->scf_AddrFile;
	}
	else
	{
		status = STATUS_INVALID_CONNECTION;
	}
	CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

	//	Unlink it if ok.
	if (NT_SUCCESS(status))
	{
		CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandleAddr);
		CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);

		//	Check again as we had released the lock
		if (SPX_CONN_IDLE(pSpxConnFile)
			&&
			(SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC)))
		{
			pSpxConnFile->scf_AddrFile	= NULL;
			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_ASSOC);

			//	Dequeue the connection from the address file
			spxConnRemoveFromAssocList(
				&pSpxAddrFile->saf_AssocConnList,
				pSpxConnFile);
	
			//	Dequeue the connection file from the address list. It must be
			//	in the inactive list.
			spxConnRemoveFromList(
				&pSpxAddrFile->saf_Addr->sa_InactiveConnList,
				pSpxConnFile);
		}
		else
		{
			status = STATUS_INVALID_CONNECTION;
		}

		CTEFreeLock (&pSpxConnFile->scf_Lock, LockHandleConn);
		CTEFreeLock (pSpxAddrFile->saf_AddrLock, lockHandleAddr);

		DBGPRINT(CREATE, INFO,
				("SpxConnDisAssociate: %lx from address file %lx\n",
					pSpxConnFile, pSpxAddrFile));

		if (NT_SUCCESS(status))
		{
			//	Remove reference on address for this association.
			SpxAddrFileDereference(pSpxAddrFile, AFREF_CONN_ASSOC);
		}
	}

	return(status);
}




NTSTATUS
SpxConnConnect(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)

/*++

Routine Description:


Arguments:

	We need to have another timer that will be started on the connection
	if the tdi client indicated a timeout value. 0 -> we do not start such
	a timer, -1 implies, we let our connection timeout values do their thing.
	Any other value will forcibly shutdown the connect process, when the timer
	fires.

Return Value:


--*/

{
	PTDI_REQUEST_KERNEL_CONNECT 	pParam;
	TDI_ADDRESS_IPX	UNALIGNED 	*	pTdiAddr;
	PNDIS_PACKET					pCrPkt;
	NTSTATUS						status;
	PIPXSPX_HDR						pIpxSpxHdr;
	PSPX_FIND_ROUTE_REQUEST			pFindRouteReq;
	CTELockHandle					lockHandleConn, lockHandleAddr, lockHandleDev;
	PSPX_ADDR						pSpxAddr;
	BOOLEAN							locksHeld = TRUE;
    PNDIS_BUFFER                    NdisBuf, NdisBuf2;
    ULONG                           BufLen =0;

	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

	//	Unpack the connect parameters
	pParam 	= (PTDI_REQUEST_KERNEL_CONNECT)REQUEST_PARAMETERS(pRequest);
	pTdiAddr= SpxParseTdiAddress(
				pParam->RequestConnectionInformation->RemoteAddress);

	DBGPRINT(CONNECT, DBG,
			("SpxConnConnect: Remote SOCKET %lx on %lx.%lx\n",
				pTdiAddr->Socket,
				pSpxConnFile,
				pRequest));

	//	Check if the connection is in a valid state
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		return(status);
	}

	do
	{
		if ((pFindRouteReq =
			(PSPX_FIND_ROUTE_REQUEST)SpxAllocateMemory(
										sizeof(SPX_FIND_ROUTE_REQUEST))) == NULL)
		{
			status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}
										
		//	Check if connection is associated, if so, the association cannot
		//	go away until the reference above is removed. So we are safe in
		//	releasing the lock.
		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
		status = STATUS_INVALID_ADDRESS;
		if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC))
		{
			status		= STATUS_SUCCESS;
			pSpxAddr	= pSpxConnFile->scf_AddrFile->saf_Addr;

			//	See if this connection is to be a spx2 connection.
			SPX_CONN_RESETFLAG(pSpxConnFile,
								(SPX_CONNFILE_SPX2 	|
								 SPX_CONNFILE_NEG	|
								 SPX_CONNFILE_STREAM));

			if ((PARAM(CONFIG_DISABLE_SPX2) == 0) &&
				(pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_SPX2))
			{
				DBGPRINT(CONNECT, DBG,
						("SpxConnConnect: SPX2 requested %lx\n",
							pSpxConnFile));

				SPX_CONN_SETFLAG(
					pSpxConnFile, (SPX_CONNFILE_SPX2 | SPX_CONNFILE_NEG));
			}

			if (pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_STREAM)
			{
				DBGPRINT(CONNECT, DBG,
						("SpxConnConnect: SOCK_STREAM requested %lx\n",
							pSpxConnFile));

				SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_STREAM);
			}

			if (pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_NOACKWAIT)
			{
				DBGPRINT(CONNECT, ERR,
						("SpxConnConnect: NOACKWAIT requested %lx\n",
							pSpxConnFile));

				SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_NOACKWAIT);
			}

			if (pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_IPXHDR)
			{
				DBGPRINT(CONNECT, ERR,
						("spxConnHandleConnReq: IPXHDR requested %lx\n",
							pSpxConnFile));

				SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_IPXHDR);
			}
		}
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
	
	} while (FALSE);

	if (!NT_SUCCESS(status))
	{
		DBGPRINT(CONNECT, ERR,
				("SpxConnConnect: Failed %lx\n", status));

		if (pFindRouteReq)
		{
			SpxFreeMemory(pFindRouteReq);
		}

		return(status);
	}

	CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
	CTEGetLock(&pSpxAddr->sa_Lock, &lockHandleAddr);
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
	locksHeld = TRUE;

	status = STATUS_INVALID_CONNECTION;
	if (SPX_CONN_IDLE(pSpxConnFile) &&
		((pSpxConnFile->scf_LocalConnId = spxConnGetId()) != 0))
	{
        //
        // If this was a post-inactivated file, clear the disconnect flags
        //
        if ((SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
            (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED)) {

            SPX_DISC_SETSTATE(pSpxConnFile, 0);
        }

		SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_CONNECTING);
		pSpxConnFile->scf_CRetryCount 	= PARAM(CONFIG_CONNECTION_COUNT);

		if (((USHORT)PARAM(CONFIG_WINDOW_SIZE) == 0) ||
            ((USHORT)PARAM(CONFIG_WINDOW_SIZE) > MAX_WINDOW_SIZE))
		{
            PARAM(CONFIG_WINDOW_SIZE) = DEFAULT_WINDOW_SIZE;
		}

		pSpxConnFile->scf_SentAllocNum	= (USHORT)(PARAM(CONFIG_WINDOW_SIZE) - 1);

		//	Move connection from inactive list to non-inactive list.
		if (!NT_SUCCESS(spxConnRemoveFromList(
							&pSpxAddr->sa_InactiveConnList,
							pSpxConnFile)))
		{
			//	This should never happen!
			KeBugCheck(0);
		}

		//	Put connection in the non-inactive list. Connection id must be set.
		SPX_INSERT_ADDR_ACTIVE(
			pSpxAddr,
			pSpxConnFile);

		//	 Insert in the global connection tree on device
		spxConnInsertIntoGlobalActiveList(
			pSpxConnFile);

		//	Store the remote address in the connection.
		//	!!NOTE!! We get both the network/socket in network form.
		*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) =
			*((UNALIGNED ULONG *)(&pTdiAddr->NetworkAddress));

		RtlCopyMemory(
			pSpxConnFile->scf_RemAddr+4,
			pTdiAddr->NodeAddress,
			6);

		*((UNALIGNED USHORT *)(pSpxConnFile->scf_RemAddr+10)) =
			*((UNALIGNED USHORT *)(&pTdiAddr->Socket));

		//	Ok, we are all set, build connect packet, queue it into connection
		//	with the connect request. Ndis buffer already describes this memory
		//	Build IPX header.

        pCrPkt = NULL;   // so it knows to allocate one.

		SpxPktBuildCr(
			pSpxConnFile,
			pSpxAddr,
			&pCrPkt,
			SPX_SENDPKT_IDLE,
			SPX2_CONN(pSpxConnFile));

		if (pCrPkt != NULL)
		{
    		//	Remember the request in the connection
            //
            // Dont queue for the failure case since we complete it in SpxInternalDispatch.
            //
    		InsertTailList(
    			&pSpxConnFile->scf_ReqLinkage,
    			REQUEST_LINKAGE(pRequest));

			SpxConnQueueSendPktTail(pSpxConnFile, pCrPkt);
	
            //
            // Get the MDL that points to the IPX/SPX header. (the second one)
            //
             
            NdisQueryPacket(pCrPkt, NULL, NULL, &NdisBuf, NULL);
            NdisGetNextBuffer(NdisBuf, &NdisBuf2);
            NdisQueryBufferSafe(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen, HighPagePriority);
			ASSERT(pIpxSpxHdr != NULL);	// Can't fail since it is already mapped
			
#if OWN_PKT_POOLS
            pIpxSpxHdr	= (PIPXSPX_HDR)((PBYTE)pCrPkt +
										NDIS_PACKET_SIZE +
										sizeof(SPX_SEND_RESD) +
										IpxInclHdrOffset);
#endif	
			//	Initialize the find route request
			*((UNALIGNED ULONG *)pFindRouteReq->fr_FindRouteReq.Network)=
				*((UNALIGNED ULONG *)pIpxSpxHdr->hdr_DestNet);

         //
         // [SA] Bug #15094
         // We need to also pass in the node number to IPX so that IPX can
         // compare the node addresses to determine the proper WAN NICid
         //

         // RtlCopyMemory (pFindRouteReq->fr_FindRouteReq.Node, pIpxSpxHdr->hdr_DestNode, 6) ;

           *((UNALIGNED ULONG *)pFindRouteReq->fr_FindRouteReq.Node)=
		    *((UNALIGNED ULONG *)pIpxSpxHdr->hdr_DestNode);

		 *((UNALIGNED USHORT *)(pFindRouteReq->fr_FindRouteReq.Node+4))=
		    *((UNALIGNED USHORT *)(pIpxSpxHdr->hdr_DestNode+4));

		 DBGPRINT(CONNECT, DBG,
					("SpxConnConnect: NETWORK %lx\n",
						*((UNALIGNED ULONG *)pIpxSpxHdr->hdr_DestNet)));

		 DBGPRINT(CONNECT, DBG,
					("SpxConnConnect: NODE %02x-%02x-%02x-%02x-%02x-%02x\n",
					   pFindRouteReq->fr_FindRouteReq.Node[0], pFindRouteReq->fr_FindRouteReq.Node[1],
                       pFindRouteReq->fr_FindRouteReq.Node[2], pFindRouteReq->fr_FindRouteReq.Node[3],
                       pFindRouteReq->fr_FindRouteReq.Node[4], pFindRouteReq->fr_FindRouteReq.Node[5]));

         pFindRouteReq->fr_FindRouteReq.Identifier 	= IDENTIFIER_SPX;
			pFindRouteReq->fr_Ctx						= pSpxConnFile;

			//	We wont force a rip for every connection. Only if its not
			//	in the IPX database.
            pFindRouteReq->fr_FindRouteReq.Type	 = IPX_FIND_ROUTE_RIP_IF_NEEDED;

			//	Reference for the find route. So that abort connect wont
			//	free up the connection until we return from here.
			SpxConnFileLockReference(pSpxConnFile, CFREF_FINDROUTE);
			status = STATUS_PENDING;
		}
		else
		{
			//	Abort connect attempt.
			spxConnAbortConnect(
				pSpxConnFile,
				status,
				lockHandleDev,
				lockHandleAddr,
				lockHandleConn);

            CTEAssert(pSpxConnFile->scf_ConnectReq == NULL);

			locksHeld = FALSE;
			status = STATUS_INSUFFICIENT_RESOURCES;
		}
	}

	if (locksHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
		CTEFreeLock(&pSpxAddr->sa_Lock, lockHandleAddr);
		CTEFreeLock(&SpxDevice->dev_Lock, lockHandleDev);
	}

	if (NT_SUCCESS(status))
	{
		//	Start off the find route request, We send the packet in completion.
		//	The verify reference is kept until the connect request completes.
        //  If connecting to network 0 we don't do this, proceed to find
        //  route completion which will send the request on very card.

		if (*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0) {

            SpxFindRouteComplete(
                &pFindRouteReq->fr_FindRouteReq,
                TRUE);

        } else {

    		(*IpxFindRoute)(
    			&pFindRouteReq->fr_FindRouteReq);
        }
	}
	else
	{
		DBGPRINT(CONNECT, ERR,
				("SpxConnConnect: Failed %lx\n", status));

		SpxFreeMemory(pFindRouteReq);
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	return(status);
}




NTSTATUS
SpxConnListen(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)

/*++

Routine Description:


Arguments:

	We assume the connection passed in is already associated with an address.
	If it is not, we will die! Is that ok?

Return Value:


--*/

{
	NTSTATUS						status;
	CTELockHandle					lockHandle1, lockHandle2;
	PSPX_ADDR						pSpxAddr;

	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

	//	Check if the connection is in a valid state
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		return(status);
	}

	//	Check if connection is associated, if so, the association cannot
	//	go away until the reference above is removed. So we are safe in
	//	releasing the lock.
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle2);
	status = STATUS_INVALID_ADDRESS;
	if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC))
	{
		status		= STATUS_SUCCESS;
		pSpxAddr	= pSpxConnFile->scf_AddrFile->saf_Addr;

		//	See if this connection is to be a spx2 connection.
		SPX_CONN_RESETFLAG(pSpxConnFile,
							(SPX_CONNFILE_SPX2 	|
							 SPX_CONNFILE_NEG	|
							 SPX_CONNFILE_STREAM));

		if (pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_SPX2)
		{
			SPX_CONN_SETFLAG(
				pSpxConnFile, (SPX_CONNFILE_SPX2 | SPX_CONNFILE_NEG));
		}

		if (pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_STREAM)
		{
			SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_STREAM);
		}

		if (pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_NOACKWAIT)
		{
			DBGPRINT(CONNECT, ERR,
					("SpxConnConnect: NOACKWAIT requested %lx\n",
						pSpxConnFile));

			SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_NOACKWAIT);
		}

		if (pSpxConnFile->scf_AddrFile->saf_Flags & SPX_ADDRFILE_IPXHDR)
		{
			DBGPRINT(CONNECT, ERR,
					("spxConnHandleConnReq: IPXHDR requested %lx\n",
						pSpxConnFile));
	
			SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_IPXHDR);
		}
	}
	CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle2);

	if (NT_SUCCESS(status))
	{
		CTEGetLock(&pSpxAddr->sa_Lock, &lockHandle1);
		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle2);
		status = STATUS_INVALID_CONNECTION;
		if (SPX_CONN_IDLE(pSpxConnFile))
		{
			SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_LISTENING);
	
			//	Move connection from inactive list to listening list.
			if (NT_SUCCESS(spxConnRemoveFromList(
								&pSpxAddr->sa_InactiveConnList,
								pSpxConnFile)))
			{
				//	Put connection in the listening list.
				SPX_INSERT_ADDR_LISTEN(pSpxAddr, pSpxConnFile);
		
				InsertTailList(
					&pSpxConnFile->scf_ReqLinkage,
					REQUEST_LINKAGE(pRequest));
		
				status = STATUS_PENDING;
			}
			else
			{
				//	This should never happen!
				KeBugCheck(0);
			}
		}
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle2);
		CTEFreeLock(&pSpxAddr->sa_Lock, lockHandle1);
	}


	if (!NT_SUCCESS(status))
	{
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	return(status);
}




NTSTATUS
SpxConnAccept(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PSPX_ADDR 		pSpxAddr;
	NTSTATUS		status;
	CTELockHandle	lockHandleConn, lockHandleAddr, lockHandleDev;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

	DBGPRINT(CONNECT, DBG,
			("SpxConnAccept: %lx\n", pSpxConnFile));

	//	Check if the connection is in a valid state
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		return (status);
	}

	//	Check if we are in the correct state and associated.
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
	status = STATUS_INVALID_CONNECTION;
	if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC))
	{
		status		= STATUS_SUCCESS;
		pSpxAddr	= pSpxConnFile->scf_AddrFile->saf_Addr;
	}
	CTEFreeLock (&pSpxConnFile->scf_Lock, lockHandleConn);

	if (NT_SUCCESS(status))
	{
		//	Grab all three locks
		CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
		CTEGetLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, &lockHandleAddr);
		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);

		status = STATUS_INVALID_CONNECTION;
		if ((SPX_CONN_LISTENING(pSpxConnFile)) &&
			(SPX_LISTEN_STATE(pSpxConnFile) == SPX_LISTEN_RECDREQ))
		{
			InsertTailList(
				&pSpxConnFile->scf_ReqLinkage,
				REQUEST_LINKAGE(pRequest));
	
			//	Call acceptcr now.
			spxConnAcceptCr(
					pSpxConnFile,
					pSpxAddr,
					lockHandleDev,
					lockHandleAddr,
					lockHandleConn);
	
			DBGPRINT(CONNECT, DBG,
					("SpxConnAccept: Accepted\n"));
	
			status = STATUS_PENDING;
		}
		else
		{
			//	Free all locks.
			CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
			CTEFreeLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
			CTEFreeLock(&SpxDevice->dev_Lock, lockHandleDev);
		}
	}

	//	Remove reference. Note: Listen reference will exist if ok. And that will
	//	be transferred to the fact that the connection is active when accepted.
	SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	return(status);
}




NTSTATUS
SpxConnDisconnect(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)
/*++

Routine Description:

	If active, we do the following.
	If informative disconnect, just remember the request in the connection.
	We do not ref for request. Assume it will always be checked for when
	changing from disconnect to idle.

Arguments:


Return Value:


--*/
{
	PTDI_REQUEST_KERNEL_DISCONNECT 	pParam;
	NTSTATUS						status;
	CTELockHandle					lockHandleConn;
	BOOLEAN							lockHeld;
	SPX_SENDREQ_TYPE				reqType;
	int								numDerefs = 0;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

	pParam 	= (PTDI_REQUEST_KERNEL_DISCONNECT)REQUEST_PARAMETERS(pRequest);

	//	Check if the connection is in a valid state
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		return(status);
	}

	//	Deref unless the disc request gets queued in as a send request.
	numDerefs++;

	DBGPRINT(CONNECT, DBG,
			("spxConnDisconnect: %lx On %lx when %lx.%lx %lx Params %lx\n",
				pRequest, pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile),
				SPX_DISC_STATE(pSpxConnFile),
				SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC),
                SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_ODISC),
				pParam->RequestFlags));

	DBGPRINT(CONNECT, DBG,
			("SpxConnDisconnect: %lx\n", pSpxConnFile));

	//	Check if we are in the correct state and associated.
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
	lockHeld = TRUE;
	switch (pParam->RequestFlags)
	{
	case TDI_DISCONNECT_WAIT:

		//	If informative disconnect, just remember in the connection.
		status = STATUS_INVALID_CONNECTION;
		if (!SPX_CONN_IDLE(pSpxConnFile))
		{
			InsertTailList(
				&pSpxConnFile->scf_DiscLinkage,
				REQUEST_LINKAGE(pRequest));

			status = STATUS_PENDING;
		}
	
		break;

	case TDI_DISCONNECT_ABORT:
	case TDI_DISCONNECT_RELEASE:

		//	NOTE! We don't honor the async disconnect symantics of tdi
		//		  but map them to an abortive disconnect.
		//	NOTE! If our send list is not empty but our client tries to
		//		  do a orderly release, we just queue the ord rel as a send
		//		  data request. In process ack, we check for the next packet
		//		  to not be a ord rel before giving up on window closure.
		//	NOTE! For spx1 connection, map TDI_DISCONNECT_RELEASE to
		//		  TDI_DISCONNECT_ABORT (Informed disconnect)

		if (!SPX2_CONN(pSpxConnFile))
		{
			pParam->RequestFlags = TDI_DISCONNECT_ABORT;
		}

		switch (SPX_MAIN_STATE(pSpxConnFile))
		{
		case SPX_CONNFILE_ACTIVE:
	
			//	Since we are not a timer disconnect, then we need to keep
			//	retrying the disconnect packet. Change state to DISCONN if this
			//	is not an orderly release or we previously received an orderly
			//	release and are now confirming it.
			//	Retry timer will now keep sending out the disconnect packet.

			reqType = SPX_REQ_DISC;
			if (pParam->RequestFlags == TDI_DISCONNECT_RELEASE)
			{
				SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_POST_ORDREL);
                reqType = SPX_REQ_ORDREL;
			}
			else
			{
				//	Abortive disconnect
				SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_DISCONN);
				SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_POST_IDISC);
				numDerefs++;

				spxConnAbortSends(
					pSpxConnFile,
					STATUS_LOCAL_DISCONNECT,
					SPX_CALL_TDILEVEL,
					lockHandleConn);
	
				CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);

				//	Abort all receives if we are informed disconnect.
				spxConnAbortRecvs(
					pSpxConnFile,
					STATUS_LOCAL_DISCONNECT,
					SPX_CALL_TDILEVEL,
					lockHandleConn);
	
				CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);

				//	Since we released the lock, a remote IDISC could have come
				//	in in which case we really don't want to queue in the disc
				//	request. Instead, we set it as the disc request in the
				//	connection if one is not already there.
				if (SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_POST_IDISC)
				{
					DBGPRINT(CONNECT, ERR,
							("SpxConnDisconnect: DISC not POST! %lx.%lx\n",
								pSpxConnFile, SPX_DISC_STATE(pSpxConnFile)));
				
					InsertTailList(
						&pSpxConnFile->scf_DiscLinkage,
						REQUEST_LINKAGE(pRequest));

					status = STATUS_PENDING;
					break;
				}
			}

			//	!NOTE
			//	AbortSends might leave send requests around as packets might
			//	have been with ipx at the time. That is why SendComplete should
			//	never call AbortSends but must call AbortPkt else it may complete
			//	the following disconnect request prematurely.

			//	Creation reference for request.
			REQUEST_INFORMATION(pRequest) = 1;
	
			//	If we have no current requests, queue it in and
			//	set it to be the current request, else just queue it in.
			//	There may be other pending requests in queue.	
			if (pSpxConnFile->scf_ReqPkt == NULL)
			{
				pSpxConnFile->scf_ReqPkt 		= pRequest;
				pSpxConnFile->scf_ReqPktOffset 	= 0;
				pSpxConnFile->scf_ReqPktSize 	= 0;
				pSpxConnFile->scf_ReqPktType	= reqType;
			}
	
			InsertTailList(
				&pSpxConnFile->scf_ReqLinkage,
				REQUEST_LINKAGE(pRequest));

			//	Do not deref the connection, it is taken by the pending request
			numDerefs--;

			//	We packetize only upto the window we have.
			if (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE)
			{
				SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_PACKETIZE);
				SpxConnPacketize(
					pSpxConnFile,
					TRUE,
					lockHandleConn);

				lockHeld = FALSE;
			}

			status	  = STATUS_PENDING;
			break;
	
		case SPX_CONNFILE_CONNECTING:
		case SPX_CONNFILE_LISTENING:
	
			spxConnAbortiveDisc(
				pSpxConnFile,
				STATUS_INSUFFICIENT_RESOURCES,
				SPX_CALL_TDILEVEL,
				lockHandleConn,
                FALSE);         // [SA] Bug #15249
	
			lockHeld = FALSE;
			status = STATUS_SUCCESS;
			break;

		case SPX_CONNFILE_DISCONN:

			//	When we queue in a disconnect as a send request, we expect
			//	to be able to set it into the scf_DiscReq when it is done.
			//	So we don't use scf_DiscReq here. This will be a problem if
			//	the client has a InformDiscReq pending, and a remote disconnect
			//	comes in, *and* the client then does a disc. We will be completing
			//	the request with STATUS_INVALID_CONNECTION.
			status = STATUS_INVALID_CONNECTION;
			if (pParam->RequestFlags != TDI_DISCONNECT_RELEASE)
			{
				InsertTailList(
					&pSpxConnFile->scf_DiscLinkage,
					REQUEST_LINKAGE(pRequest));

				status = STATUS_PENDING;

                //
                // If this is a disconnect for a connection which was already
                // disconnected (but AFD's disconnect handler was not called
                // because the connfile could not be placed in the inactive list),
                // set this flag so that the disconnect is not called from
                // ConnInactivate now that the disconnect has occured here.
                //
        		if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC)) {
                    SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC);
                }

                //
                // If this was an SPXI connection where we indicated TDI_DISCONNECT_RELEASE
                // to AFD, the ref count was bumped up to indicate a wait for local disconnect
                // from AFD. Now that we have this disconnect, deref the connection file. Now
                // we are ready to truly inactivate this connection file.
                //
                if (SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_DISC_WAIT)) {

                    CTEAssert( (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED) &&
                                SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC));

                    CTEAssert(pSpxConnFile->scf_RefTypes[CFREF_DISCWAITSPX]);

                    SPX_CONN_RESETFLAG2(pSpxConnFile, SPX_CONNFILE2_DISC_WAIT);

            		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
                    lockHeld = FALSE;

                    SpxConnFileDereference(pSpxConnFile, CFREF_DISCWAITSPX);
                }
			}

			break;

		default:
	
			//	Should never happen!
			status = STATUS_INVALID_CONNECTION;
		}
	
		break;

	default:

		status = STATUS_INVALID_PARAMETER;
		break;
	}

	if (lockHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
	}

	DBGPRINT(CONNECT, INFO,
			("SpxConnDisconnect: returning for %lx.%lx\n", pSpxConnFile, status));

	while (numDerefs-- > 0)
	{
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	return(status);
}		




NTSTATUS
SpxConnSend(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PTDI_REQUEST_KERNEL_SEND	 	pParam;
	NTSTATUS						status;
	CTELockHandle					lockHandleConn;
	BOOLEAN							lockHeld;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

	pParam 	= (PTDI_REQUEST_KERNEL_SEND)REQUEST_PARAMETERS(pRequest);

	//	Check if the connection is in a valid state
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		return(status);
	}

	DBGPRINT(SEND, DBG,
			("SpxConnSend: %lx.%lx.%lx.%lx\n",
				pSpxConnFile, pRequest, pParam->SendLength, pParam->SendFlags));


	//	Check if we are in the correct state and associated.
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
	lockHeld 	= TRUE;

	DBGPRINT(SEND, INFO,
			("Send: %lx.%lx.%lx\n",
				pParam->SendLength, pParam->SendFlags, pRequest));

	status		= STATUS_PENDING;
	do
	{
		if (SPX_CONN_ACTIVE(pSpxConnFile) &&
			((SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_POST_ORDREL) &&
			 (SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_SENT_ORDREL) &&
			 (SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_ORDREL_ACKED)))
		{
			//	Creation reference for request.
			REQUEST_INFORMATION(pRequest) = 1;
	
			//	If we have no current requests, queue it in and
			//	set it to be the current request, else just queue it in.
			//	There may be other pending requests in queue.	
			if (pSpxConnFile->scf_ReqPkt == NULL)
			{
				DBGPRINT(SEND, INFO,
						("%lx\n",
							pRequest));

				pSpxConnFile->scf_ReqPkt 		= pRequest;
				pSpxConnFile->scf_ReqPktOffset 	= 0;
				pSpxConnFile->scf_ReqPktSize 	= pParam->SendLength;
				pSpxConnFile->scf_ReqPktFlags	= pParam->SendFlags;
				pSpxConnFile->scf_ReqPktType	= SPX_REQ_DATA;
			}
	
			InsertTailList(
				&pSpxConnFile->scf_ReqLinkage,
				REQUEST_LINKAGE(pRequest));
		}
		else
		{
            //
            // [SA] Bug #14655
            // Return the correct error message in case a send fails due to remote disconnect
            //

            if ((SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
                ((SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_ABORT) ||
                (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED)))
            {
                status = STATUS_REMOTE_DISCONNECT ;
            }
            else
            {
                status = STATUS_INVALID_CONNECTION;
            }

        	break;
		}

		//	We packetize only upto the window we have.
		if (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE)
		{
			SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_PACKETIZE);
			SpxConnPacketize(pSpxConnFile, TRUE, lockHandleConn);
			lockHeld = FALSE;
		}

	} while (FALSE);


	if (lockHeld)
	{
		CTEFreeLock (&pSpxConnFile->scf_Lock, lockHandleConn);
	}

	if (!NT_SUCCESS(status))
	{
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	return(status);
}




NTSTATUS
SpxConnRecv(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS		status;
	CTELockHandle	lockHandle;
	BOOLEAN			fLockHeld;
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

	//	Check if the connection is in a valid state
	if ((status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
	{
		return(status);
	}

	DBGPRINT(CONNECT, DBG,
			("SpxConnReceive: %lx.%lx\n", pSpxConnFile, pRequest));

	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
	fLockHeld	= TRUE;
	status		= STATUS_INVALID_CONNECTION;
	if (SPX_CONN_ACTIVE(pSpxConnFile) &&
		!(SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_ODISC)))
	{
		status = STATUS_PENDING;

		//	This routine adds its own reference.
		SpxConnQueueRecv(pSpxConnFile, pRequest);
	
		//	If recv pkt queue is non-empty then we have buffered data. Call
		//	process pkts/receives.
		if ((SPX_RECV_STATE(pSpxConnFile) == SPX_RECV_IDLE) ||
            (SPX_RECV_STATE(pSpxConnFile) == SPX_RECV_POSTED))
		{
			SpxRecvProcessPkts(pSpxConnFile, lockHandle);
			fLockHeld	= FALSE;
		}
	}

	if (fLockHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
	}

	SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	return(status);
}




NTSTATUS
SpxConnAction(
    IN 	PDEVICE 			pDevice,
    IN 	PREQUEST 			pRequest
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    NTSTATUS 		Status;
    UINT 			BufferLength;
    UINT 			DataLength;
    PNDIS_BUFFER 	NdisBuffer;
    PNWLINK_ACTION 	NwlinkAction;
	CTELockHandle	lockHandle;
    PIPX_SPXCONNSTATUS_DATA	pGetStats;
    PSPX_CONN_FILE 	pSpxConnFile	= NULL;
	PSPX_ADDR_FILE	pSpxAddrFile	= NULL;
    static UCHAR BogusId[4] = { 0x01, 0x00, 0x00, 0x00 };   // old nwrdr uses this

    //
    // To maintain some compatibility with the NWLINK streams-
    // based transport, we use the streams header format for
    // our actions. The old transport expected the action header
    // to be in InputBuffer and the output to go in OutputBuffer.
    // We follow the TDI spec, which states that OutputBuffer
    // is used for both input and output. Since IOCTL_TDI_ACTION
    // is method out direct, this means that the output buffer
    // is mapped by the MDL chain; for action the chain will
    // only have one piece so we use it for input and output.
    //

    NdisBuffer = REQUEST_NDIS_BUFFER(pRequest);
    if (NdisBuffer == NULL)
	{
        return STATUS_INVALID_PARAMETER;
    }

    NdisQueryBufferSafe(
		REQUEST_NDIS_BUFFER(pRequest), (PVOID *)&NwlinkAction, &BufferLength, LowPagePriority);
	if (NwlinkAction == NULL)
	{
		return(STATUS_INSUFFICIENT_RESOURCES);
	}

    // Make sure we have enough room for just the header not
    // including the data.
    if (BufferLength < (UINT)(FIELD_OFFSET(NWLINK_ACTION, Data[0])))
    {
        DBGPRINT(ACTION, ERR,
		 ("Nwlink action failed, buffer too small\n"));

        return STATUS_BUFFER_TOO_SMALL;
    }

    if ((!RtlEqualMemory ((PVOID)(&NwlinkAction->Header.TransportId), "MISN", 4)) &&
        (!RtlEqualMemory ((PVOID)(&NwlinkAction->Header.TransportId), "MIPX", 4)) &&
        (!RtlEqualMemory ((PVOID)(&NwlinkAction->Header.TransportId), "XPIM", 4)) &&
        (!RtlEqualMemory ((PVOID)(&NwlinkAction->Header.TransportId), BogusId, 4))) {
        return STATUS_NOT_SUPPORTED;
    }


    DataLength = BufferLength - FIELD_OFFSET(NWLINK_ACTION, Data[0]);

    // Make sure that the correct file object is being used.
	switch (NwlinkAction->OptionType)
	{
	case NWLINK_OPTION_CONNECTION:

        if (REQUEST_OPEN_TYPE(pRequest) != (PVOID)TDI_CONNECTION_FILE)
		{
            DBGPRINT(ACTION, ERR,
					("Nwlink action failed, not connection file\n"));

            return STATUS_INVALID_HANDLE;
        }

        pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(pRequest);

		if ((Status = SpxConnFileVerify(pSpxConnFile)) != STATUS_SUCCESS)
			return(Status);

		break;

	case NWLINK_OPTION_ADDRESS:

        if (REQUEST_OPEN_TYPE(pRequest) != (PVOID)TDI_TRANSPORT_ADDRESS_FILE)
		{
            DBGPRINT(ACTION, ERR,
					("Nwlink action failed, not address file\n"));

            return STATUS_INVALID_HANDLE;
        }

        pSpxAddrFile = (PSPX_ADDR_FILE)REQUEST_OPEN_CONTEXT(pRequest);

		if ((Status = SpxAddrFileVerify(pSpxAddrFile)) != STATUS_SUCCESS)
			return(Status);

		break;

	default:

        DBGPRINT(ACTION, ERR,
				("Nwlink action failed, option type %d\n",
					NwlinkAction->OptionType));

		return STATUS_INVALID_HANDLE;
	}

    // Handle the requests based on the action code. For these
    // requests ActionHeader->ActionCode is 0, we use the
    // Option field in the streams header instead.

    Status = STATUS_SUCCESS;

	DBGPRINT(ACTION, INFO,
			("SpxConnAction: Option %x\n", NwlinkAction->Option));

    switch (NwlinkAction->Option)
	{

    //
    // This first group support the winsock helper dll.
    // In most cases the corresponding sockopt is shown in
    // the comment, as well as the contents of the Data
    // part of the action buffer.
    //

    case MSPX_SETDATASTREAM:

		if (pSpxConnFile == NULL)
		{
			Status = STATUS_INVALID_HANDLE;
			break;
		}

        if (DataLength >= 1)
		{
            DBGPRINT(ACTION, INFO,
					("%lx: MIPX_SETSENDPTYPE %x\n",
						pSpxConnFile, NwlinkAction->Data[0]));

			pSpxConnFile->scf_DataType = NwlinkAction->Data[0];
        }
		else
		{
            Status = STATUS_BUFFER_TOO_SMALL;
        }

        break;

    case MSPX_SENDHEADER:

        DBGPRINT(ACTION, INFO,
				("%lx: MSPX_SENDHEADER\n", pSpxAddrFile));

		if (pSpxAddrFile == NULL)
		{
			  Status = STATUS_INVALID_HANDLE;
              break;
		}

		   CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandle);
		   pSpxAddrFile->saf_Flags |= SPX_ADDRFILE_IPXHDR;
		   CTEFreeLock(pSpxAddrFile->saf_AddrLock, lockHandle);
           break ;

    case MSPX_NOSENDHEADER:

        DBGPRINT(ACTION, INFO,
				("%lx: MSPX_NOSENDHEADER\n", pSpxAddrFile));

		if (pSpxAddrFile == NULL)
		{
                 Status = STATUS_INVALID_HANDLE;
                 break;
		}

		   CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandle);
		   pSpxAddrFile->saf_Flags &= ~SPX_ADDRFILE_IPXHDR;
		   CTEFreeLock(pSpxAddrFile->saf_AddrLock, lockHandle);
           break;

	case MSPX_GETSTATS:

        DBGPRINT(ACTION, INFO,
				("%lx: MSPX_GETSTATS\n", pSpxConnFile));


		if (pSpxConnFile == NULL)
		{
		   Status = STATUS_INVALID_HANDLE;
                   DBGPRINT(ACTION, INFO,
				("pSpxConnFile is NULL. %lx: MSPX_GETSTATS\n", pSpxConnFile));
		   break;
		}

		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
		if (!SPX_CONN_IDLE(pSpxConnFile))
		{
            USHORT TempRetryCount;

            //
            // Status fields are returned in network order.
            //

			pGetStats = (PIPX_SPXCONNSTATUS_DATA)&NwlinkAction->Data[0];

            switch (SPX_MAIN_STATE(pSpxConnFile)) {
            case SPX_CONNFILE_LISTENING: pGetStats->ConnectionState = 1; break;
            case SPX_CONNFILE_CONNECTING: pGetStats->ConnectionState = 2; break;
            case SPX_CONNFILE_ACTIVE: pGetStats->ConnectionState = 3; break;
            case SPX_CONNFILE_DISCONN: pGetStats->ConnectionState = 4; break;
            default: pGetStats->ConnectionState = 0;
            }
			pGetStats->WatchDogActive		= 1;	// Always 1
			GETSHORT2SHORT(                    // scf_LocalConnId is in host order
				&pGetStats->LocalConnectionId,
				&pSpxConnFile->scf_LocalConnId);
			pGetStats->RemoteConnectionId		= pSpxConnFile->scf_RemConnId;
	
			GETSHORT2SHORT(&pGetStats->LocalSequenceNumber, &pSpxConnFile->scf_SendSeqNum);
			GETSHORT2SHORT(&pGetStats->LocalAckNumber, &pSpxConnFile->scf_RecvSeqNum);
			GETSHORT2SHORT(&pGetStats->LocalAllocNumber, &pSpxConnFile->scf_SentAllocNum);
			GETSHORT2SHORT(&pGetStats->RemoteAckNumber, &pSpxConnFile->scf_RecdAckNum);
			GETSHORT2SHORT(&pGetStats->RemoteAllocNumber, &pSpxConnFile->scf_RecdAllocNum);

			pGetStats->LocalSocket = pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket;
	
			RtlZeroMemory(pGetStats->ImmediateAddress, 6);

			//	Remote network returned in net order.
			*((ULONG UNALIGNED *)pGetStats->RemoteNetwork) =
				*((ULONG UNALIGNED *)pSpxConnFile->scf_RemAddr);
	
			RtlCopyMemory(
				pGetStats->RemoteNode,
				&pSpxConnFile->scf_RemAddr[4],
				6);
	
			pGetStats->RemoteSocket = *((UNALIGNED USHORT *)(pSpxConnFile->scf_RemAddr+10));
	
			TempRetryCount = (USHORT)pSpxConnFile->scf_WRetryCount;
			GETSHORT2SHORT(&pGetStats->RetransmissionCount, &TempRetryCount);
			GETSHORT2SHORT(&pGetStats->EstimatedRoundTripDelay, &pSpxConnFile->scf_BaseT1);
			pGetStats->RetransmittedPackets		= 0;
			pGetStats->SuppressedPacket			= 0;

			DBGPRINT(ACTION, INFO,
					("SSeq %lx RSeq %lx RecdAck %lx RemAllocNum %lx\n",
						pGetStats->LocalSequenceNumber,
						pGetStats->LocalAckNumber,
						pGetStats->RemoteAckNumber,
						pGetStats->RemoteAllocNumber));
	
			DBGPRINT(ACTION, INFO,
					("LocalSkt %lx RemSkt %lx LocConnId %lx RemConnId %lx\n",
						pGetStats->LocalSocket,
						pGetStats->RemoteSocket,
                        pGetStats->LocalConnectionId,
						pGetStats->RemoteConnectionId));
		}
		else
		{
			Status = STATUS_INVALID_CONNECTION;
		}

		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
        break;

	case MSPX_NOACKWAIT:

        DBGPRINT(ACTION, ERR,
				("%lx: MSPX_NOACKWAIT\n", pSpxAddrFile));

		if (pSpxAddrFile == NULL)
		{
			Status = STATUS_INVALID_HANDLE;
			break;
		}

		CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandle);
		pSpxAddrFile->saf_Flags |= SPX_ADDRFILE_NOACKWAIT;
		CTEFreeLock(pSpxAddrFile->saf_AddrLock, lockHandle);
		break;

	case MSPX_ACKWAIT:

        DBGPRINT(ACTION, ERR,
				("%lx: MSPX_ACKWAIT\n", pSpxAddrFile));

		if (pSpxAddrFile == NULL)
		{
			Status = STATUS_INVALID_HANDLE;
			break;
		}

		CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandle);
		pSpxAddrFile->saf_Flags &= ~SPX_ADDRFILE_NOACKWAIT;
		CTEFreeLock(pSpxAddrFile->saf_AddrLock, lockHandle);
		break;


    //
    // These are new for ISN (not supported in NWLINK).
    //

    // The Option was not supported, so fail.
    default:

        Status = STATUS_NOT_SUPPORTED;
        break;


    }   // end of the long switch on NwlinkAction->Option


#if DBG
    if (Status != STATUS_SUCCESS) {
        DBGPRINT(ACTION, ERR,
				("Nwlink action %lx failed, status %lx\n",
					NwlinkAction->Option, Status));
    }

#endif

	if (pSpxConnFile)
	{
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	if (pSpxAddrFile)
	{
		SpxAddrFileDereference(pSpxAddrFile, AFREF_VERIFY);
	}

    return Status;
}




VOID
SpxConnConnectFindRouteComplete(
	IN	PSPX_CONN_FILE			pSpxConnFile,
    IN 	PSPX_FIND_ROUTE_REQUEST	pFrReq,
    IN 	BOOLEAN 				FoundRoute,
	IN	CTELockHandle			LockHandle
	)
/*++

Routine Description:

	This routine is called with the connection lock held and the conn refd.
	It should deal with both.

Arguments:


Return Value:


--*/
{
	PNDIS_PACKET	pCrPkt;
	PSPX_SEND_RESD	pSendResd;
    ULONG           Timeout;
	NTSTATUS		status = STATUS_BAD_NETWORK_PATH;

	pSendResd	= pSpxConnFile->scf_SendListHead;

	if (pSendResd == NULL) {

	   CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandle);

	   //  Remove the reference for the call.
	   SpxConnFileDereference(pSpxConnFile, CFREF_FINDROUTE);

	   return; 
	} 

	pCrPkt	 = (PNDIS_PACKET)CONTAINING_RECORD(
								pSendResd, NDIS_PACKET, ProtocolReserved);

	DBGPRINT(CONNECT, INFO,
			("SpxConnConnectFindRouteComplete: %lx.%d\n",
				pSpxConnFile, FoundRoute));
	
#if defined(_PNP_POWER)

    Timeout = PARAM(CONFIG_CONNECTION_TIMEOUT) * HALFSEC_TO_MS_FACTOR;
#else
	if (*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0) {

        // Here we are going to send on every NIC ID. We adjust the
        // timeout down so that a full run through all the NIC IDs will
        // take one normal timeout. We don't adjust the timer below
        // 100 ms however.

	    Timeout = (PARAM(CONFIG_CONNECTION_TIMEOUT) * HALFSEC_TO_MS_FACTOR) / SpxDevice->dev_Adapters;
        if (Timeout < (HALFSEC_TO_MS_FACTOR/5)) {
            Timeout = HALFSEC_TO_MS_FACTOR / 5;
        }

    } else {

	    Timeout = PARAM(CONFIG_CONNECTION_TIMEOUT) * HALFSEC_TO_MS_FACTOR;
    }
#endif


	//	Timeout value is in half-seconds
	if ((FoundRoute) &&
		((pSpxConnFile->scf_CTimerId =
			SpxTimerScheduleEvent(
				spxConnConnectTimer,
				Timeout,
				pSpxConnFile)) != 0))
	{
		//	Add a reference for the connect timer
		SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);


		//	If the mac address in local target is all zeros, fill it with our
		//	destination address. Also if this is a connect to network 0 fill
        //  it in with the destination address, and further down we will loop
        //  through all possible NIC IDs.
		if (((*((UNALIGNED ULONG *)
				(pFrReq->fr_FindRouteReq.LocalTarget.MacAddress)) == (ULONG)0)
			&&
			 (*((UNALIGNED USHORT *)
				(pFrReq->fr_FindRouteReq.LocalTarget.MacAddress+4)) == (USHORT)0))
            ||
    		(*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0))
		{
			DBGPRINT(CONNECT, INFO,
					("SpxConnConnectFindRouteComplete: LOCAL NET\n"));

			RtlCopyMemory(
				pFrReq->fr_FindRouteReq.LocalTarget.MacAddress,
				pSpxConnFile->scf_RemAddr+4,
				6);
		}

		//	We are all set to go ahead with the connect.
		//	Timer is started on connection
		status	= STATUS_SUCCESS;

#if defined(_PNP_POWER)
        pSpxConnFile->scf_CRetryCount	= PARAM(CONFIG_CONNECTION_COUNT);
#else
		if (*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0) {
		    pSpxConnFile->scf_CRetryCount	= PARAM(CONFIG_CONNECTION_COUNT) * SpxDevice->dev_Adapters;
        } else {
    		pSpxConnFile->scf_CRetryCount	= PARAM(CONFIG_CONNECTION_COUNT);
        }
#endif _PNP_POWER

		SPX_CONN_SETFLAG(pSpxConnFile,
						(SPX_CONNFILE_C_TIMER | SPX_CONNECT_SENTREQ));

		pSpxConnFile->scf_LocalTarget	= pFrReq->fr_FindRouteReq.LocalTarget;
		pSpxConnFile->scf_AckLocalTarget= pFrReq->fr_FindRouteReq.LocalTarget;
		if (*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0) {
#if     defined(_PNP_POWER)
            pSpxConnFile->scf_LocalTarget.NicHandle.NicId = (USHORT)ITERATIVE_NIC_ID;
            pSpxConnFile->scf_AckLocalTarget.NicHandle.NicId = (USHORT)ITERATIVE_NIC_ID;
#else
            pSpxConnFile->scf_LocalTarget.NicId = 1;
            pSpxConnFile->scf_AckLocalTarget.NicId = 1;
#endif  _PNP_POWER
        }

		//	We will be giving the packet to ipx.
		pSendResd->sr_State			   |= SPX_SENDPKT_IPXOWNS;
		CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandle);

		//	Send the packet
		SPX_SENDPACKET(pSpxConnFile, pCrPkt, pSendResd);
	}

	if (!NT_SUCCESS(status))
	{
		CTELockHandle	lockHandleConn, lockHandleAddr, lockHandleDev;

		CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandle);

		CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
		CTEGetLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, &lockHandleAddr);
		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);

		DBGPRINT(CONNECT, ERR,
				("SpxConnConnectFindRouteComplete: FAILED on %lx.%d\n",
					pSpxConnFile, FoundRoute));

		spxConnAbortConnect(
			pSpxConnFile,
			status,
			lockHandleDev,
			lockHandleAddr,
			lockHandleConn);
	}

	//	Remove the reference for the call.
	SpxConnFileDereference(pSpxConnFile, CFREF_FINDROUTE);
	return;
}




VOID
SpxConnActiveFindRouteComplete(
	IN	PSPX_CONN_FILE			pSpxConnFile,
    IN 	PSPX_FIND_ROUTE_REQUEST	pFrReq,
    IN 	BOOLEAN 				FoundRoute,
	IN	CTELockHandle			LockHandle
	)
/*++

Routine Description:

	This routine is called with the connection lock held and the conn refd.
	It should deal with both.

Arguments:


Return Value:


--*/
{
	BOOLEAN		fDisconnect = TRUE;

	SPX_CONN_RESETFLAG2(pSpxConnFile, SPX_CONNFILE2_FINDROUTE);

	DBGPRINT(CONNECT, DBG,
			("SpxConnActiveFindRouteComplete: %lx.%lx\n",
				pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));

	//	If we are disconnecting, just remove the reference and exit.
	if (SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_ACTIVE)
	{
		fDisconnect = FALSE;

		//	We are here if either the wdog or the retry timer did a find
		//	route. We need to save the info from the find route if it was
		//	successful and just restart the timers.
		if (FoundRoute)
		{
			//	If the mac address in local target is all zeros, fill it with our
			//	destination address.
			if ((*((UNALIGNED ULONG *)
				(pFrReq->fr_FindRouteReq.LocalTarget.MacAddress+2)) == (ULONG)0)
				&&
				(*((UNALIGNED USHORT *)
				(pFrReq->fr_FindRouteReq.LocalTarget.MacAddress+4)) == (USHORT)0))
			{
				DBGPRINT(CONNECT, INFO,
						("SpxConnActiveFindRouteComplete: LOCAL NET\n"));
	
				RtlCopyMemory(
					pFrReq->fr_FindRouteReq.LocalTarget.MacAddress,
					pSpxConnFile->scf_RemAddr+4,
					6);
			}
	
			pSpxConnFile->scf_LocalTarget	= pFrReq->fr_FindRouteReq.LocalTarget;
		}

		//	Depending on state restart the wdog or retry timer. Add reference
		//	for it.
		switch (SPX_SEND_STATE(pSpxConnFile))
		{
		case SPX_SEND_RETRY:

			//	Set state to SPX_SEND_RETRYWD
			SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RETRYWD);

			//	Start retry timer.
			if ((pSpxConnFile->scf_RTimerId =
					SpxTimerScheduleEvent(
						spxConnRetryTimer,
						pSpxConnFile->scf_BaseT1,
						pSpxConnFile)) != 0)
			{
				SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER);

				//	Reference connection for the timer
				SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
			}
			else
			{
				fDisconnect = TRUE;
			}

			break;

		case SPX_SEND_WD:

			//	Start watchdog timer.
			if ((pSpxConnFile->scf_WTimerId =
					SpxTimerScheduleEvent(
						spxConnWatchdogTimer,
						PARAM(CONFIG_KEEPALIVE_TIMEOUT) * HALFSEC_TO_MS_FACTOR,
						pSpxConnFile)) != 0)
			{
				//	Reference connection for the timer
				SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);
				SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
			}
			else
			{
				fDisconnect = TRUE;
			}

			break;

		case SPX_SEND_IDLE:
		case SPX_SEND_PACKETIZE:

			//	Do nothing, remove reference and leave.
			break;

		default:

			KeBugCheck(0);
		}
	}

	if (fDisconnect)
	{
		DBGPRINT(CONNECT, DBG1,
				("SpxConnActiveFindRouteComplete: DISCONNECT %lx.%lx\n",
					pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));

		//	Abortive disc will reset the funky state if necessary.
		spxConnAbortiveDisc(
			pSpxConnFile,
			STATUS_INSUFFICIENT_RESOURCES,
			SPX_CALL_TDILEVEL,
			LockHandle,
            FALSE);     // [SA] Bug #15249
	}
	else
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandle);
	}

	SpxConnFileDereference(pSpxConnFile, CFREF_FINDROUTE);
	return;
}




ULONG
spxConnConnectTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown
	)
/*++

Routine Description:

 	We enter this routine during the connection attempt. We could be at any
	stage of sending either the CR or the SN packet. If we have reached the end of
	the retry count, we need to know the substate at that point. For a CR, we give
	up trying to connect, and for a SN we try the next lower packet size or if we
	have reached the minimum packet size, we give up the connect.

Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)Context;
	PNDIS_PACKET	pPkt;
	PSPX_SEND_RESD	pSendResd;
	CTELockHandle	lockHandleConn, lockHandleAddr, lockHandleDev;
	BOOLEAN			fAbort		= FALSE, locksHeld = FALSE, sendPkt     = FALSE;
	PREQUEST		pRequest	= NULL;

	//	Get all locks
	CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
	CTEGetLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, &lockHandleAddr);
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
	locksHeld = TRUE;

	DBGPRINT(CONNECT, INFO,
			("spxConnConnectTimer: Entered\n"));

	do
	{
		if ((!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_C_TIMER)) ||
			(!SPX_CONN_CONNECTING(pSpxConnFile)	&&
			 !SPX_CONN_LISTENING(pSpxConnFile)))
		{
			TimerShuttingDown = TRUE;
		}

		if (TimerShuttingDown)
		{
			break;
		}

		if (SPX_CONN_CONNECTING(pSpxConnFile))
		{
			switch (SPX_CONNECT_STATE(pSpxConnFile))
			{
            case SPX_CONNECT_SENTREQ:

				//	There should be only one packet in list, the cr.
				CTEAssert(pSpxConnFile->scf_SendListHead ==
							pSpxConnFile->scf_SendListTail);

				pSendResd	= pSpxConnFile->scf_SendListHead;
				pPkt	 	= (PNDIS_PACKET)CONTAINING_RECORD(
												pSendResd,
												NDIS_PACKET,
												ProtocolReserved);
		
				if (pSpxConnFile->scf_CRetryCount-- == 0)
				{
					//	No luck, we need to complete connect request with failure
                    ++SpxDevice->dev_Stat.NotFoundFailures;
					fAbort	= TRUE;
					break;
				}
		
				//	We need to resend the packet
				if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) != 0)
				{
					//	Try next time.
					break;
				}
		
				pSendResd->sr_State			   |= SPX_SENDPKT_IPXOWNS;
				sendPkt	= TRUE;
				break;

            case SPX_CONNECT_NEG:

				if (!spxConnGetPktByType(
						pSpxConnFile,
						SPX_TYPE_SN,
						FALSE,
						&pPkt))
				{
					KeBugCheck(0);
				}

				pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
				if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) != 0)
				{
					//	Try when we come in next.
					break;
				}
		

				//	If we have exhausted current retries, try next smaller size.
				//	If this was the smallest size, we abort.
				if (pSpxConnFile->scf_CRetryCount-- == 0)
				{
					// 	Have we tried the smallest size?
					CTEAssert(pSpxConnFile->scf_MaxPktSize > 0);
					if (!spxConnCheckNegSize(&pSpxConnFile->scf_MaxPktSize))
					{
						//	Give up! Remove negotiate packet etc.
                        ++SpxDevice->dev_Stat.SessionTimeouts;
						fAbort	= TRUE;
						break;
					}

					//	Set neg pkt size to new lower size
					spxConnSetNegSize(
						pPkt,
						pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE);

                    pSpxConnFile->scf_CRetryCount  =
											PARAM(CONFIG_CONNECTION_COUNT);
				}
		
				//	We need to resend the packet
				CTEAssert((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0);
				pSendResd->sr_State			   |= SPX_SENDPKT_IPXOWNS;
				sendPkt	= TRUE;
				break;

            case SPX_CONNECT_W_SETUP:
			default:

				DBGPRINT(CONNECT, ERR,
						("spxConnConnectTimer: state is W_Setup %lx\n",
							pSpxConnFile));

				KeBugCheck(0);
			}
		}
		else
		{
			switch (SPX_LISTEN_STATE(pSpxConnFile))
			{
            case SPX_LISTEN_SETUP:

				if (!spxConnGetPktByType(
						pSpxConnFile,
						SPX_TYPE_SS,
						FALSE,
						&pPkt))
				{
					KeBugCheck(0);
				}

				pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
				if ((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) != 0)
				{
					//	Try when we come in next.
					break;
				}

				//	If we have exhausted current retries, try next smaller size.
				//	If this was the smallest size, we abort.
				if (pSpxConnFile->scf_CRetryCount-- == 0)
				{
					// 	Have we tried the smallest size?
					if (!spxConnCheckNegSize(&pSpxConnFile->scf_MaxPktSize))
					{
						//	Give up! Remove negotiate packet etc. Have an abort
						//	kind of routine.
                        ++SpxDevice->dev_Stat.SessionTimeouts;
						fAbort	= TRUE;
						break;
					}

					//	Set neg pkt size to new lower size
					spxConnSetNegSize(
						pPkt,
						pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE);

                    pSpxConnFile->scf_CRetryCount  =
											PARAM(CONFIG_CONNECTION_COUNT);
				}
		
				//	We need to resend the packet
				CTEAssert((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) == 0);

				pSendResd->sr_State			   |= SPX_SENDPKT_IPXOWNS;
				sendPkt	= TRUE;
				break;

			default:

				KeBugCheck(0);

			}
		}

	} while (FALSE);

	if (fAbort)
	{
		CTEAssert(!sendPkt);

		DBGPRINT(CONNECT, ERR,
				("spxConnConnectTimer: Expired for %lx\n", pSpxConnFile));
	
		spxConnAbortConnect(
			pSpxConnFile,
			STATUS_BAD_NETWORK_PATH,
			lockHandleDev,
			lockHandleAddr,
			lockHandleConn);

		locksHeld = FALSE;
	}

	if (locksHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
		CTEFreeLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
		CTEFreeLock(&SpxDevice->dev_Lock, lockHandleDev);
	}

	if (sendPkt)
	{
		CTEAssert(!fAbort);

#if !defined(_PNP_POWER)
		if ((SPX_CONNECT_STATE(pSpxConnFile) == SPX_CONNECT_SENTREQ) &&
		    (*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0)) {

            // we are sending to all NICs because this is the initial
            // connect frame and the remote network is 0.

            pSpxConnFile->scf_LocalTarget.NicId = (USHORT)
                ((pSpxConnFile->scf_LocalTarget.NicId % SpxDevice->dev_Adapters) + 1);

            // we pass this a valid packet in pPkt, so it knows to
            // just refresh the header and not update the protocol
            // reserved variables.

    		SpxPktBuildCr(
    			pSpxConnFile,
			    pSpxConnFile->scf_AddrFile->saf_Addr,
    			&pPkt,
    			0,           // state will not be updated
    			SPX2_CONN(pSpxConnFile));

        }
#endif !_PNP_POWER

		//	Send the packet
		SPX_SENDPACKET(pSpxConnFile, pPkt, pSendResd);
	}

	if (TimerShuttingDown || fAbort)
	{
		//	Dereference connection for verify done in connect, for timer. This
		//	should complete any pending disconnects if they had come in in the
		//	meantime.
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
		return(TIMER_DONT_REQUEUE);
	}

	return(TIMER_REQUEUE_CUR_VALUE);
}




ULONG
spxConnWatchdogTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown
	)
/*++

Routine Description:

	This is started on a connection right after the CR or the CR ack is received.
	During the connection establishment phase, it does nothing other than decrement
	the retry count and upon reaching 0, it aborts the connection. When it goes off
	and finds the connection is active, it sends a probe.

Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)Context;
	CTELockHandle	lockHandle;
	PSPX_SEND_RESD	pSendResd;
	PSPX_FIND_ROUTE_REQUEST	pFindRouteReq;
	PNDIS_PACKET	pProbe		= NULL;
	BOOLEAN			lockHeld, fSpx2	= SPX2_CONN(pSpxConnFile),
					fDisconnect = FALSE, fFindRoute = FALSE, fSendProbe = FALSE;

	DBGPRINT(CONNECT, INFO,
			("spxConnWatchdogTimer: Entered\n"));

	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
	lockHeld = TRUE;
	do
	{
		if (TimerShuttingDown ||
			(!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER)) ||
			(SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_ABORT))
		{
#if DBG
			if ((SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_IDLE) &&
				(SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_WD))
			{
				CTEAssert(FALSE);
			}
#endif

			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
			TimerShuttingDown = TRUE;
			break;
		}

		//	If the retry timer is active on this connection, and the watchdog
		//	timer happens to fire, just requeue ourselves for spx2. For spx1,
		//	we go ahead with sending a probe. Retry timer does the same things
		//	watchdog does for spx2.
		switch (SPX_MAIN_STATE(pSpxConnFile))
		{
		case SPX_CONNFILE_ACTIVE:
		case SPX_CONNFILE_DISCONN:

			//	Squash the race condition where a disconnect request is never
			//	packetized, because the send state was not IDLE.
			if (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_POST_IDISC)
			{
				DBGPRINT(CONNECT, ERR,
						("spxConnWatchdogTimer: POST IDISC %lx\n",
							pSpxConnFile));
			
				if (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE)
				{
					DBGPRINT(CONNECT, ERR,
							("spxConnWatchdogTimer: PKT POST IDISC %lx\n",
								pSpxConnFile));
				
					SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_PACKETIZE);
					SpxConnPacketize(
						pSpxConnFile,
						TRUE,
						lockHandle);
	
					lockHeld = FALSE;
					break;
				}
			}

			if (!fSpx2)
			{
				if (pSpxConnFile->scf_WRetryCount-- > 0)
				{
					fSendProbe = TRUE;
				}
				else
				{
					fDisconnect = TRUE;
				}

				break;
			}

			//	SPX2 connection. Watchdog algorithm needs to do lots of goody
			//	stuff. If retry is active, just requeue ourselves.
			if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER))
				break;

			//	There is a race between watchdog and retry if its started. Who
			//	ever changes the state first gets to go do its thing.
			switch (SPX_SEND_STATE(pSpxConnFile))
			{
			case SPX_SEND_IDLE:

				//	Enter WD state only if we fired for the second time witout
				//	an ack. This prevents PACKETIZE from blocking due to being
				//	in a non-idle state.
                CTEAssert(pSpxConnFile->scf_WRetryCount != 0);
                if ((pSpxConnFile->scf_WRetryCount)-- !=
						(LONG)PARAM(CONFIG_KEEPALIVE_COUNT))
				{
					//	We enter the WD state. Build and send a probe.
					SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_WD);
					SpxConnFileLockReference(pSpxConnFile, CFREF_ERRORSTATE);
				}

				fSendProbe = TRUE;
				break;
	
			case SPX_SEND_PACKETIZE:

				// Do nothing.
				break;

			case SPX_SEND_RETRY:
			case SPX_SEND_RETRYWD:
			case SPX_SEND_RENEG:
			case SPX_SEND_RETRY2:
			case SPX_SEND_RETRY3:

				//	Do nothing. Send timer got in first.
				DBGPRINT(CONNECT, DBG1,
						("SpxConnWDogTimer: When retry fired %lx\n",
							pSpxConnFile));
	
				break;

			case SPX_SEND_WD:

				//	Decrement count. If not zero, send a probe. If half the
				//	count is reached, stop timer and call find route.
				if (pSpxConnFile->scf_WRetryCount-- > 0)
				{
					if (pSpxConnFile->scf_WRetryCount !=
							(LONG)PARAM(CONFIG_KEEPALIVE_COUNT)/2)
					{
						fSendProbe = TRUE;
						break;
					}

					if ((pFindRouteReq =
							(PSPX_FIND_ROUTE_REQUEST)SpxAllocateMemory(
										sizeof(SPX_FIND_ROUTE_REQUEST))) == NULL)
					{
						fDisconnect = TRUE;
						break;
					}

					//	Remove timer reference/ Add find route request ref
					fFindRoute = TRUE;
					TimerShuttingDown = TRUE;
					SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
					SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_FINDROUTE);
					SpxConnFileLockReference(pSpxConnFile, CFREF_FINDROUTE);

					//	Initialize the find route request
					*((UNALIGNED ULONG *)pFindRouteReq->fr_FindRouteReq.Network) =
						*((UNALIGNED ULONG *)pSpxConnFile->scf_RemAddr);
		
               //
               // [SA] Bug #15094
               // We need to also pass in the node number to IPX so that IPX can
               // compare the node addresses to determine the proper WAN NICid
               //

               // RtlCopyMemory (pFindRouteReq->fr_FindRouteReq.Node, pSpxConnFile->scf_RemAddr+4, 6);

               *((UNALIGNED ULONG *)pFindRouteReq->fr_FindRouteReq.Node)=
                *((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr+4));

               *((UNALIGNED USHORT *)(pFindRouteReq->fr_FindRouteReq.Node+4))=
                *((UNALIGNED USHORT *)(pSpxConnFile->scf_RemAddr+8));

					DBGPRINT(CONNECT, DBG,
							("SpxConnWDogTimer: NETWORK %lx\n",
								*((UNALIGNED ULONG *)pSpxConnFile->scf_RemAddr)));
		
					pFindRouteReq->fr_FindRouteReq.Identifier= IDENTIFIER_SPX;
					pFindRouteReq->fr_Ctx					 = pSpxConnFile;

					//	Make sure we have IPX re-rip.
                    pFindRouteReq->fr_FindRouteReq.Type	 = IPX_FIND_ROUTE_FORCE_RIP;
				}
				else
				{
					fDisconnect = TRUE;
				}

				break;

			default:
	
				KeBugCheck(0);
			}

			break;

		case SPX_CONNFILE_CONNECTING:

			if ((SPX_CONNECT_STATE(pSpxConnFile) == SPX_CONNECT_SENTREQ) ||
				(SPX_CONNECT_STATE(pSpxConnFile) == SPX_CONNECT_NEG))
			{
				//	Do nothing. Connect timer is active.
				DBGPRINT(CONNECT, ERR,
						("SpxConnWDogTimer: CR Timer active %lx\n",
							pSpxConnFile));
	
				break;
			}

			if (!(pSpxConnFile->scf_WRetryCount--))
			{
				//	Disconnect!
				DBGPRINT(CONNECT, ERR,
						("spxConnWatchdogTimer: Connection %lx.%lx expired\n",
							pSpxConnFile->scf_LocalConnId, pSpxConnFile));

				fDisconnect = TRUE;
			}

			break;

		case SPX_CONNFILE_LISTENING:

			if (SPX_LISTEN_STATE(pSpxConnFile) == SPX_LISTEN_SETUP)
			{
				//	Do nothing. Connect timer is active.
				DBGPRINT(CONNECT, ERR,
						("SpxConnWDogTimer: CR Timer active %lx\n",
							pSpxConnFile));
	
				break;
			}

			if (!(pSpxConnFile->scf_WRetryCount--))
			{
				//	Disconnect!
				DBGPRINT(CONNECT, ERR,
						("spxConnWatchdogTimer: Connection %lx.%lx expired\n",
							pSpxConnFile->scf_LocalConnId, pSpxConnFile));

				fDisconnect = TRUE;
			}

			break;

		default:

			//	Should never happen!
			KeBugCheck(0);
		}

	} while (FALSE);

	if (fSendProbe)
	{
		CTEAssert(lockHeld);
		CTEAssert(!fDisconnect);

		DBGPRINT(CONNECT, DBG1,
				("spxConnWatchdogTimer: Send Probe from %lx.%lx\n",
					pSpxConnFile->scf_LocalConnId, pSpxConnFile));

		//	Build a probe and send it out to the remote end.
		SpxPktBuildProbe(
			pSpxConnFile,
			&pProbe,
			(SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY),
			fSpx2);

		if (pProbe != NULL)
		{
			SpxConnQueueSendPktTail(pSpxConnFile, pProbe);
			pSendResd	= (PSPX_SEND_RESD)(pProbe->ProtocolReserved);
		}
	}

	if (fDisconnect)
	{
		CTEAssert(lockHeld);
		CTEAssert(!fSendProbe);

		//	Disconnect!
		DBGPRINT(CONNECT, ERR,
				("spxConnWatchdogTimer: Connection %lx.%lx expired\n",
					pSpxConnFile->scf_LocalConnId, pSpxConnFile));

		TimerShuttingDown = TRUE;
		SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);

		//	If spx2, check if we need to do anything special.
		//	AbortiveDisc will reset funky state if needed.
		spxConnAbortiveDisc(
			pSpxConnFile,
			STATUS_LINK_TIMEOUT,
			SPX_CALL_TDILEVEL,
			lockHandle,
            FALSE);     // [SA] Bug #15249

		lockHeld = FALSE;
	}

	if (lockHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
	}

	if (fFindRoute)
	{
		CTEAssert(!fSendProbe);
		CTEAssert(!fDisconnect);
		CTEAssert(TimerShuttingDown);

		//	Start off the find route request
		(*IpxFindRoute)(
			&pFindRouteReq->fr_FindRouteReq);
	}

	if (pProbe != NULL)
	{
		//	Send the packet
		SPX_SENDPACKET(pSpxConnFile, pProbe, pSendResd);
	}

	if (TimerShuttingDown)
	{
		//	Dereference connection for verify done in connect, for timer. This
		//	should complete any pending disconnects if they had come in in the
		//	meantime.
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	return((TimerShuttingDown ? TIMER_DONT_REQUEUE : TIMER_REQUEUE_CUR_VALUE));
}



ULONG
spxConnRetryTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)Context;
	PSPX_SEND_RESD	pSendResd;
	CTELockHandle	lockHandleConn;
	PIPXSPX_HDR		pSendHdr;
	PNDIS_PACKET	pPkt;
	PNDIS_PACKET	pProbe		= NULL;
	PSPX_FIND_ROUTE_REQUEST	pFindRouteReq;
	
	// Compiler warning  reenqueueTime = pSpxConnFile->scf_BaseT1; [tingcai]
	// USHORT			reenqueueTime	= TIMER_REQUEUE_CUR_VALUE; 
   	UINT			reenqueueTime	= TIMER_REQUEUE_CUR_VALUE;
	BOOLEAN			lockHeld, fResendPkt = FALSE, fDisconnect = FALSE,
					fFindRoute = FALSE, fBackoffTimer = FALSE;
	PREQUEST		pRequest		= NULL;
    PNDIS_BUFFER    NdisBuf, NdisBuf2;
    ULONG           BufLen = 0;

	DBGPRINT(CONNECT, INFO,
			("spxConnRetryTimer: Entered\n"));

	//	Get lock
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
	lockHeld = TRUE;

	do
	{
		//	If timer is not up, no send pkts, just return.
		if (TimerShuttingDown ||
			(!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER)) ||
			(SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_ABORT)	 ||
			((pSendResd = pSpxConnFile->scf_SendSeqListHead) == NULL))
		{
#if DBG
            if ((pSendResd = pSpxConnFile->scf_SendSeqListHead) == NULL)
			{
				if ((SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_IDLE) &&
					(SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_PACKETIZE) &&
					(SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_WD))
				{
					CTEAssert(FALSE);
				}
			}
#endif

			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER);
			TimerShuttingDown 	= TRUE;
			break;
		}

		//	In all other cases, reenqueue with potentially modified reenqueue
		//	time.
		reenqueueTime = pSpxConnFile->scf_BaseT1;
		DBGPRINT(SEND, INFO,
				("spxConnRetryTimer: BaseT1 %lx on %lx\n",
					pSpxConnFile->scf_BaseT1, pSpxConnFile));

		//	If an ack for a packet was processed while we were out, reset
		//	retry count and return. Or if we are packetizing, return.
		if (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_PACKETIZE)
		{
			break;
		}
		else if ((SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE) &&
	             (pSpxConnFile->scf_RetrySeqNum != pSendResd->sr_SeqNum))
		{
			pSpxConnFile->scf_RetrySeqNum = pSendResd->sr_SeqNum;
			break;
		}

		//	If packet is still with IPX, requeue for next time.
		if (pSendResd->sr_State & SPX_SENDPKT_IPXOWNS)
		{
			break;
		}

		CTEAssert(pSendResd != NULL);
		pPkt = (PNDIS_PACKET)CONTAINING_RECORD(
								pSendResd, NDIS_PACKET, ProtocolReserved);

        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBufferSafe(NdisBuf2, (PUCHAR) &pSendHdr, &BufLen, LowPagePriority);
		ASSERT(pSendHdr != NULL);
        
#if OWN_PKT_POOLS
		pSendHdr	= (PIPXSPX_HDR)((PBYTE)pPkt 			+
									NDIS_PACKET_SIZE 		+
									sizeof(SPX_SEND_RESD)	+
									IpxInclHdrOffset);
#endif 
		switch (SPX_SEND_STATE(pSpxConnFile))
		{
		case SPX_SEND_IDLE:

			//	Set ack bit in packet. pSendResd initialized at beginning.
			pSendHdr->hdr_ConnCtrl |= SPX_CC_ACK;

			//	Do we backoff the timer?
			fBackoffTimer =
				(BOOLEAN)((pSendResd->sr_State & SPX_SENDPKT_REXMIT) != 0);

			//	We are going to resend this packet
			pSendResd->sr_State |= (SPX_SENDPKT_IPXOWNS |
									SPX_SENDPKT_ACKREQ	|
									SPX_SENDPKT_REXMIT);

            ++SpxDevice->dev_Stat.ResponseTimerExpirations;

			CTEAssert((ULONG)pSpxConnFile->scf_RRetryCount <=
						PARAM(CONFIG_REXMIT_COUNT));

			DBGPRINT(SEND, DBG1,
					("spxConnRetryTimer: Retry Count %lx on %lx\n",
						pSpxConnFile->scf_RRetryCount, pSpxConnFile));

			fResendPkt = TRUE;
			if (pSpxConnFile->scf_RRetryCount-- != 0)
			{
				//	We dont treat the IDISC packet as a data packet, so none
				//	of the fancy spx2 retry stuff if we are retrying the idisc.
				if (SPX2_CONN(pSpxConnFile) &&
					(SPX_DISC_STATE(pSpxConnFile) != SPX_DISC_SENT_IDISC))
				{
					//	We enter the RETRY state. Reference conn for this
					//	"funky" state.
					CTEAssert(SPX2_CONN(pSpxConnFile));
					SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RETRY);
					SpxConnFileLockReference(pSpxConnFile, CFREF_ERRORSTATE);
				}
			}
			else
			{
				DBGPRINT(SEND, ERR,
						("spxConnRetryTimer: Retry Count over on %lx\n",
							pSpxConnFile));

				fDisconnect = TRUE;
				fResendPkt	= FALSE;
				pSendResd->sr_State &= ~SPX_SENDPKT_IPXOWNS;
			}

			break;

		case SPX_SEND_RETRY:

			//	When we have reached retry_count/2 limit, start locate route. Do
			//	not queue ourselves. Handle restarting timer in find route
			//	completion. If timer starts successfully in find route comp, then
			//	it will change our state to RETRYWD.

			//	Decrement count. If half the count is reached, stop timer and call
			//	find route.
			if (pSpxConnFile->scf_RRetryCount-- !=
						(LONG)PARAM(CONFIG_REXMIT_COUNT)/2)
			{
				//	We are going to resend this packet
				pSendResd->sr_State |= (SPX_SENDPKT_IPXOWNS |
										SPX_SENDPKT_ACKREQ	|
										SPX_SENDPKT_REXMIT);
	
				fResendPkt = TRUE;
				fBackoffTimer = TRUE;
				break;
			}

			if ((pFindRouteReq =
					(PSPX_FIND_ROUTE_REQUEST)SpxAllocateMemory(
								sizeof(SPX_FIND_ROUTE_REQUEST))) == NULL)
			{
				DBGPRINT(SEND, ERR,
						("spxConnRetryTimer: Alloc Mem %lx\n",
							pSpxConnFile));

				fDisconnect = TRUE;
				break;
			}

			//	Remove timer reference/ Add find route request ref
			fFindRoute = TRUE;
			TimerShuttingDown = TRUE;
			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER);
			SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_FINDROUTE);
			SpxConnFileLockReference(pSpxConnFile, CFREF_FINDROUTE);

			//	Initialize the find route request
			*((UNALIGNED ULONG *)pFindRouteReq->fr_FindRouteReq.Network)=
				*((UNALIGNED ULONG *)pSpxConnFile->scf_RemAddr);

         //
         // [SA] Bug #15094
         // We need to also pass in the node number to IPX so that IPX can
         // compare the node addresses to determine the proper WAN NICid
         //

         // RtlCopyMemory (pFindRouteReq->fr_FindRouteReq.Node, pSpxConnFile->scf_RemAddr+4, 6) ;

         *((UNALIGNED ULONG *)pFindRouteReq->fr_FindRouteReq.Node)=
          *((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr+4));

         *((UNALIGNED USHORT *)(pFindRouteReq->fr_FindRouteReq.Node+4)) =
          *((UNALIGNED USHORT *)(pSpxConnFile->scf_RemAddr+8));

			DBGPRINT(CONNECT, DBG,
					("SpxConnRetryTimer: NETWORK %lx\n",
						*((UNALIGNED ULONG *)pSpxConnFile->scf_RemAddr)));

			pFindRouteReq->fr_FindRouteReq.Identifier= IDENTIFIER_SPX;
			pFindRouteReq->fr_Ctx					 = pSpxConnFile;

			//	Make sure we have IPX re-rip.
			pFindRouteReq->fr_FindRouteReq.Type	 = IPX_FIND_ROUTE_FORCE_RIP;
			break;

		case SPX_SEND_RETRYWD:

			//	Retry a watchdog packet WCount times (initialize to RETRY_COUNT).
			//	If process ack receives an ack (i.e. actual ack packet) while in
			//	this state, it will transition the state to RENEG.
			//
			//	If the pending data gets acked while in this state, we go back
			//	to idle.
			DBGPRINT(CONNECT, DBG1,
					("spxConnRetryTimer: Send Probe from %lx.%lx\n",
						pSpxConnFile->scf_LocalConnId, pSpxConnFile));

			//	Use watchdog count here.
			if (pSpxConnFile->scf_WRetryCount-- > 0)
			{
				//	Build a probe and send it out to the remote end.
				SpxPktBuildProbe(
					pSpxConnFile,
					&pProbe,
					(SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY),
					TRUE);
		
				if (pProbe != NULL)
				{
					SpxConnQueueSendPktTail(pSpxConnFile, pProbe);
					pSendResd	= (PSPX_SEND_RESD)(pProbe->ProtocolReserved);
					break;
				}
			}

			//	Just set state to retry data packet retry_count/2 times.
			pSpxConnFile->scf_WRetryCount = PARAM(CONFIG_KEEPALIVE_COUNT);
			SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RETRY2);
			break;

		case SPX_SEND_RENEG:

			//	Renegotiate size. If we give up, goto RETRY3.
			//	For this both sides must have negotiated size to begin with.
			//	If they did not, we go on to retrying the data packet.
			if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_NEG))
			{
				DBGPRINT(SEND, ERR,
						("spxConnRetryTimer: NO NEG FLAG SET: %lx - %lx\n",
							pSpxConnFile,
							pSpxConnFile->scf_Flags));

				//	Reset count to be
				pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);
				SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RETRY3);
				break;
			}

			//	Send reneg packet, if we get the rr ack, then we resend data
			//	on queue. Note that each time we goto a new negotiate size,
			//	we rebuild the data packets.
			if (pSpxConnFile->scf_RRetryCount-- == 0)
			{
				//	Reset count.
				pSpxConnFile->scf_RRetryCount = SPX_DEF_RENEG_RETRYCOUNT;
				if ((ULONG)pSpxConnFile->scf_MaxPktSize <=
						(SpxMaxPktSize[0] + MIN_IPXSPX2_HDRSIZE))
				{
					pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);

					DBGPRINT(SEND, DBG3,
							("SpxConnRetryTimer: %lx MIN RENEG SIZE\n",
								pSpxConnFile));
				}

				//	Are we at the lowest possible reneg pkt size? If not, try
				//	next lower. When we do this, we free all pending send
				//	packets and reset the packetize queue to the first packet.
				//	Process ack will just do packetize and will not do anything
				//	more other than resetting state to proper value.
				DBGPRINT(SEND, DBG3,
						("spxConnRetryTimer: RENEG: %lx - CURRENT %lx\n",
							pSpxConnFile,
							pSpxConnFile->scf_MaxPktSize));

				if (!spxConnCheckNegSize(&pSpxConnFile->scf_MaxPktSize))
				{
					//	We tried lowest size and failed to receive ack. Just
					//	retry data packet, and disc if no ack.
					DBGPRINT(SEND, DBG3,
							("spxConnRetryTimer: RENEG(min), RETRY3: %lx - %lx\n",
								pSpxConnFile,
								pSpxConnFile->scf_MaxPktSize));
	
					pSpxConnFile->scf_RRetryCount = PARAM(CONFIG_REXMIT_COUNT);
					SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RETRY3);
					SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_RENEG_PKT);
					break;
				}

				DBGPRINT(SEND, DBG3,
						("spxConnRetryTimer: RENEG(!min): %lx - ATTEMPT %lx\n",
							pSpxConnFile,
							pSpxConnFile->scf_MaxPktSize));
			}

			DBGPRINT(SEND, DBG3,
					("spxConnRetryTimer: %lx.%lx.%lx RENEG SEQNUM %lx ACKNUM %lx\n",
						pSpxConnFile,
						pSpxConnFile->scf_RRetryCount,
						pSpxConnFile->scf_MaxPktSize,
						(USHORT)(pSpxConnFile->scf_SendSeqListTail->sr_SeqNum + 1),
						pSpxConnFile->scf_SentAllocNum));

			//	Use first unused data packet sequence number.
			SpxPktBuildRr(
				pSpxConnFile,
				&pPkt,
				(USHORT)(pSpxConnFile->scf_SendSeqListTail->sr_SeqNum + 1),
				(SPX_SENDPKT_IPXOWNS | SPX_SENDPKT_DESTROY));

			if (pPkt != NULL)
			{
				SpxConnQueueSendPktTail(pSpxConnFile, pPkt);
				pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
				fResendPkt  = TRUE;
				SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_RENEG_PKT);
			}

			break;

		case SPX_SEND_RETRY2:

			//	Retry the data packet for remaining amount of RRetryCount. If not
			//	acked goto cleanup. If ack received while in this state, goto idle.

			if (pSpxConnFile->scf_RRetryCount-- > 0)
			{
				//	We are going to resend this packet
				pSendResd->sr_State |= (SPX_SENDPKT_IPXOWNS |
										SPX_SENDPKT_ACKREQ	|
										SPX_SENDPKT_REXMIT);
	
				DBGPRINT(SEND, DBG3,
						("spxConnRetryTimer: 2nd try Resend on %lx\n",
							pSpxConnFile));
		
				fResendPkt = TRUE;
				fBackoffTimer = TRUE;
			}
			else
			{
				DBGPRINT(SEND, ERR,
						("spxConnRetryTimer: Retry Count over on %lx\n",
							pSpxConnFile));

				fDisconnect = TRUE;
			}

			break;

		case SPX_SEND_RETRY3:

			//	Send data packet for RETRY_COUNT times initialized in RRetryCount
			//	before state changed to this state. If ok, process ack moves us
			//	back to PKT/IDLE. If not, we disconnect.
			//	We are going to resend this packet

			if (pSpxConnFile->scf_RRetryCount-- > 0)
			{
				DBGPRINT(SEND, DBG3,
						("spxConnRetryTimer: 3rd try Resend on %lx\n",
							pSpxConnFile));
		
				//	We are going to resend this packet
				pSendResd->sr_State |= (SPX_SENDPKT_IPXOWNS |
										SPX_SENDPKT_ACKREQ	|
										SPX_SENDPKT_REXMIT);
	
				fResendPkt = TRUE;
				fBackoffTimer = TRUE;
			}
			else
			{
				DBGPRINT(SEND, ERR,
						("spxConnRetryTimer: Retry Count over on %lx\n",
							pSpxConnFile));

				fDisconnect = TRUE;
			}

			break;

		case SPX_SEND_WD:

			//	Do nothing. Watchdog timer has fired, just requeue.
			break;

		default:

			KeBugCheck(0);
		}

		if (fBackoffTimer)
		{
			//	Increase retransmit timeout by 50% upto maximum indicated by
			//	initial retransmission value.

			reenqueueTime += reenqueueTime/2;
			if (reenqueueTime > MAX_RETRY_DELAY)
				reenqueueTime = MAX_RETRY_DELAY;
	
			pSpxConnFile->scf_BaseT1 =
			pSpxConnFile->scf_AveT1	 = reenqueueTime;
			pSpxConnFile->scf_DevT1	 = 0;

			DBGPRINT(SEND, DBG,
					("spxConnRetryTimer: Backed retry on %lx.%lx %lx\n",
						pSpxConnFile, pSendResd->sr_SeqNum, reenqueueTime));
		}

		if (fDisconnect)
		{
			CTEAssert(lockHeld);

			//	Do not requeue this timer.
			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER);
			TimerShuttingDown = TRUE;

			//	Disconnect the connection.
			spxConnAbortiveDisc(
				pSpxConnFile,
				STATUS_LINK_TIMEOUT,
				SPX_CALL_TDILEVEL,
				lockHandleConn,
                FALSE);     // [SA] Bug #15249

			lockHeld = FALSE;
		}

	} while (FALSE);

	if (lockHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
	}

	if (fResendPkt)
	{
		DBGPRINT(SEND, DBG,
				("spxConnRetryTimer: Resend pkt on %lx.%lx\n",
					pSpxConnFile, pSendResd->sr_SeqNum));

        ++SpxDevice->dev_Stat.DataFramesResent;
        ExInterlockedAddLargeStatistic(
            &SpxDevice->dev_Stat.DataFrameBytesResent,
            pSendResd->sr_Len - (SPX2_CONN(pSpxConnFile) ? MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE));
		SPX_SENDPACKET(pSpxConnFile, pPkt, pSendResd);
	}
	else if (fFindRoute)
	{
		CTEAssert(!fResendPkt);
		CTEAssert(!fDisconnect);
		CTEAssert(TimerShuttingDown);

		DBGPRINT(SEND, DBG3,
				("spxConnRetryTimer: Find route on %lx\n",
					pSpxConnFile));

		//	Start off the find route request
		(*IpxFindRoute)(
			&pFindRouteReq->fr_FindRouteReq);
	}
	else if (pProbe != NULL)
	{
		//	Send the packet
		SPX_SENDPACKET(pSpxConnFile, pProbe, pSendResd);
	}

	if (TimerShuttingDown)
	{
		//	Dereference connection for verify done in connect, for timer. This
		//	should complete any pending disconnects if they had come in in the
		//	meantime.
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
		reenqueueTime = TIMER_DONT_REQUEUE;
	}

	DBGPRINT(SEND, INFO,
			("spxConnRetryTimer: Reenqueue time : %lx on %lx\n",
				reenqueueTime, pSpxConnFile));

	return(reenqueueTime);
}




ULONG
spxConnAckTimer(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pSpxConnFile = (PSPX_CONN_FILE)Context;
	CTELockHandle	lockHandleConn;

	DBGPRINT(SEND, INFO,
			("spxConnAckTimer: Entered\n"));

	//	Get lock
	CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);

	if (!TimerShuttingDown &&
		SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ACKQ))
	{
		//	We didnt have any back traffic, until we do a send from this
		//	end, send acks immediately. Dont try to piggyback.
		SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_ACKQ);
		SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_IMMED_ACK);

        ++SpxDevice->dev_Stat.PiggybackAckTimeouts;

		DBGPRINT(SEND, DBG,
				("spxConnAckTimer: Send ack on %lx.%lx\n",
					pSpxConnFile, pSpxConnFile->scf_RecvSeqNum));

		SpxConnSendAck(pSpxConnFile, lockHandleConn);
	}
	else
	{
		SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_ACKQ);
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandleConn);
	}

	//	Dereference connection for verify done in connect, for timer. This
	//	should complete any pending disconnects if they had come in in the
	//	meantime.
	SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	return(TIMER_DONT_REQUEUE);
}



//
//	DISCONNECT ROUTINES
//


VOID
spxConnAbortiveDisc(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	NTSTATUS	        Status,
	IN	SPX_CALL_LEVEL		CallLevel,
	IN	CTELockHandle		LockHandleConn,
    IN  BOOLEAN             IDiscFlag       // [SA] Bug #15249
	)
/*++

Routine Description:

	This is called when:
		We time out or have insufficient resources 	-
			STATUS_LINK_TIMEOUT/STATUS_INSUFFICIENT_RESOURCES
			- We abort everything. Could be from watchdog or retry. Stop both.

		We receive a informed disconnect packet    	-
			STATUS_REMOTE_DISCONNECT
			- We abort everything. Ack must be sent by caller as an orphan pkt.

		We receive a informed disconnect ack pkt
			STATUS_SUCCESS
			- We abort everything
			- Abort is done with status success (this completes our disc req in
			  the send queue)

    NOTE: CALLED UNDER THE CONNECTION LOCK.

Arguments:
[SA]    Bug #15249: Added IDiscFlag to indicate if this is an Informed Disconnect. If so, indicate
        TDI_DISCONNECT_RELEASE to AFD so it allows a receive of buffered pkts. This flag is TRUE
        only if this routine is called from SpxConnProcessIDisc for SPX connections.

Return Value:


--*/
{
	int						numDerefs = 0;
    PVOID 					pDiscHandlerCtx=NULL;
    PTDI_IND_DISCONNECT 	pDiscHandler	= NULL;
	BOOLEAN					lockHeld = TRUE;

	DBGPRINT(CONNECT, DBG,
			("spxConnAbortiveDisc: %lx - On %lx when %lx\n",
				Status, pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));

    switch (Status) {
    case STATUS_LINK_TIMEOUT: ++SpxDevice->dev_Stat.LinkFailures; break;
    case STATUS_INSUFFICIENT_RESOURCES: ++SpxDevice->dev_Stat.LocalResourceFailures; break;
    case STATUS_REMOTE_DISCONNECT: ++SpxDevice->dev_Stat.RemoteDisconnects; break;
    case STATUS_SUCCESS:
    case STATUS_LOCAL_DISCONNECT: ++SpxDevice->dev_Stat.LocalDisconnects; break;
    }

	switch (SPX_MAIN_STATE(pSpxConnFile))
	{
	case SPX_CONNFILE_ACTIVE:

		//	For transition from active to disconn.
		numDerefs++;

	case SPX_CONNFILE_DISCONN:

		//	If we are in any state other than idle/packetize,
		//	remove the reference for the funky state, and reset the send state to be
		//	idle.
		if ((SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_IDLE) &&
			(SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_PACKETIZE))
		{
#if DBG
			if ((SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
				(SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_ABORT))
			{
				DBGPRINT(CONNECT, ERR,
						("spxConnAbortiveDisc: When DISC STATE %lx.%lx\n",
							pSpxConnFile, SPX_SEND_STATE(pSpxConnFile)));
			}
#endif

			DBGPRINT(CONNECT, DBG1,
					("spxConnAbortiveDisc: When SEND ERROR STATE %lx.%lx\n",
						pSpxConnFile, SPX_SEND_STATE(pSpxConnFile)));
		
            SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_IDLE);

			SpxConnFileTransferReference(
				pSpxConnFile,
				CFREF_ERRORSTATE,
				CFREF_VERIFY);

			numDerefs++;
		}

		//	This can be called when a idisc is received, or if a timer
		//	disconnect is happening, or if we sent a idisc/ordrel, but the retries
		//	timed out and we are aborting the connection.
		//	So if we are already aborting, never mind.

        //
        // [SA] Bug #15249
        // SPX_DISC_INACTIVATED indicates a DISC_ABORT'ing connection that has been
        // inactivated (connfile removed from active conn. list)
        //

		if ((SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
            ((SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_ABORT) ||
            (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED)))
		{
			break;
		}

        SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_DISCONN);
        SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_ABORT);

		//	Stop all timers.
		if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_T_TIMER))
		{
			if (SpxTimerCancelEvent(pSpxConnFile->scf_TTimerId, FALSE))
			{
				numDerefs++;
			}
			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_T_TIMER);
		}
	
		if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER))
		{
			if (SpxTimerCancelEvent(pSpxConnFile->scf_RTimerId, FALSE))
			{
				numDerefs++;
			}
			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_R_TIMER);
		}
		
		if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER))
		{
			if (SpxTimerCancelEvent(pSpxConnFile->scf_WTimerId, FALSE))
			{
				numDerefs++;
			}
			SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER);
		}
#if 0
        //
        // [SA] We need to call AFD after aborting sends since this connection
        // becomes a candidate for re-use as soon as the disconnect handler is
        // called.
        // We call the disconnect handler when the refcount falls to 0 and the
        // connection transitions to the inactive list.
        //

		//	NOTE! We indicate disconnect to afd *before* aborting sends to avoid
		//		  afd from calling us again with a disconnect.
		//	Get disconnect handler if we have one. And we have not indicated
		//	abortive disconnect on this connection to afd.
		if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC))
		{
			//	Yeah, we set the flag regardless of whether a handler is
			//	present.
			pDiscHandler 	= pSpxConnFile->scf_AddrFile->saf_DiscHandler;
			pDiscHandlerCtx = pSpxConnFile->scf_AddrFile->saf_DiscHandlerCtx;
			SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC);
		}
#endif
        //
        // [SA] Save the IDiscFlag in the Connection.
        //
        (IDiscFlag) ?
            SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_IDISC) :
            SPX_CONN_RESETFLAG2(pSpxConnFile, SPX_CONNFILE2_IDISC);

		//	Indicate disconnect to afd.
		if (pDiscHandler != NULL)
		{
			CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

			DBGPRINT(CONNECT, INFO,
					("spxConnAbortiveDisc: Indicating to afd On %lx when %lx\n",
						pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));
		
			//	First complete all requests waiting for receive completion on
			//	this conn before indicating disconnect.
			spxConnCompletePended(pSpxConnFile);


            //
            // [SA] bug #15249
            // If not Informed disconnect, indicate DISCONNECT_ABORT to AFD
            //

            if (!IDiscFlag)
            {
                (*pDiscHandler)(
                        pDiscHandlerCtx,
                        pSpxConnFile->scf_ConnCtx,
                        0,								// Disc data
                        NULL,
                        0,								// Disc info
                        NULL,
                        TDI_DISCONNECT_ABORT);
            }
            else
            {
                //
                // [SA] bug #15249
                // Indicate DISCONNECT_RELEASE to AFD so it allows receive of packets
                // it has buffered before the remote disconnect took place.
                //

                (*pDiscHandler)(
                        pDiscHandlerCtx,
                        pSpxConnFile->scf_ConnCtx,
                        0,								// Disc data
                        NULL,
                        0,								// Disc info
                        NULL,
                        TDI_DISCONNECT_RELEASE);
            }

			CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
		}

		//	Go through and kill all pending requests.
		spxConnAbortRecvs(
			pSpxConnFile,
			Status,
			CallLevel,
			LockHandleConn);

		CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);

		spxConnAbortSends(
			pSpxConnFile,
			Status,
			CallLevel,
			LockHandleConn);

		lockHeld = FALSE;
		break;

	case SPX_CONNFILE_CONNECTING:
	case SPX_CONNFILE_LISTENING:

		DBGPRINT(CONNECT, DBG,
				("spxConnAbortiveDisc: CONN/LIST Disc On %lx when %lx\n",
					pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));

		CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
		lockHeld = FALSE;

		{
			CTELockHandle	lockHandleAddr, lockHandleDev;

			CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
			CTEGetLock(pSpxConnFile->scf_AddrFile->saf_AddrLock, &lockHandleAddr);
			CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);

			//	Ensure we are still in connecting/listening, else call abortive
			//	again.
			switch (SPX_MAIN_STATE(pSpxConnFile))
			{
			case SPX_CONNFILE_CONNECTING:
			case SPX_CONNFILE_LISTENING:

				DBGPRINT(CONNECT, DBG,
						("spxConnAbortiveDisc: CONN/LIST Disc2 On %lx when %lx\n",
							pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));

				spxConnAbortConnect(
					pSpxConnFile,
					Status,
					lockHandleDev,
					lockHandleAddr,
					LockHandleConn);

				break;

			case SPX_CONNFILE_ACTIVE:

				CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
				CTEFreeLock(
					pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
				CTEFreeLock(
					&SpxDevice->dev_Lock, lockHandleDev);

				CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);

				DBGPRINT(CONNECT, DBG,
						("spxConnAbortiveDisc: CHG ACT Disc2 On %lx when %lx\n",
							pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));

				spxConnAbortiveDisc(
					pSpxConnFile,
					Status,
					CallLevel,
					LockHandleConn,
                    FALSE);     // [SA] Bug #15249

				break;

			default:

				CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
				CTEFreeLock(
					pSpxConnFile->scf_AddrFile->saf_AddrLock, lockHandleAddr);
				CTEFreeLock(
					&SpxDevice->dev_Lock, lockHandleDev);

				break;
			}
		}

	default:

		//	Already disconnected.
		break;
	}

	if (lockHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
	}

	while (numDerefs-- > 0)
	{
		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxdev.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxdev.c

Abstract:

    This module contains code which implements the DEVICE_CONTEXT object.
    Routines are provided to reference, and dereference transport device
    context objects.

    The transport device context object is a structure which contains a
    system-defined DEVICE_OBJECT followed by information which is maintained
    by the transport provider, called the context.

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//      Define module number for event logging entries
#define FILENUM         SPXDEV

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, SpxInitCreateDevice)
#pragma alloc_text(PAGE, SpxDestroyDevice)
#endif




VOID
SpxDerefDevice(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine dereferences a device context by decrementing the
    reference count contained in the structure.  Currently, we don't
    do anything special when the reference count drops to zero, but
    we could dynamically unload stuff then.

Arguments:

    Device - Pointer to a transport device context object.

Return Value:

    none.

--*/

{
    LONG result;

    result = InterlockedDecrement (&Device->dev_RefCount);

    CTEAssert (result >= 0);

    if (result == 0)
        {
                //      Close binding to IPX
                SpxUnbindFromIpx();

                //      Set unload event.
                KeSetEvent(&SpxUnloadEvent, IO_NETWORK_INCREMENT, FALSE);
    }

} // SpxDerefDevice




NTSTATUS
SpxInitCreateDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  DeviceName
    )

/*++

Routine Description:

    This routine creates and initializes a device context structure.

Arguments:


    DriverObject - pointer to the IO subsystem supplied driver object.

    Device - Pointer to a pointer to a transport device context object.

    DeviceName - pointer to the name of the device this device object points to.

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INSUFFICIENT_RESOURCES otherwise.

--*/

{
    NTSTATUS        status;
    PDEVICE         Device;
    ULONG           DeviceNameOffset;
    
    DBGPRINT(DEVICE, INFO,
                        ("SpxInitCreateDevice - Create device %ws\n", DeviceName->Buffer));

    // Create the device object for the sample transport, allowing
    // room at the end for the device name to be stored (for use
    // in logging errors).

    SpxDevice = SpxAllocateMemory(sizeof (DEVICE) + DeviceName->Length + sizeof(UNICODE_NULL));

    if (!SpxDevice) {
        DbgPrint("SPX: FATAL Error: cant allocate Device Structure\n");
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Device                               = (PDEVICE)SpxDevice;
    
    RtlZeroMemory(SpxDevice, sizeof (DEVICE) + DeviceName->Length + sizeof(UNICODE_NULL) );

    //
    // This is the closest we can set the provider info [ShreeM]
    // 
    SpxQueryInitProviderInfo(&Device->dev_ProviderInfo);

    DBGPRINT(DEVICE, INFO, ("IoCreateDevice succeeded %lx\n", Device));

    // Initialize our part of the device context.
    RtlZeroMemory(
        ((PUCHAR)Device) + sizeof(DEVICE_OBJECT),
        sizeof(DEVICE) - sizeof(DEVICE_OBJECT));

    DeviceNameOffset = sizeof(DEVICE);

    // Copy over the device name.
    Device->dev_DeviceNameLen   = DeviceName->Length + sizeof(WCHAR);
    Device->dev_DeviceName      = (PWCHAR)(((PUCHAR)Device) + DeviceNameOffset);

    RtlCopyMemory(
        Device->dev_DeviceName,
        DeviceName->Buffer,
        DeviceName->Length);

    Device->dev_DeviceName[DeviceName->Length/sizeof(WCHAR)] = UNICODE_NULL;

    // Initialize the reference count.
    Device->dev_RefCount = 1;

#if DBG
    Device->dev_RefTypes[DREF_CREATE] = 1;
#endif

#if DBG
    RtlCopyMemory(Device->dev_Signature1, "IDC1", 4);
    RtlCopyMemory(Device->dev_Signature2, "IDC2", 4);
#endif

        //      Set next conn id to be used.
        Device->dev_NextConnId                                                  = (USHORT)SpxRandomNumber();
        if (Device->dev_NextConnId == 0xFFFF)
        {
                Device->dev_NextConnId  = 1;
        }

        DBGPRINT(DEVICE, ERR,
                        ("SpxInitCreateDevice: Start Conn Id %lx\n", Device->dev_NextConnId));

    // Initialize the resource that guards address ACLs.
    ExInitializeResourceLite (&Device->dev_AddrResource);

    // initialize the various fields in the device context
    CTEInitLock (&Device->dev_Interlock);
    CTEInitLock (&Device->dev_Lock);
    KeInitializeSpinLock (&Device->dev_StatInterlock);
    KeInitializeSpinLock (&Device->dev_StatSpinLock);

    Device->dev_State       = DEVICE_STATE_CLOSED;
    Device->dev_Type        = SPX_DEVICE_SIGNATURE;
    Device->dev_Size        = sizeof (DEVICE);

    Device->dev_Stat.Version = 0x100;

    return STATUS_SUCCESS;

}   // SpxCreateDevice




VOID
SpxDestroyDevice(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine destroys a device context structure.

Arguments:

    Device - Pointer to a pointer to a transport device context object.

Return Value:

    None.

--*/

{
    ExDeleteResourceLite (&Device->dev_AddrResource);

    IoDeleteDevice ((PDEVICE_OBJECT)SpxDevice->dev_DevObj);

    SpxFreeMemory(SpxDevice);

}   // SpxDestroyDevice
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxcutil.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxcutil.c

Abstract:

    This module contains code which implements the CONNECTION object.
    Routines are provided to create, destroy, reference, and dereference,
    transport connection objects.

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

    Sanjay Anand (SanjayAn) 5-July-1995
    Bug fixes - tagged [SA]

--*/

#include "precomp.h"
#pragma hdrstop


//	Define module number for event logging entries
#define	FILENUM		SPXCUTIL

//
//	Minor utility routines
//


BOOLEAN
spxConnCheckNegSize(
	IN	PUSHORT		pNegSize
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	int	i;

	//	We go thru table and see if this is the minimum size or if it
	//	can go down further. Return true if it is not the minimum size.
	DBGPRINT(CONNECT, INFO,
			("spxConnCheckNegSize: Current %lx Check Val %lx\n",
				(ULONG)(*pNegSize - MIN_IPXSPX2_HDRSIZE),
				SpxMaxPktSize[0]));

	if ((ULONG)(*pNegSize - MIN_IPXSPX2_HDRSIZE) <= SpxMaxPktSize[0])
		return(FALSE);

	for (i = SpxMaxPktSizeIndex-1; i > 0; i--)
	{
		DBGPRINT(CONNECT, INFO,
				("spxConnCheckNegSize: Current %lx Check Val %lx\n",
	                (ULONG)(*pNegSize - MIN_IPXSPX2_HDRSIZE),
					SpxMaxPktSize[i]));

		if (SpxMaxPktSize[i] < (ULONG)(*pNegSize - MIN_IPXSPX2_HDRSIZE))
			break;
	}

	*pNegSize = (USHORT)(SpxMaxPktSize[i] + MIN_IPXSPX2_HDRSIZE);

	DBGPRINT(CONNECT, ERR,
			("spxConnCheckNegSize: Trying Size %lx Min size possible %lx\n",
				*pNegSize, SpxMaxPktSize[0] + MIN_IPXSPX2_HDRSIZE));

	return(TRUE);
}




VOID
spxConnSetNegSize(
	IN OUT	PNDIS_PACKET		pPkt,
	IN		ULONG				Size
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PNDIS_BUFFER	pNdisBuffer;
	UINT			bufCount;
    PSPX_SEND_RESD	pSendResd;
	PIPXSPX_HDR		pIpxSpxHdr;

	CTEAssert(Size > 0);
	NdisQueryPacket(pPkt, NULL, &bufCount, &pNdisBuffer, NULL);
	CTEAssert (bufCount == 3);

	NdisGetNextBuffer(pNdisBuffer, &pNdisBuffer);
    NdisQueryBuffer(pNdisBuffer, &pIpxSpxHdr, &bufCount);
    
    NdisGetNextBuffer(pNdisBuffer, &pNdisBuffer);
    NdisAdjustBufferLength(pNdisBuffer, Size);
    

	//	Change it in send reserved
	pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
    pSendResd->sr_Len 	= (Size + MIN_IPXSPX2_HDRSIZE);

#if SPX_OWN_PACKETS
	//	Change in ipx header
	pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
										NDIS_PACKET_SIZE 		+
										sizeof(SPX_SEND_RESD)	+
										IpxInclHdrOffset);
#endif

	PUTSHORT2SHORT((PUSHORT)&pIpxSpxHdr->hdr_PktLen, (Size + MIN_IPXSPX2_HDRSIZE));

	//	Change in the neg packet field of the header.
	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_NegSize,
		(Size + MIN_IPXSPX2_HDRSIZE));

	DBGPRINT(CONNECT, DBG,
			("spxConnSetNegSize: Setting size to %lx Hdr %lx\n",
				Size, (Size + MIN_IPXSPX2_HDRSIZE)));

	return;
}




BOOLEAN
SpxConnDequeueSendPktLock(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN 	PNDIS_PACKET		pPkt
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PSPX_SEND_RESD	pSr, pListHead, pListTail;
	PSPX_SEND_RESD	pSendResd;
	BOOLEAN			removed = TRUE;

	//	If we are sequenced or not decides which list we choose.
	pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
	if ((pSendResd->sr_State & SPX_SENDPKT_SEQ) != 0)
	{
		pListHead = pSpxConnFile->scf_SendSeqListHead;
		pListTail = pSpxConnFile->scf_SendSeqListTail;
	}
	else
	{
		pListHead = pSpxConnFile->scf_SendListHead;
		pListTail = pSpxConnFile->scf_SendListTail;
	}

	//	Most often, we will be at the head of the list.
	if (pListHead == pSendResd)
	{
        if ((pListHead = pSendResd->sr_Next) == NULL)
		{
			DBGPRINT(SEND, INFO,
					("SpxConnDequeuePktLock: %lx first in list\n", pSendResd));

			pListTail = NULL;
		}
	}
	else
	{
		DBGPRINT(SEND, INFO,
				("SpxConnDequeuePktLock: %lx !first in list\n", pSendResd));

        pSr = pListHead;
		while (pSr != NULL)
		{
			if (pSr->sr_Next == pSendResd)
			{
				if ((pSr->sr_Next = pSendResd->sr_Next) == NULL)
				{
					pListTail = pSr;
				}

				break;
			}

			pSr = pSr->sr_Next;
		}
	
		if (pSr == NULL)
			removed = FALSE;
	}

	if (removed)
	{
		if ((pSendResd->sr_State & SPX_SENDPKT_SEQ) != 0)
		{
			pSpxConnFile->scf_SendSeqListHead = pListHead;
			pSpxConnFile->scf_SendSeqListTail = pListTail;
		}
		else
		{
			pSpxConnFile->scf_SendListHead = pListHead;
			pSpxConnFile->scf_SendListTail = pListTail;
		}
	}

	return(removed);
}




BOOLEAN
SpxConnDequeueRecvPktLock(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN 	PNDIS_PACKET		pPkt
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PSPX_RECV_RESD	pSr, pListHead, pListTail;
	PSPX_RECV_RESD	pRecvResd;
	BOOLEAN			removed = TRUE;

	pRecvResd	= (PSPX_RECV_RESD)(pPkt->ProtocolReserved);
	pListHead = pSpxConnFile->scf_RecvListHead;
	pListTail = pSpxConnFile->scf_RecvListTail;

	//	Most often, we will be at the head of the list.
	if (pListHead == pRecvResd)
	{
		DBGPRINT(RECEIVE, INFO,
				("SpxConnDequeuePktLock: %lx first in list\n", pRecvResd));

        if ((pListHead = pRecvResd->rr_Next) == NULL)
		{
			pListTail = NULL;
		}
	}
	else
	{
		DBGPRINT(RECEIVE, INFO,
				("SpxConnDequeuePktLock: %lx !first in list\n", pRecvResd));

        pSr = pListHead;
		while (pSr != NULL)
		{
			if (pSr->rr_Next == pRecvResd)
			{
				if ((pSr->rr_Next = pRecvResd->rr_Next) == NULL)
				{
					pListTail = pSr;
				}

				break;
			}

			pSr = pSr->rr_Next;
		}
	
		if (pSr == NULL)
			removed = FALSE;
	}

	if (removed)
	{
		pSpxConnFile->scf_RecvListHead = pListHead;
		pSpxConnFile->scf_RecvListTail = pListTail;
	}

	return(removed);
}




BOOLEAN
spxConnGetPktByType(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	ULONG				PktType,
	IN	BOOLEAN				fSeqList,
	IN 	PNDIS_PACKET	*	ppPkt
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PSPX_SEND_RESD	pSr, *ppSr;

	//	Most often, we will be at the head of the list.
	ppSr = (fSeqList ?
				&pSpxConnFile->scf_SendSeqListHead :
				&pSpxConnFile->scf_SendListHead);

	for (; (pSr = *ppSr) != NULL; )
	{
		if (pSr->sr_Type == PktType)
		{
			*ppPkt	 = (PNDIS_PACKET)CONTAINING_RECORD(
										pSr, NDIS_PACKET, ProtocolReserved);
			
			DBGPRINT(SEND, INFO,
					("SpxConnFindByType: %lx.%lx.%d\n", pSr,*ppPkt, fSeqList));

			break;
		}

		ppSr = &pSr->sr_Next;
	}

	return(pSr != NULL);
}




BOOLEAN
spxConnGetPktBySeqNum(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	USHORT				SeqNum,
	IN 	PNDIS_PACKET	*	ppPkt
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PSPX_SEND_RESD	pSr, *ppSr;

	//	Most often, we will be at the head of the list.
	ppSr = &pSpxConnFile->scf_SendSeqListHead;
	for (; (pSr = *ppSr) != NULL; )
	{
		if (pSr->sr_SeqNum == SeqNum)
		{
			*ppPkt	 = (PNDIS_PACKET)CONTAINING_RECORD(
										pSr, NDIS_PACKET, ProtocolReserved);
			
			DBGPRINT(SEND, DBG,
					("SpxConnFindBySeq: %lx.%lx.%d\n", pSr,*ppPkt, SeqNum));

			break;
		}

		ppSr = &pSr->sr_Next;
	}

	return(pSr != NULL);
}




USHORT
spxConnGetId(
	VOID
	)
/*++

Routine Description:

	This must be called with the device lock held.

Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pSpxConnFile;
	BOOLEAN			wrapped = FALSE;
	USHORT			startConnId, retConnId;

    startConnId = SpxDevice->dev_NextConnId;

	//	Search the global active list.
	do
	{
		if ((SpxDevice->dev_NextConnId >= startConnId) && wrapped)
		{
            retConnId = 0;
			break;
		}

		if (SpxDevice->dev_NextConnId == 0xFFFF)
		{
			wrapped = TRUE;
			SpxDevice->dev_NextConnId	= 1;
			continue;
		}

		//	Later this be a tree.
		for (pSpxConnFile = SpxDevice->dev_GlobalActiveConnList[
								SpxDevice->dev_NextConnId & NUM_SPXCONN_HASH_MASK];
			 pSpxConnFile != NULL;
			 pSpxConnFile = pSpxConnFile->scf_GlobalActiveNext)
		{
			if (pSpxConnFile->scf_LocalConnId == SpxDevice->dev_NextConnId)
			{
				break;
			}
		}

		//	Increment for next time.
		retConnId = SpxDevice->dev_NextConnId++;

		//	Ensure we are still legal. We could return if connfile is null.
		if (SpxDevice->dev_NextConnId == 0xFFFF)
		{
			wrapped = TRUE;
			SpxDevice->dev_NextConnId	= 1;
		}

		if (pSpxConnFile != NULL)
		{
			continue;
		}

		break;

	} while (TRUE);

	return(retConnId);
}




NTSTATUS
spxConnRemoveFromList(
	IN	PSPX_CONN_FILE *	ppConnListHead,
	IN	PSPX_CONN_FILE		pConnRemove
	)

/*++

Routine Description:

	This routine must be called with the address lock (and the lock of the remove
	connection will usually also be, but is not needed) held.

Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pRemConn, *ppRemConn;
	NTSTATUS		status = STATUS_SUCCESS;

	//	Dequeue the connection file from the address list. It must be
	//	in the inactive list.
	for (ppRemConn = ppConnListHead;
		 (pRemConn = *ppRemConn) != NULL;)
	{
		if (pRemConn == pConnRemove)
		{
			*ppRemConn = pRemConn->scf_Next;
			break;
		}

		ppRemConn = &pRemConn->scf_Next;
	}

	if (pRemConn == NULL)
	{
		DBGBRK(FATAL);
		CTEAssert(0);
		status = STATUS_INVALID_CONNECTION;
	}

	return(status);
}




NTSTATUS
spxConnRemoveFromAssocList(
	IN	PSPX_CONN_FILE *	ppConnListHead,
	IN	PSPX_CONN_FILE		pConnRemove
	)

/*++

Routine Description:

	This routine must be called with the address lock (and the lock of the remove
	connection will usually also be, but is not needed) held.

Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pRemConn, *ppRemConn;
	NTSTATUS		status = STATUS_SUCCESS;

	//	Dequeue the connection file from the address list. It must be
	//	in the inactive list.
	for (ppRemConn = ppConnListHead;
		 (pRemConn = *ppRemConn) != NULL;)
	{
		if (pRemConn == pConnRemove)
		{
			*ppRemConn = pRemConn->scf_AssocNext;
			break;
		}

		ppRemConn = &pRemConn->scf_AssocNext;
	}

	if (pRemConn == NULL)
	{
		CTEAssert(0);
		status = STATUS_INVALID_CONNECTION;
	}

	return(status);
}




VOID
spxConnInsertIntoGlobalActiveList(
	IN	PSPX_CONN_FILE	pSpxConnFile
	)

/*++

Routine Description:

	This routine must be called with the device lock held.

Arguments:


Return Value:


--*/

{
	int				index = (int)(pSpxConnFile->scf_LocalConnId &
														NUM_SPXCONN_HASH_MASK);

	//	For now, its just a linear list.
	pSpxConnFile->scf_GlobalActiveNext	=
		SpxDevice->dev_GlobalActiveConnList[index];

    SpxDevice->dev_GlobalActiveConnList[index] =
		pSpxConnFile;

	return;
}




NTSTATUS
spxConnRemoveFromGlobalActiveList(
	IN	PSPX_CONN_FILE	pSpxConnFile
	)

/*++

Routine Description:

	This routine must be called with the device lock held.

Arguments:


Return Value:


--*/

{
    PSPX_CONN_FILE	pC, *ppC;
	int				index = (int)(pSpxConnFile->scf_LocalConnId &
														NUM_SPXCONN_HASH_MASK);
	NTSTATUS		status = STATUS_SUCCESS;

	//	For now, its just a linear list.
	for (ppC = &SpxDevice->dev_GlobalActiveConnList[index];
		(pC = *ppC) != NULL;)
	{
		if (pC == pSpxConnFile)
		{
			DBGPRINT(SEND, INFO,
					("SpxConnRemoveFromGlobal: %lx\n", pSpxConnFile));

			//	Remove from list
			*ppC = pC->scf_GlobalActiveNext;
			break;
		}

		ppC = &pC->scf_GlobalActiveNext;
	}

	if (pC	== NULL)
		status = STATUS_INVALID_CONNECTION;

	return(status);
}




VOID
spxConnInsertIntoGlobalList(
	IN	PSPX_CONN_FILE	pSpxConnFile
	)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
	CTELockHandle	lockHandle;

	//	Get the global q lock
	CTEGetLock(&SpxGlobalQInterlock, &lockHandle);
	pSpxConnFile->scf_GlobalNext	= SpxGlobalConnList;
    SpxGlobalConnList				= pSpxConnFile;
	CTEFreeLock(&SpxGlobalQInterlock, lockHandle);

	return;
}




NTSTATUS
spxConnRemoveFromGlobalList(
	IN	PSPX_CONN_FILE	pSpxConnFile
	)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
	CTELockHandle	lockHandle;
    PSPX_CONN_FILE	pC, *ppC;
	NTSTATUS		status = STATUS_SUCCESS;

	//	Get the global q lock
	CTEGetLock(&SpxGlobalQInterlock, &lockHandle);
	for (ppC = &SpxGlobalConnList;
		(pC = *ppC) != NULL;)
	{
		if (pC == pSpxConnFile)
		{
			DBGPRINT(SEND, DBG,
					("SpxConnRemoveFromGlobal: %lx\n", pSpxConnFile));

			//	Remove from list
			*ppC = pC->scf_GlobalNext;
			break;
		}

		ppC = &pC->scf_GlobalNext;
	}
	CTEFreeLock(&SpxGlobalQInterlock, lockHandle);

	if (pC	== NULL)
		status = STATUS_INVALID_CONNECTION;

	return(status);
}






#if 0

VOID
spxConnPushIntoPktList(
	IN	PSPX_CONN_FILE	pSpxConnFile
	)

/*++

Routine Description:

	!!!MACROIZE!!!

Arguments:


Return Value:


--*/

{
	CTELockHandle	lockHandle;

	//	Get the global q lock
	CTEGetLock(&SpxGlobalQInterlock, &lockHandle);
	pSpxConnFile->scf_PktNext	= SpxPktConnList;
    SpxPktConnList		        = pSpxConnFile;
	CTEFreeLock(&SpxGlobalQInterlock, lockHandle);

	return;
}




VOID
spxConnPopFromPktList(
	IN	PSPX_CONN_FILE	* ppSpxConnFile
	)

/*++

Routine Description:

	!!!MACROIZE!!!

Arguments:


Return Value:


--*/

{
	CTELockHandle	lockHandle;

	//	Get the global q lock
	CTEGetLock(&SpxGlobalQInterlock, &lockHandle);
	if ((*ppSpxConnFile = SpxPktConnList) != NULL)
	{
		SpxPktConnList = SpxPktConnList->scf_PktNext;
		DBGPRINT(SEND, DBG,
				("SpxConnRemoveFromPkt: %lx\n", *ppSpxConnFile));
	}
	CTEFreeLock(&SpxGlobalQInterlock, lockHandle);
	return;
}




VOID
spxConnPushIntoRecvList(
	IN	PSPX_CONN_FILE	pSpxConnFile
	)

/*++

Routine Description:

	!!!MACROIZE!!!

Arguments:


Return Value:


--*/

{
	CTELockHandle	lockHandle;

	//	Get the global q lock
	CTEGetLock(&SpxGlobalQInterlock, &lockHandle);
	pSpxConnFile->scf_ProcessRecvNext	= SpxRecvConnList;
    SpxRecvConnList		        		= pSpxConnFile;
	CTEFreeLock(&SpxGlobalQInterlock, lockHandle);

	return;
}




VOID
spxConnPopFromRecvList(
	IN	PSPX_CONN_FILE	* ppSpxConnFile
	)

/*++

Routine Description:

	!!!MACROIZE!!!

Arguments:


Return Value:


--*/

{
	CTELockHandle	lockHandle;

	//	Get the global q lock
	CTEGetLock(&SpxGlobalQInterlock, &lockHandle);
	if ((*ppSpxConnFile = SpxRecvConnList) != NULL)
	{
		SpxRecvConnList = SpxRecvConnList->scf_ProcessRecvNext;
		DBGPRINT(SEND, INFO,
				("SpxConnRemoveFromRecv: %lx\n", *ppSpxConnFile));
	}
	CTEFreeLock(&SpxGlobalQInterlock, lockHandle);
	return;
}

#endif


//
//	Reference/Dereference routines
//


#if DBG

VOID
SpxConnFileRef(
    IN PSPX_CONN_FILE pSpxConnFile
    )

/*++

Routine Description:

    This routine increments the reference count on an address file.

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{

    CTEAssert ((LONG)pSpxConnFile->scf_RefCount >= 0);   // not perfect, but...

    (VOID)SPX_ADD_ULONG (
            &pSpxConnFile->scf_RefCount,
            1,
            &pSpxConnFile->scf_Lock);

} // SpxRefConnectionFile




VOID
SpxConnFileLockRef(
    IN PSPX_CONN_FILE pSpxConnFile
    )

/*++

Routine Description:

    This routine increments the reference count on an address file.
    IT IS CALLED WITH THE CONNECTION LOCK HELD.

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{

    CTEAssert ((LONG)pSpxConnFile->scf_RefCount >= 0);   // not perfect, but...

    (VOID)SPX_ADD_ULONG (
            &pSpxConnFile->scf_RefCount,
            1,
            &pSpxConnFile->scf_Lock);

} // SpxRefConnectionFileLock

#endif




VOID
SpxConnFileRefByIdLock (
	IN	USHORT				ConnId,
    OUT PSPX_CONN_FILE 	* 	ppSpxConnFile,
	OUT	PNTSTATUS  			pStatus
    )

/*++

Routine Description:

	!!!MUST BE CALLED WITH THE DEVICE LOCK HELD!!!

	All active connections should be on the device active list. Later,
	this data structure will be a tree, caching the last accessed
	connection.

Arguments:



Return Value:

    STATUS_SUCCESS if all is well; STATUS_INVALID_CONNECTION otherwise

--*/
{
	PSPX_CONN_FILE	pSpxChkConn;

	*pStatus = STATUS_SUCCESS;

	for (pSpxChkConn =
			SpxDevice->dev_GlobalActiveConnList[ConnId & NUM_SPXCONN_HASH_MASK];
		 pSpxChkConn != NULL;
		 pSpxChkConn = pSpxChkConn->scf_GlobalActiveNext)
	{
		if (pSpxChkConn->scf_LocalConnId == ConnId)
		{
			SpxConnFileReference(pSpxChkConn, CFREF_BYID);
			*ppSpxConnFile = pSpxChkConn;
			break;
		}
	}

	if (pSpxChkConn == NULL)
	{
		*pStatus = STATUS_INVALID_CONNECTION;
	}

	return;

}




VOID
SpxConnFileRefByCtxLock(
	IN	PSPX_ADDR_FILE		pSpxAddrFile,
	IN	CONNECTION_CONTEXT	Ctx,
	OUT	PSPX_CONN_FILE	*	ppSpxConnFile,
	OUT	PNTSTATUS			pStatus
	)
/*++

Routine Description:

	!!!MUST BE CALLED WITH THE ADDRESS LOCK HELD!!!

	Returns a referenced connection file with the associated context and
	address file desired.

Arguments:


Return Value:


--*/
{
	PSPX_CONN_FILE	pSpxChkConn = NULL;
    BOOLEAN         Found       = FALSE;

	*pStatus = STATUS_SUCCESS;

	for (pSpxChkConn = pSpxAddrFile->saf_Addr->sa_InactiveConnList;
		 pSpxChkConn != NULL;
		 pSpxChkConn = pSpxChkConn->scf_Next)
	{
		if ((pSpxChkConn->scf_ConnCtx == Ctx) &&
			(pSpxChkConn->scf_AddrFile == pSpxAddrFile))
		{
			SpxConnFileReference(pSpxChkConn, CFREF_BYCTX);
			*ppSpxConnFile = pSpxChkConn;
            Found = TRUE;
			break;
		}
	}

	if (!Found)
	{
		*pStatus = STATUS_INVALID_CONNECTION;
	}

	return;
}




NTSTATUS
SpxConnFileVerify (
    IN PSPX_CONN_FILE pConnFile
    )

/*++

Routine Description:

    This routine is called to verify that the pointer given us in a file
    object is in fact a valid address file object. We also verify that the
    address object pointed to by it is a valid address object, and reference
    it to keep it from disappearing while we use it.

Arguments:



Return Value:

    STATUS_SUCCESS if all is well; STATUS_INVALID_CONNECTION otherwise

--*/

{
    CTELockHandle 	LockHandle;
    NTSTATUS 		status = STATUS_SUCCESS;

    try
	{
        if ((pConnFile->scf_Size == sizeof (SPX_CONN_FILE)) &&
            (pConnFile->scf_Type == SPX_CONNFILE_SIGNATURE))
		{
            CTEGetLock (&pConnFile->scf_Lock, &LockHandle);
			if (!SPX_CONN_FLAG(pConnFile, SPX_CONNFILE_CLOSING))
			{
				SpxConnFileLockReference(pConnFile, CFREF_VERIFY);
			}
			else
			{
				DBGPRINT(TDI, ERR,
						("StVerifyConnFile: A %lx closing\n", pConnFile));

				status = STATUS_INVALID_CONNECTION;
			}
			CTEFreeLock (&pConnFile->scf_Lock, LockHandle);
        }
		else
		{
            DBGPRINT(TDI, ERR,
					("StVerifyAddressFile: AF %lx bad signature\n", pConnFile));

            status = STATUS_INVALID_CONNECTION;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

         DBGPRINT(TDI, ERR,
				("SpxVerifyConnFile: AF %lx exception\n", pConnFile));

         return GetExceptionCode();
    }

    return status;

}   // SpxVerifyConnFile




VOID
SpxConnFileDeref(
    IN PSPX_CONN_FILE pSpxConnFile
    )

/*++

Routine Description:

    This routine dereferences an address file by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    SpxDestroyConnectionFile to remove it from the system.

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{
    ULONG 			oldvalue;
    BOOLEAN         fDiscNotIndicated = FALSE;
    BOOLEAN         fIDiscFlag = FALSE;
    BOOLEAN         fSpx2;

	CTEAssert(pSpxConnFile->scf_RefCount > 0);
    oldvalue = SPX_ADD_ULONG (
                &pSpxConnFile->scf_RefCount,
                (ULONG)-1,
                &pSpxConnFile->scf_Lock);

    CTEAssert (oldvalue > 0);
    if (oldvalue == 1)
	{
		CTELockHandle		lockHandleConn, lockHandleAddr, lockHandleDev;
		LIST_ENTRY			discReqList, *p;
		PREQUEST			pDiscReq;
		PSPX_ADDR_FILE		pSpxAddrFile = NULL;
		PREQUEST			pCloseReq = NULL,
							pCleanupReq = NULL,
							pConnectReq = NULL;
		BOOLEAN				fDisassoc = FALSE;

		InitializeListHead(&discReqList);

		//	We may not be associated at this point. Note: When we are active we
		//	always have a reference. So its not like we execute this code very often.
		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
		if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC))
		{
			pSpxAddrFile = pSpxConnFile->scf_AddrFile;
		}
		else
		{
			if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_STOPPING))
			{
				DBGPRINT(TDI, DBG,
						("SpxDerefConnectionFile: Conn cleanup %lx.%lx\n",
							pSpxConnFile,
							pSpxConnFile->scf_CleanupReq));
	
				// Save this for later completion.
				pCleanupReq = pSpxConnFile->scf_CleanupReq;
                pSpxConnFile->scf_CleanupReq = NULL;
			}

			if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_CLOSING))
			{
				DBGPRINT(TDI, DBG,
						("SpxDerefConnectionFile: Conn closing %lx\n",
							pSpxConnFile));
	
				// Save this for later completion.
				pCloseReq = pSpxConnFile->scf_CloseReq;

                //
                // Null this out so on a re-entrant case, we dont try to complete this again.
                //
                pSpxConnFile->scf_CloseReq = NULL;
				CTEAssert(pCloseReq != NULL);
			}
		}
		CTEFreeLock (&pSpxConnFile->scf_Lock, lockHandleConn);

		if (pSpxAddrFile)
		{
			CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
			CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandleAddr);
			CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);

			//if (pSpxConnFile->scf_RefCount == 0)

            //
            // ** The lock passed here is a dummy - it is pre-compiled out.
            //
            if (SPX_ADD_ULONG(&pSpxConnFile->scf_RefCount, 0, &pSpxConnFile->scf_Lock) == 0)
			{
				DBGPRINT(TDI, INFO,
						("SpxDerefConnectionFile: Conn is 0 %lx.%lx\n",
							pSpxConnFile, pSpxConnFile->scf_Flags));
	
				//	All pending requests on this connection are done. See if we
				//	need to complete the disconnect phase etc.
				switch (SPX_MAIN_STATE(pSpxConnFile))
				{
				case SPX_CONNFILE_DISCONN:
	
					//	Disconnect is done. Move connection out of all the lists
					//	it is on, reset states etc.
					DBGPRINT(TDI, INFO,
							("SpxDerefConnectionFile: Conn being inactivated %lx\n",
								pSpxConnFile));

					//	Time to complete disc requests if present.
					//	There could be multiple of them.
					p = pSpxConnFile->scf_DiscLinkage.Flink;
					while (p != &pSpxConnFile->scf_DiscLinkage)
					{
						pDiscReq = LIST_ENTRY_TO_REQUEST(p);
						p = p->Flink;

						DBGPRINT(TDI, DBG,
								("SpxDerefConnectionFile: Disc on %lx.%lx\n",
									pSpxConnFile, pDiscReq));
	
						RemoveEntryList(REQUEST_LINKAGE(pDiscReq));

						if (REQUEST_STATUS(pDiscReq) == STATUS_PENDING)
						{
							REQUEST_STATUS(pDiscReq) = STATUS_SUCCESS;
						}

						InsertTailList(
							&discReqList,
							REQUEST_LINKAGE(pDiscReq));
					}

                    //
                    // Note the state here, and check after the conn has been inactivated.
                    //

                    //
                    // Bug #14354 - odisc and idisc cross each other, leading to double disc to AFD
                    //
                    if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC) &&
                        !SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_ODISC)) {
                        fDiscNotIndicated = TRUE;
                    }

                    if (SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_IDISC)) {
                        fIDiscFlag = TRUE;
                    }

                    fSpx2 = (SPX2_CONN(pSpxConnFile)) ? TRUE : FALSE;

                    //
                    // [SA] Bug #14655
                    // Do not try to inactivate an already inactivated connection
                    //

                    if (!(SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED)) {
                        spxConnInactivate(pSpxConnFile);
                    } else {
                        //
                        // This is an SPXI connection which has got the local disconnect.
                        // Reset the flags now.
                        //
                        CTEAssert(!fDiscNotIndicated);

                        SPX_MAIN_SETSTATE(pSpxConnFile, 0);
                        SPX_DISC_SETSTATE(pSpxConnFile, 0);
                        SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC);
                    }

                    //
                    // [SA] If we were waiting for sends to be aborted and did not indicate this
                    // disconnect to AFD; and AFD did not call a disconnect on this connection,
                    // then call the disonnect handler now.
                    //
                    if (fDiscNotIndicated) {
                        PVOID 					pDiscHandlerCtx;
                        PTDI_IND_DISCONNECT 	pDiscHandler	= NULL;
                        ULONG   discCode = 0;

                        pDiscHandler 	= pSpxConnFile->scf_AddrFile->saf_DiscHandler;
                        pDiscHandlerCtx = pSpxConnFile->scf_AddrFile->saf_DiscHandlerCtx;

                        //	Indicate disconnect to afd.
                        if (pDiscHandler != NULL) {

                            //
                            // If this was an SPXI connection, the disconnect state is still
                            // DISCONN, so if this routine is re-entered, we need to prevent
                            // a re-indicate to AFD.
                            // Also, we need to wait for a local disconnect from AFD since
                            // we indicated a TDI_DISCONNECT_RELEASE. We bump up the ref count
                            // in this case.
                            //
                            if (!fSpx2) {
                                CTEAssert(  (SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
                                            (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_INACTIVATED)  );

                                SPX_CONN_SETFLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC);

                                if (fIDiscFlag) {
                                    SpxConnFileLockReference(pSpxConnFile, CFREF_DISCWAITSPX);
                                    SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_DISC_WAIT);
                                }
                            }

                            CTEFreeLock (&pSpxConnFile->scf_Lock, lockHandleConn);
                            CTEFreeLock (pSpxAddrFile->saf_AddrLock, lockHandleAddr);
                            CTEFreeLock (&SpxDevice->dev_Lock, lockHandleDev);

                            DBGPRINT(CONNECT, INFO,
                                    ("spxDerefConnectionFile: Indicating to afd On %lx when %lx\n",
                                        pSpxConnFile, SPX_MAIN_STATE(pSpxConnFile)));

                            //	First complete all requests waiting for receive completion on
                            //	this conn before indicating disconnect.
                            spxConnCompletePended(pSpxConnFile);

                            if (fIDiscFlag) {
                                //
                                // Indicate DISCONNECT_RELEASE to AFD so it allows receive of packets
                                // it has buffered before the remote disconnect took place.
                                //
                                discCode = TDI_DISCONNECT_RELEASE;
                            } else {
                                //
                                // [SA] bug #15249
                                // If not Informed disconnect, indicate DISCONNECT_ABORT to AFD
                                //
                                discCode = TDI_DISCONNECT_ABORT;
                            }

                            (*pDiscHandler)(
                                    pDiscHandlerCtx,
                                    pSpxConnFile->scf_ConnCtx,
                                    0,								// Disc data
                                    NULL,
                                    0,								// Disc info
                                    NULL,
                                    discCode);

                            CTEGetLock(&SpxDevice->dev_Lock, &lockHandleDev);
                            CTEGetLock(pSpxAddrFile->saf_AddrLock, &lockHandleAddr);
                            CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandleConn);
                        }
                    }

					--SpxDevice->dev_Stat.OpenConnections;

					break;
	
				case SPX_CONNFILE_CONNECTING:
				case SPX_CONNFILE_LISTENING:

					//	Get connect/accept request if present.
					pConnectReq = pSpxConnFile->scf_ConnectReq;
					pSpxConnFile->scf_ConnectReq = NULL;

					spxConnInactivate(pSpxConnFile);
					break;

				case SPX_CONNFILE_ACTIVE:
	
					KeBugCheck(0);
			
				default:

					CTEAssert(SPX_MAIN_STATE(pSpxConnFile) == 0);
					break;
				}
	
				//	If stopping, disassociate from the address file. Complete
				//	cleanup request.
				if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_STOPPING))
				{
					DBGPRINT(TDI, DBG,
							("SpxDerefConnectionFile: Conn cleanup %lx.%lx\n",
								pSpxConnFile,
								pSpxConnFile->scf_CleanupReq));
		
					// Save this for later completion.
					pCleanupReq = pSpxConnFile->scf_CleanupReq;
					pSpxConnFile->scf_CleanupReq = NULL;
	
					SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_STOPPING);
					if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_ASSOC))
					{
						DBGPRINT(TDI, INFO,
								("SpxDerefConnectionFile: Conn stopping %lx\n",
									pSpxConnFile));
		
						pSpxAddrFile =  pSpxConnFile->scf_AddrFile;
						SPX_CONN_RESETFLAG(pSpxConnFile,SPX_CONNFILE_ASSOC);
		
						//	Dequeue the connection from the address file
						spxConnRemoveFromAssocList(
							&pSpxAddrFile->saf_AssocConnList,
							pSpxConnFile);
				
						//	Dequeue the connection file from the address list. It must
						//	be in the inactive list.
						spxConnRemoveFromList(
							&pSpxAddrFile->saf_Addr->sa_InactiveConnList,
							pSpxConnFile);
				
						DBGPRINT(CREATE, INFO,
								("SpxConnDerefDisAssociate: %lx from addr file %lx\n",
									pSpxConnFile, pSpxAddrFile));
				
						fDisassoc = TRUE;
					}
				}
	
				if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_CLOSING))
				{
					DBGPRINT(TDI, DBG,
							("SpxDerefConnectionFile: Conn closing %lx\n",
								pSpxConnFile));
		
					// Save this for later completion.
					pCloseReq = pSpxConnFile->scf_CloseReq;

                    //
                    // Null this out so on a re-entrant case, we dont try to complete this again.
                    //
                    pSpxConnFile->scf_CloseReq = NULL;
					CTEAssert(pCloseReq != NULL);
				}

				CTEAssert(IsListEmpty(&pSpxConnFile->scf_ReqLinkage));
				CTEAssert(IsListEmpty(&pSpxConnFile->scf_RecvLinkage));
				CTEAssert(IsListEmpty(&pSpxConnFile->scf_DiscLinkage));
			}
			CTEFreeLock (&pSpxConnFile->scf_Lock, lockHandleConn);
			CTEFreeLock (pSpxAddrFile->saf_AddrLock, lockHandleAddr);
			CTEFreeLock (&SpxDevice->dev_Lock, lockHandleDev);
		}

		if (fDisassoc)
		{
			//	Remove reference on address for this association.
			SpxAddrFileDereference(pSpxAddrFile, AFREF_CONN_ASSOC);
		}

		if (pConnectReq != (PREQUEST)NULL)
		{
			DBGPRINT(TDI, DBG,
					("SpxDerefConnectionFile: Connect on %lx req %lx\n",
						pSpxConnFile, pConnectReq));

			//	Status will already be set in here. We should be here only if
			//	connect is being aborted.
			SpxCompleteRequest(pConnectReq);
		}

		while (!IsListEmpty(&discReqList))
		{
			p = RemoveHeadList(&discReqList);
			pDiscReq = LIST_ENTRY_TO_REQUEST(p);
	
			DBGPRINT(CONNECT, DBG,
					("SpxConnFileDeref: DISC REQ %lx.%lx Completing\n",
						pSpxConnFile, pDiscReq));
	
			SpxCompleteRequest(pDiscReq);
		}

		if (pCleanupReq != (PREQUEST)NULL)
		{
			DBGPRINT(TDI, DBG,
					("SpxDerefConnectionFile: Cleanup complete %lx req %lx\n",
						pSpxConnFile, pCleanupReq));

			REQUEST_INFORMATION(pCleanupReq) = 0;
			REQUEST_STATUS(pCleanupReq) = STATUS_SUCCESS;
			SpxCompleteRequest (pCleanupReq);
		}

		if (pCloseReq != (PREQUEST)NULL)
		{
			DBGPRINT(TDI, DBG,
					("SpxDerefConnectionFile: Freed %lx close req %lx\n",
						pSpxConnFile, pCloseReq));

			CTEAssert(pSpxConnFile->scf_RefCount == 0);

			//	Remove from the global list
			if (!NT_SUCCESS(spxConnRemoveFromGlobalList(pSpxConnFile)))
			{
				KeBugCheck(0);
			}

			// 	Free it up.
			SpxFreeMemory (pSpxConnFile);
		
			REQUEST_INFORMATION(pCloseReq) = 0;
			REQUEST_STATUS(pCloseReq) = STATUS_SUCCESS;
			SpxCompleteRequest (pCloseReq);
		}
    }

	return;

}   // SpxDerefConnectionFile




VOID
spxConnReInit(
	IN	PSPX_CONN_FILE		pSpxConnFile
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	//	Reinit all variables.
    pSpxConnFile->scf_Flags2			= 0;

    pSpxConnFile->scf_GlobalActiveNext 	= NULL;
    pSpxConnFile->scf_PktNext			= NULL;
	pSpxConnFile->scf_CRetryCount		= 0;
	pSpxConnFile->scf_WRetryCount		= 0;
	pSpxConnFile->scf_RRetryCount		= 0;
	pSpxConnFile->scf_RRetrySeqNum		= 0;

	pSpxConnFile->scf_CTimerId =
	pSpxConnFile->scf_RTimerId =
	pSpxConnFile->scf_WTimerId =
	pSpxConnFile->scf_TTimerId =
	pSpxConnFile->scf_ATimerId = 0;

	pSpxConnFile->scf_LocalConnId	=
	pSpxConnFile->scf_SendSeqNum	=
	pSpxConnFile->scf_SentAllocNum	=
	pSpxConnFile->scf_RecvSeqNum	=
	pSpxConnFile->scf_RetrySeqNum	=
	pSpxConnFile->scf_RecdAckNum	=
    pSpxConnFile->scf_RemConnId		=
	pSpxConnFile->scf_RecdAllocNum	= 0;

#if DBG
	//	Initialize so we dont hit breakpoint on seq 0
	pSpxConnFile->scf_PktSeqNum 	= 0xFFFF;
#endif

	pSpxConnFile->scf_DataType		= 0;

	CTEAssert(IsListEmpty(&pSpxConnFile->scf_ReqLinkage));
	CTEAssert(IsListEmpty(&pSpxConnFile->scf_DiscLinkage));
	CTEAssert(IsListEmpty(&pSpxConnFile->scf_RecvLinkage));
	CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);
	CTEAssert(pSpxConnFile->scf_RecvListTail == NULL);
	CTEAssert(pSpxConnFile->scf_SendListHead == NULL);
	CTEAssert(pSpxConnFile->scf_SendListTail == NULL);
	CTEAssert(pSpxConnFile->scf_SendSeqListHead == NULL);
	CTEAssert(pSpxConnFile->scf_SendSeqListTail == NULL);
	pSpxConnFile->scf_CurRecvReq	= NULL;
	pSpxConnFile->scf_CurRecvOffset	= 0;
	pSpxConnFile->scf_CurRecvSize	= 0;

	pSpxConnFile->scf_ReqPkt		= NULL;

	return;
}




VOID
spxConnInactivate(
	IN	PSPX_CONN_FILE		pSpxConnFile
	)
/*++

Routine Description:

	!!! Called with dev/addr/connection lock held !!!

Arguments:

	This gets us back to associate SAVING the state of the STOPPING and
	CLOSING flags so that dereference can go ahead and finish those.

Return Value:


--*/
{
	BOOLEAN	fStopping, fClosing, fAborting;

	fStopping = SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_STOPPING);
	fClosing  = SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_CLOSING);

    //
    // [SA] Bug #14655
    // Save the disconnect states so that a proper error can be given in the case of
    // a send after a remote disconnection.
    //

    //
    // Bug #17729
    // Dont retain these flags if a local disconnect has already occured.
    //

    fAborting = (!SPX2_CONN(pSpxConnFile) &&
                 !SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_IND_IDISC) &&
                 (SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
                 (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_ABORT));

#if DBG
	pSpxConnFile->scf_GhostFlags	= pSpxConnFile->scf_Flags;
	pSpxConnFile->scf_GhostFlags2	= pSpxConnFile->scf_Flags2;
	pSpxConnFile->scf_GhostRefCount	= pSpxConnFile->scf_RefCount;
#endif

	//	Clear all flags, go back to the assoc state. Restore stop/close
	pSpxConnFile->scf_Flags 	   	= SPX_CONNFILE_ASSOC;
	SPX_CONN_SETFLAG(pSpxConnFile,
					((fStopping ? SPX_CONNFILE_STOPPING : 0) |
					 (fClosing  ? SPX_CONNFILE_CLOSING : 0)));

    //
    // [SA] bug #14655
    // In order to avoid a re-entry, mark connection as SPX_DISC_INACTIVATED
    //
    if (fAborting)
    {
        SPX_MAIN_SETSTATE(pSpxConnFile, SPX_CONNFILE_DISCONN);
        SPX_DISC_SETSTATE(pSpxConnFile, SPX_DISC_INACTIVATED);
    }

	//	Remove connection from global list on device
	if (!NT_SUCCESS(spxConnRemoveFromGlobalActiveList(
						pSpxConnFile)))
	{
		KeBugCheck(0);
	}

	//	Remove connection from active list on address
	if (!NT_SUCCESS(spxConnRemoveFromList(
						&pSpxConnFile->scf_AddrFile->saf_Addr->sa_ActiveConnList,
						pSpxConnFile)))
	{
		KeBugCheck(0);
	}

	//	Put connection in inactive list on address
	SPX_INSERT_ADDR_INACTIVE(
		pSpxConnFile->scf_AddrFile->saf_Addr,
		pSpxConnFile);

	spxConnReInit(pSpxConnFile);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxdev.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxdev.h

Abstract:

    This module contains definitions specific to the
    SPX module of the ISN transport.

Author:

        Adam   Barr              (adamba ) Original Version
    Nikhil Kamkolkar (nikhilk) 17-November-1993

Environment:

    Kernel mode

Revision History:

--*/


// Hash buckets for SPX_ADDR done using socket number
#define NUM_SPXADDR_HASH_BUCKETS        8
#define NUM_SPXADDR_HASH_MASK           7
#define NUM_SPXCONN_HASH_BUCKETS        8
#define NUM_SPXCONN_HASH_MASK           7

// This structure defines the per-device structure for SPX
// (one of these is allocated globally).
#define DREF_CREATE   0
#define DREF_LOADED   1
#define DREF_ADAPTER  2
#define DREF_ADDRESS  3
#define DREF_ORPHAN       4

#define DREF_TOTAL    5

typedef struct _DEVICE {

    PDEVICE_OBJECT   dev_DevObj;                         // the I/O system's device object.

#if DBG
    ULONG           dev_RefTypes[DREF_TOTAL];
#endif

    CSHORT          dev_Type;               // type of this structure
    USHORT          dev_Size;               // size of this structure

#if DBG
    UCHAR                       dev_Signature1[4];              // contains "SPX1"
#endif

    // activity count/this provider.
    LONG                        dev_RefCount;
    UCHAR                       dev_State;

    // number of adapters IPX is bound to.
    USHORT          dev_Adapters;

        // GLOBAL lock for reference count (used in ExInterlockedXxx calls).
    CTELock             dev_Interlock;
    CTELock             dev_Lock;

        //      Hash table of lists of addresses opened on this device
        struct  _SPX_ADDR               *       dev_AddrHashTable[NUM_SPXADDR_HASH_BUCKETS];

        //      List of all active connections, later this be a tree.
        struct  _SPX_CONN_FILE  *       dev_GlobalActiveConnList[NUM_SPXCONN_HASH_BUCKETS];
        USHORT                                          dev_NextConnId;

    // Other configuration parameters.
    // Where the current socket allocation is.
    USHORT                      dev_CurrentSocket;

    // Our node and network.
    UCHAR                       dev_Network[4];
    UCHAR                       dev_Node[6];

        //      Pointer to the config information from registry
        PCONFIG                 dev_ConfigInfo;

        //      Control channel identifier
        ULONG                   dev_CcId;

    // These are kept around for error logging, and stored right
    // after this structure.
    PWCHAR          dev_DeviceName;
#if     defined(_PNP_POWER)
    USHORT           dev_DeviceNameLen;
#else
    ULONG           dev_DeviceNameLen;
#endif  _PNP_POWER

#if DBG
    UCHAR                       dev_Signature2[4];      // contains "SPX2"
#endif

        //      Handle to ndis buffer pool for spx stack.
        NDIS_HANDLE             dev_NdisBufferPoolHandle;

    // registration handle with tdi clients.
#if     defined(_PNP_POWER)
    HANDLE              dev_TdiRegistrationHandle;
#endif  _PNP_POWER

    // This interlock is used to guard access to the statistics
    // define below.
    KSPIN_LOCK          dev_StatInterlock;              // for ULONG quantities
    KSPIN_LOCK          dev_StatSpinLock;       // for LARGE_INTEGER quantities

    // Counters for most of the statistics that SPX maintains;
    // some of these are kept elsewhere. Including the structure
    // itself wastes a little space but ensures that the alignment
    // inside the structure is correct.
    TDI_PROVIDER_STATISTICS dev_Stat;

    // This resource guards access to the ShareAccess
    // and SecurityDescriptor fields in addresses.
    ERESOURCE           dev_AddrResource;

    // The following structure contains statistics counters for use
    // by TdiQueryInformation and TdiSetInformation.  They should not
    // be used for maintenance of internal data structures.
    TDI_PROVIDER_INFO dev_ProviderInfo;     // information about this provider.

} DEVICE, * PDEVICE;

//
// As part of "doing it ourselves" theme as opposed to the DeviceExtension code,
// we declare a global SpxDevice that will be used by all.
//
//PDEVICE         SpxDevice;
//PDEVICE_OBJECT  DeviceObject;

// device state definitions
#if     defined(_PNP_POWER)
#define DEVICE_STATE_CLOSED   0x00      // Initial state
#define DEVICE_STATE_LOADED   0x01      // Loaded and bound to IPX but no adapters
#define DEVICE_STATE_OPEN     0x02      // Fully operational
#define DEVICE_STATE_STOPPING 0x03      // Unload has been initiated, The I/O system
                                        // will not call us until nobody above has Netbios open.
#else
#define DEVICE_STATE_CLOSED   0x00
#define DEVICE_STATE_OPEN     0x01
#define DEVICE_STATE_STOPPING 0x02
#endif  _PNP_POWER


//  SPX device name
#define SPX_DEVICE_NAME         L"\\Device\\NwlnkSpx"

#define SPX_TDI_RESOURCES     9


//      MACROS
#if DBG

#define SpxReferenceDevice(_Device, _Type)                              \
                {                                                                                               \
                        (VOID)SPX_ADD_ULONG (                           \
                                &(_Device)->dev_RefTypes[_Type],                \
                                1,                                                                              \
                                &SpxGlobalInterlock);                                   \
                                                                                                                \
                        (VOID)InterlockedIncrement (                      \
                                          &(_Device)->dev_RefCount);                     \
                }

#define SpxDereferenceDevice(_Device, _Type)                    \
                {                                                                                               \
                        (VOID)SPX_ADD_ULONG (                           \
                                &(_Device)->dev_RefTypes[_Type],                \
                                (ULONG)-1,                                                              \
                                &SpxGlobalInterlock);                                   \
                        SpxDerefDevice (_Device);                                       \
                }

#else

#define SpxReferenceDevice(_Device, _Type)                              \
                {                                                                                               \
                        (VOID)InterlockedIncrement (                      \
                                          &(_Device)->dev_RefCount);                     \
                }

#define SpxDereferenceDevice(_Device, _Type)                    \
                        SpxDerefDevice (_Device)

#endif

//  EXPORTED ROUTINES

VOID
SpxDestroyDevice(
    IN PDEVICE Device);

VOID
SpxDerefDevice(
    IN PDEVICE Device);

NTSTATUS
SpxInitCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING DeviceName);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxdrvr.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxdrvr.c

Abstract:

    This module contains the DriverEntry and other initialization
    code for the SPX/SPXII module of the ISN transport.

Author:

	Adam   Barr		 (adamba)  Original Version
    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

   Sanjay Anand (SanjayAn) 14-July-1995
   Bug fixes - tagged [SA]

--*/

#include "precomp.h"
#pragma hdrstop

//	Define module number for event logging entries
#define	FILENUM		SPXDRVR

// Forward declaration of various routines used in this module.

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath);

NTSTATUS
SpxDispatchOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
SpxDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
SpxDispatchInternal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
SpxDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

VOID
SpxUnload(
    IN PDRIVER_OBJECT DriverObject);

VOID
SpxTdiCancel(
    IN PDEVICE_OBJECT 	DeviceObject,
    IN PIRP 			Irp);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SpxUnload)
#pragma alloc_text(PAGE, SpxDispatch)
#pragma alloc_text(PAGE, SpxDeviceControl)
#pragma alloc_text(PAGE, SpxUnload)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT 	DriverObject,
    IN PUNICODE_STRING 	RegistryPath
    )

/*++

Routine Description:

    This routine performs initialization of the SPX ISN module.
    It creates the device objects for the transport
    provider and performs other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

    RegistryPath - The name of ST's node in the registry.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNICODE_STRING	deviceName;
    NTSTATUS        status  = STATUS_SUCCESS;
    BOOLEAN         BoundToIpx = FALSE;
    //	DBGBRK(FATAL);

	// Initialize the Common Transport Environment.
	if (CTEInitialize() == 0) {
		return (STATUS_UNSUCCESSFUL);
	}

	//	We have this #define'd. Ugh, but CONTAINING_RECORD has problem owise.
	//CTEAssert(NDIS_PACKET_SIZE == FIELD_OFFSET(NDIS_PACKET, ProtocolReserved[0]));

	// Create the device object. (IoCreateDevice zeroes the memory
	// occupied by the object.)
	RtlInitUnicodeString(&deviceName, SPX_DEVICE_NAME);

    status = SpxInitCreateDevice(
				 DriverObject,
				 &deviceName);

	if (!NT_SUCCESS(status))
	{
		return(status);
	}

    do
	{
		CTEInitLock (&SpxGlobalInterlock);
		CTEInitLock (&SpxGlobalQInterlock);

        // 
        // We need the following locks for the NDIS_PACKETPOOL changes [MS]
        //
        CTEInitLock(&SendHeaderLock);
        CTEInitLock(&RecvHeaderLock);
        ExInitializeSListHead(&SendPacketList);
        ExInitializeSListHead(&RecvPacketList);

		//	Initialize the unload event
 		KeInitializeEvent(
			&SpxUnloadEvent,
			NotificationEvent,
			FALSE);

		//	!!!The device is created at this point!!!
        //  Get information from the registry.
        status  = SpxInitGetConfiguration(
                    RegistryPath,
                    &SpxDevice->dev_ConfigInfo);

        if (!NT_SUCCESS(status))
		{
            break;
        }

#if     defined(_PNP_POWER)
        //
        // Make Tdi ready for pnp notifications before binding
        // to IPX
        //
        TdiInitialize();

		//	Initialize the timer system. This should be done before
        //  binding to ipx because we should have timers intialized
        //  before ipx calls our pnp indications.
		if (!NT_SUCCESS(status = SpxTimerInit()))
		{
			break;
		}
#endif  _PNP_POWER

        //  Bind to the IPX transport.
        if (!NT_SUCCESS(status = SpxInitBindToIpx()))
		{
			//	Have ipx name here as second string
			LOG_ERROR(
				EVENT_TRANSPORT_BINDING_FAILED,
				status,
				NULL,
				NULL,
				0);

            break;
        }

        BoundToIpx = TRUE;

#if      !defined(_PNP_POWER)
		//	Initialize the timer system
		if (!NT_SUCCESS(status = SpxTimerInit()))
		{
			break;
		}
#endif  !_PNP_POWER

		//	Initialize the block manager
		if (!NT_SUCCESS(status = SpxInitMemorySystem(SpxDevice)))
		{

			//	Stop the timer subsystem
			SpxTimerFlushAndStop();
			break;
		}

        // Initialize the driver object with this driver's entry points.
        DriverObject->MajorFunction [IRP_MJ_CREATE]     = SpxDispatchOpenClose;
        DriverObject->MajorFunction [IRP_MJ_CLOSE]      = SpxDispatchOpenClose;
        DriverObject->MajorFunction [IRP_MJ_CLEANUP]    = SpxDispatchOpenClose;
        DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL]
                                                        = SpxDispatch;
        DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL]
                                                        = SpxDispatchInternal;
        DriverObject->DriverUnload                      = SpxUnload;

		//	Initialize the provider info
		SpxQueryInitProviderInfo(&SpxDevice->dev_ProviderInfo);
		SpxDevice->dev_CurrentSocket = (USHORT)PARAM(CONFIG_SOCKET_RANGE_START);

		//	We are open now.
		SpxDevice->dev_State		= DEVICE_STATE_OPEN;

		//	Set the window size in statistics
		SpxDevice->dev_Stat.MaximumSendWindow =
		SpxDevice->dev_Stat.AverageSendWindow = PARAM(CONFIG_WINDOW_SIZE) *
												IpxLineInfo.MaximumSendSize;

#if     defined(_PNP_POWER)
        if ( DEVICE_STATE_CLOSED == SpxDevice->dev_State ) {
            SpxDevice->dev_State = DEVICE_STATE_LOADED;
        }
#endif  _PNP_POWER

    } while (FALSE);



    

    DBGPRINT(DEVICE, INFO,
                        ("SpxInitCreateDevice - Create device %ws\n", deviceName.Buffer));

    // Create the device object for the sample transport, allowing
    // room at the end for the device name to be stored (for use
    // in logging errors).
    
    status = IoCreateDevice(
                 DriverObject,
                 0, //DeviceSize,
                 &deviceName,
                 FILE_DEVICE_TRANSPORT,
                 FILE_DEVICE_SECURE_OPEN,
                 FALSE,
                 &SpxDevice->dev_DevObj);

    if (!NT_SUCCESS(status)) {
        DBGPRINT(DEVICE, ERR, ("IoCreateDevice failed\n"));
        
        //
        // We're outta here forever.
        //
        ExFreePool(SpxDevice);
        return status;
    }

    SpxDevice->dev_DevObj->Flags     |= DO_DIRECT_IO;

	if (!NT_SUCCESS(status) )
	{
		//	Delete the device and any associated resources created.
        if( BoundToIpx ) {
		    SpxDerefDevice(SpxDevice);
        }
		SpxDestroyDevice(SpxDevice);
	}

    return (status);
}




VOID
SpxUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine unloads the sample transport driver. The I/O system will not
	call us until nobody above has ST open.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None. When the function returns, the driver is unloaded.

--*/

{
    UNREFERENCED_PARAMETER (DriverObject);

	//	Stop the timer subsystem
	SpxTimerFlushAndStop();

	CTEFreeMem(SpxDevice->dev_ConfigInfo); 

	RtlFreeUnicodeString (&IpxDeviceName);

	//	Remove creation reference count on the IPX device object.
	SpxDerefDevice(SpxDevice);

	//	Wait on the unload event.
	KeWaitForSingleObject(
		&SpxUnloadEvent,
		Executive,
		KernelMode,
		TRUE,
		(PLARGE_INTEGER)NULL);

	// if the device is in a open state - deregister the device object 
	// with TDI before going away!
	// 
//	if (SpxDevice->dev_State == DEVICE_STATE_OPEN) {
	//	if (STATUS_SUCCESS != TdiDeregisterDeviceObject(SpxDevice->dev_TdiRegistrationHandle )) {
		//	DBGPRINT("Cant deregisterdevice object\n");
		//}
	//}
	
	//	Release the block memory stuff
	SpxDeInitMemorySystem(SpxDevice);
	SpxDestroyDevice(SpxDevice);
    return;
}



NTSTATUS
SpxDispatch(
    IN PDEVICE_OBJECT	DeviceObject,
    IN PIRP 			Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the ST device driver.
    It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS 			Status;
    PDEVICE 			Device 	= SpxDevice; // (PDEVICE)DeviceObject;
    PIO_STACK_LOCATION 	IrpSp 	= IoGetCurrentIrpStackLocation(Irp);


    if (Device->dev_State != DEVICE_STATE_OPEN) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }

    // Make sure status information is consistent every time.
    IoMarkIrpPending (Irp);
    Irp->IoStatus.Status = STATUS_PENDING;
    Irp->IoStatus.Information = 0;

    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    switch (IrpSp->MajorFunction) {

	case IRP_MJ_DEVICE_CONTROL:

		Status = SpxDeviceControl (DeviceObject, Irp);
		break;

	default:

        Status = STATUS_INVALID_DEVICE_REQUEST;

        //
        // Complete the Irp here instead of below.
        //
        IrpSp->Control &= ~SL_PENDING_RETURNED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

    } // major function switch

    /* Commented out and re-located to the default case above.

    if (Status != STATUS_PENDING) {
        IrpSp->Control &= ~SL_PENDING_RETURNED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
    }
    */

    // Return the immediate status code to the caller.
    return Status;

} // SpxDispatch

VOID
SpxAssignControlChannelId(
    IN  PDEVICE Device,
    IN  PIRP    Request
    )
/*++

Routine Description:

    This routine is required to ensure that the Device lock (to protect the ControlChannelId in the Device)
    is not taken in a pageable routine (SpxDispatchOpenClose).

    NOTE: SPX returns the ControlChannelId in the Request, but never uses it later when it comes down in a
    close/cleanup. The CCID is a ULONG; in future, if we start using this field (as in IPX which uses these Ids
    to determine lineup Irps to complete), then we may run out of numbers (since we monotonically increase the CCID);
    though there is a low chance of that since we will probably run out of memory before that! Anyhow, if that
    happens, one solution (used in IPX) is to make the CCID into a Large Integer and pack the values into the
    REQUEST_OPEN_TYPE(Irp) too.


Arguments:

    Device - Pointer to the device object for this driver.

    Request - Pointer to the request packet representing the I/O request.

Return Value:

    None.

--*/
{
    CTELockHandle 				LockHandle;

    CTEGetLock (&Device->dev_Lock, &LockHandle);

    REQUEST_OPEN_CONTEXT(Request) = UlongToPtr(Device->dev_CcId);
    ++Device->dev_CcId;
    if (Device->dev_CcId == 0) {
        Device->dev_CcId = 1;
    }

    CTEFreeLock (&Device->dev_Lock, LockHandle);
}

NTSTATUS
SpxDispatchOpenClose(
    IN PDEVICE_OBJECT 	DeviceObject,
    IN PIRP 			Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the ST device driver.
    It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PDEVICE 					Device = SpxDevice; // (PDEVICE)DeviceObject;
    NTSTATUS 					Status = STATUS_UNSUCCESSFUL;   	
    BOOLEAN 					found;
    PREQUEST 					Request;
    UINT 						i;
    PFILE_FULL_EA_INFORMATION 	openType;
	CONNECTION_CONTEXT			connCtx;


#if      !defined(_PNP_POWER)
    if (Device->dev_State != DEVICE_STATE_OPEN) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }
#endif  !_PNP_POWER

    // Allocate a request to track this IRP.
    Request = SpxAllocateRequest (Device, Irp);
    IF_NOT_ALLOCATED(Request) {
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }


    // Make sure status information is consistent every time.
    MARK_REQUEST_PENDING(Request);
    REQUEST_STATUS(Request) = STATUS_PENDING;
    REQUEST_INFORMATION(Request) = 0;

    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    switch (REQUEST_MAJOR_FUNCTION(Request)) {

    // The Create function opens a transport object (either address or
    // connection).  Access checking is performed on the specified
    // address to ensure security of transport-layer addresses.
    case IRP_MJ_CREATE:

#if     defined(_PNP_POWER)
        if (Device->dev_State != DEVICE_STATE_OPEN) {
            Status = STATUS_INVALID_DEVICE_STATE;
            break;
        }
#endif  _PNP_POWER


        openType = OPEN_REQUEST_EA_INFORMATION(Request);

        if (openType != NULL) {


            found = TRUE;
            //DbgPrint("EA:%d, TdiTransportAddress Length : %d \n", openType->EaNameLength, TDI_TRANSPORT_ADDRESS_LENGTH);

            for (i = 0; i < openType->EaNameLength && i < TDI_TRANSPORT_ADDRESS_LENGTH; i++) {
                if (openType->EaName[i] == TdiTransportAddress[i]) {
                    continue;
                } else {
                    found = FALSE;
                    break;
                }
            }

            if (found) {
                Status = SpxAddrOpen (Device, Request);
                break;
            }

            // Connection?
            found = TRUE;

            for (i=0;i<openType->EaNameLength && i < TDI_CONNECTION_CONTEXT_LENGTH;i++) {
                if (openType->EaName[i] == TdiConnectionContext[i]) {
                     continue;
                } else {
                    found = FALSE;
                    break;
                }
            }

            if (found) {
				if (openType->EaValueLength < sizeof(CONNECTION_CONTEXT))
				{
		
					DBGPRINT(CREATE, ERR,
							("Create: Context size %d\n", openType->EaValueLength));
		
					Status = STATUS_EA_LIST_INCONSISTENT;
					break;
				}
		
				connCtx =
				*((CONNECTION_CONTEXT UNALIGNED *)
					&openType->EaName[openType->EaNameLength+1]);
		
				Status = SpxConnOpen(
							Device,
							connCtx,
							Request);
		
                break;
            }

        } else {

            //
            // Takes a lock in a Pageable routine - call another (non-paged) function to do that.
            //
            if (Device->dev_State != DEVICE_STATE_OPEN) {
                DBGPRINT(TDI, ERR, ("DEVICE NOT OPEN - letting thru control channel only\n"))
            }
            
            SpxAssignControlChannelId(Device, Request);

            REQUEST_OPEN_TYPE(Request) = UlongToPtr(SPX_FILE_TYPE_CONTROL);
            Status = STATUS_SUCCESS;
        }

        break;

    case IRP_MJ_CLOSE:

#if     defined(_PNP_POWER)
        if ((Device->dev_State != DEVICE_STATE_OPEN) && ( Device->dev_State != DEVICE_STATE_LOADED )) {
            Status = STATUS_INVALID_DEVICE_STATE;
            break;
        }
#endif  _PNP_POWER

        // The Close function closes a transport endpoint, terminates
        // all outstanding transport activity on the endpoint, and unbinds
        // the endpoint from its transport address, if any.  If this
        // is the last transport endpoint bound to the address, then
        // the address is removed from the provider.
        switch ((ULONG_PTR)REQUEST_OPEN_TYPE(Request)) {
        case TDI_TRANSPORT_ADDRESS_FILE:

            Status = SpxAddrFileClose(Device, Request);
            break;

		case TDI_CONNECTION_FILE:
            Status = SpxConnClose(Device, Request);
			break;

        case SPX_FILE_TYPE_CONTROL:

			Status = STATUS_SUCCESS;
            break;

        default:
            Status = STATUS_INVALID_HANDLE;
        }

        break;

    case IRP_MJ_CLEANUP:

#if     defined(_PNP_POWER)
        if ((Device->dev_State != DEVICE_STATE_OPEN) && ( Device->dev_State != DEVICE_STATE_LOADED )) {
            Status = STATUS_INVALID_DEVICE_STATE;
            break;
        }
#endif  _PNP_POWER

        // Handle the two stage IRP for a file close operation. When the first
        // stage hits, run down all activity on the object of interest. This
        // do everything to it but remove the creation hold. Then, when the
        // CLOSE irp hits, actually close the object.
        switch ((ULONG_PTR)REQUEST_OPEN_TYPE(Request)) {
        case TDI_TRANSPORT_ADDRESS_FILE:

            Status = SpxAddrFileCleanup(Device, Request);
            break;

		case TDI_CONNECTION_FILE:

            Status = SpxConnCleanup(Device, Request);
            break;

        case SPX_FILE_TYPE_CONTROL:

            Status = STATUS_SUCCESS;
            break;

        default:
            Status = STATUS_INVALID_HANDLE;
        }

        break;

    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;

    } // major function switch

    if (Status != STATUS_PENDING) {
        UNMARK_REQUEST_PENDING(Request);
        REQUEST_STATUS(Request) = Status;
        SpxCompleteRequest (Request);
        SpxFreeRequest (Device, Request);
    }

    // Return the immediate status code to the caller.
    return Status;

} // SpxDispatchOpenClose




NTSTATUS
SpxDeviceControl(
    IN PDEVICE_OBJECT 	DeviceObject,
    IN PIRP 			Irp
    )

/*++

Routine Description:

    This routine dispatches TDI request types to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various TDI request handlers so that they are
    not IRP-dependent.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
	NTSTATUS	Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);

	// Convert the user call to the proper internal device call.
	Status = TdiMapUserRequest (DeviceObject, Irp, IrpSp);
	if (Status == STATUS_SUCCESS) {

		// If TdiMapUserRequest returns SUCCESS then the IRP
		// has been converted into an IRP_MJ_INTERNAL_DEVICE_CONTROL
		// IRP, so we dispatch it as usual. The IRP will
		// be completed by this call.
		Status = SpxDispatchInternal (DeviceObject, Irp);

        //
        // Return the proper error code here. If SpxDispatchInternal returns an error,
        // then we used to map it to pending below; this is wrong since the client above
        // us could wait for ever since the IO subsystem does not set the event if an
        // error is returned and the Irp is not marked pending.
        //

		// Status = STATUS_PENDING;
	} else {

    	DBGPRINT(TDI, DBG,
		    ("Unknown Tdi code in Irp: %lx\n", Irp));

        //
        // Complete the Irp....
        //
        IrpSp->Control &= ~SL_PENDING_RETURNED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
    }

    return Status;

} // SpxDeviceControl




NTSTATUS
SpxDispatchInternal (
    IN PDEVICE_OBJECT 	DeviceObject,
    IN PIRP 			Irp
    )

/*++

Routine Description:

    This routine dispatches TDI request types to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various TDI request handlers so that they are
    not IRP-dependent.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PREQUEST 	Request;
	KIRQL	    oldIrql;
    NTSTATUS 	Status 	= STATUS_INVALID_DEVICE_REQUEST;
    PDEVICE 	Device 	= SpxDevice; // (PDEVICE)DeviceObject;
    BOOLEAN CompleteIrpIfCancel = FALSE; 


    //
    // AFD asks SPX about its provider info before SPX is out of driver entry.
    // We need work around this by letting TDI_QUERY_INFORMATION through. [Shreem]
    //
    if (Device->dev_State != DEVICE_STATE_OPEN) 
	{
        
        if ((TDI_QUERY_INFORMATION == (IoGetCurrentIrpStackLocation(Irp))->MinorFunction) && 
            (TDI_QUERY_PROVIDER_INFO == ((PTDI_REQUEST_KERNEL_QUERY_INFORMATION)REQUEST_PARAMETERS(Irp))->QueryType))
        {
            DBGPRINT(TDI, ERR,
                     ("SpxDispatchIoctl: Letting through since it is a QueryProviderInformation\n"));
            
        } 
        else 
        {

            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
            return STATUS_INVALID_DEVICE_STATE;
        }
    }


    // Allocate a request to track this IRP.
    Request = SpxAllocateRequest (Device, Irp);
    IF_NOT_ALLOCATED(Request)
	{
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }


    // Make sure status information is consistent every time.
    MARK_REQUEST_PENDING(Request);
    REQUEST_STATUS(Request) = STATUS_PENDING;
    REQUEST_INFORMATION(Request) = 0;

	//	Cancel irp
	IoAcquireCancelSpinLock(&oldIrql);
    if (!Irp->Cancel)
    {
       IoSetCancelRoutine(Irp, (PDRIVER_CANCEL)SpxTdiCancel);
    } else {
       CompleteIrpIfCancel = TRUE; 
    }
    IoReleaseCancelSpinLock(oldIrql);
	
    if (Irp->Cancel) {
       if (CompleteIrpIfCancel) {
	  // We only want to complete the irp if we didn't register our cancel routine. 
	  // Assume the SpxTdiCancel will complete the irp, we don't want to complete it twice. 
	  Irp->IoStatus.Status = STATUS_CANCELLED;
	  DBGPRINT(TDI, DBG,
		   ("SpxDispatchInternal: Completing IRP with Ipr->Cancel = True\n"));
       
	  IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
       }
       return STATUS_CANCELLED;
    }


    // Branch to the appropriate request handler.  Preliminary checking of
    // the size of the request block is performed here so that it is known
    // in the handlers that the minimum input parameters are readable.  It
    // is *not* determined here whether variable length input fields are
    // passed correctly; this is a check which must be made within each routine.
    switch (REQUEST_MINOR_FUNCTION(Request))
	{
	case TDI_ACCEPT:

		Status = SpxConnAccept(
					Device,
					Request);

		break;

	case TDI_SET_EVENT_HANDLER:

		Status = SpxAddrSetEventHandler(
					Device,
					Request);

		break;

	case TDI_RECEIVE:

		Status = SpxConnRecv(
					Device,
					Request);
		break;


	case TDI_SEND:

		Status = SpxConnSend(
					Device,
					Request);
		break;

	case TDI_ACTION:

		Status = SpxConnAction(
					Device,
					Request);
		break;

	case TDI_ASSOCIATE_ADDRESS:

		Status = SpxConnAssociate(
					Device,
					Request);

		break;

	case TDI_DISASSOCIATE_ADDRESS:

		Status = SpxConnDisAssociate(
					Device,
					Request);

		break;

	case TDI_CONNECT:

		Status = SpxConnConnect(
					Device,
					Request);

		break;

	case TDI_DISCONNECT:

		Status = SpxConnDisconnect(
					Device,
					Request);
		break;

	case TDI_LISTEN:

		Status = SpxConnListen(
					Device,
					Request);
		break;

	case TDI_QUERY_INFORMATION:

		Status = SpxTdiQueryInformation(
					Device,
					Request);

		break;

	case TDI_SET_INFORMATION:

		Status = SpxTdiSetInformation(
					Device,
					Request);

		break;

    // Something we don't know about was submitted.
	default:

        Status = STATUS_INVALID_DEVICE_REQUEST;
		break;
    }

    if (Status != STATUS_PENDING)
	{
        UNMARK_REQUEST_PENDING(Request);
        REQUEST_STATUS(Request) = Status;
    	IoAcquireCancelSpinLock(&oldIrql);
  		IoSetCancelRoutine(Irp, (PDRIVER_CANCEL)NULL);
    	IoReleaseCancelSpinLock(oldIrql);
        SpxCompleteRequest (Request);
        SpxFreeRequest (Device, Request);
    }

    // Return the immediate status code to the caller.
    return Status;

} // SpxDispatchInternal




VOID
SpxTdiCancel(
    IN PDEVICE_OBJECT 	DeviceObject,
    IN PIRP 			Irp
	)
/*++

Routine Description:

	This routine handles cancellation of IO requests

Arguments:


Return Value:
--*/
{
	PREQUEST				Request;
	PSPX_ADDR_FILE			pSpxAddrFile;
	PSPX_ADDR				pSpxAddr;
    PDEVICE 				Device 	= SpxDevice; // (PDEVICE)DeviceObject;
    CTELockHandle           connectIrql;
    CTELockHandle           TempIrql;
    PSPX_CONN_FILE          pSpxConnFile;

    Request = SpxAllocateRequest (Device, Irp);
    IF_NOT_ALLOCATED(Request)
	{
        return;
    }

	DBGPRINT(TDI, ERR,
			("SpxTdiCancel: ------ !!! Cancel irp called %lx.%lx.%lx\n",
				Irp, REQUEST_OPEN_CONTEXT(Request), REQUEST_OPEN_TYPE(Request)));

	switch ((ULONG_PTR)REQUEST_OPEN_TYPE(Request))
	{
    case TDI_CONNECTION_FILE:
        pSpxConnFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(Request);
        CTEGetLock(&pSpxConnFile->scf_Lock, &connectIrql);

        //
        // Swap the irql
        //
        TempIrql = connectIrql;
        connectIrql = Irp->CancelIrql;
        Irp->CancelIrql  = TempIrql;

        IoReleaseCancelSpinLock (Irp->CancelIrql);
        if (!SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_STOPPING))
        {
            if (!SPX_CONN_IDLE(pSpxConnFile))
            {
                //
                // This releases the lock
                //
                spxConnAbortiveDisc(
                    pSpxConnFile,
                    STATUS_LOCAL_DISCONNECT,
                    SPX_CALL_TDILEVEL,
                    connectIrql,
                    FALSE);     // [SA] bug #15249
            }
        }

//		SpxConnStop((PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(Request));
		break;

	case TDI_TRANSPORT_ADDRESS_FILE:

        IoReleaseCancelSpinLock (Irp->CancelIrql);
		pSpxAddrFile = (PSPX_ADDR_FILE)REQUEST_OPEN_CONTEXT(Request);
		pSpxAddr = pSpxAddrFile->saf_Addr;
		SpxAddrFileStop(pSpxAddrFile, pSpxAddr);
		break;

	default:

        IoReleaseCancelSpinLock (Irp->CancelIrql);
		break;

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxerror.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxerror.c

Abstract:

    This module contains code which provides error logging support.

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//      Define module number for event logging entries
#define FILENUM         SPXERROR

LONG            SpxLastRawDataLen               = 0;
NTSTATUS        SpxLastUniqueErrorCode  = STATUS_SUCCESS;
NTSTATUS        SpxLastNtStatusCode             = STATUS_SUCCESS;
ULONG           SpxLastErrorCount               = 0;
LONG            SpxLastErrorTime                = 0;
BYTE            SpxLastRawData[PORT_MAXIMUM_MESSAGE_LENGTH - \
                                                         sizeof(IO_ERROR_LOG_PACKET)]   = {0};

BOOLEAN
SpxFilterErrorLogEntry(
    IN  NTSTATUS                        UniqueErrorCode,
    IN  NTSTATUS                        NtStatusCode,
    IN  PVOID                           RawDataBuf                      OPTIONAL,
    IN  LONG                            RawDataLen
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{

    int                                         insertionStringLength = 0;

        // Filter out events such that the same event recurring close together does not
        // cause errorlog clogging. The scheme is - if the event is same as the last event
        // and the elapsed time is > THRESHOLD and ERROR_CONSEQ_FREQ simulataneous errors
        // have happened, then log it else skip
        if ((UniqueErrorCode == SpxLastUniqueErrorCode) &&
                (NtStatusCode    == SpxLastNtStatusCode))
        {
                SpxLastErrorCount++;
                if ((SpxLastRawDataLen == RawDataLen)                                   &&
                        (RtlEqualMemory(SpxLastRawData, RawDataBuf, RawDataLen)) &&
                        ((SpxLastErrorCount % ERROR_CONSEQ_FREQ) != 0)          &&
                        ((SpxGetCurrentTime() - SpxLastErrorTime) < ERROR_CONSEQ_TIME))
                {
                        return(FALSE);
                }
        }

        SpxLastUniqueErrorCode  = UniqueErrorCode;
        SpxLastNtStatusCode             = NtStatusCode;
        SpxLastErrorCount               = 0;
        SpxLastErrorTime                = SpxGetCurrentTime();
        if (RawDataLen != 0)
        {
            SpxLastRawDataLen = RawDataLen;
                RtlCopyMemory(
                        SpxLastRawData,
                        RawDataBuf,
                        RawDataLen);
        }

        return(TRUE);
}




VOID
SpxWriteResourceErrorLog(
    IN PDEVICE  Device,
    IN ULONG    BytesNeeded,
    IN ULONG    UniqueErrorValue
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry indicating
    an out of resources condition.

Arguments:

    Device - Pointer to the device context.

    BytesNeeded - If applicable, the number of bytes that could not
        be allocated.

    UniqueErrorValue - Used as the UniqueErrorValue in the error log
        packet.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    UCHAR EntrySize;
    PUCHAR StringLoc;
    ULONG TempUniqueError;
    static WCHAR UniqueErrorBuffer[4] = L"000";
    INT i;

        if (!SpxFilterErrorLogEntry(
                        EVENT_TRANSPORT_RESOURCE_POOL,
                        STATUS_INSUFFICIENT_RESOURCES,
                        (PVOID)&BytesNeeded,
                        sizeof(BytesNeeded)))
        {
                return;
        }

    EntrySize = sizeof(IO_ERROR_LOG_PACKET) +
                Device->dev_DeviceNameLen       +
                sizeof(UniqueErrorBuffer);

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                                                                                                (PDEVICE_OBJECT)Device,
                                                                                                EntrySize);

    // Convert the error value into a buffer.
    TempUniqueError = UniqueErrorValue;
    for (i=1; i>=0; i--)
        {
        UniqueErrorBuffer[i] = (WCHAR)((TempUniqueError % 10) + L'0');
        TempUniqueError /= 10;
    }

    if (errorLogEntry != NULL)
        {
        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = sizeof(ULONG);
        errorLogEntry->NumberOfStrings = 2;
        errorLogEntry->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = EVENT_TRANSPORT_RESOURCE_POOL;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->DumpData[0] = BytesNeeded;

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;
        RtlCopyMemory(
                        StringLoc, Device->dev_DeviceName, Device->dev_DeviceNameLen);

        StringLoc += Device->dev_DeviceNameLen;
        RtlCopyMemory(
                        StringLoc, UniqueErrorBuffer, sizeof(UniqueErrorBuffer));

        IoWriteErrorLogEntry(errorLogEntry);
    }
}




VOID
SpxWriteGeneralErrorLog(
    IN PDEVICE  Device,
    IN NTSTATUS ErrorCode,
    IN ULONG    UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PWSTR    SecondString,
    IN  PVOID   RawDataBuf              OPTIONAL,
    IN  LONG    RawDataLen
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry indicating
    a general problem as indicated by the parameters. It handles
    event codes REGISTER_FAILED, BINDING_FAILED, ADAPTER_NOT_FOUND,
    TRANSFER_DATA, TOO_MANY_LINKS, and BAD_PROTOCOL. All these
    events have messages with one or two strings in them.

Arguments:

    Device - Pointer to the device context, or this may be
        a driver object instead.

    ErrorCode - The transport event code.

    UniqueErrorValue - Used as the UniqueErrorValue in the error log
        packet.

    FinalStatus - Used as the FinalStatus in the error log packet.

    SecondString - If not NULL, the string to use as the %3
        value in the error log packet.

    RawDataBuf  - The number of ULONGs of dump data.

    RawDataLen  - Dump data for the packet.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    UCHAR EntrySize;
    ULONG SecondStringSize;
    PUCHAR StringLoc;
    static WCHAR DriverName[4] = L"Spx";

        if (!SpxFilterErrorLogEntry(
                        ErrorCode,
                        FinalStatus,
                        RawDataBuf,
                        RawDataLen))
        {
                return;
        }

#ifdef DBG
		if ( sizeof(IO_ERROR_LOG_PACKET) + RawDataLen > 255) {
			DbgPrint("Size greater than maximum entry size 255.\n"); 
		}
#endif

    EntrySize = (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + RawDataLen);
    if (Device->dev_Type == SPX_DEVICE_SIGNATURE)
        {
        EntrySize += (UCHAR)Device->dev_DeviceNameLen;
    }
        else
        {
        EntrySize += sizeof(DriverName);
    }

    if (SecondString)
        {
        SecondStringSize = (wcslen(SecondString)*sizeof(WCHAR)) + sizeof(UNICODE_NULL);
        EntrySize += (UCHAR)SecondStringSize;
    }

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                                                                                                        (PDEVICE_OBJECT)Device,
                                                                                                        EntrySize);

    if (errorLogEntry != NULL)
        {
        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = (USHORT)RawDataLen;
        errorLogEntry->NumberOfStrings = (SecondString == NULL) ? 1 : 2;
        errorLogEntry->StringOffset = (USHORT)
            (sizeof(IO_ERROR_LOG_PACKET) + RawDataLen);
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;

        if (RawDataLen != 0)
                {
            RtlCopyMemory(errorLogEntry->DumpData, RawDataBuf, RawDataLen);
                }

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;
        if (Device->dev_Type == SPX_DEVICE_SIGNATURE)
                {
            RtlCopyMemory(
                                StringLoc, Device->dev_DeviceName, Device->dev_DeviceNameLen);

            StringLoc += Device->dev_DeviceNameLen;
        }
                else
                {
            RtlCopyMemory (StringLoc, DriverName, sizeof(DriverName));
            StringLoc += sizeof(DriverName);
        }

        if (SecondString)
                {
            RtlCopyMemory (StringLoc, SecondString, SecondStringSize);
        }

        IoWriteErrorLogEntry(errorLogEntry);
    }

        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxerror.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	spxerror.h

Abstract:

	This module contains some error definitions for spx.

Author:

	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:

Notes:	Tab stop: 4
--*/

//	Define the modules names for SPX - use the high bits.
#define		SPXDRVR			0x00010000
#define		SPXREG			0x00020000
#define		SPXDEV			0x00030000
#define		SPXBIND			0x00040000
#define		SPXRECV			0x00050000
#define		SPXSEND			0x00060000
#define		SPXTIMER		0x00070000
#define		SPXERROR		0x00080000
#define		SPXPKT			0x00090000
#define		SPXUTILS		0x000a0000
#define		SPXCPKT			0x000b0000
#define		SPXCONN			0x000c0000
#define		SPXADDR			0x000d0000
#define		SPXCUTIL 		0x000e0000
#define		SPXINIT			0x000f0000
#define		SPXMEM			0x00100000
#define		SPXQUERY		0x00200000

// DEBUGGING SUPPORT:
// Debugging messages are provided per-subsystem defined here, and within
// the subsystems, there are 4 levels of messages.
//
// The four levels of debug messages are:
//
// INFO:		Informational messages, eg., entry exit in routines
// DBG:			Used when debugging some msgs are turned from info to dbg
// WARN:		Something went wrong, but its not an error, eg., packet was not ours
// ERR:		    Error situations, but we can still run if a retry happens
// FATAL:		In this situation, the driver is not operational

#define	DBG_LEVEL_INFO			0x4000
#define	DBG_LEVEL_DBG			0x5000
#define	DBG_LEVEL_DBG1			0x5001
#define	DBG_LEVEL_DBG2			0x5002
#define	DBG_LEVEL_DBG3			0x5003
#define	DBG_LEVEL_WARN			0x6000
#define	DBG_LEVEL_ERR			0x7000
#define	DBG_LEVEL_FATAL			0x8000

// SUBSYSTEMS
#define DBG_COMP_DEVICE         0x00000001
#define DBG_COMP_CREATE         0x00000002
#define DBG_COMP_ADDRESS        0x00000004
#define DBG_COMP_SEND           0x00000008
#define DBG_COMP_NDIS           0x00000010
#define DBG_COMP_RECEIVE        0x00000020
#define DBG_COMP_CONFIG         0x00000040
#define DBG_COMP_PACKET         0x00000080
#define DBG_COMP_RESOURCES      0x00000100
#define DBG_COMP_BIND           0x00000200
#define DBG_COMP_UNLOAD			0x00000400
#define	DBG_COMP_DUMP			0x00000800
#define DBG_COMP_REFCOUNTS		0x00001000
#define DBG_COMP_SYSTEM			0x00002000
#define DBG_COMP_CRITSEC		0x00004000
#define DBG_COMP_UTILS			0x00008000
#define DBG_COMP_TDI			0x00010000
#define DBG_COMP_CONNECT		0x00020000
#define DBG_COMP_DISC			0x00040000
#define	DBG_COMP_ACTION			0x00080000
#define	DBG_COMP_STATE			0x00100000

#define DBG_COMP_MOST           (DBG_COMP_DEVICE	|	\
								DBG_COMP_CREATE     |	\
                                DBG_COMP_ADDRESS    |	\
                                DBG_COMP_SEND       |	\
                                DBG_COMP_NDIS       |	\
                                DBG_COMP_RECEIVE    |	\
                                DBG_COMP_CONFIG     |	\
                                DBG_COMP_PACKET     |	\
                                DBG_COMP_RESOURCES  |	\
                                DBG_COMP_BIND       |	\
                                DBG_COMP_UNLOAD     |	\
                                DBG_COMP_DUMP       |	\
                                DBG_COMP_REFCOUNTS  |	\
                                DBG_COMP_SYSTEM     |	\
                                DBG_COMP_CRITSEC    |	\
                                DBG_COMP_UTILS      |	\
                                DBG_COMP_TDI		|	\
                                DBG_COMP_CONNECT	|	\
								DBG_COMP_DISC		|	\
								DBG_COMP_ACTION		|	\
								DBG_COMP_STATE)


// More debugging support. These values define the dumping components.
// There are a max of 32 such components that can be defined. Each of
// these are associated with a dump routine. It one is specified and
// enabled, periodically it is called. It is upto that component to
// decide what it wants to do

#define	DBG_DUMP_DEF_INTERVAL		30			// In Seconds

//	This defines the number of times an error has to happen consecutively before
//	it gets logged again.
#define		ERROR_CONSEQ_FREQ	200
#define		ERROR_CONSEQ_TIME	(60*30)	// 30 minutes

#ifdef	DBG
typedef VOID	(*DUMP_ROUTINE)(VOID);

extern
BOOLEAN
SpxDumpComponents(
	IN	PVOID	Context);

#endif

//
//	PROTOTYPES
//

BOOLEAN
SpxFilterErrorLogEntry(
    IN	NTSTATUS 			UniqueErrorCode,
    IN	NTSTATUS 			NtStatusCode,
    IN	PVOID    			RawDataBuf			OPTIONAL,
    IN	LONG     			RawDataLen);
VOID
SpxWriteResourceErrorLog(
    IN PDEVICE 	Device,
    IN ULONG 	BytesNeeded,
    IN ULONG 	UniqueErrorValue);

VOID
SpxWriteGeneralErrorLog(
    IN PDEVICE 	Device,
    IN NTSTATUS ErrorCode,
    IN ULONG 	UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PWSTR 	SecondString,
    IN	PVOID   RawDataBuf		OPTIONAL,
    IN	LONG    RawDataLen);


//
//	MACROS
//

#if DBG
#define LOG_ERROR(Error, NtStatus, SecondString, RawData, RawDataLen)		\
	{																		\
		SpxWriteGeneralErrorLog(											\
			SpxDevice,														\
			Error,															\
			FILENUM | __LINE__,		        								\
			NtStatus,														\
			SecondString,													\
			RawData,														\
			RawDataLen);													\
	}

#define RES_LOG_ERROR(BytesNeeded)											\
	{																		\
		SpxWriteResourceErrorLog(											\
			SpxDevice,														\
			BytesNeeded,													\
			FILENUM | __LINE__);	        								\
	}

#else

#define LOG_ERROR(Error, NtStatus, SecondString, RawData, RawDataLen)		\
	{																		\
		SpxWriteGeneralErrorLog(											\
			SpxDevice,														\
			Error,															\
			FILENUM | __LINE__,		        								\
			NtStatus,														\
			SecondString,													\
			RawData,														\
			RawDataLen);													\
	}

#define RES_LOG_ERROR(BytesNeeded)											\
	{																		\
		SpxWriteResourceErrorLog(											\
			SpxDevice,														\
			BytesNeeded,													\
			FILENUM | __LINE__);	        								\
	}

#endif


#if DBG

#define DBGPRINT(Component, Level, Fmt)										\
		{																	\
			if (((DBG_LEVEL_ ## Level) >= SpxDebugLevel) &&					\
				(SpxDebugSystems & (DBG_COMP_ ## Component)))				\
			{																\
				DbgPrint("SPX: ");										    \
				DbgPrint Fmt;												\
			}																\
		}
			
#define DBGBRK(Level)														\
		{																	\
			if ((DBG_LEVEL_ ## Level) >= SpxDebugLevel) 					\
				DbgBreakPoint();											\
		}                                                       			
			
#define	TMPLOGERR()															\
		{																	\
			DBGPRINT(MOST, ERR,												\
					("TempErrLog: %s, Line %ld\n", __FILE__, __LINE__));	\
		}

#else
#define DBGPRINT(Component, Level, Fmt)
#define DBGBRK(Level)
#define	TMPLOGERR()
#endif

extern
VOID
SpxWriteErrorLogEntry(
	IN	NTSTATUS 					UniqueErrorCode,
	IN	ULONG						UniqueErrorValue,
	IN	NTSTATUS 					NtStatusCode,
	IN	PVOID						RawDataBuf OPTIONAL,
	IN	LONG	 					RawDataLen);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxmem.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxmem.h

Abstract:

    This module contains memory management routines.

Author:

    Nikhil Kamkolkar (nikhilk) 17-November-1993

Environment:

    Kernel mode

Revision History:

--*/


#define	QWORDSIZEBLOCK(Size)	(((Size)+sizeof(LARGE_INTEGER)-1) & ~(sizeof(LARGE_INTEGER)-1))
#define	SPX_MEMORY_SIGNATURE	*(PULONG)"SPXM"
#define	ZEROED_MEMORY_TAG		0xF0000000
#define	SPX_TAG					*((PULONG)"SPX ")

//
// Definitions for the block management package
//
typedef	UCHAR	BLKID;

// Add a BLKID_xxx and an entry to atalkBlkSize for every block client
#define	BLKID_TIMERLIST				(BLKID)0
#define	BLKID_NDISSEND				(BLKID)1
#define	BLKID_NDISRECV				(BLKID)2
#define	NUM_BLKIDS					(BLKID)3

typedef	struct _BLK_CHUNK
{
	struct _BLK_CHUNK *	bc_Next;		// Pointer to next in the link
	SHORT				bc_NumFrees;	// Number of free blocks in the chunk
	UCHAR				bc_Age;			// Number of invocations since the chunk free
	BLKID				bc_BlkId;		// Id of the block
	struct _BLK_HDR *	bc_FreeHead;	// Head of the list of free blocks

#ifndef SPX_OWN_PACKETS
	PVOID				bc_ChunkCtx;	// Used to store pool header if not own
										// packets
#else
    PVOID               bc_Padding;     // Keep the header 16 bytes
#endif

	// This is followed by an array of N blks of size M such that the block header
	// is exactly spxChunkSize[i]

} BLK_CHUNK, *PBLK_CHUNK;

typedef	struct _BLK_HDR
{
	union
	{
		struct _BLK_HDR	*	bh_Next;	// Valid when it is free
		struct _BLK_CHUNK *	bh_pChunk;	// The parent chunk to which this blocks belong
										// valid when it is allocated
	};
    PVOID               bh_Padding;     // Make the header 8 bytes
} BLK_HDR, *PBLK_HDR;

#define	BC_OVERHEAD				(8+8)		// LARGE_INTEGER for SpxAllocMemory() header and
										// POOL_HEADER for ExAllocatePool() header

#define	BLOCK_POOL_TIMER			1000	//	Check interval (1 sec)
#define	MAX_BLOCK_POOL_AGE			3		// # of timer invocations before free

ULONG
spxBPAgePool(
	IN PVOID 	Context,
	IN BOOLEAN	TimerShuttingDown);


#ifdef	TRACK_MEMORY_USAGE

#define	SpxAllocateMemory(Size)	SpxAllocMem((Size), FILENUM | __LINE__)

extern
PVOID
SpxAllocMem(
    IN	ULONG   Size,
	IN	ULONG	FileLine
);

extern
VOID
SpxTrackMemoryUsage(
	IN	PVOID	pMem,
	IN	BOOLEAN	Alloc,
	IN	ULONG	FileLine
);

#else

#define	SpxAllocateMemory(Size)	SpxAllocMem(Size)
#define	SpxTrackMemoryUsage(pMem, Alloc, FileLine)

extern
PVOID
SpxAllocMem(
    IN	ULONG   Size
);

#endif	// TRACK_MEMORY_USAGE

VOID
SpxFreeMemory(
	IN	PVOID	pBuf);

#define	SpxAllocateZeroedMemory(Size)	SpxAllocateMemory((Size) | ZEROED_MEMORY_TAG)


extern
NTSTATUS
SpxInitMemorySystem(
	IN	PDEVICE		pSpxDevice);

extern
VOID
SpxDeInitMemorySystem(
	IN	PDEVICE		pSpxDevice);

PVOID
SpxBPAllocBlock(
	IN	BLKID		BlockId);

VOID
SpxBPFreeBlock(
	IN	PVOID		pBlock,
	IN	BLKID		BlockId);

PNDIS_PACKET
GrowSPXPacketList(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxmem.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxmem.c

Abstract:

    This module contains code which implements the memory allocation wrappers.

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993
        Jameel Hyder     (jameelh) Initial Version

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, SpxInitMemorySystem)
#pragma alloc_text( PAGE, SpxDeInitMemorySystem)
#endif

#if !defined SPX_OWN_PACKETS

typedef struct	NdisResEntry {
	struct NdisResEntry	*nre_next;
	NDIS_HANDLE			nre_handle;
	uchar				*nre_buffer;
} NdisResEntry;

NdisResEntry	*SendPacketPoolList = NULL;
SLIST_HEADER    SendPacketList;
NdisResEntry	*RecvPacketPoolList = NULL;
SLIST_HEADER    RecvPacketList;

DEFINE_LOCK_STRUCTURE(SendHeaderLock);
DEFINE_LOCK_STRUCTURE(RecvHeaderLock);

uint  CurrentSendPacketCount = 0;
uint  CurrentRecvPacketCount = 0;
uint  MaxPacketCount = 0x0ffffff;

#define	PACKET_GROW_COUNT		16

#endif // SPX_OWN_PACKETS

//      Define module number for event logging entries
#define FILENUM         SPXMEM

//      Globals for this module
//      Some block sizes (like NDISSEND/NDISRECV are filled in after binding with IPX)
USHORT  spxBlkSize[NUM_BLKIDS] =        // Size of each block
                {
                        sizeof(BLK_HDR)+sizeof(TIMERLIST),                      // BLKID_TIMERLIST
                        0,                                                                                      // BLKID_NDISSEND
                        0                                                                                       // BLKID_NDISRECV
                };

USHORT  spxChunkSize[NUM_BLKIDS] =      // Size of each Chunk
                {
                         512-BC_OVERHEAD,                                                       // BLKID_TIMERLIST
                         512-BC_OVERHEAD,                                                       // BLKID_NDISSEND
                         512-BC_OVERHEAD                                                        // BLKID_NDISRECV
                };


//      Filled in after binding with IPX
//      Reference for below.
//      ( 512-BC_OVERHEAD-sizeof(BLK_CHUNK))/
//              (sizeof(BLK_HDR)+sizeof(TIMERLIST)),    // BLKID_TIMERLIST
USHORT  spxNumBlks[NUM_BLKIDS] =        // Number of blocks per chunk
                {
                        ( 512-BC_OVERHEAD-sizeof(BLK_CHUNK))/
                                (sizeof(BLK_HDR)+sizeof(TIMERLIST)),    // BLKID_TIMERLIST
                        0,                                                                                      // BLKID_NDISSEND
                        0                                                                                       // BLKID_NDISRECV
                };

CTELock                 spxBPLock[NUM_BLKIDS] = { 0 };
PBLK_CHUNK              spxBPHead[NUM_BLKIDS] = { 0 };




NTSTATUS
SpxInitMemorySystem(
        IN      PDEVICE pSpxDevice
        )
/*++

Routine Description:

        !!! MUST BE CALLED AFTER BINDING TO IPX!!!

Arguments:


Return Value:


--*/
{
        LONG            i;
        NDIS_STATUS     ndisStatus;

        //      Try to allocate the ndis buffer pool.
        NdisAllocateBufferPool(
                &ndisStatus,
                &pSpxDevice->dev_NdisBufferPoolHandle,
                20);

        if (ndisStatus != NDIS_STATUS_SUCCESS)
                return(STATUS_INSUFFICIENT_RESOURCES);

        for (i = 0; i < NUM_BLKIDS; i++)
                CTEInitLock (&spxBPLock[i]);

        //      Set the sizes in the block id info arrays.
        for (i = 0; i < NUM_BLKIDS; i++)
        {
                switch (i)
                {
                case BLKID_NDISSEND:

#ifdef SPX_OWN_PACKETS
                        spxBlkSize[i] = sizeof(BLK_HDR)                 +
                                                        sizeof(SPX_SEND_RESD)   +
                                                        NDIS_PACKET_SIZE                +
                                                        IpxMacHdrNeeded                 +
                                                        MIN_IPXSPX2_HDRSIZE;
#else
                        spxBlkSize[i] = sizeof(PNDIS_PACKET);
#endif

            //
            // Round the block size up to the next 8-byte boundary.
            //
            spxBlkSize[i] = QWORDSIZEBLOCK(spxBlkSize[i]);

                        //      Set number blocks
            spxNumBlks[i] = ( 512-BC_OVERHEAD-sizeof(BLK_CHUNK))/spxBlkSize[i];
                        break;

                case BLKID_NDISRECV:

#ifdef SPX_OWN_PACKETS
                        spxBlkSize[i] = sizeof(BLK_HDR)                 +
                                                        sizeof(SPX_RECV_RESD)   +
                                                        NDIS_PACKET_SIZE;
#else
                        spxBlkSize[i] = sizeof(PNDIS_PACKET);
#endif

            //
            // Round the block size up to the next 8-byte boundary.
            //
            spxBlkSize[i] = QWORDSIZEBLOCK(spxBlkSize[i]);

                        //      Set number blocks
            spxNumBlks[i] = ( 512-BC_OVERHEAD-sizeof(BLK_CHUNK))/spxBlkSize[i];
                        break;

                default:

                        break;
                }

        }

        SpxTimerScheduleEvent((TIMER_ROUTINE)spxBPAgePool,
                                                        BLOCK_POOL_TIMER,
                                                        NULL);

	return STATUS_SUCCESS; 
}




VOID
SpxDeInitMemorySystem(
        IN      PDEVICE         pSpxDevice
        )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
        LONG            i, j, NumBlksPerChunk;
        PBLK_CHUNK      pChunk, pFree;

        for (i = 0; i < NUM_BLKIDS; i++)
        {
                NumBlksPerChunk = spxNumBlks[i];
                for (pChunk = spxBPHead[i];
                         pChunk != NULL; )
                {
                        DBGPRINT(RESOURCES, ERR,
                                        ("SpxInitMemorySystem: Freeing %lx\n", pChunk));

                        CTEAssert (pChunk->bc_NumFrees == NumBlksPerChunk);

                        if ((pChunk->bc_BlkId == BLKID_NDISSEND) ||
                                (pChunk->bc_BlkId == BLKID_NDISRECV))
                        {
                                PBLK_HDR        pBlkHdr;

                                // We need to free the Ndis stuff for these guys
                                for (j = 0, pBlkHdr = pChunk->bc_FreeHead;
                                         j < NumBlksPerChunk;
                                         j++, pBlkHdr = pBlkHdr->bh_Next)
                                {
                                        PNDIS_PACKET    pNdisPkt;
                                        PNDIS_BUFFER    pNdisBuffer;

#ifdef SPX_OWN_PACKETS
                                        // Only need to free the ndis buffer.
                                        pNdisPkt        = (PNDIS_PACKET)((PBYTE)pBlkHdr + sizeof(BLK_HDR));

                                        if (pChunk->bc_BlkId == BLKID_NDISSEND)
                                        {
                                                NdisUnchainBufferAtFront(pNdisPkt, &pNdisBuffer);
                                                if (pNdisBuffer == NULL)
                                                {
                                                        //      Something is terribly awry.
                                                        KeBugCheck(0);
                                                }

                                                NdisFreeBuffer(pNdisBuffer);

                                                //
                                                // Free the second MDL also
                                                //
                                                NdisUnchainBufferAtFront(pNdisPkt, &pNdisBuffer);
                                                if (pNdisBuffer == NULL)
                                                {
                                                        //      Something is terribly awry.
                                                        KeBugCheck(0);
                                                }

                                                NdisFreeBuffer(pNdisBuffer);
                                        }
#else
                    /*                    //      Need to free both the packet and the buffer.
                                        pNdisPkt       = (PNDIS_PACKET *)((PBYTE)pBlkHdr + sizeof(BLK_HDR));

                                        if (pChunk->bc_BlkId == BLKID_NDISSEND)
                                        {

                                                NdisUnchainBufferAtFront(*pNdisPkt, &pNdisBuffer);
                                                if (pNdisBuffer == NULL)
                                                {
                                                        //      Something is terribly awry.
                                                        KeBugCheck(0);
                                                }

                                                NdisFreeBuffer(pNdisBuffer);
                                        }
                                        NdisFreePacket(*pNdisPkt);
                                        */
#endif
                                }
                        }
                        pFree = pChunk;
                        pChunk = pChunk->bc_Next;

#ifndef SPX_OWN_PACKETS
/*
                        //      Free the ndis packet pool in chunk
                        NdisFreePacketPool((NDIS_HANDLE)pFree->bc_ChunkCtx); */
#endif
                        SpxFreeMemory(pFree);
                }
        }

        //      Free up the ndis buffer pool
        NdisFreeBufferPool(
                pSpxDevice->dev_NdisBufferPoolHandle);

        return;
}




PVOID
SpxAllocMem(
#ifdef  TRACK_MEMORY_USAGE
        IN      ULONG   Size,
        IN      ULONG   FileLine
#else
        IN      ULONG   Size
#endif  // TRACK_MEMORY_USAGE
        )
/*++

Routine Description:

        Allocate a block of non-paged memory. This is just a wrapper over ExAllocPool.
        Allocation failures are error-logged. We always allocate a ULONG more than
        the specified size to accomodate the size. This is used by SpxFreeMemory
        to update the statistics.

Arguments:


Return Value:


--*/
{
        PBYTE   pBuf;
        BOOLEAN zeroed;

        //      round up the size so that we can put a signature at the end
        //      that is on a LARGE_INTEGER boundary
        zeroed = ((Size & ZEROED_MEMORY_TAG) == ZEROED_MEMORY_TAG);

        Size = QWORDSIZEBLOCK(Size & ~ZEROED_MEMORY_TAG);

        // Do the actual memory allocation. Allocate eight extra bytes so
        // that we can store the size of the allocation for the free routine
    // and still keep the buffer quadword aligned.

        if ((pBuf = ExAllocatePoolWithTag(NonPagedPool, Size + sizeof(LARGE_INTEGER)
#if DBG
                                                                                                        + sizeof(ULONG)
#endif
                ,SPX_TAG)) == NULL)
        {
                DBGPRINT(RESOURCES, FATAL,
                                ("SpxAllocMemory: failed - size %lx\n", Size));

                TMPLOGERR();
                return NULL;
        }

        // Save the size of this block in the four extra bytes we allocated.
        *((PULONG)pBuf) = (Size + sizeof(LARGE_INTEGER));

        // Return a pointer to the memory after the size longword.
        pBuf += sizeof(LARGE_INTEGER);

#if DBG
        *((PULONG)(pBuf+Size)) = SPX_MEMORY_SIGNATURE;
        DBGPRINT(RESOURCES, INFO,
                        ("SpxAllocMemory: %p Allocated %lx bytes @%p\n",
                        _ReturnAddress(), Size, pBuf));
#endif

        SpxTrackMemoryUsage((PVOID)(pBuf - sizeof(LARGE_INTEGER)), TRUE, FileLine);

        if (zeroed)
                RtlZeroMemory(pBuf, Size);

        return (pBuf);
}




VOID
SpxFreeMemory(
        IN      PVOID   pBuf
        )
/*++

Routine Description:

        Free the block of memory allocated via SpxAllocMemory. This is
        a wrapper around ExFreePool.

Arguments:


Return Value:


--*/
{
        PULONG  pRealBuffer;

        // Get a pointer to the block allocated by ExAllocatePool --
    // we allocate a LARGE_INTEGER at the front.
        pRealBuffer = ((PULONG)pBuf - 2);

        SpxTrackMemoryUsage(pRealBuffer, FALSE, 0);

#if     DBG
        // Check the signature at the end
        if (*(PULONG)((PCHAR)pRealBuffer + *(PULONG)pRealBuffer)
                                                                                        != SPX_MEMORY_SIGNATURE)
        {
                DBGPRINT(RESOURCES, FATAL,
                                ("SpxFreeMemory: Memory overrun on block %lx\n", pRealBuffer));

                DBGBRK(FATAL);
        }

        *(PULONG)((PCHAR)pRealBuffer + *(PULONG)pRealBuffer) = 0;
#endif

#if     DBG
        *pRealBuffer = 0;
#endif

        // Free the pool and return.
        ExFreePool(pRealBuffer);
}




#ifdef  TRACK_MEMORY_USAGE

#define MAX_PTR_COUNT           4*1024
#define MAX_MEM_USERS           512
CTELock                         spxMemTrackLock = {0};
CTELockHandle           lockHandle              = {0};
struct
{
        PVOID   mem_Ptr;
        ULONG   mem_FileLine;
} spxMemPtrs[MAX_PTR_COUNT]     = {0};

struct
{
        ULONG   mem_FL;
        ULONG   mem_Count;
} spxMemUsage[MAX_MEM_USERS]    = {0};

VOID
SpxTrackMemoryUsage(
        IN      PVOID   pMem,
        IN      BOOLEAN Alloc,
        IN      ULONG   FileLine
        )
/*++

Routine Description:

        Keep track of memory usage by storing and clearing away pointers as and
        when they are allocated or freed. This helps in keeping track of memory
        leaks.

Arguments:


Return Value:


--*/
{
        static int              i = 0;
        int                             j, k;

    CTEGetLock (&spxMemTrackLock, &lockHandle);

        if (Alloc)
        {
                for (j = 0; j < MAX_PTR_COUNT; i++, j++)
                {
                        i = i & (MAX_PTR_COUNT-1);
                        if (spxMemPtrs[i].mem_Ptr == NULL)
                        {
                                spxMemPtrs[i].mem_Ptr = pMem;
                                spxMemPtrs[i++].mem_FileLine = FileLine;
                                break;
                        }
                }

                for (k = 0; k < MAX_MEM_USERS; k++)
                {
                        if (spxMemUsage[k].mem_FL == FileLine)
                        {
                                spxMemUsage[k].mem_Count ++;
                                break;
                        }
                }
                if (k == MAX_MEM_USERS)
                {
                        for (k = 0; k < MAX_MEM_USERS; k++)
                        {
                                if (spxMemUsage[k].mem_FL == 0)
                                {
                                        spxMemUsage[k].mem_FL = FileLine;
                                        spxMemUsage[k].mem_Count = 1;
                                        break;
                                }
                        }
                }
                if (k == MAX_MEM_USERS)
                {
                        DBGPRINT(RESOURCES, ERR,
                                ("SpxTrackMemoryUsage: Out of space on spxMemUsage !!!\n"));

                        DBGBRK(FATAL);
                }
        }
        else
        {
                for (j = 0, k = i; j < MAX_PTR_COUNT; j++, k--)
                {
                        k = k & (MAX_PTR_COUNT-1);
                        if (spxMemPtrs[k].mem_Ptr == pMem)
                        {
                                spxMemPtrs[k].mem_Ptr = 0;
                                spxMemPtrs[k].mem_FileLine = 0;
                                break;
                        }
                }
        }

    CTEFreeLock (&spxMemTrackLock, lockHandle);

        if (j == MAX_PTR_COUNT)
        {
                DBGPRINT(RESOURCES, ERR,
                        ("SpxTrackMemoryUsage: %s\n", Alloc ? "Table Full" : "Can't find"));

                DBGBRK(FATAL);
        }
}

#endif  // TRACK_MEMORY_USAGE


PVOID
SpxBPAllocBlock(
        IN      BLKID   BlockId
        )
/*++

Routine Description:

        Alloc a block of memory from the block pool package. This is written to speed up
        operations where a lot of small fixed size allocations/frees happen. Going to
        ExAllocPool() in these cases is expensive.

Arguments:


Return Value:


--*/
{
        PBLK_HDR                        pBlk = NULL;
        PBLK_CHUNK                      pChunk, *ppChunkHead;
        USHORT                          BlkSize;
        CTELockHandle           lockHandle;
        PSPX_SEND_RESD          pSendResd;
        PSPX_RECV_RESD          pRecvResd;
        PNDIS_PACKET            pNdisPkt;
        PNDIS_BUFFER            pNdisBuffer;
        PNDIS_BUFFER            pNdisIpxSpxBuffer;


        CTEAssert (BlockId < NUM_BLKIDS);

        if (BlockId < NUM_BLKIDS)
        {
                BlkSize = spxBlkSize[BlockId];
                ppChunkHead = &spxBPHead[BlockId];

                CTEGetLock(&spxBPLock[BlockId], &lockHandle);

                for (pChunk = *ppChunkHead;
                         pChunk != NULL;
                         pChunk = pChunk->bc_Next)
                {
                        CTEAssert(pChunk->bc_BlkId == BlockId);
                        if (pChunk->bc_NumFrees > 0)
                        {
                                DBGPRINT(SYSTEM, INFO,
                                                ("SpxBPAllocBlock: Found space in Chunk %lx\n", pChunk));
#ifdef  PROFILING
                                InterlockedIncrement( &SpxStatistics.stat_NumBPHits);
#endif
                                break;
                        }
                }

                if (pChunk == NULL)
                {
                        DBGPRINT(SYSTEM, INFO,
                                        ("SpxBPAllocBlock: Allocating a new chunk for Id %d\n", BlockId));

#ifdef  PROFILING
                        InterlockedIncrement( &SpxStatistics.stat_NumBPMisses);
#endif
                        pChunk = SpxAllocateMemory(spxChunkSize[BlockId]);
                        if (pChunk != NULL)
                        {
                                LONG            i, j;
                                PBLK_HDR        pBlkHdr;
                                USHORT          NumBlksPerChunk;

                                NumBlksPerChunk = spxNumBlks[BlockId];
                                pChunk->bc_NumFrees = NumBlksPerChunk;
                pChunk->bc_BlkId = BlockId;
                                pChunk->bc_FreeHead = (PBLK_HDR)((PBYTE)pChunk + sizeof(BLK_CHUNK));

                                DBGPRINT(SYSTEM, INFO,
                                                ("SpxBPAllocBlock: Initializing chunk %lx\n", pChunk));

                                // Initialize the blocks in the chunk
                                for (i = 0, pBlkHdr = pChunk->bc_FreeHead;
                                         i < NumBlksPerChunk;
                                         i++, pBlkHdr = pBlkHdr->bh_Next)
                                {
                                        NDIS_STATUS     ndisStatus;

                                        pBlkHdr->bh_Next = (PBLK_HDR)((PBYTE)pBlkHdr + BlkSize);
                                        if (BlockId == BLKID_NDISSEND)
                                        {
                                                PBYTE                   pHdrMem;

#ifdef SPX_OWN_PACKETS
                                                // Point to the ndis packet,initialize it.
                                                pNdisPkt        = (PNDIS_PACKET)((PBYTE)pBlkHdr + sizeof(BLK_HDR));
                                                NdisReinitializePacket(pNdisPkt);

                                                // Allocate a ndis buffer descriptor describing hdr memory
                                                // and queue it in.
                                                pHdrMem         =       (PBYTE)pNdisPkt         +
                                                                                NDIS_PACKET_SIZE        +
                                                                                sizeof(SPX_SEND_RESD);

                                                NdisAllocateBuffer(
                                                        &ndisStatus,
                                                        &pNdisBuffer,
                                                        SpxDevice->dev_NdisBufferPoolHandle,
                                                        pHdrMem,
                                                        IpxMacHdrNeeded);

                                                if (ndisStatus != NDIS_STATUS_SUCCESS)
                                                {
                                                        break;
                                                }

                                                //  Link the buffer descriptor into the packet descriptor
                                                NdisChainBufferAtBack(
                                                        pNdisPkt,
                                                        pNdisBuffer);


                                                NdisAllocateBuffer(
                                                        &ndisStatus,
                                                        &pNdisIpxSpxBuffer,
                                                        SpxDevice->dev_NdisBufferPoolHandle,
                                                        pHdrMem + IpxMacHdrNeeded,
                                                        MIN_IPXSPX2_HDRSIZE);

                                                if (ndisStatus != NDIS_STATUS_SUCCESS)
                                                {
                                                        break;
                                                }

                                                //  Link the buffer descriptor into the packet descriptor
                                                NdisChainBufferAtBack(
                                                        pNdisPkt,
                                                        pNdisIpxSpxBuffer);



                                                pSendResd = (PSPX_SEND_RESD)pNdisPkt->ProtocolReserved;

//#else
                                                // Allocate a ndis packet pool for this chunk
//                                                NdisAllocatePacketPool();
//                                                etc.



                                                //      Initialize elements of the protocol reserved structure.
                                                pSendResd->sr_Id        = IDENTIFIER_SPX;
                                                pSendResd->sr_Reserved1 = NULL;
                                                pSendResd->sr_Reserved2 = NULL;
                                                pSendResd->sr_State     = SPX_SENDPKT_IDLE;
#endif
                                        }
                                        else if (BlockId == BLKID_NDISRECV)
                                        {
#ifdef SPX_OWN_PACKETS
                                                // Point to the ndis packet,initialize it.
                                                pNdisPkt        = (PNDIS_PACKET)((PBYTE)pBlkHdr + sizeof(BLK_HDR));
                                                NdisReinitializePacket(pNdisPkt);

                                                pRecvResd = (PSPX_RECV_RESD)pNdisPkt->ProtocolReserved;

//#else
                                                // Allocate a ndis packet pool for this chunk
  //                                              NdisAllocatePacketPool();
  //                                              etc.


                                                //      Initialize elements of the protocol reserved structure.
                                                pRecvResd->rr_Id        = IDENTIFIER_SPX;
                                                pRecvResd->rr_State     = SPX_RECVPKT_IDLE;
#endif
                                        }
                                }

                                if (i != NumBlksPerChunk)
                                {
                                        // This has to be a failure from Ndis for send blocks!!!
                                        // Undo a bunch of stuff
                                        CTEAssert (BlockId == BLKID_NDISSEND);
                                        pBlkHdr = pChunk->bc_FreeHead;
                                        for (j = 0, pBlkHdr = pChunk->bc_FreeHead;
                                                 j < i; j++, pBlkHdr = pBlkHdr->bh_Next)
                                        {
                                                NdisUnchainBufferAtFront(
                                                        (PNDIS_PACKET)((PBYTE)pBlkHdr + sizeof(BLK_HDR)),
                                                        &pNdisBuffer);

                                                CTEAssert(pNdisBuffer != NULL);
                                                NdisFreeBuffer(pNdisBuffer);

                                                NdisUnchainBufferAtFront(
                                                        (PNDIS_PACKET)((PBYTE)pBlkHdr + sizeof(BLK_HDR)),
                                                        &pNdisIpxSpxBuffer);

                                                if (pNdisIpxSpxBuffer)
                                                {
                                                  NdisFreeBuffer(pNdisIpxSpxBuffer);
                                                }
                                        }

                                        SpxFreeMemory(pChunk);
                                        pChunk = NULL;
                                }
                                else
                                {
                                        // Successfully initialized the chunk, link it in
                                        pChunk->bc_Next = *ppChunkHead;
                                        *ppChunkHead = pChunk;
                                }
                        }
                }

                if (pChunk != NULL)
                {
                        CTEAssert(pChunk->bc_BlkId == BlockId);
                        DBGPRINT(RESOURCES, INFO,
                                        ("SpxBPAllocBlock: Allocating a block out of chunk %lx(%d) for Id %d\n",
                                                pChunk, pChunk->bc_NumFrees, BlockId));

                        pChunk->bc_NumFrees --;
                        pChunk->bc_Age = 0;                     // Reset age
                        pBlk = pChunk->bc_FreeHead;
                        pChunk->bc_FreeHead = pBlk->bh_Next;
                        pBlk->bh_pChunk = pChunk;

                        //      Skip the block header!
                        pBlk++;
                }

                CTEFreeLock(&spxBPLock[BlockId], lockHandle);
        }

        return pBlk;
}



VOID
SpxBPFreeBlock(
        IN      PVOID           pBlock,
        IN      BLKID           BlockId
        )
/*++

Routine Description:

        Return a block to its owning chunk.

Arguments:


Return Value:


--*/
{
        PBLK_CHUNK              pChunk;
        PBLK_HDR                pBlkHdr = (PBLK_HDR)((PCHAR)pBlock - sizeof(BLK_HDR));
        CTELockHandle   lockHandle;

        CTEGetLock(&spxBPLock[BlockId], &lockHandle);

        for (pChunk = spxBPHead[BlockId];
                 pChunk != NULL;
                 pChunk = pChunk->bc_Next)
        {
                CTEAssert(pChunk->bc_BlkId == BlockId);
                if (pBlkHdr->bh_pChunk == pChunk)
                {
                        DBGPRINT(SYSTEM, INFO,
                                        ("SpxBPFreeBlock: Returning Block %lx to chunk %lx for Id %d\n",
                                        pBlkHdr, pChunk, BlockId));

                        CTEAssert (pChunk->bc_NumFrees < spxNumBlks[BlockId]);
                        pChunk->bc_NumFrees ++;
                        pBlkHdr->bh_Next = pChunk->bc_FreeHead;
                        pChunk->bc_FreeHead = pBlkHdr;
                        break;
                }
        }
        CTEAssert ((pChunk != NULL) && (pChunk->bc_FreeHead == pBlkHdr));

        CTEFreeLock(&spxBPLock[BlockId], lockHandle);
        return;
}




ULONG
spxBPAgePool(
        IN PVOID        Context,
        IN BOOLEAN      TimerShuttingDown
        )
/*++

Routine Description:

        Age out the block pool of unused blocks

Arguments:


Return Value:


--*/
{
        PBLK_CHUNK              pChunk, *ppChunk, pFree = NULL;
        LONG                    i, j, NumBlksPerChunk;
        CTELockHandle   lockHandle;
        PNDIS_PACKET    pNdisPkt;
        PNDIS_BUFFER    pNdisBuffer;

        if (TimerShuttingDown)
        {
                return TIMER_DONT_REQUEUE;
        }

        for (i = 0; i < NUM_BLKIDS; i++)
        {
            NumBlksPerChunk = spxNumBlks[i];
                CTEGetLock(&spxBPLock[i], &lockHandle);

                for (ppChunk = &spxBPHead[i];
                         (pChunk = *ppChunk) != NULL; )
                {
                        if ((pChunk->bc_NumFrees == NumBlksPerChunk) &&
                                (++(pChunk->bc_Age) >= MAX_BLOCK_POOL_AGE))
                        {
                                DBGPRINT(SYSTEM, INFO,
                                                ("spxBPAgePool: freeing Chunk %lx, Id %d\n",
                                                pChunk, pChunk->bc_BlkId));

                                *ppChunk = pChunk->bc_Next;
#ifdef  PROFILING
                                InterlockedIncrement( &SpxStatistics.stat_NumBPAge);
#endif
                                if (pChunk->bc_BlkId == BLKID_NDISSEND)
                                {
                                        PBLK_HDR        pBlkHdr;

                                        // We need to free Ndis stuff for these guys
                                        pBlkHdr = pChunk->bc_FreeHead;

                                        for (j = 0, pBlkHdr = pChunk->bc_FreeHead;
                                                 j < NumBlksPerChunk;
                                                 j++, pBlkHdr = pBlkHdr->bh_Next)
                                        {

                                                pNdisPkt = (PNDIS_PACKET)((PBYTE)pBlkHdr + sizeof(BLK_HDR));

                                                NdisUnchainBufferAtFront(
                                                        pNdisPkt,
                                                        &pNdisBuffer);

                                                NdisFreeBuffer(pNdisBuffer);

                                                NdisUnchainBufferAtFront(
                                                        pNdisPkt,
                                                        &pNdisBuffer);

                                                NdisFreeBuffer(pNdisBuffer);

                                        }
                                }

                                SpxFreeMemory(pChunk);
                        }
                        else
                        {
                                ppChunk = &pChunk->bc_Next;
                        }
                }
                CTEFreeLock(&spxBPLock[i], lockHandle);
        }

        return TIMER_REQUEUE_CUR_VALUE;
}

#if !defined SPX_OWN_PACKETS
//
// GrowSPXSendPacketsList
// Called when we dont have any free packets in the SendPacketsList.
//
// Allocate a packet pool, allocate all the packets for that pool and
// store these on a list.
//
// Returns: Pointer to newly allocated packet, or NULL if this faild.
//
PNDIS_PACKET
GrowSPXSendPacketList(void)
{
	NdisResEntry		*NewEntry;
	NDIS_STATUS			Status;
	PNDIS_PACKET		Packet, ReturnPacket;
	uint				i;
	CTELockHandle		Handle;
	
	CTEGetLock(&SendHeaderLock, &Handle);
	
	if (CurrentSendPacketCount >= MaxPacketCount)
		goto failure;
		
	// First, allocate a tracking structure.
	NewEntry = CTEAllocMem(sizeof(NdisResEntry));
	if (NewEntry == NULL)
		goto failure;
		
    NewEntry->nre_handle = (void *) NDIS_PACKET_POOL_TAG_FOR_NWLNKSPX;

	// Got a tracking structure. Now allocate a packet pool.
	NdisAllocatePacketPoolEx(
                             &Status,
                             &NewEntry->nre_handle,
                             PACKET_GROW_COUNT,
                             0,
                             sizeof(SPX_SEND_RESD)
                             );
	
	if (Status != NDIS_STATUS_SUCCESS) {
		CTEFreeMem(NewEntry);
		goto failure;
	}
	
    NdisSetPacketPoolProtocolId(NewEntry->nre_handle,NDIS_PROTOCOL_ID_IPX);

	// We've allocated the pool. Now initialize the packets, and link them
	// on the free list.
	ReturnPacket = NULL;
	
	// Link the new NDIS resource tracker entry onto the list.
	NewEntry->nre_next = SendPacketPoolList;
	SendPacketPoolList = NewEntry;
	CurrentSendPacketCount += PACKET_GROW_COUNT;
	CTEFreeLock(&SendHeaderLock, Handle);
	
	for (i = 0; i < PACKET_GROW_COUNT; i++) {
		SPX_SEND_RESD   *SendReserved;
		
		NdisAllocatePacket(&Status, &Packet, NewEntry->nre_handle);
		if (Status != NDIS_STATUS_SUCCESS) {
			CTEAssert(FALSE);
			break;
		}
		
		CTEMemSet(Packet->ProtocolReserved, 0, sizeof(SPX_SEND_RESD));
		SendReserved = (SPX_SEND_RESD *)Packet->ProtocolReserved;
		// store whatever's required in the reserved section.

        if (i != 0) {
			(void)SpxFreeSendPacket(SpxDevice, Packet);
		} else
			ReturnPacket = Packet;

	}
	
	// We've put all but the first one on the list. Return the first one.
	return ReturnPacket;

failure:
	CTEFreeLock(&SendHeaderLock, Handle);
	return NULL;
		
}

//
// GrowSPXRecvPacketsList
// Called when we dont have any free packets in the RecvPacketsList.
//
// Allocate a packet pool, allocate all the packets for that pool and
// store these on a list.
//
// Returns: Pointer to newly allocated packet, or NULL if this faild.
//
PNDIS_PACKET
GrowSPXRecvPacketList(void)
{
	NdisResEntry		*NewEntry;
	NDIS_STATUS			Status;
	PNDIS_PACKET		Packet, ReturnPacket;
	uint				i;
	CTELockHandle		Handle;
	
	CTEGetLock(&RecvHeaderLock, &Handle);
	
	if (CurrentRecvPacketCount >= MaxPacketCount)
		goto failure;
		
	// First, allocate a tracking structure.
	NewEntry = CTEAllocMem(sizeof(NdisResEntry));
	if (NewEntry == NULL)
		goto failure;
		
    NewEntry->nre_handle = (void *) NDIS_PACKET_POOL_TAG_FOR_NWLNKSPX;

	// Got a tracking structure. Now allocate a packet pool.
	NdisAllocatePacketPoolEx(
                             &Status,
                             &NewEntry->nre_handle,
                             PACKET_GROW_COUNT,
                             0,
                             sizeof(SPX_RECV_RESD)
                             );
	
	if (Status != NDIS_STATUS_SUCCESS) {
		CTEFreeMem(NewEntry);
		goto failure;
	}
	
    NdisSetPacketPoolProtocolId(NewEntry->nre_handle,NDIS_PROTOCOL_ID_IPX);

	// We've allocated the pool. Now initialize the packets, and link them
	// on the free list.
	ReturnPacket = NULL;
	
	// Link the new NDIS resource tracker entry onto the list.
	NewEntry->nre_next = RecvPacketPoolList;
	RecvPacketPoolList = NewEntry;
	CurrentRecvPacketCount += PACKET_GROW_COUNT;
	CTEFreeLock(&RecvHeaderLock, Handle);
	
	for (i = 0; i < PACKET_GROW_COUNT; i++) {
		SPX_RECV_RESD   *RecvReserved;
		
		NdisAllocatePacket(&Status, &Packet, NewEntry->nre_handle);
		if (Status != NDIS_STATUS_SUCCESS) {
			CTEAssert(FALSE);
			break;
		}
		
		CTEMemSet(Packet->ProtocolReserved, 0, sizeof(SPX_RECV_RESD));
		RecvReserved = (SPX_RECV_RESD *)Packet->ProtocolReserved;
		// store whatever's required in the reserved section.

        if (i != 0) {
			(void)SpxFreeRecvPacket(SpxDevice, Packet);
		} else
			ReturnPacket = Packet;

	}
	
	// We've put all but the first one on the list. Return the first one.
	return ReturnPacket;

failure:
	CTEFreeLock(&RecvHeaderLock, Handle);
	return NULL;
		
}

PNDIS_PACKET
SpxAllocSendPacket(
                   IN  PDEVICE      _Device,
                   OUT NDIS_PACKET  **_SendPacket,
                   OUT NDIS_STATUS  *_Status)					

{
        PSINGLE_LIST_ENTRY  Link;
        SPX_SEND_RESD       *Common, *pSendResd;
        PNDIS_BUFFER        pNdisIpxMacBuffer, pNdisIpxSpxBuffer;
        NDIS_STATUS         ndisStatus;
        PUCHAR              pHdrMem = NULL;

        Link = ExInterlockedPopEntrySList(&SendPacketList, &SendHeaderLock);			

        if (Link != NULL) {

           Common = STRUCT_OF(SPX_SEND_RESD, Link, Linkage);
           (*_SendPacket) = STRUCT_OF(NDIS_PACKET, Common, ProtocolReserved);

           (*_Status) = NDIS_STATUS_SUCCESS;

        } else {

           (*_SendPacket) = GrowSPXSendPacketList();
           (*_Status)     =  NDIS_STATUS_SUCCESS;

           if (NULL == *_SendPacket) {
              DBGPRINT(NDIS, DBG, ("Couldn't grow packets allocated...\r\n"));
              (*_Status)     =  NDIS_STATUS_RESOURCES;
              return NULL;
           }
        }

        //
        //  Now add the NdisBuffers to the packet.
        //  1. IPX MAC HDR
        //  2. IPX/SPX Hdr
        //  3. Chain these
        //

        if (NDIS_STATUS_SUCCESS == (*_Status)) {

           //
           // First allocate the memory
           //
           pHdrMem = SpxAllocateMemory(IpxMacHdrNeeded + MIN_IPXSPX2_HDRSIZE);

           if (NULL == pHdrMem) {
              DBGPRINT(NDIS, DBG, ("Cannot allocate non paged pool for sendpacket\n"));
              (*_Status) = NDIS_STATUS_RESOURCES;
              goto failure;
           }

           NdisAllocateBuffer(
                   &ndisStatus,
                   &pNdisIpxMacBuffer,
                   SpxDevice->dev_NdisBufferPoolHandle,
                   pHdrMem,
                   IpxMacHdrNeeded);

           if (ndisStatus != NDIS_STATUS_SUCCESS)
           {

               if (NULL != pHdrMem) {
                   SpxFreeMemory(pHdrMem);
                   pHdrMem = NULL;
               }

               DBGPRINT(NDIS, DBG, ("NdisallocateBuffer failed\r\n", ndisStatus));
               goto failure;
           }

           //  Link the buffer descriptor into the packet descriptor
           NdisChainBufferAtBack(
                   (*_SendPacket),
                   pNdisIpxMacBuffer);


           NdisAllocateBuffer(
                   &ndisStatus,
                   &pNdisIpxSpxBuffer,
                   SpxDevice->dev_NdisBufferPoolHandle,
                   pHdrMem + IpxMacHdrNeeded,
                   MIN_IPXSPX2_HDRSIZE);

           if (ndisStatus != NDIS_STATUS_SUCCESS)
           {
              DBGPRINT(NDIS, DBG, ("NdisallocateBuffer failed\r\n", ndisStatus));
              goto failure;
           }

           //  Link the buffer descriptor into the packet descriptor
           NdisChainBufferAtBack(
                   (*_SendPacket),
                   pNdisIpxSpxBuffer);

           pSendResd = (PSPX_SEND_RESD)(*_SendPacket)->ProtocolReserved;

           //  Initialize elements of the protocol reserved structure.
           pSendResd->sr_Id        = IDENTIFIER_SPX;
           pSendResd->sr_Reserved1 = NULL;
           pSendResd->sr_Reserved2 = NULL;
           pSendResd->sr_State     = SPX_SENDPKT_IDLE;

           return (*_SendPacket);
        }

failure:

   SpxFreeSendPacket(SpxDevice, (*_SendPacket));
   (*_Status) = NDIS_STATUS_RESOURCES;
   return NULL;

}

PNDIS_PACKET
SpxAllocRecvPacket(
                   IN  PDEVICE      _Device,
                   OUT NDIS_PACKET  **_RecvPacket,
                   OUT NDIS_STATUS  *_Status)
{

        PSINGLE_LIST_ENTRY  Link;
        SPX_RECV_RESD       *Common, *pRecvResd;

        Link = ExInterlockedPopEntrySList(
                     &RecvPacketList,
                     &RecvHeaderLock
                     );											

        if (Link != NULL) {
           Common = STRUCT_OF(SPX_RECV_RESD, Link, Linkage);
           //PC = STRUCT_OF(PacketContext, Common, pc_common);
           (*_RecvPacket) = STRUCT_OF(NDIS_PACKET, Common, ProtocolReserved);

           (*_Status) = NDIS_STATUS_SUCCESS;
        } else {

           (*_RecvPacket) = GrowSPXRecvPacketList();
               (*_Status)     =  NDIS_STATUS_SUCCESS;
           if (NULL == *_RecvPacket) {
              DBGPRINT(NDIS, DBG, ("Couldn't grow packets allocated...\r\n"));
              (*_Status)     =  NDIS_STATUS_RESOURCES;
           }
        }

        if ((*_Status) == NDIS_STATUS_SUCCESS) {

           pRecvResd = (PSPX_RECV_RESD)(*_RecvPacket)->ProtocolReserved;
           //  Initialize elements of the protocol reserved structure.
           pRecvResd->rr_Id        = IDENTIFIER_SPX;
           pRecvResd->rr_State     = SPX_RECVPKT_IDLE;

        }

        return (*_RecvPacket);
}

//* SpxFreeSendPacket - Free an SPX packet when we're done with it.
//
//  Called when a send completes and a packet needs to be freed. We look at the
//  packet, decide what to do with it, and free the appropriate components.
//
//  Entry:  Packet  - Packet to be freed.
//
//
void
SpxFreeSendPacket(PDEVICE        _Device,
                  PNDIS_PACKET   _Packet)
{

    PNDIS_BUFFER    NextBuffer, Buffer;
    SPX_SEND_RESD   *Context = (SPX_SEND_RESD *)_Packet->ProtocolReserved;
    PVOID           Header = NULL;
    ULONG           Length = 0;

    DBGPRINT(NDIS, DBG,
     ("SpxFreeSendPacket\n"));

    NdisQueryPacket(_Packet, NULL, NULL, &Buffer, NULL);

    if (NULL != Buffer) {
       NdisQueryBuffer(Buffer, &Header, &Length);
       //KdPrint(("Pointer = %x Length = %x", Header, Length));

       if (Header != NULL && Length > 0) {
          //KdPrint(("Freed buffer"));
          SpxFreeMemory(Header);
       }
    }

    while (Buffer != (PNDIS_BUFFER)NULL) {
        NdisGetNextBuffer(Buffer, &NextBuffer);
        NdisFreeBuffer(Buffer);
        Buffer = NextBuffer;
    }

    NdisReinitializePacket(_Packet);

    ExInterlockedPushEntrySList(
                                &SendPacketList,
                                STRUCT_OF(SINGLE_LIST_ENTRY, &(Context->Linkage), Next),
                                &SendHeaderLock
                                );

    return;
}


//* SpxFreeRecvPacket - Free an SPX packet when we're done with it.
//
//  Called when a recv completes and a packet needs to be freed. We look at the
//  packet, decide what to do with it, and free the appropriate components.
//
//  Entry:  Packet  - Packet to be freed.
//
//

void
SpxFreeRecvPacket(PDEVICE        _Device,
                  PNDIS_PACKET   _Packet)
{ 																		
    PNDIS_BUFFER    NextBuffer, Buffer;
    SPX_RECV_RESD *Context = (SPX_RECV_RESD *)_Packet->ProtocolReserved;

    DBGPRINT(NDIS, DBG,
            ("SpxFreeRecvPacket\n"));

    NdisQueryPacket(_Packet, NULL, NULL, &Buffer, NULL);

    while (Buffer != (PNDIS_BUFFER)NULL) {
        NdisGetNextBuffer(Buffer, &NextBuffer);
        NdisFreeBuffer(Buffer);
        Buffer = NextBuffer;
    }

    NdisReinitializePacket(_Packet);

    ExInterlockedPushEntrySList(
                                &RecvPacketList,
                                STRUCT_OF(SINGLE_LIST_ENTRY, &(Context->Linkage), Next),
                                &RecvHeaderLock
                                );

    return;

}

void
SpxReInitSendPacket(PNDIS_PACKET _Packet)
{
   DBGPRINT(NDIS, DBG,
            ("SpxReInitSendPacket\n"));
}

void
SpxReInitRecvPacket(PNDIS_PACKET _Packet)
{
   DBGPRINT(NDIS, DBG,
               ("SpxReInitRecvPacket\n"));
}


#endif //SPX_OWN_PACKETS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxpkt.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxpkt.c

Abstract:

    This module contains code that builds various spx packets.

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//	Define module number for event logging entries
#define	FILENUM		SPXPKT

VOID
SpxPktBuildCr(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	IN		PSPX_ADDR			pSpxAddr,
	IN OUT	PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fSpx2
	)
/*++

Routine Description:

    NOTE: If *ppPkt is NULL, we allocate a packet. If not, we just
    recreate the data and don't update the packet's state.

Arguments:


Return Value:


--*/
{
	PNDIS_PACKET		pCrPkt;
	PSPX_SEND_RESD		pSendResd;
	NDIS_STATUS			ndisStatus;
	PIPXSPX_HDR			pIpxSpxHdr;
    PNDIS_BUFFER        pNdisMacHdr, pNdisIpxHdr;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

    if (*ppPkt == NULL) {

    	SpxAllocSendPacket(SpxDevice, &pCrPkt, &ndisStatus);
    	if (ndisStatus != NDIS_STATUS_SUCCESS)
    	{
    		DBGPRINT(CONNECT, ERR,
    				("SpxConnHandleConnReq: Could not allocate ndis packet\n"));
    		return;
    	}

    } else {

        pCrPkt = *ppPkt;
    }
    
    //
    // Get the MDL that points to the IPX/SPX header. (the second one)
    //
     
    NdisQueryPacket(pCrPkt, NULL, NULL, &NdisBuf, NULL);
    NdisGetNextBuffer(NdisBuf, &NdisBuf2);
    NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

#if OWN_PKT_POOLS
	pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pCrPkt 			+
										NDIS_PACKET_SIZE 		+
										sizeof(SPX_SEND_RESD)	+
										IpxInclHdrOffset);
#endif 
    NdisQueryPacket(pCrPkt, NULL, NULL, &pNdisMacHdr, NULL);
    pNdisIpxHdr = NDIS_BUFFER_LINKAGE(pNdisMacHdr);
    if (!fSpx2)
    {
      NdisAdjustBufferLength(pNdisIpxHdr, MIN_IPXSPX_HDRSIZE);
    }
	SpxBuildIpxHdr(
		pIpxSpxHdr,
		MIN_IPXSPX_HDRSIZE,
		pSpxConnFile->scf_RemAddr,
		pSpxAddr->sa_Socket);

	//	Build SPX Header.
	pIpxSpxHdr->hdr_ConnCtrl	= (SPX_CC_SYS | SPX_CC_ACK |
									(fSpx2 ? (SPX_CC_SPX2 | SPX_CC_NEG) : 0));
	pIpxSpxHdr->hdr_DataType	= 0;
	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_SrcConnId,
		pSpxConnFile->scf_LocalConnId);
	pIpxSpxHdr->hdr_DestConnId	= 0xFFFF;
	pIpxSpxHdr->hdr_SeqNum		= 0;
	pIpxSpxHdr->hdr_AckNum		= 0;
	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_AllocNum,
		pSpxConnFile->scf_SentAllocNum);

	//	Initialize

    if (*ppPkt == NULL) {

    	pSendResd	= (PSPX_SEND_RESD)(pCrPkt->ProtocolReserved);
    	pSendResd->sr_Id		= IDENTIFIER_SPX;
    	pSendResd->sr_Type		= SPX_TYPE_CR;
    	pSendResd->sr_Reserved1	= NULL;
    	pSendResd->sr_Reserved2	= NULL;
    	pSendResd->sr_State		= State;
    	pSendResd->sr_ConnFile	= pSpxConnFile;
    	pSendResd->sr_Request	= NULL;
    	pSendResd->sr_Next 		= NULL;
    	pSendResd->sr_Len		= pSendResd->sr_HdrLen = MIN_IPXSPX_HDRSIZE;

    	*ppPkt	= pCrPkt;
    }

	return;
}




VOID
SpxPktBuildCrAck(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	IN		PSPX_ADDR			pSpxAddr,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fNeg,
	IN		BOOLEAN				fSpx2
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PNDIS_PACKET		pCrAckPkt;
	PSPX_SEND_RESD		pSendResd;
    PIPXSPX_HDR         pIpxSpxHdr;
	NDIS_STATUS			ndisStatus;
	USHORT				hdrLen;
    PNDIS_BUFFER        pNdisMacHdr, pNdisIpxHdr;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	*ppPkt	= NULL;

	SpxAllocSendPacket(SpxDevice, &pCrAckPkt, &ndisStatus);
	if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		DBGPRINT(CONNECT, ERR,
				("SpxConnHandleConnReq: Could not allocate ndis packet\n"));
		return;
	}
    
    //
    // Get the MDL that points to the IPX/SPX header. (the second one)
    //
     
    NdisQueryPacket(pCrAckPkt, NULL, NULL, &NdisBuf, NULL);
    NdisGetNextBuffer(NdisBuf, &NdisBuf2);
    NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);
#if OWN_PKT_POOLS
	pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pCrAckPkt 			+
										NDIS_PACKET_SIZE 		+
										sizeof(SPX_SEND_RESD)	+
										IpxInclHdrOffset);
#endif 
	hdrLen = (SPX2_CONN(pSpxConnFile) ? MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE);

    NdisQueryPacket(pCrAckPkt, NULL, NULL, &pNdisMacHdr, NULL);
    pNdisIpxHdr = NDIS_BUFFER_LINKAGE(pNdisMacHdr);
    if (!SPX2_CONN(pSpxConnFile))
    {
      NdisAdjustBufferLength(pNdisIpxHdr, MIN_IPXSPX_HDRSIZE);
    }
	SpxBuildIpxHdr(
		pIpxSpxHdr,
		hdrLen,
		pSpxConnFile->scf_RemAddr,
		pSpxAddr->sa_Socket);

	pIpxSpxHdr->hdr_ConnCtrl	=
		(SPX_CC_SYS 														|
		 (fSpx2 ? SPX_CC_SPX2 : 0)	|
		 (fNeg  ? SPX_CC_NEG : 0));

	pIpxSpxHdr->hdr_DataType		= 0;
	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_SrcConnId,
		pSpxConnFile->scf_LocalConnId);

	pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;
	pIpxSpxHdr->hdr_SeqNum		= 0;
	pIpxSpxHdr->hdr_AckNum		= 0;
	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_AllocNum,
		pSpxConnFile->scf_SentAllocNum);

	if (SPX2_CONN(pSpxConnFile))
	{
		DBGPRINT(CONNECT, DBG,
				("SpxConnBuildCrAck: Spx2 packet size %d.%lx\n",
					pSpxConnFile->scf_MaxPktSize));

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			pSpxConnFile->scf_MaxPktSize);
	}


	pSendResd	= (PSPX_SEND_RESD)(pCrAckPkt->ProtocolReserved);
	pSendResd->sr_Id		= IDENTIFIER_SPX;
	pSendResd->sr_Type		= SPX_TYPE_CRACK;
	pSendResd->sr_Reserved1	= NULL;
	pSendResd->sr_Reserved2	= NULL;
	pSendResd->sr_State		= State;
	pSendResd->sr_ConnFile	= pSpxConnFile;
	pSendResd->sr_Request	= NULL;
	pSendResd->sr_Next 		= NULL;
	pSendResd->sr_Len		= pSendResd->sr_HdrLen = hdrLen;

	*ppPkt	= pCrAckPkt;
	return;
}



VOID
SpxPktBuildSn(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_PACKET 	pPkt;
	PSPX_SEND_RESD	pSendResd;
	PNDIS_BUFFER	pBuf;
	NDIS_STATUS		ndisStatus;
    PIPXSPX_HDR     pIpxSpxHdr;
	PBYTE			pData;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	do
	{
		*ppPkt = NULL;

		//	Allocate a ndis packet for the cr.
		SpxAllocSendPacket(SpxDevice, &pPkt, &ndisStatus);
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		CTEAssert(pSpxConnFile->scf_MaxPktSize != 0);
		DBGPRINT(SEND, DBG,
				("SpxPktBuildSn: Data size %lx\n", pSpxConnFile->scf_MaxPktSize));

		if ((pData =
				SpxAllocateMemory(
			        pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE)) == NULL)
		{
			SpxPktSendRelease(pPkt);
			break;
		}

		//	Build ndis buffer desc
		NdisAllocateBuffer(
			&ndisStatus,
			&pBuf,
			SpxDevice->dev_NdisBufferPoolHandle,
			pData,
            pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE);

		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			SpxPktSendRelease(pPkt);
			SpxFreeMemory(pData);
			break;
		}

		//	Chain at back.
		NdisChainBufferAtBack(
			pPkt,
			pBuf);

        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);
#if OWN_PKT_POOLS
		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			pSpxConnFile->scf_MaxPktSize,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);
	
		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl	= (	SPX_CC_SYS | SPX_CC_ACK |
										SPX_CC_NEG | SPX_CC_SPX2);
		pIpxSpxHdr->hdr_DataType	= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;
		pIpxSpxHdr->hdr_SeqNum		= 0;
		pIpxSpxHdr->hdr_AckNum		= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			pSpxConnFile->scf_MaxPktSize);
	
		//	Init the data part to indicate no neg values
		*(UNALIGNED ULONG *)pData = 0;

		pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_Type		= SPX_TYPE_SN;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_State		= (State | SPX_SENDPKT_FREEDATA);
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Request	= NULL;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_HdrLen 	= MIN_IPXSPX2_HDRSIZE;
		pSendResd->sr_Len	    = pSpxConnFile->scf_MaxPktSize;

		*ppPkt 	= pPkt;

	} while (FALSE);

	return;
}




VOID
SpxPktBuildSnAck(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_PACKET 	pPkt;
	NDIS_STATUS		ndisStatus;
    PIPXSPX_HDR     pIpxSpxHdr;
	PSPX_SEND_RESD	pSendResd;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	do
	{
		*ppPkt = NULL;

		//	Allocate a ndis packet for the cr.
		SpxAllocSendPacket(SpxDevice, &pPkt, &ndisStatus);
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			break;
		}
	
#if OWN_PKT_POOLS
		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 
        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

	
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			MIN_IPXSPX2_HDRSIZE,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);
	
		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl	= (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2);
		pIpxSpxHdr->hdr_DataType	= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;
		pIpxSpxHdr->hdr_SeqNum		= 0;
		pIpxSpxHdr->hdr_AckNum		= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			pSpxConnFile->scf_MaxPktSize);
	
		pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_Type		= SPX_TYPE_SNACK;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_State		= State;
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Request	= NULL;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_Len		= pSendResd->sr_HdrLen = MIN_IPXSPX2_HDRSIZE;

		*ppPkt 	= pPkt;

	} while (FALSE);

	return;
}




VOID
SpxPktBuildSs(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_PACKET 	pPkt;
	PSPX_SEND_RESD	pSendResd;
	PNDIS_BUFFER	pBuf;
	NDIS_STATUS		ndisStatus;
    PIPXSPX_HDR     pIpxSpxHdr;
	PBYTE			pData;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	do
	{
		*ppPkt = NULL;

		//	Allocate a ndis packet for the cr.
		SpxAllocSendPacket(SpxDevice, &pPkt, &ndisStatus);
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			break;
		}


		CTEAssert(pSpxConnFile->scf_MaxPktSize != 0);
		DBGPRINT(SEND, DBG,
				("SpxPktBuildSs: Data size %lx\n", pSpxConnFile->scf_MaxPktSize));

		if ((pData =
				SpxAllocateMemory(
					pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE)) == NULL)
		{
			SpxPktSendRelease(pPkt);
			break;
		}

		//	Build ndis buffer desc
		NdisAllocateBuffer(
			&ndisStatus,
			&pBuf,
			SpxDevice->dev_NdisBufferPoolHandle,
			pData,
            pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE);

		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			SpxPktSendRelease(pPkt);
			SpxFreeMemory(pData);
			break;
		}

		//	Chain at back.
		NdisChainBufferAtBack(
			pPkt,
			pBuf);

#if OWN_PKT_POOLS
		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 
        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

		SpxBuildIpxHdr(
			pIpxSpxHdr,
			pSpxConnFile->scf_MaxPktSize,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);
  	
		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl	=
			(SPX_CC_SYS | SPX_CC_ACK | SPX_CC_SPX2 |
				((pSpxConnFile->scf_Flags & SPX_CONNFILE_NEG) ? SPX_CC_NEG : 0));

		pIpxSpxHdr->hdr_DataType	= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;
		pIpxSpxHdr->hdr_SeqNum		= 0;
		pIpxSpxHdr->hdr_AckNum		= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			pSpxConnFile->scf_MaxPktSize);
	
		//	Init the data part to indicate no neg values
		*(UNALIGNED ULONG *)pData = 0;

		pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_Type		= SPX_TYPE_SS;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_State		= (State | SPX_SENDPKT_FREEDATA);
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Request	= NULL;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_HdrLen 	= MIN_IPXSPX2_HDRSIZE;
		pSendResd->sr_Len	    = pSpxConnFile->scf_MaxPktSize;

		*ppPkt 	= pPkt;
	} while (FALSE);

	return;
}



VOID
SpxPktBuildSsAck(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_PACKET 	pPkt;
	NDIS_STATUS		ndisStatus;
    PIPXSPX_HDR     pIpxSpxHdr;
	PSPX_SEND_RESD	pSendResd;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	do
	{
		*ppPkt = NULL;

		//	Allocate a ndis packet for the cr.
		SpxAllocSendPacket(SpxDevice, &pPkt, &ndisStatus);
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			break;
		}
	
        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

#if OWN_PKT_POOLS
        
		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 
	
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			MIN_IPXSPX2_HDRSIZE,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);
	
		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl	=
			(SPX_CC_SYS | SPX_CC_SPX2 |
				((pSpxConnFile->scf_Flags & SPX_CONNFILE_NEG) ? SPX_CC_NEG : 0));

		pIpxSpxHdr->hdr_DataType	= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;
		pIpxSpxHdr->hdr_SeqNum		= 0;
		pIpxSpxHdr->hdr_AckNum		= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			pSpxConnFile->scf_MaxPktSize);
	
		pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_Type		= SPX_TYPE_SSACK;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_State		= State;
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Request	= NULL;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_Len		= pSendResd->sr_HdrLen = MIN_IPXSPX2_HDRSIZE;

		*ppPkt 	= pPkt;

	} while (FALSE);

	return;
}




VOID
SpxPktBuildRr(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				SeqNum,
	IN		USHORT				State
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_PACKET 	pPkt;
	PSPX_SEND_RESD	pSendResd;
	PNDIS_BUFFER	pBuf;
	NDIS_STATUS		ndisStatus;
    PIPXSPX_HDR     pIpxSpxHdr;
	PBYTE			pData;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	do
	{
		*ppPkt = NULL;

		//	Allocate a ndis packet for the cr.
		SpxAllocSendPacket(SpxDevice, &pPkt, &ndisStatus);
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		if ((pData =
				SpxAllocateMemory(
			        pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE)) == NULL)
		{
			SpxPktSendRelease(pPkt);
			break;
		}

		//	Build ndis buffer desc
		NdisAllocateBuffer(
			&ndisStatus,
			&pBuf,
			SpxDevice->dev_NdisBufferPoolHandle,
			pData,
            pSpxConnFile->scf_MaxPktSize - MIN_IPXSPX2_HDRSIZE);

		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			SpxPktSendRelease(pPkt);
			SpxFreeMemory(pData);
			break;
		}

		//	Chain at back.
		NdisChainBufferAtBack(
			pPkt,
			pBuf);

        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

#if OWN_PKT_POOLS
		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			pSpxConnFile->scf_MaxPktSize,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);
	
		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl	= (	SPX_CC_SYS | SPX_CC_ACK |
										SPX_CC_NEG | SPX_CC_SPX2);
		pIpxSpxHdr->hdr_DataType	= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;

		//	For a renegotiate request, we use the sequence number of
		//	the first waiting data packet. Passed in.
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SeqNum,
			SeqNum);

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AckNum,
			pSpxConnFile->scf_RecvSeqNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			pSpxConnFile->scf_MaxPktSize);
	
		//	Init the data part to indicate no neg values
		*(UNALIGNED ULONG *)pData = 0;

		pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_Type		= SPX_TYPE_RR;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_State		= (State | SPX_SENDPKT_FREEDATA);
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Request	= NULL;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_SeqNum	= SeqNum;
		pSendResd->sr_HdrLen 	= MIN_IPXSPX2_HDRSIZE;
		pSendResd->sr_Len	    = pSpxConnFile->scf_MaxPktSize;

		*ppPkt 	= pPkt;

	} while (FALSE);

	return;
}




VOID
SpxPktBuildRrAck(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		USHORT				MaxPktSize
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_PACKET 	pPkt;
	NDIS_STATUS		ndisStatus;
    PIPXSPX_HDR     pIpxSpxHdr;
	PSPX_SEND_RESD	pSendResd;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	do
	{
		*ppPkt = NULL;

		//	Allocate a ndis packet for the cr.
		SpxAllocSendPacket(SpxDevice, &pPkt, &ndisStatus);
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			break;
		}
	
        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

#if OWN_PKT_POOLS
		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif	
	
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			MIN_IPXSPX2_HDRSIZE,
			pSpxConnFile->scf_RemAckAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);
	
		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl	= (SPX_CC_SYS | SPX_CC_NEG | SPX_CC_SPX2);
		pIpxSpxHdr->hdr_DataType	= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SeqNum,
			pSpxConnFile->scf_SendSeqNum);

		//	For the RrAck, ack number will be the appropriate number
		//	for the last data packet received.
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AckNum,
			pSpxConnFile->scf_RenegAckAckNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			MaxPktSize);
	
		DBGPRINT(SEND, DBG3,
				("SpxPktBuildRrAck: SEQ %lx ACKNUM %lx ALLOCNUM %lx MAXPKT %lx\n",
	                pSpxConnFile->scf_SendSeqNum,
                    pSpxConnFile->scf_RenegAckAckNum,
                    pSpxConnFile->scf_SentAllocNum,
                    MaxPktSize));
	
		pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_Type		= SPX_TYPE_RRACK;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_State		= State;
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Request	= NULL;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_Len		= pSendResd->sr_HdrLen = MIN_IPXSPX2_HDRSIZE;

		*ppPkt 	= pPkt;

	} while (FALSE);

	return;
}




VOID
SpxPktBuildDisc(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	IN		PREQUEST			pRequest,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		UCHAR				DataType
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PSPX_SEND_RESD	pSendResd;
	PNDIS_PACKET	pDiscPkt;
	NDIS_STATUS		ndisStatus;
	PIPXSPX_HDR		pIpxSpxHdr;
	USHORT			hdrLen;
    PNDIS_BUFFER    pNdisMacHdr, pNdisIpxHdr;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;


	*ppPkt = NULL;

	SpxAllocSendPacket(SpxDevice, &pDiscPkt, &ndisStatus);
	if (ndisStatus == NDIS_STATUS_SUCCESS)
	{
#if OWN_PKT_POOLS
		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pDiscPkt 			+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 
        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pDiscPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

		hdrLen = SPX2_CONN(pSpxConnFile) ? MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE;
        NdisQueryPacket(pDiscPkt, NULL, NULL, &pNdisMacHdr, NULL);
        pNdisIpxHdr = NDIS_BUFFER_LINKAGE(pNdisMacHdr);
        if (!SPX2_CONN(pSpxConnFile))
        {
           NdisAdjustBufferLength(pNdisIpxHdr, MIN_IPXSPX_HDRSIZE);
        }
	
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			hdrLen,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);

		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl =
			(SPX_CC_ACK |
             (SPX2_CONN(pSpxConnFile) ? SPX_CC_SPX2 : 0) |
			 ((DataType == SPX2_DT_IDISC) ? 0 : SPX_CC_EOM));

		pIpxSpxHdr->hdr_DataType = DataType;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	=
			*((UNALIGNED USHORT *)&pSpxConnFile->scf_RemConnId);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SeqNum,
			pSpxConnFile->scf_SendSeqNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AckNum,
			pSpxConnFile->scf_RecvSeqNum);
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);

		if (SPX2_CONN(pSpxConnFile))
		{
			PUTSHORT2SHORT(
				&pIpxSpxHdr->hdr_NegSize,
				pSpxConnFile->scf_MaxPktSize);
		}

		pSendResd	= (PSPX_SEND_RESD)(pDiscPkt->ProtocolReserved);

		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_State		= State;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_Type		=
			((DataType == SPX2_DT_IDISC) ? SPX_TYPE_IDISC : SPX_TYPE_ORDREL);
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_Request	= pRequest;
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Offset	= 0;
		pSendResd->sr_SeqNum	= pSpxConnFile->scf_SendSeqNum;
		pSendResd->sr_Len		=
		pSendResd->sr_HdrLen 	= hdrLen;

		*ppPkt = pDiscPkt;
	}

	return;
}




VOID
SpxPktBuildProbe(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fSpx2
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PSPX_SEND_RESD	pSendResd;
	PNDIS_PACKET	pProbe;
	NDIS_STATUS		ndisStatus;
	PIPXSPX_HDR		pIpxSpxHdr;
	USHORT		    hdrLen;
    PNDIS_BUFFER    pNdisMacHdr, pNdisIpxHdr;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;


	*ppPkt = NULL;

	SpxAllocSendPacket(SpxDevice, &pProbe, &ndisStatus);
	if (ndisStatus == NDIS_STATUS_SUCCESS)
	{
       //
       // Get the MDL that points to the IPX/SPX header. (the second one)
       //
        
       NdisQueryPacket(pProbe, NULL, NULL, &NdisBuf, NULL);
       NdisGetNextBuffer(NdisBuf, &NdisBuf2);
       NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);
   
#if OWN_PKT_POOLS

		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pProbe 			+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 
		hdrLen = (fSpx2 ? MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE);
	
        NdisQueryPacket(pProbe, NULL, NULL, &pNdisMacHdr, NULL);
        pNdisIpxHdr = NDIS_BUFFER_LINKAGE(pNdisMacHdr);
        if (!fSpx2)
        {
           NdisAdjustBufferLength(pNdisIpxHdr, MIN_IPXSPX_HDRSIZE);
        }
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			hdrLen,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);

		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl	= (SPX_CC_SYS | SPX_CC_ACK |
										(fSpx2 ? SPX_CC_SPX2 : 0));
		pIpxSpxHdr->hdr_DataType	= 0;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	=
			*((UNALIGNED USHORT *)&pSpxConnFile->scf_RemConnId);

		if (fSpx2)
		{
			pIpxSpxHdr->hdr_SeqNum		= 0;
			PUTSHORT2SHORT(
				&pIpxSpxHdr->hdr_NegSize,
				pSpxConnFile->scf_MaxPktSize);
		}
		else
		{
			PUTSHORT2SHORT(
				&pIpxSpxHdr->hdr_SeqNum,
				pSpxConnFile->scf_SendSeqNum);
		}

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AckNum,
			pSpxConnFile->scf_RecvSeqNum);

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);

		pSendResd	= (PSPX_SEND_RESD)(pProbe->ProtocolReserved);
		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_Type		= SPX_TYPE_PROBE;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_State		= State;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_Request	= NULL;
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_Len		=
		pSendResd->sr_HdrLen 	= (fSpx2 ? MIN_IPXSPX2_HDRSIZE
											: MIN_IPXSPX_HDRSIZE);

		*ppPkt = pProbe;
	}

	return;
}




VOID
SpxPktBuildData(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		USHORT				Length
	)
/*++

Routine Description:

	Handles zero length sends.

Arguments:


Return Value:


--*/
{
	PNDIS_BUFFER	pNdisBuffer;
	PSPX_SEND_RESD	pSendResd;
	PNDIS_PACKET	pDataPkt;
	NDIS_STATUS		ndisStatus;
	PIPXSPX_HDR		pIpxSpxHdr;
	USHORT			hdrLen;
    PNDIS_BUFFER    pNdisMacHdr, pNdisIpxHdr;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	*ppPkt = NULL;

	SpxAllocSendPacket(SpxDevice, &pDataPkt, &ndisStatus);
	if (ndisStatus == NDIS_STATUS_SUCCESS)
	{
		//	Make a ndis buffer descriptor for the data if present.
		if (Length > 0)
		{
			SpxCopyBufferChain(
				&ndisStatus,
				&pNdisBuffer,
				SpxDevice->dev_NdisBufferPoolHandle,
				REQUEST_TDI_BUFFER(pSpxConnFile->scf_ReqPkt),
				pSpxConnFile->scf_ReqPktOffset,
				Length);
	
			if (ndisStatus != NDIS_STATUS_SUCCESS)
			{
				//	Free the send packet
				SpxPktSendRelease(pDataPkt);
				return;
			}
	
			//	Chain this in the packet
			NdisChainBufferAtBack(pDataPkt, pNdisBuffer);
		}
        
        //
        // Get the MDL that points to the IPX/SPX header. (the second one)
        //
         
        NdisQueryPacket(pDataPkt, NULL, NULL, &NdisBuf, NULL);
        NdisGetNextBuffer(NdisBuf, &NdisBuf2);
        NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);
    
#if OWN_PKT_POOLS

		pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pDataPkt 			+
											NDIS_PACKET_SIZE 		+
											sizeof(SPX_SEND_RESD)	+
											IpxInclHdrOffset);
#endif 

		hdrLen = SPX2_CONN(pSpxConnFile) ? MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE;
		Length	+= hdrLen;

        NdisQueryPacket(pDataPkt, NULL, NULL, &pNdisMacHdr, NULL);
        pNdisIpxHdr = NDIS_BUFFER_LINKAGE(pNdisMacHdr);
        if (!SPX2_CONN(pSpxConnFile))
        {
           NdisAdjustBufferLength(pNdisIpxHdr, MIN_IPXSPX_HDRSIZE);
        }
		SpxBuildIpxHdr(
			pIpxSpxHdr,
			Length,
			pSpxConnFile->scf_RemAddr,
			pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);

		//	Build SPX Header.
		pIpxSpxHdr->hdr_ConnCtrl =
			(((State & SPX_SENDPKT_ACKREQ) ? SPX_CC_ACK : 0) |
			 ((State & SPX_SENDPKT_EOM) ? SPX_CC_EOM : 0)	 |
             (SPX2_CONN(pSpxConnFile) ? SPX_CC_SPX2 : 0));

		pIpxSpxHdr->hdr_DataType = pSpxConnFile->scf_DataType;
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SrcConnId,
			pSpxConnFile->scf_LocalConnId);
		pIpxSpxHdr->hdr_DestConnId	=
			*((UNALIGNED USHORT *)&pSpxConnFile->scf_RemConnId);

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SeqNum,
			pSpxConnFile->scf_SendSeqNum);

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AckNum,
			pSpxConnFile->scf_RecvSeqNum);

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_AllocNum,
			pSpxConnFile->scf_SentAllocNum);

		if (SPX2_CONN(pSpxConnFile))
		{
			PUTSHORT2SHORT(
				&pIpxSpxHdr->hdr_NegSize,
				pSpxConnFile->scf_MaxPktSize);
		}

		pSendResd	= (PSPX_SEND_RESD)(pDataPkt->ProtocolReserved);

		pSendResd->sr_Id		= IDENTIFIER_SPX;
		pSendResd->sr_State		= State;
		pSendResd->sr_Reserved1	= NULL;
		pSendResd->sr_Reserved2	= NULL;
		pSendResd->sr_Type		= SPX_TYPE_DATA;
		pSendResd->sr_Next 		= NULL;
		pSendResd->sr_Request	= pSpxConnFile->scf_ReqPkt;
		pSendResd->sr_Offset	= pSpxConnFile->scf_ReqPktOffset;
		pSendResd->sr_ConnFile	= pSpxConnFile;
		pSendResd->sr_SeqNum	= pSpxConnFile->scf_SendSeqNum;
		pSendResd->sr_Len		= Length;
		pSendResd->sr_HdrLen 	= hdrLen;

		if (State & SPX_SENDPKT_ACKREQ)
		{
			KeQuerySystemTime((PLARGE_INTEGER)&pSendResd->sr_SentTime);
		}

		CTEAssert(pSendResd->sr_Len <= pSpxConnFile->scf_MaxPktSize);
		*ppPkt = pDataPkt;

		//	Ok, allocation succeeded. Increment send seq.
		pSpxConnFile->scf_SendSeqNum++;
	}

	return;
}


VOID
SpxCopyBufferChain(
    OUT PNDIS_STATUS Status,
    OUT PNDIS_BUFFER * TargetChain,
    IN NDIS_HANDLE PoolHandle,
    IN PNDIS_BUFFER SourceChain,
    IN UINT Offset,
    IN UINT Length
    )
/*++

Routine Description:

    Creates a TargetBufferChain from the SourceBufferChain.  The copy begins at
    the 'Offset' location in the source chain. It copies 'Length' bytes. It also
    handles Length = 0. If we run out of source chain before copying length amount
    of bytes or run out of memory to create any more buffers for the target chain,
    we clean up the partial chain created so far.

Arguments:

    Status - Status of the request.
    TargetChain - Pointer to the allocated buffer descriptor.
    PoolHandle - Handle that is used to specify the pool.
    SourceChain - Pointer to the descriptor of the source memory.
    Offset - The Offset in the sources memory from which the copy is to
             begin
    Length - Number of Bytes to copy.

Return Value:

    None.

--*/
{
    UINT            BytesBeforeCurBuffer        = 0;
    PNDIS_BUFFER    CurBuffer                   = SourceChain;
    UINT            BytesLeft;
    UINT            AvailableBytes;
    PNDIS_BUFFER    NewNdisBuffer, StartTargetChain;

    CTEAssert( SourceChain );

    // First of all find the source buffer that contains data that starts at
    // Offset.
    NdisQueryBuffer( CurBuffer, NULL, &AvailableBytes );
    while ( BytesBeforeCurBuffer + AvailableBytes <= Offset ) {
        BytesBeforeCurBuffer    += AvailableBytes;
        CurBuffer               = CurBuffer->Next;
        if ( CurBuffer ) {
            NdisQueryBuffer( CurBuffer, NULL, &AvailableBytes );
        } else {
            break;
        }
    }

    if ( ! CurBuffer ) {
        *Status = STATUS_UNSUCCESSFUL;
        return;
    }

    //
    // Copy the first buffer. This takes care of Length = 0.
    //
    BytesLeft   = Length;

    //
    // ( Offset - BytesBeforeCurBuffer ) gives us the offset within this buffer.
    //

    AvailableBytes -= ( Offset - BytesBeforeCurBuffer );

    if ( AvailableBytes > BytesLeft ) {
        AvailableBytes = BytesLeft;
    }

    NdisCopyBuffer(
        Status,
        &NewNdisBuffer,
        PoolHandle,
        CurBuffer,
        Offset - BytesBeforeCurBuffer,
        AvailableBytes);

    if ( *Status != NDIS_STATUS_SUCCESS ) {
        return;
    }

    StartTargetChain    =  NewNdisBuffer;
    BytesLeft           -= AvailableBytes;

    //
    // Did the first buffer have enough data. If so, we r done.
    //
    if ( ! BytesLeft ) {
        *TargetChain = StartTargetChain;
        return;
    }

    //
    // Now follow the Mdl chain and copy more buffers.
    //
    CurBuffer = CurBuffer->Next;
    NdisQueryBuffer( CurBuffer, NULL, &AvailableBytes );
    while ( CurBuffer  ) {

        if ( AvailableBytes > BytesLeft ) {
            AvailableBytes = BytesLeft;
        }

        NdisCopyBuffer(
            Status,
            &(NDIS_BUFFER_LINKAGE(NewNdisBuffer)),
            PoolHandle,
            CurBuffer,
            0,
            AvailableBytes);

        if ( *Status != NDIS_STATUS_SUCCESS ) {

            //
            // ran out of resources. put back what we've used in this call and
            // return the error.
            //

            while ( StartTargetChain != NULL) {
                NewNdisBuffer = NDIS_BUFFER_LINKAGE( StartTargetChain );
                NdisFreeBuffer ( StartTargetChain );
                StartTargetChain = NewNdisBuffer;
            }

            return;
        }

        NewNdisBuffer = NDIS_BUFFER_LINKAGE(NewNdisBuffer);
        BytesLeft -= AvailableBytes;

        if ( ! BytesLeft ) {
            *TargetChain = StartTargetChain;
            return;
        }

        CurBuffer   = CurBuffer->Next;
        NdisQueryBuffer( CurBuffer, NULL, &AvailableBytes );
    }

    //
    // Ran out of source chain. This should not happen.
    //

    CTEAssert( FALSE );

    // For Retail build we clean up anyways.

    while ( StartTargetChain != NULL) {
        NewNdisBuffer = NDIS_BUFFER_LINKAGE( StartTargetChain );
        NdisFreeBuffer ( StartTargetChain );
        StartTargetChain = NewNdisBuffer;
    }

    *Status = STATUS_UNSUCCESSFUL;
    return;
}


VOID
SpxPktBuildAck(
	IN		PSPX_CONN_FILE		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fBuildNack,
	IN		USHORT				NumToResend
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PNDIS_PACKET		pPkt;
	PSPX_SEND_RESD		pSendResd;
    PIPXSPX_HDR         pIpxSpxHdr;
	NDIS_STATUS			ndisStatus;
	USHORT				hdrLen;
    PNDIS_BUFFER    pNdisMacHdr, pNdisIpxHdr;
    PNDIS_BUFFER        NdisBuf, NdisBuf2;
    ULONG               BufLen = 0;

	BOOLEAN				fSpx2 = SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_SPX2);

	*ppPkt	= NULL;

	SpxAllocSendPacket(SpxDevice, &pPkt, &ndisStatus);
	if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		DBGPRINT(SEND, ERR,
				("SpxPktBuildAck: Could not allocate ndis packet\n"));
		return;
	}

    //
    // Get the MDL that points to the IPX/SPX header. (the second one)
    //
     
    NdisQueryPacket(pPkt, NULL, NULL, &NdisBuf, NULL);
    NdisGetNextBuffer(NdisBuf, &NdisBuf2);
    NdisQueryBuffer(NdisBuf2, (PUCHAR) &pIpxSpxHdr, &BufLen);

#if OWN_PKT_POOLS
	pIpxSpxHdr		= 	(PIPXSPX_HDR)((PBYTE)pPkt 				+
										NDIS_PACKET_SIZE 		+
										sizeof(SPX_SEND_RESD)	+
										IpxInclHdrOffset);
#endif 
	hdrLen = SPX2_CONN(pSpxConnFile) ? MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE;
    NdisQueryPacket(pPkt, NULL, NULL, &pNdisMacHdr, NULL);
    pNdisIpxHdr = NDIS_BUFFER_LINKAGE(pNdisMacHdr);
    if (!fSpx2)
    {
           NdisAdjustBufferLength(pNdisIpxHdr, MIN_IPXSPX_HDRSIZE);
    }

    // Send where data came from
	SpxBuildIpxHdr(
		pIpxSpxHdr,
		hdrLen,
		pSpxConnFile->scf_RemAckAddr,
		pSpxConnFile->scf_AddrFile->saf_Addr->sa_Socket);

	pIpxSpxHdr->hdr_ConnCtrl	= (SPX_CC_SYS | (fSpx2 ? SPX_CC_SPX2 : 0));

	pIpxSpxHdr->hdr_DataType		= 0;
	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_SrcConnId,
		pSpxConnFile->scf_LocalConnId);

	pIpxSpxHdr->hdr_DestConnId	= pSpxConnFile->scf_RemConnId;

	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_AckNum,
		pSpxConnFile->scf_RecvSeqNum);

	if (fSpx2)
	{
        pIpxSpxHdr->hdr_SeqNum = 0;
		if (fBuildNack)
		{
			PUTSHORT2SHORT(
				&pIpxSpxHdr->hdr_SeqNum,
				NumToResend);
		}

		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_NegSize,
			pSpxConnFile->scf_MaxPktSize);
	}
	else
	{
		//	Put current send seq number in packet for spx1
		PUTSHORT2SHORT(
			&pIpxSpxHdr->hdr_SeqNum,
			pSpxConnFile->scf_SendSeqNum);
	}

	PUTSHORT2SHORT(
		&pIpxSpxHdr->hdr_AllocNum,
		pSpxConnFile->scf_SentAllocNum);

	pSendResd	= (PSPX_SEND_RESD)(pPkt->ProtocolReserved);
	pSendResd->sr_Id		= IDENTIFIER_SPX;
	pSendResd->sr_Type		= (fBuildNack ? SPX_TYPE_DATANACK : SPX_TYPE_DATAACK);
	pSendResd->sr_Reserved1	= NULL;
	pSendResd->sr_Reserved2	= NULL;
	pSendResd->sr_State		= State;
	pSendResd->sr_ConnFile	= pSpxConnFile;
	pSendResd->sr_Request	= NULL;
	pSendResd->sr_Next 		= NULL;
	pSendResd->sr_Len		= pSendResd->sr_HdrLen = hdrLen;

	*ppPkt	= pPkt;
	return;
}



VOID
SpxPktRecvRelease(
	IN	PNDIS_PACKET	pPkt
	)
{
	((PSPX_RECV_RESD)(pPkt->ProtocolReserved))->rr_State = SPX_RECVPKT_IDLE;
	SpxFreeRecvPacket(SpxDevice, pPkt);
	return;
}




VOID
SpxPktSendRelease(
	IN	PNDIS_PACKET	pPkt
	)
{
	PNDIS_BUFFER	pBuf, pIpxSpxBuf, pFreeBuf;
	UINT			bufCount;

	CTEAssert((((PSPX_SEND_RESD)(pPkt->ProtocolReserved))->sr_State &
									SPX_SENDPKT_IPXOWNS) == 0);

	NdisQueryPacket(pPkt, NULL, &bufCount, &pBuf, NULL);

	//	BufCount == 1 for only the header. That's ok, we just reset the length
	//	and free the packet to the buffer pools. Else we need to free user buffers
	//	before that.

	NdisUnchainBufferAtFront(
		pPkt,
		&pBuf);

	NdisUnchainBufferAtFront(
		pPkt,
		&pIpxSpxBuf);

    //
    // Set the header length to the max. that can be needed.
    //
    NdisAdjustBufferLength(pIpxSpxBuf, MIN_IPXSPX2_HDRSIZE);

	while (bufCount-- > 2)
	{
		PBYTE	pData;
		ULONG	dataLen;

		NdisUnchainBufferAtBack(
			pPkt,
			&pFreeBuf);

		//	See if we free data associated with the buffer
		if ((((PSPX_SEND_RESD)(pPkt->ProtocolReserved))->sr_State &
												SPX_SENDPKT_FREEDATA) != 0)
		{
			NdisQueryBuffer(pFreeBuf, &pData, &dataLen);
			CTEAssert(pData != NULL);
			SpxFreeMemory(pData);
		}

		CTEAssert(pFreeBuf != NULL);
		NdisFreeBuffer(pFreeBuf);
	}

	NdisReinitializePacket(pPkt);

	//	Initialize elements of the protocol reserved structure.
	((PSPX_SEND_RESD)(pPkt->ProtocolReserved))->sr_Id	 	= IDENTIFIER_SPX;
	((PSPX_SEND_RESD)(pPkt->ProtocolReserved))->sr_State	= SPX_SENDPKT_IDLE;
	((PSPX_SEND_RESD)(pPkt->ProtocolReserved))->sr_Reserved1= NULL;
	((PSPX_SEND_RESD)(pPkt->ProtocolReserved))->sr_Reserved2= NULL;

	NdisChainBufferAtFront(
		pPkt,
		pBuf);

	NdisChainBufferAtBack(
		pPkt,
		pIpxSpxBuf);

	SpxFreeSendPacket(SpxDevice, pPkt);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxntdef.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxntdef.h				

Abstract:

	Missing nt definitions in ntddk.h

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/


NTSTATUS
NTAPI
NtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

NTSTATUS
NTAPI
NtClose(
    IN HANDLE Handle
    );

NTSTATUS
NTAPI
NtDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

NTSTATUS
NTAPI
NtWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxpkt.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxpkt.h

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/

//	Use our own NDIS packets
//#define	SPX_OWN_PACKETS		1



//
// List of NDIS_PACKETS stored...
//
extern SLIST_HEADER    SendPacketList;  
extern SLIST_HEADER    RecvPacketList;  
EXTERNAL_LOCK(RecvHeaderLock);
EXTERNAL_LOCK(SendHeaderLock);

//  Offsets into the IPX header
#define IPX_HDRSIZE         30  // Size of the IPX header
#define IPX_CHECKSUM        0   // Checksum
#define IPX_LENGTH          2   // Length
#define IPX_XPORTCTL        4   // Transport Control
#define IPX_PKTTYPE         5   // Packet Type
#define IPX_DESTADDR        6   // Dest. Address (Total)
#define IPX_DESTNET         6   // Dest. Network Address
#define IPX_DESTNODE        10  // Dest. Node Address
#define IPX_DESTSOCK        16  // Dest. Socket Number
#define IPX_SRCADDR         18  // Source Address (Total)
#define IPX_SRCNET          18  // Source Network Address
#define IPX_SRCNODE         22  // Source Node Address
#define IPX_SRCSOCK         28  // Source Socket Number

#define IPX_NET_LEN         4
#define IPX_NODE_LEN        6


#include <packon.h>

// Definition of the IPX/SPX header.
typedef struct _IPXSPX_HEADER
{
    USHORT 	hdr_CheckSum;
    USHORT 	hdr_PktLen;
    UCHAR 	hdr_XportCtrl;
    UCHAR 	hdr_PktType;
    UCHAR 	hdr_DestNet[4];
    UCHAR 	hdr_DestNode[6];
    USHORT 	hdr_DestSkt;
    UCHAR 	hdr_SrcNet[4];
    UCHAR 	hdr_SrcNode[6];
    USHORT 	hdr_SrcSkt;

	//	SPX Header Elements
	UCHAR	hdr_ConnCtrl;
	UCHAR	hdr_DataType;
	USHORT	hdr_SrcConnId;
	USHORT	hdr_DestConnId;
	USHORT	hdr_SeqNum;
	USHORT	hdr_AckNum;
	USHORT	hdr_AllocNum;

	//	For non-CR SPXII packets only
	USHORT	hdr_NegSize;

} IPXSPX_HDR, *PIPXSPX_HDR;

#include <packoff.h>

//	NDIS Packet size - two more ulongs added... 11/26/96
#define		NDIS_PACKET_SIZE	48+8
	
//	Minimum header size (doesnt include neg size)
#define		MIN_IPXSPX_HDRSIZE	(sizeof(IPXSPX_HDR) - sizeof(USHORT))
#define		MIN_IPXSPX2_HDRSIZE	sizeof(IPXSPX_HDR)
#define		SPX_CR_PKTLEN		42

//	SPX packet type
#define		SPX_PKT_TYPE		0x5

//	Connection control fields
#define		SPX_CC_XHD		0x01
#define		SPX_CC_RES1		0x02
#define		SPX_CC_NEG		0x04
#define		SPX_CC_SPX2		0x08
#define		SPX_CC_EOM		0x10
#define		SPX_CC_ATN		0x20
#define		SPX_CC_ACK		0x40
#define		SPX_CC_SYS		0x80

#define		SPX_CC_CR		(SPX_CC_ACK | SPX_CC_SYS)

//	Data stream types
#define		SPX2_DT_ORDREL		0xFD
#define		SPX2_DT_IDISC		0xFE
#define		SPX2_DT_IDISC_ACK	0xFF

//	Negotiation size
#define	SPX_MAX_PACKET			576
#define	SPX_NEG_MIN				SPX_MAX_PACKET
#define	SPX_NEG_MAX				65535

//	No packet references connection. But if the sends are being aborted, and
//	the packet happens to be owned by ipx at the time, the pkt is dequeued from
//	conn, the ABORT flag is set and conn is referenced for packet.
//
//	Send packet states
//	ABORT	: Used for aborted packet. Calls AbortSendPkt().
//	IPXOWNS	: Currently owned by ipx
//	FREEDATA: Frees the data associated with second ndis buffer desc
//	ACKREQ	: Only for sequenced packets. Set by retry timer in packets it wants
//			  resent (1 for spx1, all pending for spx2) with ack bit set.
//	DESTROY	: Only for non-sequenced packets, dequeue packet from list and free.
//	REQ		: For both seq/non-seq. A request is associated with the packet
//	SEQ		: Packet is a sequenced packet.
//	LASTPKT	: Packet is last packet comprising the request, if acked req is done.
//	EOM		: Send EOM with the last packet for this request
//	ACKEDPKT: Send completion must only deref req with pkt and complete if zero.
//

#define	SPX_SENDPKT_IDLE        0
#define	SPX_SENDPKT_ABORT		0x0002
#define SPX_SENDPKT_IPXOWNS		0x0004
#define	SPX_SENDPKT_FREEDATA    0x0008
#define	SPX_SENDPKT_ACKREQ		0x0010
#define	SPX_SENDPKT_DESTROY		0x0020
#define	SPX_SENDPKT_REQ			0x0040
#define	SPX_SENDPKT_SEQ			0x0080
#define	SPX_SENDPKT_LASTPKT		0x0100
#define	SPX_SENDPKT_ACKEDPKT	0x0200
#define	SPX_SENDPKT_EOM			0x0400
#define	SPX_SENDPKT_REXMIT		0x0800

//	Packet types
#define	SPX_TYPE_CR		 		0x01
#define	SPX_TYPE_CRACK			0x02
#define	SPX_TYPE_SN				0x03
#define	SPX_TYPE_SNACK			0x04
#define	SPX_TYPE_SS				0x05
#define	SPX_TYPE_SSACK			0x06
#define	SPX_TYPE_RR				0x07
#define	SPX_TYPE_RRACK			0x08
#define	SPX_TYPE_IDISC			0x09
#define	SPX_TYPE_IDISCACK		0x0a
#define	SPX_TYPE_ORDREL			0x0b
#define	SPX_TYPE_ORDRELACK		0x0c
#define	SPX_TYPE_DATA			0x0d
#define	SPX_TYPE_DATAACK		0x0e
#define	SPX_TYPE_DATANACK		0x0f
#define	SPX_TYPE_PROBE			0x10

// Definition of the protocol reserved field of a send packet.
// Make Len/HdrLen USHORTS, move to the end before the
//		   sr_SentTime so we dont use padding space.
typedef struct _SPX_SEND_RESD
{
	UCHAR					sr_Id;						// Set to SPX
	UCHAR					sr_Type;					// What kind of packet
	USHORT					sr_State;					// State of send packet
	PVOID					sr_Reserved1;				// Needed by IPX
	PVOID					sr_Reserved2;				// Needed by IPX
#if     defined(_PNP_POWER)
    PVOID                   sr_Reserved[SEND_RESERVED_COMMON_SIZE-2]; // needed by IPX for local target
#endif  _PNP_POWER
	ULONG					sr_Len;						// Length of packet
	ULONG					sr_HdrLen;					// Included header length

	struct _SPX_SEND_RESD *	sr_Next;					// Points to next packet
														// in send queue in conn.
    PREQUEST 				sr_Request;              	// request associated
	ULONG					sr_Offset;					// Offset in mdl for sends

#ifndef SPX_OWN_PACKETS
    PVOID					sr_FreePtr;              	// Ptr to use in free chunk
#endif

    struct _SPX_CONN_FILE * sr_ConnFile; 				// that this send is on
	USHORT					sr_SeqNum;					// Seq num for seq pkts

														// Quad word aligned.
	LARGE_INTEGER			sr_SentTime;				// Time packet was sent
														// Only valid for data pkt
														// with ACKREQ set.
    SINGLE_LIST_ENTRY       Linkage;
} SPX_SEND_RESD, *PSPX_SEND_RESD;



//	Recv packet states
#define	SPX_RECVPKT_IDLE		0
#define	SPX_RECVPKT_BUFFERING	0x0001
#define	SPX_RECVPKT_IDISC		0x0002
#define	SPX_RECVPKT_ORD_DISC	0x0004
#define	SPX_RECVPKT_INDICATED	0x0008
#define	SPX_RECVPKT_SENDACK		0x0010
#define	SPX_RECVPKT_EOM			0x0020
#define	SPX_RECVPKT_IMMEDACK	0x0040

#define	SPX_RECVPKT_DISCMASK	(SPX_RECVPKT_ORD_DISC | SPX_RECVPKT_IDISC)

// Definition of the protocol reserved field of a receive packet.
typedef struct _SPX_RECV_RESD
{
	UCHAR					rr_Id;						// Set to SPX
	USHORT					rr_State;					// State of receive packet
	struct _SPX_RECV_RESD *	rr_Next;					// Points to next packet
	ULONG					rr_DataOffset;				// To indicate/copy from

#ifndef SPX_OWN_PACKETS
    PVOID					rr_FreePtr;              	// Ptr to use in free chunk
#endif

#if DBG
	USHORT					rr_SeqNum;					// Seq num of packet
#endif
    SINGLE_LIST_ENTRY       Linkage;
    PREQUEST 				rr_Request;            		// request waiting on xfer
    struct _SPX_CONN_FILE * rr_ConnFile; 				// that this recv is on

} SPX_RECV_RESD, *PSPX_RECV_RESD;


//	Destination built as an assign of 3 ulongs.
#define	SpxBuildIpxHdr(pIpxSpxHdr, PktLen, pRemAddr, SrcSkt)					\
		{																		\
			PBYTE	pDestIpxAddr = (PBYTE)pIpxSpxHdr->hdr_DestNet;				\
			(pIpxSpxHdr)->hdr_CheckSum	= 0xFFFF;								\
			PUTSHORT2SHORT((PUSHORT)(&(pIpxSpxHdr)->hdr_PktLen), (PktLen));		\
			(pIpxSpxHdr)->hdr_XportCtrl	= 0;									\
			(pIpxSpxHdr)->hdr_PktType		= SPX_PKT_TYPE;						\
			*((UNALIGNED ULONG *)pDestIpxAddr) =								\
				*((UNALIGNED ULONG *)pRemAddr);									\
			*((UNALIGNED ULONG *)(pDestIpxAddr+4)) =							\
				*((UNALIGNED ULONG *)(pRemAddr+4));								\
			*((UNALIGNED ULONG *)(pDestIpxAddr+8)) =							\
				*((UNALIGNED ULONG *)(pRemAddr+8));								\
			*((UNALIGNED ULONG *)((pIpxSpxHdr)->hdr_SrcNet))=					\
				*((UNALIGNED ULONG *)(SpxDevice->dev_Network));					\
			*((UNALIGNED ULONG *)((pIpxSpxHdr)->hdr_SrcNode)) = 				\
				*((UNALIGNED ULONG *)SpxDevice->dev_Node);						\
			*((UNALIGNED USHORT *)((pIpxSpxHdr)->hdr_SrcNode+4)) = 				\
				*((UNALIGNED USHORT *)(SpxDevice->dev_Node+4));					\
			*((UNALIGNED USHORT *)&((pIpxSpxHdr)->hdr_SrcSkt)) = 				\
				SrcSkt;															\
		}

#define	SpxCopyIpxAddr(pIpxSpxHdr, pDestIpxAddr)								\
		{																		\
			PBYTE	pRemAddr = (PBYTE)pIpxSpxHdr->hdr_SrcNet;					\
			*((UNALIGNED ULONG *)pDestIpxAddr) =								\
				*((UNALIGNED ULONG *)pRemAddr);									\
			*((UNALIGNED ULONG *)(pDestIpxAddr+4)) =							\
				*((UNALIGNED ULONG *)(pRemAddr+4));								\
			*((UNALIGNED ULONG *)(pDestIpxAddr+8)) =							\
				*((UNALIGNED ULONG *)(pRemAddr+8));								\
		}

#ifdef UNDEFINDED

#define SpxAllocRecvPacket(_Device,_RecvPacket,_Status)							\
	{ 							                                                \
        PSINGLE_LIST_ENTRY  Link;                                               \ 
                                                                                \       
        Link = ExInterlockedPopEntrySList(                                      \
                     &PacketList,                                               \ 
                     &HeaderLock                                                \       
                     );											                \
                                                                                 \
        if (Link != NULL) {                                                      \         
           Common = STRUCT_OF(struct PCCommon, Link, pc_link);                   \
           PC = STRUCT_OF(PacketContext, Common, pc_common);                     \      
           (*_RecvPacket) = STRUCT_OF(NDIS_PACKET, PC, ProtocolReserved);        \
           (*_Status) = NDIS_STATUS_SUCCESS;                                     \
        } else {                                                                 \
                                                                                 \
           (*_RecvPacket) = GrowSPXPacketsList();                              \ 
               (*_Status)     =  NDIS_STATUS_SUCCESS;                          \
           if (NULL == _RecvPacket) {                                       \
              DBGPRINT(NDIS, ("Couldn't grow packets allocated...\r\n"));   \
              (*_Status)     =  NDIS_STATUS_RESOURCES;                          \
           }                                                                \
        }                                                                   \
    }                                                                      

#define SpxFreeSendPacket(_Device,_Packet)										\
		{ 																		\
           DBGPRINT(NDIS                                                        \ 
            ("SpxFreeSendPacket\n"));                                           \
           SpxFreePacket(_Device, _Packet);                                     \
        }                                                                       \

#define SpxFreeRecvPacket(_Device,_Packet)										\
		{ 																		\
           DBGPRINT(NDIS                                                        \ 
            ("SpxFreeRecvPacket\n"));                                           \
           SpxFreePacket(_Device, _Packet);                                     \
        }                                                                       \

#define	SpxReInitSendPacket(_Packet)                                            \
		{                                                                       \
           DBGPRINT(NDIS                                                        \ 
            ("SpxReInitSendPacket\n"));                                         \
		}                                                                       \

#define	SpxReInitRecvPacket(_Packet)                                            \
		{                                                                       \
           DBGPRINT(NDIS,                                                       \ 
            ("SpxReInitRecvPacket\n"));                                         \ 
		}            
                                                                   \    
#endif

#if !defined SPX_OWN_PACKETS

#define SEND_RESD(_Packet) ((PSPX_SEND_RESD)((_Packet)->ProtocolReserved))
#define RECV_RESD(_Packet) ((PSPX_RECV_RESD)((_Packet)->ProtocolReserved))

#else

#define SpxAllocSendPacket(_Device, _SendPacket, _Status)						\
		{ 																		\
			if (*(_SendPacket) = SpxBPAllocBlock(BLKID_NDISSEND))				\
				*(_Status) = NDIS_STATUS_SUCCESS;	 							\
			else																\
				*(_Status) = NDIS_STATUS_RESOURCES;								\
		}																		

#define SpxAllocRecvPacket(_Device,_RecvPacket,_Status)							\
		{																		\
			if (*(_RecvPacket) = SpxBPAllocBlock(BLKID_NDISRECV))				\
				*(_Status) = NDIS_STATUS_SUCCESS;	 							\
			else																\
				*(_Status) = NDIS_STATUS_RESOURCES;								\
		}

#define SpxFreeSendPacket(_Device,_Packet)										\
		{ 																		\
			SpxBPFreeBlock(_Packet, BLKID_NDISSEND);							\
		}

#define SpxFreeRecvPacket(_Device,_Packet)										\
		{ 																		\
			SpxBPFreeBlock(_Packet, BLKID_NDISRECV);							\
		}

#define	SpxReInitSendPacket(_Packet)											\
		{																		\
		}

#define	SpxReInitRecvPacket(_Packet)											\
		{																		\
		}

#define SEND_RESD(_Packet) ((PSPX_SEND_RESD)((_Packet)->ProtocolReserved))
#define RECV_RESD(_Packet) ((PSPX_RECV_RESD)((_Packet)->ProtocolReserved))

#endif




#if !defined SPX_OWN_PACKETS
//
// If we DO NOT use SPX_OWN_PACKETS, we would rather make it a function call
//

PNDIS_PACKET
SpxAllocSendPacket(
                   IN  PDEVICE      _Device,
                   OUT PNDIS_PACKET *_SendPacket,
                   OUT PNDIS_STATUS _Status
                   );

PNDIS_PACKET
SpxAllocRecvPacket(
                   IN  PDEVICE      _Device,
                   OUT PNDIS_PACKET *_SendPacket,
                   OUT PNDIS_STATUS _Status
                   );   

void 
SpxFreeSendPacket(
                  PDEVICE        _Device,
                  PNDIS_PACKET   _Packet
                  );

void
SpxFreeRecvPacket(
                  PDEVICE        _Device,
                  PNDIS_PACKET   _Packet
                  );   

void 
SpxReInitSendPacket(
                    PNDIS_PACKET _Packet
                    );

void 
SpxReInitRecvPacket(
                    PNDIS_PACKET _Packet
                    );


#endif // SPX_OWN_PACKETS

//
//	Routine Prototypes
//

VOID
SpxPktBuildCr(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	IN		struct _SPX_ADDR		*	pSpxAddr,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fSpx2);

VOID
SpxPktBuildCrAck(
	IN		struct _SPX_CONN_FILE 	*	pSpxConnFile,
	IN		struct _SPX_ADDR		*	pSpxAddr,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fNeg,
	IN		BOOLEAN				fSpx2);

VOID
SpxPktBuildSn(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State);

VOID
SpxPktBuildSs(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State);

VOID
SpxPktBuildSsAck(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State);

VOID
SpxPktBuildSnAck(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State);

VOID
SpxPktBuildRr(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				SeqNum,
	IN		USHORT				State);

VOID
SpxPktBuildRrAck(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		USHORT				MaxPktSize);

VOID
SpxPktBuildProbe(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fSpx2);

VOID
SpxPktBuildData(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		USHORT				Length);

VOID
SpxCopyBufferChain(
    OUT PNDIS_STATUS Status,
    OUT PNDIS_BUFFER * TargetChain,
    IN NDIS_HANDLE PoolHandle,
    IN PNDIS_BUFFER SourceChain,
    IN UINT Offset,
    IN UINT Length
    );

VOID
SpxPktBuildAck(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		BOOLEAN				fBuildNack,
	IN		USHORT				NumToResend);

VOID
SpxPktBuildDisc(
	IN		struct _SPX_CONN_FILE *		pSpxConnFile,
	IN		PREQUEST			pRequest,
	OUT		PNDIS_PACKET	*	ppPkt,
	IN		USHORT				State,
	IN		UCHAR				DataType);

VOID
SpxPktRecvRelease(
	IN	PNDIS_PACKET	pPkt);

VOID
SpxPktSendRelease(
	IN	PNDIS_PACKET	pPkt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxquery.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxquery.h				

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/

#define SPX_TDI_PROVIDERINFO_VERSION    0x0001
#define SPX_PINFOSENDSIZE               0xFFFFFFFF
#define SPX_PINFOMINMAXLOOKAHEAD		128

//
// Bug #14498: Indicate to AFD that we are capable of orderly disc so AFD can follow
// these semantics.
// In order to have SPXI connections work correctly, we OR this bit in at query time.
// (see SpxTdiQueryInformation)
//
#define SPX_PINFOSERVICEFLAGS   (   TDI_SERVICE_CONNECTION_MODE     | \
                                    TDI_SERVICE_DELAYED_ACCEPTANCE  | \
                                    TDI_SERVICE_MESSAGE_MODE        | \
                                    TDI_SERVICE_ERROR_FREE_DELIVERY) // | \
                                    // TDI_SERVICE_ORDERLY_RELEASE       )

VOID
SpxQueryInitProviderInfo(
    PTDI_PROVIDER_INFO  ProviderInfo);

NTSTATUS
SpxTdiQueryInformation(
    IN PDEVICE Device,
    IN PREQUEST Request);

NTSTATUS
SpxTdiSetInformation(
    IN PDEVICE Device,
    IN PREQUEST Request);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxquery.c ===
/*++

Copyright (c) 1989-1993 Microsoft Corporation

Module Name:

    spxquery.c

Abstract:

    This module contains code which performs the following TDI services:

        o   TdiQueryInformation

Author:

	Adam   Barr		 (adamba)  Initial Version
    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//  Discardable code after Init time
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, SpxQueryInitProviderInfo)
#endif

//	Define module number for event logging entries
#define	FILENUM		SPXQUERY

// Useful macro to obtain the total length of an MDL chain.
#define SpxGetMdlChainLength(Mdl, Length) { \
    PMDL _Mdl = (Mdl); \
    *(Length) = 0; \
    while (_Mdl) { \
        *(Length) += MmGetMdlByteCount(_Mdl); \
        _Mdl = _Mdl->Next; \
    } \
}



VOID
SpxQueryInitProviderInfo(
    PTDI_PROVIDER_INFO  ProviderInfo
    )
{
    //  Initialize to defaults first
    RtlZeroMemory((PVOID)ProviderInfo, sizeof(TDI_PROVIDER_INFO));

    ProviderInfo->Version 		= SPX_TDI_PROVIDERINFO_VERSION;
    KeQuerySystemTime (&ProviderInfo->StartTime);
    ProviderInfo->MinimumLookaheadData	= SPX_PINFOMINMAXLOOKAHEAD;
    ProviderInfo->MaximumLookaheadData	= IpxLineInfo.MaximumPacketSize;
    ProviderInfo->MaxSendSize 	= SPX_PINFOSENDSIZE;
    ProviderInfo->ServiceFlags 	= SPX_PINFOSERVICEFLAGS;
    return;
}




NTSTATUS
SpxTdiQueryInformation(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiQueryInformation request for the transport
    provider.

Arguments:

    Request - the request for the operation.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS 							status;
    PSPX_ADDR_FILE 						AddressFile;
    PSPX_CONN_FILE 						ConnectionFile;
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION 	query;
	struct {
        ULONG 			ActivityCount;
        TA_IPX_ADDRESS 	SpxAddress;
    } AddressInfo;



    // what type of status do we want?
    query = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)REQUEST_PARAMETERS(Request);

    switch (query->QueryType)
	{
	case TDI_QUERY_CONNECTION_INFO:

		status = STATUS_NOT_IMPLEMENTED;
		break;

    case TDI_QUERY_ADDRESS_INFO:

        // The caller wants the exact address value.

        ConnectionFile = (PSPX_CONN_FILE)REQUEST_OPEN_CONTEXT(Request);
        status = SpxConnFileVerify(ConnectionFile);

        if (status == STATUS_SUCCESS) {
            AddressFile = ConnectionFile->scf_AddrFile;
            SpxConnFileDereference(ConnectionFile, CFREF_VERIFY);
        } else {
            AddressFile = (PSPX_ADDR_FILE)REQUEST_OPEN_CONTEXT(Request);
        }

        status = SpxAddrFileVerify(AddressFile);

        if (status == STATUS_SUCCESS)
		{
			DBGPRINT(RECEIVE, INFO,
					("SpxTdiQuery: Net.Socket %lx.%lx\n",
						*(PULONG)Device->dev_Network,
						AddressFile->saf_Addr->sa_Socket));

            AddressInfo.ActivityCount = 0;
            (VOID)SpxBuildTdiAddress(
                &AddressInfo.SpxAddress,
                sizeof(TA_IPX_ADDRESS),
                Device->dev_Network,
                Device->dev_Node,
                AddressFile->saf_Addr->sa_Socket);

            status = TdiCopyBufferToMdl(
                &AddressInfo,
                0,
                sizeof(AddressInfo),
                REQUEST_NDIS_BUFFER(Request),
                0,
                (PULONG)&REQUEST_INFORMATION(Request));

            SpxAddrFileDereference(AddressFile, AFREF_VERIFY);

        }

        break;

    case TDI_QUERY_PROVIDER_INFO: {
        BYTE    socketType;
        TDI_PROVIDER_INFO  providerInfo = Device->dev_ProviderInfo;

        //
        // The device name extension comes down in the Irp
        //
    	if (!NT_SUCCESS(status = SpxUtilGetSocketType(
    								REQUEST_OPEN_NAME(Request),
    								&socketType))) {
            DBGPRINT(RECEIVE, ERR, ("TDI_QUERY_PROVIDER_INFO: SpxUtilGetSocketType failed: %lx\n", status));
    		return(status);
    	}

        //
        // The Catapult folks had a problem where AFD was discarding buffered sends on the NT box when it got a
        // local disconnect on SPX1. This was because the Orderly release flag was always set in the provider
        // info. AFD queries this once per device type. We detect the device above and OR in the orderly release
        // flag if this query came down on an SPX2 endpoint.
        // This is to make sure that AFD follows the correct disconnect semantics for SPX1 and SPX2 (SPX1 does
        // only abortive; SPX2 does both abortive and orderly).
        //
        // this will still not solve the problem completely since a connection that starts off as an SPX2
        // one can still be negotiated to SPX1 if the remote supports only SPX1.
        //
        if ((socketType == SOCKET2_TYPE_SEQPKT) ||
            (socketType == SOCKET2_TYPE_STREAM)) {

            DBGPRINT(RECEIVE, INFO, ("TDI_QUERY_PROVIDER_INFO: SPX2 socket\n"));
            providerInfo.ServiceFlags |= TDI_SERVICE_ORDERLY_RELEASE;
        } else {
            DBGPRINT(RECEIVE, INFO, ("TDI_QUERY_PROVIDER_INFO: SPX1 socket\n"));
        }

        status = TdiCopyBufferToMdl (
                    &providerInfo,
                    0,
                    sizeof (TDI_PROVIDER_INFO),
                    REQUEST_TDI_BUFFER(Request),
                    0,
                    (PULONG)&REQUEST_INFORMATION(Request));
        break;
    }

    case TDI_QUERY_PROVIDER_STATISTICS:

        status = TdiCopyBufferToMdl (
                    &Device->dev_Stat,
                    0,
                    FIELD_OFFSET (TDI_PROVIDER_STATISTICS, ResourceStats[0]),
                    REQUEST_TDI_BUFFER(Request),
                    0,
                    (PULONG)&REQUEST_INFORMATION(Request));
        break;

    default:
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return status;

} // SpxTdiQueryInformation



NTSTATUS
SpxTdiSetInformation(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiSetInformation request for the transport
    provider.

Arguments:

    Device - the device.

    Request - the request for the operation.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    UNREFERENCED_PARAMETER (Device);
    UNREFERENCED_PARAMETER (Request);

    return STATUS_NOT_IMPLEMENTED;

} // SpxTdiSetInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxrecv.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxrecv.h

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/

BOOLEAN
SpxReceive(
        IN  NDIS_HANDLE         MacBindingHandle,
        IN  NDIS_HANDLE         MacReceiveContext,
        IN  ULONG_PTR           FwdAdapterCtx,
        IN  PIPX_LOCAL_TARGET   RemoteAddress,
        IN  ULONG               MacOptions,
        IN  PUCHAR              LookaheadBuffer,
        IN  UINT                LookaheadBufferSize,
        IN  UINT                LookaheadBufferOffset,
        IN  UINT                PacketSize,
        IN  PMDL                pMdl);

VOID
SpxTransferDataComplete(
    IN  PNDIS_PACKET    pNdisPkt,
    IN  NDIS_STATUS     NdisStatus,
    IN  UINT            BytesTransferred);

VOID
SpxReceiveComplete(
    IN  USHORT  NicId);

VOID
SpxRecvDataPacket(
        IN  NDIS_HANDLE         MacBindingHandle,
        IN  NDIS_HANDLE         MacReceiveContext,
        IN  PIPX_LOCAL_TARGET   RemoteAddress,
        IN  ULONG               MacOptions,
        IN  PUCHAR              LookaheadBuffer,
        IN  UINT                LookaheadBufferSize,
        IN  UINT                LookaheadBufferOffset,
        IN  UINT                PacketSize);

VOID
SpxRecvDiscPacket(
    IN  PUCHAR              LookaheadBuffer,
	IN  PIPX_LOCAL_TARGET   pRemoteAddr,
    IN  UINT                LookaheadSize);

VOID
SpxRecvSysPacket(
        IN  NDIS_HANDLE         MacBindingHandle,
        IN  NDIS_HANDLE         MacReceiveContext,
        IN  PIPX_LOCAL_TARGET   pRemoteAddr,
        IN  ULONG               MacOptions,
        IN  PUCHAR              LookaheadBuffer,
        IN  UINT                LookaheadBufferSize,
        IN  UINT                LookaheadBufferOffset,
        IN  UINT                PacketSize);

VOID
SpxRecvFlushBytes(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	ULONG				BytesToFlush,
	IN	CTELockHandle		LockHandleConn);

VOID
SpxRecvProcessPkts(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	CTELockHandle		LockHandleConn);

BOOLEAN
SpxRecvIndicatePendingData(
	IN	PSPX_CONN_FILE		pSpxConnFile,
	IN	CTELockHandle		LockHandleConn);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxrecv.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxrecv.c

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:

    Sanjay Anand (SanjayAn) 5-July-1995
    Bug fixes - tagged [SA]

--*/

#include "precomp.h"
#pragma hdrstop

//      Define module number for event logging entries
#define FILENUM         SPXRECV

BOOLEAN
SpxReceive(
        IN  NDIS_HANDLE         MacBindingHandle,
        IN  NDIS_HANDLE         MacReceiveContext,
        IN  ULONG_PTR           FwdAdapterCtx,
        IN  PIPX_LOCAL_TARGET   RemoteAddress,
        IN  ULONG               MacOptions,
        IN  PUCHAR              LookaheadBuffer,
        IN  UINT                LookaheadBufferSize,
        IN  UINT                LookaheadBufferOffset,
        IN  UINT                PacketSize,
        IN  PMDL                pMdl
        )

{
        PIPXSPX_HDR                     pHdr;

        //      We have a separate routine to process SYS packets. DATA packets are
        //      processed within this routine.
        if (LookaheadBufferSize < MIN_IPXSPX_HDRSIZE)
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxReceive: Invalid length %lx\n", LookaheadBufferSize));

                return FALSE;
        }

    ++SpxDevice->dev_Stat.PacketsReceived;

        pHdr    = (PIPXSPX_HDR)LookaheadBuffer;
        if ((pHdr->hdr_ConnCtrl & SPX_CC_SYS) == 0)
        {
                //      Check for data packets
                if ((pHdr->hdr_DataType != SPX2_DT_ORDREL) &&
                        (pHdr->hdr_DataType != SPX2_DT_IDISC) &&
                        (pHdr->hdr_DataType != SPX2_DT_IDISC_ACK))
                {
                        //      HANDLE DATA PACKET
                        SpxRecvDataPacket(
                                MacBindingHandle,
                                MacReceiveContext,
                                RemoteAddress,
                                MacOptions,
                                LookaheadBuffer,
                                LookaheadBufferSize,
                                LookaheadBufferOffset,
                                PacketSize);
                }
                else
                {
                        //      The whole packet better be in the lookahead, else we ignore.
                        if (LookaheadBufferSize == PacketSize)
                        {
                                SpxRecvDiscPacket(
                                        LookaheadBuffer,
                                        RemoteAddress,
                                        LookaheadBufferSize);
                        }
                }
        }
        else
        {
                SpxRecvSysPacket(
                        MacBindingHandle,
                        MacReceiveContext,
                        RemoteAddress,
                        MacOptions,
                        LookaheadBuffer,
                        LookaheadBufferSize,
                        LookaheadBufferOffset,
                        PacketSize);
        }

        return FALSE;
}




VOID
SpxTransferDataComplete(
    IN  PNDIS_PACKET    pNdisPkt,
    IN  NDIS_STATUS     NdisStatus,
    IN  UINT            BytesTransferred
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
        PSPX_CONN_FILE          pSpxConnFile;
        PREQUEST                        pRequest;
        PSPX_RECV_RESD          pRecvResd;
        CTELockHandle           lockHandle;
        NTSTATUS                        status;
        BOOLEAN                         fAck, fEom, fBuffered, fImmedAck, fLockHeld;
        PNDIS_BUFFER            pNdisBuffer;

        DBGPRINT(RECEIVE, DBG,
                        ("SpxTransferData: For %lx with status %lx\n", pNdisPkt, NdisStatus));

        pRecvResd               = RECV_RESD(pNdisPkt);
        pSpxConnFile    = pRecvResd->rr_ConnFile;

        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
        fLockHeld = TRUE;

        fEom            = ((pRecvResd->rr_State & SPX_RECVPKT_EOM) != 0);
        fImmedAck       = ((pRecvResd->rr_State & SPX_RECVPKT_IMMEDACK) != 0);
        fBuffered       = ((pRecvResd->rr_State & SPX_RECVPKT_BUFFERING) != 0);
        fAck            = ((pRecvResd->rr_State & SPX_RECVPKT_SENDACK) != 0);

        //      Check if receive is done. If we remove the reference for this
        //      packet and it goes to zero, that means the receive was aborted.
        //      Move to the completion queue.
        //      If receive is filled up, then remove the creation reference
        //      i.e. just complete the receive at this point.
        //      There can be only one packet per receive, we dont support
        //      out of order reception.

        if (!fBuffered)
        {
                //      Get pointer to the buffer descriptor and its memory.
                NdisUnchainBufferAtFront(pNdisPkt, &pNdisBuffer);
                CTEAssert((pNdisBuffer != NULL) || (BytesTransferred == 0));

                //      BUG #11772
                //      On MP-machines scf_CurRecvReq could be set to NULL. Get the req
                //      from the recv packet.
                //      pRequest                = pSpxConnFile->scf_CurRecvReq;
                //      CTEAssert(pRequest == pRecvResd->rr_Request);
        pRequest = pRecvResd->rr_Request;

                //      Remove reference for this packet.
                --(REQUEST_INFORMATION(pRequest));

                if (NdisStatus == NDIS_STATUS_SUCCESS)
                {
                        pSpxConnFile->scf_CurRecvOffset += BytesTransferred;
                        pSpxConnFile->scf_CurRecvSize   -= BytesTransferred;

#if DBG
                        if ((pRecvResd->rr_State & SPX_RECVPKT_INDICATED) != 0)
                        {
                                if (BytesTransferred != 0)
                                {
                                        CTEAssert (pSpxConnFile->scf_IndBytes != 0);
                                        pSpxConnFile->scf_IndBytes      -= BytesTransferred;
                                }
                        }
#endif

                        if (REQUEST_INFORMATION(pRequest) == 0)
                        {
                                DBGPRINT(RECEIVE, DBG,
                                                ("SpxTransferDataComplete: Request %lx ref %lx Cur %lx.%lx\n",
                                                        pRequest, REQUEST_INFORMATION(pRequest),
                                                        REQUEST_STATUS(pRequest),
                                                        pSpxConnFile->scf_CurRecvSize));

                                if (SPX_CONN_STREAM(pSpxConnFile)                       ||
                                        (pSpxConnFile->scf_CurRecvSize == 0)    ||
                                        fEom                                                                    ||
                                        ((REQUEST_STATUS(pRequest) != STATUS_SUCCESS) &&
                                         (REQUEST_STATUS(pRequest) != STATUS_RECEIVE_PARTIAL)))
                                {
                                        CTELockHandle                                   lockHandleInter;

                                        //      We are done with this receive.
                                        REQUEST_INFORMATION(pRequest) = pSpxConnFile->scf_CurRecvOffset;

                                        status = STATUS_SUCCESS;
                                        if (!SPX_CONN_STREAM(pSpxConnFile) &&
                                                (pSpxConnFile->scf_CurRecvSize == 0) &&
                                                !fEom)
                                        {
                                                status = STATUS_RECEIVE_PARTIAL;
                                        }

                                        if ((REQUEST_STATUS(pRequest) != STATUS_SUCCESS) &&
                                                (REQUEST_STATUS(pRequest) != STATUS_RECEIVE_PARTIAL))
                                        {
                                                status = REQUEST_STATUS(pRequest);
                                        }

                                        REQUEST_STATUS(pRequest) = status;

                                        DBGPRINT(RECEIVE, DBG,
                                                        ("SpxTransferDataComplete: Request %lx ref %lx Cur %lx.%lx\n",
                                                                pRequest, REQUEST_INFORMATION(pRequest),
                                                                REQUEST_STATUS(pRequest),
                                                                pSpxConnFile->scf_CurRecvSize));

                                        //      Dequeue this request, Set next recv if one exists.
                                        SPX_CONN_SETNEXT_CUR_RECV(pSpxConnFile, pRequest);
                                        CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
                                        InsertTailList(
                                                &pSpxConnFile->scf_RecvDoneLinkage,
                                                REQUEST_LINKAGE(pRequest));

                                        SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                        CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                                }
                        }
                }

                if (pNdisBuffer != NULL)
                {
                        NdisFreeBuffer(pNdisBuffer);
                }
        }
        else
        {
                //      Buffered receive, queue it in if successful.
                //      BUG #18363
                //      IF WE DISCONNECTED in the meantime, we need to just dump this
                //      packet.
                if (SPX_CONN_ACTIVE(pSpxConnFile) &&
            (NdisStatus == NDIS_STATUS_SUCCESS))
                {
                        //      Queue packet in connection. Reference connection for this.
                        SpxConnQueueRecvPktTail(pSpxConnFile, pNdisPkt);
                        SpxConnFileLockReference(pSpxConnFile, CFREF_VERIFY);

                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxTransferData: Buffering: %lx Pkt %lx Size %lx F %lx\n",
                                        pSpxConnFile, pNdisPkt, BytesTransferred, pRecvResd->rr_State));

                        //      There could either be queued receives. (This could happen in
                        //      a partial receive case. Or if a receive got queued in while we
                        //      were processing this packet (Possible on MP)), or a packet was
                        //      buffered while we were completing some receives

                        CTEAssert(pSpxConnFile->scf_RecvListHead);

                        if ((pSpxConnFile->scf_CurRecvReq != NULL) ||
                                ((pSpxConnFile->scf_RecvListHead->rr_State &
                                                                                                SPX_RECVPKT_INDICATED) == 0))
                        {
                                CTELockHandle   interLockHandle;

                                //      Push this connection into a ProcessRecv queue which will be
                                //      dealt with in receive completion.

                                DBGPRINT(RECEIVE, DBG,
                                                ("spxRecvTransferData: Queueing for recvp %lx.%lx\n",
                                                        pSpxConnFile, pSpxConnFile->scf_Flags));

                                //      Get the global q lock, push into recv list.
                                CTEGetLock(&SpxGlobalQInterlock, &interLockHandle);
                                SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                CTEFreeLock(&SpxGlobalQInterlock, interLockHandle);
                        }
                }
                else
                {
                        PBYTE                                           pData;
                        ULONG                                           dataLen;

                        //      Get pointer to the buffer descriptor and its memory.
                        NdisUnchainBufferAtFront(pNdisPkt, &pNdisBuffer);
                        if (pNdisBuffer != NULL)
                        {
                                NdisQueryBuffer(pNdisBuffer, &pData, &dataLen);
                                CTEAssert(pData != NULL);
                                CTEAssert((LONG)dataLen >= 0);

                                //      Free the data, ndis buffer.
                                if (pNdisBuffer != NULL)
                                {
                                        NdisFreeBuffer(pNdisBuffer);
                                }
                                SpxFreeMemory(pData);
                        }

                        //      Dont send ack, set status to be failure so we free packet/buffer.
                        fAck = FALSE;
                        NdisStatus = NDIS_STATUS_FAILURE;
                }
        }

        END_PROCESS_PACKET(
                pSpxConnFile, fBuffered, (NdisStatus == NDIS_STATUS_SUCCESS));

        if (fAck)
        {
                //      Rem ack addr should have been copied in receive.

                //      #17564
                if (fImmedAck                                                                                     ||
                        SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_NOACKWAIT) ||
                        SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_IMMED_ACK))
                {
                        SpxConnSendAck(pSpxConnFile, lockHandle);
                        fLockHeld = FALSE;
                }
                else
                {
                        SpxConnQWaitAck(pSpxConnFile);
                }
        }

        if (fLockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
        }

        if (!fBuffered || (NdisStatus != STATUS_SUCCESS))
        {
                //      Free the ndis packet/buffer
                SpxPktRecvRelease(pNdisPkt);
        }

    return;
}




VOID
SpxReceiveComplete(
    IN  USHORT  NicId
    )

{
        CTELockHandle           lockHandleInter, lockHandle;
        PREQUEST                        pRequest;
        BOOLEAN                         fConnLockHeld, fInterlockHeld;
        PSPX_CONN_FILE          pSpxConnFile;
        int                                     numDerefs = 0;

        //      See if any connections need recv processing. This will also take
        //      care of any acks opening up window so our sends go to the max.
        CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
        fInterlockHeld = TRUE;

        while ((pSpxConnFile = SpxRecvConnList.pcl_Head) != NULL)
        {
                //      Reset for each connection
                numDerefs = 0;

                if ((SpxRecvConnList.pcl_Head = pSpxConnFile->scf_ProcessRecvNext) == NULL)
            SpxRecvConnList.pcl_Tail    = NULL;

                //      Reset next field to NULL
        pSpxConnFile->scf_ProcessRecvNext = NULL;

                DBGPRINT(SEND, DBG,
                                ("SpxConnRemoveFromRecv: %lx\n", pSpxConnFile));

                CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);

                do
                {
                        //      Complete pending requests.
                        while (!IsListEmpty(&pSpxConnFile->scf_ReqDoneLinkage))
                        {
                                pRequest =
                                        LIST_ENTRY_TO_REQUEST(pSpxConnFile->scf_ReqDoneLinkage.Flink);

                                RemoveEntryList(REQUEST_LINKAGE(pRequest));
                                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

                                DBGPRINT(TDI, DBG,
                                                ("SpxReceiveComplete: Completing %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

                                CTEAssert (REQUEST_MINOR_FUNCTION(pRequest) != TDI_RECEIVE);
                                SpxCompleteRequest(pRequest);
                                numDerefs++;
                                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                        }

                        //      Call process pkts if we have any packets or if any receives to
                        //      complete. Note this will call even when there are no receives
                        //      queued and the first packet has already been indicated.
                        if ((SPX_RECV_STATE(pSpxConnFile) != SPX_RECV_PROCESS_PKTS) &&
                                        (!IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage) ||
                                        (pSpxConnFile->scf_RecvListHead != NULL)))
                        {
                                //      We have the flag reference on the connection.
                                SpxRecvProcessPkts(pSpxConnFile, lockHandle);
                                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                        }

#if DBG
                        if (!IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage))
                        {
                                DBGPRINT(TDI, DBG,
                                                ("SpxReceiveComplete: RecvDone left %lx\n",
                                                        pSpxConnFile));
                        }
#endif

                //      Hmm. This check is rather expensive, and essentially we are doing
                //      it twice. Should look to see if this can be modified safely.
                } while ((!IsListEmpty(&pSpxConnFile->scf_ReqDoneLinkage))                      ||
                                 ((SPX_RECV_STATE(pSpxConnFile) != SPX_RECV_PROCESS_PKTS) &&
                                  ((!IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage))     ||
                                   ((pSpxConnFile->scf_RecvListHead != NULL) &&
                                   ((pSpxConnFile->scf_RecvListHead->rr_State &
                                        (SPX_RECVPKT_BUFFERING | SPX_RECVPKT_INDICATED)) ==
                                                SPX_RECVPKT_BUFFERING)))));

                SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_RECVQ);
                SpxConnFileTransferReference(
                        pSpxConnFile,
                        CFREF_RECV,
                        CFREF_VERIFY);

                numDerefs++;
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

                while (numDerefs-- > 0)
                {
                        SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
                }

                CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
        }


        //      First see if we need to packetize.
        while ((pSpxConnFile = SpxPktConnList.pcl_Head) != NULL)
        {
                if ((SpxPktConnList.pcl_Head = pSpxConnFile->scf_PktNext) == NULL)
            SpxPktConnList.pcl_Tail = NULL;

                //      Reset next field to NULL
        pSpxConnFile->scf_PktNext = NULL;

                CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);

                DBGPRINT(SEND, DBG,
                                ("SpxConnRemoveFromPkt: %lx\n", pSpxConnFile));

                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                fConnLockHeld = TRUE;

                DBGPRINT(RECEIVE, DBG,
                                ("SpxReceiveComplete: Packetizing %lx\n", pSpxConnFile));

                SPX_CONN_RESETFLAG(pSpxConnFile, SPX_CONNFILE_PKTQ);
                if (SPX_SEND_STATE(pSpxConnFile) == SPX_SEND_IDLE)
                {
                        SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_PACKETIZE);

			// 262691 SpxConnPacketize always frees the lock.
                        SpxConnPacketize(
                                        pSpxConnFile,
                                        TRUE,
                                        lockHandle);
                        fConnLockHeld = FALSE;
                }

                if (fConnLockHeld)
                {
                        CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
                }

                SpxConnFileDereference(pSpxConnFile, CFREF_PKTIZE);
                CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
        }

        if (fInterlockHeld)
        {
                CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
        }

    return;
}




//
//      PACKET HANDLING ROUTINES
//


VOID
SpxRecvSysPacket(
        IN  NDIS_HANDLE         MacBindingHandle,
        IN  NDIS_HANDLE         MacReceiveContext,
        IN  PIPX_LOCAL_TARGET   pRemoteAddr,
        IN  ULONG               MacOptions,
        IN  PUCHAR              LookaheadBuffer,
        IN  UINT                LookaheadBufferSize,
        IN  UINT                LookaheadBufferOffset,
        IN  UINT                PacketSize
        )
/*++

Routine Description:

        This is called to indicate an incoming system packet.

Arguments:


Return Value:


--*/

{
        NTSTATUS                        status;
        PIPXSPX_HDR                     pHdr;
        USHORT                          srcConnId, destConnId,
                                                pktLen, ackNum, allocNum;
        PSPX_CONN_FILE          pSpxConnFile;
        CTELockHandle           lockHandle;
        BOOLEAN                         lockHeld = FALSE;

        pHdr    = (PIPXSPX_HDR)LookaheadBuffer;

        //      check minimum length
        if (PacketSize < MIN_IPXSPX_HDRSIZE)
        {
                return;
        }

        //      Convert hdr to host format as needed.
        GETSHORT2SHORT(&pktLen, &pHdr->hdr_PktLen);
        GETSHORT2SHORT(&destConnId, &pHdr->hdr_DestConnId);

        if ((pktLen < MIN_IPXSPX_HDRSIZE)       ||
                (pktLen > PacketSize)                   ||
                (pHdr->hdr_PktType != SPX_PKT_TYPE))
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxRecvSysPacket: Packet Size %lx.%lx\n",
                                        pktLen, PacketSize));

                return;
        }

        if ((pktLen == SPX_CR_PKTLEN) &&
                (destConnId == 0xFFFF) &&
                (pHdr->hdr_ConnCtrl & SPX_CC_CR))
        {
                spxConnHandleConnReq(
                        pHdr,
                        pRemoteAddr);

                return;
        }

        //
        // [SA] Bug #14917
        // Some SPX SYS packets (no extended ack field) may come in with the SPX2 bit set.
        // Make sure we don't discard these packets.
        //

        // if ((pHdr->hdr_ConnCtrl & SPX_CC_SPX2) && (pktLen < MIN_IPXSPX2_HDRSIZE))
        // {
        //         return;
        // }

        GETSHORT2SHORT(&ackNum, &pHdr->hdr_AckNum);
        GETSHORT2SHORT(&allocNum, &pHdr->hdr_AllocNum);

        //      We keep and use the remote id in the net format. This maintains the
        //      0x0 and 0xFFFF to be as in the host format.
        srcConnId       = *(USHORT UNALIGNED *)&pHdr->hdr_SrcConnId;

        if ((srcConnId == 0) || (srcConnId == 0xFFFF) || (destConnId == 0))
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxConnSysPacket: Incorrect conn id %lx.%lx\n",
                                        srcConnId, destConnId));

                return;
        }

        DBGPRINT(CONNECT, DBG,
                        ("SpxConnSysPacket: packet received dest %lx src %lx\n",
                                pHdr->hdr_DestSkt, pHdr->hdr_SrcSkt));

        //      Find the connection this is destined for and reference it.
        SpxConnFileReferenceById(destConnId, &pSpxConnFile, &status);
        if (!NT_SUCCESS(status))
        {
                DBGPRINT(RECEIVE, WARN,
                                ("SpxConnSysPacket: Id %lx NOT FOUND\n", destConnId));
                return;
        }

        do
        {

                DBGPRINT(RECEIVE, INFO,
                                ("SpxConnSysPacket: Id %lx Conn %lx\n",
                                        destConnId, pSpxConnFile));

                //      This could be one of many packets. Connection ack/Session negotiate/
                //      Session setup, Data Ack, Probe/Ack, Renegotiate/Ack. We shunt
                //      off all the packets to different routines but process the data
                //      ack packets here.
                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
               //
               // We have the connection.  We should update the dest. sock # in
               // it in case it changed.  Unix machines do do that sometimes.
               // SCO bug 7676
               //
                SpxCopyIpxAddr(pHdr, pSpxConnFile->scf_RemAddr);

                lockHeld = TRUE;

                //      Restart watchdog timer if started.
                if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER))
                {
                        //      This will either successfully restart or not affect the timer
                        //      if it is currently running.
                        SpxTimerCancelEvent(
                                pSpxConnFile->scf_WTimerId,
                                TRUE);

                        pSpxConnFile->scf_WRetryCount   = PARAM(CONFIG_KEEPALIVE_COUNT);
                }

                switch (SPX_MAIN_STATE(pSpxConnFile))
                {
                case SPX_CONNFILE_CONNECTING:

                        CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
                        lockHeld = FALSE;

                        spxConnHandleSessPktFromSrv(
                                pHdr,
                                pRemoteAddr,
                                pSpxConnFile);

                        break;

                case SPX_CONNFILE_LISTENING:

                        CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
                        lockHeld = FALSE;

                        spxConnHandleSessPktFromClient(
                                pHdr,
                                pRemoteAddr,
                                pSpxConnFile);

                        break;

                case SPX_CONNFILE_ACTIVE:
                case SPX_CONNFILE_DISCONN:

                        //      NOTE:   Our ack to a session setup might get dropped.
                        //                      But the SS Ack is similar to a normal SPX2 ack.
                        //                      We dont have to do anything special.

                        //      Received ack/nack/reneg/reneg ack/disc associated packet.
                        //      Disc packets except ordrel ack have non-zero datastream type.
                        if ((pHdr->hdr_ConnCtrl &
                                        (SPX_CC_SYS | SPX_CC_ACK | SPX_CC_NEG | SPX_CC_SPX2)) ==
                    (SPX_CC_SYS | SPX_CC_ACK | SPX_CC_NEG | SPX_CC_SPX2))
                        {
                                //      We received a renegotiate packet. Ignore all ack values
                                //      in a reneg req.
                                SpxConnProcessRenegReq(pSpxConnFile, pHdr, pRemoteAddr, lockHandle);
                                lockHeld = FALSE;
                                break;
                        }

                        //      Set ack numbers for connection.
            SPX_SET_ACKNUM(
                                pSpxConnFile, ackNum, allocNum);

                        //      Check if we are an ack/nack packet in which case call process
                        //      ack. Note that the spx2 orderly release ack is a normal spx2 ack.
                        if (((pHdr->hdr_ConnCtrl & SPX_CC_ACK) == 0) &&
                                (pHdr->hdr_DataType == 0))
                        {
                                SpxConnProcessAck(pSpxConnFile, pHdr, lockHandle);
                                lockHeld = FALSE;
                        }
                        else
                        {
                                //      Just process the numbers we got.
                                SpxConnProcessAck(pSpxConnFile, NULL, lockHandle);
                                lockHeld = FALSE;
                        }

                        //      If the remote wants us to send an ack, do it.
                        if (pHdr->hdr_ConnCtrl & SPX_CC_ACK)
                        {
                                //      First copy the remote address in connection.
                                SpxCopyIpxAddr(pHdr, pSpxConnFile->scf_RemAckAddr);
                                pSpxConnFile->scf_AckLocalTarget        = *pRemoteAddr;

                                if (!lockHeld)
                                {
                                        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                                        lockHeld = TRUE;
                                }

                                SpxConnSendAck(pSpxConnFile, lockHandle);
                                lockHeld = FALSE;
                                break;
                        }

                        break;

                default:

                        //      Ignore this packet.
                        DBGPRINT(RECEIVE, WARN,
                                        ("SpxConnSysPacket: Ignoring packet, state is not active\n"));
                        break;
                }

        } while (FALSE);

        if (lockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
        }

        //      Remove reference added on connection
        SpxConnFileDereference(pSpxConnFile, CFREF_BYID);
        return;
}




VOID
SpxRecvDiscPacket(
    IN  PUCHAR              LookaheadBuffer,
        IN  PIPX_LOCAL_TARGET   pRemoteAddr,
    IN  UINT                LookaheadSize
    )
/*++

Routine Description:

        This is called to indicate an incoming connection.

Arguments:


Return Value:


--*/
{
        NTSTATUS                                status;
        PIPXSPX_HDR                             pHdr;
        USHORT                                  srcConnId, destConnId,
                                                        pktLen, seqNum, ackNum, allocNum;
        PSPX_CONN_FILE                  pSpxConnFile;
        CTELockHandle                   lockHandle;
        BOOLEAN                                 lockHeld;

        pHdr    = (PIPXSPX_HDR)LookaheadBuffer;

        //      check minimum length
        if (LookaheadSize < MIN_IPXSPX_HDRSIZE)
        {
                return;
        }

        //      Convert hdr to host format as needed.
        GETSHORT2SHORT(&pktLen, &pHdr->hdr_PktLen);
        GETSHORT2SHORT(&destConnId, &pHdr->hdr_DestConnId);
        GETSHORT2SHORT(&seqNum, &pHdr->hdr_SeqNum);
        GETSHORT2SHORT(&ackNum, &pHdr->hdr_AckNum);
        GETSHORT2SHORT(&allocNum, &pHdr->hdr_AllocNum);

        if ((pktLen < MIN_IPXSPX_HDRSIZE)       ||
                (pHdr->hdr_PktType != SPX_PKT_TYPE))
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxRecvDiscPacket: Packet Size %lx\n",
                                        pktLen));

                return;
        }

        //      We keep and use the remote id in the net format. This maintains the
        //      0x0 and 0xFFFF to be as in the host format.
        srcConnId       = *(USHORT UNALIGNED *)&pHdr->hdr_SrcConnId;
        if ((srcConnId == 0) || (srcConnId == 0xFFFF) || (destConnId == 0))
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxConnDiscPacket: Incorrect conn id %lx.%lx\n",
                                        srcConnId, destConnId));

                return;
        }

        DBGPRINT(CONNECT, DBG,
                        ("SpxConnDiscPacket: packet received dest %lx src %lx\n",
                                pHdr->hdr_DestSkt, pHdr->hdr_SrcSkt));

        //      Find the connection this is destined for and reference it.
        SpxConnFileReferenceById(destConnId, &pSpxConnFile, &status);
        if (!NT_SUCCESS(status))
        {
                DBGPRINT(RECEIVE, WARN,
                                ("SpxConnDiscPacket: Id %lx NOT FOUND", destConnId));

                return;
        }

        do
        {
                DBGPRINT(RECEIVE, INFO,
                                ("SpxConnDiscPacket: Id %lx Conn %lx DiscType %lx\n",
                                        destConnId, pSpxConnFile, pHdr->hdr_DataType));

                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                lockHeld = TRUE;

                //      Unless we are in the active/disconnecting, but send state = idle
                //      and recv state = idle/recv posted, we ignore all disconnect packets.
                if (((SPX_MAIN_STATE(pSpxConnFile) != SPX_CONNFILE_ACTIVE)      &&
                         (SPX_MAIN_STATE(pSpxConnFile) != SPX_CONNFILE_DISCONN))        ||
                        ((SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_IDLE)                &&
                         (SPX_SEND_STATE(pSpxConnFile) != SPX_SEND_PACKETIZE))          ||
                        ((SPX_RECV_STATE(pSpxConnFile) != SPX_RECV_IDLE)                &&
                         (SPX_RECV_STATE(pSpxConnFile) != SPX_RECV_POSTED))             ||
                        !(IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage))                      ||
                        (SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_PKT)))
                {
                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxConnDiscPacket: %lx, %lx, %lx.%lx, %d.%d\n",
                    pSpxConnFile,
                                        SPX_MAIN_STATE(pSpxConnFile),
                                        SPX_SEND_STATE(pSpxConnFile), SPX_RECV_STATE(pSpxConnFile),
                    (IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage)),
                    (SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_PKT))));

                        break;
                }

                //      If we have received a disconnect, process received ack to complete any
                //      pending sends before we allow the disconnect. This ack number will be
                //      the last word on this session.
                SPX_SET_ACKNUM(
                        pSpxConnFile, ackNum, allocNum);

                SpxConnProcessAck(pSpxConnFile, NULL, lockHandle);
                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);

                switch (pHdr->hdr_DataType)
                {
        case SPX2_DT_ORDREL:

                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxConnDiscPacket: Recd ORDREl!\n"));

                        //      Need to deal with all sthe states.
                        //      Restart watchdog timer if started.
                        if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER))
                        {
                                //      This will either successfully restart or not affect the timer
                                //      if it is currently running.
                                SpxTimerCancelEvent(
                                        pSpxConnFile->scf_WTimerId,
                                        TRUE);

                                pSpxConnFile->scf_WRetryCount   = PARAM(CONFIG_KEEPALIVE_COUNT);
                        }

                        //      On receive, we do check the seq num for the orderly release, just
                        //      like for a data packet.
                        //      If this was not already indicated, indicate it now. That is all
                        //      we do for an orderly release. When our client does a orderly rel
                        //      and we receive the ack for that, call abortive with success.

                        //      Verify ord rel packet, this checks if seq nums match also.
                        if ((pktLen  != MIN_IPXSPX2_HDRSIZE) ||
                                ((pHdr->hdr_ConnCtrl &
                                        (SPX_CC_ACK | SPX_CC_EOM | SPX_CC_SPX2)) !=
                                                (SPX_CC_ACK | SPX_CC_EOM | SPX_CC_SPX2)) ||
                                (pHdr->hdr_DataType != SPX2_DT_ORDREL) ||
                                (srcConnId == 0) ||
                                (srcConnId == 0xFFFF) ||
                                (srcConnId  != pSpxConnFile->scf_RemConnId) ||
                                (destConnId == 0) ||
                                (destConnId == 0xFFFF) ||
                                (destConnId != pSpxConnFile->scf_LocalConnId))
                        {
                                DBGPRINT(CONNECT, DBG1,
                                                ("SpxConnDiscPacket: OR Failed/Ignored %lx, %lx.%lx.%lx\n",
                                                pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum,
                                                pSpxConnFile->scf_RecvListTail));

                                break;
                        }

                        //      If it passed above test, but seq number is incorrect, schedule
                        //      to send an ack.
                        if (seqNum != pSpxConnFile->scf_RecvSeqNum)
                        {
                                USHORT  NumToResend;

                                DBGPRINT(CONNECT, DBG,
                                                ("SpxConnDiscPacket: Unexpected seq on %lx, %lx.%lx\n",
                                                        pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum));

                                //      Calculate number to be resent. If we expect sequence 1 and receive
                                //      2 for eg., we need to send a nack, else we send an ack.
                                if (SPX2_CONN(pSpxConnFile) &&
                                        UNSIGNED_GREATER_WITH_WRAP(
                                                seqNum,
                                                pSpxConnFile->scf_RecvSeqNum) &&
                                        !UNSIGNED_GREATER_WITH_WRAP(
                                                seqNum,
                                                pSpxConnFile->scf_SentAllocNum))
                                {
                                        NumToResend = (USHORT)(seqNum - pSpxConnFile->scf_RecvSeqNum + 1);
                                        SpxConnSendNack(pSpxConnFile, NumToResend, lockHandle);
                                        lockHeld = FALSE;
                                }

                                break;
                        }

                        //      Copy address for when ack is to be sent.
                        SpxCopyIpxAddr(pHdr, pSpxConnFile->scf_RemAckAddr);
                        pSpxConnFile->scf_AckLocalTarget        = *pRemoteAddr;

                        if (pSpxConnFile->scf_RecvListHead == NULL)
                        {
                                //      No received data, go ahead and process now.
                                DBGPRINT(CONNECT, INFO,
                                                ("SpxConnDiscPacket: NO DATA ORDREL %lx.%lx.%lx\n",
                                                        pSpxConnFile,
                                                        pSpxConnFile->scf_RecvListHead,
                                                        pSpxConnFile->scf_SendSeqListHead));

                                SpxConnProcessOrdRel(pSpxConnFile, lockHandle);
                                lockHeld = FALSE;
                        }
                        else
                        {
                                //      No received data, go ahead and process now.
                                DBGPRINT(CONNECT, DBG1,
                                                ("SpxConnDiscPacket: DATA ORDREL %lx.%lx.%lx\n",
                                                        pSpxConnFile,
                                                        pSpxConnFile->scf_RecvListHead,
                                                        pSpxConnFile->scf_SendSeqListHead));

                                //      Set flag in last recd buffer
                pSpxConnFile->scf_RecvListTail->rr_State |= SPX_RECVPKT_ORD_DISC;
                        }

                        break;

        case SPX2_DT_IDISC:

                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxConnDiscPacket: %lx Recd IDISC %lx!\n",
                                                pSpxConnFile, pSpxConnFile->scf_RefCount));

                        DBGPRINT(RECEIVE, INFO,
                                        ("SpxConnDiscPacket: SEND %d. RECV %d.%lx!\n",
                                                IsListEmpty(&pSpxConnFile->scf_ReqLinkage),
                                                IsListEmpty(&pSpxConnFile->scf_RecvLinkage),
                                                pSpxConnFile->scf_RecvDoneLinkage));

                        if (!((pktLen  == MIN_IPXSPX_HDRSIZE) ||
                                        ((pHdr->hdr_ConnCtrl & SPX_CC_SPX2) &&
                                         (pktLen  == MIN_IPXSPX2_HDRSIZE))) ||
                                !(pHdr->hdr_ConnCtrl & SPX_CC_ACK) ||
                                (pHdr->hdr_DataType != SPX2_DT_IDISC) ||
                                (srcConnId == 0) ||
                                (srcConnId == 0xFFFF) ||
                                (srcConnId  != pSpxConnFile->scf_RemConnId) ||
                                (destConnId == 0) ||
                                (destConnId == 0xFFFF) ||
                                (destConnId != pSpxConnFile->scf_LocalConnId))
                        {
                                DBGPRINT(CONNECT, ERR,
                                                ("SpxConnDiscPacket:IDISC Ignored %lx.%lx.%lx.%lx\n",
                                                        pSpxConnFile, seqNum,
                                                        pSpxConnFile->scf_RecvSeqNum,
                                                        pSpxConnFile->scf_RecvListTail));
                                break;
                        }

                        //      Copy address for when ack is to be sent.
                        SpxCopyIpxAddr(pHdr, pSpxConnFile->scf_RemAckAddr);
                        pSpxConnFile->scf_AckLocalTarget        = *pRemoteAddr;

                        if (pSpxConnFile->scf_RecvListHead == NULL)
                        {
                                //      No received data, go ahead and process now.
                                DBGPRINT(CONNECT, INFO,
                                                ("SpxConnDiscPacket: NO RECV DATA IDISC %lx.%lx.%lx\n",
                                                        pSpxConnFile,
                                                        pSpxConnFile->scf_RecvListHead,
                                                        pSpxConnFile->scf_SendSeqListHead));

                                SpxConnProcessIDisc(pSpxConnFile, lockHandle);

                                lockHeld = FALSE;
                        }
                        else
                        {
                                //      Set flag in last recd buffer

                pSpxConnFile->scf_RecvListTail->rr_State |= SPX_RECVPKT_IDISC;
                        }

                        break;

        case SPX2_DT_IDISC_ACK:

                        //      Done with informed disconnect. Call abort connection with
                        //      status success. That completes the pending disconnect request
                        //      with status_success.

                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxConnDiscPacket: %lx Recd IDISC ack!\n", pSpxConnFile));

                        if (!((pktLen == MIN_IPXSPX_HDRSIZE) ||
                                        ((pHdr->hdr_ConnCtrl & SPX_CC_SPX2) &&
                                         (pktLen  == MIN_IPXSPX2_HDRSIZE))) ||
                                (pHdr->hdr_DataType != SPX2_DT_IDISC_ACK) ||
                                (srcConnId == 0) ||
                                (srcConnId == 0xFFFF) ||
                                (srcConnId  != pSpxConnFile->scf_RemConnId) ||
                                (destConnId == 0) ||
                                (destConnId == 0xFFFF) ||
                                (destConnId != pSpxConnFile->scf_LocalConnId))
                        {
                                DBGPRINT(CONNECT, ERR,
                                                ("SpxConnDiscPacket:Ver idisc ack Failed %lx, %lx.%lx\n",
                                                        pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum));
                                break;
                        }

                        //      We should be in the right state to accept this.
                        if ((SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_DISCONN) &&
                                (SPX_DISC_STATE(pSpxConnFile) == SPX_DISC_SENT_IDISC))
                        {
                                spxConnAbortiveDisc(
                                        pSpxConnFile,
                                        STATUS_SUCCESS,
                                        SPX_CALL_RECVLEVEL,
                                        lockHandle,
                                        FALSE);     // [SA] bug #15249

                                lockHeld = FALSE;
                        }

                        break;

                default:

                        KeBugCheck(0);
                }


        } while (FALSE);

        if (lockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
        }

        //      Remove reference added on connection
        SpxConnFileDereference(pSpxConnFile, CFREF_BYID);
        return;
}




VOID
SpxRecvBufferPkt(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN  NDIS_HANDLE         MacBindingHandle,
        IN  NDIS_HANDLE         MacReceiveContext,
        IN  UINT                LookaheadOffset,
        IN      PIPXSPX_HDR                     pIpxSpxHdr,
        IN  UINT                PacketSize,
        IN  PIPX_LOCAL_TARGET   pRemoteAddr,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:

        This is called to indicate an incoming connection.

Arguments:


Return Value:


--*/
{
        PNDIS_PACKET    pNdisPkt;
        PSPX_RECV_RESD  pRecvResd;
        ULONG                   bytesCopied;
        BOOLEAN                 fEom;
        NDIS_STATUS             ndisStatus = NDIS_STATUS_SUCCESS;
        PBYTE                   pData = NULL;
        PNDIS_BUFFER    pNdisBuffer = NULL;

        if (PacketSize > 0)
        {
                //      Allocate memory for this data.
                if (pData = (PBYTE)SpxAllocateMemory(PacketSize))
                {
                        //      Describe memory with a ndis buffer descriptor.
                        NdisAllocateBuffer(
                                &ndisStatus,
                                &pNdisBuffer,
                                SpxDevice->dev_NdisBufferPoolHandle,
                                pData,
                                PacketSize);
                }
                else
                {
                        ndisStatus = NDIS_STATUS_RESOURCES;
                }
        }

        if (ndisStatus == NDIS_STATUS_SUCCESS)
        {
                //      Allocate a ndis receive packet.
                SpxAllocRecvPacket(SpxDevice, &pNdisPkt, &ndisStatus);
                if (ndisStatus == NDIS_STATUS_SUCCESS)
                {
                        //      Queue the buffer into the packet if there is one.
                        if (pNdisBuffer)
                        {
                                NdisChainBufferAtBack(
                                        pNdisPkt,
                                        pNdisBuffer);
                        }

                        fEom            = ((SPX_CONN_MSG(pSpxConnFile) &&
                                                   (pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_EOM)) ||
                                                   SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_IPXHDR));

                        pRecvResd                               = RECV_RESD(pNdisPkt);
                        pRecvResd->rr_DataOffset= 0;

#if DBG
                        //      Store seq number
                        GETSHORT2SHORT(&pRecvResd->rr_SeqNum , &pIpxSpxHdr->hdr_SeqNum);
#endif

                        pRecvResd->rr_State             =
                                (SPX_RECVPKT_BUFFERING |
                                (SPX_CONN_FLAG2(
                                        pSpxConnFile, SPX_CONNFILE2_PKT_NOIND) ? SPX_RECVPKT_INDICATED : 0) |
                                (fEom ? SPX_RECVPKT_EOM : 0) |
                                ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_ACK) ? SPX_RECVPKT_SENDACK : 0));

                        if (pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_ACK)
                        {
                                //      copy the remote address in connection.
                                SpxCopyIpxAddr(pIpxSpxHdr, pSpxConnFile->scf_RemAckAddr);
                                pSpxConnFile->scf_AckLocalTarget        = *pRemoteAddr;
                        }

                        pRecvResd->rr_Request   = NULL;
                        pRecvResd->rr_ConnFile  = pSpxConnFile;

                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxRecvBufferPkt: %lx Len %lx DataPts %lx F %lx\n",
                                                pSpxConnFile, PacketSize, pData, pRecvResd->rr_State));

                        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

                        //      Call ndis transfer data. Copy ENTIRE packet. copySize has
                        //      been modified so use original values.
                        ndisStatus      = NDIS_STATUS_SUCCESS;
                        bytesCopied = 0;
                        if (PacketSize > 0)
                        {
                                (*IpxTransferData)(
                                        &ndisStatus,
                                        MacBindingHandle,
                                        MacReceiveContext,
                                        LookaheadOffset,
                                        PacketSize,
                                        pNdisPkt,
                                        &bytesCopied);
                        }

                        if (ndisStatus != STATUS_PENDING)
                        {
                                SpxTransferDataComplete(
                                        pNdisPkt,
                                        ndisStatus,
                                        bytesCopied);
                        }

                        //      BUG: FDDI returns pending which messes us up here. 
                        ndisStatus      = NDIS_STATUS_SUCCESS;
                }
        }

        //      ASSERT: Lock will be freed in the success case.
        if (ndisStatus != NDIS_STATUS_SUCCESS)
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxRecvBufferPkt: FAILED!\n"));

                END_PROCESS_PACKET(pSpxConnFile, FALSE, FALSE);
                CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

                if (pData != NULL)
                {
                        SpxFreeMemory(pData);
                }

                if (pNdisBuffer != NULL)
                {
                        NdisFreeBuffer(pNdisBuffer);
                }
        }

        return;
}




VOID
SpxRecvDataPacket(
        IN  NDIS_HANDLE         MacBindingHandle,
        IN  NDIS_HANDLE         MacReceiveContext,
        IN  PIPX_LOCAL_TARGET   RemoteAddress,
        IN  ULONG               MacOptions,
        IN  PUCHAR              LookaheadBuffer,
        IN  UINT                LookaheadSize,
        IN  UINT                LookaheadOffset,
        IN  UINT                PacketSize
        )
/*++

Routine Description:

        This is called to indicate an incoming connection.

Arguments:


Return Value:


--*/

{
        NTSTATUS                        status;
        PIPXSPX_HDR                     pIpxSpxHdr;
        USHORT                          srcConnId, destConnId,
                                                pktLen, seqNum, ackNum, allocNum;
        ULONG                           receiveFlags;
        PSPX_CONN_FILE          pSpxConnFile;
        PTDI_IND_RECEIVE        pRecvHandler;
        PVOID                           pRecvCtx;
        PIRP                            pRecvIrp;
        ULONG                           bytesTaken, iOffset, copySize, bytesCopied;
        CTELockHandle           lockHandle;
        PNDIS_PACKET            pNdisPkt;
        PNDIS_BUFFER            pNdisBuffer;
        PSPX_RECV_RESD          pRecvResd;
        NDIS_STATUS                     ndisStatus;
        PREQUEST                        pRequest = NULL;
        BOOLEAN                         fEom,
                                                fImmedAck = FALSE, fLockHeld = FALSE, fPktDone = FALSE;

        pIpxSpxHdr      = (PIPXSPX_HDR)LookaheadBuffer;

        //      check minimum length
        if (PacketSize < MIN_IPXSPX_HDRSIZE)
        {
                return;
        }

        //      Convert hdr to host format as needed.
        GETSHORT2SHORT(&pktLen, &pIpxSpxHdr->hdr_PktLen);
        GETSHORT2SHORT(&destConnId, &pIpxSpxHdr->hdr_DestConnId);
        GETSHORT2SHORT(&seqNum, &pIpxSpxHdr->hdr_SeqNum);
        GETSHORT2SHORT(&allocNum, &pIpxSpxHdr->hdr_AllocNum);
        GETSHORT2SHORT(&ackNum, &pIpxSpxHdr->hdr_AckNum);

        if ((pktLen < MIN_IPXSPX_HDRSIZE)       ||
                (pktLen > PacketSize)                   ||
                (pIpxSpxHdr->hdr_PktType != SPX_PKT_TYPE))
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxConnDataPacket: Packet Size %lx.%lx\n",
                                        pktLen, PacketSize));

                return;
        }

        //      We keep and use the remote id in the net format.
        srcConnId       = *(USHORT UNALIGNED *)&pIpxSpxHdr->hdr_SrcConnId;

        if ((srcConnId == 0) || (srcConnId == 0xFFFF) || (destConnId == 0))
        {
                DBGPRINT(RECEIVE, ERR,
                                ("SpxConnDataPacket: Incorrect conn id %lx.%lx\n",
                                        srcConnId, destConnId));

                return;
        }

        DBGPRINT(CONNECT, DBG,
                        ("SpxConnDataPacket: packet received dest %lx src %lx seq %lx\n",
                                pIpxSpxHdr->hdr_DestSkt, pIpxSpxHdr->hdr_SrcSkt, seqNum));

        if ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_SPX2) &&
                (pktLen < MIN_IPXSPX2_HDRSIZE))
        {
                return;
        }

        //      Find the connection this is destined for and reference it.
        SpxConnFileReferenceById(destConnId, &pSpxConnFile, &status);
        if (!NT_SUCCESS(status))
        {
                DBGPRINT(RECEIVE, WARN,
                                ("SpxConnDataPacket: Id %lx NOT FOUND", destConnId));
                return;
        }
        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);

#if 0
        //
        // We have the connection.  We should update the dest. sock # in
        // it in case it changed.  Unix machines do do that sometimes.
        // SCO bug 7676
        //
        SpxCopyIpxAddr(pIpxSpxHdr, pSpxConnFile->scf_RemAddr);
#endif

        fLockHeld = TRUE;
        do
        {
                DBGPRINT(RECEIVE, INFO,
                                ("SpxConnDataPacket: Id %lx Conn %lx\n",
                                        destConnId, pSpxConnFile));

                //      Restart watchdog timer if started.
                if (SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_W_TIMER))
                {
                        //      This will either successfully restart or not affect the timer
                        //      if it is currently running.
                        SpxTimerCancelEvent(
                                pSpxConnFile->scf_WTimerId,
                                TRUE);

                        pSpxConnFile->scf_WRetryCount   = PARAM(CONFIG_KEEPALIVE_COUNT);
                }

                if (SPX_CONN_ACTIVE(pSpxConnFile))
                {
                        //      Verify data packet, this checks if seq nums match also.
                        if ((pIpxSpxHdr->hdr_SrcConnId != pSpxConnFile->scf_RemConnId) ||
                                (destConnId != pSpxConnFile->scf_LocalConnId) ||
                                !((pktLen  >= MIN_IPXSPX_HDRSIZE) ||
                                        ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_SPX2) &&
                                         (pktLen  >= MIN_IPXSPX2_HDRSIZE))))
                        {
                                DBGPRINT(CONNECT, DBG,
                                                ("SpxConnDataPacket: Failed %lx, %lx.%lx\n",
                                                        pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum));

                                break;
                        }

                        //      If it passed above test, but seq number is incorrect, schedule
                        //      to send an ack.
                        if (seqNum != pSpxConnFile->scf_RecvSeqNum)
                        {
                                USHORT  NumToResend;

                                DBGPRINT(CONNECT, DBG,
                                                ("SpxConnDataPacket: Unexpected seq on %lx, %lx.%lx\n",
                                                        pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum));

                ++SpxDevice->dev_Stat.DataFramesRejected;
                ExInterlockedAddLargeStatistic(
                    &SpxDevice->dev_Stat.DataFrameBytesRejected,
                    pktLen - (SPX2_CONN(pSpxConnFile) ?
                                                                        MIN_IPXSPX2_HDRSIZE : MIN_IPXSPX_HDRSIZE));

                                //
                                // Bug #16975: Set the remote ack addr for use in SpxConnSendAck()
                                //
                                SpxCopyIpxAddr(pIpxSpxHdr, pSpxConnFile->scf_RemAckAddr);
                                pSpxConnFile->scf_AckLocalTarget        = *RemoteAddress;

                                //      Calculate number to be resent. If we expect sequence 1 and receive
                                //      2 for eg., we need to send a nack, else we send an ack.
                                if (SPX2_CONN(pSpxConnFile) &&
                                        UNSIGNED_GREATER_WITH_WRAP(
                                                seqNum,
                                                pSpxConnFile->scf_RecvSeqNum) &&
                                        !UNSIGNED_GREATER_WITH_WRAP(
                                                seqNum,
                                                pSpxConnFile->scf_SentAllocNum))
                                {
                                        NumToResend = (USHORT)(seqNum - pSpxConnFile->scf_RecvSeqNum + 1);
                                        SpxConnSendNack(pSpxConnFile, NumToResend, lockHandle);
                                        fLockHeld = FALSE;
                                }
                                else
                                {
                                        SpxConnSendAck(pSpxConnFile, lockHandle);
                                        fLockHeld = FALSE;
                                }

                                break;
                        }

                        //      If we have received an orderly release, we accept no more data
                        //      packets.
                        if (SPX_CONN_FLAG(
                                        pSpxConnFile,
                    (SPX_CONNFILE_IND_IDISC |
                     SPX_CONNFILE_IND_ODISC))

                                ||

                                ((pSpxConnFile->scf_RecvListTail != NULL) &&
                 ((pSpxConnFile->scf_RecvListTail->rr_State &
                                                SPX_RECVPKT_DISCMASK) != 0)))
                        {
                                DBGPRINT(CONNECT, ERR,
                                                ("SpxConnDataPacket: After ord rel %lx, %lx.%lx\n",
                                                        pSpxConnFile, seqNum, pSpxConnFile->scf_RecvSeqNum));

                                break;
                        }

                        //      We are processing a packet OR a receive is about to complete.
                        if (!SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_PKT))
                        {
                BEGIN_PROCESS_PACKET(pSpxConnFile, seqNum);
                        }
                        else
                        {
                                //      Already processing a packet. Or a receive is waiting to
                                //      complete. Get out.
                                break;
                        }

                        //      Set ack numbers for connection.
            SPX_SET_ACKNUM(
                                pSpxConnFile, ackNum, allocNum);

                        SpxConnProcessAck(pSpxConnFile, NULL, lockHandle);
                        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);

            iOffset = MIN_IPXSPX2_HDRSIZE;
                        if (!SPX2_CONN(pSpxConnFile))
                        {
                                iOffset = 0;
                                if (!SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_IPXHDR))
                                {
                                        iOffset = MIN_IPXSPX_HDRSIZE;
                                }
                        }

                        copySize        = pktLen - iOffset;
                        fEom            = ((SPX_CONN_MSG(pSpxConnFile) &&
                                                   (pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_EOM)) ||
                                                   SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_IPXHDR));

                        //      Do we attempt to piggyback? If not, fImmedAck is true.
                        //      For SPX1 we dont piggyback.
                        //      Bug #18253
                        fImmedAck       = (!SPX2_CONN(pSpxConnFile)     ||
                                                        ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_EOM) == 0));

                        //      If we do not have EOM to indicate AND we are a zero-sized packet
                        //      then just consume this packet.
                        if (!fEom && (copySize == 0))
                        {
                                DBGPRINT(RECEIVE, ERR,
                                                ("SpxConnDataPacket: ZERO LENGTH PACKET NO EOM %lx.%lx\n",
                                                        pSpxConnFile, seqNum));

                                fPktDone = TRUE;
                                break;
                        }

                        receiveFlags     = TDI_RECEIVE_NORMAL;
            receiveFlags        |= ((fEom ? TDI_RECEIVE_ENTIRE_MESSAGE : 0) |
                                                                (((MacOptions &
                                                                        NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA) != 0) ?
                                                                                TDI_RECEIVE_COPY_LOOKAHEAD : 0));

            ++SpxDevice->dev_Stat.DataFramesReceived;
            ExInterlockedAddLargeStatistic(
                &SpxDevice->dev_Stat.DataFrameBytesReceived,
                copySize);

                        //      Ok, we accept this packet. Depending on our state.
                        switch (SPX_RECV_STATE(pSpxConnFile))
                        {
                        case SPX_RECV_PROCESS_PKTS:

                                        DBGPRINT(RECEIVE, DBG,
                                                        ("SpxConnDataPacket: recv completions on %lx\n",
                                                                pSpxConnFile));

                                        goto BufferPacket;

                        case SPX_RECV_IDLE:

                                //      If recv q is non-empty we are buffering data.
                                //      Also, if no receive handler goto buffer data. Also, if receives
                                //      are being completed, buffer this packet.
                                if ((pSpxConnFile->scf_RecvListHead != NULL)                                    ||
                                        !(IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage))                      ||
                                        !(pRecvHandler = pSpxConnFile->scf_AddrFile->saf_RecvHandler))
                                {
                                        DBGPRINT(RECEIVE, DBG,
                                                        ("SpxConnDataPacket: RecvListHead non-null %lx\n",
                                                                pSpxConnFile));

                                        goto BufferPacket;
                                }

                                if (!SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_PKT_NOIND))
                                {
                                        pRecvCtx = pSpxConnFile->scf_AddrFile->saf_RecvHandlerCtx;

                                        //      Don't indicate this packet again.
                    SPX_CONN_SETFLAG2(pSpxConnFile, SPX_CONNFILE2_PKT_NOIND);

#if DBG
                                        CTEAssert(pSpxConnFile->scf_CurRecvReq == NULL);

                                        //      Debug code to ensure we dont reindicate data/indicate
                                        //      when previously indicated data waiting with afd.

                                        //
                                        // Comment this out for Buf # 10394. we'r hitting this assert
                                        // even when there was no data loss.
                                        //
                                        // CTEAssert(pSpxConnFile->scf_IndBytes == 0);
                                        CTEAssert(pSpxConnFile->scf_PktSeqNum != seqNum);

                                        pSpxConnFile->scf_PktSeqNum     = seqNum;
                                        pSpxConnFile->scf_PktFlags      = pSpxConnFile->scf_Flags;
                                        pSpxConnFile->scf_PktFlags2 = pSpxConnFile->scf_Flags2;

                                        pSpxConnFile->scf_IndBytes  = copySize;
                                        pSpxConnFile->scf_IndLine       = __LINE__;


#endif
                                        CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);

                                        bytesTaken = 0;
                                        status = (*pRecvHandler)(
                                                        pRecvCtx,
                                                                        pSpxConnFile->scf_ConnCtx,
                                                                        receiveFlags,
                                    LookaheadSize - iOffset,
                                                                        copySize,
                                    &bytesTaken,
                                                                    LookaheadBuffer + iOffset,
                                                                        &pRecvIrp);

                                        DBGPRINT(RECEIVE, DBG,
                                                        ("SpxConnDataPacket: IND Flags %lx.%lx ConnID %lx,\
                                                                %lx Ctx %lx SEQ %lx Size %lx . %lx .%lx IND Status %lx\n",
                                                                pIpxSpxHdr->hdr_ConnCtrl,
                                                                receiveFlags,
                                                                destConnId,
                                                                pSpxConnFile,
                                                                pSpxConnFile->scf_ConnCtx,
                                seqNum,
                                                                LookaheadSize - iOffset,
                                                                copySize,
                                                                bytesTaken,
                                                                status));

                                        DBGPRINT(RECEIVE, INFO,
                                                        ("SpxConnDataPacket: %x %x %x %x %x %x %x %x %x %x %x %x\n",
                                                                *(LookaheadBuffer+iOffset),
                                                                *(LookaheadBuffer+iOffset+1),
                                                                *(LookaheadBuffer+iOffset+2),
                                                                *(LookaheadBuffer+iOffset+3),
                                                                *(LookaheadBuffer+iOffset+4),
                                                                *(LookaheadBuffer+iOffset+5),
                                                                *(LookaheadBuffer+iOffset+6),
                                                                *(LookaheadBuffer+iOffset+7),
                                                                *(LookaheadBuffer+iOffset+8),
                                                                *(LookaheadBuffer+iOffset+9),
                                                                *(LookaheadBuffer+iOffset+10),
                                                                *(LookaheadBuffer+iOffset+11)));

                                        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);

                                        if (status == STATUS_SUCCESS)
                                        {
                                                //      Assume all data accepted.
                                                CTEAssert((bytesTaken != 0) || fEom);
                                                fPktDone        = TRUE;

#if DBG
                                                //      Set this to 0, since we just indicated, there could
                                                //      not have been other data.
                                                pSpxConnFile->scf_IndBytes  = 0;
#endif

                                                break;
                                        }

                                        if (status == STATUS_MORE_PROCESSING_REQUIRED)
                                        {

                                                //      Queue irp into connection, change state to receive
                                                //      posted and fall thru.
                                                pRequest        = SpxAllocateRequest(
                                                                                SpxDevice,
                                                                                pRecvIrp);

                                                IF_NOT_ALLOCATED(pRequest)
                                                {
                                                        pRecvIrp->IoStatus.Status =
                                                                                        STATUS_INSUFFICIENT_RESOURCES;
                                                        IoCompleteRequest (pRecvIrp, IO_NETWORK_INCREMENT);
                                                        break;
                                                }

                                                //      If there was indicated but not received data waiting
                                                //      (which in this path there will never be, the request
                                                //      could be completed given the data filled it up, and
                                                //      the lock released.
                                                SpxConnQueueRecv(
                                                        pSpxConnFile,
                                                        pRequest);

                                                CTEAssert(pRequest == pSpxConnFile->scf_CurRecvReq);
                                        }
                                        else if (IsListEmpty(&pSpxConnFile->scf_RecvLinkage))
                                        {
                                                //      Data was not accepted. Need to buffer data and
                                                //      reduce window.
                                                goto BufferPacket;
                                        }

                                        //      Fall through to recv_posted.
                                }
                                else
                                {
                                        DBGPRINT(RECEIVE, WARN,
                                                        ("SpxConnDataPacket: !!!Ignoring %lx Seq %lx\n",
                                                                pSpxConnFile,
                                                                seqNum));

                                        break;
                                }

                        case SPX_RECV_POSTED:

                                if (pSpxConnFile->scf_RecvListHead != NULL)
                                {
                                        //      This can happen also. Buffer packet if it does.
                                        goto BufferPacket;
                                }

                                //      If a receive irp is posted, then process the receive irp. If
                                //      we fell thru we MAY already will have an irp.
                                if (pRequest == NULL)
                                {
                                        CTEAssert(!IsListEmpty(&pSpxConnFile->scf_RecvLinkage));
                                        CTEAssert(pSpxConnFile->scf_CurRecvReq != NULL);
                                        pRequest = pSpxConnFile->scf_CurRecvReq;
                                }

                                //      Process receive. Here we do not need to worry about
                                //      indicated yet not received data. We just deal with
                                //      servicing the current packet.
                                CTEAssert(pRequest == pSpxConnFile->scf_CurRecvReq);
                                if ((LookaheadSize == PacketSize) &&
                                        (pSpxConnFile->scf_CurRecvSize >= copySize))
                                {
                                        bytesCopied = 0;
                                        status          = STATUS_SUCCESS;
                                        if (copySize > 0)
                                        {
                                                status = TdiCopyBufferToMdl(
                                                                        LookaheadBuffer,
                                                                        iOffset,
                                                                        copySize,
                                                                        REQUEST_TDI_BUFFER(pRequest),
                                                                        pSpxConnFile->scf_CurRecvOffset,
                                                                        &bytesCopied);

                                                CTEAssert(NT_SUCCESS(status));
                                                if (!NT_SUCCESS(status))
                                                {
                                                        //      Abort request with this status. Reset request
                                                        //      queue to next request if one is available.
                                                }

                                                DBGPRINT(RECEIVE, DBG,
                                                                ("BytesCopied %lx CopySize %lx, Recv Size %lx.%lx\n",
                                                                        bytesCopied, copySize,
                                                                        pSpxConnFile->scf_CurRecvSize,
                                                                        pSpxConnFile->scf_CurRecvOffset));
                                        }

                                        //      Update current request values and see if this request
                                        //      is to be completed. Either zero or fEom.
                                        pSpxConnFile->scf_CurRecvOffset += bytesCopied;
                                        pSpxConnFile->scf_CurRecvSize   -= bytesCopied;

#if DBG
                                        //      Decrement indicated data count
                                        if (SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_PKT_NOIND))
                                        {
                                                if (bytesCopied != 0)
                                                {
                                                        CTEAssert (pSpxConnFile->scf_IndBytes != 0);
                                                        pSpxConnFile->scf_IndBytes      -= bytesCopied;
                                                }
                                        }
#endif

                                        if (SPX_CONN_STREAM(pSpxConnFile)                       ||
                                                (pSpxConnFile->scf_CurRecvSize == 0)    ||
                                                fEom)
                                        {
                                                CTELockHandle           lockHandleInter;

                                                //      Set status
                                                REQUEST_STATUS(pRequest) = STATUS_SUCCESS;
                                                REQUEST_INFORMATION(pRequest)=
                                                                                                pSpxConnFile->scf_CurRecvOffset;

                                                if (!SPX_CONN_STREAM(pSpxConnFile)               &&
                                                        (pSpxConnFile->scf_CurRecvSize == 0) &&
                                                        !fEom)
                                                {
                                                        REQUEST_STATUS(pRequest) = STATUS_RECEIVE_PARTIAL;
                                                }

                                                DBGPRINT(RECEIVE, DBG,
                                                                ("spxConnData: Completing recv %lx with %lx.%lx\n",
                                                                        pRequest, REQUEST_STATUS(pRequest),
                                    REQUEST_INFORMATION(pRequest)));

                                                //      Dequeue this request, Set next recv if one exists.
                                                SPX_CONN_SETNEXT_CUR_RECV(pSpxConnFile, pRequest);

                                                //      Request is done. Move to completion list.
                                                CTEGetLock(&SpxGlobalQInterlock, &lockHandleInter);
                                                InsertTailList(
                                                        &pSpxConnFile->scf_RecvDoneLinkage,
                                                        REQUEST_LINKAGE(pRequest));

                                                SPX_QUEUE_FOR_RECV_COMPLETION(pSpxConnFile);
                                                CTEFreeLock(&SpxGlobalQInterlock, lockHandleInter);
                                        }

                                        fPktDone = TRUE;
                                }
                                else
                                {
                                        //      Need to allocate a ndis receive packet for transfer
                                        //      data.
                                        DBGPRINT(RECEIVE, DBG,
                                                        ("SpxConnDataPacket: %lx.%lx Tranfer data needed!\n",
                                                                copySize, pSpxConnFile->scf_CurRecvSize));

                                        if (copySize > pSpxConnFile->scf_CurRecvSize)
                                        {
                                                //      Partial receive. Buffer and then deal with it.
                                                goto BufferPacket;
                                        }

                                        //      Allocate a ndis receive packet.
                                        SpxAllocRecvPacket(SpxDevice, &pNdisPkt, &ndisStatus);
                                        if (ndisStatus != NDIS_STATUS_SUCCESS)
                                        {
                                                break;
                                        }

                                        //      Describe the receive irp's data with a ndis buffer
                                        //      descriptor.
                                        if (copySize > 0)
                                        {
                                                SpxCopyBufferChain(
                                                        &ndisStatus,
                                                        &pNdisBuffer,
                                                        SpxDevice->dev_NdisBufferPoolHandle,
                                                        REQUEST_TDI_BUFFER(pRequest),
                                                        pSpxConnFile->scf_CurRecvOffset,
                                                        copySize);

                                                if (ndisStatus != NDIS_STATUS_SUCCESS)
                                                {
                                                        //      Free the recv packet
                                                        SpxPktRecvRelease(pNdisPkt);
                                                        break;
                                                }

                                                //      Queue the buffer into the packet
                                                //  Link the buffer descriptor into the packet descriptor
                                                NdisChainBufferAtBack(
                                                        pNdisPkt,
                                                        pNdisBuffer);
                                        }

                                        //      Don't care about whether this is indicated or not here
                                        //      as it is not a buffering packet.
                                        pRecvResd                               = RECV_RESD(pNdisPkt);
                                        pRecvResd->rr_Id        = IDENTIFIER_SPX;
                                        pRecvResd->rr_State             =
                                                ((fEom ? SPX_RECVPKT_EOM : 0) |
                                                (SPX_CONN_FLAG2(
                                                        pSpxConnFile, SPX_CONNFILE2_PKT_NOIND) ? SPX_RECVPKT_INDICATED : 0) |
                                                 (fImmedAck ? SPX_RECVPKT_IMMEDACK : 0) |
                                                 ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_ACK) ?
                                                        SPX_RECVPKT_SENDACK : 0));

                                        if (pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_ACK)
                                        {
                                                //      copy the remote address in connection.
                                                SpxCopyIpxAddr(pIpxSpxHdr, pSpxConnFile->scf_RemAckAddr);
                                                pSpxConnFile->scf_AckLocalTarget        = *RemoteAddress;
                                        }

                                        pRecvResd->rr_Request   = pRequest;
                                        pRecvResd->rr_ConnFile  = pSpxConnFile;

                                        //      reference receive request
                                        REQUEST_INFORMATION(pRequest)++;

                                        CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
                                        fLockHeld = FALSE;

                                        //      Call ndis transfer data.
                                        ndisStatus      = NDIS_STATUS_SUCCESS;
                                        bytesCopied = 0;
                                        if (copySize > 0)
                                        {
                                                (*IpxTransferData)(
                                                        &ndisStatus,
                                                        MacBindingHandle,
                                                        MacReceiveContext,
                                                        iOffset + LookaheadOffset,
                                                        copySize,
                                                        pNdisPkt,
                                                        &bytesCopied);
                                        }

                                        if (ndisStatus != STATUS_PENDING)
                                        {
                                                SpxTransferDataComplete(
                                                        pNdisPkt,
                                                        ndisStatus,
                                                        bytesCopied);
                                        }
                                }

                                break;

                        default:

                                KeBugCheck(0);
                                break;
                        }

                        break;

BufferPacket:

                        SpxRecvBufferPkt(
                                pSpxConnFile,
                                MacBindingHandle,
                                MacReceiveContext,
                                iOffset + LookaheadOffset,
                                pIpxSpxHdr,
                                copySize,
                                RemoteAddress,
                                lockHandle);

                        fLockHeld = FALSE;
                }

        } while (FALSE);

        //      Here we process a received ack.
        if (!fLockHeld)
        {
                CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                fLockHeld = TRUE;
        }

        //      Send an ack if one was asked for. And we are done with this packet.
        if (fPktDone)
        {
                END_PROCESS_PACKET(pSpxConnFile, FALSE, TRUE);
        }

        if ((pIpxSpxHdr->hdr_ConnCtrl & SPX_CC_ACK) && fPktDone)
        {
                if (!fLockHeld)
                {
                        CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
                        fLockHeld = TRUE;
                }

                //      First copy the remote address in connection.
                SpxCopyIpxAddr(pIpxSpxHdr, pSpxConnFile->scf_RemAckAddr);
                pSpxConnFile->scf_AckLocalTarget        = *RemoteAddress;

                //      #17564
                if (fImmedAck                                                                                     ||
                        SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_NOACKWAIT) ||
                        SPX_CONN_FLAG2(pSpxConnFile, SPX_CONNFILE2_IMMED_ACK))
                {
                        SpxConnSendAck(pSpxConnFile, lockHandle);
                        fLockHeld = FALSE;
                }
                else
                {
                        SpxConnQWaitAck(pSpxConnFile);
                }
        }

        if (fLockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
        }

        //      Deref the connection
        SpxConnFileDereference(pSpxConnFile, CFREF_BYID);
        return;
}




VOID
SpxRecvFlushBytes(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      ULONG                           BytesToFlush,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:


Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:


--*/
{
        PNDIS_PACKET                            pNdisPkt;
        PNDIS_BUFFER                            pNdisBuffer;
        PSPX_RECV_RESD                          pRecvResd;
        PBYTE                                           pData;
        ULONG                                           dataLen, copyLen;
        BOOLEAN                                         fLockHeld = TRUE, fWdwOpen = FALSE;
        USHORT                                          discState       = 0;
        int                                                     numPkts = 0, numDerefs = 0;

        DBGPRINT(RECEIVE, DBG,
                        ("SpxRecvFlushBytes: %lx Flush %lx\n",
                                pSpxConnFile, BytesToFlush));

        while (((pRecvResd = pSpxConnFile->scf_RecvListHead) != NULL) &&
                   ((BytesToFlush > 0) ||
                    ((pRecvResd->rr_State & SPX_RECVPKT_INDICATED) != 0)))
        {
                //      A buffering recv packet will have ATMOST one ndis buffer descriptor
                //      queued in, which will describe a segment of memory we have
                //      allocated. An offset will also be present indicating the data
                //      to start reading from (or to indicate from to AFD).
                CTEAssert((pRecvResd->rr_State & SPX_RECVPKT_BUFFERING) != 0);
                pNdisPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                        pRecvResd, NDIS_PACKET, ProtocolReserved);

                NdisQueryPacket(pNdisPkt, NULL, NULL, &pNdisBuffer, NULL);

                //      Initialize pData
                pData = NULL;
                dataLen = 0;

                if (pNdisBuffer != NULL)
                {
                        NdisQueryBuffer(pNdisBuffer, &pData, &dataLen);
                        CTEAssert(pData != NULL);
                        CTEAssert((LONG)dataLen >= 0);
                }

                if ((BytesToFlush == 0) && (dataLen != 0))
                {
                        //      Don't flush this packet.
                        break;
                }

                //      Allow for zero data, eom only packets.
                copyLen = MIN((dataLen - pRecvResd->rr_DataOffset), BytesToFlush);

                DBGPRINT(RECEIVE, DBG,
                                ("SpxRecvFlushBytes: %lx Pkt %lx DataLen %lx Copy %lx Flush %lx\n",
                                        pSpxConnFile, pNdisPkt, dataLen, copyLen, BytesToFlush));

                //      Adjust various values to see whats done whats not
        pRecvResd->rr_DataOffset                        += (USHORT)copyLen;
                BytesToFlush                                            -= (ULONG)copyLen;

#if DBG
                if (copyLen != 0)
                {
                        CTEAssert (pSpxConnFile->scf_IndBytes != 0);
                        pSpxConnFile->scf_IndBytes      -= copyLen;
                }
#endif

                if (pRecvResd->rr_DataOffset == dataLen)
                {
                        //      Packet consumed. Free it up. Check if disc happened.
                        discState = (pRecvResd->rr_State & SPX_RECVPKT_DISCMASK);
                        CTEAssert((discState == 0) ||
                                                (pRecvResd == pSpxConnFile->scf_RecvListTail));

                        numDerefs++;
                        SpxConnDequeueRecvPktLock(pSpxConnFile, pNdisPkt);
                        if (pNdisBuffer != NULL)
                        {
                                NdisUnchainBufferAtFront(pNdisPkt, &pNdisBuffer);
                                CTEAssert(pNdisBuffer != NULL);
                                NdisFreeBuffer(pNdisBuffer);
                                SpxFreeMemory(pData);
                        }

                        SpxPktRecvRelease(pNdisPkt);

                        DBGPRINT(RECEIVE, DBG,
                                        ("SpxRecvFlushBytes: !!!ALL INDICATED on %lx.%lx.%lx.%lx\n",
                                                pSpxConnFile, pNdisPkt, pNdisBuffer, pData));

            INCREMENT_WINDOW(pSpxConnFile);
                        fWdwOpen = TRUE;
                }
                else
                {
                        //      Took only part of this packet. Get out.
                        break;
                }
        }

        if (fWdwOpen && (pSpxConnFile->scf_RecvListHead == NULL))
        {
                //      Send an ack as our windows probably opened up. Dont wait to
                //      piggyback here...
                DBGPRINT(RECEIVE, DBG,
                                ("spxRecvFlushBytes: Send ACK %lx\n",
                                        pSpxConnFile));

#if DBG_WDW_CLOSE
                //      If packets been indicated we have started buffering. Also
                //      check if window is now zero.
                {
                        LARGE_INTEGER   li, ntTime;
                        int                             value;

                        li = pSpxConnFile->scf_WdwCloseTime;
                        if (li.LowPart && li.HighPart)
                        {
                                KeQuerySystemTime(&ntTime);

                                //      Get the difference
                                ntTime.QuadPart = ntTime.QuadPart - li.QuadPart;

                                //      Convert to milliseconds. If the highpart is 0, we
                                //      take a shortcut.
                                if (ntTime.HighPart == 0)
                                {
                                        value   = ntTime.LowPart/10000;
                                }
                                else
                                {
                                        ntTime  = SPX_CONVERT100NSTOCENTISEC(ntTime);
                                        value   = ntTime.LowPart << 4;
                                }

                                //      Set new average close time
                                pSpxConnFile->scf_WdwCloseAve += value;
                                pSpxConnFile->scf_WdwCloseAve /= 2;
                                DBGPRINT(RECEIVE, DBG,
                                                ("V %ld AVE %ld\n",
                                                        value, pSpxConnFile->scf_WdwCloseAve));
                        }
                }
#endif

                SpxConnSendAck(pSpxConnFile, LockHandleConn);
                CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
        }

        //      Check if disconnect happened
        switch (discState)
        {
        case SPX_RECVPKT_IDISC:

                CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);

                DBGPRINT(RECEIVE, ERR,
                                ("spxRecvFlushBytes: Buffered IDISC %lx\n",
                                        pSpxConnFile));

                SpxConnProcessIDisc(pSpxConnFile, LockHandleConn);
                fLockHeld = FALSE;
                break;

        case SPX_RECVPKT_ORD_DISC:

                CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);

                DBGPRINT(RECEIVE, ERR,
                                ("spxRecvFlushBytes: Buffered ORDREL %lx\n",
                                        pSpxConnFile));

                SpxConnProcessOrdRel(pSpxConnFile, LockHandleConn);
                fLockHeld = FALSE;
                break;

        case (SPX_RECVPKT_IDISC | SPX_RECVPKT_ORD_DISC):

                //      IDISC has more priority.
                CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);

                DBGPRINT(RECEIVE, ERR,
                                ("spxRecvFlushBytes: Buffered IDISC *AND* ORDREL %lx\n",
                                        pSpxConnFile));

                SpxConnProcessIDisc(pSpxConnFile, LockHandleConn);
                fLockHeld = FALSE;
                break;

        default:

                break;
        }

        if (fLockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
        }

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}




BOOLEAN
SpxRecvIndicatePendingData(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:


Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:

        BOOLEAN - Receive was queued => TRUE

--*/
{
        ULONG                           indicateFlags;
        PNDIS_PACKET            pNdisPkt;
        PNDIS_BUFFER            pNdisBuffer;
        PREQUEST                        pRequest;
        PIRP                            pRecvIrp;
        ULONG                           bytesTaken, totalSize, bufSize;
        PTDI_IND_RECEIVE        pRecvHandler;
        PVOID                           pRecvCtx;
        PSPX_RECV_RESD          pRecvResd;
        NTSTATUS                        status;
        PBYTE                           lookaheadData;
        ULONG                           lookaheadSize;
        BOOLEAN                         fLockHeld = TRUE, fRecvQueued = FALSE;


        while  ((pRecvHandler = pSpxConnFile->scf_AddrFile->saf_RecvHandler)    &&
                        ((pRecvResd = pSpxConnFile->scf_RecvListHead) != NULL)                  &&
                        (IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage))                               &&
                        ((pRecvResd->rr_State & SPX_RECVPKT_BUFFERING) != 0)                    &&
                        ((pRecvResd->rr_State & SPX_RECVPKT_INDICATED) == 0))
        {
                //      Once a receive is queued we better get out.
                CTEAssert(!fRecvQueued);

                //      Initialize lookahead values
                lookaheadData = NULL;
                lookaheadSize = 0;

                //      We have no indicated but pending data, and there is some data to
                //      indicate. Figure out how much. Indicate upto end of message or as
                //      much as we have.

                //      A buffering recv packet will have ATMOST one ndis buffer descriptor
                //      queued in, which will describe a segment of memory we have
                //      allocated. An offset will also be present indicating the data
                //      to start reading from (or to indicate from to AFD).
                CTEAssert((pRecvResd->rr_State & SPX_RECVPKT_BUFFERING) != 0);
                pNdisPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                        pRecvResd, NDIS_PACKET, ProtocolReserved);

                NdisQueryPacket(pNdisPkt, NULL, NULL, &pNdisBuffer, NULL);
                if (pNdisBuffer != NULL)
                {
                        NdisQueryBuffer(pNdisBuffer, &lookaheadData, &lookaheadSize);
                        CTEAssert(lookaheadData != NULL);
                        CTEAssert((LONG)lookaheadSize >= 0);
                }

                //      Allow for zero data, eom only packets.
                lookaheadSize -= pRecvResd->rr_DataOffset;
                totalSize          = lookaheadSize;
                lookaheadData += pRecvResd->rr_DataOffset;

                //      If this packet contained data then eom must also have been
                //      indicated at the time all the data was consumed.
                CTEAssert((lookaheadSize > 0) ||
                                        ((pRecvResd->rr_DataOffset == 0) &&
                                         ((pRecvResd->rr_State & SPX_RECVPKT_EOM) != 0)));

#if DBG
                CTEAssert (pSpxConnFile->scf_CurRecvReq == NULL);

                //      Debug code to ensure we dont reindicate data/indicate
                //      when previously indicated data waiting with afd.
                CTEAssert(pSpxConnFile->scf_IndBytes == 0);
                CTEAssert(pSpxConnFile->scf_PktSeqNum != pRecvResd->rr_SeqNum);

                pSpxConnFile->scf_PktSeqNum     = pRecvResd->rr_SeqNum;
                pSpxConnFile->scf_PktFlags      = pSpxConnFile->scf_Flags;
                pSpxConnFile->scf_PktFlags2 = pSpxConnFile->scf_Flags2;
#endif

                pRecvResd->rr_State     |= SPX_RECVPKT_INDICATED;

                //      Go ahead and walk the list of waiting packets. Get total size.
                while ((pRecvResd->rr_Next != NULL) &&
                           ((pRecvResd->rr_State & SPX_RECVPKT_EOM) == 0))
                {
                        //      Check next packet.
                        pRecvResd = pRecvResd->rr_Next;

#if DBG
                        CTEAssert(pSpxConnFile->scf_PktSeqNum != pRecvResd->rr_SeqNum);

                        pSpxConnFile->scf_PktSeqNum     = pRecvResd->rr_SeqNum;
                        pSpxConnFile->scf_PktFlags      = pSpxConnFile->scf_Flags;
                        pSpxConnFile->scf_PktFlags2 = pSpxConnFile->scf_Flags2;
#endif

                        pRecvResd->rr_State     |= SPX_RECVPKT_INDICATED;

                        pNdisPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                                pRecvResd, NDIS_PACKET, ProtocolReserved);

                        NdisQueryPacket(pNdisPkt, NULL, NULL, NULL, &bufSize);
                        CTEAssert((LONG)bufSize >= 0);

                        //      Allow for zero data, eom only packets.
                        totalSize       += bufSize;
                }

#if DBG
        pSpxConnFile->scf_IndBytes  = totalSize;
                pSpxConnFile->scf_IndLine       = __LINE__;

                //      There better not be any pending receives. If so, we have data
                //      corruption about to happen.
                if (!IsListEmpty(&pSpxConnFile->scf_RecvDoneLinkage))
                {
                        DBGBRK(FATAL);
                        KeBugCheck(0);
                }
#endif

                indicateFlags = TDI_RECEIVE_NORMAL | TDI_RECEIVE_COPY_LOOKAHEAD;
                if ((pRecvResd->rr_State & SPX_RECVPKT_EOM) != 0)
                {
                        indicateFlags |= TDI_RECEIVE_ENTIRE_MESSAGE;
                }

                pRecvCtx = pSpxConnFile->scf_AddrFile->saf_RecvHandlerCtx;
                CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

                bytesTaken = 0;
                status = (*pRecvHandler)(
                                                pRecvCtx,
                                                pSpxConnFile->scf_ConnCtx,
                                                indicateFlags,
                                                lookaheadSize,
                                                totalSize,
                                                &bytesTaken,
                                                lookaheadData,
                                                &pRecvIrp);

                DBGPRINT(RECEIVE, DBG,
                                ("SpxConnIndicatePendingData: IND Flags %lx Size %lx .%lx IND Status %lx\n",
                                        indicateFlags,
                                        totalSize,
                                        bytesTaken,
                                        status));

                CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                if (status == STATUS_SUCCESS)
                {
                        //      Assume all data accepted. Free bytesTaken worth of data packets.
                        //      Sometimes AFD returns STATUS_SUCCESS to just flush the data, so
                        //      we can't assume it took only one packet (since lookahead only
                        //      had that information).
                        CTEAssert(bytesTaken == totalSize);
                        SpxRecvFlushBytes(pSpxConnFile, totalSize, LockHandleConn);
                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                        continue;
                }
                else if (status == STATUS_MORE_PROCESSING_REQUIRED)
                {

                        //      Queue irp into connection, change state to receive
                        //      posted and fall thru.
                        pRequest        = SpxAllocateRequest(
                                                        SpxDevice,
                                                        pRecvIrp);

                        IF_NOT_ALLOCATED(pRequest)
                        {
                                pRecvIrp->IoStatus.Status =
                                                                STATUS_INSUFFICIENT_RESOURCES;
                                IoCompleteRequest (pRecvIrp, IO_NETWORK_INCREMENT);
                                return (FALSE);
                        }

                        SpxConnQueueRecv(
                                pSpxConnFile,
                                pRequest);

                        fRecvQueued = TRUE;
                }

                break;
        }

        if (fLockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
        }

        return fRecvQueued;
}




VOID
SpxRecvProcessPkts(
        IN      PSPX_CONN_FILE          pSpxConnFile,
        IN      CTELockHandle           LockHandleConn
        )
/*++

Routine Description:

        Handle buffered data, complete irp if necessary. Set state to idle
        if list becomes empty.

Arguments:

    pSpxConnFile - Pointer to a transport address file object.

Return Value:

        BOOLEAN: More data left to indicate => TRUE

--*/
{
        ULONG                                           remainingDataLen, copyLen, bytesCopied;
        PREQUEST                                        pRequest;
        NTSTATUS                                        status;
        BOOLEAN                                         fEom;
        PNDIS_PACKET                            pNdisPkt;
        PNDIS_BUFFER                            pNdisBuffer;
        PSPX_RECV_RESD                          pRecvResd;
        ULONG                                           dataLen;
        PBYTE                                           pData;
        LIST_ENTRY                                      *p;
        BOOLEAN                                         fLockHeld = TRUE, fMoreData = TRUE, fWdwOpen = FALSE;
        USHORT                                          discState       = 0;
        int                                                     numDerefs       = 0;

        if (SPX_RECV_STATE(pSpxConnFile) != SPX_RECV_PROCESS_PKTS)
        {
        SPX_RECV_SETSTATE(pSpxConnFile, SPX_RECV_PROCESS_PKTS);

ProcessReceives:

                while ((pSpxConnFile->scf_CurRecvReq != NULL) &&
                                ((pRecvResd = pSpxConnFile->scf_RecvListHead) != NULL))
                {
                        //      A buffering recv packet will have one ndis buffer descriptor
                        //      queued in, which will describe a segment of memory we have
                        //      allocated. An offset will also be present indicating the data
                        //      to start reading from (or to indicate from to AFD).
                        CTEAssert((pRecvResd->rr_State & SPX_RECVPKT_BUFFERING) != 0);

                        pNdisPkt = (PNDIS_PACKET)CONTAINING_RECORD(
                                                                                pRecvResd, NDIS_PACKET, ProtocolReserved);

                        NdisQueryPacket(pNdisPkt, NULL, NULL, &pNdisBuffer, NULL);


                        //      Initialize pData
                        pData = NULL;
                        dataLen = 0;

                        if (pNdisBuffer != NULL)
                        {
                                NdisQueryBuffer(pNdisBuffer, &pData, &dataLen);
                                CTEAssert(pData != NULL);
                                CTEAssert((LONG)dataLen >= 0);
                        }

                        //      Allow for zero data, eom only packets.
                        remainingDataLen = dataLen - pRecvResd->rr_DataOffset;

                        //      If this packet contained data then eom must also have been
                        //      indicated at the time all the data was consumed.
                        CTEAssert((remainingDataLen > 0) ||
                                                ((pRecvResd->rr_DataOffset == 0) &&
                                                 ((pRecvResd->rr_State & SPX_RECVPKT_EOM) != 0)));

                        status  = STATUS_SUCCESS;
                        copyLen = 0;
                        if (remainingDataLen > 0)
                        {
                                copyLen = MIN(remainingDataLen, pSpxConnFile->scf_CurRecvSize);
                                status = TdiCopyBufferToMdl(
                                                        pData,
                                                        pRecvResd->rr_DataOffset,
                                                        copyLen,
                                                        REQUEST_TDI_BUFFER(pSpxConnFile->scf_CurRecvReq),
                                                        pSpxConnFile->scf_CurRecvOffset,
                                                        &bytesCopied);

                                CTEAssert(NT_SUCCESS(status));
                                if (!NT_SUCCESS(status))
                                {
                                        //      Abort request with this status. Reset request
                                        //      queue to next request if one is available.
                                        copyLen = pSpxConnFile->scf_CurRecvSize;
                                }
                        }

                        DBGPRINT(RECEIVE, DBG,
                                        ("spxConnProcessRecdPkts: %lx Pkt %lx Data %lx Size %lx F %lx\n",
                                                pSpxConnFile, pNdisPkt, pData, copyLen, pRecvResd->rr_State));

                        //      Adjust various values to see whats done whats not
                        pRecvResd->rr_DataOffset                        += (USHORT)copyLen;
                        pSpxConnFile->scf_CurRecvSize           -= (USHORT)copyLen;
                        pSpxConnFile->scf_CurRecvOffset         += (USHORT)copyLen;

#if DBG
                        //      If this packet was part of indicated data count, decrement.
                        if ((pRecvResd->rr_State & SPX_RECVPKT_INDICATED) != 0)
                        {
                                if (copyLen != 0)
                                {
                                        CTEAssert (pSpxConnFile->scf_IndBytes != 0);
                                        pSpxConnFile->scf_IndBytes      -= copyLen;
                                }
                        }
#endif

                        //      Set fEom/discState (init to 0)  only if all of packet was consumed.
                        fEom = FALSE;
                        if (pRecvResd->rr_DataOffset == dataLen)
                        {
                                fEom    = (BOOLEAN)((pRecvResd->rr_State & SPX_RECVPKT_EOM) != 0);

                                //      Remember if disconnect needed to happen. If set, this better be
                                //      last packet received. Again, only if entire pkt was consumed.
                                discState = (pRecvResd->rr_State & SPX_RECVPKT_DISCMASK);
                                CTEAssert((discState == 0) ||
                                                        (pRecvResd == pSpxConnFile->scf_RecvListTail));

                                //      Packet consumed. Free it up.
                                numDerefs++;

                                SpxConnDequeueRecvPktLock(pSpxConnFile, pNdisPkt);
                                INCREMENT_WINDOW(pSpxConnFile);

                fWdwOpen = TRUE;

                                DBGPRINT(RECEIVE, DBG,
                                                ("spxConnProcessRecdPkts: %lx Pkt %lx Data %lx DEQUEUED\n",
                                                        pSpxConnFile, pNdisPkt, pData));

                                if (pNdisBuffer != NULL)
                                {
                                        NdisUnchainBufferAtFront(pNdisPkt, &pNdisBuffer);
                                        NdisFreeBuffer(pNdisBuffer);
                                        SpxFreeMemory(pData);
                                }

                                SpxPktRecvRelease(pNdisPkt);
                        }
                        else
                        {
                                DBGPRINT(RECEIVE, DBG,
                                                ("spxConnProcessRecdPkts: %lx Pkt %lx PARTIAL USE %lx.%lx\n",
                                                        pSpxConnFile, pNdisPkt, pRecvResd->rr_DataOffset, dataLen));
                        }

                        //      Don't complete until we are out of all packets and stream mode or...
                        if (((pSpxConnFile->scf_RecvListHead == NULL) &&
                                        SPX_CONN_STREAM(pSpxConnFile))                          ||
                                (pSpxConnFile->scf_CurRecvSize == 0)                    ||
                                fEom)
                        {
                                //      Done with receive, move to completion or complete depending on
                                //      call level.
                                pRequest = pSpxConnFile->scf_CurRecvReq;

                                //      Set status. Complete with error from TdiCopy if so.
                                REQUEST_INFORMATION(pRequest)   = pSpxConnFile->scf_CurRecvOffset;
                                REQUEST_STATUS(pRequest)                = status;

                                //      Ensure we dont overwrite an error status.
                                if (!SPX_CONN_STREAM(pSpxConnFile)               &&
                                        (pSpxConnFile->scf_CurRecvSize == 0) &&
                                        !fEom &&
                                        NT_SUCCESS(status))
                                {
                                        REQUEST_STATUS(pRequest) = STATUS_RECEIVE_PARTIAL;
                                }

                                //      Dequeue this request, set next recv if one exists.
                                SPX_CONN_SETNEXT_CUR_RECV(pSpxConnFile, pRequest);

                                DBGPRINT(RECEIVE, DBG,
                                                ("spxConnProcessRecdPkts: %lx Recv %lx with %lx.%lx\n",
                                                        pSpxConnFile, pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));

#if DBG
                                if ((REQUEST_STATUS(pRequest) == STATUS_SUCCESS) &&
                                        (REQUEST_INFORMATION(pRequest) == 0))
                                {
                                        DBGPRINT(TDI, DBG,
                                                        ("SpxReceiveComplete: Completing %lx with %lx.%lx\n",
                                                                pRequest, REQUEST_STATUS(pRequest),
                                                                REQUEST_INFORMATION(pRequest)));
                                }
#endif

                                //      Request is done. Move to receive completion list. There
                                //      could already be previously queued requests in here.
                                InsertTailList(
                                        &pSpxConnFile->scf_RecvDoneLinkage,
                                        REQUEST_LINKAGE(pRequest));
                        }

                        CTEAssert((discState == 0) ||
                                                (pSpxConnFile->scf_RecvListHead == NULL));
                }

                //      Complete any completed receives
                while ((p = pSpxConnFile->scf_RecvDoneLinkage.Flink) !=
                                                                                        &pSpxConnFile->scf_RecvDoneLinkage)
                {
                        pRequest = LIST_ENTRY_TO_REQUEST(p);
                        RemoveEntryList(REQUEST_LINKAGE(pRequest));
                        CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);

                        DBGPRINT(TDI, DBG,
                                        ("SpxConnDiscPkt: PENDING REQ COMP %lx with %lx.%lx\n",
                                                pRequest, REQUEST_STATUS(pRequest),
                                                REQUEST_INFORMATION(pRequest)));

#if DBG
                        if ((REQUEST_STATUS(pRequest) == STATUS_SUCCESS) &&
                                (REQUEST_INFORMATION(pRequest) == 0))
                        {
                                DBGPRINT(TDI, DBG,
                                                ("SpxReceiveComplete: Completing %lx with %lx.%lx\n",
                                                        pRequest, REQUEST_STATUS(pRequest),
                                                        REQUEST_INFORMATION(pRequest)));
                        }
#endif

                        SpxCompleteRequest(pRequest);
                        numDerefs++;
                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                }

                fMoreData = ((pSpxConnFile->scf_RecvListHead != NULL)                           &&
                                         ((pSpxConnFile->scf_RecvListHead ->rr_State    &
                                                                                SPX_RECVPKT_BUFFERING) != 0)            &&
                                         ((pSpxConnFile->scf_RecvListHead->rr_State     &
                                                                                SPX_RECVPKT_INDICATED) == 0));

                while (fMoreData)
                {
                        //      Bug #21036
                        //      If there is a receive waiting to be processed, we better not
                        //      indicate data before we finish it.
                        if (pSpxConnFile->scf_CurRecvReq != NULL)
                                goto ProcessReceives;

                        //      If a receive was queued the goto beginning again.
                        if (SpxRecvIndicatePendingData(pSpxConnFile, LockHandleConn))
                        {
                                CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                                goto ProcessReceives;
                        }

                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                        fMoreData = ((pSpxConnFile->scf_RecvListHead != NULL)                           &&
                                                 ((pSpxConnFile->scf_RecvListHead ->rr_State    &
                                                                                        SPX_RECVPKT_BUFFERING) != 0)            &&
                                                 ((pSpxConnFile->scf_RecvListHead->rr_State     &
                                                                                        SPX_RECVPKT_INDICATED) == 0));
                }

                //      Set state
                SPX_RECV_SETSTATE(
                        pSpxConnFile,
                        (pSpxConnFile->scf_CurRecvReq == NULL) ?
                                SPX_RECV_IDLE : SPX_RECV_POSTED);
        }
#if DBG
        else
        {
                DBGPRINT(RECEIVE, ERR,
                                ("spxConnProcessRecdPkts: Already processing pkts %lx\n",
                                        pSpxConnFile));
        }
#endif

        if (fWdwOpen && (pSpxConnFile->scf_RecvListHead == NULL))
        {
                //      Send an ack as our windows probably opened up. Dont wait to
                //      piggyback here...
                DBGPRINT(RECEIVE, DBG,
                                ("spxConnProcessRecdPkts: Send ACK %lx\n",
                                        pSpxConnFile));

#if DBG_WDW_CLOSE
                //      If packets been indicated we have started buffering. Also
                //      check if window is now zero.
                {
                        LARGE_INTEGER   li, ntTime;
                        int                             value;

                        li = pSpxConnFile->scf_WdwCloseTime;
                        if (li.LowPart && li.HighPart)
                        {
                                KeQuerySystemTime(&ntTime);

                                //      Get the difference
                                ntTime.QuadPart = ntTime.QuadPart - li.QuadPart;

                                //      Convert to milliseconds. If the highpart is 0, we
                                //      take a shortcut.
                                if (ntTime.HighPart == 0)
                                {
                                        value   = ntTime.LowPart/10000;
                                }
                                else
                                {
                                        ntTime  = SPX_CONVERT100NSTOCENTISEC(ntTime);
                                        value   = ntTime.LowPart << 4;
                                }

                                //      Set new average close time
                                pSpxConnFile->scf_WdwCloseAve += value;
                                pSpxConnFile->scf_WdwCloseAve /= 2;
                                DBGPRINT(RECEIVE, DBG,
                                                ("V %ld AVE %ld\n",
                                                        value, pSpxConnFile->scf_WdwCloseAve));
                        }
                }
#endif

                SpxConnSendAck(pSpxConnFile, LockHandleConn);
                fLockHeld = FALSE;
        }

        //      Check if disconnect happened
        switch (discState)
        {
        case SPX_RECVPKT_IDISC:

                CTEAssert(!fMoreData);
                CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);

                if (!fLockHeld)
                {
                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                }

                DBGPRINT(RECEIVE, DBG,
                                ("spxConnProcessRecdPkts: Buffered IDISC %lx\n",
                                        pSpxConnFile, fMoreData));

                SpxConnProcessIDisc(pSpxConnFile, LockHandleConn);
                fLockHeld = FALSE;
                break;

        case SPX_RECVPKT_ORD_DISC:

                CTEAssert(!fMoreData);
                CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);

                if (!fLockHeld)
                {
                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                }

                DBGPRINT(RECEIVE, DBG,
                                ("spxConnProcessRecdPkts: Buffered ORDREL %lx\n",
                                        pSpxConnFile, fMoreData));

                SpxConnProcessOrdRel(pSpxConnFile, LockHandleConn);
                fLockHeld = FALSE;
                break;

        case (SPX_RECVPKT_IDISC | SPX_RECVPKT_ORD_DISC):

                //      IDISC has more priority.
                CTEAssert(!fMoreData);
                CTEAssert(pSpxConnFile->scf_RecvListHead == NULL);

                if (!fLockHeld)
                {
                        CTEGetLock(&pSpxConnFile->scf_Lock, &LockHandleConn);
                }

                DBGPRINT(RECEIVE, ERR,
                                ("spxConnProcessRecdPkts: Buffered IDISC *AND* ORDREL %lx\n",
                                        pSpxConnFile, fMoreData));

                SpxConnProcessIDisc(pSpxConnFile, LockHandleConn);
                fLockHeld = FALSE;
                break;

        default:

                break;
        }

        if (fLockHeld)
        {
                CTEFreeLock(&pSpxConnFile->scf_Lock, LockHandleConn);
        }

        while (numDerefs-- > 0)
        {
                SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
        }

        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxreg.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxreg.h

Abstract:

    Private include file for the ISN SPX module.
    file defines all constants and structures necessary for support of
    the dynamic configuration of ST.

Revision History:

--*/

#define	HALFSEC_TO_MS_FACTOR				500
#define	IPX_REG_PATH						L"NwlnkIpx\\Linkage"

// These are used to index into the Parameters array in CONFIG.
#define CONFIG_CONNECTION_COUNT             0
#define CONFIG_CONNECTION_TIMEOUT           1
#define CONFIG_INIT_PACKETS                 2
#define CONFIG_MAX_PACKETS                  3
#define CONFIG_INITIAL_RETRANSMIT_TIMEOUT   4
#define CONFIG_KEEPALIVE_COUNT              5
#define CONFIG_KEEPALIVE_TIMEOUT            6
#define CONFIG_WINDOW_SIZE                  7
#define CONFIG_SOCKET_RANGE_START           8
#define CONFIG_SOCKET_RANGE_END	           	9
#define CONFIG_SOCKET_UNIQUENESS           	10
#define CONFIG_MAX_PACKET_SIZE           	11
#define CONFIG_REXMIT_COUNT		           	12

//	Hidden parameters
#define	CONFIG_DISABLE_SPX2					13
#define	CONFIG_ROUTER_MTU					14
#define	CONFIG_BACKCOMP_SPX					15
#define CONFIG_DISABLE_RTT                  16
 
#define CONFIG_PARAMETERS                   17

// Main configuration structure.
typedef struct _CONFIG {

    ULONG       cf_Parameters[CONFIG_PARAMETERS];   // index defined above
    NDIS_STRING cf_DeviceName;                      // device name exported
    PWSTR       cf_RegistryPathBuffer;              // path to config info

} CONFIG, * PCONFIG;


#define	PARAM(x)	(SpxDevice->dev_ConfigInfo->cf_Parameters[(x)])


NTSTATUS
SpxInitGetConfiguration (
    IN  PUNICODE_STRING RegistryPath,
    OUT PCONFIG * ConfigPtr);

VOID
SpxInitFreeConfiguration (
    IN PCONFIG Config);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxreg.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxreg.c

Abstract:

    This contains all routines necessary for the support of the dynamic
    configuration of the ISN SPX module.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//	Define module number for event logging entries
#define	FILENUM		SPXREG

// Local functions used to access the registry.
NTSTATUS
SpxInitReadIpxDeviceName(
    VOID);

NTSTATUS
SpxInitSetIpxDeviceName(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext);

NTSTATUS
SpxInitGetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, SpxInitGetConfiguration)
#pragma alloc_text(INIT, SpxInitFreeConfiguration)
#pragma alloc_text(INIT, SpxInitGetConfigValue)
#pragma alloc_text(INIT, SpxInitReadIpxDeviceName)
#pragma alloc_text(INIT, SpxInitSetIpxDeviceName)
#endif


NTSTATUS
SpxInitGetConfiguration (
    IN PUNICODE_STRING RegistryPath,
    OUT PCONFIG * ConfigPtr
    )

/*++

Routine Description:

    This routine is called by SPX to get information from the configuration
    management routines. We read the registry, starting at RegistryPath,
    to get the parameters. If they don't exist, we use the defaults
    set in ipxcnfg.h file. A list of adapters to bind to is chained
    on to the config information.

Arguments:

    RegistryPath - The name of ST's node in the registry.

    ConfigPtr - Returns the configuration information.

Return Value:

    Status - STATUS_SUCCESS if everything OK, STATUS_INSUFFICIENT_RESOURCES
            otherwise.

--*/
{
    NTSTATUS    Status;
    UINT        i;
    PWSTR       RegistryPathBuffer;
    PCONFIG     Config;
    RTL_QUERY_REGISTRY_TABLE QueryTable[CONFIG_PARAMETERS+2];

	ULONG Zero = 0;
    ULONG Two = 2;
    ULONG Four = 4;
    ULONG Five = 5;
    ULONG Eight = 8;
    ULONG Twelve = 12;
    ULONG Fifteen = 15;
    ULONG Thirty = 30;
    ULONG FiveHundred = 500;
	ULONG Hex4000 = 0x4000;
	ULONG Hex7FFF = 0x7FFF;
	ULONG FourK   = 4096;

    PWSTR Parameters = L"Parameters";
    struct {
        PWSTR KeyName;
        PULONG DefaultValue;
    } ParameterValues[CONFIG_PARAMETERS] = {
        { L"ConnectionCount",       &Five },
        { L"ConnectionTimeout",     &Two  },
        { L"InitPackets",           &Five },
        { L"MaxPackets",            &Thirty},
        { L"InitialRetransmissionTime", &FiveHundred},
        { L"KeepAliveCount",        &Eight},
        { L"KeepAliveTimeout",      &Twelve},
        { L"WindowSize",            &Four},
		{ L"SpxSocketRangeStart",	&Hex4000},
		{ L"SpxSocketRangeEnd",		&Hex7FFF},
		{ L"SpxSocketUniqueness",	&Eight},
		{ L"MaxPacketSize",         &FourK},
		{ L"RetransmissionCount",   &Eight},
		{ L"DisableSpx2",			&Zero},
		{ L"RouterMtu", 			&Zero},
		{ L"BackCompSpx", 			&Zero},
        { L"DisableRTT",            &Zero}
	};

    if (!NT_SUCCESS(SpxInitReadIpxDeviceName()))
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Allocate memory for the main config structure.
    Config = CTEAllocMem (sizeof(CONFIG));
    if (Config == NULL) {
		TMPLOGERR();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Config->cf_DeviceName.Buffer = NULL;

    // SpxReadLinkageInformation expects a null-terminated path,
    // so we have to create one from the UNICODE_STRING.
    RegistryPathBuffer = (PWSTR)CTEAllocMem(RegistryPath->Length + sizeof(WCHAR));

    if (RegistryPathBuffer == NULL) {

        SpxInitFreeConfiguration(Config);

		TMPLOGERR();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory (
		RegistryPathBuffer,
		RegistryPath->Buffer,
		RegistryPath->Length);

    *(PWCHAR)(((PUCHAR)RegistryPathBuffer)+RegistryPath->Length) = (WCHAR)'\0';

    Config->cf_RegistryPathBuffer = RegistryPathBuffer;

    // Read the per-transport (as opposed to per-binding)
    // parameters.
    //
    // Set up QueryTable to do the following:
    // 1) Switch to the Parameters key below SPX
    //

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Parameters;

    // 2-14) Call SpxSetBindingValue for each of the keys we
    // care about.
    for (i = 0; i < CONFIG_PARAMETERS; i++) {

        QueryTable[i+1].QueryRoutine = SpxInitGetConfigValue;
        QueryTable[i+1].Flags = 0;
        QueryTable[i+1].Name = ParameterValues[i].KeyName;
        QueryTable[i+1].EntryContext = UlongToPtr(i);
        QueryTable[i+1].DefaultType = REG_DWORD;
        QueryTable[i+1].DefaultData = (PVOID)(ParameterValues[i].DefaultValue);
        QueryTable[i+1].DefaultLength = sizeof(ULONG);
    }

    // 15) Stop
    QueryTable[CONFIG_PARAMETERS+1].QueryRoutine = NULL;
    QueryTable[CONFIG_PARAMETERS+1].Flags = 0;
    QueryTable[CONFIG_PARAMETERS+1].Name = NULL;


    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 Config->cf_RegistryPathBuffer,
                 QueryTable,
                 (PVOID)Config,
                 NULL);

    if (Status != STATUS_SUCCESS) {
        SpxInitFreeConfiguration(Config);

		TMPLOGERR();
        return Status;
    }

    CTEFreeMem (RegistryPathBuffer);
    *ConfigPtr = Config;

    return STATUS_SUCCESS;

}   // SpxInitGetConfiguration




VOID
SpxInitFreeConfiguration (
    IN PCONFIG Config
    )

/*++

Routine Description:

    This routine is called by SPX to get free any storage that was allocated
    by SpxGetConfiguration in producing the specified CONFIG structure.

Arguments:

    Config - A pointer to the configuration information structure.

Return Value:

    None.

--*/
{
    CTEFreeMem (Config);

}   // SpxInitFreeConfig




NTSTATUS
SpxInitGetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the Parameters
    node to set the config values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).

    ValueType - The type of the value (REG_DWORD -- ignored).

    ValueData - The data for the value.

    ValueLength - The length of ValueData (ignored).

    Context - A pointer to the CONFIG structure.

    EntryContext - The index in Config->Parameters to save the value.

Return Value:

    STATUS_SUCCESS

--*/

{
    PCONFIG Config = (PCONFIG)Context;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);
    UNREFERENCED_PARAMETER(ValueLength);

    if ((ValueType != REG_DWORD) || (ValueLength != sizeof(ULONG))) {
        return STATUS_INVALID_PARAMETER;
    }

    DBGPRINT(CONFIG, INFO,
			("Config parameter %d, value %lx\n",
                (ULONG_PTR)EntryContext, *(UNALIGNED ULONG *)ValueData));

    Config->cf_Parameters[(ULONG_PTR)EntryContext] = *(UNALIGNED ULONG *)ValueData;
    return STATUS_SUCCESS;

}   // SpxInitGetConfigValue




NTSTATUS
SpxInitReadIpxDeviceName(
    VOID
    )

{
    NTSTATUS                    Status;
    RTL_QUERY_REGISTRY_TABLE    QueryTable[2];
    PWSTR                       Export = L"Export";
    PWSTR                       IpxRegistryPath = IPX_REG_PATH;

    // Set up QueryTable to do the following:
    //
    // 1) Call SetIpxDeviceName for the string in "Export"
    QueryTable[0].QueryRoutine = SpxInitSetIpxDeviceName;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = Export;
    QueryTable[0].EntryContext = NULL;
    QueryTable[0].DefaultType = REG_NONE;

    // 2) Stop
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    Status = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                IpxRegistryPath,
                QueryTable,
                NULL,
                NULL);

    return Status;
}




NTSTATUS
SpxInitSetIpxDeviceName(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each piece of the "Export" multi-string and
    saves the information in a ConfigurationInfo structure.

Arguments:

    ValueName - The name of the value ("Export" -- ignored).

    ValueType - The type of the value (REG_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - NULL.

    EntryContext - NULL.

Return Value:

    status

--*/

{
    PWSTR       fileName;
    NTSTATUS    status  = STATUS_SUCCESS;

    fileName = (PWSTR)CTEAllocMem(ValueLength);
    if (fileName != NULL) {
        RtlCopyMemory(fileName, ValueData, ValueLength);
        RtlInitUnicodeString (&IpxDeviceName, fileName);
    }
    else
    {
        status  = STATUS_UNSUCCESSFUL;
    }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxsend.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxsend.c

Abstract:

    This module contains code that implements the send engine for the
    SPX transport provider.

Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


//	Define module number for event logging entries
#define	FILENUM		SPXSEND

VOID
SpxSendComplete(
    IN PNDIS_PACKET pNdisPkt,
    IN NDIS_STATUS  NdisStatus
    )

/*++

Routine Description:

    This routine is called by the I/O system to indicate that a connection-
    oriented packet has been shipped and is no longer needed by the Physical
    Provider.

Arguments:

    ProtocolBindingContext - The ADAPTER structure for this binding.

    NdisPacket/RequestHandle - A pointer to the NDIS_PACKET that we sent.

    NdisStatus - the completion status of the send.

Return Value:

    none.

--*/

{
	PSPX_CONN_FILE	pSpxConnFile;
	PSPX_SEND_RESD	pSendResd;
	PNDIS_BUFFER	pNdisBuffer;
	CTELockHandle	lockHandle;
	UINT			bufCount;
	PREQUEST		pRequest	= NULL;
	BOOLEAN			completeReq = FALSE, freePkt = FALSE,
					orphaned 	= FALSE, lockHeld = FALSE;

	pSendResd		= (PSPX_SEND_RESD)(pNdisPkt->ProtocolReserved);

#if DBG
	if (NdisStatus != NDIS_STATUS_SUCCESS)
	{
		DBGPRINT(SEND, DBG,
				("SpxSendComplete: For %lx with status **%lx**\n",
					pNdisPkt, NdisStatus));
	}
#endif
	//	IPX changes the length set for the first ndis buffer descriptor.
	//	Change it back to its original value here.
	NdisQueryPacket(pNdisPkt, NULL, &bufCount, &pNdisBuffer, NULL);
	NdisAdjustBufferLength(pNdisBuffer, IpxMacHdrNeeded	+ MIN_IPXSPX2_HDRSIZE);


	do
	{
		pSpxConnFile 	= pSendResd->sr_ConnFile;
		CTEGetLock(&pSpxConnFile->scf_Lock, &lockHandle);
		lockHeld = TRUE;
#if defined(__PNP)
        //
        // if IPX gave us a new LocalTarget, use for our next send.
        //
        // But if we are sending connect requests by iterating over NicIds,
        // dont update the local target bcoz that will mess up our iteration
        // logic.
        //
        if ( DEVICE_NETWORK_PATH_NOT_FOUND == NdisStatus
                    &&
             !(
                SPX_CONN_CONNECTING(pSpxConnFile) &&
                (SPX_CONNECT_STATE(pSpxConnFile) == SPX_CONNECT_SENTREQ) &&
                (*((UNALIGNED ULONG *)(pSpxConnFile->scf_RemAddr)) == 0)
               ) ) {

            pSpxConnFile->scf_LocalTarget = pSendResd->LocalTarget;

            //
            // Renegotiate the max packet size if we have an active SPX2
            // session going on and we negotiated the max size originally.
            //
            if ( SPX_MAIN_STATE(pSpxConnFile) == SPX_CONNFILE_ACTIVE &&
                 SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_SPX2) &&
                 SPX_CONN_FLAG(pSpxConnFile, SPX_CONNFILE_NEG)    ) {

                //
                // this call will get the local max size on this new local target
                // from IPX.
                //
                SPX_MAX_PKT_SIZE(pSpxConnFile, TRUE, TRUE, *((UNALIGNED ULONG *)pSpxConnFile->scf_RemAddr );
                SPX_SEND_SETSTATE(pSpxConnFile, SPX_SEND_RENEG);

                DBGPRINT(SEND, DBG3,
                                ("SpxConnProcessAck: %lx CONNECTION ENTERING RENEG\n",
                                        pSpxConnFile));
            }

        }
#endif  __PNP

		CTEAssert((pSendResd->sr_State & SPX_SENDPKT_IPXOWNS) != 0);
	
		//	IPX dont own this packet nomore.
		pSendResd->sr_State		&= ~SPX_SENDPKT_IPXOWNS;
	
		//	If a send packet has been aborted, then we need to call
		//	abort send to go ahead and free up this packet, and deref associated
		//	request, if there is one, potentially completing it.
		if ((pSendResd->sr_State & SPX_SENDPKT_ABORT) != 0)
		{
			spxConnAbortSendPkt(
				pSpxConnFile,
				pSendResd,
				SPX_CALL_TDILEVEL,
				lockHandle);

			lockHeld = FALSE;
			break;
		}

		//	If there is an associated request, remove reference on it. BUT for a
		//	sequenced packet only if it has been acked and is waiting for the request
		//	to be dereferenced. It is already dequeued from queue, just free it up.
		if ((((pSendResd->sr_State & SPX_SENDPKT_REQ) != 0) &&
			 ((pSendResd->sr_State & SPX_SENDPKT_SEQ) == 0)) ||
			((pSendResd->sr_State & SPX_SENDPKT_ACKEDPKT) != 0))
		{
			freePkt = (BOOLEAN)((pSendResd->sr_State & SPX_SENDPKT_ACKEDPKT) != 0);

			pRequest		= pSendResd->sr_Request;
			CTEAssert(pRequest != NULL);

			DBGPRINT(SEND, DBG,
					("IpxSendComplete: ReqRef before dec %lx.%lx\n",
						pRequest, REQUEST_INFORMATION(pRequest)));

			//	Deref the request and see if we complete it now. We always have our
			//	own reference on the request.
			//	!!! Status should already have been set in request...!!!
			if (--(REQUEST_INFORMATION(pRequest)) == 0)
			{
				CTEAssert(REQUEST_STATUS(pRequest) != STATUS_PENDING);

				completeReq	= TRUE;

				//	If this is acked already, request is not on list.
				//	BUG #11626
				if ((pSendResd->sr_State & SPX_SENDPKT_ACKEDPKT) == 0)
				{
					RemoveEntryList(REQUEST_LINKAGE(pRequest));
				}
			}
		}
	
		//	Do we destroy this packet?
		if ((pSendResd->sr_State & SPX_SENDPKT_DESTROY) != 0)
		{
			//	Remove this packet from the send list in the connection.
			DBGPRINT(SEND, INFO,
					("IpxSendComplete: destroy packet...\n"));

			SpxConnDequeueSendPktLock(pSpxConnFile, pNdisPkt);
			freePkt = TRUE;	
		}

	} while (FALSE);

	if (lockHeld)
	{
		CTEFreeLock(&pSpxConnFile->scf_Lock, lockHandle);
	}

	if (freePkt)
	{
		DBGPRINT(SEND, INFO,
				("IpxSendComplete: free packet...\n"));

		SpxPktSendRelease(pNdisPkt);
	}

	if (completeReq)
	{
		//	If this is a send request, set info to data sent, else it will be
		//	zero.
		if (REQUEST_MINOR_FUNCTION(pRequest) == TDI_SEND)
		{
			PTDI_REQUEST_KERNEL_SEND	pParam;

			pParam 	= (PTDI_REQUEST_KERNEL_SEND)
						REQUEST_PARAMETERS(pRequest);

			REQUEST_INFORMATION(pRequest) = pParam->SendLength;
			DBGPRINT(SEND, DBG,
					("IpxSendComplete: complete req %lx.%lx...\n",
						REQUEST_STATUS(pRequest),
						REQUEST_INFORMATION(pRequest)));
	
			CTEAssert(pRequest != NULL);
			CTEAssert(REQUEST_STATUS(pRequest) != STATUS_PENDING);
			SpxCompleteRequest(pRequest);
		}
		else
		{
			DBGPRINT(SEND, DBG,
					("SpxSendComplete: %lx DISC Request %lx with %lx.%lx\n",
						pSpxConnFile, pRequest, REQUEST_STATUS(pRequest),
						REQUEST_INFORMATION(pRequest)));

			DBGPRINT(SEND, DBG,
					("SpxSendComplete: %lx.%lx.%lx\n",
						pSpxConnFile->scf_RefCount,
						pSpxConnFile->scf_Flags,
						pSpxConnFile->scf_Flags2));

			//	Set the request in the connection, and deref for it.
			InsertTailList(
				&pSpxConnFile->scf_DiscLinkage,
				REQUEST_LINKAGE(pRequest));
		}

		SpxConnFileDereference(pSpxConnFile, CFREF_VERIFY);
	}

    return;

}   //  SpxSendComplete




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxsend.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxsend.h

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/


VOID
SpxSendComplete(
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS  NdisStatus);

VOID
SpxSendPktRelease(
	IN	PNDIS_PACKET	pPkt,
	IN	UINT			BufCount);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxtimer.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	spxtimer.h

Abstract:

	This module contains routines to schedule timer events.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	TIMER_DONT_REQUEUE		0
#define	TIMER_REQUEUE_CUR_VALUE	1

typedef	ULONG (*TIMER_ROUTINE)(IN PVOID Context, IN BOOLEAN TimerShuttingDown);

extern
NTSTATUS
SpxTimerInit(
	VOID);

extern
ULONG
SpxTimerScheduleEvent(
	IN	TIMER_ROUTINE	Worker,		// Routine to invoke when time expires
	IN	ULONG			DeltaTime,	// Schedule after this much time
	IN	PVOID			pContext);	// Context to pass to the routine

extern
VOID
SpxTimerFlushAndStop(
	VOID);

extern
BOOLEAN
SpxTimerCancelEvent(
	IN	ULONG	TimerId,
	IN	BOOLEAN	ReEnqueue);

#define	TMR_SIGNATURE		*(PULONG)"ATMR"
#if	DBG
#define	VALID_TMR(pTmr)		(((pTmr) != NULL) && \
							 ((pTmr)->tmr_Signature == TMR_SIGNATURE))
#else                   	
#define	VALID_TMR(pTmr)		((pTmr) != NULL)
#endif
typedef	struct _TimerList
{
#if	DBG
	ULONG					tmr_Signature;
#endif
	struct _TimerList *		tmr_Next;		// Link to next
	struct _TimerList **	tmr_Prev;		// Link to prev
	struct _TimerList *		tmr_Overflow;	// Link to overflow entry in hash table
	ULONG					tmr_AbsTime;	// Absolute time, for re-enqueue
	ULONG					tmr_RelDelta;	// Relative to the previous entry
	ULONG					tmr_Id;			// Unique Id for this event
	BOOLEAN					tmr_Cancelled;	// Was the timer cancelled?
	TIMER_ROUTINE			tmr_Worker;		// Real Worker
	PVOID					tmr_Context;	// Real context
} TIMERLIST, *PTIMERLIST;


#define	SpxGetCurrentTime()	(SpxTimerCurrentTime/SPX_TIMER_FACTOR)
#define	SpxGetCurrentTick()	SpxTimerCurrentTime

// Keep this at a ONE second level.
#define	SPX_TIMER_FACTOR	10				// i.e. 10 ticks per second
#define	SPX_MS_TO_TICKS		100				// Divide ms by this to get ticks
#define	SPX_TIMER_TICK		-1000000L		// 100ms in 100ns units
#define	SPX_TIMER_WAIT		50				// Time to wait in FlushAndStop in ms
#define	TIMER_HASH_TABLE	32

VOID
spxTimerDpcRoutine(
	IN	PKDPC	pKDpc,
	IN	PVOID	pContext,
	IN	PVOID	SystemArgument1,
	IN	PVOID	SystemArgument2);

VOID
spxTimerWorker(
	IN	PTIMERLIST	pList);

VOID
spxTimerEnqueue(
	PTIMERLIST	pListNew);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxtimer.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	spxtimer.c

Abstract:

	This file implements the timer routines used by the stack.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)


Revision History:
	23 Feb 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include "precomp.h"
#pragma hdrstop

//	Define module number for event logging entries
#define	FILENUM		SPXTIMER

//  Discardable code after Init time
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, SpxTimerInit)
#endif

//	Globals for this module
PTIMERLIST			spxTimerList 					= NULL;
PTIMERLIST			spxTimerTable[TIMER_HASH_TABLE]	= {0};
PTIMERLIST			spxTimerActive					= NULL;
CTELock     		spxTimerLock      				= {0};
LARGE_INTEGER		spxTimerTick					= {0};
KTIMER				spxTimer						= {0};
KDPC				spxTimerDpc						= {0};
ULONG				spxTimerId 						= 1;
LONG				spxTimerCount 					= 0;
USHORT				spxTimerDispatchCount 			= 0;
BOOLEAN				spxTimerStopped 				= FALSE;


NTSTATUS
SpxTimerInit(
	VOID
	)
/*++

Routine Description:

 	Initialize the timer component for the appletalk stack.

Arguments:


Return Value:


--*/
{
#if      !defined(_PNP_POWER)
	BOOLEAN	TimerStarted;
#endif  !_PNP_POWER

	// Initialize the timer and its associated Dpc. timer will be kicked
    // off when we get the first card arrival notification from ipx
	KeInitializeTimer(&spxTimer);
	CTEInitLock(&spxTimerLock);
	KeInitializeDpc(&spxTimerDpc, spxTimerDpcRoutine, NULL);
	spxTimerTick = RtlConvertLongToLargeInteger(SPX_TIMER_TICK);
#if      !defined(_PNP_POWER)
	TimerStarted = KeSetTimer(&spxTimer,
							  spxTimerTick,
							  &spxTimerDpc);
	CTEAssert(!TimerStarted);
#endif  !_PNP_POWER
	return STATUS_SUCCESS;
}




ULONG
SpxTimerScheduleEvent(
	IN	TIMER_ROUTINE		Worker,		// Routine to invoke when time expires
	IN	ULONG				MsTime,		// Schedule after this much time
	IN	PVOID				pContext	// Context(s) to pass to the routine
	)
/*++

Routine Description:

 	Insert an event in the timer event list. If the list is empty, then
 	fire off a timer. The time is specified in ms. We convert to ticks.
	Each tick is currently 100ms. It may not be zero or negative. The internal
	timer fires at 100ms granularity.

Arguments:


Return Value:


--*/
{
	PTIMERLIST		pList;
	CTELockHandle	lockHandle;
	ULONG			DeltaTime;
	ULONG			Id = 0;

	//	Convert to ticks.
	DeltaTime	= MsTime/SPX_MS_TO_TICKS;
	if (DeltaTime == 0)
	{
		DBGPRINT(SYSTEM, INFO,
				("SpxTimerScheduleEvent: Converting %ld to ticks %ld\n",
					MsTime, DeltaTime));

		DeltaTime = 1;
	}

	DBGPRINT(SYSTEM, INFO,
			("SpxTimerScheduleEvent: Converting %ld to ticks %ld\n",
				MsTime, DeltaTime));

	// Negative or Zero DeltaTime is invalid.
	CTEAssert (DeltaTime > 0);
			
	DBGPRINT(SYSTEM, INFO,
			("SpxTimerScheduleEvent: Routine %lx, Time %d, Context %lx\n",
			Worker, DeltaTime, pContext));

	CTEGetLock(&spxTimerLock, &lockHandle);

	if (spxTimerStopped)
	{
		DBGPRINT(SYSTEM, FATAL,
				("SpxTimerScheduleEvent: Called after Flush !!\n"));
	}

	else do
	{
		pList = SpxBPAllocBlock(BLKID_TIMERLIST);

		if (pList == NULL)
		{
			break;
		}

#if	DBG
		pList->tmr_Signature = TMR_SIGNATURE;
#endif
		pList->tmr_Cancelled = FALSE;
		pList->tmr_Worker = Worker;
		pList->tmr_AbsTime = DeltaTime;
		pList->tmr_Context = pContext;
		
		Id = pList->tmr_Id = spxTimerId++;

		// Take care of wrap around
		if (spxTimerId == 0)
			spxTimerId = 1;

		// Enqueue this handler
		spxTimerEnqueue(pList);
	} while (FALSE);

	CTEFreeLock(&spxTimerLock, lockHandle);

	return Id;
}



VOID
spxTimerDpcRoutine(
	IN	PKDPC	pKDpc,
	IN	PVOID	pContext,
	IN	PVOID	SystemArgument1,
	IN	PVOID	SystemArgument2
	)
/*++

Routine Description:

 	This is called in at DISPATCH_LEVEL when the timer expires. The entry at
 	the head of the list is decremented and if ZERO unlinked and dispatched.
 	If the list is non-empty, the timer is fired again.

Arguments:


Return Value:


--*/
{
	PTIMERLIST		pList, *ppList;
	BOOLEAN			TimerStarted;
	ULONG			ReEnqueueTime;
	CTELockHandle	lockHandle;

	pKDpc; pContext; SystemArgument1; SystemArgument2;

#if     defined(_PNP_POWER)
	CTEGetLock(&spxTimerLock, &lockHandle);
	if (spxTimerStopped)
	{
		DBGPRINT(SYSTEM, ERR,
				("spxTimerDpc: Enetered after Flush !!!\n"));

        CTEFreeLock(&spxTimerLock, lockHandle);
		return;
	}
#else
	if (spxTimerStopped)
	{
		DBGPRINT(SYSTEM, ERR,
				("spxTimerDpc: Enetered after Flush !!!\n"));
		return;
	}

	CTEGetLock(&spxTimerLock, &lockHandle);
#endif  _PNP_POWER

	SpxTimerCurrentTime ++;	// Update our relative time

#ifdef	PROFILING
	//	This is the only place where this is changed. And it always increases.
	SpxStatistics.stat_ElapsedTime = SpxTimerCurrentTime;
#endif

	// We should never be here if we have no work to do
	if ((spxTimerList != NULL))
	{
		// Careful here. If two guys wanna go off together - let them !!
		if (spxTimerList->tmr_RelDelta != 0)
			(spxTimerList->tmr_RelDelta)--;
	
		// Dispatch the entry if it is ready to go
		if (spxTimerList->tmr_RelDelta == 0)
		{
			pList = spxTimerList;
			CTEAssert(VALID_TMR(pList));

			// Unlink from the list
			spxTimerList = pList->tmr_Next;
			if (spxTimerList != NULL)
				spxTimerList->tmr_Prev = &spxTimerList;

			// Unlink from the hash table now
			for (ppList = &spxTimerTable[pList->tmr_Id % TIMER_HASH_TABLE];
				 *ppList != NULL;
				 ppList = &((*ppList)->tmr_Overflow))
			{
				CTEAssert(VALID_TMR(*ppList));
				if (*ppList == pList)
				{
					*ppList = pList->tmr_Overflow;
					break;
				}
			}

			CTEAssert (*ppList == pList->tmr_Overflow);

			DBGPRINT(SYSTEM, INFO,
					("spxTimerDpcRoutine: Dispatching %lx\n",
					pList->tmr_Worker));

			spxTimerDispatchCount ++;
			spxTimerCount --;
			spxTimerActive = pList;
			CTEFreeLock(&spxTimerLock, lockHandle);

			//	If reenqueue time is 0, do not requeue. If 1, then requeue with
			//	current value, else use value specified.
			ReEnqueueTime = (*pList->tmr_Worker)(pList->tmr_Context, FALSE);
			DBGPRINT(SYSTEM, INFO,
					("spxTimerDpcRoutine: Reenequeu time %lx.%lx\n",
						ReEnqueueTime, pList->tmr_AbsTime));

			CTEGetLock(&spxTimerLock, &lockHandle);

			spxTimerActive = NULL;
			spxTimerDispatchCount --;

			if (ReEnqueueTime != TIMER_DONT_REQUEUE)
			{
				// If this chappie was cancelled while it was running
				// and it wants to be re-queued, do it right away.
				if (pList->tmr_Cancelled)
				{
					(*pList->tmr_Worker)(pList->tmr_Context, FALSE);
					SpxBPFreeBlock(pList, BLKID_TIMERLIST);
				}
				else
				{
					if (ReEnqueueTime != TIMER_REQUEUE_CUR_VALUE)
					{
						pList->tmr_AbsTime = ReEnqueueTime/SPX_MS_TO_TICKS;
						if (pList->tmr_AbsTime == 0)
						{
							DBGPRINT(SYSTEM, INFO,
									("SpxTimerDispatch: Requeue at %ld\n",
										pList->tmr_AbsTime));
						}
						DBGPRINT(SYSTEM, INFO,
								("SpxTimerDispatch: Requeue at %ld.%ld\n",
									ReEnqueueTime, pList->tmr_AbsTime));
					}

					spxTimerEnqueue(pList);
				}
			}
			else
			{
				SpxBPFreeBlock(pList, BLKID_TIMERLIST);
			}
		}
	}

#if     defined(_PNP_POWER)
	if (!spxTimerStopped)
	{
		TimerStarted = KeSetTimer(&spxTimer,
								  spxTimerTick,
								  &spxTimerDpc);

        // it is possible that while we were here in Dpc, PNP_ADD_DEVICE
        // restarted the timer, so this assert is commented out for PnP
//		CTEAssert(!TimerStarted);
	}

	CTEFreeLock(&spxTimerLock, lockHandle);
#else
	CTEFreeLock(&spxTimerLock, lockHandle);

	if (!spxTimerStopped)
	{
		TimerStarted = KeSetTimer(&spxTimer,
								  spxTimerTick,
								  &spxTimerDpc);
		CTEAssert(!TimerStarted);
	}
#endif  _PNP_POWER
}


VOID
spxTimerEnqueue(
	IN	PTIMERLIST	pListNew
	)
/*++

Routine Description:

 	Here is a thesis on the code that follows.

 	The timer events are maintained as a list which the timer dpc routine
 	looks at every timer tick. The list is maintained in such a way that only
 	the head of the list needs to be updated every tick i.e. the entire list
 	is never scanned. The way this is achieved is by keeping delta times
 	relative to the previous entry.

 	Every timer tick, the relative time at the head of the list is decremented.
 	When that goes to ZERO, the head of the list is unlinked and dispatched.

 	To give an example, we have the following events queued at time slots
 	X			Schedule A after 10 ticks.
 	X+3			Schedule B after 5  ticks.
 	X+5			Schedule C after 4  ticks.
 	X+8			Schedule D after 6  ticks.

 	So A will schedule at X+10, B at X+8 (X+3+5), C at X+9 (X+5+4) and
 	D at X+14 (X+8+6).

 	The above example covers all the situations.

 	- NULL List.
 	- Inserting at head of list.
 	- Inserting in the middle of the list.
 	- Appending to the list tail.

 	The list will look as follows.

 		    BEFORE                          AFTER
 		    ------                          -----

     X   Head -->|                  Head -> A(10) ->|
     A(10)

     X+3 Head -> A(7) ->|           Head -> B(5) -> A(2) ->|
     B(5)

     X+5 Head -> B(3) -> A(2) ->|   Head -> B(3) -> C(1) -> A(1) ->|
     C(4)

     X+8 Head -> C(1) -> A(1) ->|   Head -> C(1) -> A(1) -> D(4) ->|
     D(6)

 	The granularity is one tick. THIS MUST BE CALLED WITH THE TIMER LOCK HELD.

Arguments:


Return Value:


--*/
{
	PTIMERLIST	pList, *ppList;
	ULONG		DeltaTime = pListNew->tmr_AbsTime;
	
	// The DeltaTime is adjusted in every pass of the loop to reflect the
	// time after the previous entry that the new entry will schedule.
	for (ppList = &spxTimerList;
		 (pList = *ppList) != NULL;
		 ppList = &pList->tmr_Next)
	{
		CTEAssert(VALID_TMR(pList));
		if (DeltaTime <= pList->tmr_RelDelta)
		{
			pList->tmr_RelDelta -= DeltaTime;
			break;
		}
		DeltaTime -= pList->tmr_RelDelta;
	}
	

	// Link this in the chain
	pListNew->tmr_RelDelta = DeltaTime;
	pListNew->tmr_Next = pList;
	pListNew->tmr_Prev = ppList;
	*ppList = pListNew;
	if (pList != NULL)
	{
		pList->tmr_Prev = &pListNew->tmr_Next;
	}

	// Now link it in the hash table
	pListNew->tmr_Overflow = spxTimerTable[pListNew->tmr_Id % TIMER_HASH_TABLE];
	spxTimerTable[pListNew->tmr_Id % TIMER_HASH_TABLE] = pListNew;
	spxTimerCount ++;
}




VOID
SpxTimerFlushAndStop(
	VOID
	)
/*++

Routine Description:

 	Force all entries in the timer queue to be dispatched immediately. No
 	more queue'ing of timer routines is permitted after this. The timer
 	essentially shuts down.

Arguments:


Return Value:


--*/
{
	PTIMERLIST		pList;
	CTELockHandle	lockHandle;

	CTEAssert (KeGetCurrentIrql() == LOW_LEVEL);

	DBGPRINT(SYSTEM, ERR,
			("SpxTimerFlushAndStop: Entered\n"));

	CTEGetLock(&spxTimerLock, &lockHandle);

	spxTimerStopped = TRUE;

	KeCancelTimer(&spxTimer);

	if (spxTimerList != NULL)
	{
		// Dispatch all entries right away
		while (spxTimerList != NULL)
		{
			pList = spxTimerList;
			CTEAssert(VALID_TMR(pList));
			spxTimerList = pList->tmr_Next;

			DBGPRINT(SYSTEM, INFO,
					("spxTimerFlushAndStop: Dispatching %lx\n",
					pList->tmr_Worker));

			// The timer routines assume they are being called at DISPATCH
			// level. This is OK since we are calling with SpinLock held.

			(*pList->tmr_Worker)(pList->tmr_Context, TRUE);

			spxTimerCount --;
			SpxBPFreeBlock(pList, BLKID_TIMERLIST);
		}
		RtlZeroMemory(spxTimerTable, sizeof(spxTimerTable));
	}

	CTEFreeLock(&spxTimerLock, lockHandle);

	// Wait for all timer routines to complete
	while (spxTimerDispatchCount != 0)
	{
		SpxSleep(SPX_TIMER_WAIT);
	}
}




BOOLEAN
SpxTimerCancelEvent(
	IN	ULONG	TimerId,
	IN	BOOLEAN	ReEnqueue
	)
/*++

Routine Description:

 	Cancel a previously scheduled timer event, if it hasn't fired already.

Arguments:


Return Value:


--*/
{
	PTIMERLIST		pList, *ppList;
	CTELockHandle	lockHandle;

	DBGPRINT(SYSTEM, INFO,
			("SpxTimerCancelEvent: Entered for TimerId %ld\n", TimerId));

	CTEAssert(TimerId != 0);

	CTEGetLock(&spxTimerLock, &lockHandle);

	for (ppList = &spxTimerTable[TimerId % TIMER_HASH_TABLE];
		 (pList = *ppList) != NULL;
		 ppList = &pList->tmr_Overflow)
	{
		CTEAssert(VALID_TMR(pList));
		// If we find it, cancel it
		if (pList->tmr_Id == TimerId)
		{
			// Unlink this from the hash table
			*ppList = pList->tmr_Overflow;

			// ... and from the list
			if (pList->tmr_Next != NULL)
			{
				pList->tmr_Next->tmr_RelDelta += pList->tmr_RelDelta;
				pList->tmr_Next->tmr_Prev = pList->tmr_Prev;
			}
			*(pList->tmr_Prev) = pList->tmr_Next;

			spxTimerCount --;
			if (ReEnqueue)
				 spxTimerEnqueue(pList);
			else SpxBPFreeBlock(pList, BLKID_TIMERLIST);
			break;
		}
	}

	// If we could not find it in the list, see if it currently running.
	// If so mark him to not reschedule itself, only if reenqueue was false.
	if (pList == NULL)
	{
		if ((spxTimerActive != NULL) &&
			(spxTimerActive->tmr_Id == TimerId) &&
			!ReEnqueue)
		{
	        spxTimerActive->tmr_Cancelled = TRUE;
		}
	}

	CTEFreeLock(&spxTimerLock, lockHandle);

	DBGPRINT(SYSTEM, INFO,
			("SpxTimerCancelEvent: %s for Id %ld\n",
				(pList != NULL) ? "Success" : "Failure", TimerId));

	return (pList != NULL);
}




#if	DBG

VOID
SpxTimerDumpList(
	VOID
	)
{
	PTIMERLIST		pList;
	ULONG			CumTime = 0;
	CTELockHandle	lockHandle;

	DBGPRINT(DUMP, FATAL,
			("TIMER LIST: (Times are in %dms units\n", 1000));
	DBGPRINT(DUMP, FATAL,
			("\tTimerId  Time(Abs)  Time(Rel)  Routine Address\n"));

	CTEGetLock(&spxTimerLock, &lockHandle);

	for (pList = spxTimerList;
		 pList != NULL;
		 pList = pList->tmr_Next)
	{
		CumTime += pList->tmr_RelDelta;
		DBGPRINT(DUMP, FATAL,
				("\t% 6lx      %5d      %5ld         %lx\n",
				pList->tmr_Id, pList->tmr_AbsTime, CumTime, pList->tmr_Worker));
	}

	CTEFreeLock(&spxTimerLock, lockHandle);
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\winsock\wshisn.c ===
/****************************************************************************
* (c) Copyright 1993 Micro Computer Systems, Inc. All rights reserved.
*****************************************************************************
*
*   Title:    IPX/SPX WinSock Helper DLL for Windows NT
*
*   Module:   ipx/sockhelp/wshnwlnk.c
*
*   Version:  1.00.00
*
*   Date:     04-08-93
*
*   Author:   Brian Walker
*
*****************************************************************************
*
*   Change Log:
*
*   Date     DevSFC   Comment
*   -------- ------   -------------------------------------------------------
*
*****************************************************************************
*
*   Functional Description:
*
****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <tdi.h>

#include <winsock.h>
#include <wsahelp.h>
#include <wsipx.h>
#include <wsnwlink.h>

/*page****************************************************************
       These are the triples we support.
*********************************************************************/
typedef struct _MAPPING_TRIPLE {
    INT triple_addrfam;
    INT triple_socktype;
    INT triple_protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;

MAPPING_TRIPLE stream_triples[] = {
    { AF_NS,   SOCK_STREAM,    NSPROTO_SPX },
    { AF_NS,   SOCK_SEQPACKET, NSPROTO_SPX },
    { AF_NS,   SOCK_STREAM,    NSPROTO_SPXII },
    { AF_NS,   SOCK_SEQPACKET, NSPROTO_SPXII },
};
int stream_num_triples = 4;                     /* When SPXII - set to 4 */
int stream_table_size = sizeof(stream_triples);

/**
    For IPX we assign the default packet type according to the
    protocol type used.  The user can also we setsockopt
    to set the packet type.
**/

MAPPING_TRIPLE dgram_triples[] = {
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX     },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+1   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+2   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+3   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+4   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+5   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+6   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+7   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+8   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+9   },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+10  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+11  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+12  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+13  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+14  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+15  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+16  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+17  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+18  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+19  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+20  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+21  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+22  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+23  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+24  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+25  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+26  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+27  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+28  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+29  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+30  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+31  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+32  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+33  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+34  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+35  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+36  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+37  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+38  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+39  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+40  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+41  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+42  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+43  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+44  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+45  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+46  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+47  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+48  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+49  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+50  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+51  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+52  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+53  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+54  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+55  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+56  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+57  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+58  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+59  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+60  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+61  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+62  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+63  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+64  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+65  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+66  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+67  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+68  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+69  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+70  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+71  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+72  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+73  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+74  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+75  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+76  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+77  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+78  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+79  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+80  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+81  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+82  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+83  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+84  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+85  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+86  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+87  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+88  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+89  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+90  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+91  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+92  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+93  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+94  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+95  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+96  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+97  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+98  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+99  },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+100 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+101 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+102 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+103 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+104 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+105 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+106 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+107 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+108 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+109 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+110 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+111 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+112 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+113 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+114 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+115 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+116 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+117 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+118 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+119 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+120 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+121 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+122 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+123 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+124 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+125 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+126 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+127 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+128 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+129 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+130 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+131 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+132 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+133 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+134 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+135 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+136 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+137 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+138 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+139 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+140 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+141 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+142 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+143 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+144 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+145 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+146 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+147 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+148 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+149 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+150 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+151 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+152 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+153 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+154 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+155 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+156 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+157 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+158 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+159 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+160 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+161 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+162 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+163 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+164 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+165 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+166 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+167 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+168 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+169 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+170 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+171 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+172 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+173 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+174 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+175 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+176 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+177 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+178 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+179 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+180 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+181 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+182 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+183 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+184 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+185 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+186 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+187 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+188 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+189 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+190 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+191 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+192 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+193 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+194 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+195 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+196 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+197 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+198 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+199 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+200 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+201 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+202 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+203 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+204 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+205 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+206 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+207 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+208 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+209 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+210 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+211 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+212 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+213 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+214 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+215 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+216 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+217 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+218 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+219 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+220 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+221 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+222 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+223 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+224 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+225 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+226 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+227 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+228 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+229 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+230 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+231 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+232 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+233 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+234 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+235 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+236 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+237 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+238 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+239 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+240 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+241 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+242 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+243 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+244 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+245 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+246 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+247 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+248 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+249 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+250 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+251 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+252 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+253 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+254 },
    { AF_NS,     SOCK_DGRAM, NSPROTO_IPX+255 }
};
int dgram_num_triples = 256;
int dgram_table_size = sizeof(dgram_triples);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxutils.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxutils.h				

Abstract:


Author:

    Nikhil Kamkolkar (nikhilk) 11-November-1993

Environment:

    Kernel mode

Revision History:


--*/

//	For PROTO_SPX, i'd return a device name from the dll of the form
//	\Device\NwlnkSpx\SpxStream (for SOCK_STREAM) or
//	\Device\NwlnkSpx\Spx       (for SOCK_SEQPKT)
//	
//	and for PROTO_SPXII (the more common case we hope, even if
//	internally we degrade to SPX1 cause of the remote client's
//	limitations)
//	\Device\NwlnkSpx\Stream        (for SOCK_STREAM) or
//	\Device\NwlnkSpx               (for SOCK_SEQPKT)

#define	SOCKET1STREAM_SUFFIX		L"\\SpxStream"
#define	SOCKET1_SUFFIX				L"\\Spx"
#define	SOCKET2STREAM_SUFFIX		L"\\Stream"
#define	SOCKET1_TYPE_SEQPKT			0	
#define	SOCKET2_TYPE_SEQPKT			1
#define	SOCKET1_TYPE_STREAM			2
#define	SOCKET2_TYPE_STREAM			3

#define	IN_RANGE(_S, _RangeStart, _RangeEnd)		\
		((_S >= _RangeStart) && (_S <= _RangeEnd))


//
// The following macros deal with on-the-wire integer and long values
//
// On the wire format is big-endian i.e. a long value of 0x01020304 is
// represented as 01 02 03 04. Similarly an int value of 0x0102 is
// represented as 01 02.
//
// The host format is not assumed since it will vary from processor to
// processor.
//

// Get a byte from on-the-wire format to a short in the host format
#define GETBYTE2SHORT(DstPtr, SrcPtr)	\
		*(PUSHORT)(DstPtr) = (USHORT) (*(PBYTE)(SrcPtr))

// Get a byte from on-the-wire format to a short in the host format
#define GETBYTE2ULONG(DstPtr, SrcPtr)	\
		*(PULONG)(DstPtr) = (ULONG) (*(PBYTE)(SrcPtr))

// Get a short from on-the-wire format to a dword in the host format
#define GETSHORT2ULONG(DstPtr, SrcPtr)	\
		*(PULONG)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 8) +	\
							  (*((PBYTE)(SrcPtr)+1)		))

// Get a short from on-the-wire format to a dword in the host format
#define GETSHORT2SHORT(DstPtr, SrcPtr)	\
		*(PUSHORT)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 8) +	\
							  (*((PBYTE)(SrcPtr)+1)		))

// Get a dword from on-the-wire format to a dword in the host format
#define GETULONG2ULONG(DstPtr, SrcPtr)   \
		*(PULONG)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 24) + \
							  (*((PBYTE)(SrcPtr)+1) << 16) + \
							  (*((PBYTE)(SrcPtr)+2) << 8)  + \
							  (*((PBYTE)(SrcPtr)+3)	))

// Get a dword from on-the-wire format to a dword in the same format but
// also watch out for alignment
#define GETULONG2ULONG_NOCONV(DstPtr, SrcPtr)   \
		*((PBYTE)(DstPtr)+0) = *((PBYTE)(SrcPtr)+0); \
		*((PBYTE)(DstPtr)+1) = *((PBYTE)(SrcPtr)+1); \
		*((PBYTE)(DstPtr)+2) = *((PBYTE)(SrcPtr)+2); \
		*((PBYTE)(DstPtr)+3) = *((PBYTE)(SrcPtr)+3);

// Put a dword from the host format to a short to on-the-wire format
#define PUTBYTE2BYTE(DstPtr, Src)   \
		*((PBYTE)(DstPtr)) = (BYTE)(Src)

// Put a dword from the host format to a short to on-the-wire format
#define PUTSHORT2BYTE(DstPtr, Src)   \
		*((PBYTE)(DstPtr)) = ((USHORT)(Src) % 256)

// Put a dword from the host format to a short to on-the-wire format
#define PUTSHORT2SHORT(DstPtr, Src)   \
		*((PBYTE)(DstPtr)+0) = (BYTE) ((USHORT)(Src) >> 8), \
		*((PBYTE)(DstPtr)+1) = (BYTE)(Src)

// Put a dword from the host format to a byte to on-the-wire format
#define PUTULONG2BYTE(DstPtr, Src)   \
		*(PBYTE)(DstPtr) = (BYTE)(Src)

// Put a dword from the host format to a short to on-the-wire format
#define PUTULONG2SHORT(DstPtr, Src)   \
		*((PBYTE)(DstPtr)+0) = (BYTE) ((ULONG)(Src) >> 8), \
		*((PBYTE)(DstPtr)+1) = (BYTE) (Src)

// Put a dword from the host format to a dword to on-the-wire format
#define PUTULONG2ULONG(DstPtr, Src)   \
		*((PBYTE)(DstPtr)+0) = (BYTE) ((ULONG)(Src) >> 24), \
		*((PBYTE)(DstPtr)+1) = (BYTE) ((ULONG)(Src) >> 16), \
		*((PBYTE)(DstPtr)+2) = (BYTE) ((ULONG)(Src) >>  8), \
		*((PBYTE)(DstPtr)+3) = (BYTE) (Src)

// Put a BYTE[4] array into another BYTE4 array.
#define PUTBYTE42BYTE4(DstPtr, SrcPtr)   \
		*((PBYTE)(DstPtr)+0) = *((PBYTE)(SrcPtr)+0),	\
		*((PBYTE)(DstPtr)+1) = *((PBYTE)(SrcPtr)+1),	\
		*((PBYTE)(DstPtr)+2) = *((PBYTE)(SrcPtr)+2),	\
		*((PBYTE)(DstPtr)+3) = *((PBYTE)(SrcPtr)+3)

//	MIN/MAX macros
#define	MIN(a, b)	(((a) < (b)) ? (a) : (b))
#define	MAX(a, b)	(((a) > (b)) ? (a) : (b))




//	Exported prototypes

UINT
SpxUtilWstrLength(
	IN PWSTR Wstr);

LONG
SpxRandomNumber(
	VOID);

NTSTATUS
SpxUtilGetSocketType(
	PUNICODE_STRING 	RemainingFileName,
	PBYTE				SocketType);

VOID
SpxSleep(
	IN	ULONG	TimeInMs);

ULONG
SpxBuildTdiAddress(
    IN PVOID AddressBuffer,
    IN ULONG AddressBufferLength,
    IN UCHAR Network[4],
    IN UCHAR Node[6],
    IN USHORT Socket);

VOID
SpxBuildTdiAddressFromIpxAddr(
    IN PVOID 		AddressBuffer,
    IN PBYTE	 	pIpxAddr);

TDI_ADDRESS_IPX UNALIGNED *
SpxParseTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress);

BOOLEAN
SpxValidateTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress,
    IN ULONG TransportAddressLength);

VOID
SpxCalculateNewT1(
	IN	struct _SPX_CONN_FILE	* 	pSpxConnFile,
	IN	int							NewT1);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\idlole\makefile.inc ===
$(O)\alg.idl: alg.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ipmsp.idl: ipmsp.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\confpriv.idl: confpriv.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\h323priv.idl: h323priv.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\hnetbcon.idl: hnetbcon.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\hnetcfg.idl: hnetcfg.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\hnautoc.idl: hnautoc.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ih26xcd.idl: ih26xcd.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\msp.idl: msp.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\natupnp.idl: natupnp.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\netcfgn.idl: netcfgn.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\netcfgx.idl: netcfgx.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\netcon.idl: netcon.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\netmon.idl: netmon.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\prsht.idl: prsht.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\rend.idl: rend.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\sdoias.idl: sdoias.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tapi3cc.idl: tapi3cc.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tapi3ds.idl: tapi3ds.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tapi3if.idl: tapi3if.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\termmgr.idl: termmgr.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\rtccore.idl: rtccore.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\upnp.idl: upnp.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\upnphost.idl: upnphost.idl
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_ROOT)\inc\$(O)\cxq_cust.h: $(O)\cxq_cust.h
    -copy /v $? $@

$(PROJECT_ROOT)\inc\$(O)\iaspolcy.h: $(O)\iaspolcy.h
    -copy /v $? $@

$(PROJECT_ROOT)\inc\$(O)\iaspolcy.idl: iaspolcy.idl
    -copy /v $? $@

$(PROJECT_ROOT)\inc\$(O)\ippmcb.h: $(O)\ippmcb.h
    -copy /v $? $@

$(PROJECT_ROOT)\inc\$(O)\netmon.idl: netmon.idl
    -copy /v $? $@
    
$(PROJECT_ROOT)\inc\$(O)\upnpp.h: $(O)\upnpp.h
    -copy /v $? $@

$(PROJECT_ROOT)\inc\$(O)\upnpp.idl: upnpp.idl
    -copy /v $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\winsock\wshelper.c ===
/****************************************************************************
* (c) Copyright 1993 Micro Computer Systems, Inc. All rights reserved.
*****************************************************************************
*
*   Title:    IPX WinSock Helper DLL for Windows NT
*
*   Module:   ipx/sockhelp/wshelper.c
*
*   Version:  1.00.00
*
*   Date:     04-08-93
*
*   Author:   Brian Walker
*
*****************************************************************************
*
*   Change Log:
*
*   Date     DevSFC   Comment
*   -------- ------   -------------------------------------------------------
*
*****************************************************************************
*
*   Functional Description:
*
****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <tdi.h>

#include <winsock2.h>
#include <wsahelp.h>
#include <basetyps.h>
#include <nspapi.h>
#include <nspapip.h>
#include <wsipx.h>
#include <wsnwlink.h>

#include <isnkrnl.h>

#include <stdio.h>

#if defined(UNICODE)
#define NWLNKSPX_SERVICE_NAME L"nwlnkspx"
#else
#define NWLNKSPX_SERVICE_NAME "nwlnkspx"
#endif


typedef struct _IPX_OLD_ADDRESS_DATA {
    UINT adapternum;
    UCHAR netnum[4];
    UCHAR nodenum[6];
} IPX_OLD_ADDRESS_DATA, *PIPX_OLD_ADDRESS_DATA;


/** Device names for IPX sockets **/

#define ISNDGRAM_DEVNAME        L"\\Device\\NwlnkIpx"

/** Device names for SPX/SPXII sockets **/

#define ISNSTREAM_DEVNAME       L"\\Device\\NwlnkSpx\\SpxStream"
#define ISNSEQPKT_DEVNAME       L"\\Device\\NwlnkSpx\\Spx"

#define ISNSTREAMII_DEVNAME     L"\\Device\\NwlnkSpx\\Stream"
#define ISNSEQPKTII_DEVNAME     L"\\Device\\NwlnkSpx"

/** Friendly names for IPX and SPX. **/

#define SPX_NAME                L"SPX"
#define SPX2_NAME               L"SPX II"
#define IPX_NAME                L"IPX"

/** Start for IPX protocol families **/

#define MCSBASE_DGRAM           NSPROTO_IPX

#define BUFFER_SIZE 40

/** **/

UCHAR wsh_bcast[6] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

//  SPX Loaded flag, set for each process
BOOLEAN SpxLoaded = FALSE;

//
// IPX/SPX provider GUIDs.
//

GUID IpxProviderGuid =
         { /* 11058240-be47-11cf-95c8-00805f48a192 */
             0x11058240,
             0xbe47,
             0x11cf,
             { 0x95, 0xc8, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}
         };

GUID SpxProviderGuid =
         { /* 11058241-be47-11cf-95c8-00805f48a192 */
             0x11058241,
             0xbe47,
             0x11cf,
             { 0x95, 0xc8, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}
         };

/** Forward Decls/External Prototypes **/
DWORD
WshLoadSpx(
    VOID);

extern
INT
do_tdi_action(
    HANDLE,
    ULONG,
    PUCHAR,
    INT,
    BOOLEAN,
    PHANDLE OPTIONAL);

/*page****************************************************************
       These are the triples we support.
*********************************************************************/
typedef struct _MAPPING_TRIPLE {
    INT triple_addrfam;
    INT triple_socktype;
    INT triple_protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;
#define MAPPING_NUM_COLUMNS     3

extern MAPPING_TRIPLE stream_triples[];
extern int stream_num_triples;
extern int stream_table_size;

extern MAPPING_TRIPLE dgram_triples[];
extern int dgram_num_triples;
extern int dgram_table_size;

/** Forward declarations on internal routines **/

BOOLEAN is_triple_in_list(PMAPPING_TRIPLE, ULONG, INT, INT, INT);

/**
    There is one of these structures allocated for every
    socket that is created for us.
**/

typedef struct _WSHIPX_SOCKET_CONTEXT {
    INT con_addrfam;
    INT con_socktype;
    INT con_pcol;
    INT con_flags;
    UCHAR con_sendptype;        /* Current send packet type     */
    UCHAR con_recvptype;        /* Recv ptype we are filtering on */
    UCHAR con_dstype;           /* Datastream type              */
} WSHIPX_SOCKET_CONTEXT, *PWSHIPX_SOCKET_CONTEXT;

/** Values for con_flags **/

#define WSHCON_FILTER       0x0001  /* We are filtering on recv pkt type */
#define WSHCON_EXTADDR      0x0002  /* Extended addressing is on         */
#define WSHCON_SENDHDR      0x0004  /* Send header flag                  */
#define WSHCON_RCVBCAST     0x0008  /* It does receive broadcasts        */
#define WSHCON_IMM_SPXACK   0x0020  /* Immediate spx acks no piggyback   */

/*page***************************************************************
       W S H O p e n S o c k e t

       This is called for the socket call.  We make sure that
       we support the address family/socket type/protocol triple
       given and then we will allocate some memory to keep track
       of the socket.

       Arguments - addrfam  = Entry: Address family from socket call
                       Exit:  Filled in address family
            socktype = Entry: Socket type from socket call
                       Exit:  Filled in socket type
            pcol     = Entry: Protocol from socket call
                       Exit:  Filled in protocol
            devname  = Ptr to where to store device name
            pcontext = Where to store context value
            events   = Bitmask for events we want to know about

       Returns - NO_ERROR = OK
          Else = WinSock Error Code
*********************************************************************/
INT WSHOpenSocket(PINT addrfam, PINT socktype, PINT pcol,
          PUNICODE_STRING devname, PVOID *pcontext, PDWORD events)
{
    PWSHIPX_SOCKET_CONTEXT context;

    /** Determine whether this is DGRAM or STREAM or SEQPACKET **/

    if (is_triple_in_list(stream_triples, stream_num_triples,
                  *addrfam, *socktype, *pcol)) {

       if (*socktype == SOCK_SEQPACKET) {
           if (*pcol == NSPROTO_SPX)
               RtlInitUnicodeString(devname, ISNSEQPKT_DEVNAME);
           else
               RtlInitUnicodeString(devname, ISNSEQPKTII_DEVNAME);
       }
       else {
           if (*pcol == NSPROTO_SPX)
               RtlInitUnicodeString(devname, ISNSTREAM_DEVNAME);
           else
               RtlInitUnicodeString(devname, ISNSTREAMII_DEVNAME);
       }

       if (!SpxLoaded) {

           WshLoadSpx();

       }
    }

    /** Check for DGRAM **/

    else if (is_triple_in_list(dgram_triples, dgram_num_triples,
                       *addrfam, *socktype, *pcol)) {

       RtlInitUnicodeString(devname, ISNDGRAM_DEVNAME);
    }

    /**
       All others are errors.   This should never happen unless
       the registry information is wrong.
    **/

    else
       return WSAEINVAL;

    /** Allocate context for the socket **/

    context = RtlAllocateHeap(RtlProcessHeap(), 0L, sizeof(*context));
    if (context == NULL)
       return WSAENOBUFS;

    /** Init the context **/

    context->con_addrfam   = *addrfam;
    context->con_socktype  = *socktype;
    context->con_pcol      = *pcol;
    context->con_flags     = WSHCON_RCVBCAST;
    context->con_sendptype = (UCHAR)(*pcol - MCSBASE_DGRAM);
    context->con_recvptype = 0;
    context->con_dstype    = 0;

    /**
       Tell the Windows Sockets DLL which state transitions we
       are interested in.
    **/

    *events = WSH_NOTIFY_CLOSE | WSH_NOTIFY_BIND | WSH_NOTIFY_CONNECT;

    /** Give WinSock DLL our context pointer **/

    *pcontext = context;

    /** Everything OK - return OK **/

    return NO_ERROR;
}

/*page**************************************************************
       W S H G e t S o c k A d d r T y p e

       This routine parses a sockaddr to determine the type
       of machine address and endpoint address portions of the
       sockaddr.  This is called by the WinSock DLL whenever it
       needs to interpret a sockaddr.

       Arguments - sockaddr      = Ptr to sockaddr struct to evaluate
            sockaddrlen  = Length of data in the sockaddr
            sockaddrinfo = Ptr to structure to recv info
                           about the sockaddr

       Returns - NO_ERROR = Evaluation OK
          Else = WinSock error code
********************************************************************/
INT WSHGetSockaddrType(PSOCKADDR sockaddr, DWORD sockaddrlen,
               PSOCKADDR_INFO sockaddrinfo)
{
    PSOCKADDR_IPX sa = (PSOCKADDR_IPX)sockaddr;


    /** Make sure the address family is correct **/

    if (sa->sa_family != AF_NS)
       return WSAEAFNOSUPPORT;

    /** Make sure the length is OK **/

    if (sockaddrlen < sizeof(SOCKADDR_IPX))
       return WSAEFAULT;

    /** Looks like a good addr - determine the type **/

    if (!memcmp(sa->sa_nodenum, wsh_bcast, 6))
       sockaddrinfo->AddressInfo = SockaddrAddressInfoBroadcast;
    else
       sockaddrinfo->AddressInfo = SockaddrAddressInfoNormal;

    /** Determine the endpoint **/

    if (sa->sa_socket == 0)
       sockaddrinfo->EndpointInfo = SockaddrEndpointInfoWildcard;
    else if (ntohs(sa->sa_socket) < 2000)
       sockaddrinfo->EndpointInfo = SockaddrEndpointInfoReserved;
    else
       sockaddrinfo->EndpointInfo = SockaddrEndpointInfoNormal;

    /** **/

    return NO_ERROR;
}

/*page**************************************************************
       W S H G e t W i n s o c k M a p p i n g

       Returns the list of address family/socket type/protocol
       triples supported by this helper DLL.

       Arguments - mapping = Contect ptr from WSAOpenSocket
            maplen  =

       Returns - The length in bytes of a eeded OK
          Else = WinSock error code
********************************************************************/
DWORD WSHGetWinsockMapping(PWINSOCK_MAPPING mapping, DWORD maplen)
{
    DWORD len;

    /**
       Figure how much data we are going to copy into
       the user buffer.
    **/

    len = sizeof(WINSOCK_MAPPING) - sizeof(MAPPING_TRIPLE) +
         dgram_table_size + stream_table_size;

    /**
       If the buffer passed is too small, then return the size
       that is needed.  The caller should then call us again
       with a buffer of the correct size.
    **/

    if (len > maplen)
       return len;

    /** Fill in the output buffer **/

    mapping->Rows    = stream_num_triples + dgram_num_triples;
    mapping->Columns = MAPPING_NUM_COLUMNS;
    RtlMoveMemory(mapping->Mapping,
          stream_triples,
          stream_table_size);

    RtlMoveMemory((PCHAR)mapping->Mapping + stream_table_size,
          dgram_triples,
          dgram_table_size);

    /** Return the number of bytes we filled in **/

    return len;
}

/*page***************************************************************
       W S H N o t i f y

       This routine is called for events that we registered at
       open socket time.

       Arguments - context    = Context ptr from WSAOpenSocket
            handle     = Socket handle
            addrhandle = Datagram Handle
            connhandle = Connection Handle
            event      = What event happened

       Returns - NO_ERROR = Operation succeeded OK
          Else = WinSock error code
*********************************************************************/
INT WSHNotify(PVOID context, SOCKET handle,
             HANDLE addrhandle, HANDLE connhandle,
             DWORD event)
{
    INT rc;
    INT t1;
    PWSHIPX_SOCKET_CONTEXT ct;

    /** Get context pointer **/

    ct = (PWSHIPX_SOCKET_CONTEXT)context;

    /** On close - just free the context structure **/

    if (event == WSH_NOTIFY_CLOSE) {
       RtlFreeHeap(RtlProcessHeap(), 0L, context);
       return NO_ERROR;
    }

    /** On bind set the send packet type **/

    if (event == WSH_NOTIFY_BIND)
    {
        if (ct->con_socktype == SOCK_DGRAM)
        {
            /** Set the send packet ptype **/
            t1 = (UINT)ct->con_sendptype;
            rc = WSHSetSocketInformation(
                    context, handle, addrhandle,
                    connhandle, NSPROTO_IPX,
                    IPX_PTYPE, (PCHAR)&t1, sizeof(INT));

            if (rc)
                return rc;

            if (ct->con_flags & WSHCON_EXTADDR)
            {
                t1 = 1;
                rc = WSHSetSocketInformation(
                        context, handle, addrhandle,
                        connhandle, NSPROTO_IPX,
                        IPX_EXTENDED_ADDRESS, (PCHAR)&t1, sizeof(INT));

                if (rc)
                    return rc;
            }

            /** Set the recv filter packet type **/

            if (ct->con_flags & WSHCON_FILTER)
            {
                t1 = (UINT)ct->con_recvptype;
                rc = WSHSetSocketInformation(
                        context, handle, addrhandle,
                        connhandle, NSPROTO_IPX,
                        IPX_FILTERPTYPE, (PCHAR)&t1, sizeof(INT));

                if (rc)
                    return rc;
            }

            /** Set up broadcast reception **/

            if (ct->con_flags & WSHCON_RCVBCAST)
            {

                t1 = 1;
                rc = WSHSetSocketInformation(
                        context, handle, addrhandle,
                        connhandle, NSPROTO_IPX,
                        IPX_RECEIVE_BROADCAST, (PCHAR)&t1, sizeof(INT));

                if (rc)
                    return rc;
            }

            /** Enable send header if we need to **/
            if (ct->con_flags & WSHCON_SENDHDR)
            {
                t1 = 1;
                rc = WSHSetSocketInformation(
                        context, handle, addrhandle,
                        connhandle, NSPROTO_IPX,
                        IPX_RECVHDR, (PCHAR)&t1, sizeof(INT));

                if (rc)
                    return rc;
            }
        }
        else if ((ct->con_socktype == SOCK_STREAM) ||
                (ct->con_socktype == SOCK_SEQPACKET))
        {
            if (ct->con_flags & WSHCON_SENDHDR)
            {
                t1 = 1;
                rc = WSHSetSocketInformation(
                        context, handle, addrhandle,
                        connhandle, NSPROTO_IPX,
                        IPX_RECVHDR, (PCHAR)&t1, sizeof(INT));

                if (rc)
                    return rc;
            }

            if (ct->con_flags & WSHCON_IMM_SPXACK)
            {
                t1 = 1;
                rc = WSHSetSocketInformation(
                        context, handle, addrhandle,
                        connhandle, NSPROTO_IPX,
                        IPX_IMMEDIATESPXACK, (PCHAR)&t1, sizeof(INT));

                if (rc)
                    return rc;
            }
        }

        /** It is OK - return OK **/
        return NO_ERROR;
    }

    /** On connect set things not set already **/
    if (event == WSH_NOTIFY_CONNECT)
    {

        /** If on DGRAM - just return OK **/
        if (ct->con_socktype == SOCK_DGRAM)
            return NO_ERROR;

        /**
           If the datastream type has been set - set it
       **/

        if (ct->con_dstype)
        {
            rc = do_tdi_action(connhandle, MSPX_SETDATASTREAM, &ct->con_dstype, 1, FALSE, NULL);
            if (rc)
                return rc;
        }

        /** It is OK - return OK **/
        return NO_ERROR;
    }

    /** All others are bad **/
    return WSAEINVAL;
}


/*page**************************************************************
       W S H G e t S o c k I n f o r m a t i o n

       This routine retrieves information about a socket for those
       socket options supported in this DLL.  The options
       supported here are SO_KEEPALIVE and SO_DONTROUTE.  This
       routine is called by the WinSock DLL when a level/option name
       combination is passed to getsockopt that the WinSock DLL
       does not understand.

       Arguments - context    = Context ptr from WSAOpenSocket
            handle     = Socket handle
            addrhandle = Datagram Handle
            connhandle = Connection Handle
            level      = Level from getsockopt call
            optname    = Option name from getsockopt call
            optvalue   = Option value ptr from getsockopt call
            optlength  = Option length field from getsockopt call

       Returns - NO_ERROR = Operation succeeded OK
          Else = WinSock error code
********************************************************************/
INT WSHGetSocketInformation(PVOID context, SOCKET handle,
                    HANDLE addrhandle, HANDLE connhandle,
                    INT level, INT optname, PCHAR optvalue,
                    PINT optlength)
{
    PWSHIPX_SOCKET_CONTEXT ct;
    INT rc;
    INT ibuf[2];
    PIPX_ADDRESS_DATA p;

    /** Get ptr to context **/

    ct = (PWSHIPX_SOCKET_CONTEXT)context;

    //
    // Check if this is an internal request for context information.
    //

    if ( level == SOL_INTERNAL && optname == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting context information
        // from us.  If an output buffer was not supplied, the Windows
        // Sockets DLL is just requesting the size of our context
        // information.
        //

        if ( optvalue != NULL ) {

            //
            // Make sure that the buffer is sufficient to hold all the
            // context information.
            //

            if ( *optlength < sizeof(*ct) ) {
                return WSAEFAULT;
            }

            //
            // Copy in the context information.
            //

            RtlCopyMemory( optvalue, ct, sizeof(*ct) );
        }

        *optlength = sizeof(*ct);

        return NO_ERROR;
    }

    /** The only level we support is NSPROTO_IPX **/

    if (level != NSPROTO_IPX)
       return WSAEINVAL;

    /** Fill in the result based on the options name **/

    switch (optname) {

    /** Get the current send packet type **/

    case IPX_PTYPE:

       /** Make sure the length is OK **/

       if (*optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Set the type **/

       *(UINT *)optvalue = (UINT)ct->con_sendptype;
       *optlength = sizeof(UINT);
       break;

    /** Get the current recv packet type filter **/

    case IPX_FILTERPTYPE:

       /** Make sure length is OK **/

       if (*optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** If option not on - return error **/

       if (!(ct->con_flags & WSHCON_FILTER))
           return WSAEINVAL;

       /** Save the new value **/

       *(UINT *)optvalue = (UINT)ct->con_recvptype;
       *optlength = sizeof(UINT);
       break;

    /** Get the max DGRAM size that can be sent **/

    case IPX_MAXSIZE:

       /** Make sure length is OK **/

       if (*optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Get the value from the driver **/

       rc = do_tdi_action(addrhandle, MIPX_GETPKTSIZE, (PUCHAR)ibuf, sizeof(INT)*2, TRUE, NULL);

       *(INT *)optvalue = ibuf[1];
       *optlength = sizeof(int);

       /** Return the result **/

       return rc;

    /** Get the max adapternum that is valid **/

    case IPX_MAX_ADAPTER_NUM:

       /** Make sure length is OK **/

       if (*optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Get the value from the driver **/

       rc = do_tdi_action(addrhandle, MIPX_ADAPTERNUM, optvalue, sizeof(INT), TRUE, NULL);

       *optlength = sizeof(int);

       /** Return the result **/

       return rc;

    /** Get SPX statistics **/

    case IPX_SPXGETCONNECTIONSTATUS:

        /** Make sure data length OK **/

        if (*optlength < sizeof(IPX_SPXCONNSTATUS_DATA))
            return WSAEFAULT;

        /** Make sure this is for a STREAM socket **/

        if ((ct->con_socktype != SOCK_STREAM) &&
            (ct->con_socktype != SOCK_SEQPACKET)) {

            return WSAEINVAL;
        }

        /** Send it to the driver **/

        rc = do_tdi_action(
                connhandle,
                MSPX_GETSTATS,
                optvalue,
                *optlength,
                FALSE,
                NULL);

        if (rc)
            return rc;

        *optlength = sizeof(IPX_SPXCONNSTATUS_DATA);

        /** Return OK **/

        return NO_ERROR;

    /** Get the current datastream type to send pkts with **/

    case IPX_DSTYPE:

       /** Make sure length is OK **/

       if (*optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a STREAM socket **/

       if ((ct->con_socktype != SOCK_STREAM) &&
           (ct->con_socktype != SOCK_SEQPACKET)) {

           return WSAEINVAL;
       }

       /** Save the new value **/

       *(UINT *)optvalue = (UINT)ct->con_dstype;
       *optlength = sizeof(UINT);
       break;

    /** Get net information **/

    case IPX_GETNETINFO:

       /** Make sure data length OK **/

       if (*optlength < sizeof(IPX_NETNUM_DATA))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Send it to the driver **/

       rc = do_tdi_action(
                addrhandle,
                MIPX_GETNETINFO,
                optvalue,
                *optlength,
                TRUE,
                NULL);

       if (rc) {
           return rc;
       }

       *optlength = sizeof(IPX_NETNUM_DATA);

       /** Return OK **/

       return NO_ERROR;

    /** Get net information without RIPping **/

    case IPX_GETNETINFO_NORIP:

       /** Make sure data length OK **/

       if (*optlength < sizeof(IPX_NETNUM_DATA))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Send it to the driver **/

       rc = do_tdi_action(
                addrhandle,
                MIPX_GETNETINFO_NR,
                optvalue,
                *optlength,
                TRUE,
                NULL);

       if (rc) {
           return rc;
       }

       *optlength = sizeof(IPX_NETNUM_DATA);

       /** Return OK **/

       return NO_ERROR;

    /** Like GETNETINFO, but force a re-rip **/

    case IPX_RERIPNETNUMBER:

       /** Make sure data length OK **/

       if (*optlength < sizeof(IPX_NETNUM_DATA))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Send it to the driver **/

       rc = do_tdi_action(
                addrhandle,
                MIPX_RERIPNETNUM,
                optvalue,
                *optlength,
                TRUE,
                NULL);

       if (rc) {
           return rc;
       }

       *optlength = sizeof(IPX_NETNUM_DATA);

       /** Return OK **/

       return NO_ERROR;

    /** Get card information **/

    case IPX_ADDRESS_NOTIFY:

       /** We need the action header, the data, and the event handle **/

       if (*optlength < (INT)(FIELD_OFFSET(NWLINK_ACTION, Data[0]) + sizeof(IPX_ADDRESS_DATA) + sizeof(HANDLE)))
           return WSAEFAULT;

       /** Otherwise just fall through **/

    case IPX_ADDRESS:

       /** Make sure data length OK **/

       if (*optlength < sizeof(IPX_OLD_ADDRESS_DATA))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Send it to the driver **/

       if (optname == IPX_ADDRESS) {

           rc = do_tdi_action(
                    addrhandle,
                    MIPX_GETCARDINFO,
                    optvalue,
                    *optlength,
                    TRUE,
                    NULL);

       } else {

           rc = do_tdi_action(
                    addrhandle,
                    MIPX_NOTIFYCARDINFO,
                    optvalue,
                    *optlength - sizeof(HANDLE),
                    TRUE,
                    (PHANDLE)(optvalue + FIELD_OFFSET(NWLINK_ACTION, Data[0]) + sizeof(IPX_ADDRESS_DATA)));
       }

       if (rc) {
           p = (PIPX_ADDRESS_DATA)optvalue;
           memset(p->netnum, 0xFF, 4);
           memset(p->nodenum, 0xFF, 6);
           return rc;
       }

       /** Return OK **/

       if (*optlength < sizeof(IPX_ADDRESS_DATA)) {
           *optlength = sizeof(IPX_OLD_ADDRESS_DATA);
       } else if (*optlength < sizeof(IPX_ADDRESS_DATA)) {
           *optlength = sizeof(IPX_ADDRESS_DATA);
       }

       return NO_ERROR;

    /** All others are error **/

    default:
       return WSAENOPROTOOPT;
    }

    /** All is OK **/

    return NO_ERROR;
}

/*page***************************************************************
       W S H S e t S o c k e t I n f o r m a t i o n

       This routine sets information about a socket for those
       options supported in this helper DLL.  This routine
       is called when a setsockopt call is made and the option/level
       passed is unknown to the WinSock DLL.

       Arguments - context    = Context ptr from WSAOpenSocket
            handle     = Socket handle
            addrhandle = Datagram Handle
            connhandle = Connection Handle
            level      = Level from getsockopt call
            optname    = Option name from getsockopt call
            optvalue   = Option value ptr from getsockopt call
            optlength  = Option length field from getsockopt call

       Returns - NO_ERROR = Operation succeeded OK
          Else = WinSock error code
*********************************************************************/
INT WSHSetSocketInformation(PVOID context, SOCKET handle,
                    HANDLE addrhandle, HANDLE connhandle,
                    INT level, INT optname, PCHAR optvalue,
                    INT optlength)
{
    PWSHIPX_SOCKET_CONTEXT ct;
    INT rc;

    /** Get ptr to context **/

    ct = (PWSHIPX_SOCKET_CONTEXT)context;

    //
    // Check if this is an internal request for context information.
    //

    if ( level == SOL_INTERNAL && optname == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting that we set context
        // information for a new socket.  If the new socket was
        // accept()'ed, then we have already been notified of the socket
        // and HelperDllSocketContext will be valid.  If the new socket
        // was inherited or duped into this process, then this is our
        // first notification of the socket and HelperDllSocketContext
        // will be equal to NULL.
        //
        // Insure that the context information being passed to us is
        // sufficiently large.
        //

        if ( optlength < sizeof(*ct) ) {
            return WSAEINVAL;
        }

        if ( ct == NULL ) {

            //
            // This is our notification that a socket handle was
            // inherited or duped into this process.  Allocate a context
            // structure for the new socket.
            //

            ct = RtlAllocateHeap( RtlProcessHeap( ), 0, sizeof(*ct) );
            if ( ct == NULL ) {
                return WSAENOBUFS;
            }

            //
            // Copy over information into the context block.
            //

            RtlCopyMemory( ct, optvalue, sizeof(*ct) );

            //
            // Tell the Windows Sockets DLL where our context information is
            // stored so that it can return the context pointer in future
            // calls.
            //

            *(PWSHIPX_SOCKET_CONTEXT *)optvalue = ct;

            return NO_ERROR;

        } else {

            PWSHIPX_SOCKET_CONTEXT parentContext;
            INT one = 1;

            //
            // The socket was accept()'ed and it needs to have the same
            // properties as it's parent.  The OptionValue buffer
            // contains the context information of this socket's parent.
            //

            parentContext = (PWSHIPX_SOCKET_CONTEXT)optvalue;

            ASSERT( ct->con_addrfam == parentContext->con_addrfam );
            ASSERT( ct->con_socktype == parentContext->con_socktype );
            ASSERT( ct->con_pcol == parentContext->con_pcol );

            return NO_ERROR;
        }
    }

    /** We only support level NSPROTO_IPX **/

    if (level != NSPROTO_IPX)
       return WSAEINVAL;

    /** Handle the options **/

    switch (optname) {

    /** Set the send packet type **/

    case IPX_PTYPE:

       /** Make sure length is OK **/

       if (optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Get the value and check it **/

       rc = *(INT *)optvalue;
       if ((rc < 0) || (rc > 255))
           return WSAEINVAL;

       /** Save the new value **/

       ct->con_sendptype = (UCHAR)rc;

       /** Send the new value down to the driver **/

       if (addrhandle)
           rc = do_tdi_action(addrhandle, MIPX_SETSENDPTYPE, &ct->con_sendptype, 1, TRUE, NULL);
       else
           rc = NO_ERROR;

       return rc;

    /** Set the recv filter for packet type **/

    case IPX_FILTERPTYPE:

       /** Make sure length is OK **/

       if (optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Get the value and check it **/

       rc = *(INT *)optvalue;
       if ((rc < 0) || (rc > 255))
           return WSAEINVAL;

       /** Save the new value **/

       ct->con_recvptype = (UCHAR)rc;
       ct->con_flags |= WSHCON_FILTER;

       /** Send the new value down to the driver **/

       if (addrhandle)
           rc = do_tdi_action(addrhandle, MIPX_FILTERPTYPE, &ct->con_recvptype, 1, TRUE, NULL);
       else
           rc = NO_ERROR;

       /** **/

       return rc;

    /** Stop filtering recv on pkt type **/

    case IPX_STOPFILTERPTYPE:

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Turn off the flag **/

       ct->con_flags &= ~WSHCON_FILTER;

       /** Tell the driver **/

       if (addrhandle)
           rc = do_tdi_action(addrhandle, MIPX_NOFILTERPTYPE, NULL, 0, TRUE, NULL);
       else
           rc = NO_ERROR;
       break;

    /** Set piggyback wait for backtraffic flag **/
    case IPX_IMMEDIATESPXACK:

       /** Get the optvalue as an INT **/

       rc = *(INT *)optvalue;

       /** **/

        if (rc)
        {
            /** Turn it ON **/
            rc = WSAEINVAL;
            if ((ct->con_socktype == SOCK_STREAM) ||
                (ct->con_socktype == SOCK_SEQPACKET))
            {
                rc = NO_ERROR;

                ct->con_flags |= WSHCON_IMM_SPXACK;

                if (addrhandle)
                    rc = do_tdi_action(addrhandle, MSPX_NOACKWAIT, NULL, 0, TRUE, NULL);
            }
        }
        else
        {
            /** Turn it OFF **/
            rc = WSAEINVAL;
            if ((ct->con_socktype == SOCK_STREAM) ||
                (ct->con_socktype == SOCK_SEQPACKET))
            {
                rc = NO_ERROR;

                ct->con_flags &= ~WSHCON_IMM_SPXACK;

                if (addrhandle)
                    rc = do_tdi_action(addrhandle, MSPX_ACKWAIT, NULL, 0, TRUE, NULL);
            }
       }

       /** Return the result **/
       return rc;

    /** Set to recv pcol hdrs with data **/

    case IPX_RECVHDR:

        /** Get the optvalue as an INT **/
        rc = *(INT *)optvalue;

        if (rc)
        {
            /** Turn it ON **/
            ct->con_flags |= WSHCON_SENDHDR;

            /** Send it to the driver **/
            rc = WSAEINVAL;
            if (ct->con_socktype == SOCK_DGRAM)
            {
                rc = NO_ERROR;
                if (addrhandle)
                    rc = do_tdi_action(addrhandle, MIPX_SENDHEADER, NULL, 0, TRUE, NULL);
            }
            else if ((ct->con_socktype == SOCK_STREAM) ||
                    (ct->con_socktype == SOCK_SEQPACKET))
            {
                /** Do this on address handle **/
                rc = NO_ERROR;
                if (addrhandle)
                    rc = do_tdi_action(addrhandle, MSPX_SENDHEADER, NULL, 0, TRUE, NULL);
            }
        }
        else
        {

            /** Turn it OFF **/
            ct->con_flags &= ~WSHCON_SENDHDR;

            /** Send it to the driver **/
            rc = WSAEINVAL;
            if (ct->con_socktype == SOCK_DGRAM)
            {
                rc = NO_ERROR;
                if (addrhandle)
                    rc = do_tdi_action(addrhandle, MIPX_NOSENDHEADER, NULL, 0, TRUE, NULL);
            }
            else if ((ct->con_socktype == SOCK_STREAM) ||
                     (ct->con_socktype == SOCK_SEQPACKET))
            {
                rc = NO_ERROR;
                if (addrhandle)
                    rc = do_tdi_action(addrhandle, MSPX_NOSENDHEADER, NULL, 0, TRUE, NULL);
            }
        }

        /** Return the result **/
        return rc;

    /** Set the Datastream type to send pkts with **/

    case IPX_DSTYPE:

       /** Make sure length is OK **/

       if (optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a STREAM socket **/

       if ((ct->con_socktype != SOCK_STREAM) &&
           (ct->con_socktype != SOCK_SEQPACKET)) {

           return WSAEINVAL;
       }

       /** Get the value and check it **/

       rc = *(INT *)optvalue;
       if ((rc < 0) || (rc > 255))
           return WSAEINVAL;

       /** Save the new value **/

       ct->con_dstype = (UCHAR)rc;

       /** Send the new value down to the driver **/

       if (connhandle)
           rc = do_tdi_action(connhandle, MSPX_SETDATASTREAM, &ct->con_dstype, 1, FALSE, NULL);
       else
           rc = 0;

       /** **/

       return rc;

    /** Set the extended address option **/

    case IPX_EXTENDED_ADDRESS:

       /** Make sure length is OK **/

       if (optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Get the optvalue as an INT **/

       rc = *(INT *)optvalue;

       /** **/

        if (rc) {

           /** Send the option down to the driver **/

           ct->con_flags |= WSHCON_EXTADDR;
           if (addrhandle)
               rc = do_tdi_action(addrhandle, MIPX_SENDADDROPT, NULL, 0, TRUE, NULL);
           else
               rc = NO_ERROR;
       }
       else {

           /** Send the option down to the driver **/

           ct->con_flags &= ~WSHCON_EXTADDR;
           if (addrhandle)
               rc = do_tdi_action(addrhandle, MIPX_NOSENDADDROPT, NULL, 0, TRUE, NULL);
           else
               rc = NO_ERROR;
       }
       return rc;


    /** Set the broadcast reception **/

    case IPX_RECEIVE_BROADCAST:

       /** Make sure length is OK **/

       if (optlength < sizeof(INT))
           return WSAEFAULT;

       /** Make sure this is for a DGRAM socket **/

       if (ct->con_socktype != SOCK_DGRAM)
           return WSAEINVAL;

       /** Get the optvalue as an INT **/

       rc = *(INT *)optvalue;

       /** **/

        if (rc) {

           /** Send the option down to the driver **/

           ct->con_flags |= WSHCON_RCVBCAST;
           if (addrhandle)
               rc = do_tdi_action(addrhandle, MIPX_RCVBCAST, NULL, 0, TRUE, NULL);
           else
               rc = NO_ERROR;
       }
       else {

           /** Send the option down to the driver **/

           ct->con_flags &= ~WSHCON_RCVBCAST;
           if (addrhandle)
               rc = do_tdi_action(addrhandle, MIPX_NORCVBCAST, NULL, 0, TRUE, NULL);
           else
               rc = NO_ERROR;
       }
       return rc;

    /** All others return error **/

    default:
       return WSAENOPROTOOPT;
    }

    /** All Done OK **/

    return NO_ERROR;
}

/*page***************************************************************
       W S H G e t W i l d c a r d S o c k a d d r

       This routing returns a wilcard socket address for the
       sockets DLL to use.

       Arguments - context    = Context ptr from WSAOpenSocket
            addrp      = Ptr to where to store the address
            addrlen    = Ptr to where to store length of address

       Returns - NO_ERROR = Operation succeeded OK
          Else = WinSock error code
*********************************************************************/
INT WSHGetWildcardSockaddr(PVOID context, PSOCKADDR addrp, PINT addrlen)
{

    /**
       Setup the address as the address family +
       all 0's for the rest.
    **/

    memset(addrp, 0, sizeof(SOCKADDR));
    addrp->sa_family = AF_NS;

    /** Set the address length **/

    *addrlen = sizeof(SOCKADDR);

    /** Return OK **/

    return NO_ERROR;
}

/*page***************************************************************
       i s _ t r i p l e _ i n _ l i s t

       Check to see if the given triple is in the given
       triple list.

       Arguments - tlist    = Ptr to the triple list
            tlen     = Num entries in the triple list
            addrfam  = Address family to look for
            socktype = Socket Type to look for
            pcol     = Protocol to look for

       Returns - TRUE   = Yes
          FALSE = No
*********************************************************************/
BOOLEAN is_triple_in_list(PMAPPING_TRIPLE tlist, ULONG tlen,
                  INT addrfam, INT socktype, INT pcol)
{
    ULONG i;

    /**
       Go thru the list and search to see if we can
       find the given triple in the list.
    **/

    for (i = 0 ; i < tlen ; i++,tlist++) {

       /** If it matches - return OK **/

       if ((addrfam  == tlist->triple_addrfam) &&
           (socktype == tlist->triple_socktype) &&
           (pcol     == tlist->triple_protocol))

           return TRUE;
    }

    /** Not Found **/

    return FALSE;
}

/*page***************************************************************
       W S H E n u m P r o t o c o l s

       Enumerates IPX/SPX protocols.

       Returns - NO_ERROR or an error code.
*********************************************************************/
INT
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPTSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    DWORD bytesRequired;
    PPROTOCOL_INFOW protocolInfo;
    BOOL useSpx = FALSE;
    BOOL useSpx2 = FALSE;
    BOOL useIpx = FALSE;
    BOOL spxString;
    DWORD i;
    PWCHAR namePtr;
    INT entriesReturned = 0;

    //
    // Determine whether we should return information for IPX or SPX.
    //

    if ( _wcsicmp( L"NwlnkIpx", (LPWSTR)lpTransportKeyName ) == 0 ) {
        spxString = FALSE;
    } else {
        spxString = TRUE;
    }

    //
    // Make sure that the caller cares about SPX, SPX2, and/or IPX.
    //

    if ( ARGUMENT_PRESENT( lpiProtocols ) ) {

        for ( i = 0; lpiProtocols[i] != 0; i++ ) {
            if ( lpiProtocols[i] == NSPROTO_SPX && spxString ) {
                useSpx = TRUE;
            }
            if ( lpiProtocols[i] == NSPROTO_SPXII && spxString ) {
                useSpx2 = TRUE;
            }
            if ( lpiProtocols[i] == NSPROTO_IPX && !spxString ) {
                useIpx = TRUE;
            }
        }

    } else {

        useSpx = FALSE;
        useSpx2 = spxString;
        useIpx = !spxString;
    }

    if ( !useSpx && !useSpx2 && !useIpx ) {
        *lpdwBufferLength = 0;
        return 0;
    }

    //
    // Make sure that the caller has specified a sufficiently large
    // buffer.
    //

    bytesRequired = (DWORD)((sizeof(PROTOCOL_INFO) * 3) +
                        ( (wcslen( SPX_NAME ) + 1) * sizeof(WCHAR)) +
                        ( (wcslen( SPX2_NAME ) + 1) * sizeof(WCHAR)) +
                        ( (wcslen( IPX_NAME ) + 1) * sizeof(WCHAR)));

    if ( bytesRequired > *lpdwBufferLength ) {
        *lpdwBufferLength = bytesRequired;
        return -1;
    }

    //
    // Initialize local variables.
    //

    protocolInfo = lpProtocolBuffer;
    namePtr = (PWCHAR)( (PCHAR)lpProtocolBuffer + *lpdwBufferLength );

    //
    // Fill in SPX info, if requested.
    //

    if ( useSpx ) {

        entriesReturned += 1;

        protocolInfo->dwServiceFlags = XP_GUARANTEED_DELIVERY |
                                       XP_MESSAGE_ORIENTED |
                                       XP_PSEUDO_STREAM |
                                       XP_GUARANTEED_ORDER |
                                       XP_FRAGMENTATION;
        protocolInfo->iAddressFamily = AF_IPX;
        protocolInfo->iMaxSockAddr = 0x10;
        protocolInfo->iMinSockAddr = 0xE;
        protocolInfo->iSocketType = SOCK_SEQPACKET;
        protocolInfo->iProtocol = NSPROTO_SPX;
        protocolInfo->dwMessageSize = 0xFFFFFFFF;

        namePtr = namePtr - (wcslen( SPX_NAME) + 1);
        protocolInfo->lpProtocol = namePtr;
        wcscpy( protocolInfo->lpProtocol, SPX_NAME );

        protocolInfo += 1;
    }

    //
    // Fill in SPX II info, if requested.
    //

    if ( useSpx2 ) {

        entriesReturned += 1;

        protocolInfo->dwServiceFlags = XP_GUARANTEED_DELIVERY |
                                       XP_MESSAGE_ORIENTED |
                                       XP_PSEUDO_STREAM |
                                       XP_GRACEFUL_CLOSE |
                                       XP_GUARANTEED_ORDER |
                                       XP_FRAGMENTATION;
        protocolInfo->iAddressFamily = AF_IPX;
        protocolInfo->iMaxSockAddr = 0x10;
        protocolInfo->iMinSockAddr = 0xE;
        protocolInfo->iSocketType = SOCK_SEQPACKET;
        protocolInfo->iProtocol = NSPROTO_SPXII;
        protocolInfo->dwMessageSize = 0xFFFFFFFF;

        namePtr = namePtr - (wcslen( SPX2_NAME) + 1);
        protocolInfo->lpProtocol = namePtr;
        wcscpy( protocolInfo->lpProtocol, SPX2_NAME );

        protocolInfo += 1;
    }

    //
    // Fill in IPX info, if requested.
    //

    if ( useIpx ) {

        entriesReturned += 1;

        protocolInfo->dwServiceFlags = XP_CONNECTIONLESS |
                                       XP_MESSAGE_ORIENTED |
                                       XP_SUPPORTS_BROADCAST |
                                       XP_SUPPORTS_MULTICAST |
                                       XP_FRAGMENTATION;
        protocolInfo->iAddressFamily = AF_IPX;
        protocolInfo->iMaxSockAddr = 0x10;
        protocolInfo->iMinSockAddr = 0xE;
        protocolInfo->iSocketType = SOCK_DGRAM;
        protocolInfo->iProtocol = NSPROTO_IPX;
        protocolInfo->dwMessageSize = 576;

        namePtr = namePtr - (wcslen( IPX_NAME) + 1);
        protocolInfo->lpProtocol = namePtr;
        wcscpy( protocolInfo->lpProtocol, IPX_NAME );
    }

    *lpdwBufferLength = bytesRequired;

    return entriesReturned;

} // WSHEnumProtocols


#define _IPX_CONTROL_CODE(request,method) \
            CTL_CODE(FILE_DEVICE_TRANSPORT, request, method, FILE_ANY_ACCESS)
#define IOCTL_IPX_LOAD_SPX      _IPX_CONTROL_CODE( 0x5678, METHOD_BUFFERED )

DWORD
WshLoadSpx(
    VOID
    )
/*++

Routine Description:

    Starts the nwlnkspx.sys driver by submitting a special ioctl
    to ipx, which calls ZwLoadDriver() for us.

Arguments:

    none

Returns:

    Error return from the load operation.

++*/
{
    DWORD err = NO_ERROR;
    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING FileString;
    WCHAR FileName[] = L"\\Device\\NwlnkIpx";
    NTSTATUS Status;

    RtlInitUnicodeString (&FileString, FileName);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtOpenFile(
                 &FileHandle,
                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_SYNCHRONOUS_IO_ALERT);

    if (!NT_SUCCESS(Status)) {

        err = ERROR_FILE_NOT_FOUND;

    } else {

        Status = NtDeviceIoControlFile(
                     FileHandle,
                     NULL,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     IOCTL_IPX_LOAD_SPX,
                     NULL,
                     0,
                     NULL,
                     0);

        if (Status == STATUS_IMAGE_ALREADY_LOADED) {

            err = ERROR_SERVICE_ALREADY_RUNNING;

            //
            // #36451
            // If the service controller loads SPX ("net start nwlnkspx", or due to dependency of RPC on SPX)
            // then we get this error the first time too. Keep a note of that.
            //
            // NOTE: we still leak a handle per process since the handle to the driver is actually created
            // in the system process' context. The ideal way to fix this should be to have IPX associate the
            // handle with the current process (so handle is destroyed when the process dies) or to have the
            // dll tell IPX to close the handle it opened earlier.
            //
            SpxLoaded = TRUE;

        } else if (!NT_SUCCESS(Status)) {

            err = ERROR_IO_DEVICE;

        } else {
            SpxLoaded = TRUE;
        }

        NtClose (FileHandle);

    }

    return(err);
}

/*page***************************************************************
       W S H G e t P r o v i d e r G u i d

       Queries the GUID identifier for this protocol.

       Returns - NO_ERROR or an error code.
*********************************************************************/
INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    )
{

    if( ProviderName == NULL ||
        ProviderGuid == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, L"NwlnkIpx" ) == 0 ) {

        RtlCopyMemory(
            ProviderGuid,
            &IpxProviderGuid,
            sizeof(GUID)
            );

        return NO_ERROR;

    }

    if( _wcsicmp( ProviderName, L"NwlnkSpx" ) == 0 ) {

        RtlCopyMemory(
            ProviderGuid,
            &SpxProviderGuid,
            sizeof(GUID)
            );

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetProviderGuid


INT
WINAPI
WSHAddressToString (
    IN LPSOCKADDR Address,
    IN INT AddressLength,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPWSTR AddressString,
    IN OUT LPDWORD AddressStringLength
    )

/*++

Routine Description:

    Converts a SOCKADDR to a human-readable form.

Arguments:

    Address - The SOCKADDR to convert.

    AddressLength - The length of Address.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    AddressString - Receives the formatted address string.

    AddressStringLength - On input, contains the length of AddressString.
        On output, contains the number of characters actually written
        to AddressString.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{
        
    WCHAR string[BUFFER_SIZE];
    INT length;
    LPSOCKADDR_IPX addr;

    //
    // Quick sanity checks.
    //

    if( Address == NULL ||
        AddressLength < sizeof(SOCKADDR_IPX) ||
        AddressString == NULL ||
        AddressStringLength == NULL ) {

        return WSAEFAULT;

    }

    addr = (LPSOCKADDR_IPX)Address;

    if( addr->sa_family != AF_NS ) {

        return WSAEINVAL;

    }

 
    length = swprintf(
                 string,
                 L"%2.2x%2.2x%2.2x%2.2x.%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",
                 (UCHAR) addr->sa_netnum[0],
                                 (UCHAR) addr->sa_netnum[1],
                                 (UCHAR) addr->sa_netnum[2],
                                 (UCHAR) addr->sa_netnum[3],
                                 (UCHAR) addr->sa_nodenum[0],
                                 (UCHAR) addr->sa_nodenum[1],
                                 (UCHAR) addr->sa_nodenum[2],
                                 (UCHAR) addr->sa_nodenum[3],
                                 (UCHAR) addr->sa_nodenum[4],
                                 (UCHAR) addr->sa_nodenum[5]                                     
                 );

    if( addr->sa_socket != 0 ) {

        length += swprintf(
                      string + length,
                      L":%hu",
                      ntohs( addr->sa_socket )
                      );

    }

    length++;   // account for terminator

        if ( length > BUFFER_SIZE ) {
                DbgPrint("length exceeded internal buffer in wshisn.dll.\n"); 
                return WSAEFAULT; 
        }

    if( *AddressStringLength < (DWORD)length ) {
                DbgPrint("AddressStringLength %lu < length %lu\n",*AddressStringLength, length);  
        return WSAEFAULT;
    }

    *AddressStringLength = (DWORD)length;

    RtlCopyMemory(
        AddressString,
        string,
        length * sizeof(WCHAR)
        );

    return NO_ERROR;

} // WSHAddressToString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\spx\spxutils.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    spxutils.c

Abstract:

    This contains all utility routines for the ISN SPX module.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//	Define module number for event logging entries
#define	FILENUM		SPXUTILS

UINT
SpxUtilWstrLength(
	IN PWSTR Wstr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	UINT length = 0;

	while (*Wstr++)
	{
		length += sizeof(WCHAR);
	}

	return length;
}




LONG
SpxRandomNumber(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	LARGE_INTEGER	Li;
	static LONG		seed = 0;

	// Return a positive pseudo-random number; simple linear congruential
	// algorithm. ANSI C "rand()" function.

	if (seed == 0)
	{
		KeQuerySystemTime(&Li);
		seed = Li.LowPart;
	}

	seed *= (0x41C64E6D + 0x3039);

	return (seed & 0x7FFFFFFF);
}




NTSTATUS
SpxUtilGetSocketType(
	PUNICODE_STRING 	RemainingFileName,
	PBYTE				SocketType
	)
/*++

Routine Description:

	For PROTO_SPX, i'd return a device name from the dll of the form
	\Device\IsnSpx\SpxStream (for SOCK_STREAM) or
	\Device\IsnSpx\Spx               (for SOCK_SEQPKT)
	
	and for PROTO_SPXII (the more common case we hope, even if
	internally we degrade to SPX1 cause of the remote client's
	limitations)
	\Device\IsnSpx\Stream        (for SOCK_STREAM) or
	\Device\IsnSpx               (for SOCK_SEQPKT)

Arguments:


Return Value:


--*/
{
	NTSTATUS			status = STATUS_SUCCESS;
	UNICODE_STRING		typeString;

	*SocketType		= SOCKET2_TYPE_SEQPKT;

	// Check for the socket type
	do
	{
		if (RemainingFileName->Length == 0)
		{
			break;
		}

		if ((UINT)RemainingFileName->Length ==
									SpxUtilWstrLength(SOCKET1STREAM_SUFFIX))
		{
			RtlInitUnicodeString(&typeString, SOCKET1STREAM_SUFFIX);
		
			//  Case insensitive compare
			if (RtlEqualUnicodeString(&typeString, RemainingFileName, TRUE))
			{
				*SocketType = SOCKET1_TYPE_STREAM;
				break;
			}
		}

		if ((UINT)RemainingFileName->Length ==
									SpxUtilWstrLength(SOCKET1_SUFFIX))
		{
			RtlInitUnicodeString(&typeString, SOCKET1_SUFFIX);
		
			//  Case insensitive compare
			if (RtlEqualUnicodeString(&typeString, RemainingFileName, TRUE))
			{
				*SocketType = SOCKET1_TYPE_SEQPKT;
				break;
			}
		}

		if ((UINT)RemainingFileName->Length ==
									SpxUtilWstrLength(SOCKET2STREAM_SUFFIX))
		{
			RtlInitUnicodeString(&typeString, SOCKET2STREAM_SUFFIX);
		
			//  Case insensitive compare
			if (RtlEqualUnicodeString(&typeString, RemainingFileName, TRUE))
			{
				*SocketType = SOCKET2_TYPE_STREAM;
				break;
			}
		}

		status = STATUS_NO_SUCH_DEVICE;
	
	} while (FALSE);

	return(status);
}




#define	ONE_MS_IN_100ns		-10000L		// 1ms in 100ns units

VOID
SpxSleep(
	IN	ULONG	TimeInMs
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KTIMER	SleepTimer;

	ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

	KeInitializeTimer(&SleepTimer);

	KeSetTimer(&SleepTimer,
				RtlConvertLongToLargeInteger(TimeInMs * ONE_MS_IN_100ns),
				NULL);

	KeWaitForSingleObject(&SleepTimer, UserRequest, KernelMode, FALSE, NULL);
	return;
}




TDI_ADDRESS_IPX UNALIGNED *
SpxParseTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress
	)

/*++

Routine Description:

    This routine scans a TRANSPORT_ADDRESS, looking for an address
    of type TDI_ADDRESS_TYPE_IPX.

Arguments:

    Transport - The generic TDI address.

Return Value:

    A pointer to the IPX address, or NULL if none is found.

--*/

{
    TA_ADDRESS * addressName;
    INT i;

    addressName = &TransportAddress->Address[0];

    // The name can be passed with multiple entries; we'll take and use only
    // the IPX one.
    for (i=0;i<TransportAddress->TAAddressCount;i++)
	{
        if (addressName->AddressType == TDI_ADDRESS_TYPE_IPX)
		{
            if (addressName->AddressLength >= sizeof(TDI_ADDRESS_IPX))
			{
                return ((TDI_ADDRESS_IPX UNALIGNED *)(addressName->Address));
            }
        }
        addressName = (TA_ADDRESS *)(addressName->Address +
                                                addressName->AddressLength);
    }
    return NULL;

}   // SpxParseTdiAddress



BOOLEAN
SpxValidateTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress,
    IN ULONG TransportAddressLength
	)

/*++

Routine Description:

    This routine scans a TRANSPORT_ADDRESS, verifying that the
    components of the address do not extend past the specified
    length.

Arguments:

    TransportAddress - The generic TDI address.

    TransportAddressLength - The specific length of TransportAddress.

Return Value:

    TRUE if the address is valid, FALSE otherwise.

--*/

{
    PUCHAR AddressEnd = ((PUCHAR)TransportAddress) + TransportAddressLength;
    TA_ADDRESS * addressName;
    INT i;

    if (TransportAddressLength < sizeof(TransportAddress->TAAddressCount))
	{
        DBGPRINT(TDI, ERR,
				("SpxValidateTdiAddress: runt address\n"));

        return FALSE;
    }

    addressName = &TransportAddress->Address[0];

    for (i=0;i<TransportAddress->TAAddressCount;i++)
	{
        if (addressName->Address > AddressEnd)
		{
            DBGPRINT(TDI, ERR,
					("SpxValidateTdiAddress: address too short\n"));

            return FALSE;
        }
        addressName = (TA_ADDRESS *)(addressName->Address +
                                                addressName->AddressLength);
    }

    if ((PUCHAR)addressName > AddressEnd)
	{
        DBGPRINT(TDI, ERR,
				("SpxValidateTdiAddress: address too short\n"));

        return FALSE;
    }
    return TRUE;

}   // SpxValidateTdiAddress




ULONG
SpxBuildTdiAddress(
    IN PVOID AddressBuffer,
    IN ULONG AddressBufferLength,
    IN UCHAR Network[4],
    IN UCHAR Node[6],
    IN USHORT Socket
	)

/*++

Routine Description:

    This routine fills in a TRANSPORT_ADDRESS in the specified
    buffer, given the socket, network and node. It will write
    less than the full address if the buffer is too short.

Arguments:

    AddressBuffer - The buffer that will hold the address.

    AddressBufferLength - The length of the buffer.

    Network - The network number.

    Node - The node address.

    Socket - The socket.

Return Value:

    The number of bytes written into AddressBuffer.

--*/

{
    TA_IPX_ADDRESS UNALIGNED * SpxAddress;
    TA_IPX_ADDRESS TempAddress;

    if (AddressBufferLength >= sizeof(TA_IPX_ADDRESS))
	{
        SpxAddress = (TA_IPX_ADDRESS UNALIGNED *)AddressBuffer;
    }
	else
	{
        SpxAddress = (TA_IPX_ADDRESS UNALIGNED *)&TempAddress;
    }

    SpxAddress->TAAddressCount = 1;
    SpxAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_IPX);
    SpxAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    SpxAddress->Address[0].Address[0].NetworkAddress = *(UNALIGNED LONG *)Network;
    SpxAddress->Address[0].Address[0].Socket = Socket;
    RtlCopyMemory(SpxAddress->Address[0].Address[0].NodeAddress, Node, 6);

    if (AddressBufferLength >= sizeof(TA_IPX_ADDRESS))
	{
        return sizeof(TA_IPX_ADDRESS);
    }
	else
	{
        RtlCopyMemory(AddressBuffer, &TempAddress, AddressBufferLength);
        return AddressBufferLength;
    }

}   // SpxBuildTdiAddress



VOID
SpxBuildTdiAddressFromIpxAddr(
    IN PVOID 		AddressBuffer,
    IN PBYTE	 	pIpxAddr
	)
{
    TA_IPX_ADDRESS UNALIGNED * SpxAddress;

    SpxAddress = (TA_IPX_ADDRESS UNALIGNED *)AddressBuffer;
    SpxAddress->TAAddressCount = 1;
    SpxAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_IPX);
    SpxAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    SpxAddress->Address[0].Address[0].NetworkAddress = *(UNALIGNED LONG *)pIpxAddr;
    RtlCopyMemory(
		SpxAddress->Address[0].Address[0].NodeAddress,
		pIpxAddr+4,
		6);

	GETSHORT2SHORT(
		&SpxAddress->Address[0].Address[0].Socket,
		pIpxAddr + 10);

	return;
}



VOID
SpxCalculateNewT1(
	IN	struct _SPX_CONN_FILE	* 	pSpxConnFile,
	IN	int							NewT1
	)
/*++

Routine Description:


Arguments:

	NewT1 - New value for the RTT in ms.

Return Value:


--*/
{
	int	baseT1, error;

	//
	//	VAN JACOBSEN Algorithm.  From Internetworking with Tcp/ip
	//	(Comer) book.
	//

	error 					 = NewT1 - (pSpxConnFile->scf_AveT1 >> 3);
	pSpxConnFile->scf_AveT1	+= error;
	if (pSpxConnFile->scf_AveT1 <= 0)     // Make sure not too small
	{
        pSpxConnFile->scf_AveT1 = SPX_T1_MIN;
	}

	if (error < 0)
		error = -error;

	error 					-= (pSpxConnFile->scf_DevT1 >> 2);
	pSpxConnFile->scf_DevT1	+= error;
	if (pSpxConnFile->scf_DevT1 <= 0)
        pSpxConnFile->scf_DevT1 = 1;

	baseT1 = (((pSpxConnFile->scf_AveT1 >> 2) + pSpxConnFile->scf_DevT1) >> 1);

	//	If less then min - set it
	if (baseT1 < SPX_T1_MIN)
		baseT1 = SPX_T1_MIN;

	//	Set the new value
	DBGPRINT(TDI, DBG,
			("SpxCalculateNewT1: Old value %lx New %lx\n",
				pSpxConnFile->scf_BaseT1, baseT1));

	pSpxConnFile->scf_BaseT1	= baseT1;

	//	At the time of restarting the timer,we convert this to a tick value.
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\winsock\wshutil.c ===
/****************************************************************************
* (c) Copyright 1993 Micro Computer Systems, Inc. All rights reserved.
*****************************************************************************
*
*   Title:    IPX/SPX WinSock Helper DLL for Windows NT
*
*   Module:   ipx/sockhelp/wshutil.c
*
*   Version:  1.00.00
*
*   Date:     04-08-93
*
*   Author:   Brian Walker
*
*****************************************************************************
*
*   Change Log:
*
*   Date     DevSFC   Comment
*   -------- ------   -------------------------------------------------------
*
*****************************************************************************
*
*   Functional Description:
*
****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <tdi.h>

#include <winsock.h>
#include <wsahelp.h>

#include <isnkrnl.h>

/*page*******************************************************
       d o _ t d i _ a c t i o n

       Generate a TDI_ACTION down to the streams
       driver.

       Arguments - fd     = Handle to send on
            cmd    = Command to send down
            optbuf = Ptr to options buffer
            optlen = Ptr to options length
            addrflag = TRUE  = This is for DG/STREAM socket on addr handle
                       FALSE = This is for conn handle

       Returns - A WinSock error code (NO_ERROR = OK)
************************************************************/
INT do_tdi_action(HANDLE fd, ULONG cmd, PUCHAR optbuf, INT optlen, BOOLEAN addrflag, PHANDLE eventhandle OPTIONAL)
{
    NTSTATUS status;
    PSTREAMS_TDI_ACTION tdibuf;
    ULONG           tdilen;
    IO_STATUS_BLOCK iostat;
    HANDLE          event;


    /** If the eventhandle is passed, it also means that the **/
    /** NWLINK_ACTION header is pre-allocated in the buffer, **/
    /** although we still have to fill the header in here.   **/

    if (eventhandle == NULL) {

        /** Get the length of the buffer we need to allocate **/

        tdilen = FIELD_OFFSET(STREAMS_TDI_ACTION,Buffer) + sizeof(ULONG) + optlen;

        /** Allocate a buffer to use for the action **/

        tdibuf = RtlAllocateHeap(RtlProcessHeap(), 0, tdilen);
        if (tdibuf == NULL) {
           return WSAENOBUFS;
        }

    } else {

        tdilen = optlen;
        tdibuf = (PSTREAMS_TDI_ACTION)optbuf;

    }

    /** Set the datagram option **/

    RtlMoveMemory(&tdibuf->Header.TransportId, "MISN", 4);
    tdibuf->DatagramOption = addrflag;

    /**
       Fill out the buffer, the buffer looks like this:

       ULONG cmd
       data passed.
    **/

    memcpy(tdibuf->Buffer, &cmd, sizeof(ULONG));

    if (eventhandle == NULL) {

        tdibuf->BufferLength = sizeof(ULONG) + optlen;

        RtlMoveMemory(tdibuf->Buffer + sizeof(ULONG), optbuf, optlen);

        /** Create an event to wait on **/

        status = NtCreateEvent(
           &event,
           EVENT_ALL_ACCESS,
           NULL,
           SynchronizationEvent,
           FALSE);

        /** If no event - then return error **/

        if (!NT_SUCCESS(status)) {
           RtlFreeHeap(RtlProcessHeap(), 0, tdibuf);
           return WSAENOBUFS;
        }

    } else {

        tdibuf->BufferLength = sizeof(ULONG) + optlen - FIELD_OFFSET (NWLINK_ACTION, Data[0]);

        /** Use the event handle passed in **/

        event = *eventhandle;

    }

    /** **/

    status = NtDeviceIoControlFile(
       fd,
       event,
       NULL,
       NULL,
       &iostat,
       IOCTL_TDI_ACTION,
       NULL,
       0,
       tdibuf,
       tdilen);


    if (eventhandle == NULL) {

        /** If pending - wait for it to finish **/

        if (status == STATUS_PENDING) {
           status = NtWaitForSingleObject(event, FALSE, NULL);
           ASSERT(status == 0);
           status = iostat.Status;
        }

        /** Close the event **/

        NtClose(event);

    }

    /** If we get an error - return it **/

    if (!NT_SUCCESS(status)) {
       if (eventhandle == NULL) {
           RtlFreeHeap(RtlProcessHeap(), 0, tdibuf);
       }
       return WSAEINVAL;
    }

    if (eventhandle == NULL) {

        /** Copy the returned back to optbuf if needed */

        if (optlen) {
            RtlMoveMemory (optbuf, tdibuf->Buffer + sizeof(ULONG), optlen);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, tdibuf);

    }

    /** Return OK **/

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\dload\iphlpapi.c ===
#include "netpch.h"
#pragma hdrstop

#include <iphlpapi.h>


static
DWORD
WINAPI
GetIfTable(
    OUT    PMIB_IFTABLE pIfTable,
    IN OUT PULONG       pdwSize,
    IN     BOOL         bOrder
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetInterfaceInfo(
    IN PIP_INTERFACE_INFO pIfTable,
    OUT PULONG            dwOutBufLen
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD
WINAPI
GetIpAddrTable(
    OUT    PMIB_IPADDRTABLE pIpAddrTable,
    IN OUT PULONG           pdwSize,
    IN     BOOL             bOrder
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetIpNetTable(
    OUT    PMIB_IPNETTABLE pIpNetTable,
    IN OUT PULONG          pdwSize,
    IN     BOOL            bOrder
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetIpForwardTable(
    OUT    PMIB_IPFORWARDTABLE pIpForwardTable,
    IN OUT PULONG              pdwSize,
    IN     BOOL                bOrder
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetIpStatistics(
    OUT  PMIB_IPSTATS   pStats
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetIcmpStatistics(
    OUT PMIB_ICMP   pStats
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetNumberOfInterfaces(
    OUT PDWORD  pdwNumIf
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetTcpStatistics(
    OUT PMIB_TCPSTATS   pStats
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetUdpStatistics(
    OUT PMIB_UDPSTATS   pStats
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetBestInterface(
    IN  IPAddr  dwDestAddr,
    OUT PDWORD  pdwBestIfIndex
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetBestRoute(
    IN  DWORD               dwDestAddr,
    IN  DWORD               dwSourceAddr, OPTIONAL
    OUT PMIB_IPFORWARDROW   pBestRoute
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
NotifyAddrChange(
    OUT PHANDLE      Handle,
    IN  LPOVERLAPPED overlapped
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
NotifyRouteChange(
    OUT PHANDLE      Handle,
    IN  LPOVERLAPPED overlapped
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
GetRTTAndHopCount(
    IPAddr DestIpAddress,
    PULONG HopCount,
    ULONG  MaxHops,
    PULONG RTT
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    
    return FALSE;
}

static
DWORD
WINAPI
GetFriendlyIfIndex(
    DWORD IfIndex
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetAdaptersInfo(
    PIP_ADAPTER_INFO    pAdapterInfo,
    PULONG              pOutBufLen
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetIfEntry(
    IN OUT PMIB_IFROW   pIfRow
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
GetPerAdapterInfo(
    ULONG                   IfIndex,
    PIP_PER_ADAPTER_INFO    pPerAdapterInfo,
    PULONG                  pOutBufLen
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
NhGetInterfaceNameFromDeviceGuid(
    IN      GUID    *pGuid,
    OUT     PWCHAR  pwszBuffer,
    IN  OUT PULONG  pulBufferSize,
    IN      BOOL    bCache,
    IN      BOOL    bRefresh
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(iphlpapi)
{
    DLPENTRY(GetAdaptersInfo)
    DLPENTRY(GetBestInterface)
    DLPENTRY(GetBestRoute)
    DLPENTRY(GetFriendlyIfIndex)
    DLPENTRY(GetIcmpStatistics)
    DLPENTRY(GetIfEntry)
    DLPENTRY(GetIfTable)
    DLPENTRY(GetInterfaceInfo)    
    DLPENTRY(GetIpAddrTable)
    DLPENTRY(GetIpForwardTable)
    DLPENTRY(GetIpNetTable)
    DLPENTRY(GetIpStatistics)
    DLPENTRY(GetNumberOfInterfaces)    
    DLPENTRY(GetPerAdapterInfo)
    DLPENTRY(GetRTTAndHopCount)
    DLPENTRY(GetTcpStatistics)
    DLPENTRY(GetUdpStatistics)
    DLPENTRY(NhGetInterfaceNameFromDeviceGuid)
    DLPENTRY(NotifyAddrChange)
    DLPENTRY(NotifyRouteChange)    
};

DEFINE_PROCNAME_MAP(iphlpapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\dload\mswsock.c ===
#include "netpch.h"
#pragma hdrstop

#include <wsasetup.h>

static
DWORD
MigrateWinsockConfiguration(
    LPWSA_SETUP_DISPOSITION Disposition,
    LPFN_WSA_SETUP_CALLBACK Callback OPTIONAL,
    DWORD Context OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mswsock)
{
    DLPENTRY(MigrateWinsockConfiguration)
};

DEFINE_PROCNAME_MAP(mswsock)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\dload\netpch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\dload\mpr.c ===
#include "netpch.h"
#pragma hdrstop

#include <winnetwk.h>

static
DWORD
APIENTRY
WNetAddConnection2W(
     IN LPNETRESOURCEW lpNetResource,
     IN LPCWSTR       lpPassword,
     IN LPCWSTR       lpUserName,
     IN DWORD          dwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD
APIENTRY
WNetAddConnection3W(
    IN HWND             hwndOwner,
    IN LPNETRESOURCEW   lpNetResource,
    IN LPCWSTR          lpPassword,
    IN LPCWSTR          lpUserName,
    IN DWORD            dwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetCancelConnection2W(
    IN LPCWSTR  lpName,
    IN DWORD    dwFlags,
    IN BOOL     fForce
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetCloseEnum(
    IN HANDLE   hEnum
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetEnumResourceW(
     IN HANDLE  hEnum,
     IN OUT LPDWORD lpcCount,
     OUT LPVOID  lpBuffer,
     IN OUT LPDWORD lpBufferSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetUniversalNameW(
     IN LPCWSTR lpLocalPath,
     IN DWORD    dwInfoLevel,
     OUT LPVOID   lpBuffer,
     IN OUT LPDWORD  lpBufferSize
     )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetResourceInformationW(
    IN LPNETRESOURCEW   lpNetResource,
    OUT LPVOID          lpBuffer,
    IN OUT LPDWORD      lpcbBuffer,
    OUT LPWSTR         *lplpSystem
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetResourceInformationA(
    IN LPNETRESOURCEA   lpNetResource,
    OUT LPVOID          lpBuffer,
    IN OUT LPDWORD      lpcbBuffer,
    OUT LPSTR          *lplpSystem
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetOpenEnumW(
     IN DWORD          dwScope,
     IN DWORD          dwType,
     IN DWORD          dwUsage,
     IN LPNETRESOURCEW lpNetResource,
     OUT LPHANDLE       lphEnum
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetConnectionDialog(
    IN HWND  hwnd,
    IN DWORD dwType
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetConnectionDialog1W(
    IN OUT LPCONNECTDLGSTRUCTW lpConnDlgStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetDisconnectDialog1W(
    IN LPDISCDLGSTRUCTW lpConnDlgStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetUseConnectionW(
    IN HWND            hwndOwner,
    IN LPNETRESOURCEW   lpNetResource,
    IN LPCWSTR        lpUserID,
    IN LPCWSTR        lpPassword,
    IN DWORD           dwFlags,
    OUT LPWSTR         lpAccessName,
    IN OUT LPDWORD     lpBufferSize,
    OUT LPDWORD        lpResult
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetUserW(
    IN LPCWSTR  lpName,
    OUT LPWSTR   lpUserName,
    IN OUT LPDWORD   lpnLength
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetConnectionW(
    IN LPCWSTR lpLocalName,
    OUT LPWSTR  lpRemoteName,
    IN OUT LPDWORD  lpnLength
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
WNetGetResourceParentW(
    IN LPNETRESOURCEW lpNetResource,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpcbBuffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static    
DWORD
APIENTRY
WNetGetProviderNameW(
    IN DWORD   dwNetType,
    OUT LPWSTR lpProviderName,
    IN OUT LPDWORD lpBufferSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
MultinetGetConnectionPerformanceW(
    IN LPNETRESOURCEW lpNetResource,
    OUT LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetDisconnectDialog(
    IN HWND  hwnd,
    IN DWORD dwType
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetGetLastErrorW(
    OUT LPDWORD    lpError,
    OUT LPWSTR    lpErrorBuf,
    IN DWORD      nErrorBufSize,
    OUT LPWSTR    lpNameBuf,
    IN DWORD      nNameBufSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetGetLastErrorA(
     OUT LPDWORD    lpError,
     OUT LPSTR    lpErrorBuf,
     IN DWORD      nErrorBufSize,
     OUT LPSTR    lpNameBuf,
     IN DWORD      nNameBufSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetRestoreConnectionW(
    IN HWND     hwndParent,
    IN LPCWSTR lpDevice
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetRestoreConnectionA(
    IN HWND     hwndParent,
    IN LPCSTR  lpDevice
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MultinetGetErrorTextW(
    OUT LPWSTR lpErrorTextBuf,
    IN OUT LPDWORD lpnErrorBufSize,
    OUT LPWSTR lpProviderNameBuf,
    IN OUT LPDWORD lpnNameBufSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetGetConnection3W(
     IN LPCWSTR lpLocalName,
     IN LPCWSTR lpProviderName,
     IN DWORD    dwInfoLevel,
     OUT LPVOID   lpBuffer,
     IN OUT LPDWORD  lpcbBuffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetFormatNetworkNameW(
    IN LPCWSTR  lpProvider,
    IN LPCWSTR  lpRemoteName,
    OUT LPWSTR   lpFormattedName,
    IN OUT LPDWORD   lpnLength,
    IN DWORD     dwFlags,
    IN DWORD     dwAveCharPerLine
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetGetProviderTypeW(
    IN  LPCWSTR          lpProvider,
    OUT LPDWORD           lpdwNetType
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetRestoreConnection2W(
    IN  HWND     hwndParent,
    IN  LPCWSTR lpDevice,
    IN  DWORD    dwFlags,
    OUT BOOL*    pfReconnectFailed
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
WNetClearConnections(
    HWND hWnd
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mpr)
{
    DLPENTRY(MultinetGetConnectionPerformanceW)
    DLPENTRY(MultinetGetErrorTextW)
    DLPENTRY(WNetAddConnection2W)
    DLPENTRY(WNetAddConnection3W)
    DLPENTRY(WNetCancelConnection2W)
    DLPENTRY(WNetClearConnections)
    DLPENTRY(WNetCloseEnum)
    DLPENTRY(WNetConnectionDialog)
    DLPENTRY(WNetConnectionDialog1W)
    DLPENTRY(WNetDisconnectDialog)
    DLPENTRY(WNetDisconnectDialog1W)
    DLPENTRY(WNetEnumResourceW)
    DLPENTRY(WNetFormatNetworkNameW)
    DLPENTRY(WNetGetConnection3W)
    DLPENTRY(WNetGetConnectionW)
    DLPENTRY(WNetGetLastErrorA)
    DLPENTRY(WNetGetLastErrorW)
    DLPENTRY(WNetGetProviderNameW)
    DLPENTRY(WNetGetProviderTypeW)
    DLPENTRY(WNetGetResourceInformationA)
    DLPENTRY(WNetGetResourceInformationW)
    DLPENTRY(WNetGetResourceParentW)
    DLPENTRY(WNetGetUniversalNameW)
    DLPENTRY(WNetGetUserW)
    DLPENTRY(WNetOpenEnumW)
    DLPENTRY(WNetRestoreConnection2W)
    DLPENTRY(WNetRestoreConnectionA)
    DLPENTRY(WNetRestoreConnectionW)
    DLPENTRY(WNetUseConnectionW)
};

DEFINE_PROCNAME_MAP(mpr)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\dload\mprapi.c ===
#include "netpch.h"
#pragma hdrstop

#include <mprapi.h>
#include <mprapip.h>

static
DWORD
MprAdminBufferFree(
    IN PVOID        pBuffer
)
{
    return ERROR_PROC_NOT_FOUND;
}

DWORD APIENTRY
MprAdminConnectionEnum(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE *                lplpbBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN      LPDWORD                 lpdwResumeHandle
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MprAdminConnectionGetInfo(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
    IN      HANDLE                  hRasConnection,
    OUT     LPBYTE *                lplpbBuffer
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminDeregisterConnectionNotification(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hEventNotification
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminInterfaceCreate(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE *                phInterface
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminInterfaceDelete(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminInterfaceEnum(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE *                lplpbBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN      LPDWORD                 lpdwResumeHandle        OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminInterfaceGetHandle(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      LPWSTR                  lpwsInterfaceName,
    OUT     HANDLE *                phInterface,
    IN      BOOL                    fIncludeClientInterfaces
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminInterfaceTransportAdd(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwTransportId,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL APIENTRY
MprAdminIsServiceRunning(
    IN  LPWSTR  lpwsServerName
)
{
    return FALSE;
}

static
DWORD APIENTRY
MprAdminMIBBufferFree(
    IN      LPVOID                  pBuffer
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminMIBEntryCreate(
    IN      MIB_SERVER_HANDLE       hMibServer,
    IN      DWORD                   dwPid,
    IN      DWORD                   dwRoutingPid,
    IN      LPVOID                  lpEntry,
    IN      DWORD                   dwEntrySize
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminMIBEntryDelete(
    IN      MIB_SERVER_HANDLE       hMibServer,
    IN      DWORD                   dwProtocolId,
    IN      DWORD                   dwRoutingPid,
    IN      LPVOID                  lpEntry,
    IN      DWORD                   dwEntrySize
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminMIBEntryGet(
    IN      MIB_SERVER_HANDLE       hMibServer,
    IN      DWORD                   dwProtocolId,
    IN      DWORD                   dwRoutingPid,
    IN      LPVOID                  lpInEntry,
    IN      DWORD                   dwInEntrySize,
    OUT     LPVOID*                 lplpOutEntry,
    OUT     LPDWORD                 lpOutEntrySize
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminMIBEntrySet(
    IN      MIB_SERVER_HANDLE       hMibServer,
    IN      DWORD                   dwProtocolId,
    IN      DWORD                   dwRoutingPid,
    IN      LPVOID                  lpEntry,
    IN      DWORD                   dwEntrySize
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminMIBServerConnect(
    IN      LPWSTR                  lpwsServerName      OPTIONAL,
    OUT     MIB_SERVER_HANDLE *     phMibServer
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
VOID APIENTRY
MprAdminMIBServerDisconnect(
    IN      MIB_SERVER_HANDLE       hMibServer
)
{
}

static
DWORD APIENTRY
MprAdminPortEnum(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
    IN      HANDLE                  hRasConnection,
    OUT     LPBYTE *                lplpbBuffer,        // RAS_PORT_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN      LPDWORD                 lpdwResumeHandle    OPTIONAL
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminPortGetInfo(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
    IN      HANDLE                  hPort,
    OUT     LPBYTE *                lplpbBuffer
)
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MprAdminRegisterConnectionNotification(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hEventNotification
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminServerConnect(
    IN      LPWSTR                  lpwsServerName      OPTIONAL,
    OUT     MPR_SERVER_HANDLE *     phMprServer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
VOID APIENTRY
MprAdminServerDisconnect(
    IN      MPR_SERVER_HANDLE       hMprServer
    )
{
}

static
DWORD APIENTRY
MprAdminTransportCreate(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwTransportId,
    IN      LPWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      LPWSTR                  lpwsDLLPath
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprAdminUpgradeUsers(
    IN  PWCHAR pszServer,
    IN  BOOL bLocal
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigBufferFree(
    IN      LPVOID                  pBuffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE*                 phRouterInterface
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceDelete(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceEnum(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      LPWSTR                  lpwsInterfaceName,
    OUT     HANDLE*                 phRouterInterface
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceTransportAdd(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    IN      LPWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize,
    OUT     HANDLE*                 phRouterIfTransport
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceTransportEnum(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,     // MPR_IFTRANSPORT_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterIfTransport
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceTransportRemove(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      HANDLE                  hRouterIfTransport
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigServerConnect(
    IN      LPWSTR                  lpwsServerName,
    OUT     HANDLE*                 phMprConfig
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
VOID APIENTRY
MprConfigServerDisconnect(
    IN      HANDLE                  hMprConfig
    )
{
}

static
DWORD APIENTRY
MprConfigTransportCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    IN      LPWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      LPWSTR                  lpwsDLLPath,
    OUT     HANDLE*                 phRouterTransport
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigTransportDelete(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterTransport
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigTransportGetInfo(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport,
    IN  OUT LPBYTE*                 ppGlobalInfo                OPTIONAL,
    OUT     LPDWORD                 lpdwGlobalInfoSize          OPTIONAL,
    IN  OUT LPBYTE*                 ppClientInterfaceInfo       OPTIONAL,
    OUT     LPDWORD                 lpdwClientInterfaceInfoSize OPTIONAL,
    IN  OUT LPWSTR*                 lplpwsDLLPath               OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprSetupIpInIpInterfaceFriendlyNameEnum(
    IN  PWCHAR  pwszMachineName,
    OUT LPBYTE* lplpBuffer,
    OUT LPDWORD lpdwEntriesRead
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprSetupIpInIpInterfaceFriendlyNameFree(
    IN  LPVOID  lpBuffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
MprConfigInterfaceTransportGetInfo(
    IN      HANDLE  hMprConfig,
    IN      HANDLE  hRouterInterface,
    IN      HANDLE  hRouterIfTransport,
    IN  OUT LPBYTE* ppInterfaceInfo       OPTIONAL,
    OUT     LPDWORD lpdwInterfaceInfoSize OPTIONAL
)
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mprapi)
{
    DLPENTRY(MprAdminBufferFree)
    DLPENTRY(MprAdminConnectionEnum)
    DLPENTRY(MprAdminConnectionGetInfo)
    DLPENTRY(MprAdminDeregisterConnectionNotification)
    DLPENTRY(MprAdminInterfaceCreate)
    DLPENTRY(MprAdminInterfaceDelete)
    DLPENTRY(MprAdminInterfaceEnum)
    DLPENTRY(MprAdminInterfaceGetHandle)
    DLPENTRY(MprAdminInterfaceTransportAdd)
    DLPENTRY(MprAdminIsServiceRunning)
    DLPENTRY(MprAdminMIBBufferFree)
    DLPENTRY(MprAdminMIBEntryCreate)
    DLPENTRY(MprAdminMIBEntryDelete)
    DLPENTRY(MprAdminMIBEntryGet)
    DLPENTRY(MprAdminMIBEntrySet)
    DLPENTRY(MprAdminMIBServerConnect)
    DLPENTRY(MprAdminMIBServerDisconnect)
    DLPENTRY(MprAdminPortEnum)
    DLPENTRY(MprAdminPortGetInfo)
    DLPENTRY(MprAdminRegisterConnectionNotification)
    DLPENTRY(MprAdminServerConnect)
    DLPENTRY(MprAdminServerDisconnect)
    DLPENTRY(MprAdminTransportCreate)
    DLPENTRY(MprAdminUpgradeUsers)
    DLPENTRY(MprConfigBufferFree)
    DLPENTRY(MprConfigInterfaceCreate)
    DLPENTRY(MprConfigInterfaceDelete)
    DLPENTRY(MprConfigInterfaceEnum)
    DLPENTRY(MprConfigInterfaceGetHandle)
    DLPENTRY(MprConfigInterfaceTransportAdd)
    DLPENTRY(MprConfigInterfaceTransportEnum)
    DLPENTRY(MprConfigInterfaceTransportGetHandle)
    DLPENTRY(MprConfigInterfaceTransportGetInfo)
    DLPENTRY(MprConfigInterfaceTransportRemove)
    DLPENTRY(MprConfigServerConnect)
    DLPENTRY(MprConfigServerDisconnect)
    DLPENTRY(MprConfigTransportCreate)
    DLPENTRY(MprConfigTransportDelete)
    DLPENTRY(MprConfigTransportGetHandle)
    DLPENTRY(MprConfigTransportGetInfo)
    DLPENTRY(MprSetupIpInIpInterfaceFriendlyNameEnum)
    DLPENTRY(MprSetupIpInIpInterfaceFriendlyNameFree)
};

DEFINE_PROCNAME_MAP(mprapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\inc\makefile.inc ===
$(O)\atm.h: atm.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\blberr.h: blberr.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\g711uids.h: g711uids.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspaddr.h: mspaddr.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspbase.h: mspbase.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspcall.h: mspcall.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspcoll.h: mspcoll.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspenum.h: mspenum.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\msplog.h: msplog.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspstrm.h: mspstrm.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspterm.h: mspterm.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\mspthrd.h: mspthrd.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\msptrmac.h: msptrmac.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\msptrmar.h: msptrmar.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\msptrmvc.h: msptrmvc.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\msputils.h: msputils.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ndistapi.h: ndistapi.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ndiswan.h: ndiswan.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\nettypes.h: nettypes.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\qos.h: qos.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\qosname.h: qosname.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\qospol.h: qospol.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\qossp.h: qossp.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\rnderr.h: rnderr.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\sdperr.h: sdperr.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tapi.xc: tapi.x
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tapi.h: $(O)\tapi.xc
    hsplit -s -o $@ nul: $?

$(O)\tdi.h: tdi.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tdiinfo.h: tdiinfo.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tdikrnl.h: tdikrnl.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tdistat.h: tdistat.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\traffic.h: traffic.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tspi.xc: tspi.x
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tspi.h: $(O)\tspi.xc
    hsplit -s -o $@ nul: $?

$(O)\tapiclnt.xc: tapiclnt.x
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\tapiclnt.h: $(O)\tapiclnt.xc
    hsplit -s -o $@ nul: $?

$(O)\viduids.h: viduids.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

#
# winnet
#
$(O)\winnet.wc : winnet.w
   $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\winnetwk.x $(O)\winnetp.x: $(O)\winnet.wc
    hsplit -e -o $(O)\winnetwk.x $(O)\winnetp.x $(O)\winnet.wc

$(O)\winnetp.h: $(O)\winnetp.x
    wcshdr < $? > $@

$(O)\winnetwk.h: $(O)\winnetwk.x
    wcshdr < $? > $@

all: $(DDK_INC_PATH)\ndis.h

$(DDK_INC_PATH)\ndis.h: $(O)\ndis.h
    $(PUBLISH_CMD) {$?=$@}

NDIS_DEPENDS = \
    $(DDK_INC_PATH)\netpnp.h          \
    ndismain.w       \
    ndisprot.w       \
    ndismac.w        \
    ndismini.w       \
    ndisco.w

$(O)\ndis.h: $(BASE_INC_PATH)\ndisbase.w $(NDIS_DEPENDS) makefile.inc
    copy $(BASE_INC_PATH)\ndisbase.w $@
    type << >> $@
//
// END INTERNAL DEFINITIONS
//
// The following definitions may be used by NDIS drivers, except as noted.
//

<<
    type $(DDK_INC_PATH)\netpnp.h >> $@
    type << >> $@

<<
    type ndismain.w >> $@
    type << >> $@

<<
    type ndisprot.w >> $@
    type << >> $@

//
// The following definitions are available only to full MAC drivers.  They
// must not be used by miniport drivers.
//

<<
    type ndismac.w >> $@
    type << >> $@

//
// The following definitions are available only to miniport drivers.  They
// must not be used by full MAC drivers.
//

#if defined(NDIS_MINIPORT_DRIVER) || defined(NDIS_WRAPPER)

<<
    type ndismini.w >> $@
    type << >> $@

#endif // defined(NDIS_MINIPORT_DRIVER) || defined(NDIS_WRAPPER)

#if defined(NDIS50) || defined(NDIS50_MINIPORT) || defined(NDIS51_MINIPORT)
<<
    type ndisco.w >> $@
    type << >> $@

#endif // defined(NDIS50) || defined(NDIS50_MINIPORT) || defined(NDIS51_MINIPORT)

#endif // _NDIS_
<<

$(O)\ndismain.h : ndismain.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ndisprot.h : ndisprot.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ndismac.h : ndismac.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ndismini.h : ndismini.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(O)\ndisco.h : ndisco.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

{$(O)}.h{$(PROJECT_ROOT)\inc\$(O)}.h:
   copy $< $@

$(PROJECT_ROOT)\inc\$(O)\tapip.h : tapi.x
    copy $? $@

$(PROJECT_ROOT)\inc\$(O)\tapclntp.h : tapiclnt.x
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\dload\dhcpcsvc.c ===
#include "netpch.h"
#pragma hdrstop

#include <dhcpcapi.h>


static
DWORD
APIENTRY
DhcpAcquireParameters(
    LPWSTR AdapterName
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD
APIENTRY
DhcpAcquireParametersByBroadcast(
    LPWSTR AdapterName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
DhcpNotifyConfigChange(
    LPWSTR ServerName,
    LPWSTR AdapterName,
    BOOL IsNewIpAddress,
    DWORD IpIndex,
    DWORD IpAddress,
    DWORD SubnetMask,
    SERVICE_ENABLE DhcpServiceEnabled
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD 
APIENTRY
DhcpStaticRefreshParams(
    IN LPWSTR Adapter
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD
APIENTRY
DhcpReleaseParameters(
    LPWSTR AdapterName
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(dhcpcsvc)
{
    DLPENTRY(DhcpAcquireParameters)
    DLPENTRY(DhcpAcquireParametersByBroadcast)
    DLPENTRY(DhcpNotifyConfigChange)
    DLPENTRY(DhcpReleaseParameters)
    DLPENTRY(DhcpStaticRefreshParams)
};

DEFINE_PROCNAME_MAP(dhcpcsvc)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\dload\rasman.c ===
#include "netpch.h"
#pragma hdrstop

#include <rasapip.h>

static
DWORD
APIENTRY
RasReferenceRasman (
    BOOL fAttach
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasInitialize()
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(rasman)
{
    DLPENTRY(RasInitialize)
    DLPENTRY(RasReferenceRasman)
};

DEFINE_PROCNAME_MAP(rasman)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\dload\netcfgx.c ===
#include "netpch.h"
#pragma hdrstop

#include "netcfgx.h"
#include "netcfgp.h"


static
HRESULT
WINAPI
HrDiAddComponentToINetCfg(
    INetCfg* pINetCfg,
    INetCfgInternalSetup* pInternalSetup,
    const NIQ_INFO* pInfo)    
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
VOID
WINAPI
UpdateLanaConfigUsingAnswerfile (
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszSection)
{
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(netcfgx)
{
    DLPENTRY(HrDiAddComponentToINetCfg)
    DLPENTRY(UpdateLanaConfigUsingAnswerfile)
};

DEFINE_PROCNAME_MAP(netcfgx)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\dload\netshell.c ===
#include "netpch.h"
#pragma hdrstop

#include <setupapi.h>

static
HRESULT
WINAPI
HrGetAnswerFileParametersForNetCard(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN PCWSTR pszDeviceName,
    IN const GUID*  pguidNetCardInstance,
    OUT PWSTR* ppszwAnswerFile,
    OUT PWSTR* ppszwAnswerSections)
{
    return E_FAIL;
}

static
HRESULT
WINAPI
HrOemUpgrade(
    IN HKEY hkeyDriver,
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszAnswerSection)
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(netshell)
{
    DLPENTRY(HrGetAnswerFileParametersForNetCard)
    DLPENTRY(HrOemUpgrade)
};

DEFINE_PROCNAME_MAP(netshell)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\dload\rasdlg.c ===
#include "netpch.h"
#pragma hdrstop

#include <ras.h>
#include <rasdlg.h>
#include <rasuip.h>
#include <hnetcfg.h>

static
BOOL
APIENTRY
RasDialDlgW (
    LPWSTR lpszPhonebook,
    LPWSTR lpszEntry,
    LPWSTR lpszPhoneNumber,
    LPRASDIALDLG lpInfo
    )
{
    lpInfo->dwError = ERROR_PROC_NOT_FOUND;
    return FALSE;
}

static
BOOL
APIENTRY
RasEntryDlgW (
    LPWSTR lpszPhonebook,
    LPWSTR lpszEntry,
    LPRASENTRYDLGW lpInfo
    )
{
    lpInfo->dwError = ERROR_PROC_NOT_FOUND;
    return FALSE;
}

static
DWORD
APIENTRY
RasSrvAddPropPages (
    IN HRASSRVCONN          hRasSrvConn,
    IN HWND                 hwndParent,
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvAddWizPages (
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvAllowConnectionsConfig (
    OUT BOOL* pfAllow
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvCleanupService (
    VOID
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvEnumConnections (
    IN OUT  LPRASSRVCONN    pRasSrvConn,    // Buffer of array of connections.
    IN      LPDWORD         pcb,            // size in bytes of buffer
    OUT     LPDWORD         pcConnections
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvHangupConnection (
    IN  HRASSRVCONN hRasSrvConn
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvInitializeService (
    VOID
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvIsConnectionConnected (
    IN  HRASSRVCONN hRasSrvConn,            // The connection in question
    OUT BOOL*       pfConnected
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSrvQueryShowIcon (
    OUT BOOL* pfShowIcon
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasUserEnableManualDial (
    IN HWND  hwndParent,    // parent for error dialogs
    IN BOOL  bLogon,        // whether a user is logged in
    IN BOOL  bEnable
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasUserGetManualDial (
    IN HWND  hwndParent,    // parent for error dialogs
    IN BOOL  bLogon,        // whether a user is logged in
    IN PBOOL pbEnabled
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasUserPrefsDlg (
    HWND hwndParent
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasWizCreateNewEntry(
    IN  DWORD    dwRasWizType,
    IN  LPVOID   pvData,
    OUT LPWSTR   pszwPbkFile,
    OUT LPWSTR   pszwEntryName,
    OUT DWORD*   pdwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasWizGetNCCFlags(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT DWORD * pdwFlags)
{
    return ERROR_PROC_NOT_FOUND;
}



static
DWORD
APIENTRY
RasWizGetSuggestedEntryName(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwSuggestedName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasWizGetUserInputConnectionName (
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwInputName)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasWizIsEntryRenamable(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT BOOL*   pfRenamable
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasWizQueryMaxPageCount(
    IN  DWORD    dwRasWizType
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasWizSetEntryName(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    IN  LPCWSTR pszwName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
APIENTRY
RasPhonebookDlgW(
    LPWSTR lpszPhonebook,
    LPWSTR lpszEntry,
    LPRASPBDLGW lpInfo
    )
{
    if (lpInfo)
    {
        lpInfo->dwError = ERROR_PROC_NOT_FOUND;
    }

    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(rasdlg)
{
    DLPENTRY(RasDialDlgW)
    DLPENTRY(RasEntryDlgW)
    DLPENTRY(RasPhonebookDlgW)
    DLPENTRY(RasSrvAddPropPages)
    DLPENTRY(RasSrvAddWizPages)
    DLPENTRY(RasSrvAllowConnectionsConfig)
    DLPENTRY(RasSrvCleanupService)
    DLPENTRY(RasSrvEnumConnections)
    DLPENTRY(RasSrvHangupConnection)
    DLPENTRY(RasSrvInitializeService)
    DLPENTRY(RasSrvIsConnectionConnected)
    DLPENTRY(RasSrvQueryShowIcon)
    DLPENTRY(RasUserEnableManualDial)
    DLPENTRY(RasUserGetManualDial)
    DLPENTRY(RasUserPrefsDlg)
    DLPENTRY(RasWizCreateNewEntry)
    DLPENTRY(RasWizGetNCCFlags)
    DLPENTRY(RasWizGetSuggestedEntryName)
    DLPENTRY(RasWizGetUserInputConnectionName)
    DLPENTRY(RasWizIsEntryRenamable)
    DLPENTRY(RasWizQueryMaxPageCount)
    DLPENTRY(RasWizSetEntryName)
};

DEFINE_PROCNAME_MAP(rasdlg)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\dload\rasapi32.c ===
#include "netpch.h"
#pragma hdrstop

#include <ras.h>
#include <rasapip.h>
#include <rasuip.h>


static
DWORD
APIENTRY
DwCloneEntry(
    IN      LPCWSTR lpwszPhonebookPath,
    IN      LPCWSTR lpwszSrcEntryName,
    IN      LPCWSTR lpwszDstEntryName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
DwEnumEntryDetails(
    IN     LPCWSTR               lpszPhonebookPath,
    OUT    LPRASENUMENTRYDETAILS lprasentryname,
    IN OUT LPDWORD               lpcb,
    OUT    LPDWORD               lpcEntries
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
DwRasUninitialize()
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD
APIENTRY
RasConnectionNotificationW (
    HRASCONN hrasconn,
    HANDLE hEvent,
    DWORD dwfEvents
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasDeleteEntryW (
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszEntry
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasEnumConnectionsW (
    LPRASCONNW lprasconn,
    LPDWORD lpcb,
    LPDWORD lpcbConnections
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasGetConnectStatusW (
    HRASCONN hrasconn,
    LPRASCONNSTATUSW lprasconnstatus
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasGetConnectionStatistics (
    HRASCONN hRasConn,
    RAS_STATS *lpStatistics
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasGetEntryPropertiesW (
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszEntry,
    LPRASENTRYW lpRasEntry,
    LPDWORD lpcbRasEntry,
    LPBYTE lpbDeviceConfig,
    LPDWORD lpcbDeviceConfig
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasGetErrorStringW (
    IN  UINT  ResourceId,
    OUT LPWSTR lpszString,
    IN  DWORD InBufSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD APIENTRY
RasGetProjectionInfoW(
    HRASCONN        hrasconn,
    RASPROJECTION   rasprojection,
    LPVOID          lpprojection,
    LPDWORD         lpcb )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasGetSubEntryHandleW (
    HRASCONN hrasconn,
    DWORD dwSubEntry,
    LPHRASCONN lphrasconn
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasGetSubEntryPropertiesW (
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszEntry,
    DWORD dwSubEntry,
    LPRASSUBENTRYW lpRasSubEntry,
    LPDWORD lpcbRasSubEntry,
    LPBYTE lpbDeviceConfig,
    LPDWORD lpcbDeviceCnfig
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasHangUpW (
    HRASCONN hrasconn
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasIsSharedConnection(
    IN LPRASSHARECONN   pConn,
    OUT PBOOL           pfShared
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasQueryLanConnTable(
    IN LPRASSHARECONN   pExcludedConn,
    OUT LPVOID*         ppvLanConnTable OPTIONAL, // NETCON_PROPERTIES
    OUT LPDWORD         pdwLanConnCount
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasRenameEntryW (
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszOldEntry,
    LPCWSTR lpszNewEntry
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasSetEntryPropertiesW (
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszEntry,
    LPRASENTRYW lpRasEntry,
    DWORD dwcbRasEntry,
    LPBYTE lpbDeviceConfig,
    DWORD dwcbDeviceConfig
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasShareConnection(
    IN LPRASSHARECONN   pConn,
    IN GUID*            pPrivateLanGuid OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasUnshareConnection(
    OUT PBOOL           pfWasShared OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasValidateEntryNameW (
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszEntry
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
RasQuerySharedConnection(
    OUT LPRASSHARECONN  pConn
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(rasapi32)
{
    DLPENTRY(DwCloneEntry)
    DLPENTRY(DwEnumEntryDetails)
    DLPENTRY(DwRasUninitialize)
    DLPENTRY(RasConnectionNotificationW)
    DLPENTRY(RasDeleteEntryW)
    DLPENTRY(RasEnumConnectionsW)
    DLPENTRY(RasGetConnectStatusW)
    DLPENTRY(RasGetConnectionStatistics)
    DLPENTRY(RasGetEntryPropertiesW)
    DLPENTRY(RasGetErrorStringW)
    DLPENTRY(RasGetProjectionInfoW)
    DLPENTRY(RasGetSubEntryHandleW)
    DLPENTRY(RasGetSubEntryPropertiesW)
    DLPENTRY(RasHangUpW)
    DLPENTRY(RasIsSharedConnection)
    DLPENTRY(RasQueryLanConnTable)
    DLPENTRY(RasQuerySharedConnection)
    DLPENTRY(RasRenameEntryW)
    DLPENTRY(RasSetEntryPropertiesW)
    DLPENTRY(RasShareConnection)
    DLPENTRY(RasUnshareConnection)
    DLPENTRY(RasValidateEntryNameW)
};

DEFINE_PROCNAME_MAP(rasapi32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\dload\wzcdlg.c ===
#include "netpch.h"
#pragma hdrstop

#include <netcon.h>
#include <wzcdlg.h>

static
HRESULT
WZCCanShowBalloon (
        IN const GUID * pGUIDConn,
        IN const PCWSTR pszConnectionName,
        IN OUT   BSTR * pszBalloonText,
        IN OUT   BSTR * pszCookie
        )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WZCOnBalloonClick (
        IN const GUID * pGUIDConn,
        IN const BSTR pszConnectionName,
        IN const BSTR szCookie
        )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WZCQueryConnectionStatusText (
        IN const GUID *  pGUIDConn,
        IN const NETCON_STATUS ncs,
        IN OUT BSTR *  pszStatusText
        )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(wzcdlg)
{
    DLPENTRY(WZCCanShowBalloon)
    DLPENTRY(WZCOnBalloonClick)
    DLPENTRY(WZCQueryConnectionStatusText)
};

DEFINE_PROCNAME_MAP(wzcdlg)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\dload\ws2_32.c ===
#include "netpch.h"
#pragma hdrstop

#define WINSOCK_API_LINKAGE
#include <ws2spi.h>

#define SWAP_LONG(l)                                \
            ( ( ((l) >> 24) & 0x000000FFL ) |       \
              ( ((l) >>  8) & 0x0000FF00L ) |       \
              ( ((l) <<  8) & 0x00FF0000L ) |       \
              ( ((l) << 24) & 0xFF000000L ) )

#define WS_SWAP_SHORT(s)                            \
            ( ( ((s) >> 8) & 0x00FF ) |             \
              ( ((s) << 8) & 0xFF00 ) )


static
WINSOCK_API_LINKAGE
int
WSAAPI
WSAAddressToStringA(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOA lpProtocolInfo,
    IN OUT LPSTR               lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
WSAAddressToStringW(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN OUT LPWSTR             lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
WSACleanup(
    void
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
WSAGetLastError(
    void
    )
{
    return ERROR_MOD_NOT_FOUND;
}

static
int
WSAAPI
WSAStartup(
    IN WORD wVersionRequested,
    OUT LPWSADATA lpWSAData
    )
{
    return WSAEFAULT;
}

static
int
WSAAPI
WSALookupServiceBeginW(
    IN  LPWSAQUERYSETW lpqsRestrictions,
    IN  DWORD          dwControlFlags,
    OUT LPHANDLE       lphLookup
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
WSALookupServiceNextW(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETW   lpqsResults
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
WSALookupServiceEnd(
    IN HANDLE  hLookup
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
WSAStringToAddressW(
    IN     LPWSTR              AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    OUT    LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    )
{
    return SOCKET_ERROR;
}

static
int
WSPAPI
WSCDeinstallProvider(
    IN LPGUID lpProviderId,
    OUT LPINT lpErrno
    )
{
    *lpErrno = WSAEFAULT;
    return SOCKET_ERROR;
}

static
int
WSPAPI
WSCDeinstallProvider32(
    IN LPGUID lpProviderId,
    OUT LPINT lpErrno
    )
{
    *lpErrno = WSAEFAULT;
    return SOCKET_ERROR;
}

static
int
WSPAPI
WSCEnumProtocols(
    IN LPINT lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    OUT LPINT lpErrno
    )
{
    *lpErrno = WSAEFAULT;
    return SOCKET_ERROR;
}

static
INT
WSPAPI
WSCInstallNameSpace (
    IN LPWSTR lpszIdentifier,
    IN LPWSTR lpszPathName,
    IN DWORD dwNameSpace,
    IN DWORD dwVersion,
    IN LPGUID lpProviderId
    )
{
    return SOCKET_ERROR;
}

static
INT
WSPAPI
WSCInstallNameSpace32 (
    IN LPWSTR lpszIdentifier,
    IN LPWSTR lpszPathName,
    IN DWORD dwNameSpace,
    IN DWORD dwVersion,
    IN LPGUID lpProviderId
    )
{
    return SOCKET_ERROR;
}

static
int
WSPAPI
WSCInstallProvider(
    IN LPGUID lpProviderId,
    IN const WCHAR FAR * lpszProviderDllPath,
    IN const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    )
{
    *lpErrno = WSAEFAULT;
    return SOCKET_ERROR;
}

static
int
WSPAPI
WSCInstallProvider64_32(
    IN LPGUID lpProviderId,
    IN const WCHAR FAR * lpszProviderDllPath,
    IN const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    )
{
    *lpErrno = WSAEFAULT;
    return SOCKET_ERROR;
}

static
INT
WSPAPI
WSCUnInstallNameSpace (
    IN LPGUID lpProviderId
    )
{
    return SOCKET_ERROR;
}

static
INT
WSPAPI
WSCUnInstallNameSpace32 (
    IN LPGUID lpProviderId
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
bind(
    IN SOCKET s,
    IN const struct sockaddr FAR * name,
    IN int namelen
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
connect(
    IN SOCKET s,
    IN const struct sockaddr FAR * name,
    IN int namelen
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
closesocket(
    IN SOCKET s
    )
{
    return SOCKET_ERROR;
}

static
struct hostent FAR *
WSAAPI
gethostbyname(
    IN const char FAR * name
    )
{
    return NULL;
}

static
int
WSAAPI
getsockname(
    IN SOCKET s,
    OUT struct sockaddr FAR * name,
    OUT int FAR * namelen
    )
{
    return SOCKET_ERROR;
}

static
int
WSAAPI
getsockopt(
    IN SOCKET s,
    IN int level,
    IN int optname,
    OUT char FAR * optval,
    IN OUT int FAR * optlen
    )
{
    return SOCKET_ERROR;
}

static
WINSOCK_API_LINKAGE
u_long
WSAAPI
htonl(
    IN u_long hostlong
    )
{
    return SWAP_LONG( hostlong );
}

static
WINSOCK_API_LINKAGE
u_short
WSAAPI
htons(
    IN u_short hostshort
    )
{
    return WS_SWAP_SHORT( hostshort );
}

static
unsigned long
WSAAPI
inet_addr(
    IN const char FAR * cp
    )
{
    return INADDR_NONE;
}

static
char FAR *
WSAAPI
inet_ntoa(
    IN struct in_addr in
    )
{
    return NULL;
}

static
u_long
WSAAPI
ntohl(
    IN u_long netlong
    )
{
    return SWAP_LONG( netlong );
}

WINSOCK_API_LINKAGE
u_short
WSAAPI
ntohs(
    IN u_short netshort
    )
{
    return WS_SWAP_SHORT( netshort );
}

static
SOCKET
WSAAPI
socket(
    IN int af,
    IN int type,
    IN int protocol
    )
{
    return INVALID_SOCKET;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(ws2_32)
{
    DLOENTRY(  2, bind)
    DLOENTRY(  3, closesocket)
    DLOENTRY(  4, connect)
    DLOENTRY(  6, getsockname)
    DLOENTRY(  7, getsockopt)
    DLOENTRY(  8, htonl)
    DLOENTRY(  9, htons)
    DLOENTRY( 11, inet_addr)
    DLOENTRY( 12, inet_ntoa)
    DLOENTRY( 14, ntohl)
    DLOENTRY( 15, ntohs)
    DLOENTRY( 23, socket)
    DLOENTRY( 52, gethostbyname)
    DLOENTRY(111, WSAGetLastError)
    DLOENTRY(115, WSAStartup)
    DLOENTRY(116, WSACleanup)
};

DEFINE_ORDINAL_MAP(ws2_32);

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ws2_32)
{
    DLPENTRY(WSAAddressToStringA)
    DLPENTRY(WSAAddressToStringW)
    DLPENTRY(WSALookupServiceBeginW)
    DLPENTRY(WSALookupServiceEnd)
    DLPENTRY(WSALookupServiceNextW)
    DLPENTRY(WSAStringToAddressW)
    DLPENTRY(WSCDeinstallProvider)
    DLPENTRY(WSCDeinstallProvider32)
    DLPENTRY(WSCEnumProtocols)
    DLPENTRY(WSCInstallNameSpace)
    DLPENTRY(WSCInstallNameSpace32)
    DLPENTRY(WSCInstallProvider)
    DLPENTRY(WSCInstallProvider64_32)
    DLPENTRY(WSCUnInstallNameSpace)
    DLPENTRY(WSCUnInstallNameSpace32)
};

DEFINE_PROCNAME_MAP(ws2_32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\dload\rtutils.c ===
#include "netpch.h"
#pragma hdrstop

#include <rtutils.h>

static
VOID
APIENTRY
RouterLogDeregisterW(
    HANDLE hLogHandle
    )
{
}

static
VOID
APIENTRY
RouterLogEventW(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPWSTR *plpszSubStringArray,
    IN DWORD dwErrorCode
    )
{
}

static
HANDLE
APIENTRY
RouterLogRegisterW(
    LPCWSTR lpszSource
    )
{
    return NULL;
}

static
DWORD
APIENTRY
TraceDeregisterW(
    IN  DWORD       dwTraceID
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
TraceRegisterExW(
    IN  LPCWSTR     lpszCallerName,
    IN  DWORD       dwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
TraceVprintfExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCSTR      lpszFormat,
    IN  va_list     arglist
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
APIENTRY
TraceVprintfExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCWSTR     lpszFormat,
    IN  va_list     arglist
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(rtutils)
{
    DLPENTRY(RouterLogDeregisterW)
    DLPENTRY(RouterLogEventW)
    DLPENTRY(RouterLogRegisterW)
    DLPENTRY(TraceDeregisterW)
    DLPENTRY(TraceRegisterExW)
    DLPENTRY(TraceVprintfExA)
    DLPENTRY(TraceVprintfExW)
};

DEFINE_PROCNAME_MAP(rtutils)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\unixapis\getlogin.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    getlogin.c

Abstract:

    Emulates the Unix getlogin routine. Used by libstcp and the tcpcmd
    utilities.

Author:

    Mike Massa (mikemas)           Sept 20, 1991

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     10-29-91     created
    sampa       10-31-91     modified getpass to not echo input

Notes:

    Exports:

    getlogin

--*/
#include <stdio.h>
#include <windef.h>
#include <winbase.h>


int
getlogin(
    OUT char *UserName,
    IN  int   len
    )
{

    DWORD llen = len;

    if (!GetUserNameA(UserName, &llen)) {
        return(-1);
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\unixapis\makefile.inc ===
$(O)\nlstxt.mc: $(PROJECT_ROOT)\inc\unixapis.mc
    copy $? $@
    $(MC) -v -h $(O) -r $(O) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\unixapis\getpass.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    getpass.c

Abstract:

    Emulates the Unix getpass routine. Used by libstcp and the tcpcmd
    utilities.

Author:

    Mike Massa (mikemas)           Sept 20, 1991

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     10-29-91     created
    sampa       10-31-91     modified getpass to not echo input

Notes:

    Exports:

    getpass

--*/

#include <stdio.h>
#include <windef.h>
#include <winbase.h>
#include <wincon.h>
#include <nls.h>
#include <winuser.h>
#include "nlstxt.h"

#define MAXPASSLEN 32

static char     pbuf[MAXPASSLEN+1];

/******************************************************************/
char *
getpass(
    char *prompt
    )
/******************************************************************/
{
    HANDLE          InHandle, OutHandle;
    unsigned long   SaveMode, NewMode;
    BOOL            Result;
    DWORD           NumBytes;
    int             i;

    pbuf[0] = 0;

    InHandle = CreateFile("CONIN$",
                          GENERIC_READ | GENERIC_WRITE,
			  FILE_SHARE_READ | FILE_SHARE_WRITE,
			  NULL,
			  OPEN_EXISTING,
			  FILE_ATTRIBUTE_NORMAL,
			  NULL
			 );

    if (InHandle == (HANDLE) -1)
        {
        NlsPutMsg(STDOUT, LIBUEMUL_ERROR_GETTING_CI_HANDLE,GetLastError());
        CloseHandle(InHandle);
        return(pbuf);
        }

    OutHandle = CreateFile("CONOUT$",
                          GENERIC_WRITE,
			  FILE_SHARE_READ | FILE_SHARE_WRITE,
			  NULL,
			  OPEN_EXISTING,
			  FILE_ATTRIBUTE_NORMAL,
			  NULL
			 );

    if (OutHandle == (HANDLE) -1)
        {
        NlsPutMsg(STDOUT, LIBUEMUL_ERROR_GETTING_CO_HANDLE,GetLastError());
        CloseHandle(InHandle);
        CloseHandle(OutHandle);
        return(pbuf);
        }

    Result =
    GetConsoleMode(InHandle, &SaveMode);

    if (!Result)
        {
        NlsPutMsg(STDOUT,LIBUEMUL_ERROR_GETTING_CON_MODE, GetLastError());
        CloseHandle(InHandle);
        CloseHandle(OutHandle);
        return(pbuf);
        }

    NewMode = SaveMode & ~ENABLE_ECHO_INPUT;

    Result = SetConsoleMode(InHandle, NewMode);

    if (!Result)
        {
        NlsPutMsg(STDOUT,LIBUEMUL_ERROR_SETTING_CON_MODE, GetLastError());
        CloseHandle(InHandle);
        CloseHandle(OutHandle);
        return(pbuf);
        }

    NumBytes = strlen (prompt);

    CharToOemBuff (prompt, prompt, NumBytes);

    Result =
    WriteFile (
        OutHandle,
        prompt,
        NumBytes,
        &NumBytes,
        NULL);

    if (!Result)
        {
        NlsPutMsg(STDOUT,LIBUEMUL_WRITE_TO_CONSOLEOUT_ERROR, GetLastError());
        Result = SetConsoleMode(InHandle, SaveMode);
        CloseHandle(InHandle);
        CloseHandle(OutHandle);
        return(pbuf);
        }

    Result =
    ReadFile(
        InHandle,
        pbuf,
        MAXPASSLEN,
        &NumBytes,
        NULL);

    if (!Result)
        {
        NlsPutMsg(STDOUT,LIBUEMUL_READ_FROM_CONSOLEIN_ERROR, GetLastError());
        }

    OemToCharBuff (pbuf, pbuf, NumBytes);

    // peel off linefeed
    i =  (int) NumBytes;
    while(--i >= 0) {
        if ((pbuf[i] == '\n') || (pbuf[i] == '\r')) {
            pbuf[i] = '\0';
	}
    }

    Result = SetConsoleMode(InHandle, SaveMode);

    if (!Result)
        {
        NlsPutMsg(STDOUT, LIBUEMUL_ERROR_RESTORING_CONSOLE_MODE, GetLastError());
        }

    WriteFile(
        OutHandle,
        "\n",
        1,
        &NumBytes,
        NULL);

    CloseHandle(InHandle);
    CloseHandle(OutHandle);
	
    return(pbuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\unixapis\getopt.c ===
#include <stdio.h>
#include <windef.h>
#include <winbase.h>
#include <nls.h>
#include "nlstxt.h"

char *  optarg;
int     optind = 1;
int     optinx = 1;
int     opterr;

int
getopt(
    int     ac,
    char *  av[],
    char *  opts_allowed)
{
    char        option;
    static char NoOpt[] = "";

    optarg = NoOpt;

    if (optind >= ac)
        return(-1);

    if (*av[optind] != '-')
        return(-1);

    option = av[optind][optinx];
    while ((*opts_allowed ) && (*opts_allowed != option))
        opts_allowed ++;

    if (!*opts_allowed)
        {
        NlsPutMsg(STDOUT, LIBUEMUL_OPTION_INVALID, option);
        return((int) '?');
        }

    if ( *(opts_allowed + 1) == ':')   // there's an argument
        {
        if (av[optind][optinx+1] == '\0') // the argument is in the next av[]
            {
            optind++;
            optinx = 1;
            optarg = av[optind];
            }
        else
            {
            optarg = &av[optind][optinx+1];
            }
    	if (optarg == NULL)
    	    {
            NlsPutMsg(STDOUT, LIBUEMUL_OPTION_MORE_ARGS, option);
    	    optarg = NoOpt;
    	    return((int) '?');
    	    }
        optind++;
        optinx = 1;
        }
    else
        {
        if (av[optind][optinx+1] == '\0') // no more args for this -
            {
            optind++;
            optinx = 1;
            }
        else                              // more args for this -
            {
            optinx++;
            }
        }

    return((int) option);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\nls\nls.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    nls.c

Abstract:

    This module contains functions needed for the internationalisation
    of the TCP/IP utilities.

Author:

    Ronald Meijer (ronaldm)	  Nov 8, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    ronaldm	11-8-92	    created

Notes:

--*/

#include <io.h>
#include <stdio.h>
#include <windef.h>
#include <winbase.h>
#include <winuser.h>

#include <nls.h>

// see comment in nls.h
//
HMODULE NlsMsgSourcemModuleHandle = NULL;

/***	NlsPutMsg - Print a message to a handle
 *
 *  Purpose:
 *	PutMsg takes the given message number from the
 *	message table resource, and displays it on the requested
 *	handle with the given parameters (optional)
 *
 *   UINT PutMsg(UINT Handle, UINT MsgNum, ... )
 *
 *  Args:
 *	Handle		- the handle to print to
 *	MsgNum		- the number of the message to print
 *	Arg1 [Arg2...]	- additonal arguments for the message as necessary
 *
 *  Returns:
 *	The number of characters printed.
 *
 */

UINT 
NlsPutMsg (
    IN UINT Handle, 
    IN UINT MsgNumber, 
    IN ...)
{
    UINT msglen;
    VOID * vp;
    va_list arglist;
    DWORD StrLen;

    va_start(arglist, MsgNumber);
    if (!(msglen = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            NlsMsgSourcemModuleHandle,
            MsgNumber,
            0L,		// Default country ID.
            (LPTSTR)&vp,
            0,
            &arglist)))
    {
	    return 0;
    }

    // Convert vp to oem
    StrLen=strlen(vp);
    CharToOemBuff((LPCTSTR)vp,(LPSTR)vp,StrLen);

    msglen = _write(Handle, vp, StrLen);
    LocalFree(vp);

    return msglen;
}

/***	NlsPerror - NLS compliant version of perror()
 *
 *  Purpose:
 *	NlsPerror takes a messagetable resource ID code, and an error
 *	value (This function replaces perror()), loads the string
 *	from the resource, and passes it with the error code to s_perror()
 *
 *   void NlsPerror(UINT usMsgNum, int nError)
 *
 *  Args:
 *
 *	usMsgNum	    The message ID
 *	nError		    Typically returned from GetLastError()
 *
 *  Returns:
 *	Nothing.
 *
 */
    extern void s_perror(
            char *yourmsg,  // your message to be displayed
            int  lerrno     // errno to be converted
            );
VOID 
NlsPerror (
    IN UINT usMsgNum, 
    IN INT nError)
{
    VOID * vp;
    UINT msglen;

    if (!(msglen = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
		    NlsMsgSourcemModuleHandle,
		    usMsgNum,
		    0L,		// Default country ID.
		    (LPTSTR)&vp,
		    0,
		    NULL)))
    {
	    return;
    }

    s_perror(vp, nError);
    LocalFree(vp);
}

UINT 
NlsSPrintf ( 
    IN UINT usMsgNum,
    OUT char* pszBuffer,
    IN DWORD cbSize,
    IN ...)
/*++
    Prints the given message into the buffer supplied.

    Arguments:
        usMsgNum        message number for resource string.
        pszBuffer       buffer into which we need to print the string
        cbSize          size of buffer
        ...             optional arguments

    Returns:
        Size of the message printed.

    History:
       MuraliK   10-19-94
--*/
{
    UINT msglen;

    va_list arglist;
    
    va_start(arglist, cbSize);
    
    msglen = FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                NlsMsgSourcemModuleHandle,
                usMsgNum,
                0L,
                (LPTSTR) pszBuffer,
                cbSize,
                &arglist);

    va_end(arglist);
    return msglen; 
}

/***	ConvertArgvToOem
 *
 *  Purpose:
 *	Convert all the command line arguments from Ansi to Oem.
 *
 *  Args:
 *
 *	argc		    Argument count
 *	argv[]		    Array of command-line arguments
 *
 *  Returns:
 *	Nothing.
 *
 *  
 */

VOID
ConvertArgvToOem(
    int argc,
    char* argv[]
    )
{
#if 0
    Bug 84807.  Removed workaround of needing to convert args to Oem by placing
                conversion immediately before dumping.
    
    int i;

    for (i=1; i<argc; ++i)
	CharToOemA(argv[i], argv[i]);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\uuid\hnclsid.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       H N C L S I D . C
//
//  Contents:   HNetCfg & HNetBcon class IDs
//
//  Notes:
//
//  Author:     jonburs 23 May 2000
//
//  History:    rgatta 16 August 2000
//              (added CLSID_InternetConnectionBeaconService)
//
//----------------------------------------------------------------------------

#define INITGUID
#include <guiddef.h>

//
// GUIDs reserved for our use
//
// 46C166AA-3108-11D4-9348-00C04F8EEB71     CLSID_HNetCfgMgr
// 46C166AB-3108-11D4-9348-00C04F8EEB71     CLSID_NetSharingManager
// 46C166AC-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumPublicConnection
// 46C166AD-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumPrivateConnection
// 46C166AE-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumApplicationDefinition
// 46C166AF-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumPortMapping
// 46C166B0-3108-11D4-9348-00C04F8EEB71     CLSID_NetSharingApplicationDefinition
// 46C166B1-3108-11D4-9348-00C04F8EEB71		CLSID_NetSharingConfiguration
// 46C166B2-3108-11D4-9348-00C04F8EEB71
// 46C166B3-3108-11D4-9348-00C04F8EEB71
// 46C166B4-3108-11D4-9348-00C04F8EEB71
// 46C166B5-3108-11D4-9348-00C04F8EEB71
// 46C166B6-3108-11D4-9348-00C04F8EEB71
// 46C166B7-3108-11D4-9348-00C04F8EEB71
// 46C166B8-3108-11D4-9348-00C04F8EEB71
// 46C166B9-3108-11D4-9348-00C04F8EEB71
// 46C166BA-3108-11D4-9348-00C04F8EEB71
// 46C166BB-3108-11D4-9348-00C04F8EEB71
// 46C166BC-3108-11D4-9348-00C04F8EEB71
// 46C166BD-3108-11D4-9348-00C04F8EEB71

DEFINE_GUID(CLSID_HNetCfgMgr, 0x46C166AA,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);



// 04df613a-5610-11d4-9ec8-00b0d022dd1f     CLSID_InternetConnectionBeaconService

DEFINE_GUID(CLSID_InternetConnectionBeaconService, 0x04df613a,0x5610,0x11d4,0x9e,0xc8,0x00,0xb0,0xd0,0x22,0xdd,0x1f);

// {9A8EA3B5-572E-4cb3-9EB9-EC689AC575AE}   CLSID_HomeNetAutoConfigService 
DEFINE_GUID(CLSID_HomeNetAutoConfigService, 0x9a8ea3b5, 0x572e, 0x4cb3, 0x9e, 0xb9, 0xec, 0x68, 0x9a, 0xc5, 0x75, 0xae);

// {46C166AB-3108-11D4-9348-00C04F8EEB71}   CLSID_NetSharingManager
//DEFINE_GUID(CLSID_NetSharingManager, 0x46C166AB,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);
// bhanlon: 1/19/01:  I'm commenting this out because (we think) that
// the netcon.idl, which now uses the "coclass" keyword, and the netshell
// component was getting "one or more multiply defined symbols found" errors.
// Commenting out this line seems to help.

// 46C166AC-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumPublicConnection
DEFINE_GUID(CLSID_SharingManagerEnumPublicConnection, 0x46C166AC,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);

// 46C166AD-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumPrivateConnection
DEFINE_GUID(CLSID_SharingManagerEnumPrivateConnection, 0x46C166AD,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);

// 46C166AE-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumApplicationDefinition
DEFINE_GUID(CLSID_SharingManagerEnumApplicationDefinition, 0x46C166AE,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);

// 46C166AF-3108-11D4-9348-00C04F8EEB71		CLSID_SharingManagerEnumPortMapping
DEFINE_GUID(CLSID_SharingManagerEnumPortMapping, 0x46C166AF,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);

// 46C166B0-3108-11D4-9348-00C04F8EEB71		CLSID_SharingApplicationDefinition
DEFINE_GUID(CLSID_SharingApplicationDefinition, 0x46C166B0,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);

// 46C166B1-3108-11D4-9348-00C04F8EEB71		CLSID_SharingConfiguration
DEFINE_GUID(CLSID_SharingConfiguration, 0x46C166B1,0x3108,0x11D4,0x93,0x48,0x00,0xC0,0x4F,0x8E,0xEB,0x71);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\dload\wzcsapi.c ===
#include "netpch.h"
#pragma hdrstop

#include <wzcsapi.h>

static
DTLLIST*
ReadEapcfgList(DWORD dwFlags)
{
    return NULL;
}

static
VOID
DtlDestroyList (
    IN OUT DTLLIST* pdtllist,
    IN     PDESTROYNODE pfuncDestroyNode)
{
}

static
VOID
DestroyEapcfgNode(
    IN OUT DTLNODE* pNode)
{
}

static
DWORD
WZCEapolGetCustomAuthData (
    IN  LPWSTR pSrvAddr,
    IN  PWCHAR pwszGuid,
    IN  DWORD dwEapTypeId,
    IN  DWORD dwSizeOfSSID,
    IN  BYTE *pbSSID,
    IN OUT PBYTE pbConnInfo,
    IN OUT PDWORD pdwInfoSize)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WZCEapolSetCustomAuthData (
    IN  LPWSTR pSrvAddr,
    IN  PWCHAR pwszGuid,
    IN  DWORD dwEapTypeId,
    IN  DWORD dwSizeOfSSID,
    IN  BYTE *pbSSID,
    IN  PBYTE pbConnInfo,
    IN  DWORD dwInfoSize)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WZCEapolGetInterfaceParams (
    IN  LPWSTR pSrvAddr,
    IN  PWCHAR pwszGuid,
    IN OUT EAPOL_INTF_PARAMS *pIntfParams
    )
{
    return ERROR_PROC_NOT_FOUND;
}

HINSTANCE
WZCGetSPResModule()
{
    return NULL;
}


static
DWORD
WZCRefreshInterface(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PINTF_ENTRY         pIntf,
    LPDWORD             pdwOutFlags)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WZCSetInterface(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PINTF_ENTRY         pIntf,
    LPDWORD             pdwOutFlags)
{
    return ERROR_PROC_NOT_FOUND;
}

static
VOID
WZCDeleteIntfObj(
    PINTF_ENTRY pIntf)
{
}

static
DWORD
WZCQueryInterface(
    LPWSTR pSrvAddr,
    DWORD dwInFlags,
    PINTF_ENTRY pIntf,
    LPDWORD pdwOutFlags)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WZCEapolSetInterfaceParams (
    IN  LPWSTR pSrvAddr,
    IN  PWCHAR pwszGuid,
    IN  EAPOL_INTF_PARAMS *pIntfParams)
{
    return ERROR_PROC_NOT_FOUND;
}

static
DTLNODE*
EapcfgNodeFromKey(
    IN DTLLIST* pList,
    IN DWORD dwKey)
{
    return NULL;
}

static
PVOID
MIDL_user_allocate(size_t NumBytes)
{
    return NULL;
}

static
VOID
MIDL_user_free(void * MemPointer)
{
}

static
DWORD
WZCEapolReAuthenticate (
    IN  LPWSTR        pSrvAddr,
    IN  PWCHAR        pwszGuid
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WZCEapolQueryState (
    IN  LPWSTR              pSrvAddr,
    IN  PWCHAR              pwszGuid,
    IN OUT EAPOL_INTF_STATE *pIntfState
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(wzcsapi)
{
    DLOENTRY(60, MIDL_user_allocate)
    DLOENTRY(61, MIDL_user_free)
};

DEFINE_ORDINAL_MAP(wzcsapi)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(wzcsapi)
{
    DLPENTRY(DestroyEapcfgNode)
    DLPENTRY(DtlDestroyList)
    DLPENTRY(EapcfgNodeFromKey)
    DLPENTRY(ReadEapcfgList)
    DLPENTRY(WZCDeleteIntfObj)
    DLPENTRY(WZCEapolGetCustomAuthData)
    DLPENTRY(WZCEapolGetInterfaceParams)
    DLPENTRY(WZCEapolQueryState)
    DLPENTRY(WZCEapolReAuthenticate)
    DLPENTRY(WZCEapolSetCustomAuthData)
    DLPENTRY(WZCEapolSetInterfaceParams)
    DLPENTRY(WZCGetSPResModule)
    DLPENTRY(WZCQueryInterface)
    DLPENTRY(WZCRefreshInterface)
    DLPENTRY(WZCSetInterface)
};

DEFINE_PROCNAME_MAP(wzcsapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\unixapis\getuname.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    getuname.c

Abstract:

    Provides a function to prompt the user for a username similar to getpass
    for passwords.

Author:

    Mike Massa (mikemas)           Sept 20, 1991

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     03-25-92     created by cloning getpass.c

Notes:

    Exports:

    getuname

--*/

#include <stdio.h>
#include <windef.h>
#include <winbase.h>
#include <wincon.h>
#include <winuser.h>
#include <nls.h>
#include "nlstxt.h"

#define MAXUSERNAMELEN 32

static char     ubuf[MAXUSERNAMELEN+1];

/******************************************************************/
char *
getusername(
    char *prompt
    )
/******************************************************************/
{
    HANDLE          InHandle, OutHandle;
    BOOL            Result;
    DWORD           NumBytes;
    int             i;

    ubuf[0] = '\0';

    InHandle = CreateFile("CONIN$",
                          GENERIC_READ | GENERIC_WRITE,
			  FILE_SHARE_READ | FILE_SHARE_WRITE,
			  NULL,
			  OPEN_EXISTING,
			  FILE_ATTRIBUTE_NORMAL,
			  NULL
			 );

    if (InHandle == (HANDLE) -1)
        {
        NlsPutMsg(STDERR,LIBUEMUL_ERROR_GETTING_CI_HANDLE,GetLastError());
        CloseHandle(InHandle);
        return(ubuf);
        }

    OutHandle = CreateFile("CONOUT$",
                          GENERIC_WRITE,
			  FILE_SHARE_READ | FILE_SHARE_WRITE,
			  NULL,
			  OPEN_EXISTING,
			  FILE_ATTRIBUTE_NORMAL,
			  NULL
			 );

    if (OutHandle == (HANDLE) -1)
        {
        NlsPutMsg(STDERR,LIBUEMUL_ERROR_GETTING_CO_HANDLE,GetLastError());
        CloseHandle(InHandle);
        CloseHandle(OutHandle);
        return(ubuf);
        }

    NumBytes = strlen (prompt);

    CharToOemBuff (prompt, prompt, NumBytes);

    Result =
    WriteFile (
        OutHandle,
        prompt,
        NumBytes,
        &NumBytes,
        NULL);

    if (!Result)
        {
        NlsPutMsg(STDERR,LIBUEMUL_WRITE_TO_CONSOLEOUT_ERROR, GetLastError());
        CloseHandle(InHandle);
        CloseHandle(OutHandle);
        return(ubuf);
        }

    Result =
    ReadFile(
        InHandle,
        ubuf,
        MAXUSERNAMELEN,
        &NumBytes,
        NULL);

    if (!Result)
        {
        NlsPutMsg(STDERR,LIBUEMUL_READ_FROM_CONSOLEIN_ERROR, GetLastError());
        }

    OemToCharBuff (ubuf, ubuf, NumBytes);

    // peel off linefeed
    i =  (int) NumBytes;
    while(--i >= 0) {
        if ((ubuf[i] == '\n') || (ubuf[i] == '\r')) {
            ubuf[i] = '\0';
	}
    }
	
    CloseHandle(InHandle);
    CloseHandle(OutHandle);

    return(ubuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\uuid\ndisguid.c ===
#define INITGUID
#include <guiddef.h>

#include <ndisguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\uuid\ncclsid.c ===
#define INITGUID
#include <guiddef.h>

DEFINE_GUID(CLSID_CNetCfg,                  0x5B035261,0x40F9,0x11D1,0xAA,0xEC,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_ConnectionCommonUi,       0x7007ACD1,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);

DEFINE_GUID(CLSID_ConnectionManager,        0xBA126AD1,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_ConnectionManager2,       0xBA126AE5,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);

DEFINE_GUID(CLSID_LanConnectionManager,     0xBA126AD3,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_NetConnectionUiUtilities, 0x7007ACD3,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_EAPOLManager,             0xBA126AE4,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_NetConnectionHNetUtil,    0xBA126AE3,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(GUID_NETSHELL_PROPS,            0x2d15a9a1,0xa556,0x4189,0x91,0xad,0x02,0x74,0x58,0xf1,0x1a,0x07);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\inc\ntddgpc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ntddgpc.h

Abstract:

    defines that are exported to user mode

Author:

    Ofer Bar (oferbar) 23-May-1997

Revision History:

--*/

#ifndef _NTDDGPC_
#define _NTDDGPC_


typedef struct _PROTOCOL_STAT {

    ULONG          CreatedSp;
    ULONG          DeletedSp;
    ULONG          RejectedSp;
    ULONG          CurrentSp;

    ULONG          CreatedGp;
    ULONG          DeletedGp;
    ULONG          RejectedGp;
    ULONG          CurrentGp;

    ULONG          CreatedAp;
    ULONG          DeletedAp;
    ULONG          RejectedAp;
    ULONG          CurrentAp;

    ULONG          ClassificationRequests;
    ULONG          PatternsClassified;
    ULONG          PacketsClassified;

    ULONG		   DerefPattern2Zero;
    ULONG		   FirstFragsCount;
    ULONG          LastFragsCount;
    
    ULONG		   InsertedPH;
    ULONG		   RemovedPH;

    ULONG		   InsertedRz;
    ULONG		   RemovedRz;

    ULONG		   InsertedCH;
    ULONG		   RemovedCH;

} PROTOCOL_STAT, *PPROTOCOL_STAT;

typedef struct _CF_STAT {

    ULONG          CreatedBlobs;
    ULONG          ModifiedBlobs;
    ULONG          DeletedBlobs;
    ULONG          RejectedBlobs;
    ULONG          CurrentBlobs;
    ULONG		   DerefBlobs2Zero;

} CF_STAT, *PCF_STAT;


//
// GPC stats
//
typedef struct _GPC_STATS {

    ULONG          CreatedCf;
    ULONG          DeletedCf;
    ULONG          RejectedCf;
    ULONG          CurrentCf;

    ULONG		   InsertedHF;
    ULONG		   RemovedHF;

    CF_STAT		   CfStat[GPC_CF_MAX];
    PROTOCOL_STAT  ProtocolStat[GPC_PROTOCOL_TEMPLATE_MAX];

} GPC_STAT, *PGPC_STAT;



//
// CF data struct
//
typedef struct _CF_DATA {

    ULONG          CfId;
    ULONG          NumberOfClients;
    ULONG          Flags;
    ULONG          NumberOfPriorities;
    
} CF_DATA, *PCF_DATA;


//
// blob data struct
//
typedef struct _BLOB_DATA {

    ULONG          CfId;
    ULONG          BlobId;
    ULONG          ByteCount;
    CHAR           Data[1];
    
} BLOB_DATA, *PBLOB_DATA;


//
// specific pattern data struct
//
typedef struct _SP_DATA {

    ULONG          BlobId;
    CHAR           Pattern[1];

} SP_DATA, *PSP_DATA;


//
// generic pattern data struct
//
typedef struct _GP_DATA {

    ULONG          CfId;
    ULONG          Priority;
    ULONG          BlobId;
    CHAR           Pattern[1];
    //   Mask is following here
    
} GP_DATA, *PGP_DATA;

//
// the big output buffer
//

typedef struct _GPC_OUTPUT_BUFFER {

    ULONG          Version;

    //
    // statistics until now
    //

    GPC_STAT       Stats;

    //
    // number of elements in this report
    //

    ULONG          NumberOfCf;
    ULONG          NumberOfBlobs;
    ULONG          NumberOfSp;
    ULONG          NumberOfGp;
    CHAR           Data[1];

    //
    // order of data:
    //  CF_DATA
    //  BLOB_DATA
    //  SP_DATA
    //  GP_DATA
    //

} GPC_OUTPUT_BUFFER, *PGPC_OUTPUT_BUFFER;


typedef struct _GPC_INPUT_BUFFER {

    ULONG          Version;
    ULONG          ProtocolTemplateId;
    ULONG          Cf;                 // which CF or (-1) for all
    ULONG          BlobCount;          // (-1) for all
    ULONG          PatternCount;       // (-1) for all

} GPC_INPUT_BUFFER, *PGPC_INPUT_BUFFER;


/* Prototypes */
/* End Prototypes */

#endif /* _NTDDGPC_ */

/* end ntddgpc.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\uuid\tapi3iid.c ===
//
// TAPI3IID.c
//
//  Description: CPP file instanciating the TAPI3 IIDs
//
//

#define INITGUID
#include <guiddef.h>

//
// TERMINAL CLASSES
//
    
//
// Video Window Terminal Class descriptor
// {F7438990-D6EB-11d0-82A6-00AA00B5CA1B}
//
const CLSID __declspec(selectany) CLSID_VideoWindowTerm = 
{ 0xf7438990, 0xd6eb, 0x11d0, { 0x82, 0xa6, 0x0, 0xaa, 0x0, 0xb5, 0xca, 0x1b } };

// {AAF578EC-DC70-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) CLSID_VideoInputTerminal = 
{ 0xaaf578ec, 0xdc70, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {AAF578EB-DC70-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) CLSID_HandsetTerminal = 
{ 0xaaf578eb, 0xdc70, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {AAF578ED-DC70-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) CLSID_HeadsetTerminal = 
{ 0xaaf578ed, 0xdc70, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {AAF578EE-DC70-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) CLSID_SpeakerphoneTerminal = 
{ 0xaaf578ee, 0xdc70, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {AAF578EF-DC70-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) CLSID_MicrophoneTerminal = 
{ 0xaaf578ef, 0xdc70, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {E2F7AEF7-4971-11D1-A671-006097C9A2E8}
const CLSID __declspec(selectany) CLSID_MediaStreamTerminal = 
{ 0xE2F7AEF7, 0x4971, 0x11D1, { 0xA6, 0x71, 0x0, 0x60, 0x97, 0xC9, 0xA2, 0xE8 } };

// {8EBAE7A3-8943-11d1-96B8-00C04FB6E866}
const GUID __declspec(selectany) CLSID_BridgeTerminal = 
{ 0x8ebae7a3, 0x8943, 0x11d1, { 0x96, 0xb8, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66 } };


// {AAF578F0-DC70-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) CLSID_SpeakersTerminal = 
{ 0xaaf578f0, 0xdc70, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {AAF578F1-DC70-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) CLSID_FileTerminal = 
{ 0xaaf578f1, 0xdc70, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {521F3D06-C3D0-4511-8617-86B9A783DA77}
const CLSID __declspec(selectany) CLSID_FileRecordingTerminal = 
{ 0x521F3D06, 0xC3D0, 0x4511, {0x86, 0x17, 0x86, 0xB9, 0xA7, 0x83, 0xDA, 0x77 } };

// {BF14A2E4-E88B-4ef5-9740-5AC5D022F8C9}
const CLSID __declspec(selectany) CLSID_FileRecordingTrack =  
{ 0xbf14a2e4, 0xe88b, 0x4ef5, { 0x97, 0x40, 0x5a, 0xc5, 0xd0, 0x22, 0xf8, 0xc9 } };

// {0CB9914C-79CD-47dc-ADB0-327F47CEFB20}
const CLSID __declspec(selectany) CLSID_FilePlaybackTerminal =  
{ 0x0CB9914C, 0x79CD, 0x47dc, { 0xAD, 0xB0, 0x32, 0x7F, 0x47, 0xCE, 0xFB, 0x20 } };

//
// MEDIATYPES
//

// {028ED8C2-DC7A-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) TAPIMEDIATYPE_Audio =
{ 0x28ed8c2, 0xdc7a, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {028ED8C4-DC7A-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) TAPIMEDIATYPE_Video =
{ 0x28ed8c4, 0xdc7a, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {028ED8C6-DC7A-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) TAPIMEDIATYPE_DataModem =
{ 0x28ed8c6, 0xdc7a, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {028ED8C7-DC7A-11d0-8ED3-00C04FB6809F}
const CLSID __declspec(selectany) TAPIMEDIATYPE_G3Fax =
{ 0x28ed8c7, 0xdc7a, 0x11d0, { 0x8e, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };


// {831CE2D6-83B5-11d1-BB5C-00C04FB6809F}
const CLSID __declspec(selectany) TAPIPROTOCOL_PSTN = 
{ 0x831ce2d6, 0x83b5, 0x11d1, { 0xbb, 0x5c, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {831CE2D7-83B5-11d1-BB5C-00C04FB6809F}
const CLSID __declspec(selectany) TAPIPROTOCOL_H323 = 
{ 0x831ce2d7, 0x83b5, 0x11d1, { 0xbb, 0x5c, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };

// {831CE2D8-83B5-11d1-BB5C-00C04FB6809F}
const CLSID __declspec(selectany) TAPIPROTOCOL_Multicast = 
{ 0x831ce2d8, 0x83b5, 0x11d1, { 0xbb, 0x5c, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\inc\pktsched.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    pktsched.h

Abstract:

    defines for packet scheduler component interface

Author:


Revision History:

--*/

#ifndef _PKTSCHED_H_
#define _PKTSCHED_H_

//
// forwards
//

/*
typedef struct _PSI_INFO;
typedef struct _PS_PROFILE;
typedef struct _PS_PIPE_CONTEXT;
typedef struct _PS_FLOW_CONTEXT;
typedef struct _PS_DEBUG_INFO;
*/

//
// Component registration function exported by PSched
//


//
// Context info passed to each component during pipe initialization.  The PS
// allocates one PS_PIPE_CONTEXT struct for each component.  The size of an
// individual component's struct is indicated by the component during registration,
// and must be at least as large as sizeof(PS_PIPE_CONTEXT).
// Each component's context area begins with the struct defined below, and the
// component-specific data follows.
//
// Note : This structure has to be word aligned.
//

typedef struct _PS_PIPE_CONTEXT {
    // NextComponentContext -   Pointer to next component's pipe-specific data
    // PrevComponentContext -   Pointer to previous component's pipe-specific data
    // NextComponent -          Function info about next component in pipeline
    // PacketReservedOffset -   Offset to packet reserved bytes for this component

    struct _PS_PIPE_CONTEXT    *NextComponentContext;
    struct _PS_PIPE_CONTEXT    *PrevComponentContext;
    struct _PSI_INFO           *NextComponent;
    ULONG                      PacketReservedOffset;
} PS_PIPE_CONTEXT, *PPS_PIPE_CONTEXT;

//
// Context info passed to each component during flow initialization.  The PS
// allocates one PS_FLOW_CONTEXT struct for each component.  The size of an
// individual component's struct is indicated by the component during registration,
// and must be at least as large as sizeof(PS_FLOW_CONTEXT).
// Each component's context area begins with the struct defined below, and the
// component-specific data follows.
//

typedef struct _PS_FLOW_CONTEXT {
    // NextComponentContext -   Pointer to next component's flow-specific data
    // PrevComponentContext -   Pointer to previous component's flow-specific data

    struct _PS_FLOW_CONTEXT    *NextComponentContext;
    struct _PS_FLOW_CONTEXT    *PrevComponentContext;
} PS_FLOW_CONTEXT, *PPS_FLOW_CONTEXT, PS_CLASS_MAP_CONTEXT, *PPS_CLASS_MAP_CONTEXT;

//
// Packet Information Block.  This structure can be found
// at offset zero from the packet's ProtocolReserved area.
//

typedef struct _PACKET_INFO_BLOCK {

    // SchedulerLinks -     Linkage in scheduling component list
    // PacketLength -       Length of packet, non including MAC header
    // ConformanceTime -    Token Bucket Conformance Time
    // DelayTime -          Time at which packet is eligible for sending
    // FlowContext -        Flow context area for the convenience of the scheduling
    //                      components.  May be used by the scheduling component
    //                      while the packet is being processed by that component.
    // ClassMapContext -    Class Map context area for convenience of scheduling
    //                      components. May be used by the scheduling component
    //                      when the packet is being processed by that component.
    // IpHdr -              points to the IP transport header. This is used by the 
    //                      sequencer to stamp the IP packet with the non conforming
    //                      TOS byte. We store a pointer here because we have already
    //                      done the dirty work of getting to the buffer in MpSend.
    //                      This will be 0 for non IP packets, in which case the 
    //                      sequencer  need not do anything.
    // IPPrecedenceByteNonConforming - The TOS setting for non conforming packets.
    // UserPriorityNonConforming - 802.1p setting for non conforming packets.

    LIST_ENTRY SchedulerLinks;
    ULONG   PacketLength;
    LARGE_INTEGER ConformanceTime;
    LARGE_INTEGER DelayTime;
    HANDLE FlowContext;
    HANDLE ClassMapContext;
    ULONG IPHeaderOffset;
    IPHeader *IPHdr;
    PNDIS_PACKET NdisPacket;
    UCHAR TOSNonConforming;
    UCHAR UserPriorityNonConforming;
} PACKET_INFO_BLOCK, *PPACKET_INFO_BLOCK;


//
// Prototypes for PS routines made available to scheduling components.
//

typedef VOID
(*PS_DROP_PACKET)(
    IN HANDLE PsPipeContext,
    IN HANDLE PsFlowContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status
    );

typedef HANDLE
(*PS_NDIS_PIPE_HANDLE)(
    IN HANDLE PsPipeContext
    );

typedef HANDLE
(*PS_NDIS_FLOW_HANDLE)(
    IN HANDLE PsFlowContext
    );

typedef VOID
(*PS_GET_TIMER_INFO)(
    OUT PULONG TimerResolution  // Timer resolution in system time units
    );

typedef struct _PS_PROCS {
    PS_DROP_PACKET DropPacket;
    PS_NDIS_PIPE_HANDLE NdisPipeHandle;
    PS_GET_TIMER_INFO GetTimerInfo;
} PS_PROCS, *PPS_PROCS;


//
// Upcall information passed to next component
//

typedef VOID
(*PSU_SEND_COMPLETE)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PNDIS_PACKET Packet
    );

typedef struct _PS_UPCALLS {
    PSU_SEND_COMPLETE SendComplete;
    PPS_PIPE_CONTEXT  PipeContext;
} PS_UPCALLS, *PPS_UPCALLS;

//
// Pipe parameters
//

typedef struct _PS_PIPE_PARAMETERS {

    // Bandwidth            - In bytes/sec
    // MTUSize              - Maximum frame size
    // HeaderSize           - Number of bytes in header
    // Flags                - See below
    // MaxOutstandingSends  - Maximum sends that can be pending concurrently
    // SDModeControlledLoad - Default handling of non-conforming controlled load traffic
    // SDModeGuaranteed     - Default handling of non-conforming guaranteed service  traffic
    // SDModeNetworkControl - Default handling of non-conforming NetworkControl service  traffic
    // SDModeQualitative    - Default handling of non-conforming Qualitative service  traffic
    // RegistryPath         - Pointer to the registry path of that interface. Can be used to read reg params.

    ULONG Bandwidth;
    ULONG MTUSize;
    ULONG HeaderSize;
    ULONG Flags;
    ULONG MaxOutstandingSends;
    ULONG SDModeControlledLoad;
    ULONG SDModeGuaranteed;
    ULONG SDModeNetworkControl;
    ULONG SDModeQualitative;
    PNDIS_STRING RegistryPath;

    // Need this to let the scheduling components to know what kind of medium it is //
    NDIS_MEDIUM MediaType;      //  Wan Or anything else

} PS_PIPE_PARAMETERS, *PPS_PIPE_PARAMETERS;

// Pipe flags

#define PS_DISABLE_DRR                  2
#define PS_INTERMEDIATE_SYS             4

//
// function typedefs for the scheduler entry points
//

typedef NDIS_STATUS
(*PS_INITIALIZE_PIPE)(
    IN HANDLE              PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT    ComponentPipeContext,
    IN PPS_PROCS           PsProcs,
    IN PPS_UPCALLS         Upcalls
    );

typedef NDIS_STATUS
(*PS_MODIFY_PIPE)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    );

typedef VOID
(*PS_DELETE_PIPE)(
    IN PPS_PIPE_CONTEXT PipeContext
    );

typedef NDIS_STATUS
(*PS_CREATE_FLOW)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    );

typedef NDIS_STATUS
(*PS_MODIFY_FLOW)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

typedef VOID
(*PS_DELETE_FLOW)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );

typedef VOID
(*PS_EMPTY_FLOW)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );    

typedef BOOLEAN
(*PS_SUBMIT_PACKET)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PktInfo);

typedef BOOLEAN
(*PS_RECEIVE_PACKET)(
    IN PPS_PIPE_CONTEXT         PipeContext,
    IN PPS_FLOW_CONTEXT         FlowContext,
    IN PPS_CLASS_MAP_CONTEXT    ClassMapContext,
    IN PNDIS_PACKET             Packet,
    IN NDIS_MEDIUM              Medium
    );

typedef BOOLEAN
(*PS_RECEIVE_INDICATION)(
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PVOID    HeaderBuffer,
    IN UINT     HeaderBufferSize,
    IN PVOID    LookAheadBuffer,
    IN UINT     LookAheadBufferSize,
    IN UINT     PacketSize,
    IN UINT     TransportHeaderOffset
    );

typedef VOID
(*PS_SET_INFORMATION) (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG BufferSize,
    IN PVOID Buffer
    );

typedef VOID
(*PS_QUERY_INFORMATION) (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG BufferSize,
    IN PVOID Buffer,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status);

typedef NDIS_STATUS
(*PS_CREATE_CLASS_MAP) (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    );

typedef NDIS_STATUS
(*PS_DELETE_CLASS_MAP) (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT
    );

/* End Prototypes */


//
// Scheduling component registration structure.
//

#define PS_COMPONENT_CURRENT_VERSION 1

typedef struct _PSI_INFO {
    LIST_ENTRY Links;
    BOOLEAN Registered;
    BOOLEAN AddIn;
    USHORT  Version;
    NDIS_STRING ComponentName;
    ULONG PacketReservedLength;
    ULONG PipeContextLength;
    ULONG FlowContextLength;
    ULONG ClassMapContextLength;
    ULONG SupportedOidsLength;
    NDIS_OID *SupportedOidList;
    ULONG SupportedGuidsLength;
    NDIS_GUID *SupportedGuidList;
    PS_INITIALIZE_PIPE InitializePipe;
    PS_MODIFY_PIPE ModifyPipe;
    PS_DELETE_PIPE DeletePipe;
    PS_CREATE_FLOW CreateFlow;
    PS_MODIFY_FLOW ModifyFlow;
    PS_DELETE_FLOW DeleteFlow;
    PS_EMPTY_FLOW  EmptyFlow;
    PS_SUBMIT_PACKET SubmitPacket;
    PS_RECEIVE_PACKET ReceivePacket;
    PS_RECEIVE_INDICATION ReceiveIndication;
    PS_SET_INFORMATION SetInformation;
    PS_QUERY_INFORMATION QueryInformation;
    PS_CREATE_CLASS_MAP CreateClassMap;
    PS_DELETE_CLASS_MAP DeleteClassMap;
} PSI_INFO, *PPSI_INFO;

//
// Profile registration structure
//
#define MAX_COMPONENT_PER_PROFILE 10
typedef struct _PS_PROFILE {
    LIST_ENTRY  Links;
    USHORT      UnregisteredAddInCnt;
    NDIS_STRING ProfileName;
    UINT        ComponentCnt;
    // Allocate an extra slot for the StubComponent
    PPSI_INFO   ComponentList[MAX_COMPONENT_PER_PROFILE + 1];
} PS_PROFILE, *PPS_PROFILE;



//
// Debugging support for add-in components
//
typedef VOID
(*PS_GET_CURRENT_TIME) (PLARGE_INTEGER SysTime);

typedef VOID
(*PS_LOGSTRING_PROC) (
    IN char *format,
    ...
    );

typedef VOID 
(*PS_LOGSCHED_PROC) (
    IN ULONG SchedulerComponent,
    IN ULONG Action,
    IN PVOID VC,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG Priority,
    IN LONGLONG ArrivalTime,
    IN LONGLONG ConformanceTime,
    IN ULONG PacketsInComponent,
    IN ULONG BytesInComponent
    );

typedef VOID
(*PS_LOGREC_PROC) (
    IN ULONG ComponentId,
    IN PVOID RecordData,
    IN ULONG RecordLength
    );

typedef ULONG
(*PS_GETID_PROC) (
    VOID);

typedef struct _PS_DEBUG_INFO {
    PULONG DebugLevel;
    PULONG DebugMask;
    PULONG LogTraceLevel;
    PULONG LogTraceMask;
    ULONG LogId;
    PS_GET_CURRENT_TIME GetCurrentTime;
    PS_LOGSTRING_PROC LogString;
    PS_LOGSCHED_PROC LogSched;
    PS_LOGREC_PROC LogRec;
} PS_DEBUG_INFO, *PPS_DEBUG_INFO;

NDIS_STATUS RegisterPsComponent( PPSI_INFO PsiComponentInfo, ULONG Size ,
                                 PPS_DEBUG_INFO Dbg);


//
//  VOID
//  InsertEntryList(
//      PLIST_ENTRY Entry,
//      PLIST_ENTRY EntryToInsert
//      );
//
//  insert EntryToInsert just after Entry
//

#define InsertEntryList( Entry, EntryToInsert ) {           \
    (EntryToInsert)->Flink = (Entry)->Flink;                \
    (Entry)->Flink = (EntryToInsert);                       \
    (EntryToInsert)->Blink = (EntryToInsert)->Flink->Blink; \
    (EntryToInsert)->Flink->Blink = (EntryToInsert);        \
    }


#define ARP_802_ADDR_LENGTH 6               // Length of an 802 address.
#define ARP_ETYPE_IP        0x800

typedef struct _ETH_HEADER {
    UCHAR DestAddr[ARP_802_ADDR_LENGTH];
    UCHAR SrcAddr[ARP_802_ADDR_LENGTH];
    USHORT Type;
} ETH_HEADER, *PETH_HEADER;

_inline
IPHeader *
GetIpHeader(ULONG TransportHeaderOffset, PNDIS_PACKET pNdisPacket)
{
    PVOID         pAddr;
    PNDIS_BUFFER  pNdisBuf1, pNdisBuf2;
    UINT          Len;

    pNdisBuf1 = pNdisPacket->Private.Head;
    NdisQueryBuffer(pNdisBuf1, &pAddr, &Len);

    while(Len <= TransportHeaderOffset) {

        //
        // Transport header is not in this buffer,
        // try the next buffer
        //

        TransportHeaderOffset -= Len;
        NdisGetNextBuffer(pNdisBuf1, &pNdisBuf2);
        ASSERT(pNdisBuf2);
        NdisQueryBuffer(pNdisBuf2, &pAddr, &Len);
        pNdisBuf1 = pNdisBuf2;
    }

    return (IPHeader *)(((PUCHAR)pAddr) + TransportHeaderOffset);

}

//
// Set TOS byte and recalculate checksum 
// Use incremental checksum update
// RFCs 1071, 1141, 1624
// 
//
// RFC : 1624
// HC' = ~(~HC + ~m + m');
// HC - old checksum, m - old value, m' - new value
//

#define SET_TOS_XSUM(Packet, pIpHdr, tos) {                                              \
    PNDIS_PACKET_EXTENSION _PktExt;                                                               \
    NDIS_TCP_IP_CHECKSUM_PACKET_INFO _ChkPI;                                                      \
    _PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET((Packet));                                        \
    _ChkPI.Value = PtrToUlong(_PktExt->NdisPacketInfo[TcpIpChecksumPacketInfo]);                  \
    if(_ChkPI.Transmit.NdisPacketIpChecksum) {                                                    \
        (pIpHdr)->iph_tos = ((pIpHdr)->iph_tos & PS_IP_DS_CODEPOINT_MASK) | (tos);                \
    }                                                                                             \
    else {                                                                                        \
        USHORT _old, _new;                                                                        \
        ULONG _sum;                                                                               \
        _old = *(USHORT *)(pIpHdr);                                                               \
        (pIpHdr)->iph_tos = ((pIpHdr)->iph_tos & PS_IP_DS_CODEPOINT_MASK) | (tos);                \
        _new = *(USHORT *)(pIpHdr);                                                               \
        _sum = ((~(pIpHdr)->iph_xsum) & 0xffff) + ((~_old) & 0xffff) + _new;                      \
        _sum = (_sum & 0xffff) + (_sum >> 16);                                                    \
        _sum += (_sum >> 16);                                                                     \
        (pIpHdr)->iph_xsum = (ushort) ((~_sum) & 0xffff);                                         \
    }                                                                                             \
}

   
//
// Number of OS time units per second
//

#define OS_TIME_SCALE               10000000

//
// convert from OS's 100 ns to millisecs
//

#define OS_TIME_TO_MILLISECS(_time) ((_time)/10000)

_inline VOID
PsGetCurrentTime(
    PLARGE_INTEGER SysTime
    )

/*++

Routine Description:

    Get the current system time

Arguments:

Comments:
    1. We need something that always increases - Hence we cannot use NdisGetCurrentSystemTime or
       KeQueryCurrentSystem time. Those APIs can return decreasing times (daylight savings, date/time, etc).

Return Value:

    System time (in base OS time units)

--*/

{

#if defined(PERF_COUNTER)
    LARGE_INTEGER Now;
    LARGE_INTEGER Frequency;

    Now = KeQueryPerformanceCounter(&Frequency);
    SysTime->QuadPart = (Now.QuadPart * OS_TIME_SCALE) / Frequency.QuadPart;

#else
    //
    // We used to use KeQueryTickCount() with KeQueryTimeIncrement(). But, if we are driving the clock at a lower
    // resolution, then we cannot use KeQueryTickCount, because this will always return the time based on the 
    // maximum resolution. Therefore, we use KeQueryInterruptTime().
    //
    SysTime->QuadPart = KeQueryInterruptTime();

#endif

}

#endif /* _PKTSCHED_H_ */

/* end pktsched.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\gpcdb.c ===
/*
************************************************************************

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    gpcdb.c

Abstract:

    This file contains database routines, that includes specific patterns,
    and classification index table.

Author:

    Ofer Bar - April 15, 1997

Environment:

    Kernel mode

Revision History:


************************************************************************
*/

#include "gpcpre.h"



VOID
GpcSpecificCallback(
             IN VOID 				  *Ctx, 
             IN SpecificPatternHandle  SpHandle);




/*
************************************************************************

InitSpecificPatternDb - 

Initialize the specific patterns database. It will allocate a table
length Size.

Arguments
    pDb         - a pointer to the db to initialize
    Size        - number of entries in the table

Returns
	NDIS_STATUS

************************************************************************
*/
GPC_STATUS
InitSpecificPatternDb(
                      IN	PSPECIFIC_PATTERN_DB	pDb,
                      IN	ULONG					PatternSize
                      )
{
    GPC_STATUS		Status = GPC_STATUS_SUCCESS;
	ULONG			Len, i;
    
	TRACE(INIT, pDb, PatternSize, "InitSpecificPatternDb");
    
    ASSERT(pDb);

    ASSERT(PatternSize);

    //
    // init the specific db struct
    // call the PH init routine
    //

    INIT_LOCK(&pDb->Lock);

    AllocatePatHashTable(pDb->pDb);

    if (pDb->pDb != NULL) {

        constructPatHashTable(pDb->pDb,
                              PatternSize * 8,
                              2,	// usage_ratio,
                              1,    // usage_histeresis,
                              1,    // allocation_histeresis,
                              16    // max_free_list_size
                              );
    } else {
        
        Status = GPC_STATUS_RESOURCES;
    }
    
	TRACE(INIT, Status, 0, "InitSpecificPatternDb==>");

    return Status;
}




/*
************************************************************************

UninitSpecificPatternDb - 

Un-Initialize the specific patterns database. It will release all
allocated memory.

Arguments
    pDb         - a pointer to the db to free

Returns
	NDIS_STATUS

************************************************************************
*/
GPC_STATUS
UninitSpecificPatternDb(
                        IN	PSPECIFIC_PATTERN_DB	pDb
                        )
{
    GPC_STATUS		Status = GPC_STATUS_SUCCESS;
    
	TRACE(INIT, pDb, 0, "UninitSpecificPatternDb");
    
    ASSERT(pDb);

    destructPatHashTable(pDb->pDb);
    FreePatHashTable(pDb->pDb);
    
	TRACE(INIT, Status, 0, "UninitSpecificPatternDb==>");

    return Status;
}





/*
************************************************************************

InitClassificationHandleTbl - 

Init the classification index table

Arguments
    ppCHTable       - a pointer a class handle table pointer
	
Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
InitClassificationHandleTbl(
                            IN	HandleFactory **ppCHTable
                            )
{
    GPC_STATUS					Status = GPC_STATUS_SUCCESS;

	TRACE(INIT, ppCHTable, 0, "InitClassificationHandleTbl");
    
    ASSERT(ppCHTable);

    NEW_HandleFactory(*ppCHTable);

    if (*ppCHTable == NULL) {
        return GPC_STATUS_RESOURCES;
    }

    if (0 != constructHandleFactory(*ppCHTable)) {
        return GPC_STATUS_RESOURCES;
    }

    TRACE(INIT, Status, 0, "InitClassificationIndexTbl==>");

    return Status;
}




/*
************************************************************************

UninitClassificationHandleTbl - 

Uninit the classification index table

Arguments
    pCHTable       - a pointer a class handle table
	
Returns
	void

************************************************************************
*/
VOID
UninitClassificationHandleTbl(
                            IN	HandleFactory *pCHTable
                            )
{
    destructHandleFactory(pCHTable);
    FreeHandleFactory(pCHTable);
}




/*
************************************************************************

InitializeGenericDb - 

Init the generic db. This is called by per CF.

Arguments
    pGenericDb   - a pointer to the generic db
    NumEntries   - number of entries, one per rhizome
    PatternSize  - pattern size in bytes
	
Returns
	GPC_STATUS: no memory resources

************************************************************************
*/
GPC_STATUS
InitializeGenericDb(
                    IN  PGENERIC_PATTERN_DB	*ppGenericDb,
                    IN  ULONG				 NumEntries,
                    IN  ULONG				 PatternSize
                    )
{
    GPC_STATUS			Status = GPC_STATUS_SUCCESS;
    ULONG				i;
    PGENERIC_PATTERN_DB	pDb;
    
    *ppGenericDb = NULL;

    ASSERT(PatternSize);

    GpcAllocMem(&pDb, 
                sizeof(GENERIC_PATTERN_DB) * NumEntries, 
                GenPatternDbTag);

    if (pDb == NULL)
        return GPC_STATUS_RESOURCES;

    *ppGenericDb = pDb;

    for (i = 0; i < NumEntries; i++, pDb++) {
        
        INIT_LOCK(&pDb->Lock);

        AllocateRhizome(pDb->pRhizome);

        if (pDb->pRhizome == NULL) {

            //
            // failed, release all allocated resources
            //

            while (i > 0) {
                NdisFreeSpinLock(&pDb->Lock);
                i--;
                pDb--;
                destructRhizome(pDb->pRhizome);
                FreeRhizome(pDb->pRhizome);
            }

            GpcFreeMem((*ppGenericDb), GenPatternDbTag);

            Status = GPC_STATUS_RESOURCES;
            *ppGenericDb = NULL;
            break;
        }

        //
        // init the rhizome
        //

        constructRhizome(pDb->pRhizome, PatternSize*8);
    }

    return Status;
}



/*
************************************************************************

UninitializeGenericDb - 

Uninit the generic db. 

Arguments
    pGenericDb   - a pointer to the generic db
    NumEntries   - number of entries, one per rhizome
    PatternSize  - pattern size in bytes
	
Returns
	void

************************************************************************
*/
VOID
UninitializeGenericDb(
                    IN  PGENERIC_PATTERN_DB	*ppGenericDb,
                    IN  ULONG				 NumEntries
                    )
{
    ULONG				i;
    PGENERIC_PATTERN_DB	pDb;
    
    pDb = *ppGenericDb;

    ASSERT(pDb);

    for (i = 0; i < NumEntries; i++, pDb++) {
        
        NdisFreeSpinLock(&pDb->Lock);

        destructRhizome(pDb->pRhizome);
        
        FreeRhizome(pDb->pRhizome);
    }

    GpcFreeMem(*ppGenericDb, GenPatternDbTag);

    *ppGenericDb = NULL;
}



/*
************************************************************************

GpcSpecificCallback -

Call back routine given when calling scanPatHashTable and getting called
by the pathash scanning routine.

Arguments
	Ctx      - a pointer to a SCAN_STRUCT to hold context info
    SpHandle - the specific pattern handle that matches

Returns
	void

************************************************************************
*/
VOID
GpcSpecificCallback(
             IN VOID 				  *Ctx, 
             IN SpecificPatternHandle  SpHandle)
{
    PSCAN_STRUCT			pScan = (PSCAN_STRUCT)Ctx;
    PPATTERN_BLOCK			pSpPattern;
    PPATTERN_BLOCK			pGpPattern;
    PGENERIC_PATTERN_DB		pGenericDb;
    PatternHandle	    	GpHandle;
    PBLOB_BLOCK				pSpBlob, *ppSpCbBlob, OldBlob;
    ULONG					CfIndex;
    PCF_BLOCK				pCf;
    KIRQL					ReadIrql;
    KIRQL					CBirql;
    PCLASSIFICATION_BLOCK	pCB;
    PGPC_IP_PATTERN         pIp;
    BOOLEAN                 bBetterFound = FALSE;
    UINT                     i;
    TRACE(PATTERN, Ctx, SpHandle, "GpcSpecificCallback");

    pSpPattern = (PPATTERN_BLOCK)GetReferenceFromSpecificPatternHandle(SpHandle);
    pCB = pSpPattern->pClassificationBlock;
   
    pIp = (PGPC_IP_PATTERN) GetKeyPtrFromSpecificPatternHandle(SpHandle);
    ASSERT(pCB);
    ASSERT(pScan);
    
    //
    // get the CF index 
    //

    CfIndex = pScan->pClientBlock->pCfBlock->AssignedIndex;
    pCf = pScan->pClientBlock->pCfBlock;

    //
    // the blob that actually belongs to the SP
    //

    pSpBlob = GetBlobFromPattern(pSpPattern,CfIndex);

    //
    // the blob that currently exist in the CfIndex entry of the the CB
    //

    ppSpCbBlob = &pCB->arpBlobBlock[CfIndex];

    TRACE(PATTERN, pSpBlob, *ppSpCbBlob, "GpcSpecificCallback (2)");
    TRACE(PATTERN, pCB, CfIndex, "GpcSpecificCallback (2.5)");

    if (pSpBlob != *ppSpCbBlob || pSpBlob == NULL) {

        if (!pScan->bRemove) {

            //
            // we just added the generic pattern, so we should set the
            // CB pointer for that CF point to the new blob
            //
            for (i = 0; i <= pScan->pPatternBlock->Priority; i++) {

                pGenericDb = &pScan->pClientBlock->pCfBlock->arpGenericDb[pSpPattern->ProtocolTemplate][i];

                READ_LOCK(&pGenericDb->Lock, &ReadIrql);

                GpHandle = searchRhizome(pGenericDb->pRhizome,
                                         GetKeyPtrFromSpecificPatternHandle(SpHandle)
                                         );

                TRACE(PATTERN, pGenericDb, GpHandle, "GpcSpecificCallback (3.5)");

                if (GpHandle != NULL) {

                    WRITE_LOCK(&glData.ChLock, &CBirql);
                    bBetterFound = TRUE;

                    pGpPattern = (PPATTERN_BLOCK)GetReferenceFromPatternHandle(GpHandle);
                    *ppSpCbBlob = GetBlobFromPattern(pGpPattern, CfIndex);

                    WRITE_UNLOCK(&glData.ChLock, CBirql);
                    READ_UNLOCK(&pGenericDb->Lock, ReadIrql);
                    break;

                }

                READ_UNLOCK(&pGenericDb->Lock, ReadIrql);

            } 

            if (!bBetterFound) {

                WRITE_LOCK(&glData.ChLock, &CBirql);
                *ppSpCbBlob = pScan->pBlobBlock;

                WRITE_UNLOCK(&glData.ChLock, CBirql);
            }


        } else {
            
            //
            // The CfIndex slot in the CB points to a blob that doesn't belong
            // to the specific pattern we have just found. There is a chance
            // that there is another generic pattern somewhere, that may
            // or may not be more specific, thus resulting in updating the blob
            // pointer in the CB. So we need to search the generic db for a
            // match (to the specific pattern).
            //
            
            for (i = 0; i <= pScan->pPatternBlock->Priority; i++) {
            
                pGenericDb = &pScan->pClientBlock->pCfBlock->arpGenericDb[pSpPattern->ProtocolTemplate][i];
            
                READ_LOCK(&pGenericDb->Lock, &ReadIrql);
            
                GpHandle = searchRhizome(pGenericDb->pRhizome, 
                                         GetKeyPtrFromSpecificPatternHandle(SpHandle)
                                         );

                TRACE(PATTERN, pGenericDb, GpHandle, "GpcSpecificCallback (3.5)");


                if (GpHandle != NULL) {
        
                    //
                    // we found a generic pattern in the rhizoe that can also be
                    // the same one that is currently being installed, but
                    // that's fine, since we want the most specific one, and
                    // the search guarantees that.
                    // all we need to do is to update the CB of the SP with 
                    // the blob of the GP we've just found.
                    //
                    bBetterFound = TRUE; 
                    WRITE_LOCK(&glData.ChLock, &CBirql);
                    OldBlob = *ppSpCbBlob;
                    pGpPattern = (PPATTERN_BLOCK)GetReferenceFromPatternHandle(GpHandle);
                    *ppSpCbBlob = GetBlobFromPattern(pGpPattern, CfIndex);

                    TRACE(PATTERN, pGpPattern, pCB->arpBlobBlock[CfIndex], "GpcSpecificCallback (4)");
                    
                    WRITE_UNLOCK(&glData.ChLock, CBirql);
                    READ_UNLOCK(&pGenericDb->Lock, ReadIrql);
                    break;

                }

                READ_UNLOCK(&pGenericDb->Lock, ReadIrql);
            
            }

            if (!bBetterFound) {

                //
                // non was found
                //

                WRITE_LOCK(&glData.ChLock, &CBirql);
                *ppSpCbBlob = NULL;
                WRITE_UNLOCK(&glData.ChLock, CBirql);
                TRACE(PATTERN, *ppSpCbBlob, pCB->arpBlobBlock[CfIndex], "GpcSpecificCallback (5)");

            }


        }
                            
    }

    TRACE(PATTERN, pCB, CfIndex, "GpcSpecificCallback==>");
}





/*
************************************************************************

AddGenericPattern -

Add a generic pattern to the db. 

Arguments
	pClient		- 
    Pattern		- 
    Mask		- 
    Priority	- 
    pBlob		- 
    ppPatter	- 

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
AddGenericPattern(
                  IN  PCLIENT_BLOCK		pClient,
                  IN  PUCHAR			pPatternBits,
                  IN  PUCHAR			pMaskBits,
                  IN  ULONG				Priority,
                  IN  PBLOB_BLOCK		pBlob,
                  IN  PPROTOCOL_BLOCK	pProtocol,
                  IN OUT PPATTERN_BLOCK	*ppPattern
)
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PatternHandle			GpHandle;
    PPATTERN_BLOCK			pPattern = *ppPattern;
    PGENERIC_PATTERN_DB		pGenericDb;
    PSPECIFIC_PATTERN_DB	pSpecificDb;
    SCAN_STRUCT				ScanStruct;
    ULONG                   i;
    ULONG                   CfIndex = pClient->pCfBlock->AssignedIndex;
    KIRQL					ReadIrql;
    KIRQL					WriteIrql;
    PGPC_IP_PATTERN         pIp, pMask;

	TRACE(PATTERN, pClient, pPatternBits, "AddGenericPattern");

    // This is impossible with a good client (320705)
    if (!pBlob) {

        return GPC_STATUS_INVALID_PARAMETER;

    }
    
    pIp = (PGPC_IP_PATTERN)pPatternBits;
    pMask = (PGPC_IP_PATTERN)pMaskBits;


    //
    // get the specific db pointer
    //

    pSpecificDb = &pProtocol->SpecificDb;
    ASSERT(pSpecificDb);

    //
    // Add to the Rhizome tree, according to priority value
    //

    pGenericDb = &pClient->pCfBlock->arpGenericDb[pProtocol->ProtocolTemplate][Priority];

    //
    // Lock the generic db for insertion
    //

    WRITE_LOCK(&pGenericDb->Lock, &WriteIrql);

    GpHandle = insertRhizome(pGenericDb->pRhizome,
                             pPatternBits,
                             pMaskBits,
                             (PVOID)*ppPattern,
                             (PULONG)&Status
                             );

    WRITE_UNLOCK(&pGenericDb->Lock, WriteIrql);

    if (NT_SUCCESS(Status)) {

        //
        // add one ref count
        //
        
        REFADD(&(*ppPattern)->RefCount, 'ADGP');

        //
        // we managed to insert the pattern, no conflicts.
        // now we need to scan the specific db for a match, 
        // since the insertion might affect CB entries for
        // patterns which are subsets of the installed pattern
        //
        
        ProtocolStatInc(pProtocol->ProtocolTemplate, 
                        InsertedRz);
        
        //
        // lock the specific db, some other client may access it
        //
        
        ScanStruct.Priority = Priority;
        ScanStruct.pClientBlock = pClient;
        ScanStruct.pPatternBlock = *ppPattern;
        ScanStruct.pBlobBlock = pBlob;
        ScanStruct.bRemove = FALSE;

        //
        // update the pattern
        //

        GetBlobFromPattern(pPattern,CfIndex) = pBlob;
        pPattern->pClientBlock = pClient;
        ASSERT(GpHandle);
        pPattern->DbCtx = (PVOID)GpHandle;

        TRACE(PATTERN, pPattern, GpHandle, "AddGenericPattern: DbCtx");

        pPattern->State = GPC_STATE_READY;

        GpcInterlockedInsertTailList
            (&pBlob->PatternList,
             &pPattern->BlobLinkage[CfIndex],
             &pBlob->Lock
             );

        //
        // this will do the rest of the work...
        //
        
        READ_LOCK(&pSpecificDb->Lock, &ReadIrql);

        scanPatHashTable(
                         pSpecificDb->pDb,
                         pPatternBits,
                         pMaskBits,
                         (PVOID)&ScanStruct,
                         GpcSpecificCallback   // see callback routine...
                         );

        READ_UNLOCK(&pSpecificDb->Lock, ReadIrql);

    }

	TRACE(PATTERN, Status, 0, "AddGenericPattern==>");

    return Status;
}




/*
************************************************************************

AddSpecificPattern -

Add a specific pattern to the db. 

Arguments
	pClient		- 
    pPatternBits-
    pMaskBits	- 
    pBlob		- 
    pProtocol   - 
    ppPattern	- 
    ppCB		-

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
AddSpecificPattern(
                  IN  PCLIENT_BLOCK				pClient,
                  IN  PUCHAR					pPatternBits,
                  IN  PUCHAR					pMaskBits,
                  IN  PBLOB_BLOCK				pBlob,     // optional
                  IN  PPROTOCOL_BLOCK			pProtocol,
                  IN OUT PPATTERN_BLOCK			*ppPattern,
                  OUT PCLASSIFICATION_HANDLE 	pCH
                  )
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PSPECIFIC_PATTERN_DB	pSpecificDb;
    PGENERIC_PATTERN_DB		pGenericDb;
    ULONG					Chyme;
    ULONG					CfIndex, i;
    PPATTERN_BLOCK			pPatternSave;
    PBLOB_BLOCK             pBlobSave;
    SpecificPatternHandle	SpHandle;
    PatternHandle			GpHandle;
    PCLASSIFICATION_BLOCK	pCB = NULL;
    PCF_BLOCK				pCf = NULL;
    PLIST_ENTRY				pHead, pEntry;
    KIRQL					ReadIrql;
    KIRQL					WriteIrql;
    KIRQL					irql;
    //BOOLEAN					bIsAuto;

    ASSERT(ppPattern);
    ASSERT(*ppPattern);

	TRACE(PATTERN, pClient, *ppPattern, "AddSpecificPattern");

    *pCH = 0;
    //bIsAuto = TEST_BIT_ON((*ppPattern)->Flags, PATTERN_AUTO);

    //
    // get the specific db pointer
    //

    pSpecificDb = &pProtocol->SpecificDb;
    ASSERT(pSpecificDb);

    //
    // get the CF index
    //

    CfIndex = pClient->pCfBlock->AssignedIndex;
    pCf = pClient->pCfBlock;

    //
    // Since we want to take the blob lock and specific DB lock
    // in the same order everywhere. Take the blob lock before the specific DB
    // lock. GPCEnumCfInfo does the same.
    //
    if (pBlob) {
        
        NDIS_LOCK(&pBlob->Lock);

    }
    //
    // lock the specific db, some other client may access it
    //

    WRITE_LOCK(&pSpecificDb->Lock, &WriteIrql);

    //
    // calculate a chyme hash value for the pat -hash
    //

    Chyme = GpcCalcHash(pProtocol->ProtocolTemplate, pPatternBits);
    ASSERT(Chyme != (-1));

    //
    // actually call insert directly. If the pattern already exist in the 
    // db, the returned reference will be the one for a previously
    // installed pattern, so ppPattern will be different
    //

    SpHandle = insertPatHashTable(
                                  pSpecificDb->pDb,
                                  pPatternBits,
                                  Chyme,
                                  (PVOID)*ppPattern
                                  );

    if (SpHandle != NULL) {

        //
        // the pattern block associated with the pattern we've just
        // installed, we may have gotten one that has already been
        // installed.
        //

        pPatternSave = GetReferenceFromSpecificPatternHandle(SpHandle);

        if (*ppPattern != pPatternSave) {

            //NDIS_LOCK(&pPatternSave->Lock);

            if (GetBlobFromPattern(pPatternSave,CfIndex) && pBlob) {

                //
                // there is a blob assigned to this entry
                // this is a NO NO, and will be REJECTED!
                //
                
                //
                // just a duplicate - the caller will release
                // one ref count in case of an error, so this 
                // will keep the pattern around!
                //

                //NdisInterlockedIncrement(&(*ppPatternSave)->RefCount);

                //NDIS_UNLOCK(&pPatternSave->Lock);
                
                WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);

                //
                // Since we want to take the blob lock and specific DB lock
                // in the same order everywhere, release the blob lock after
                // the specific DB lock. GPCEnumCfInfo does the same.
                //
                if (pBlob) {
        
                    NDIS_UNLOCK(&pBlob->Lock);

                }

                //TRACE(PATTERN, (*ppPattern)->RefCount, GPC_STATUS_CONFLICT, "AddSpecificPattern-->");

                return GPC_STATUS_CONFLICT;
            }

            //
            // get the CB pointer, since
            // the pattern has been already created. 
            //

            pCB = pPatternSave->pClassificationBlock;

            TRACE(PATTERN, pCB, CfIndex, "AddSpecificPattern (1.5)");

            ASSERT(pCB);
            ASSERT(CfIndex < pCB->NumberOfElements);
            ASSERT(pPatternSave->DbCtx);
            //
            // increase ref count, since the caller assume there is 
            // an extra one
            //

            REFADD(&pPatternSave->RefCount, 'ADSP');

            *ppPattern = pPatternSave;

            //
            // increase client ref count
            //

            NdisInterlockedIncrement(&pPatternSave->ClientRefCount);

            if (pBlob) {

                //
                // now assign the slot entry in the CB to the new blob
                //
                
                WRITE_LOCK(&glData.ChLock, &irql);

                pCB->arpBlobBlock[CfIndex] = pBlob;

                WRITE_UNLOCK(&glData.ChLock, irql);

                GetBlobFromPattern(pPatternSave,CfIndex) = pBlob;

                TRACE(PATTERN, pPatternSave, pBlob, "AddSpecificPattern(2)");
    
                        
                //
                // Reasons for removing the blob->lock - 
                // The lock is taken at teh start of this function.
                // (only to maintain the order in which locks are taken/released.
                //
                GpcInsertTailList
                    (&pBlob->PatternList, 
                     &pPatternSave->BlobLinkage[CfIndex]
                     );
            }

            *pCH = pCB->ClassificationHandle;

            //NDIS_UNLOCK(&pPatternSave->Lock);

        } else { // if (*ppPattern != pPatternSave)

            ProtocolStatInc(pProtocol->ProtocolTemplate, 
                            InsertedPH);
        
            //
            // it's a new pattern -
            // first we need to create a CB and update the pattern and
            // the blob entries
            //

            REFADD(&pPatternSave->RefCount, 'ADSP');

            pCB = CreateNewClassificationBlock(GPC_CF_MAX);

            //
            // This is a specific pattern, so we'll add the classification
            // handle for future use
            //

            WRITE_LOCK(&glData.ChLock, &irql);
            *pCH = (HFHandle)assign_HF_handle(
                                              glData.pCHTable,
                                              (void *)pCB
                                              );
            ProtocolStatInc(pProtocol->ProtocolTemplate, 
                            InsertedCH);
            WRITE_UNLOCK(&glData.ChLock, irql);

            if (pCB && *pCH) {

                TRACE(CLASSHAND, pCB, pCB->ClassificationHandle, "AddSpecificPattern (CH+)");
                //
                // got the CB, update the pattern
                //

                pCB->arpBlobBlock[CfIndex] = pBlob;
                GetBlobFromPattern(pPatternSave, CfIndex) = pBlob;
                pPatternSave->pClientBlock = pClient;
                pPatternSave->pClassificationBlock = pCB;
                pPatternSave->DbCtx = (PVOID)SpHandle;
                pCB->ClassificationHandle = *pCH;
                TRACE(PATTERN, pPatternSave, pBlob, "AddSpecificPattern(3)");

                TRACE(PATTERN, pPatternSave, SpHandle, "AddSpecificPattern: DbCtx");

                pPatternSave->State = GPC_STATE_READY;

                if (pBlob != NULL) {
                    
                    //
                    // Reason for not using the Blob->Lock anymore -
                    // The lock is taken at teh start of this function.
                    // (only to maintain the order in which locks are taken/released.
                    GpcInsertTailList
                        (&pBlob->PatternList, 
                         &pPatternSave->BlobLinkage[CfIndex]
                         );
                    

                }

                ASSERT(pCf);

                if (pProtocol->GenericPatternCount) {

                    //
                    // a new pattern has been created in the specific db.
                    // the CB associated with it needs to be updated for each
                    // CF entry (except the one we've already updated now)
                    // we'll loop through the CF enlisted and find a match
                    // for the specific pattern in each generic db.
                    //
                    
                    pHead = &glData.CfList;
                    pEntry = pHead->Flink;
                    
                    while (pEntry != pHead) {
                        
                        //
                        // loop through the registered CF's
                        //
                        
                        pCf = CONTAINING_RECORD(pEntry, CF_BLOCK, Linkage);
                        
                        pEntry = pEntry->Flink;
                        
                        if (pCf->AssignedIndex != CfIndex || pBlob == NULL) {
                            
                            //
                            // skip the current CF only if this client installed
                            // a CfInfo
                            //
                            
                            pGenericDb = pCf->arpGenericDb[pProtocol->ProtocolTemplate];
                            ASSERT(pGenericDb);
                            
                            for (i = 0, pPatternSave = NULL; 
                                 i < pCf->MaxPriorities && pPatternSave == NULL; 
                                 i++, pGenericDb++) {
                                
                                //
                                // scan each priority Rhizome
                                //
                                
                                READ_LOCK(&pGenericDb->Lock, &ReadIrql);
                                
                                GpHandle = searchRhizome(pGenericDb->pRhizome,
                                                         pPatternBits);
                                
                                if (GpHandle != NULL) {
                                    
                                    pPatternSave = (PPATTERN_BLOCK)GetReferenceFromPatternHandle(GpHandle);

                                    REFADD(&pPatternSave->RefCount, 'ADSP');

                                }
                                
                                READ_UNLOCK(&pGenericDb->Lock, ReadIrql);
                            }
                            
                            if (pPatternSave != NULL) {
                                
                                //
                                // found a generic match, get the reference
                                // which is a pointer to a pattern and get the
                                // blob pointer from it.
                                //
                                
                                pCB->arpBlobBlock[pCf->AssignedIndex] = 
                                    GetBlobFromPattern(pPatternSave,pCf->AssignedIndex);
                                
                                REFDEL(&pPatternSave->RefCount, 'ADSP');

                            } else {
                                
                                //
                                // no generic pattern matches this specific one
                                //
                                
                                pCB->arpBlobBlock[pCf->AssignedIndex] = NULL;

                            }

                            TRACE(PATTERN, pPatternSave, pCB->arpBlobBlock[pCf->AssignedIndex], "AddSpecificPattern(4)");

                        }

                    }	// while (pEntry != pHead)

                } 	// if (pProtocol->GenericPatternCount)

            } else {   // if (pCB)

                //
                // remove from pathash table!! (#321509)
                //

                removePatHashTable(
                                   pSpecificDb->pDb,
                                   SpHandle
                                   );

                REFDEL(&pPatternSave->RefCount, 'ADSP');

                if (pCB) {
                    ReleaseClassificationBlock(pCB);
                }

                if (*pCH) {
                    FreeClassificationHandle(pClient, 
                                             *pCH
                                             );
                }
                 
                Status = GPC_STATUS_RESOURCES;

            }
        }
            
    } else { // if (SpHandle != NULL)

        Status = GPC_STATUS_RESOURCES;
    }

    //
    // release the specific db lock
    //
    
    WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);

    //
    // Since we want to take the blob lock and specific DB lock
    // in the same order everywhere, release the blob lock after
    // the specific DB lock. GPCEnumCfInfo does the same.
    //
    if (pBlob) {
        
        NDIS_UNLOCK(&pBlob->Lock);

    }

    //
    // set output parameters:
    //   ppPattern should have been set by now
    //
    
    TRACE(PATTERN, *ppPattern, Status, "AddSpecificPattern==>");

    return Status;
}





/*
************************************************************************

HandleFragment -

Handle an IP fragment.

Arguments
	pClient    -
    bFirstFrag -
    bLastFrag  - 
    
Retu
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
HandleFragment(
               IN  PCLIENT_BLOCK		pClient,
               IN  PPROTOCOL_BLOCK		pProtocol,
               IN  BOOLEAN             	bFirstFrag,
               IN  BOOLEAN             	bLastFrag,
               IN  ULONG				PacketId,
               IN OUT PPATTERN_BLOCK   *ppPatternBlock,
               OUT PBLOB_BLOCK			*ppBlob
)
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PFRAGMENT_DB	        pFragDb;
    SpecificPatternHandle	SpHandle;
    KIRQL					ReadIrql;
    KIRQL					WriteIrql;
    KIRQL					CHirql;

    ASSERT(ppPatternBlock);
    ASSERT(ppBlob);

	TRACE(CLASSIFY, PacketId, bFirstFrag, "HandleFragment: PacketId, bFirstFrag");
	TRACE(CLASSIFY, PacketId, bLastFrag, "HandleFragment: PacketId, bLastFrag");

    pFragDb = (PFRAGMENT_DB)pProtocol->pProtocolDb;

    if (bFirstFrag) {

        //
        // add an entry to the hash table
        //

        WRITE_LOCK(&pFragDb->Lock, &WriteIrql);

        SpHandle = insertPatHashTable(
                                      pFragDb->pDb,
                                      (char *)&PacketId,
                                      PacketId,
                                      (void *)*ppPatternBlock
                                      );

        WRITE_UNLOCK(&pFragDb->Lock, WriteIrql);

        ProtocolStatInc(pProtocol->ProtocolTemplate, 
                        FirstFragsCount);
        
    } else {

        //
        // search for it
        //

        READ_LOCK(&pFragDb->Lock, &ReadIrql);

        SpHandle = searchPatHashTable(
                                      pFragDb->pDb,
                                      (char *)&PacketId,
                                      PacketId);
        if (SpHandle) {

            *ppPatternBlock = GetReferenceFromSpecificPatternHandle(SpHandle);

            READ_UNLOCK(&pFragDb->Lock, ReadIrql);

            //NdisInterlockedIncrement(&(*ppPatternBlock)->RefCount);

            if (bLastFrag) {
                
                //
                // remove the entry from the hash table
                //
             
                WRITE_LOCK(&pFragDb->Lock, &WriteIrql);

                removePatHashTable(pFragDb->pDb, SpHandle);

                WRITE_UNLOCK(&pFragDb->Lock, WriteIrql);
                
                ProtocolStatInc(pProtocol->ProtocolTemplate, 
                                LastFragsCount);
            }

        } else {

            //
            // not found
            //

            READ_UNLOCK(&pFragDb->Lock, ReadIrql);

            *ppPatternBlock = NULL;
            *ppBlob = NULL;
            Status = GPC_STATUS_NOT_FOUND;
        }

    }

    if (Status == GPC_STATUS_SUCCESS) {

        ASSERT(*ppPatternBlock);

        if (TEST_BIT_ON((*ppPatternBlock)->Flags, PATTERN_SPECIFIC)) {

            //
            // specific pattern, lookup throught the CH
            //

            READ_LOCK(&glData.ChLock, &CHirql);

            *ppBlob = (PBLOB_BLOCK)dereference_HF_handle_with_cb(
							glData.pCHTable,
                            (*ppPatternBlock)->pClassificationBlock->ClassificationHandle,
                            pClient->pCfBlock->AssignedIndex);

            READ_UNLOCK(&glData.ChLock, CHirql);

        } else {

            //
            // generic pattern, get the blob ptr directly
            //

            *ppBlob = GetBlobFromPattern((*ppPatternBlock), 
                                         pClient->pCfBlock->AssignedIndex);
                            
        }
         
        DBGPRINT(CLASSIFY, ("HandleFragment: Pattern=%X Blob=%X\n", 
                            *ppPatternBlock, *ppBlob));

    }

	TRACE(CLASSIFY, *ppPatternBlock, *ppBlob, "HandleFragment==>");

    return Status;
}





/*
************************************************************************

InternalSearchPattern -


Arguments

Returns
	matched pattern or NULL for none

************************************************************************
*/
NTSTATUS
InternalSearchPattern(
	IN  PCLIENT_BLOCK			pClientBlock,
    IN  PPROTOCOL_BLOCK			pProtocol,
    IN  PVOID					pPatternKey,
    OUT PPATTERN_BLOCK          *pPatternBlock,
    OUT	PCLASSIFICATION_HANDLE  pClassificationHandle,
    IN	BOOLEAN                 bNoCache
    )
{
    PSPECIFIC_PATTERN_DB	pSpecificDb;
    PGENERIC_PATTERN_DB		pGenericDb;
    PatternHandle			GpHandle;
    SpecificPatternHandle	SpHandle;
    PPATTERN_BLOCK			pPattern;
    PCF_BLOCK				pCf;
    int                     i;
    KIRQL					ReadIrql;
    NTSTATUS                Status;

	TRACE(CLASSIFY, pClientBlock, pPatternKey, "InternalSearchPattern:");

    DBGPRINT(CLASSIFY, ("InternalSearchPattern: Client=%X \n", pClientBlock));

    Status = GPC_STATUS_SUCCESS;

    //
    // start with the specific db
    //

    pSpecificDb = &pProtocol->SpecificDb;

    READ_LOCK(&pSpecificDb->Lock, &ReadIrql);

    pCf = pClientBlock->pCfBlock;

    SpHandle = searchPatHashTable(
                                  pSpecificDb->pDb,
                                  (char *)pPatternKey,
                                  GpcCalcHash(pProtocol->ProtocolTemplate,
                                              pPatternKey)
                                  );
    
    if (SpHandle) {
        
        pPattern = (PPATTERN_BLOCK)GetReferenceFromSpecificPatternHandle(SpHandle);
        //NdisInterlockedIncrement(&pPattern->RefCount);

        *pClassificationHandle = 
            (CLASSIFICATION_HANDLE)pPattern->pClassificationBlock->ClassificationHandle;

        TRACE(CLASSIFY, pClientBlock, *pClassificationHandle, "InternalSearchPattern (2)" );

    } else {

        pPattern = NULL;
        *pClassificationHandle = 0;
    }

    READ_UNLOCK(&pSpecificDb->Lock, ReadIrql);

    if (pPattern == NULL) {

        if (bNoCache) {

            Status = GPC_STATUS_FAILURE;

        } else {

            //
            // no specific pattern, add an automagic one 
            //

            Status = AddSpecificPatternWithTimer(
                                            pClientBlock,
                                            pProtocol->ProtocolTemplate,
                                            pPatternKey,
                                            &pPattern,
                                            pClassificationHandle
                                            );

            DBGPRINT(CLASSIFY, ("InternalSearchPattern: Client=%X installed Pattern=%X\n", 
                                pClientBlock, pPattern));

        }

        if (!NT_SUCCESS(Status)) {

            //
            // not found, search each generic db
            //
        
            for (i = 0; i < (int)pCf->MaxPriorities && pPattern == NULL; i++) {
            
                //
                // scan each priority Rhizome
                //
            
                pGenericDb = &pCf->arpGenericDb[pProtocol->ProtocolTemplate][i];
                READ_LOCK(&pGenericDb->Lock, &ReadIrql);
            
                GpHandle = searchRhizome(pGenericDb->pRhizome, pPatternKey);
            
                if (GpHandle != NULL) {
                
                    pPattern = (PPATTERN_BLOCK)GetReferenceFromPatternHandle(GpHandle);
                    //NdisInterlockedIncrement(&pPattern->RefCount);

                }
                            
                READ_UNLOCK(&pGenericDb->Lock, ReadIrql);
            
            }

            // we had to search manually, make sure we know this in the main code.
            *pClassificationHandle = 0;

        }


        DBGPRINT(CLASSIFY, ("InternalSearchPattern: Client=%X Generic Pattern=%X\n", 
                            pClientBlock, pPattern));
    }


	TRACE(CLASSIFY, pPattern, *pClassificationHandle, "InternalSearchPattern==>");

    DBGPRINT(CLASSIFY, ("InternalSearchPattern: Client=%X returned Pattern=%X\n", 
                        pClientBlock, pPattern));

    *pPatternBlock = pPattern;
    return Status;
}




GPC_STATUS
InitFragmentDb(
               IN  PFRAGMENT_DB   *ppFragDb
)
{
    GPC_STATUS   Status = GPC_STATUS_SUCCESS;
    PFRAGMENT_DB pDb;
	ULONG		 Len, i;
    
	TRACE(INIT, ppFragDb, 0, "InitFragmentDb");
    
    ASSERT(ppFragDb);

    //
    // init the pattern db struct
    // call the PH init routine
    //
    
    GpcAllocMem(ppFragDb, sizeof(FRAGMENT_DB), FragmentDbTag);

    if (pDb = *ppFragDb) {
        
        INIT_LOCK(&pDb->Lock);

        AllocatePatHashTable(pDb->pDb);
        
        if (pDb->pDb != NULL) {
            
            constructPatHashTable(pDb->pDb,
                                  sizeof(ULONG),
                                  2,	// usage_ratio,
                                  1,    // usage_histeresis,
                                  1,    // allocation_histeresis,
                                  16    // max_free_list_size
                                  );
        } else {
            GpcFreeMem (*ppFragDb, FragmentDbTag);
            
            Status = GPC_STATUS_RESOURCES;
        }
        
    } else {

        Status = GPC_STATUS_RESOURCES;
    }
    
	TRACE(INIT, Status, 0, "InitFragmentDb==>");
    
    return Status;
}


GPC_STATUS
UninitFragmentDb(
               IN  PFRAGMENT_DB   pFragDb
)
{
    destructPatHashTable (pFragDb->pDb);
    FreePatHashTable(pFragDb->pDb);
    GpcFreeMem (pFragDb, FragmentDbTag);
    return STATUS_SUCCESS;
}

/*
************************************************************************

RemoveSpecificPattern -

Remove a specific pattern from the db. 

Arguments
	pClient		- 
    pPattern	- 

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
RemoveSpecificPattern(
                      IN  PCLIENT_BLOCK			pClient,
                      IN  PPROTOCOL_BLOCK		pProtocol,
                      IN  PPATTERN_BLOCK		pPattern,
                      IN  BOOLEAN               ForceRemoval
                      )
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PSPECIFIC_PATTERN_DB	pSpecificDb;
    PatternHandle	    	GpHandle;
    PPATTERN_BLOCK          pGp;
    PCF_BLOCK               pCf;
    int                     i;
    ULONG                   CfIndex;
    PBLOB_BLOCK             pBlob, pNewBlob;
    PGENERIC_PATTERN_DB		pGenericDb;
    KIRQL					ReadIrql;
    KIRQL					WriteIrql;
    ULONG					ProtocolTemplate;
    KIRQL					irql;
    LONG					cClientRef;
    BOOLEAN					bRemoveLinks = FALSE;
    GPC_HANDLE              ClHandle = NULL;

	TRACE(PATTERN, pClient, pPattern, "RemoveSpecificPattern");

    //
    // get the specific db pointer
    //

    pSpecificDb = &pProtocol->SpecificDb;
    ASSERT(pSpecificDb);
    
    pCf = pClient->pCfBlock;
    CfIndex = pCf->AssignedIndex;
    ProtocolTemplate = pProtocol->ProtocolTemplate;

    // The plan: Remove the DbCtx (from the Specific pattern structure)
    // from teh Pathash table with the Specific Db Lock held. This 
    // will ensure that if the same pattern is being added, the pathash
    // table will accept the new one instead of bumping up the ref on what
    // we are trying to delete now.
    //
    NDIS_LOCK(&pPattern->Lock);        
    WRITE_LOCK(&pSpecificDb->Lock, &WriteIrql);
    
    cClientRef = NdisInterlockedDecrement(&pPattern->ClientRefCount);

    if (pPattern->State != GPC_STATE_DELETE) {
        
        ASSERT(cClientRef >= 0); 
        ASSERT(pPattern->DbCtx);
        
        if (0 == cClientRef) {

            pPattern->State = GPC_STATE_DELETE;
        
            removePatHashTable(
                               pSpecificDb->pDb,
                               (SpecificPatternHandle)pPattern->DbCtx
                               );
    
            pPattern->DbCtx = NULL;

            WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);
            NDIS_UNLOCK(&pPattern->Lock);
        
            ReadySpecificPatternForDeletion(
                                            pClient,
                                            pProtocol,
                                            pPattern
                                            );

        } else if (cClientRef > 0) {
        
            WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);
            NDIS_UNLOCK(&pPattern->Lock);

            ClientRefsExistForSpecificPattern(
                                              pClient,
                                              pProtocol,
                                              pPattern
                                              );

        } else {

            // we shouldn't be getting here - really.
            WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);
            NDIS_UNLOCK(&pPattern->Lock);

        }
            
    
    } else {

        WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);
        NDIS_UNLOCK(&pPattern->Lock);

    }

	TRACE(PATTERN, pPattern, Status, "RemoveSpecificPattern==>");

    return Status;
}


/*
************************************************************************

ReadySpecificPatternForDeletion -

Remove a specific pattern from the db. 

Arguments
	pClient		- 
    pPattern	- 

Returns
	GPC_STATUS

************************************************************************
*/
VOID
ReadySpecificPatternForDeletion(
                                IN  PCLIENT_BLOCK	    pClient,
                                IN  PPROTOCOL_BLOCK		pProtocol,
                                IN  PPATTERN_BLOCK		pPattern
                                )
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PSPECIFIC_PATTERN_DB	pSpecificDb;
    PatternHandle	    	GpHandle;
    PPATTERN_BLOCK          pGp;
    PCF_BLOCK               pCf;
    PCLASSIFICATION_BLOCK	pCB;
    int                     i;
    ULONG                   CfIndex;
    PBLOB_BLOCK             pBlob, pNewBlob;
    PGENERIC_PATTERN_DB		pGenericDb;
    KIRQL					ReadIrql;
    KIRQL					WriteIrql;
    ULONG					ProtocolTemplate;
    KIRQL					irql;
    PVOID					Key;
    LONG					cClientRef;
    BOOLEAN					bRemoveLinks = FALSE;
    GPC_HANDLE              ClHandle = NULL;

	TRACE(PATTERN, pClient, pPattern, "ReadySpecificPatternForDeletion");

    //
    // get the specific db pointer
    //

    pSpecificDb = &pProtocol->SpecificDb;
    ASSERT(pSpecificDb);
    
    pCf = pClient->pCfBlock;
    CfIndex = pCf->AssignedIndex;
    pCB = pPattern->pClassificationBlock;
    ProtocolTemplate = pProtocol->ProtocolTemplate;
    Key = GetKeyPtrFromSpecificPatternHandle(((SpecificPatternHandle)pPattern->DbCtx));

    ASSERT(pCB);

    //
    // Remove the ClHandle, so that if we are coming back in via a
    // user mode ioctl, we wont try to remove it again.
    //
    ClHandle = (HANDLE) LongToPtr(InterlockedExchange((PLONG32)&pPattern->ClHandle, 0));

    if (ClHandle) {
        FreeHandle(ClHandle);
    }
        
    //
    // remove the pattern from any linked list
    //
    ClearPatternLinks(pPattern, pProtocol, CfIndex);
    
    //
    // We are going to access the Specific DB now, lock it NOW.
    // This should fix deadlock 248352 [ShreeM]
    //
    WRITE_LOCK(&pSpecificDb->Lock, &WriteIrql);
        
    //
    // this is the last client that holds the pattern, 
    // we need to take the pattern off the specific db
    // 
    
    TRACE(PATTERN, pPattern, pPattern->DbCtx, "ReadySpecificPatternForDeletion: DbCtx");
    
    ASSERT(!pPattern->DbCtx);

    ProtocolStatInc(ProtocolTemplate, 
                    RemovedPH);
            
    //
    // free the classification handle - 
    // this must come *before* we free the classification block
    // since it may be referenced by other clients
    //
    
    TRACE(PATTERN, pCB, CfIndex, "ReadySpecificPatternForDeletion: (2)");
    
    FreeClassificationHandle(
                             pClient,
                             (CLASSIFICATION_HANDLE)pCB->ClassificationHandle
                             );
    
    ProtocolStatInc(ProtocolTemplate, 
                    RemovedCH);
    
    WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);
        
    
    //
    // bye bye pattern, at least for this client
    //
    
    REFDEL(&pPattern->RefCount, 'ADSP');
    
    TRACE(PATTERN, pClient, pPattern, "ReadySpecificPatternForDeletion--------->");

}


/*
************************************************************************

ClientRefsExistForSpecificPattern -

Arguments
	pClient		- 
    pPattern	- 

Returns
	GPC_STATUS

************************************************************************
*/
VOID
ClientRefsExistForSpecificPattern(
                      IN  PCLIENT_BLOCK			pClient,
                      IN  PPROTOCOL_BLOCK		pProtocol,
                      IN  PPATTERN_BLOCK		pPattern
                      )
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PSPECIFIC_PATTERN_DB	pSpecificDb;
    PatternHandle	    	GpHandle;
    PPATTERN_BLOCK          pGp;
    PCF_BLOCK               pCf;
    PCLASSIFICATION_BLOCK	pCB;
    int                     i;
    ULONG                   CfIndex;
    PBLOB_BLOCK             pBlob, pNewBlob;
    PGENERIC_PATTERN_DB		pGenericDb;
    KIRQL					ReadIrql;
    KIRQL					WriteIrql;
    ULONG					ProtocolTemplate;
    KIRQL					irql;
    PVOID					Key;
    LONG					cClientRef;
    BOOLEAN					bRemoveLinks = FALSE;
    GPC_HANDLE              ClHandle = NULL;

	TRACE(PATTERN, pClient, pPattern, "ClientRefsExistForSpecificPattern");

    //
    // get the specific db pointer
    //

    pSpecificDb = &pProtocol->SpecificDb;
    ASSERT(pSpecificDb);
    
    pCf = pClient->pCfBlock;
    CfIndex = pCf->AssignedIndex;
    pCB = pPattern->pClassificationBlock;
    ProtocolTemplate = pProtocol->ProtocolTemplate;
    Key = GetKeyPtrFromSpecificPatternHandle(((SpecificPatternHandle)pPattern->DbCtx));

    ASSERT(pCB);

    //
    // reference count > 0
    //

    pBlob = pCB->arpBlobBlock[CfIndex];

    TRACE(PATTERN, pPattern, pBlob, "ClientRefsExistForSpecificPattern (2)");

    //
    // We are going to access the Specific DB now, lock it NOW.
    // This should fix deadlock 248352 [ShreeM]
        //
    WRITE_LOCK(&pSpecificDb->Lock, &WriteIrql);

    if (pBlob 
        && 
        ((pBlob->pOwnerClient == pClient) ||
         TEST_BIT_ON(pBlob->Flags, PATTERN_REMOVE_CB_BLOB))) {

        bRemoveLinks = TRUE;
        pNewBlob = NULL;

        TRACE(PATTERN, pCB, CfIndex, "ClientRefsExistForSpecificPattern (3)");

        //
        // search the generic db for the same CF, since there is an open slot,
        // some other generic pattern might fill it with its own blob pointer
        //
            
        pGenericDb = pCf->arpGenericDb[ProtocolTemplate];
            
        ASSERT(pGenericDb);
            
        for (i = 0, pGp = NULL; 
             i < (int)pCf->MaxPriorities && pGp == NULL; 
             i++) {
                
            //
            // scan each priority Rhizome
            //
                
            READ_LOCK(&pGenericDb->Lock, &ReadIrql);
                
            GpHandle = searchRhizome(pGenericDb->pRhizome, Key);
                
            if (GpHandle != NULL) {
                    
                //
                // found a generic pattern that match this specific one.
                //
                    
                pGp = (PPATTERN_BLOCK)GetReferenceFromPatternHandle(GpHandle);
                pNewBlob = GetBlobFromPattern(pGp, CfIndex);
            }
                
            READ_UNLOCK(&pGenericDb->Lock, ReadIrql);
                
            pGenericDb++;
        }

        //
        // update the classification block entry
        //

        WRITE_LOCK(&glData.ChLock, &irql);

        pCB->arpBlobBlock[CfIndex] = pNewBlob;

        WRITE_UNLOCK(&glData.ChLock, irql);

        TRACE(PATTERN, pGp, 
              pCB->arpBlobBlock[CfIndex], 
              "ClientRefsExistForSpecificPattern (4)");

    }

    //
    // must first release this lock to avoid dead lock
    // when aquiring the Blob lock
    //

    WRITE_UNLOCK(&pSpecificDb->Lock, WriteIrql);
    
    if (bRemoveLinks) {

        //
        // remove the pattern from any linked list
        //
            
        ClearPatternLinks(pPattern, pProtocol, CfIndex);

        ASSERT(CfIndex == pBlob->pOwnerClient->pCfBlock->AssignedIndex);

        GetBlobFromPattern(pPattern, CfIndex) = NULL;

    }


    REFDEL(&pPattern->RefCount, 'ADSP');

	TRACE(PATTERN, pClient, pPattern, "ClientRefsExistForSpecificPattern---->");

} 




/*
************************************************************************

RemoveGenericPattern -

Remove a generic pattern from the db. 

Arguments
	pClient		- 
    pPattern	- 

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
RemoveGenericPattern(
                     IN  PCLIENT_BLOCK			pClient,
                     IN  PPROTOCOL_BLOCK		pProtocol,
                     IN  PPATTERN_BLOCK		    pPattern
                     )
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PSPECIFIC_PATTERN_DB	pSpecificDb;
    PGENERIC_PATTERN_DB		pGenericDb;
    PCF_BLOCK               pCf;
    SCAN_STRUCT				ScanStruct;
    UCHAR                   PatternBits[MAX_PATTERN_SIZE];
    UCHAR                   MaskBits[MAX_PATTERN_SIZE];
    ULONG                   i;
    KIRQL					ReadIrql;
    KIRQL					WriteIrql;
    GPC_HANDLE              ClHandle = NULL;

	TRACE(PATTERN, pPattern, pPattern->DbCtx, "RemoveGenericPattern");

    ASSERT(MAX_PATTERN_SIZE >= sizeof(GPC_IP_PATTERN));
    ASSERT(MAX_PATTERN_SIZE >= sizeof(GPC_IPX_PATTERN));

    //
    // Remove the ClHandle, so that if we are coming back in via a
    // user mode ioctl, we wont try to remove it again.
    //
    ClHandle = (HANDLE) LongToPtr(InterlockedExchange((PLONG32)&pPattern->ClHandle, 0));
    
    if (ClHandle) {
        FreeHandle(ClHandle);
    }

    pPattern->State = GPC_STATE_REMOVE;

    pCf = pClient->pCfBlock;
    
    ScanStruct.Priority = pPattern->Priority;
    ScanStruct.pClientBlock = pClient;
    ScanStruct.pPatternBlock = pPattern;
    ScanStruct.pBlobBlock = GetBlobFromPattern(pPattern, pCf->AssignedIndex);
    ScanStruct.bRemove = TRUE;

    //
    // get the specific db pointer
    //

    pSpecificDb = &pProtocol->SpecificDb;
    ASSERT(pSpecificDb);

    pGenericDb = &pCf->arpGenericDb[pProtocol->ProtocolTemplate][pPattern->Priority];
    ASSERT(pGenericDb);
    
    //
    // remove the pattern from any linked list
    //
    ClearPatternLinks(pPattern, pProtocol, pCf->AssignedIndex);
    
    //
    // copy the pattern key and mask for searching later
    //
    NDIS_LOCK(&pPattern->Lock);

    WRITE_LOCK(&pGenericDb->Lock, &WriteIrql);



    ASSERT(pPattern->DbCtx);

    NdisMoveMemory(PatternBits, 
                   GetKeyPtrFromPatternHandle(pGenericDb->pRhizome,
                                              pPattern->DbCtx),
                   GetKeySizeBytes(pGenericDb->pRhizome)
                   );
    NdisMoveMemory(MaskBits,
                   GetMaskPtrFromPatternHandle(pGenericDb->pRhizome,
                                               pPattern->DbCtx),
                   GetKeySizeBytes(pGenericDb->pRhizome)
                   );

    //
    // remove the pattern from generic db
    //

    removeRhizome(pGenericDb->pRhizome,
                  (PatternHandle)pPattern->DbCtx
                  );

    ProtocolStatInc(pProtocol->ProtocolTemplate, 
                    RemovedRz);
        
    //
    // This is no longer valid
    //

    pPattern->DbCtx = NULL;
    
    WRITE_UNLOCK(&pGenericDb->Lock, WriteIrql);
    NDIS_UNLOCK(&pPattern->Lock);

    //
    // the generic pattern has been removed, 
    //

    READ_LOCK(&pSpecificDb->Lock, &ReadIrql);
    
    //
    // this will do the rest of the work...
    //
    
    scanPatHashTable(
                     pSpecificDb->pDb,
                     (char *)PatternBits,
                     (char *)MaskBits,
                     (PVOID)&ScanStruct,
                     GpcSpecificCallback   // see callback routine...
                     );
    
    READ_UNLOCK(&pSpecificDb->Lock, ReadIrql);

    //
    // time to go to the big hunting fields....
    //
    REFDEL(&pPattern->RefCount, 'ADGP');

	TRACE(PATTERN, pPattern, Status, "RemoveGenericPattern==>");

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\gpcdbg.c ===
/*
************************************************************************

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    gpcmain.c

Abstract:

    This file contains initialization stuff for the GPC

Author:

    Ofer Bar - April 15, 1997

Environment:

    Kernel mode

Revision History:


************************************************************************
*/

#include "gpcpre.h"



#if DBG

ULONG	DebugFlags = PATTERN | RHIZOME 
                     | LOCKS | CLASSIFY
					 | BLOB | MEMORY | IOCTL 
                     | CLIENT | MAPHAND | CLASSHAND | PAT_TIMER;
ULONG   DbgPrintFlags = 0;
ULONG   BytesAllocated = 0;

NDIS_SPIN_LOCK   LogLock;

//extern LOG Log;

LOG     Log  = {0, NULL, NULL, 0};


//
// Forward definition
//
#if 0
ULONG
StrLen(
    IN  UCHAR   *Ptr
    );
#endif


NTSTATUS
InitializeLog(
    VOID
    )
{
    NTSTATUS  Status = STATUS_SUCCESS;

    //
    // allocate memory for it
    //
    Log.Buffer = (PROW)ExAllocatePoolWithTag(NonPagedPool, 
                                             (LOGSIZE+4) * sizeof(ROW), 
                                             DebugTag);
    
    if (Log.Buffer) {

        Log.Index = 0;
        Log.Wraps = 0;
        Log.Current = Log.Buffer;

        NdisAllocateSpinLock(&LogLock);

    } else {

        Status = STATUS_NO_MEMORY;
    }

    return Status;
}


VOID
FreeDebugLog(VOID) 
{
    ExFreePool(Log.Buffer);
    Log.Buffer = NULL;
}


#if 0
ULONG
StrLen(
    IN  UCHAR   *Ptr
    )

/*++

Routine Description:

    This function does a strlen - so that we don't have to enable intrinsics.

Arguments:
    Ptr - a ptr to the string

Return Value:

    - the number of characters.

--*/

{
    ULONG   Count = 0;

    while (*Ptr++) {
        Count++;
    }

    return( Count );

}
#endif

VOID
TraceRtn(
    IN  UCHAR       *File,
    IN  ULONG       Line,
    IN  UCHAR       *FuncName,
    IN  ULONG_PTR   Param1,
    IN  ULONG_PTR   Param2,
    IN  ULONG	    Param3,
    IN  ULONG	    Param4,
    IN  ULONG       Mask
    )

/*++

Routine Description:

    This function logs the file and line number along with 3 other parameters
    into a circular buffer and possibly to the debug terminal.

Arguments:


Return Value:


--*/

{
    NTSTATUS    status;
    PROW        pEntry;
    PUCHAR      pFile, p;
    LONG		l, m;

    if (!Log.Buffer)
    {
        return;
    }

    NdisAcquireSpinLock(&LogLock);

    pEntry = &Log.Buffer[Log.Index];

    p = File;
    pFile = p + strlen(File) - 1;
    while (*pFile != '\\' && p != pFile) {
      pFile--;
    }
    //pFile = (PUCHAR)strrchr((CONST CHAR * )File,'\\');
    pFile++;

    RtlZeroMemory(&pEntry->Row[0], LOGWIDTH);

    l = strlen(pFile);
    RtlCopyMemory(&pEntry->Row[0], pFile, min(l,LOGWIDTH));

    if (l+3 < LOGWIDTH) {

        pEntry->Row[l+0] = ' ';
        pEntry->Row[l+1] = '%';
        pEntry->Row[l+2] = 'd';
        pEntry->Row[l+3] = ' ';
    }

    if (l+4 < LOGWIDTH) {

        m = strlen(FuncName);
        RtlCopyMemory(&pEntry->Row[l+4], FuncName, min(m,LOGWIDTH-(l+4)));
    }

    pEntry->Line = Line;
    pEntry->Time = GetTime();
    pEntry->P1 = Param1;
    pEntry->P2 = Param2;
    pEntry->P3 = Param3;
    pEntry->P4 = Param4;

    //++Log.Current;
    if (++(Log.Index) >= LOGSIZE)
    {
        Log.Index = 0;
        Log.Wraps++;
        Log.Current = Log.Buffer;
    }
    if (DebugFlags & KD_PRINT) {
        KdPrint(( pEntry->Row, Line ));
        KdPrint(( " %p %p %d %d\n", Param1, Param2, Param3, Param4 ));
    }

    NdisReleaseSpinLock(&LogLock);
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\gpcdbg.h ===
/********************************************************************/
/**                 Microsoft Generic Packet Scheduler             **/
/**               Copyright(c) Microsoft Corp., 1996-1997          **/
/********************************************************************/

#ifndef __GPCDBG
#define __GPCDBG

//***   gpcdbg.h - GPC definitions & prototypes for debug/memory handling
//


#define GPC_MEM_MARK     'KRAM'


/*
/////////////////////////////////////////////////////////////////
//
//   defines
//
/////////////////////////////////////////////////////////////////
*/

#if DBG


#undef ASSERT
#define ASSERT( Value ) \
{                       \
    if ((ULONG_PTR)(Value) == 0) {   \
        KdPrint(("** ASSERT Failed ** %s\n",#Value));\
        KdPrint(("Assert Failed at line %d in file %s\n",__LINE__,__FILE__));\
        DbgBreakPoint();                                                     \
    }                                                                        \
}

//
// DBG=1
//

#define GpcAllocMem( _pAddress,_Length,_Tag )                          \
{                                                                      \
    PCHAR   _Addr;                                                     \
    ULONG   _Size = (((_Length)+3)&0xfffffffc) + 3*sizeof(ULONG);      \
    _Addr=ExAllocatePoolWithTag(NonPagedPool,_Size,_Tag );             \
    TRACE(MEMORY,_Addr+8,_Length,"GpcAllocMem");                       \
    if (_Addr) {                                                       \
        NdisFillMemory(_Addr, _Size, 0x7f);                            \
        *(PULONG)_Addr = _Size;                                        \
        *(PULONG)(_Addr+sizeof(ULONG)) = GPC_MEM_MARK;                 \
        *(PULONG)(_Addr+_Size-sizeof(ULONG)) = GPC_MEM_MARK;           \
        (PVOID)(*_pAddress) = (PVOID)(_Addr + 2*sizeof(ULONG));        \
        BytesAllocated += _Size;                                       \
    } else {                                                           \
        *_pAddress = NULL;                                             \
    }                                                                  \
}


#define GpcFreeMem( _Address,_Tag )                                    \
{                                                                      \
    PCHAR _Addr = ((PUCHAR)_Address) - 2*sizeof(ULONG);                \
    ULONG _Size = *(PULONG)_Addr;                                      \
    TRACE(MEMORY,_Address,_Size-12,"GpcFreeMem");                      \
    ASSERT(*(PULONG)(_Addr+sizeof(ULONG)) == GPC_MEM_MARK);            \
    ASSERT(*(PULONG)(_Addr+_Size-sizeof(ULONG)) == GPC_MEM_MARK);      \
    NdisFillMemory(_Addr, _Size, 0xCC);                                \
    ExFreePool( _Addr );                                               \
    BytesAllocated -= _Size;                                           \
}


#define GpcAllocFromLL(_ptr, _list, _tag)                              \
{                                                                      \
    PCHAR _Addr;                                                       \
    if (_Addr = (PCHAR)NdisAllocateFromNPagedLookasideList(_list)) {   \
    	*(PULONG)(_Addr) = GPC_MEM_MARK;                               \
    	(PVOID)(*_ptr) = (PVOID)(_Addr + sizeof(ULONG_PTR));           \
    	TRACE(MEMORY,_tag,*_ptr,"GpcAllocFromLL");                     \
    } else {														   \
        *_ptr = NULL;                                                  \
    }        														   \
}


#define GpcFreeToLL(_ptr, _list, _tag)                                 \
{                                                                      \
    PCHAR _Addr = ((PUCHAR)_ptr) - sizeof(ULONG_PTR);                  \
    ASSERT(*(PULONG)_Addr == GPC_MEM_MARK);                            \
    *(PULONG)_Addr = 0x77777777;                                       \
    NdisFreeToNPagedLookasideList(_list, _Addr);                       \
    TRACE(MEMORY,_tag,_ptr,"GpcFreeToLL");                             \
}


#define GET_IRQL(_i)      _i = KeGetCurrentIrql()
#define VERIFY_IRQL(_i)   ASSERT((_i)==KeGetCurrentIrql())
#define DEFINE_KIRQL(_i)  KIRQL _i

#else     // DBG != 1



#define GpcAllocMem( Addr,Len,_Tag ) \
    *Addr = ExAllocatePoolWithTag(NonPagedPool, Len, _Tag )

#define GpcFreeMem( Address,_Tag )   \
    ExFreePool( (Address) )

#define GpcAllocFromLL(_ptr, _list, _tag) \
    *_ptr = NdisAllocateFromNPagedLookasideList(_list)

#define GpcFreeToLL(_ptr, _list, _tag)    \
    NdisFreeToNPagedLookasideList(_list, _ptr)

#define GET_IRQL(_i)
#define VERIFY_IRQL(_i)
#define DEFINE_KIRQL(_i)

#endif // if DBG



#if DBG
#define LockedIncrement( Count,_p )   LockedInc(Count,__FILE__,__LINE__,_p)
#else
#define LockedIncrement( Count,_p )   NdisInterlockedIncrement((PLONG)Count)
#endif

#if DBG
#define LockedDecrement( Count,_p )   LockedDec(Count,__FILE__,__LINE__,_p)
#else
#define LockedDecrement( Count,_p )   NdisInterlockedDecrement((PLONG)Count)
#endif

#define KD_PRINT     0x00000001
#define INIT         0x00000002
#define BLOB         0x00000004
#define PATTERN      0x00000008
#define NOTIFY       0x00000010
#define REGISTER     0x00000020
#define MEMORY       0x00000040
#define LOOKUP       0x00000080
#define LOCKS        0x00000100
#define CLASSIFY     0x00000200
#define RHIZOME      0x00000400
#define PATHASH      0x00000800
#define IOCTL        0x00001000
#define CLIENT       0x00002000
#define MAPHAND      0x00004000
#define CLASSHAND    0x00008000
#define PAT_TIMER    0x00010000
#define REFCOUNT     0x00020000
#define PARAM_EX     0x80000000   // this is reserved for the trace routine

#if DBG
#define DBGPRINT(Mask, String) \
{ \
 if(Mask & DbgPrintFlags)\
  DbgPrint String;\
}

#define TRACE( Mask,P1,P2,_fname )  \
{ \
 if (Mask & DebugFlags)\
  TraceRtn((PUCHAR)__FILE__,(ULONG)__LINE__,_fname,(ULONG_PTR)(P1),(ULONG_PTR)(P2),KeGetCurrentProcessorNumber(),KeGetCurrentIrql(),Mask|PARAM_EX);\
}

#else

#define DBGPRINT(Mask, String)
#define TRACE( Mask,P1,P2,_fname )

#endif



/*
/////////////////////////////////////////////////////////////////
//
//   externs & prototypes
//
/////////////////////////////////////////////////////////////////
*/

extern ULONG       DebugFlags;
extern ULONG       DbgPrintFlags;
extern ULONG       BytesAllocated;

VOID
TraceRtn(
        IN  UCHAR       *File,
        IN  ULONG       Line,
        IN  UCHAR       *FuncName,
        IN  ULONG_PTR   Param1,
        IN  ULONG_PTR   Param2,
        IN  ULONG   	Param3,
        IN  ULONG   	Param4,
        IN  ULONG       Mask
        );


_inline LONGLONG
GetTime(
    VOID
    )

/*++

Routine Description:

    Get the current system time

Arguments:


Return Value:

    System time (in base OS time units)

--*/

{
    LARGE_INTEGER Now;
    LARGE_INTEGER Frequency;

#if defined(PERF_COUNTER) || defined (TRACE_PERF_COUNTER)
    Now = KeQueryPerformanceCounter(&Frequency);
    Now.QuadPart = (Now.QuadPart * OS_TIME_SCALE) / Frequency.QuadPart;
#else
    NdisGetCurrentSystemTime( &Now );
#endif

    return Now.QuadPart;
}


#define LOGSIZE     4000  // number of entries
#define LOGWIDTH    64  // number of characters (one or two bytes) per entry


//
//
typedef struct {

    UCHAR   	Row[ LOGWIDTH ];
    LONGLONG	Time;
    ULONG		Line;
    ULONG_PTR	P1;
    ULONG_PTR	P2;
    ULONG		P3;
    ULONG		P4;

} ROW, *PROW;

typedef struct {

    ULONG   Index;
    PROW    Current;
    PROW    Buffer;
    ULONG	Wraps;

} LOG, *PLOG;

_inline VOID
DbgVerifyList(
           PLIST_ENTRY h
           )
{
    PLIST_ENTRY p = h->Flink;
    PLIST_ENTRY q = h;
    int			m = 1000;

    if (h->Flink == h) {
        ASSERT(h->Blink == h);
    }

    while (p != h && m > 0) {

        ASSERT(p->Blink == q);
        q = p;
        p = p->Flink;
        m--;
    }

    ASSERT(m > 0);
}


#endif //__GPCDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\gpcmap.h ===
/********************************************************************/
/**                 Microsoft Generic Packet Scheduler             **/
/**               Copyright(c) Microsoft Corp., 1996-1997          **/
/********************************************************************/

#ifndef __GPCMAP
#define __GPCMAP

//***   gpcmap.h - GPC definitions & prototypes for mapping handles
//

HANDLE
AllocateHandle(
    OUT HANDLE *OutHandle,           
    IN  PVOID  Reference
    );

VOID
SuspendHandle(
    IN 	HANDLE    Handle
    );

VOID
ResumeHandle(
    IN 	HANDLE    Handle
    );

VOID
FreeHandle(
    IN 	HANDLE    Handle
    );

PVOID
GetHandleObject(
	IN  HANDLE					h,
    IN  GPC_ENUM_OBJECT_TYPE	ObjType
    );

PVOID
GetHandleObjectWithRef(
	IN  HANDLE					h,
    IN  GPC_ENUM_OBJECT_TYPE	ObjType,
    IN  ULONG                   Ref

    );

GPC_STATUS
InitMapHandles(VOID);

VOID
UninitMapHandles(VOID);


#endif //__GPCMAP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\gpchlp.c ===
/*
************************************************************************

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    gpcdb.c

Abstract:

    This file contains specific patterns database routines

Author:

    Ofer Bar  -April 15, 1997

Environment:

    Kernel mode

Revision History:


************************************************************************
*/

#include "gpcpre.h"

//
// locals
//

/*
************************************************************************

CreateNewCfBlock -

create and return a new CF block for internal use

Arguments

	CfId			- 
    MaxPriorities	-

Returns
	pointer to the new CF block or NULL for no memory resources

************************************************************************
*/
PCF_BLOCK
CreateNewCfBlock(
	IN	ULONG			CfId,
    IN	ULONG			MaxPriorities
    )
{
    PCF_BLOCK	pCf;
    int			i;
    GPC_STATUS	Status;

    GpcAllocFromLL(&pCf, &ClassificationFamilyLL, ClassificationFamilyTag);

    if (pCf) {

        //
        // reset all
        //

        NdisZeroMemory(pCf, sizeof(CF_BLOCK));

        InitializeListHead(&pCf->ClientList);
        InitializeListHead(&pCf->BlobList);
        NDIS_INIT_LOCK(&pCf->Lock);
        //pCf->ClientSync = 0;
        //INIT_LOCK(&pCf->ClientSync);
        NDIS_INIT_LOCK(&pCf->ClientSync);

        pCf->NumberOfClients = 0;
        pCf->AssignedIndex = CfId;
        pCf->MaxPriorities = MaxPriorities;
        ReferenceInit(&pCf->RefCount, pCf, ReleaseCfBlock);
        REFADD(&pCf->RefCount, 'CFBK');

        //
        // for each protocol, reset the generic pattern
        // this will be dynamically allocated later
        // when pattern are installed
        //
        
        for (i = 0; i < GPC_PROTOCOL_TEMPLATE_MAX; i++) {

            Status = InitializeGenericDb(&pCf->arpGenericDb[i], 
                                         MaxPriorities,
                                         glData.pProtocols[i].PatternSize);
            
            if (Status != GPC_STATUS_SUCCESS) {
                
                REFDEL(&pCf->RefCount, 'CFBK');
                pCf = NULL;
                break;
            }
        }
    }

    return pCf;
}


/*
************************************************************************

ReleaseCfBlock -

Release the CF block

Arguments

	pCf - the CF block to release

Returns
	void

************************************************************************
*/
VOID
ReleaseCfBlock(
	IN  PCF_BLOCK	pCf
    )
{
    int		i;

    ASSERT(pCf);
    ASSERT(IsListEmpty(&pCf->ClientList));
    ASSERT(IsListEmpty(&pCf->BlobList));
    ASSERT(pCf->NumberOfClients == 0);

    for (i = 0; i < GPC_PROTOCOL_TEMPLATE_MAX; i++) {
        
        if (pCf->arpGenericDb[i]) {
            
            UninitializeGenericDb(&pCf->arpGenericDb[i],
                                  pCf->MaxPriorities
                                  );
        }
    }
    
    NdisFreeSpinLock(&pCf->Lock);

    //
    // just free the memory
    //

    GpcFreeToLL(pCf, &ClassificationFamilyLL, ClassificationFamilyTag);
}




/*
************************************************************************

CreateNewClientBlock -

create and return a new client block for internal use

Arguments
	none

Returns
	pointer to the new client block or NULL for no memory resources

************************************************************************
*/
PCLIENT_BLOCK
CreateNewClientBlock(VOID)
{
    PCLIENT_BLOCK	pClient;

    GpcAllocFromLL(&pClient, &ClientLL, ClientTag);

    if (pClient) {

        //
        // reset all
        //

        NdisZeroMemory(pClient, sizeof(CLIENT_BLOCK));

        pClient->ObjectType = GPC_ENUM_CLIENT_TYPE;
        pClient->ClHandle = NULL;

        NDIS_INIT_LOCK(&pClient->Lock);
        InitializeListHead(&pClient->BlobList);
        ReferenceInit(&pClient->RefCount, pClient, DereferenceClient);
        REFADD(&pClient->RefCount, 'CLNT');
    }

    return pClient;
}




/*
************************************************************************

CreateNewPatternBlock -

create and return a new pattern block for internal use

Arguments
	none

Returns
	pointer to the new pattern block or NULL for no memory resources

************************************************************************
*/
PPATTERN_BLOCK
CreateNewPatternBlock(
                     IN  ULONG	Flags
                     )
{
    PPATTERN_BLOCK	pPattern;
    int				i;

    GpcAllocFromLL(&pPattern, &PatternLL, PatternTag);

    if (pPattern) {

        //
        // reset all
        //

        TRACE(PATTERN, pPattern, sizeof(PATTERN_BLOCK), "CreateNewPatternBlock");

        NdisZeroMemory(pPattern, sizeof(PATTERN_BLOCK));

        pPattern->ObjectType = GPC_ENUM_PATTERN_TYPE;
        
        for (i = 0; i < GPC_CF_MAX; i++) {
            InitializeListHead(&pPattern->BlobLinkage[i]);
        }

        InitializeListHead(&pPattern->TimerLinkage);
        NDIS_INIT_LOCK(&pPattern->Lock);
        pPattern->Flags = Flags;
        ReferenceInit(&pPattern->RefCount, pPattern, DereferencePattern);
        REFADD(&pPattern->RefCount, 'FILT');
        pPattern->ClientRefCount = 1;
        pPattern->State = GPC_STATE_INIT;

        //AllocateHandle(&pPattern->ClHandle, (PVOID)pPattern);
    }

    return pPattern;
}




/*
************************************************************************

CreateNewBlobBlock -

create and return a new blob block for internal use.
A copy of ClientData is being place pointed by the new blob

Arguments
	none

Returns
	pointer to the new blob block or NULL for no memory resources

************************************************************************
*/
PBLOB_BLOCK
CreateNewBlobBlock(
                     IN  ULONG		ClientDataSize,
                     IN  PVOID		pClientData
                     )
{
    PBLOB_BLOCK	pBlob;

    GpcAllocFromLL(&pBlob, &CfInfoLL, CfInfoTag);

    if (pBlob) {

        //
        // reset all
        //
            
        NdisZeroMemory(pBlob, sizeof(BLOB_BLOCK));

        GpcAllocMem(&pBlob->pClientData, ClientDataSize, CfInfoDataTag);

        if (pBlob->pClientData) {

            pBlob->ObjectType = GPC_ENUM_CFINFO_TYPE;
            pBlob->ClHandle = NULL;
            
            InitializeListHead(&pBlob->ClientLinkage);
            InitializeListHead(&pBlob->PatternList);
            InitializeListHead(&pBlob->CfLinkage);

            pBlob->State = GPC_STATE_INIT;
            pBlob->Flags = 0;
            ReferenceInit(&pBlob->RefCount, pBlob, DereferenceBlob);
            REFADD(&pBlob->RefCount, 'BLOB');
            pBlob->ClientDataSize = ClientDataSize;
            pBlob->LastStatus = GPC_STATUS_SUCCESS;
            NdisMoveMemory(pBlob->pClientData, pClientData, ClientDataSize);
            NDIS_INIT_LOCK(&pBlob->Lock);

            //
            // that's for the notified client about the CfInfo Add
            //

            pBlob->pNotifiedClient = NULL;
            pBlob->NotifiedClientCtx = NULL;

        } else {

            GpcFreeToLL(pBlob, &CfInfoLL, CfInfoTag);

            pBlob = NULL;
        }
    }

    return pBlob;
}




/*
************************************************************************

AssignNewClientIndex -

Finds and returns a new index for a client on the CF. It also sets
the index as busy in the CF block.

Arguments
	pClient - poinetr to the client block

Returns
	a client index or (-1) for none

************************************************************************
*/
ULONG
AssignNewClientIndex(
                     IN PCF_BLOCK	pCfBlock
                     )
{
    ULONG	i;

    for (i = 0; i < MAX_CLIENTS_CTX_PER_BLOB; i++) {

        if (TEST_BIT_OFF(pCfBlock->ClientIndexes, (1 << i)))
            break;
    }

    if (i < MAX_CLIENTS_CTX_PER_BLOB) {

        //
        // found a zero bit, set it on
        //

        pCfBlock->ClientIndexes |= (1 << i);

    } else {
        i = (-1);
    }

    return i;
}



/*
************************************************************************

ReleaseClientBlock -

Release the client block

Arguments
	pClientBlock - the client block to release

Returns
	void

************************************************************************
*/
VOID
ReleaseClientBlock(
                   IN  PCLIENT_BLOCK	pClientBlock
                   )
{
    NdisFreeSpinLock(&pClientBlock->Lock);

    //
    // just free the memory
    //

    GpcFreeToLL(pClientBlock, &ClientLL, ClientTag);
}




/*
************************************************************************

ReleasePatternBlock -

Release the pattern block

Arguments
	pPatternBlock - the pattern block to release

Returns
	void

************************************************************************
*/
VOID
ReleasePatternBlock(
                   IN  PPATTERN_BLOCK	pPatternBlock
                   )
{

#if DBG
    pPatternBlock->TimeToLive = 0xdeadbeef;
#endif 

    //
    // just free the memory
    //

    GpcFreeToLL(pPatternBlock, &PatternLL, PatternTag);
}





/*
************************************************************************

ReleaseBlobBlock -

Release the blob block

Arguments
	pBlobBlock - the blob block to release

Returns
	void

************************************************************************
*/
VOID
ReleaseBlobBlock(
                   IN  PBLOB_BLOCK	pBlobBlock
                   )
{

    //
    // just free the memory
    //
    
    GpcFreeMem(pBlobBlock->pClientData, CfInfoDataTag);
    ASSERT(pBlobBlock->pNewClientData == NULL);
    GpcFreeToLL(pBlobBlock, &CfInfoLL, CfInfoTag);
}





/*
************************************************************************

CreateNewClassificationBlock -

create and return a new classification block for internal use

Arguments
	NumEntries - number of entries

Returns
	pointer to the new classification block or NULL for no memory resources

************************************************************************
*/
PCLASSIFICATION_BLOCK
CreateNewClassificationBlock(
                             IN  ULONG	NumEntries
                             )
{
    PCLASSIFICATION_BLOCK	pClassification;
    ULONG					l;

    l = sizeof(CLASSIFICATION_BLOCK) + sizeof(PBLOB_BLOCK) * (NumEntries-1);
    GpcAllocMem(&pClassification, l, ClassificationBlockTag);

    if (pClassification) {

        //
        // reset all
        //

        NdisZeroMemory(pClassification, l);

        pClassification->NumberOfElements = NumEntries;
    }

    return pClassification;
}




/*
************************************************************************

ReleaseClassificationBlock -

Release the Classification block

Arguments
	pClassificationBlock - the Classification block to release

Returns
	void

************************************************************************
*/
VOID
ReleaseClassificationBlock(
                           IN  PCLASSIFICATION_BLOCK	pClassificationBlock
                           )
{
    if (pClassificationBlock) {

        //
        // release the memory block
        //
        
        GpcFreeMem(pClassificationBlock, ClassificationBlockTag);
    }
}





/*
************************************************************************

GpcCalcHash -

Calculate the hash table key for a specific pattern

Arguments
	ProtocolTempId - The protocol template
    pPattern	   - a pointer to the pattern

Returns
	ULONG - the hash key, (-1) if Protocol value is illegal

************************************************************************
*/
ULONG
GpcCalcHash(
            IN	ULONG		ProtocolTempId,
            IN	PUCHAR		pPattern
            )
{
    ULONG				Key = (-1);
    ULONG				temp;
    PULONG				Cheat;
    PGPC_IP_PATTERN		pIpPatt;
    PGPC_IPX_PATTERN	pIpxPatt;
    const ULONG			MagicNumber = 0x9e4155b9; // magic number - hocus pocus

    TRACE(LOOKUP, ProtocolTempId, pPattern, "GpcClacHash");

    ASSERT(pPattern);

    switch (ProtocolTempId) {

    case GPC_PROTOCOL_TEMPLATE_IP:

        //
        // the IP protocol template, this function was contributed by
        // JohnDo
        //

        pIpPatt = (PGPC_IP_PATTERN)pPattern;
        temp = (pIpPatt->SrcAddr << 16) ^ (pIpPatt->SrcAddr >> 16)
            ^ pIpPatt->DstAddr ^ pIpPatt->ProtocolId ^ pIpPatt->gpcSpi;
        Key = temp * MagicNumber;	
        break;

    case GPC_PROTOCOL_TEMPLATE_IPX:

        //
        // the IPX protocol template, this function was contributed by
        // JohnDo
        //

        Cheat = (PULONG)pPattern;
        temp = 
            (Cheat[0] << 16) ^ (Cheat[0] >> 16) ^
            (Cheat[1] << 16) ^ (Cheat[1] >> 16) ^
            (Cheat[2] << 16) ^ (Cheat[2] >> 16) ^
            Cheat[3] ^ Cheat[4] ^ Cheat[5];

        Key = temp * MagicNumber;
        break;

    default:

        //
        // illegal value
        //

        ASSERT(0);
    }

    //
    // -1 is a bad key
    //

    if (Key == (-1))
        Key = 0;

    TRACE(LOOKUP, Key, 0, "GpcClacHash==>");

    return Key;
}





/*
************************************************************************

DereferencePattern -

Decrement the RefCount and deletes the pattern block if the count reaches
zero.

Arguments
    pPattern	- a pointer to the pattern

Returns
	void

************************************************************************
*/
VOID
DereferencePattern(
                   IN  PPATTERN_BLOCK	pPattern
                   )
{
    ASSERT(pPattern);
    //ASSERT(pPattern->RefCount.Count > 0);

    TRACE(PATTERN, pPattern, pPattern->DbCtx, "DereferencePattern");

    ProtocolStatInc(pPattern->ProtocolTemplate,
                    DerefPattern2Zero);

    ASSERT(IsListEmpty(&pPattern->TimerLinkage));

    //
    // no longer do we need this CB
    //

    ReleaseClassificationBlock(pPattern->pClassificationBlock);

    //
    // time to remove the pattern
    //
        
    ReleasePatternBlock(pPattern);

}



/*
************************************************************************

DereferenceBlob -

Decrement the RefCount and deletes the blob block if the count reaches
zero.

Arguments
    pBlob	   - a pointer to the blob

Returns
	void

************************************************************************
*/
VOID
DereferenceBlob(
                IN  PBLOB_BLOCK	pBlob
                )
{
    ASSERT(pBlob);
    //ASSERT(*ppBlob);

    //TRACE(BLOB, *ppBlob, (*ppBlob)->RefCount, "DereferenceBlob");
    
    //ASSERT((*ppBlob)->RefCount.Count > 0);

    CfStatInc(pBlob->pOwnerClient->pCfBlock->AssignedIndex,DerefBlobs2Zero);

    //
    // time to remove the blob
    //

    ReleaseBlobBlock(pBlob);
        
}



/*
************************************************************************

DereferenceClient -

Decrement the RefCount and deletes the client block if the count reaches
zero.

Arguments
    pClient - pointer to the client block

Returns
	void

************************************************************************
*/
VOID
DereferenceClient(
                  IN  PCLIENT_BLOCK	pClient
                  )
{
    PCF_BLOCK   pCf;
    KIRQL		irql;

    ASSERT(pClient);

    //TRACE(CLIENT, pClient, pClient->RefCount, "DereferenceClient");

    //ASSERT(pClient->RefCount.Count > 0);

    pCf = pClient->pCfBlock;

    RSC_WRITE_LOCK(&pCf->ClientSync, &irql);

    //
    // time to remove the client
    //

    GpcRemoveEntryList(&pClient->ClientLinkage);
    ReleaseClientIndex(pCf->ClientIndexes, pClient->AssignedIndex);

    ReleaseClientBlock(pClient);

    RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);
}





/*
************************************************************************

ClientAddCfInfo - 


Arguments


Returns
	

************************************************************************
*/
GPC_STATUS
ClientAddCfInfo(
                IN	PCLIENT_BLOCK			pClient,
                IN  PBLOB_BLOCK             pBlob,
                OUT	PGPC_CLIENT_HANDLE      pClientCfInfoContext
                )
{
    GPC_STATUS  Status = GPC_STATUS_SUCCESS;
    DEFINE_KIRQL(dbgIrql);

    TRACE(PATTERN, pClient, pBlob, "ClientAddCfInfo");

    *pClientCfInfoContext = NULL;

    if (pClient->State == GPC_STATE_READY) {

        if (pClient->FuncList.ClAddCfInfoNotifyHandler) {
            
            NdisInterlockedIncrement(&pBlob->ClientStatusCountDown);

            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, dbgIrql, "ClientAddCfInfo (2)");

            Status = (pClient->FuncList.ClAddCfInfoNotifyHandler)
                (
                 pClient->ClientCtx,
                 (GPC_HANDLE)pBlob,
                 pBlob->ClientDataSize,
                 pBlob->pClientData,
                 pClientCfInfoContext
                 );

            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, *pClientCfInfoContext, Status, "ClientAddCfInfo (3)");

            if (Status != GPC_STATUS_PENDING) {

                NdisInterlockedDecrement(&pBlob->ClientStatusCountDown);
            }

        }
    }

    return Status;
}

  

/*
************************************************************************

ClientAddCfInfoComplete - 


Arguments


Returns
	

************************************************************************
*/
VOID
ClientAddCfInfoComplete(
                        IN	PCLIENT_BLOCK			pClient,
                        IN	PBLOB_BLOCK             pBlob,
                        IN	GPC_STATUS				Status
                        )
{
    ULONG	CfIndex;
    DEFINE_KIRQL(dbgIrql);

    TRACE(PATTERN, pClient, pBlob, "ClientAddCfInfoComplete");

    ASSERT(Status != GPC_STATUS_PENDING);
    ASSERT(pClient);
    ASSERT(pBlob);

    if (pClient->State == GPC_STATE_READY) {

#if NO_USER_PENDING

        //
        // the user is blocking on this call
        //

        CTESignal(&pBlob->WaitBlock, Status);

#else

        CfIndex = pClient->pCfBlock->AssignedIndex;

        if (NT_SUCCESS(Status)) {
            
            CfStatInc(CfIndex,CreatedBlobs);
            CfStatInc(CfIndex,CurrentBlobs);
            
        } else {
            
            CfStatInc(CfIndex,RejectedBlobs);
        }

        if (pClient->FuncList.ClAddCfInfoCompleteHandler) {
            
            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, dbgIrql, "ClientAddCfInfoComplete (2)");
            TRACE(PATTERN, pClient, pBlob->arClientCtx[pClient->AssignedIndex], "ClientAddCfInfoComplete (3)");

            (pClient->FuncList.ClAddCfInfoCompleteHandler)
                (
                 pClient->ClientCtx,
                 pBlob->arClientCtx[pClient->AssignedIndex],
                 Status
                 );

            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, Status, "ClientAddCfInfoComplete (4)");

        } else if (IS_USERMODE_CLIENT(pClient) 
                   &&
                   pClient == pBlob->pOwnerClient ) {

            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, dbgIrql, "ClientAddCfInfoComplete (5)");

            //
            // this is a user mode client - call the specific routine
            // to complete a pending IRP, but only if the client is the 
            // blob owner
            //

            UMCfInfoComplete( OP_ADD_CFINFO, pClient, pBlob, Status );
                                
            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, Status, "ClientAddCfInfoComplete (6)");

        }

        if (NT_SUCCESS(Status)) {
            
            pBlob->State = GPC_STATE_READY;
            
        } else {
            
            //
            // remove the blob
            //
            REFDEL(&pBlob->RefCount, 'BLOB');

        }
#endif
    }
}



/*
************************************************************************

ClientModifyCfInfoComplete - 


Arguments


Returns
	

************************************************************************
*/
VOID
ClientModifyCfInfoComplete(
                           IN	PCLIENT_BLOCK			pClient,
                           IN	PBLOB_BLOCK             pBlob,
                           IN	GPC_STATUS	        	Status
                           )
{
    DEFINE_KIRQL(dbgIrql);

    TRACE(PATTERN, pClient, pBlob, "ClientModifyCfInfoComplete");

    ASSERT(Status != GPC_STATUS_PENDING);

    if (pClient->State == GPC_STATE_READY) {

        if (pClient->FuncList.ClModifyCfInfoCompleteHandler) {
            
            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, dbgIrql, "ClientModifyCfInfoComplete (2)");

            (pClient->FuncList.ClModifyCfInfoCompleteHandler)
                (
                 pClient->ClientCtx,
                 pBlob->arClientCtx[pClient->AssignedIndex],
                 Status
                 );

            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, pBlob->arClientCtx[pClient->AssignedIndex], Status, "ClientModifyCfInfoComplete (3)");

        } else if (IS_USERMODE_CLIENT(pClient)) {

            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, dbgIrql, "ClientModifyCfInfoComplete (4)");

            UMCfInfoComplete( OP_MODIFY_CFINFO, pClient, pBlob, Status );
                                
            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, pBlob->arClientCtx[pClient->AssignedIndex], Status, "ClientModifyCfInfoComplete (5)");
        }

    }
}



/*
************************************************************************

ClientModifyCfInfo - 


Arguments


Returns
	

************************************************************************
*/
GPC_STATUS
ClientModifyCfInfo(
                   IN	PCLIENT_BLOCK			pClient,
                   IN   PBLOB_BLOCK             pBlob,
                   IN   ULONG                   CfInfoSize,
                   IN   PVOID                   pClientData
                   )
{
    GPC_STATUS  Status = GPC_STATUS_IGNORED;
    DEFINE_KIRQL(dbgIrql);

    TRACE(PATTERN, pClient, pBlob, "ClientModifyCfInfo");

    if (pClient->State == GPC_STATE_READY) {

        if (pClient->FuncList.ClModifyCfInfoNotifyHandler) {

            NdisInterlockedIncrement(&pBlob->ClientStatusCountDown);

            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, dbgIrql, "ClientModifyCfInfo (2)");

            Status = (pClient->FuncList.ClModifyCfInfoNotifyHandler)
                (pClient->ClientCtx,
                 pBlob->arClientCtx[pClient->AssignedIndex],
                 CfInfoSize,
                 pClientData
                 );

            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, pBlob->arClientCtx[pClient->AssignedIndex], Status, "ClientModifyCfInfo (3)");

            if (Status != GPC_STATUS_PENDING) {
             
                NdisInterlockedDecrement(&pBlob->ClientStatusCountDown);
            }

        }
    }

    return Status;
}




/*
************************************************************************

ClientRemoveCfInfoComplete - 


Arguments


Returns
	

************************************************************************
*/
VOID
ClientRemoveCfInfoComplete(
                           IN	PCLIENT_BLOCK			pClient,
                           IN	PBLOB_BLOCK             pBlob,
                           IN	GPC_STATUS				Status
                           )
{
    ULONG	CfIndex;
    DEFINE_KIRQL(dbgIrql);

    TRACE(PATTERN, pClient, pBlob, "ClientRemoveCfInfoComplete");

    ASSERT(Status != GPC_STATUS_PENDING);
    ASSERT(pClient);
    ASSERT(pBlob);

#if NO_USER_PENDING

    //
    // the user is blocking on this call
    //
    
    CTESignal(&pBlob->WaitBlock, Status);

#else

    CfIndex = pClient->pCfBlock->AssignedIndex;

    if (NT_SUCCESS(Status)) {
        
        CfStatInc(CfIndex,DeletedBlobs);
        CfStatDec(CfIndex,CurrentBlobs);
    }
    
    if (pClient->FuncList.ClRemoveCfInfoCompleteHandler) {
        
        GET_IRQL(dbgIrql);

        TRACE(PATTERN, pClient, pBlob->arClientCtx[pClient->AssignedIndex], "ClientRemoveCfInfoComplete (2)");

        (pClient->FuncList.ClRemoveCfInfoCompleteHandler)
            (
             pClient->ClientCtx,
             pBlob->arClientCtx[pClient->AssignedIndex],
             Status
             );
        
        VERIFY_IRQL(dbgIrql);

        TRACE(PATTERN, pClient, Status, "ClientRemoveCfInfoComplete (3)");

    } else if (IS_USERMODE_CLIENT(pClient)) {

        GET_IRQL(dbgIrql);

        TRACE(PATTERN, pClient, pBlob->arClientCtx[pClient->AssignedIndex], "ClientRemoveCfInfoComplete (4)");

        UMCfInfoComplete( OP_REMOVE_CFINFO, pClient, pBlob, Status );
        
        VERIFY_IRQL(dbgIrql);

        TRACE(PATTERN, pClient, Status, "ClientRemoveCfInfoComplete (5)");
    }

#endif
}



/*
************************************************************************

ClientRemoveCfInfo - 


Arguments


Returns
	

************************************************************************
*/
GPC_STATUS
ClientRemoveCfInfo(
                   IN	PCLIENT_BLOCK			pClient,
                   IN   PBLOB_BLOCK             pBlob,
                   IN	GPC_CLIENT_HANDLE		ClientCfInfoContext
                   )
{
    GPC_STATUS  Status = GPC_STATUS_SUCCESS;
    DEFINE_KIRQL(dbgIrql);

    TRACE(PATTERN, pClient, pBlob, "ClientRemoveCfInfo");

    if (pClient->State == GPC_STATE_READY) {

        if (pClient->FuncList.ClRemoveCfInfoNotifyHandler) {

            NdisInterlockedIncrement(&pBlob->ClientStatusCountDown);

            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, ClientCfInfoContext, "ClientRemoveCfInfo (2)");

            Status = (pClient->FuncList.ClRemoveCfInfoNotifyHandler)
                (pClient->ClientCtx,
                 ClientCfInfoContext
                 );

            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, Status, "ClientRemoveCfInfo (3)");

            if (Status != GPC_STATUS_PENDING) {
             
                NdisInterlockedDecrement(&pBlob->ClientStatusCountDown);
            }

        } else if (IS_USERMODE_CLIENT(pClient)
                   &&
                   pClient == pBlob->pOwnerClient) {

            GET_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, ClientCfInfoContext, "ClientRemoveCfInfo (4)");

            //
            // the notified client installed the blob
            // and it is a user mode client
            // we need to make a special call to dequeue a pending IRP
            // and complete it with the specified data
            //

            UMClientRemoveCfInfoNotify(pClient, pBlob);

            VERIFY_IRQL(dbgIrql);

            TRACE(PATTERN, pClient, Status, "ClientRemoveCfInfo (5)");
        }
    }

    return Status;
}





/*
************************************************************************

ClearPatternLinks - 


Arguments


Returns
	

************************************************************************
*/
VOID
ClearPatternLinks(
                  IN  PPATTERN_BLOCK        pPattern,
                  IN  PPROTOCOL_BLOCK		pProtocol,
                  IN  ULONG                 CfIndex
                  )
{
    PBLOB_BLOCK    *ppBlob;

    //
    // Remove the pattern from the blob list
    // and NULL the pointer to the blob in the pattern block
    //

    ppBlob = & GetBlobFromPattern(pPattern, CfIndex);

    if (*ppBlob) {

        NDIS_LOCK(&(*ppBlob)->Lock);

        GpcRemoveEntryList(&pPattern->BlobLinkage[CfIndex]);

        NDIS_UNLOCK(&(*ppBlob)->Lock);

        *ppBlob = NULL;

    }

}




/*
************************************************************************

ModifyCompleteClients - 


Arguments


Returns
	

************************************************************************
*/
VOID
ModifyCompleteClients(
                      IN  PCLIENT_BLOCK   pClient,
                      IN  PBLOB_BLOCK     pBlob
                      )
{
    uint            i;
    PCLIENT_BLOCK   pNotifyClient;
    KIRQL			irql;

    if (NT_SUCCESS(pBlob->LastStatus)) {
        
        //
        // in case of successful completion, assign the 
        // new client data
        //
        
        NDIS_LOCK(&pBlob->Lock);
        WRITE_LOCK(&glData.ChLock, &irql);

        GpcFreeMem(pBlob->pClientData, CfInfoDataTag);
        pBlob->ClientDataSize = pBlob->NewClientDataSize;
        pBlob->pClientData = pBlob->pNewClientData;

        WRITE_UNLOCK(&glData.ChLock, irql);
        NDIS_UNLOCK(&pBlob->Lock);

    } else {
        
        GpcFreeMem(pBlob->pNewClientData, CfInfoDataTag);
    }

    pBlob->NewClientDataSize = 0;
    pBlob->pNewClientData = NULL;
    
    //
    // notify each client (except the caller) that successfully
    // modified the blob about the status. 
    // it can be SUCCESS or some failure
    //
    
    for (i = 0; i < MAX_CLIENTS_CTX_PER_BLOB; i++) {
        
        //
        // only clients with none zero entries
        // have been succefully modified the blob
        //
        
        if (pNotifyClient = pBlob->arpClientStatus[i]) {
            
            //
            // complete here
            //
            
            ClientModifyCfInfoComplete(
                                       pNotifyClient,
                                       pBlob,
                                       pBlob->LastStatus
                                       );
            
            //
            // release the one we got earlier
            //
            
            //DereferenceClient(pNotifyClient);
        }
        
    } // for

#if 0
    //
    // now, complete the call back to the calling client
    //
    
    ClientModifyCfInfoComplete(
                               pBlob->pCallingClient,
                               pBlob,
                               pBlob->LastStatus
                               );
#endif

    pBlob->State = GPC_STATE_READY;
}




#if 0
/*
************************************************************************

GetClassificationHandle - 

Get the classification handle from the blob. If none is available
creates a new one. '0' is not a valid CH!

Arguments
    pClient  - The calling client
    pPattern - The pattern that refers to the CH

Returns
    A classification handle 

************************************************************************
*/
CLASSIFICATION_HANDLE
GetClassificationHandle(
                        IN  PCLIENT_BLOCK   pClient,
                        IN  PPATTERN_BLOCK  pPattern
                        )
{
    HFHandle				hfh;
	ULONG					t;
    PCLASSIFICATION_BLOCK	pCB;

	TRACE(CLASSIFY, pClient, pPattern, "GetClassificationHandle:");

    if (TEST_BIT_ON(pPattern->Flags,PATTERN_SPECIFIC)) {
        
        //
        // this is a specific pattern
        //

        //
        // get the CH from it
        //

        ASSERT(pPattern->pClassificationBlock);
        hfh = pPattern->pClassificationBlock->ClassificationHandle;

        //
        // check if CH is valid
        //

        t = pPattern->ProtocolTemplate;
        
        pCB = (PCLASSIFICATION_BLOCK)dereference_HF_handle(glData.pCHTable, 
                                                           hfh);
        
        TRACE(CLASSHAND, pCB, hfh, "GetClassificationHandle (~)");

        if (pCB != pPattern->pClassificationBlock) {

            //
            // the CH is invalid, release it and get a new one
            //

            NDIS_LOCK(&glData.Lock);

            release_HF_handle(glData.pCHTable, hfh);

            ProtocolStatInc(pPattern->ProtocolTemplate, 
                            RemovedCH);
        
            TRACE(CLASSHAND, glData.pCHTable, hfh, "GetClassificationHandle (-)");

            hfh = assign_HF_handle(glData.pCHTable,
                                   (void *)pPattern->pClassificationBlock);

            ProtocolStatInc(pPattern->ProtocolTemplate, 
                            InsertedCH);
        

            NDIS_UNLOCK(&glData.Lock);

            TRACE(CLASSIFY, pPattern, hfh, "GetClassificationHandle (+)");

            pPattern->pClassificationBlock->ClassificationHandle = hfh;
        }

    } else {

        //
        // this is a generic pattern
        //

        hfh = 0;

    }

	TRACE(CLASSIFY, pPattern, hfh, "GetClassificationHandle==>");

    return (CLASSIFICATION_HANDLE)hfh;
}
#endif



/*
************************************************************************

FreeClassificationHandle - 

Free the classification handle. It will invalidate the entry in the 
index table and make it avaiable for future use.

Arguments
    pClient  - The calling client
    CH       - The classification handle

Returns
    void

************************************************************************
*/
VOID
FreeClassificationHandle(
                         IN  PCLIENT_BLOCK          pClient, 
                         IN  CLASSIFICATION_HANDLE  CH
                         )
{
    KIRQL	CHirql;

    WRITE_LOCK(&glData.ChLock, &CHirql);

    release_HF_handle(glData.pCHTable, CH);

    TRACE(CLASSHAND, glData.pCHTable, CH, "FreeClassificationHandle");

    WRITE_UNLOCK(&glData.ChLock, CHirql);
}




GPC_STATUS
CleanupBlobs(
             IN  PCLIENT_BLOCK     pClient
             )
{
    PBLOB_BLOCK          pBlob;
    //PPATTERN_BLOCK       pPattern;
    //ULONG                CfIndex = pClient->pCfBlock->AssignedIndex;
    GPC_STATUS           Status = GPC_STATUS_SUCCESS;

    NDIS_LOCK(&pClient->Lock);

    //
    // scan blobs
    //

    while (!IsListEmpty(&pClient->BlobList)) {

        //
        // get the blob
        //

        pBlob = CONTAINING_RECORD(pClient->BlobList.Flink, BLOB_BLOCK, ClientLinkage);

        pBlob->Flags |= PATTERN_REMOVE_CB_BLOB;

        NDIS_UNLOCK(&pClient->Lock);

        //
        // remove the blob
        //
        
        Status = GpcRemoveCfInfo((GPC_HANDLE)pClient,
                                 (GPC_HANDLE)pBlob
                                 );

        NDIS_LOCK(&pClient->Lock);
        
    }

    NDIS_UNLOCK(&pClient->Lock);

    return GPC_STATUS_SUCCESS;
}




VOID
CloseAllObjects(
	IN	PFILE_OBJECT	FileObject,
    IN  PIRP			Irp
    )
{
    PLIST_ENTRY     	pEntry0, pHead0;
    PLIST_ENTRY     	pEntry, pHead;
    PCLIENT_BLOCK		pClient = NULL;
    PCF_BLOCK			pCf;
    PPROTOCOL_BLOCK		pProtocol;
    //int					i,j;
    //NTSTATUS			NtStatus;
    //QUEUED_COMPLETION	QItem;
    KIRQL				irql;

    NDIS_LOCK(&glData.Lock);

    pHead0 = &glData.CfList;
    pEntry0 = pHead0->Flink;

    while (pEntry0 != pHead0 && pClient == NULL) {

        pCf = CONTAINING_RECORD(pEntry0, CF_BLOCK, Linkage);
        pEntry0 = pEntry0->Flink;
        
        RSC_READ_LOCK(&pCf->ClientSync, &irql);

        pHead = &pCf->ClientList;
        pEntry = pHead->Flink;
            
        while (pEntry != pHead && pClient == NULL) {

            pClient = CONTAINING_RECORD(pEntry,CLIENT_BLOCK,ClientLinkage);
            pEntry = pEntry->Flink;

            if (pClient->pFileObject == FileObject) {

                REFADD(&pClient->RefCount, 'CAOB');

            } else {

                pClient = NULL;
            }
        }

        RSC_READ_UNLOCK(&pCf->ClientSync, irql);
        
    } // while (...)
        
    NDIS_UNLOCK(&glData.Lock);

    if (pClient) {

        //
        // clear all the blobs on the client
        //
        
        CleanupBlobs(pClient);
        
        //
        // deregister the client
        //
        
        GpcDeregisterClient((GPC_HANDLE)pClient);

        //
        // release the previous ref count
        //
        
        REFDEL(&pClient->RefCount, 'CAOB');

    }                    

}



// Cool new feature - Timer Wheels [ShreeM]
// We maintain N lists of patterns, one for each "timertick". The Pattern 
// Expiry routine will clean up one of the lists every time it is invoked.
// It then makes a note to cleanup the next list on the wheel, the next time
// it is invoked.
// The Timer Wheels reduces spin lock contention between inserts and deletes.

VOID
PatternTimerExpired(
	IN	PVOID					SystemSpecific1,
	IN	PVOID					FunctionContext,
	IN	PVOID					SystemSpecific2,
	IN	PVOID					SystemSpecific3
)
{
    PLIST_ENTRY		pEntry;
    PPATTERN_BLOCK	pPattern;
    PCF_BLOCK		pCf;
    ULONG           CleanupWheelIndex = 0, NewWheelIndex;
    PPROTOCOL_BLOCK	pProtocol = &glData.pProtocols[PtrToUlong(FunctionContext)];

    TRACE(PAT_TIMER, FunctionContext, 0, "PatternTimerExpired");

    DBGPRINT(PAT_TIMER, ("PatternTimerExpired: Timer expired, protocol=%d \n", 
                        PtrToUlong(FunctionContext)));

    //
    // Which of the timer wheels do we want to cleanup this time?
    // Remember that we Increment the current index pointer into the wheels
    // All the wheel index calculations are protected by gldata->lock.
    NDIS_LOCK(&glData.Lock);

    CleanupWheelIndex   = pProtocol->CurrentWheelIndex;
    pProtocol->CurrentWheelIndex += 1;
    //
    // Make sure we wrap around.
    //
    pProtocol->CurrentWheelIndex %= NUMBER_OF_WHEELS;
    NDIS_UNLOCK(&glData.Lock);
    NDIS_LOCK(&pProtocol->PatternTimerLock[CleanupWheelIndex]);


    while (!IsListEmpty(&pProtocol->TimerPatternList[CleanupWheelIndex])) {

        pEntry = RemoveHeadList(&pProtocol->TimerPatternList[CleanupWheelIndex]);

        pPattern = CONTAINING_RECORD(pEntry, PATTERN_BLOCK, TimerLinkage);

        NDIS_UNLOCK(&pProtocol->PatternTimerLock[CleanupWheelIndex]);
        
        ASSERT(pPattern->TimeToLive != 0xdeadbeef);
        
        ASSERT(TEST_BIT_ON( pPattern->Flags, PATTERN_AUTO ));

        NDIS_LOCK(&pPattern->Lock);
        pPattern->Flags |= ~PATTERN_AUTO;
        NDIS_UNLOCK(&pPattern->Lock);

        InitializeListHead(&pPattern->TimerLinkage);

        pCf = pPattern->pAutoClient->pCfBlock;

        TRACE(PAT_TIMER, pPattern, pPattern->RefCount.Count, "PatternTimerExpired: del");

        ProtocolStatInc(pPattern->ProtocolTemplate,
                        DeletedAp);

        ProtocolStatDec(pPattern->ProtocolTemplate,
                        CurrentAp);

        //
        // actually remove the pattern
        //

        DBGPRINT(PAT_TIMER, ("PatternTimerExpired: removing pattern=%X, ref=%d, client=%X \n", 
                            pPattern, pPattern->RefCount, pPattern->pAutoClient));

        GpcRemovePattern((GPC_HANDLE)pPattern->pAutoClient,
                         (GPC_HANDLE)pPattern);

        InterlockedDecrement(&pProtocol->AutoSpecificPatternCount);

        NDIS_LOCK(&pProtocol->PatternTimerLock[CleanupWheelIndex]);

    }
    
    NDIS_UNLOCK(&pProtocol->PatternTimerLock[CleanupWheelIndex]);

    //
    // If there are any Auto Specific patterns around restart the timer.
    //
    if(InterlockedExchangeAdd(&pProtocol->AutoSpecificPatternCount, 0) > 0) {
    
        NdisSetTimer(&pProtocol->PatternTimer, PATTERN_TIMEOUT);
        
        DBGPRINT(PAT_TIMER, ("PatternTimer restarted\n"));
    
    } else {

        DBGPRINT(PAT_TIMER, ("Zero Auto Patterns - Timer NOT restarted\n"));

    }

}



GPC_STATUS
AddSpecificPatternWithTimer(
	IN	PCLIENT_BLOCK			pClient,
    IN	ULONG					ProtocolTemplate,
    IN	PVOID					PatternKey,
    OUT	PPATTERN_BLOCK			*ppPattern,
    OUT	PCLASSIFICATION_HANDLE  pClassificationHandle
)
{
    GPC_STATUS		Status;
    PPATTERN_BLOCK	pPattern, pCreatedPattern;
    PPROTOCOL_BLOCK	pProtocol = &glData.pProtocols[ProtocolTemplate];
    UCHAR			Mask[MAX_PATTERN_SIZE];
    ULONG           WheelIndex = 0;

    TRACE(PAT_TIMER, pClient, PatternKey, "AddSpecificPatternWithTimer");

#if DBG
    {
        PGPC_IP_PATTERN	pIp = (PGPC_IP_PATTERN)PatternKey;
        
        DBGPRINT(PAT_TIMER, ("AddSpecificPatternWithTimer: Client=%X \n", pClient));
#if INTERFACE_ID
        DBGPRINT(PAT_TIMER, ("IP: ifc={%d,%d} src=%08X:%04x, dst=%08X:%04x, prot=%d rsv=%x,%x,%x\n",
                             pIp->InterfaceId.InterfaceId,
                             pIp->InterfaceId.LinkId,
                             pIp->SrcAddr,
                             pIp->gpcSrcPort,
                             pIp->DstAddr,
                             pIp->gpcDstPort,
                             pIp->ProtocolId,
                             pIp->Reserved[0],
                             pIp->Reserved[1],
                             pIp->Reserved[2]
                             ));
#endif
    }
#endif

    RtlFillMemory(Mask, sizeof(Mask), 0xff);

    pPattern = CreateNewPatternBlock(PATTERN_SPECIFIC);
    pCreatedPattern = pPattern;
    
    if (pPattern) {
        
        //
        // setup the pattern fields and add it
        //
        
        //pPattern->RefCount++;
        pPattern->Priority = 0;
        pPattern->ProtocolTemplate = ProtocolTemplate;
        pPattern->Flags |= PATTERN_AUTO;
        pPattern->pAutoClient = pClient;

        Status = AddSpecificPattern(
                                    pClient,
                                    PatternKey,
                                    Mask,
                                    NULL,
                                    pProtocol,
                                    &pPattern,  // output pattern pointer
                                    pClassificationHandle
                                    );
        

    } else {

        Status = GPC_STATUS_NO_MEMORY;

    }
    
    if (NT_SUCCESS(Status)) {
        
        //
        // we didn't get an already existing pattern
        //

        //ASSERT(*pClassificationHandle);
        
        *ppPattern = pPattern;
        
        // Figure out which wheel to stick this pattern on.
        NDIS_LOCK(&glData.Lock);
        WheelIndex = pProtocol->CurrentWheelIndex;
        NDIS_UNLOCK(&glData.Lock);
        
        WheelIndex += (NUMBER_OF_WHEELS -1);
        WheelIndex %= NUMBER_OF_WHEELS;

        //
        // we must lock this pattern since we look at the timer linkage
        // 

        NDIS_LOCK(&pPattern->Lock);

        //
        // set the AUTO flag again, since we might have got
        // a pattern that already exist
        //

        pPattern->Flags |= PATTERN_AUTO;
        pPattern->pAutoClient = pClient;
        pPattern->WheelIndex = WheelIndex;

        //
        // this pattern has not been on any the timer list yet
        //

        if (IsListEmpty(&pPattern->TimerLinkage)) {

            //
            // We need to insert this in the TimerWheel which is (NUMBER_OF_WHEELS - 1)
            // away from the current, so that it spends enough time on the list.
            //
            NDIS_DPR_LOCK(&pProtocol->PatternTimerLock[WheelIndex]);
        
            //
            // If the AutoSpecificPatternCount was zero earlier, then we need
            // to a) start the timer and b) increment this count.
            //
            if (1 == InterlockedIncrement(&pProtocol->AutoSpecificPatternCount)) {
            
                //
                // restart the timer for the first auto pattern
                //
                NdisSetTimer(&pProtocol->PatternTimer, PATTERN_TIMEOUT);
                
                TRACE(PAT_TIMER, pPattern, PATTERN_TIMEOUT, "Starting Pattern Timer\n AddSpecificPatternWithTimer: (1)");
            }
        
            GpcInsertHeadList(&pProtocol->TimerPatternList[WheelIndex], &pPattern->TimerLinkage);

            //
            // don't refer to pPattern after it has been placed on the timer list
            // since the timer may expire any time and remove it from there...
            //
            
            NDIS_DPR_UNLOCK(&pProtocol->PatternTimerLock[WheelIndex]);

        }

        //
        // This is a specific pattern, so lets increment the count [ShreeM].
        InterlockedIncrement(&pProtocol->SpecificPatternCount);

        NDIS_UNLOCK(&pPattern->Lock);
        
        ProtocolStatInc(ProtocolTemplate,
                        CreatedAp);
        
        ProtocolStatInc(ProtocolTemplate,
                        CurrentAp);
    } else {
        
        
        *ppPattern = NULL;
        *pClassificationHandle = 0;
        
        ProtocolStatInc(ProtocolTemplate,
                        RejectedAp);
        
    }

    if (pPattern) {

        //
        // release the reference count to this pattern
        // in case of an error, this will also release
        // the data block
        //

        REFDEL(&pCreatedPattern->RefCount, 'FILT');
    }

    TRACE(PAT_TIMER, pPattern, Status, "AddSpecificPatternWithTimer==>");
    
    DBGPRINT(CLASSIFY, ("AddSpecificPatternWithTimer: pClient=%X Pattern=%X Status=%X\n", 
                        pClient, pPattern, Status));

    return Status;
}



NTSTATUS
InitPatternTimer(
	IN	ULONG	ProtocolTemplate
)
{
    ULONG  i=0;

    
    //
    // We increase the granularity of when a "Automatic" Pattern gets cleaned 
    // out by using timer wheels, but they are more efficient for inserting and
    // removing (in terms of locks).
    //
    
    for (i = 0; i < NUMBER_OF_WHEELS; i++) {
        
        NDIS_INIT_LOCK(&glData.pProtocols[ProtocolTemplate].PatternTimerLock[i]);

        InitializeListHead(&glData.pProtocols[ProtocolTemplate].TimerPatternList[i]);

    }

    glData.pProtocols[ProtocolTemplate].CurrentWheelIndex = 0;

    
    NdisInitializeTimer(&glData.pProtocols[ProtocolTemplate].PatternTimer, 
                        PatternTimerExpired, 
                        (PVOID) ULongToPtr(ProtocolTemplate));

    return STATUS_SUCCESS;
}


//
// Some CRT and RTL functions that cant be used at DISPATHC_LEVEL IRQL are being 
// cut/paste here.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\gpcpre.h ===
//
// gpcpre.h
//

#include <ndis.h>
#include <ntddndis.h>
#include <cxport.h>

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "refcnt.h"
#include "gpcifc.h"
#include "rhizome.h"
#include "pathash.h"
#include "handfact.h"
#include "ntddgpc.h"
#include "gpcstruc.h"
#include "gpcdef.h"
#include "gpcdbg.h"
#include "gpcmap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\gpcdef.h ===
/*********************************************************************/
/**                 Microsoft Generic Packet Scheduler             **/
/**               Copyright(c) Microsoft Corp., 1996-1997          **/
/********************************************************************/

#ifndef __GPCDEF
#define __GPCDEF

//***   gpcdef.h - GPC internal definitions & prototypes
//
//  This file containes all the GPC data structures & defines


/*
/////////////////////////////////////////////////////////////////
//
//   defines
//
/////////////////////////////////////////////////////////////////
*/

//
// Max number of clients per blob (same CF)
//
// AbhisheV - This can not be more than sizeof(ULONG)*8.
//

#define MAX_CLIENTS_CTX_PER_BLOB 8


//
// Max pattern size,
// GPC_IP_PATTERN = 24 bytes
// GPC_IPX_PATTERN = 24 bytes
//
#define MAX_PATTERN_SIZE	    sizeof(GPC_IP_PATTERN)

extern BOOLEAN IsItChanging;

//
// Pattern flags
//
#define PATTERN_SPECIFIC		0x00000001
#define PATTERN_AUTO			0x00000002
#define PATTERN_REMOVE_CB_BLOB	0x00000004

//
// Auto Pattern defines
//

// Every PATTERN_TIMEOUT seconds, the PatternTimerExpiry Routine gets called.
#define PATTERN_TIMEOUT	                60000		// 60 seconds

// This is the amount of time that a Pattern created for optimization 
// lives on the Pattern List.
#define AUTO_PATTERN_ENTRY_TIMEOUT      300000      // 5 minutes

// This is the number of timer granularity.
#define NUMBER_OF_WHEELS	 	        (AUTO_PATTERN_ENTRY_TIMEOUT/PATTERN_TIMEOUT)

// New debug locks [ShreeM]
// This will enable us to figure out who took the lock last
// and who released it last. New structure defined below and
// lock_acquire and lock_release macros are redefined later.

typedef struct _GPC_LOCK {

    NDIS_SPIN_LOCK			Lock;

#if DBG
    PETHREAD    CurrentThread;
    KIRQL       CurrentIRQL;
    LONG        LockAcquired;             // is it current held?
    UCHAR       LastAcquireFile[8];       
    ULONG       LastAcquireLine;
    UCHAR       LastReleaseFile[8];
    ULONG       LastReleaseLine;
#endif

} GPC_LOCK, PGPC_LOCK;

//
//
// states for blobs, patterns and more
//
typedef enum {

    GPC_STATE_READY = 0,
    GPC_STATE_INIT,
    GPC_STATE_ADD,
    GPC_STATE_MODIFY,
    GPC_STATE_REMOVE,   
    GPC_STATE_FORCE_REMOVE,
    GPC_STATE_DELETE,
    GPC_STATE_INVALID,
    GPC_STATE_NOTREADY,
    GPC_STATE_ERROR,
    GPC_STATE_PENDING

} GPC_STATE;


//
// ObjectVerification macro
//
#define VERIFY_OBJECT(_obj, _val) if(_obj) \
        {if(*(GPC_ENUM_OBJECT_TYPE *)_obj!=_val) return STATUS_INVALID_HANDLE;}

//
// define event log error codes
//
#define GPC_ERROR_INIT_MAIN         0x00010000
#define GPC_ERROR_INIT_IOCTL        0x00020000


#define GPC_FLAGS_USERMODE_CLIENT   0x80000000

#define IS_USERMODE_CLIENT(_pc)	\
	TEST_BIT_ON((_pc)->Flags,GPC_FLAGS_USERMODE_CLIENT)


//
// for ioctl
//
#define SHUTDOWN_DELETE_DEVICE          0x00000100
#define SHUTDOWN_DELETE_SYMLINK         0x00000200

//
// helper macros
//
#define TEST_BIT_ON(_v,_b)          (((_v)&(_b))==(_b))
#define TEST_BIT_OFF(_v,_b)         (((_v)&(_b))==0)

#if DBG

#define NDIS_INIT_LOCK(_sl) {\
        NdisAllocateSpinLock(&(_sl)->Lock); \
        TRACE(LOCKS,(_sl),(_sl)->Lock.OldIrql,"LOCK");\
        (_sl)->LockAcquired = -1; \
        strncpy((_sl)->LastAcquireFile, strrchr(__FILE__,'\\')+1, 7); \
        (_sl)->LastAcquireLine = __LINE__; \
        strncpy((_sl)->LastReleaseFile, strrchr(__FILE__,'\\')+1, 7); \
        (_sl)->LastReleaseLine = __LINE__; \
        (_sl)->CurrentIRQL = KeGetCurrentIrql(); \
        (_sl)->CurrentThread = PsGetCurrentThread(); \
}

#define NDIS_LOCK(_sl)  {\
      	NdisAcquireSpinLock(&(_sl)->Lock);\
        TRACE(LOCKS,(_sl),(_sl)->Lock.OldIrql,"LOCK");\
        (_sl)->LockAcquired = TRUE; \
        strncpy((_sl)->LastAcquireFile, strrchr(__FILE__,'\\')+1, 7); \
        (_sl)->LastAcquireLine = __LINE__; \
        (_sl)->CurrentIRQL = KeGetCurrentIrql(); \
        (_sl)->CurrentThread = PsGetCurrentThread(); \
}

#define NDIS_UNLOCK(_sl) {\
        (_sl)->LockAcquired = FALSE; \
        strncpy((_sl)->LastReleaseFile, strrchr(__FILE__,'\\')+1, 7); \
        (_sl)->LastReleaseLine = __LINE__; \
       	TRACE(LOCKS,(_sl),(_sl)->Lock.OldIrql,"UNLOCK");\
        NdisReleaseSpinLock(&(_sl)->Lock);\
}

#define NDIS_DPR_LOCK(_sl) {\
        NdisDprAcquireSpinLock(&(_sl)->Lock);\
		TRACE(LOCKS,(_sl),(_sl)->Lock.OldIrql,"DPR_LOCK");\
		(_sl)->LockAcquired = TRUE; \
        strncpy((_sl)->LastAcquireFile, strrchr(__FILE__,'\\')+1, 7); \
        (_sl)->LastAcquireLine = __LINE__; \
        (_sl)->CurrentIRQL = KeGetCurrentIrql(); \
        (_sl)->CurrentThread = PsGetCurrentThread(); \
}

#define NDIS_DPR_UNLOCK(_sl) {\
        (_sl)->LockAcquired = FALSE; \
        strncpy((_sl)->LastReleaseFile, strrchr(__FILE__,'\\')+1, 7); \
        (_sl)->LastReleaseLine = __LINE__; \
        TRACE(LOCKS,(_sl),(_sl)->Lock.OldIrql,"DPR_UNLOCK");\
        NdisDprReleaseSpinLock(&(_sl)->Lock);\
}

#else

#define NDIS_INIT_LOCK(_sl)      NdisAllocateSpinLock(&(_sl)->Lock)
#define NDIS_LOCK(_sl)           NdisAcquireSpinLock(&(_sl)->Lock)
#define NDIS_UNLOCK(_sl)         NdisReleaseSpinLock(&(_sl)->Lock)
#define NDIS_DPR_LOCK(_sl)       NdisDprAcquireSpinLock(&(_sl)->Lock)
#define NDIS_DPR_UNLOCK(_sl)     NdisDprReleaseSpinLock(&(_sl)->Lock)

#endif

#if DBG && EXTRA_DBG
#define VERIFY_LIST(_l) DbgVerifyList(_l)
#else
#define VERIFY_LIST(_l)
#endif

#define GpcRemoveEntryList(_pl) {PLIST_ENTRY _q = (_pl)->Flink;VERIFY_LIST(_pl);RemoveEntryList(_pl);InitializeListHead(_pl);VERIFY_LIST(_q);}
#define GpcInsertTailList(_l,_e) VERIFY_LIST(_l);InsertTailList(_l,_e);VERIFY_LIST(_e)
#define GpcInsertHeadList(_l,_e) VERIFY_LIST(_l);InsertHeadList(_l,_e);VERIFY_LIST(_e)

#if 0
#define GpcInterlockedInsertTailList(_l,_e,_s) \
	NdisInterlockedInsertTailList(_l,_e,_s)

#else

#define GpcInterlockedInsertTailList(_l,_e,_s) \
	{NDIS_LOCK(_s);VERIFY_LIST(_l);InsertTailList(_l,_e);VERIFY_LIST(_l);NDIS_UNLOCK(_s);}
#endif


#if NEW_MRSW

#define INIT_LOCK				 InitializeMRSWLock
#define READ_LOCK                EnterReader
#define READ_UNLOCK              ExitReader
#define WRITE_LOCK               EnterWriter
#define WRITE_UNLOCK             ExitWriter

#else

#define INIT_LOCK				 InitializeMRSWLock
#define READ_LOCK                AcquireReadLock
#define READ_UNLOCK              ReleaseReadLock
#define WRITE_LOCK               AcquireWriteLock
#define WRITE_UNLOCK             ReleaseWriteLock

#endif

//
// Get the CF index from the client block
//
#define GetCFIndexFromClient(_cl) (((PCLIENT_BLOCK)(_cl))->pCfBlock->AssignedIndex)

//
// Get the client index from the client block
//
#define GetClientIndexFromClient(_cl) (((PCLIENT_BLOCK)(_cl))->AssignedIndex)

//
// return the blob block pointer for the pattern:
// for specific patterns - its the blob entry in the CB
// for generic patterns  - its the pBlobBlock
//
#define GetBlobFromPattern(_p,_i)  (_p)->arpBlobBlock[_i]


//
// return the index bit to the ULONG
//
#define ReleaseClientIndex(_v,_i)  _v&=~(1<<_i) // clear the bit

//
// statistics macros
//
#define StatInc(_m)   (glStat._m)++
#define StatDec(_m)   (glStat._m)--
#define CfStatInc(_cf,_m)   (glStat.CfStat[_cf]._m)++
#define CfStatDec(_cf,_m)   (glStat.CfStat[_cf]._m)--
#define ProtocolStatInc(_p,_m)   (glStat.ProtocolStat[_p]._m)++
#define ProtocolStatDec(_p,_m)   (glStat.ProtocolStat[_p]._m)--

/*
/////////////////////////////////////////////////////////////////
//
//   typedef
//
/////////////////////////////////////////////////////////////////
*/


//
// completion opcodes
//
typedef enum {

    OP_ANY_CFINFO,
    OP_ADD_CFINFO,
    OP_MODIFY_CFINFO,
    OP_REMOVE_CFINFO

} GPC_COMPLETION_OP;


//
// define object type enum for handle verification
//
typedef enum {

    GPC_ENUM_INVALID,
    GPC_ENUM_CLIENT_TYPE,
    GPC_ENUM_CFINFO_TYPE,
    GPC_ENUM_PATTERN_TYPE

} GPC_ENUM_OBJECT_TYPE;


typedef struct _CF_BLOCK CF_BLOCK;
typedef struct _PATTERN_BLOCK PATTERN_BLOCK;


//
// A queued notification structure
//
typedef struct _QUEUED_NOTIFY {

    LIST_ENTRY   			Linkage;
    GPC_NOTIFY_REQUEST_RES	NotifyRes;
	PFILE_OBJECT 			FileObject;

} QUEUED_NOTIFY, *PQUEUED_NOTIFY;


//
// A queued completion structure
//
typedef struct _QUEUED_COMPLETION {

    GPC_COMPLETION_OP	OpCode;			// what completed
    GPC_HANDLE			ClientHandle;
    GPC_HANDLE			CfInfoHandle;
    GPC_STATUS			Status;

} QUEUED_COMPLETION, *PQUEUED_COMPLETION;


//
// A pending IRP structure
//
typedef struct _PENDING_IRP {

    LIST_ENTRY   		Linkage;

    PIRP         		Irp;
	PFILE_OBJECT 		FileObject;
    QUEUED_COMPLETION	QComp;

} PENDING_IRP, *PPENDING_IRP;


#if NEW_MRSW

//
// Multiple Readers Single Write definitions
// code has been taken from (tdi\tcpipmerge\ip\ipmlock.h)
//

typedef struct _MRSW_LOCK 
{
    KSPIN_LOCK rlReadLock;
    KSPIN_LOCK rlWriteLock;
    LONG       lReaderCount;
} MRSW_LOCK, *PMRSW_LOCK;

#else

//
// Multiple Readers Single Write definitions
// code has been taken from the filter driver project (routing\ip\fltrdrvr)
//

typedef struct _MRSW_LOCK 
{
    KSPIN_LOCK      SpinLock;
    LONG            ReaderCount;
} MRSW_LOCK, *PMRSW_LOCK;

#endif


//
// The generic pattern database struct
//
typedef struct _GENERIC_PATTERN_DB {

    MRSW_LOCK	Lock;
    Rhizome	   *pRhizome;     // pointer to a Rhizome

} GENERIC_PATTERN_DB, *PGENERIC_PATTERN_DB;



//
// A client block is used to store specific client context
//
typedef struct _CLIENT_BLOCK {

    //
    // !!! MUST BE FIRST FIELD !!!
    //
    GPC_ENUM_OBJECT_TYPE	ObjectType;

    LIST_ENTRY				ClientLinkage; // client blocks list link
	LIST_ENTRY				BlobList;     // list of blobs of the client

    CF_BLOCK		   	   *pCfBlock;
    GPC_CLIENT_HANDLE		ClientCtx;
    ULONG					AssignedIndex;
    ULONG					Flags;
    ULONG					State;
    GPC_LOCK			    Lock;
    REF_CNT                 RefCount;
    PFILE_OBJECT			pFileObject;	// used for async completion
    GPC_HANDLE				ClHandle;		// handle returned to the client
    GPC_CLIENT_FUNC_LIST	FuncList;

} CLIENT_BLOCK, *PCLIENT_BLOCK;


//
// A blob (A.K.A CF_INFO) block holds a GPC header + client specific data
//
typedef struct _BLOB_BLOCK {

    //
    // !!! MUST BE FIRST FIELD !!!
    //
    GPC_ENUM_OBJECT_TYPE	ObjectType;

	LIST_ENTRY				ClientLinkage;   // linked on the client
	LIST_ENTRY				PatternList;     // head of pattern linked list
    LIST_ENTRY				CfLinkage;		 // blobs on the CF

    //PCLIENT_BLOCK			pClientBlock;	 // pointer to installer
    REF_CNT					RefCount;
    GPC_STATE				State;
    ULONG					Flags;
    GPC_CLIENT_HANDLE		arClientCtx[MAX_CLIENTS_CTX_PER_BLOB];
    ULONG                   ClientStatusCountDown;
    GPC_STATUS              LastStatus;
    GPC_LOCK                Lock;
    CTEBlockStruc			WaitBlockAddFailed;
    PCLIENT_BLOCK			arpClientStatus[MAX_CLIENTS_CTX_PER_BLOB];
    ULONG					ClientDataSize;
    PVOID					pClientData;
    ULONG					NewClientDataSize;
    PVOID					pNewClientData;
    PCLIENT_BLOCK			pOwnerClient;
    PCLIENT_BLOCK			pCallingClient;
    PCLIENT_BLOCK			pCallingClient2;
    HANDLE					OwnerClientHandle;
    GPC_CLIENT_HANDLE		OwnerClientCtx;
    GPC_HANDLE				ClHandle;	// handle returned to the client

    //
    // assume only one client can accept the flow
    //
    PCLIENT_BLOCK			pNotifiedClient;
    GPC_CLIENT_HANDLE		NotifiedClientCtx;

#if NO_USER_PENDING
    CTEBlockStruc			WaitBlock;
#endif

} BLOB_BLOCK, *PBLOB_BLOCK;

//
// The classification block is an array of blob pointers
//
typedef struct _CLASSIFICATION_BLOCK {

    REF_CNT         RefCount;
    ULONG			NumberOfElements;
    HFHandle		ClassificationHandle;  // how to get back to index tbl

    // must be last
    PBLOB_BLOCK		arpBlobBlock[1];

} CLASSIFICATION_BLOCK, *PCLASSIFICATION_BLOCK;

//
// A pattern block holds specific data for the pattern
//
typedef struct _PATTERN_BLOCK {

    //
    // !!! MUST BE FIRST FIELD !!!
    //
    GPC_ENUM_OBJECT_TYPE	ObjectType;
    GPC_STATE               State;

    LIST_ENTRY				BlobLinkage[GPC_CF_MAX]; // linked on the blob
    LIST_ENTRY				TimerLinkage;

    PBLOB_BLOCK				arpBlobBlock[GPC_CF_MAX];
    PCLIENT_BLOCK		    pClientBlock;
    PCLIENT_BLOCK		    pAutoClient;
    PCLASSIFICATION_BLOCK	pClassificationBlock;
    ULONG                   WheelIndex;
    REF_CNT					RefCount;
    ULONG					ClientRefCount;
    ULONG					TimeToLive;				// for internal patterns
    ULONG					Flags;
    ULONG                   Priority;	// for generic pattern
    PVOID					DbCtx;
    GPC_LOCK                Lock;
    GPC_HANDLE				ClHandle;	// handle returned to the client
    ULONG					ProtocolTemplate;

} PATTERN_BLOCK, *PPATTERN_BLOCK;


//
// A CF block struct. This would construct a linked list of Cf blocks.
//
typedef struct _CF_BLOCK {

    REF_CNT                 RefCount;
    LIST_ENTRY				Linkage;		// on the global list
    LIST_ENTRY				ClientList;		// for the client blocks
    LIST_ENTRY				BlobList;		// list of blobs

    ULONG					NumberOfClients;
    ULONG					AssignedIndex;
    ULONG					ClientIndexes;
    GPC_LOCK			    Lock;
  	//MRSW_LOCK		   		ClientSync;
  	GPC_LOCK	   	        ClientSync;
    ULONG					MaxPriorities;
    PGENERIC_PATTERN_DB		arpGenericDb[GPC_PROTOCOL_TEMPLATE_MAX];

} CF_BLOCK, *PCF_BLOCK;


typedef struct _SPECIFIC_PATTERN_DB {

    MRSW_LOCK	   Lock;
    PatHashTable   *pDb;

} SPECIFIC_PATTERN_DB, *PSPECIFIC_PATTERN_DB;


typedef struct _FRAGMENT_DB {

    MRSW_LOCK   	Lock;
    PatHashTable   *pDb;

} FRAGMENT_DB, *PFRAGMENT_DB;


//
// A context structure to pass to the pathash scan routine
//
typedef struct _SCAN_STRUCT {

    PCLIENT_BLOCK	pClientBlock;
    PPATTERN_BLOCK	pPatternBlock;
    PBLOB_BLOCK		pBlobBlock;
    ULONG			Priority;
    BOOLEAN         bRemove;

} SCAN_STRUCT, *PSCAN_STRUCT;


//
// A protocol block holds pointers to databases for a specific 
// protocol template
//
typedef struct _PROTOCOL_BLOCK {

    LIST_ENTRY                      TimerPatternList[NUMBER_OF_WHEELS];
    ULONG                           CurrentWheelIndex;
    ULONG							SpecificPatternCount;
    ULONG                           GenericPatternCount;
    ULONG							AutoSpecificPatternCount;
    ULONG							ProtocolTemplate;
    ULONG							PatternSize;
    SPECIFIC_PATTERN_DB				SpecificDb;
    PVOID                           pProtocolDb;	// fragments
    GPC_LOCK					    PatternTimerLock[NUMBER_OF_WHEELS];
    NDIS_TIMER						PatternTimer;

} PROTOCOL_BLOCK, *PPROTOCOL_BLOCK;


//
// Global data block
//
typedef struct _GLOBAL_BLOCK {

    LIST_ENTRY			CfList;		// CF list head
    LIST_ENTRY          gRequestList; // Maintain a request list to deal with contention...
    GPC_LOCK		    Lock;
    GPC_LOCK		    RequestListLock;
    HandleFactory		*pCHTable;
    MRSW_LOCK	   		ChLock;		// lock for pCHTable
    PPROTOCOL_BLOCK		pProtocols;	// pointer to array of supported protocols

} GLOBAL_BLOCK, *PGLOBAL_BLOCK;

//
// New request block. This will be used to store the event and linkage.
// Therefore, when a thread needs to block, allocate a request_block, allocate
// an event, grab the requestlist lock , put this on the list and wait.
//
typedef struct _REQUEST_BLOCK {

    LIST_ENTRY              Linkage;
    NDIS_EVENT              RequestEvent;

}   REQUEST_BLOCK, *PREQUEST_BLOCK;

#if NEW_MRSW

//
// VOID
// InitRwLock(
//  PMRSW_LOCK    pLock
//  )
//
//  Initializes the spin locks and the reader count
//

#define InitializeMRSWLock(l) {                                 \
    KeInitializeSpinLock(&((l)->rlReadLock));                   \
    KeInitializeSpinLock(&((l)->rlWriteLock));                  \
    (l)->lReaderCount = 0;                                      \
}


//
// VOID
// EnterReader(
//  PMRSW_LOCK    pLock,
//  PKIRQL        pCurrIrql 
//  )
//
// Acquires the Reader Spinlock (now thread is at DPC). 
// InterlockedIncrements the reader count (interlocked because the reader 
// lock is not taken when the count is decremented in ExitReader())
// If the thread is the first reader, also acquires the Writer Spinlock (at
// DPC to be more efficient) to block writers
// Releases the Reader Spinlock from DPC, so that it remains at DPC
// for the duration of the lock being held 
//
// If a writer is in the code, the first reader will wait on the Writer
// Spinlock and all subsequent readers will wait on the Reader Spinlock
// If a reader is in the code and is executing the EnterReader, then a new
// reader will wait for sometime on the Reader Spinlock, and then proceed
// on to the code (at DPC)
//
#define EnterReader(l, q) {\
    KeAcquireSpinLock(&((l)->rlReadLock), (q));                 \
    TRACE(LOCKS,l,*q,"EnterReader");                            \
    if(InterlockedIncrement(&((l)->lReaderCount)) == 1) {       \
        TRACE(LOCKS,l,(l)->lReaderCount,"EnterReader1");        \
        KeAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));       \
        TRACE(LOCKS,l,(l)->rlWriteLock,"EnterReader2");         \
    }                                                           \
    TRACE(LOCKS,l,(l)->lReaderCount,"EnterReader3");            \
    KeReleaseSpinLockFromDpcLevel(&((l)->rlReadLock));          \
}

#define EnterReaderAtDpcLevel(l) {\
    KeAcquireSpinLockAtDpcLevel(&((l)->rlReadLock));            \
    if(InterlockedIncrement(&((l)->lReaderCount)) == 1)         \
        KeAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));       \
    KeReleaseSpinLockFromDpcLevel(&((l)->rlReadLock));          \
}

//
// VOID
// ExitReader(
//  PMRSW_LOCK    pLock,
//  KIRQL         kiOldIrql
//  )
//
// InterlockedDec the reader count.
// If this is the last reader, then release the Writer Spinlock to let
// other writers in
// Otherwise, just lower the irql to what was before the lock was
// acquired.  Either way, the irql is down to original irql
//

#define ExitReader(l, q) {\
    TRACE(LOCKS,l,q,"ExitReader");\
    if(InterlockedDecrement(&((l)->lReaderCount)) == 0) {       \
        TRACE(LOCKS,(l)->rlWriteLock,q,"ExitReader1");          \
        KeReleaseSpinLock(&((l)->rlWriteLock), q);              \
    }                                                           \
    else {                                                      \
        TRACE(LOCKS,l,(l)->lReaderCount,"ExitReader2");         \
        KeLowerIrql(q);                                         \
    }                                                           \
}

#define ExitReaderFromDpcLevel(l) {\
    if(InterlockedDecrement(&((l)->lReaderCount)) == 0)         \
        KeReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock));     \
}

//
// EnterWriter(
//  PMRSW_LOCK    pLock,
//  PKIRQL        pCurrIrql
//  )
//
// Acquire the reader and then the writer spin lock
// If there  are readers in the code, the first writer will wait
// on the Writer Spinlock.  All other writers will wait (with readers)
// on the Reader Spinlock
// If there is a writer in the code then a new writer will wait on 
// the Reader Spinlock

#define EnterWriter(l, q) {\
    KeAcquireSpinLock(&((l)->rlReadLock), (q));                 \
    TRACE(LOCKS,l,*q,"EnterWriter");                            \
    TRACE(LOCKS,l,(l)->rlWriteLock,"EnterWrite1");              \
    KeAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));           \
}

#define EnterWriterAtDpcLevel(l) {                              \
    KeAcquireSpinLockAtDpcLevel(&((l)->rlReadLock));            \
    KeAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));           \
}


//
// ExitWriter(
//  PMRSW_LOCK    pLock,
//  KIRQL       kiOldIrql
//  )
//
// Release both the locks
//

#define ExitWriter(l, q) {\
    TRACE(LOCKS,l,(l)->rlWriteLock,"ExitWrite1");               \
    KeReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock));         \
    TRACE(LOCKS,l,q,"ExitWrite1");                              \
    KeReleaseSpinLock(&((l)->rlReadLock), q);                   \
}


#define ExitWriterFromDpcLevel(l) {\
    KeReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock));         \
    KeReleaseSpinLockFromDpcLevel(&((l)->rlReadLock));          \
}

#else

#define InitializeMRSWLock(_pLock) {                       \
    (_pLock)->ReaderCount =    0;                          \
    KeInitializeSpinLock(&((_pLock)->SpinLock));           \
}

#define AcquireReadLock(_pLock,_pOldIrql) {                \
	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "RL.1");   \
    KeAcquireSpinLock(&((_pLock)->SpinLock),_pOldIrql);    \
    InterlockedIncrement(&((_pLock)->ReaderCount));        \
	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "RL.2");   \
    KeReleaseSpinLockFromDpcLevel(&((_pLock)->SpinLock));  \
	TRACE(LOCKS, _pLock, *(_pOldIrql), "RL.3");            \
}

#define ReleaseReadLock(_pLock,_OldIrql) {                 \
	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "RU.1");   \
    InterlockedDecrement(&((_pLock)->ReaderCount));        \
	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "RU.2");   \
    KeLowerIrql(_OldIrql);                                 \
	TRACE(LOCKS, _pLock, _OldIrql, "RU.3");                \
}

#define AcquireWriteLock(_pLock,_pOldIrql) {               \
	TRACE(LOCKS, _pLock, _pOldIrql, "WL.1");               \
    KeAcquireSpinLock(&((_pLock)->SpinLock),_pOldIrql);    \
	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "WL.2");   \
    while(InterlockedDecrement(&((_pLock)->ReaderCount))>=0)\
    {                                                      \
        InterlockedIncrement (&((_pLock)->ReaderCount));   \
    }                                                      \
	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "WL.3");   \
}

#define ReleaseWriteLock(_pLock,_OldIrql) {                \
 	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "WU.1");   \
    InterlockedExchange(&(_pLock)->ReaderCount,0);         \
 	TRACE(LOCKS, _pLock, (_pLock)->ReaderCount, "WU.2");   \
    KeReleaseSpinLock(&((_pLock)->SpinLock),_OldIrql);     \
 	TRACE(LOCKS, _pLock, _OldIrql, "WU.3");                \
}

#endif

#if 1

#define RSC_READ_LOCK(_l,_i)		NDIS_LOCK(_l)
#define RSC_READ_UNLOCK(_l,_i)		NDIS_UNLOCK(_l)
#define RSC_WRITE_LOCK(_l,_i)		NDIS_LOCK(_l)
#define RSC_WRITE_UNLOCK(_l,_i)		NDIS_UNLOCK(_l)

#else

#define RSC_READ_LOCK		WRITE_LOCK
#define RSC_READ_UNLOCK		WRITE_UNLOCK
#define RSC_WRITE_LOCK		WRITE_LOCK
#define RSC_WRITE_UNLOCK	WRITE_UNLOCK

#endif

/*
/////////////////////////////////////////////////////////////////
//
//   IP definitions
//
/////////////////////////////////////////////////////////////////
*/

#define	DEFAULT_VERLEN		0x45		// Default version and length.
#define	IP_VERSION			0x40
#define	IP_VER_FLAG			0xF0
#define	IP_RSVD_FLAG		0x0080		// Reserved.
#define	IP_DF_FLAG			0x0040		// 'Don't fragment' flag
#define	IP_MF_FLAG			0x0020		// 'More fragments flag'
#define	IP_OFFSET_MASK		~0x00E0		// Mask for extracting offset field.

#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define net_short(_x) _byteswap_ushort((USHORT)(_x))
#define net_long(_x)  _byteswap_ulong(_x)
#else
#define net_short(x) ((((x)&0xff) << 8) | (((x)&0xff00) >> 8))
#define net_long(x) (((((ulong)(x))&0xffL)<<24) | \
                     ((((ulong)(x))&0xff00L)<<8) | \
                     ((((ulong)(x))&0xff0000L)>>8) | \
                     ((((ulong)(x))&0xff000000L)>>24))
#endif
/*
 * Protocols (from winsock.h)
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */
#define IPPROTO_IPSEC			51              /* ???????? */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

// 
// UDP header definition
//
typedef struct _UDP_HEADER {
    ushort          uh_src;
    ushort          uh_dest;
    ushort          uh_length;
    ushort          uh_xsum;
} UDP_HEADER, *PUDP_HEADER;


//
//*	IP Header format.
//
typedef struct _IP_HEADER {

	uchar		iph_verlen;				// Version and length.
	uchar		iph_tos;				// Type of service.
	ushort		iph_length;				// Total length of datagram.
	ushort		iph_id;					// Identification.
	ushort		iph_offset;				// Flags and fragment offset.
	uchar		iph_ttl;				// Time to live.
	uchar		iph_protocol;			// Protocol.
	ushort		iph_xsum;				// Header checksum.
	ULONG		iph_src;				// Source address.
	ULONG		iph_dest;				// Destination address.

} IP_HEADER, *PIP_HEADER;


//
// Definition of the IPX header.
//
typedef struct _IPX_HEADER {

    USHORT 	CheckSum;
    UCHAR 	PacketLength[2];
    UCHAR 	TransportControl;
    UCHAR 	PacketType;
    UCHAR 	DestinationNetwork[4];
    UCHAR 	DestinationNode[6];
    USHORT 	DestinationSocket;
    UCHAR 	SourceNetwork[4];
    UCHAR 	SourceNode[6];
    USHORT 	SourceSocket;

} IPX_HEADER, *PIPX_HEADER;


/*
/////////////////////////////////////////////////////////////////
//
//   extern
//
/////////////////////////////////////////////////////////////////
*/

extern GLOBAL_BLOCK 		glData;
extern GPC_STAT       		glStat;

#ifdef STANDALONE_DRIVER
extern GPC_EXPORTED_CALLS  	glGpcExportedCalls;
#endif

// tags

extern ULONG					ClassificationFamilyTag;
extern ULONG					ClientTag;
extern ULONG					PatternTag;
extern ULONG					CfInfoTag;
extern ULONG					QueuedNotificationTag;
extern ULONG					PendingIrpTag;

extern ULONG					HandleFactoryTag;
extern ULONG					PathHashTag;
extern ULONG					RhizomeTag;
extern ULONG					GenPatternDbTag;
extern ULONG					FragmentDbTag;
extern ULONG					CfInfoDataTag;
extern ULONG					ClassificationBlockTag;
extern ULONG					ProtocolTag;
extern ULONG					DebugTag;

// Lookaside lists

extern NPAGED_LOOKASIDE_LIST	ClassificationFamilyLL;
extern NPAGED_LOOKASIDE_LIST	ClientLL;
extern NPAGED_LOOKASIDE_LIST	PatternLL;
extern NPAGED_LOOKASIDE_LIST	CfInfoLL;
extern NPAGED_LOOKASIDE_LIST	QueuedNotificationLL;
extern NPAGED_LOOKASIDE_LIST	PendingIrpLL;

/*
/////////////////////////////////////////////////////////////////
//
//   prototypes
//
/////////////////////////////////////////////////////////////////
*/


NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


GPC_STATUS
InitSpecificPatternDb(
    IN	PSPECIFIC_PATTERN_DB	pDb,
    IN  ULONG					PatternSize
    );

GPC_STATUS
UninitSpecificPatternDb(
    IN	PSPECIFIC_PATTERN_DB	pDb
    );

GPC_STATUS
InitClassificationHandleTbl(
	IN	HandleFactory **ppCHTable
);

VOID
UninitClassificationHandleTbl(
	IN	HandleFactory *pCHTable
);
GPC_STATUS
InitializeGenericDb(
	IN  PGENERIC_PATTERN_DB	*ppGenericDb,
    IN  ULONG				 NumEntries,
    IN  ULONG				 PatternSize
);

VOID
UninitializeGenericDb(
	IN  PGENERIC_PATTERN_DB	*ppGenericDb,
    IN  ULONG				 NumEntries
    );

PCLIENT_BLOCK
CreateNewClientBlock(VOID);

VOID
ReleaseCfBlock(
	IN  PCF_BLOCK	pCf
    );

PCF_BLOCK
CreateNewCfBlock(
	IN	ULONG			CfId,
    IN	ULONG			MaxPriorities
    );

VOID
ReleaseClientBlock(
	IN  PCLIENT_BLOCK	pClientBlock
    );

PPATTERN_BLOCK
CreateNewPatternBlock(
	IN  ULONG	Flags
    );

VOID
ReleasePatternBlock(
	IN  PPATTERN_BLOCK	pPatternBlock
    );

PCLASSIFICATION_BLOCK
CreateNewClassificationBlock(
	IN  ULONG	NumEntries
    );

ULONG
AssignNewClientIndex(
	IN PCF_BLOCK	pCfBlock
    );

GPC_STATUS
AddGenericPattern(
	IN  PCLIENT_BLOCK		pClient,
    IN  PUCHAR				pPatternBits,
    IN  PUCHAR				pMaskBits,
    IN  ULONG				Priority,
    IN  PBLOB_BLOCK			pBlob,
    IN  PPROTOCOL_BLOCK		pProtocol,
    IN OUT PPATTERN_BLOCK	*ppPattern
    );


GPC_STATUS
AddSpecificPattern(
	IN  PCLIENT_BLOCK			pClient,
    IN  PUCHAR					pPatternBits,
    IN  PUCHAR					pMaskBits,
    IN  PBLOB_BLOCK				pBlob,
    IN  PPROTOCOL_BLOCK			pProtocol,
    IN OUT PPATTERN_BLOCK		*ppPattern,
    OUT PCLASSIFICATION_HANDLE	pCH
    );

ULONG
GpcCalcHash(
	IN	ULONG				ProtocolTempId,
    IN	PUCHAR				pPattern
    );


VOID
DereferencePattern(
	IN  PPATTERN_BLOCK		pPattern
    );

VOID
DereferenceBlob(
	IN  PBLOB_BLOCK			pBlob
    );

PBLOB_BLOCK
CreateNewBlobBlock(
    IN  ULONG				ClientDataSize,
    IN  PVOID				pClientData
    );

VOID
ReleaseBlobBlock(
    IN  PBLOB_BLOCK			pBlobBlock
    );

GPC_STATUS
HandleFragment(
	IN  PCLIENT_BLOCK		pClientBlock,
    IN  PPROTOCOL_BLOCK		pProtocol,
    IN  BOOLEAN             bFirstFrag,
    IN  BOOLEAN             bLastFrag,
    IN  ULONG				PacketId,
    IN OUT PPATTERN_BLOCK   *ppPatternBlock,
    OUT PBLOB_BLOCK			*ppBlob
    );

NTSTATUS
InternalSearchPattern(
	IN  PCLIENT_BLOCK			pClientBlock,
    IN  PPROTOCOL_BLOCK			pProtocol,
    IN  PVOID					pPatternKey,
    OUT PPATTERN_BLOCK          *ppPatternBlock,
    OUT	PCLASSIFICATION_HANDLE  pClassificationHandle,
    IN  BOOLEAN					bNoCache
    );

GPC_STATUS
InitFragmentDb(
	IN  PFRAGMENT_DB   *ppFragDb
    );

GPC_STATUS
UninitFragmentDb(
               IN  PFRAGMENT_DB   pFragDb
);

VOID
DereferenceClient(
	IN  PCLIENT_BLOCK	pClient
    );


GPC_STATUS
ClientAddCfInfo(
	IN	PCLIENT_BLOCK			pClient,
    IN  PBLOB_BLOCK             pBlob,
    OUT	PGPC_CLIENT_HANDLE      pClientCfInfoContext
    );
  
VOID
ClientAddCfInfoComplete(
	IN	PCLIENT_BLOCK			pClient,
    IN	PBLOB_BLOCK             pBlob,
    IN	GPC_STATUS				Status
    );

GPC_STATUS
ClientModifyCfInfo(
	IN	PCLIENT_BLOCK			pClient,
    IN  PBLOB_BLOCK             pBlob,
    IN  ULONG                   CfInfoSize,
    IN  PVOID                   pClientData
    );

VOID
ClientModifyCfInfoComplete(
	IN	PCLIENT_BLOCK			pClient,
    IN	PBLOB_BLOCK             pBlob,
    IN	GPC_STATUS	        	Status
    );

GPC_STATUS
ClientRemoveCfInfo(
	IN	PCLIENT_BLOCK			pClient,
    IN  PBLOB_BLOCK             pBlob,
    IN	GPC_CLIENT_HANDLE		ClientCfInfoContext
    );

VOID
ClientRemoveCfInfoComplete(
	IN	PCLIENT_BLOCK		pClient,
    IN	PBLOB_BLOCK         pBlob,
    IN	GPC_STATUS			Status
    );

GPC_STATUS
RemoveSpecificPattern(
	IN  PCLIENT_BLOCK		pClient,
    IN  PPROTOCOL_BLOCK		pProtocol,
    IN  PPATTERN_BLOCK		pPattern,
    IN  BOOLEAN             ForceRemoval
    );

VOID
ClientRefsExistForSpecificPattern(
                      IN  PCLIENT_BLOCK			pClient,
                      IN  PPROTOCOL_BLOCK		pProtocol,
                      IN  PPATTERN_BLOCK		pPattern
                      );

VOID
ReadySpecificPatternForDeletion(
                                IN  PCLIENT_BLOCK	    pClient,
                                IN  PPROTOCOL_BLOCK		pProtocol,
                                IN  PPATTERN_BLOCK		pPattern
                                );

GPC_STATUS
RemoveGenericPattern(
	IN  PCLIENT_BLOCK		pClient,
    IN  PPROTOCOL_BLOCK		pProtocol,
    IN  PPATTERN_BLOCK		pPattern
    );

VOID
ReleaseClassificationBlock(
	IN  PCLASSIFICATION_BLOCK	pClassificationBlock
    );

VOID
ClearPatternLinks(
	IN  PPATTERN_BLOCK        	pPattern,
    IN  PPROTOCOL_BLOCK			pProtocol,
    IN  ULONG                 	CfIndex
    );

VOID
ModifyCompleteClients(
	IN  PCLIENT_BLOCK   		pClient,
    IN  PBLOB_BLOCK     		pBlob
    );

//CLASSIFICATION_HANDLE
//GetClassificationHandle(
//	IN  PCLIENT_BLOCK   		pClient, 
//    IN  PPATTERN_BLOCK  		pPattern
//    );

VOID
FreeClassificationHandle(
	IN  PCLIENT_BLOCK          pClient,
    IN  CLASSIFICATION_HANDLE  CH
    );

GPC_STATUS
CleanupBlobs(
	IN  PCLIENT_BLOCK     		pClient
    );


#ifdef STANDALONE_DRIVER
/*
/////////////////////////////////////////////////////////////////
//
// GPC inetrface APIs
//
/////////////////////////////////////////////////////////////////
*/


GPC_STATUS
GpcGetCfInfoClientContext(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    OUT PGPC_CLIENT_HANDLE      pClientCfInfoContext
    );

GPC_CLIENT_HANDLE
GpcGetCfInfoClientContextWithRef(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    IN  ULONG                   Offset
    );

GPC_STATUS
GpcGetUlongFromCfInfo(
    IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    IN  ULONG					Offset,
    IN	PULONG					pValue
    );

GPC_STATUS
GpcRegisterClient(
    IN	ULONG					CfId,
	IN	ULONG					Flags,
    IN  ULONG					MaxPriorities,
	IN	PGPC_CLIENT_FUNC_LIST	pClientFuncList,
	IN	GPC_CLIENT_HANDLE		ClientContext,
	OUT	PGPC_HANDLE				pClientHandle
    );

GPC_STATUS
GpcDeregisterClient(
	IN	GPC_HANDLE				ClientHandle
    );

GPC_STATUS
GpcAddCfInfo(
	IN	GPC_HANDLE				ClientHandle,
    IN  ULONG					CfInfoSize,
	IN	PVOID					pClientCfInfo,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
	OUT	PGPC_HANDLE	    		pGpcCfInfoHandle
    );

GPC_STATUS
GpcAddPattern(
	IN	GPC_HANDLE				ClientHandle,
	IN	ULONG					ProtocolTemplate,
	IN	PVOID					Pattern,
	IN	PVOID					Mask,
	IN	ULONG					Priority,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	OUT	PGPC_HANDLE				pGpcPatternHandle,
	OUT	PCLASSIFICATION_HANDLE  pClassificationHandle
    );

VOID
GpcAddCfInfoNotifyComplete(
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	IN	GPC_STATUS				Status,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext
    );

GPC_STATUS
GpcModifyCfInfo (
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE	    		GpcCfInfoHandle,
    IN	ULONG					CfInfoSize,
	IN  PVOID	    			pClientCfInfo
    );

VOID
GpcModifyCfInfoNotifyComplete(
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	IN	GPC_STATUS				Status
    );

GPC_STATUS
GpcRemoveCfInfo (
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle
    );

VOID
GpcRemoveCfInfoNotifyComplete(
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	IN	GPC_STATUS				Status
    );

GPC_STATUS
GpcRemovePattern (
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcPatternHandle
    );

GPC_STATUS
GpcClassifyPattern (
	IN	GPC_HANDLE				ClientHandle,
	IN	ULONG					ProtocolTemplate,
	IN	PVOID			        pPattern,
	OUT	PGPC_CLIENT_HANDLE		pClientCfInfoContext,
	IN OUT	PCLASSIFICATION_HANDLE	pClassificationHandle,
    IN		ULONG				Offset,
    IN		PULONG				pValue,
    IN		BOOLEAN				bNoCache
    );

GPC_STATUS
GpcClassifyPacket (
	IN	GPC_HANDLE				ClientHandle,
	IN	ULONG					ProtocolTemplate,
	IN	PVOID					pNdisPacket,
	IN	ULONG					TransportHeaderOffset,
    IN  PTC_INTERFACE_ID		InterfaceId,
	OUT	PGPC_CLIENT_HANDLE		pClientCfInfoContext,
	OUT	PCLASSIFICATION_HANDLE	pClassificationHandle
    );

GPC_STATUS
GpcEnumCfInfo (
	IN		GPC_HANDLE				ClientHandle,
    IN OUT 	PHANDLE					pCfInfoHandle,
    OUT    PHANDLE					pCfInfoMapHandle,
    IN OUT 	PULONG					pCfInfoCount,
    IN OUT 	PULONG					pBufferSize,
    OUT 	PGPC_ENUM_CFINFO_BUFFER	Buffer
    );

#endif // STANDALONE_DRIVER

GPC_STATUS
GetClientCtxAndUlongFromCfInfo(
	IN	GPC_HANDLE				ClientHandle,
    IN	OUT PCLASSIFICATION_HANDLE	pClassificationHandle,
    OUT PGPC_CLIENT_HANDLE		pClientCfInfoContext,
    IN	ULONG					Offset,
    IN	PULONG					pValue
    );

GPC_STATUS
privateGpcRemoveCfInfo(
	IN	GPC_HANDLE				ClientHandle,
    IN	GPC_HANDLE				GpcCfInfoHandle,
    IN   ULONG					Flags
    );

GPC_STATUS
privateGpcRemovePattern(
	IN	GPC_HANDLE		ClientHandle,
    IN	GPC_HANDLE		GpcPatternHandle,
    IN  BOOLEAN         ForceRemoval
    );

VOID
UMClientRemoveCfInfoNotify(
	IN	PCLIENT_BLOCK			pClient,
    IN	PBLOB_BLOCK				pBlob
    );


VOID
UMCfInfoComplete(
	IN	GPC_COMPLETION_OP		OpCode,
	IN	PCLIENT_BLOCK			pClient,
    IN	PBLOB_BLOCK             pBlob,
    IN	GPC_STATUS				Status
    );

VOID
CloseAllObjects(
	IN	PFILE_OBJECT			FileObject,
    IN  PIRP					Irp
    );

NTSTATUS
IoctlInitialize(
    IN	PDRIVER_OBJECT DriverObject,
    IN	PULONG         InitShutdownMask
    );

NTSTATUS
CheckQueuedNotification(
	IN		PIRP	Irp,
    IN OUT  ULONG 	*outputBufferLength
    );

NTSTATUS
CheckQueuedCompletion(
	IN PQUEUED_COMPLETION		pQItem,
    IN PIRP              		Irp
    );

VOID
PatternTimerExpired(
	IN	PVOID					SystemSpecific1,
	IN	PVOID					FunctionContext,
	IN	PVOID					SystemSpecific2,
	IN	PVOID					SystemSpecific3
    );

GPC_STATUS
AddSpecificPatternWithTimer(
	IN	PCLIENT_BLOCK			pClient,
    IN	ULONG					ProtocolTemplate,
    IN	PVOID					PatternKey,
    OUT	PPATTERN_BLOCK			*ppPattern,
    OUT	PCLASSIFICATION_HANDLE  pClassificationHandle
    );

NTSTATUS
InitPatternTimer(
	IN	ULONG	ProtocolTemplate
    );


#endif // __GPCDEF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\gpcmain.c ===
/*
************************************************************************

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    gpcmain.c

Abstract:

    This file contains initialization stuff for the GPC
    and all the exposed APIs

Author:

    Ofer Bar - April 15, 1997

Environment:

    Kernel mode

Revision History:


************************************************************************
*/

#include "gpcpre.h"


/*
/////////////////////////////////////////////////////////////////
//
//   globals
//
/////////////////////////////////////////////////////////////////
*/

NDIS_STRING 	DriverName = NDIS_STRING_CONST( "\\Device\\Gpc" );
GLOBAL_BLOCK    glData;

GPC_STAT        glStat;
static          _init_driver = FALSE;
ULONG			GpcMinorVersion = 0;

#ifdef STANDALONE_DRIVER
GPC_EXPORTED_CALLS			glGpcExportedCalls;
#endif

#if DBG
CHAR VersionTimestamp[] = __DATE__ " " __TIME__;
#endif

// tags

ULONG					QueuedNotificationTag = 'nqpQ';
ULONG					PendingIrpTag = 'ippQ';
ULONG					CfInfoTag = 'icpQ';
ULONG					ClientTag = 'tcpQ';
ULONG					PatternTag = 'appQ';

ULONG					HandleFactoryTag = 'fhpQ';	// Gphf
ULONG					PathHashTag = 'hppQ';
ULONG					RhizomeTag = 'zrpQ';
ULONG					GenPatternDbTag = 'dppQ';
ULONG					FragmentDbTag = 'dfpQ';
ULONG					ClassificationFamilyTag = 'fcpQ';
ULONG					CfInfoDataTag = 'dcpQ';
ULONG					ClassificationBlockTag = 'bcpQ';
ULONG					ProtocolTag = 'tppQ';
ULONG					DebugTag = 'gdpQ';
ULONG                   RequestBlockTag = 'brpQ';

// Lookaside lists

NPAGED_LOOKASIDE_LIST	ClassificationFamilyLL;
NPAGED_LOOKASIDE_LIST	ClientLL;
NPAGED_LOOKASIDE_LIST	PatternLL;
NPAGED_LOOKASIDE_LIST	CfInfoLL;
NPAGED_LOOKASIDE_LIST	QueuedNotificationLL;
NPAGED_LOOKASIDE_LIST	PendingIrpLL;

ULONG 					ClassificationFamilyLLSize = sizeof( CF_BLOCK );
ULONG 					ClientLLSize = sizeof( CLIENT_BLOCK );
ULONG 					PatternLLSize = sizeof( PATTERN_BLOCK );
ULONG 					CfInfoLLSize = sizeof( BLOB_BLOCK );
ULONG 					QueuedNotificationLLSize = sizeof( QUEUED_NOTIFY );
ULONG 					PendingIrpLLSize = sizeof( PENDING_IRP );

/*
/////////////////////////////////////////////////////////////////
//
//   pragma
//
/////////////////////////////////////////////////////////////////
*/


//#pragma NDIS_INIT_FUNCTION(DriverEntry)

#if 0
#pragma NDIS_PAGEABLE_FUNCTION(DriverEntry)
#pragma NDIS_PAGEABLE_FUNCTION(GpcRegisterClient)
#pragma NDIS_PAGEABLE_FUNCTION(GpcDeregisterClient)
#pragma NDIS_PAGEABLE_FUNCTION(GpcAddCfInfo)
#pragma NDIS_PAGEABLE_FUNCTION(GpcAddPattern)
#pragma NDIS_PAGEABLE_FUNCTION(GpcAddCfInfoNotifyComplete)
#pragma NDIS_PAGEABLE_FUNCTION(GpcModifyCfInfo)
#pragma NDIS_PAGEABLE_FUNCTION(GpcModifyCfInfoNotifyComplete)
#pragma NDIS_PAGEABLE_FUNCTION(GpcRemoveCfInfo)
#pragma NDIS_PAGEABLE_FUNCTION(GpcRemoveCfInfoNotifyComplete)
#pragma NDIS_PAGEABLE_FUNCTION(GpcRemovePattern)
#endif

/*
/////////////////////////////////////////////////////////////////
//
//   prototypes
//
/////////////////////////////////////////////////////////////////
*/

#if DBG
NTSTATUS
InitializeLog();

VOID
FreeDebugLog(
    VOID);

#endif

VOID
GpcUnload (
    IN PDRIVER_OBJECT DriverObject
    );

/*
************************************************************************

InitGpc - 

The initialization routine. It is getting called during load time
and is responsible to call other initialization code.

Arguments
	none

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
InitGpc(void)
{
    GPC_STATUS	Status = STATUS_SUCCESS;
    ULONG		i, k;

	TRACE(INIT, 0, 0, "InitGpc");

    //
    // init the global data
    //

    RtlZeroMemory(&glData, sizeof(glData));

    InitializeListHead(&glData.CfList);
	NDIS_INIT_LOCK(&glData.Lock);
    
    //
    // Create a new Request list for blocked requests... [276945]
    //
    InitializeListHead(&glData.gRequestList);
    NDIS_INIT_LOCK(&glData.RequestListLock);

    k = sizeof(PROTOCOL_BLOCK) * GPC_PROTOCOL_TEMPLATE_MAX;

    GpcAllocMem(&glData.pProtocols, k, ProtocolTag);

    if (glData.pProtocols == NULL) {

        Status = GPC_STATUS_NO_MEMORY;

        TRACE(INIT, Status, 0, "InitGpc==>");

        return Status;
    }

    RtlZeroMemory(glData.pProtocols, k);
    RtlZeroMemory(&glStat, sizeof(glStat));

    for (i = 0; i < GPC_PROTOCOL_TEMPLATE_MAX; i++) {

        if ((Status = InitPatternTimer(i)) != STATUS_SUCCESS) {
            
            TRACE(INIT, Status, i, "InitGpc, timer==>");
            
            break;
        }

        //
        // init rest of strcture
        //
        
        glData.pProtocols[i].ProtocolTemplate = i;
        glData.pProtocols[i].SpecificPatternCount = 0;
        glData.pProtocols[i].AutoSpecificPatternCount = 0;
        glData.pProtocols[i].GenericPatternCount = 0;

        switch (i) {

        case GPC_PROTOCOL_TEMPLATE_IP:

            k = sizeof(GPC_IP_PATTERN);
            break;

        case GPC_PROTOCOL_TEMPLATE_IPX:

            k = sizeof(GPC_IPX_PATTERN);
            break;

        default:
            ASSERT(0);
        }

        glData.pProtocols[i].PatternSize = k;

        //
        // init specific pattern db
        //
        
        Status = InitSpecificPatternDb(&glData.pProtocols[i].SpecificDb, k);
        
        if (!NT_SUCCESS(Status)) {
            
            TRACE(INIT, Status, 0, "InitGpc==>");
            
            break;
        }

        //
        // init fragments db
        //
        
        Status = InitFragmentDb((PFRAGMENT_DB *)&glData.pProtocols[i].pProtocolDb);
        
        if (!NT_SUCCESS(Status)) {
            
            UninitSpecificPatternDb(&glData.pProtocols[i].SpecificDb);
            
            TRACE(INIT, Status, 0, "InitGpc==>");
            
            break;
        }
        
    } 	// for (i...)

    if (!NT_SUCCESS (Status)) {
        while (i-- != 0) {
            UninitSpecificPatternDb (&glData.pProtocols[i].SpecificDb);
            UninitFragmentDb((PFRAGMENT_DB)glData.pProtocols[i].pProtocolDb);
        }
        return Status;
    }
    //
    // init handle mapping table
    //

    Status = InitMapHandles();

    if (!NT_SUCCESS(Status)) {
	  
        TRACE(INIT, Status, 0, "InitGpc==>");

        for (i = 0; i < GPC_PROTOCOL_TEMPLATE_MAX; i++) {
            UninitSpecificPatternDb (&glData.pProtocols[i].SpecificDb);
            UninitFragmentDb((PFRAGMENT_DB)glData.pProtocols[i].pProtocolDb);
        }
        return Status;
    }

    //
    // init classification index table
    //

    Status = InitClassificationHandleTbl(&glData.pCHTable);

    if (!NT_SUCCESS(Status)) {
	  
        TRACE(INIT, Status, 0, "InitGpc==>");

        UninitMapHandles();
        for (i = 0; i < GPC_PROTOCOL_TEMPLATE_MAX; i++) {
            UninitSpecificPatternDb (&glData.pProtocols[i].SpecificDb);
            UninitFragmentDb((PFRAGMENT_DB)glData.pProtocols[i].pProtocolDb);
        }
        return Status;
    }


#ifdef STANDALONE_DRIVER

    //
    // initialize the exported calls table
    //

    glGpcExportedCalls.GpcVersion = GpcMajorVersion;
    glGpcExportedCalls.GpcGetCfInfoClientContextHandler = GpcGetCfInfoClientContext;
    glGpcExportedCalls.GpcGetCfInfoClientContextWithRefHandler = GpcGetCfInfoClientContextWithRef;
    glGpcExportedCalls.GpcGetUlongFromCfInfoHandler = GpcGetUlongFromCfInfo;
    glGpcExportedCalls.GpcRegisterClientHandler = GpcRegisterClient;
    glGpcExportedCalls.GpcDeregisterClientHandler = GpcDeregisterClient;
    glGpcExportedCalls.GpcAddCfInfoHandler = GpcAddCfInfo;
    glGpcExportedCalls.GpcAddPatternHandler = GpcAddPattern;
    glGpcExportedCalls.GpcAddCfInfoNotifyCompleteHandler = GpcAddCfInfoNotifyComplete;
    glGpcExportedCalls.GpcModifyCfInfoHandler = GpcModifyCfInfo;
    glGpcExportedCalls.GpcModifyCfInfoNotifyCompleteHandler = GpcModifyCfInfoNotifyComplete;
    glGpcExportedCalls.GpcRemoveCfInfoHandler = GpcRemoveCfInfo;
    glGpcExportedCalls.GpcRemoveCfInfoNotifyCompleteHandler = GpcRemoveCfInfoNotifyComplete;
    glGpcExportedCalls.GpcRemovePatternHandler = GpcRemovePattern;
    glGpcExportedCalls.GpcClassifyPatternHandler = GpcClassifyPattern;
    glGpcExportedCalls.GpcClassifyPacketHandler = GpcClassifyPacket;
    //glGpcExportedCalls.GpcEnumCfInfoHandler = GpcEnumCfInfo;

#endif

#if DBG

    //
    // for the debug version, add a ULONG_PTR for the GPC mark ULONG.
    // ULONG_PTR is used to ensure 8-byte alignment of the returned block on
    // 64-bit platforms.
    //

    ClassificationFamilyLLSize += sizeof( ULONG_PTR );
    ClientLLSize += sizeof( ULONG_PTR );
    PatternLLSize += sizeof( ULONG_PTR );
    CfInfoLLSize += sizeof( ULONG_PTR );
    QueuedNotificationLLSize += sizeof( ULONG_PTR );
    PendingIrpLLSize += sizeof( ULONG_PTR );
#endif

    NdisInitializeNPagedLookasideList(&ClassificationFamilyLL,
                                      NULL,
                                      NULL,
                                      0,
                                      ClassificationFamilyLLSize,
                                      ClassificationFamilyTag,
                                      (USHORT)0);

    NdisInitializeNPagedLookasideList(&ClientLL,
                                      NULL,
                                      NULL,
                                      0,
                                      ClientLLSize,
                                      ClientTag,
                                      (USHORT)0);

    NdisInitializeNPagedLookasideList(&PatternLL,
                                      NULL,
                                      NULL,
                                      0,
                                      PatternLLSize,
                                      PatternTag,
                                      (USHORT)0);

    NdisInitializeNPagedLookasideList(&CfInfoLL,
                                      NULL,
                                      NULL,
                                      0,
                                      CfInfoLLSize,
                                      CfInfoTag,
                                      (USHORT)0);

    NdisInitializeNPagedLookasideList(&QueuedNotificationLL,
                                      NULL,
                                      NULL,
                                      0,
                                      QueuedNotificationLLSize,
                                      QueuedNotificationTag,
                                      (USHORT)0);

    NdisInitializeNPagedLookasideList(&PendingIrpLL,
                                      NULL,
                                      NULL,
                                      0,
                                      PendingIrpLLSize,
                                      PendingIrpTag,
                                      (USHORT)0);

    TRACE(INIT, Status, 0, "InitGpc==>");


	return Status;
}





/*
************************************************************************

DriverEntry -

The driver's entry point.

Arguments
	DriverObject - Pointer to the driver object created by the system.
        RegistryPath - string path to the registry.

Returns
	NT_STATUS

************************************************************************
*/
NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    GPC_STATUS		Status;
    ULONG			dummy = 0;
    PWCHAR          EventLogString = DriverName.Buffer;

    _init_driver = TRUE;


#if DBG

    //
    // first thing, init the trace log
    //

    Status = InitializeLog();

    if (Status != STATUS_SUCCESS) {
     
        KdPrint(("!!! GPC Failed to initialize trace log !!!\n", Status));
    }
#endif

    DriverObject->DriverUnload = GpcUnload;
    //
    // Call the init routine
    //
    
    Status = InitGpc();
    
    if (NT_SUCCESS(Status)) {
        
        //
        // initialize the file system device
        //
        
        Status = (GPC_STATUS)IoctlInitialize(DriverObject, &dummy);
        
        if (!NT_SUCCESS(Status)) {
            
            NdisWriteEventLogEntry(DriverObject,
                                   EVENT_TRANSPORT_REGISTER_FAILED,
                                   GPC_ERROR_INIT_IOCTL,
                                   1,
                                   &EventLogString,
                                   0,
                                   NULL);
        }

    } else {

        NdisWriteEventLogEntry(DriverObject,
                               EVENT_TRANSPORT_REGISTER_FAILED,
                               GPC_ERROR_INIT_MAIN,
                               1,
                               &EventLogString,
                               0,
                               NULL);
#if DBG
        FreeDebugLog ();
#endif
    }

#if DBG
    if (!NT_SUCCESS(Status)) {
        KdPrint(("!!! GPC loading Failed (%08X) !!!\n", Status));        
    }
#endif

    return (NTSTATUS)Status;

} // end DriverEntry
VOID
GpcUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    ULONG i;

    NdisDeleteNPagedLookasideList(&ClassificationFamilyLL);
    NdisDeleteNPagedLookasideList(&ClientLL);
    NdisDeleteNPagedLookasideList(&PatternLL);
    NdisDeleteNPagedLookasideList(&CfInfoLL);
    NdisDeleteNPagedLookasideList(&QueuedNotificationLL);
    NdisDeleteNPagedLookasideList(&PendingIrpLL);

    UninitClassificationHandleTbl(glData.pCHTable);
    UninitMapHandles();

    for (i = 0; i < GPC_PROTOCOL_TEMPLATE_MAX; i++) {
        UninitSpecificPatternDb (&glData.pProtocols[i].SpecificDb);
        UninitFragmentDb((PFRAGMENT_DB)glData.pProtocols[i].pProtocolDb);
    }
    GpcFreeMem(glData.pProtocols, ProtocolTag);
#if DBG
    FreeDebugLog ();
#endif

}




/*
************************************************************************

GpcGetCfInfoClientContext -

Returns the client context for blob

Arguments
    ClientHandle - the calling client's handle
	ClassificationHandle - needless to say

Returns
	A CfInfo client context or NULL if the classification 
	handle is invalid

************************************************************************
*/
GPC_STATUS
GpcGetCfInfoClientContext(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    OUT PGPC_CLIENT_HANDLE      pClientCfInfoContext
    )
{
    PBLOB_BLOCK				pBlob;
    GPC_CLIENT_HANDLE		h;
    KIRQL					CHirql;
    NTSTATUS                Status;
    PCLASSIFICATION_BLOCK   pCB;

	TRACE(CLASSIFY, ClientHandle, ClassificationHandle, "GpcGetCfInfoClientContext");

    pCB = NULL;

	if (ClientHandle == NULL) {
        
        *pClientCfInfoContext = NULL;
	    return GPC_STATUS_INVALID_PARAMETER;

    }

    READ_LOCK(&glData.ChLock, &CHirql);

	pBlob = (PBLOB_BLOCK)dereference_HF_handle_with_cb(
							glData.pCHTable,
                            ClassificationHandle,
                            GetCFIndexFromClient(ClientHandle));

	if (pBlob == NULL) {
    
        pCB = dereference_HF_handle(
                                    glData.pCHTable,
                                    ClassificationHandle);

        READ_UNLOCK(&glData.ChLock, CHirql);

        if (!pCB) {

            Status = GPC_STATUS_INVALID_HANDLE;

        } else {
        
            Status = GPC_STATUS_NOT_FOUND;

        }

        *pClientCfInfoContext = 0;

        return Status;
    }

#if DBG
    {
        //
        // Get the client index to reference into the ClientCtx table
        //
        
        ULONG t = GetClientIndexFromClient(ClientHandle);

        ASSERT(t < MAX_CLIENTS_CTX_PER_BLOB);
        
        TRACE(CLASSIFY, ClassificationHandle, pBlob->arClientCtx[t],
              "GpcGetCfInfoClientContext (ctx)");
    }
#endif

    h = pBlob->arClientCtx[GetClientIndexFromClient(ClientHandle)];

    READ_UNLOCK(&glData.ChLock, CHirql);

	TRACE(CLASSIFY, pBlob, h, "GpcGetCfInfoClientContext==>");
    
    *pClientCfInfoContext = h;

    return GPC_STATUS_SUCCESS;
}


/*
************************************************************************

GpcGetCfInfoClientContextWithRef -

Returns the client context for blob and increments a Dword provided by
the client. This function can be used by clients to synchronize access
to their structures on the remove and send path.

Arguments
    ClientHandle - the calling client's handle
	ClassificationHandle - needless to say
    Offset - Offset to location that needs to be incremented.

Returns
	A CfInfo client context or NULL if the classification 
	handle is invalid

************************************************************************
*/
GPC_CLIENT_HANDLE
GpcGetCfInfoClientContextWithRef(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    IN  ULONG                   Offset
    )
{
    PBLOB_BLOCK				pBlob;
    GPC_CLIENT_HANDLE		h;
    KIRQL					CHirql;
    PULONG                  RefPtr = NULL;

	TRACE(CLASSIFY, ClientHandle, ClassificationHandle, "GpcGetCfInfoClientContextWithRef");

	if (ClientHandle == NULL)
	  return NULL;

    READ_LOCK(&glData.ChLock, &CHirql);

	pBlob = (PBLOB_BLOCK)dereference_HF_handle_with_cb(
							glData.pCHTable,
                            ClassificationHandle,
                            GetCFIndexFromClient(ClientHandle));

    
	if (pBlob == NULL) {

        READ_UNLOCK(&glData.ChLock, CHirql);

        return NULL;

    } 
    
#if DBG
    {
        //
        // Get the client index to reference into the ClientCtx table
        //
        
        ULONG t = GetClientIndexFromClient(ClientHandle);

        ASSERT(t < MAX_CLIENTS_CTX_PER_BLOB);
        
        TRACE(CLASSIFY, ClassificationHandle, pBlob->arClientCtx[t],
              "GpcGetCfInfoClientContextWithRef (ctx)");
    }
#endif

    h = pBlob->arClientCtx[GetClientIndexFromClient(ClientHandle)];

    //
    // As part of 390882, it has been noted that sometimes the handle can
    // NULL, this could be either due to an Auto pattern or a generic 
    // pattern.
    //
    if (!h) {
        
        READ_UNLOCK(&glData.ChLock, CHirql);
        TRACE(CLASSIFY, pBlob, h, "GpcGetCfInfoClientContextWithRef==>");
        return NULL;

    }

    // The GPC Clients wants GPC to increment the memory at this offset.
    ASSERT(h);
    RefPtr = (PULONG) (((PUCHAR)h) + Offset);
    InterlockedIncrement(RefPtr);

    //(*((PUCHAR)h + Offset))++;

    READ_UNLOCK(&glData.ChLock, CHirql);

	TRACE(CLASSIFY, pBlob, h, "GpcGetCfInfoClientContextWithRef==>");

    return h;
}




/*
************************************************************************

GpcGetUlongFromCfInfo -

Returns a ulong in the blob data pointer from the classification handle for
the particular client.

Arguments
    ClientHandle    - the client handle
    ClassificationHandle - the classification handle
    Offset          - oofset in bytes into the CfInfo structure
    pValue          - store for the returned value

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GpcGetUlongFromCfInfo(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    IN	ULONG					Offset,
    IN	PULONG					pValue
    )
{
    KIRQL					irql;
    PCLASSIFICATION_BLOCK	pCB;
    PBLOB_BLOCK				pBlob;

    ASSERT( pValue );

	TRACE(CLASSIFY, ClientHandle, ClassificationHandle, "GpcGetUlongFromCfInfo");

	if (ClientHandle == NULL)
	  return GPC_STATUS_INVALID_PARAMETER;

    READ_LOCK(&glData.ChLock, &irql);

	pCB = (PCLASSIFICATION_BLOCK)dereference_HF_handle(
							glData.pCHTable,
                            ClassificationHandle);

	if (pCB == NULL) {

        READ_UNLOCK(&glData.ChLock, irql);
    
        return GPC_STATUS_INVALID_HANDLE;
    }

    pBlob = pCB->arpBlobBlock[GetCFIndexFromClient(ClientHandle)];

    if (pBlob == NULL) {

        TRACE(CLASSIFY, pBlob, 0, "GpcGetUlongFromCfInfo-->");

        READ_UNLOCK(&glData.ChLock, irql);
    
        return GPC_STATUS_NOT_FOUND;
    }

	TRACE(CLASSIFY, ClassificationHandle, pBlob->pClientData, "GpcGetUlongFromCfInfo (2)");

    ASSERT( Offset+sizeof(ULONG) <= pBlob->ClientDataSize );
    ASSERT( pBlob->pClientData );

    if (pBlob->pClientData == NULL) {
        READ_UNLOCK(&glData.ChLock, irql);
        return (GPC_STATUS_FAILURE);
    }

    *pValue = *(PULONG)((PUCHAR)pBlob->pClientData + Offset);

    READ_UNLOCK(&glData.ChLock, irql);

	TRACE(CLASSIFY, pBlob, *pValue, "GpcGetUlongFromCfInfo==>");

    return GPC_STATUS_SUCCESS;
}




/*
************************************************************************

GetClientCtxAndUlongFromCfInfo -

Returns a ulong in the blob data pointer AND the client context
from the classification handle for the particular client.

Arguments
    ClientHandle    - the client handle
    ClassificationHandle - the classification handle
    Offset          - oofset in bytes into the CfInfo structure
    pValue          - store for the returned value

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GetClientCtxAndUlongFromCfInfo(
	IN	GPC_HANDLE				ClientHandle,
    IN	OUT PCLASSIFICATION_HANDLE	pClassificationHandle,
    OUT PGPC_CLIENT_HANDLE		pClientCfInfoContext,
    IN	ULONG					Offset,
    IN	PULONG					pValue
    )
{
    PCLASSIFICATION_BLOCK	pCB;
    KIRQL					irql;
    PBLOB_BLOCK				pBlob;

    ASSERT( ClientHandle );
    ASSERT( pClientCfInfoContext || pValue );

	TRACE(CLASSIFY, ClientHandle, pClassificationHandle, "GetClientCtxAndUlongFromCfInfo");

    READ_LOCK(&glData.ChLock, &irql);

	pCB = (PCLASSIFICATION_BLOCK)dereference_HF_handle(
							glData.pCHTable,
                            *pClassificationHandle
                            );

	TRACE(CLASSIFY, pCB, GetCFIndexFromClient(ClientHandle), "GetClientCtxAndUlongFromCfInfo (2)");

	if (pCB == NULL) {

        //
        // didn't find the reference, which means the CH is probably invalid
        // reset it to 0 to indicate the caller that it should add a new one
        //

        *pClassificationHandle = 0;
        READ_UNLOCK(&glData.ChLock, irql);

        return GPC_STATUS_NOT_FOUND;
    }

    ASSERT(GetClientIndexFromClient(ClientHandle) < MAX_CLIENTS_CTX_PER_BLOB);

    pBlob = pCB->arpBlobBlock[GetCFIndexFromClient(ClientHandle)];

    if (pBlob == NULL) {

        TRACE(CLASSIFY, pBlob, 0, "GetClientCtxAndUlongFromCfInfo-->");

        READ_UNLOCK(&glData.ChLock, irql);

        return GPC_STATUS_NOT_FOUND;
    
    } 
    
    TRACE(CLASSIFY, *pClassificationHandle, pBlob->pClientData, "GetClientCtxAndUlongFromCfInfo (3)");

    ASSERT( Offset+sizeof(ULONG) <= pBlob->ClientDataSize );
    ASSERT( pBlob->pClientData );
    
    if (pClientCfInfoContext) {
        *pClientCfInfoContext = pBlob->arClientCtx[GetClientIndexFromClient(ClientHandle)];

        TRACE(CLASSIFY, pBlob, *pClientCfInfoContext, "GetClientCtxAndUlongFromCfInfo==>");

    }

    if (pValue) {
        *pValue = *(PULONG)((PUCHAR)pBlob->pClientData + Offset);

        TRACE(CLASSIFY, pBlob, *pValue, "GetClientCtxAndUlongFromCfInfo==>");

    }

    READ_UNLOCK(&glData.ChLock, irql);

    return GPC_STATUS_SUCCESS;
}



/*
************************************************************************

GpcRegisterClient -

	This will register the client in the GPC and return a client handle.
    If another client already registered for the same CF, we link this one
    on a list for the CF. The first client for the CF will cause a CF block
    to be created. CFs are identified by CfName. The other parameters will also
    be set in the client's block.

Arguments
	CfId 				- Id of the classification family
    Flags				- operation modes for the client:
							CF_FRAGMENT
    MaxPriorities		- max number of priorities the client will ever use
    pClientFuncList		- list of callback functions
    ClientContext		- client context, GPC will use it in callbacks
    pClientHandle		- OUT, the returned client handle
    
Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GpcRegisterClient(
	IN	ULONG					CfId,
    IN	ULONG					Flags,
    IN  ULONG					MaxPriorities,
    IN	PGPC_CLIENT_FUNC_LIST	pClientFuncList,
    IN	GPC_CLIENT_HANDLE		ClientContext,
    OUT	PGPC_HANDLE				pClientHandle
    )
{
    GPC_STATUS		Status = GPC_STATUS_SUCCESS;
    PCF_BLOCK		pCf;
    PCLIENT_BLOCK	pClient= NULL;
    ULONG			i;
    PLIST_ENTRY		pHead, pEntry;
    KIRQL			irql;

	TRACE(REGISTER, CfId, ClientContext, "GpcRegisterClient");

    *pClientHandle = NULL;

    if (!_init_driver) {

        return GPC_STATUS_NOTREADY;
    }

    //
    // verify the CF Id
    //

    if (CfId >= GPC_CF_MAX) {
        
        TRACE(REGISTER, GPC_STATUS_INVALID_PARAMETER, CfId, "GpcRegisterClient-->");
        StatInc(RejectedCf);

        return GPC_STATUS_INVALID_PARAMETER;
    }

    //
    // verify the maximum number of priorities
    //

    if (MaxPriorities > GPC_PRIORITY_MAX) {
        
        TRACE(REGISTER, GPC_STATUS_INVALID_PARAMETER, MaxPriorities, "GpcRegisterClient~~>");
        StatInc(RejectedCf);

        return GPC_STATUS_INVALID_PARAMETER;
    }

    if (MaxPriorities == 0) {
        MaxPriorities = 1;
    }

    //
    // find the CF or create a new one
    //

    NDIS_LOCK(&glData.Lock);

    pHead = &glData.CfList;
    pEntry = pHead->Flink;
    pCf = NULL;

    while (pCf == NULL && pEntry != pHead) {

        pCf = CONTAINING_RECORD(pEntry, CF_BLOCK, Linkage);

        if (pCf->AssignedIndex != CfId) {

            pCf = NULL;
        }

        pEntry = pEntry->Flink;
    }

    if (pCf == NULL) {

        //
        // create a new CF
        //

        pCf = CreateNewCfBlock(CfId, MaxPriorities);

        if (pCf == NULL) {

            NDIS_UNLOCK(&glData.Lock);

            return GPC_STATUS_NO_MEMORY;
        }
     
        //
        // add the new CF to the list
        //

        GpcInsertTailList(&glData.CfList, &pCf->Linkage);
    }

    //
    // grab the CF lock before releasing the global lock
    //

    NDIS_UNLOCK(&glData.Lock);

    RSC_WRITE_LOCK(&pCf->ClientSync, &irql);

    NDIS_LOCK(&pCf->Lock);
    
    //
    // create a new client block and chain it on the CF block
    //

    pClient = CreateNewClientBlock();

    if (pClient == NULL) {

        //
        // oops
        //

        NDIS_UNLOCK(&pCf->Lock);

        RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);

        TRACE(REGISTER, GPC_STATUS_RESOURCES, 0, "GpcRegisterClient==>");

        StatInc(RejectedCf);

        return GPC_STATUS_NO_MEMORY;
    }

    //
    // assign a new index to the client. This will also mark the index
    // as busy for this CF.
    //

    pClient->AssignedIndex = AssignNewClientIndex(pCf);

    if (pClient->AssignedIndex == (-1)) {

        //
        // too many clients
        //

        StatInc(RejectedCf);

        NDIS_UNLOCK(&pCf->Lock);

        RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);

        ReleaseClientBlock(pClient);

        TRACE(REGISTER, GPC_STATUS_TOO_MANY_HANDLES, 0, "GpcRegisterClient==>");
        return GPC_STATUS_TOO_MANY_HANDLES;
    }

    //
    // init the client block
    //

    pClient->pCfBlock = pCf;
    pClient->ClientCtx = ClientContext;
    pClient->Flags = Flags;
    pClient->State = GPC_STATE_READY;

    if (pClientFuncList) {

        RtlMoveMemory(&pClient->FuncList, 
                      pClientFuncList, 
                      sizeof(GPC_CLIENT_FUNC_LIST));
    }

    //
    // add the client block to the CF and update CF
    //

    GpcInsertTailList(&pCf->ClientList, &pClient->ClientLinkage);

    pCf->NumberOfClients++;

    //
    // fill the output client handle
    //

    *pClientHandle = (GPC_CLIENT_HANDLE)pClient;

    //
    // release the lock
    //

    NDIS_UNLOCK(&pCf->Lock);

    RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);

#if 0
    //
    // if this is not the first client for the CF, start a working
    // thread to notify the client about each installed blob for the CF.
    // In the call include:
    //

    if (!IsListEmpty(&pCf->BlobList)) {

        //
        // this is not the first client, start a notification thread
        //

    }
#endif

    TRACE(REGISTER, pClient, Status, "GpcRegisterClient==>");

    if (NT_SUCCESS(Status)) {

        StatInc(CreatedCf);
        StatInc(CurrentCf);

    } else {

        StatInc(RejectedCf);

    }

    return Status;
}




/*
************************************************************************

GpcDeregisterClient -

Deregisters the client and remove associated data from the GPC.

Arguments
	ClientHandle - client handle

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GpcDeregisterClient(
	IN	GPC_HANDLE		ClientHandle
    )
{
    GPC_STATUS	    Status = STATUS_SUCCESS;
    PCLIENT_BLOCK   pClient;
    PCF_BLOCK       pCf;

	TRACE(REGISTER, ClientHandle, 0, "GpcDeregisterClient");

    pClient = (PCLIENT_BLOCK)ClientHandle;

    NDIS_LOCK(&pClient->Lock);

    pCf = pClient->pCfBlock;
    
    if (!IsListEmpty(&pClient->BlobList)) {

        Status = GPC_STATUS_NOT_EMPTY;

        NDIS_UNLOCK(&pClient->Lock);

        return Status;
    }

    if (pClient->State != GPC_STATE_READY) {

        //
        // HUH?!?
        // Client called to remove twice! probably caller bug
        // but we need to protect our selves.
        //

        NDIS_UNLOCK(&pClient->Lock);

        TRACE(REGISTER, GPC_STATUS_NOTREADY, 0, "GpcDeregisterClient==>");

        return GPC_STATUS_NOTREADY;
    }

    //
    // remove the client from the Cf's client list
    //
    
    pClient->State = GPC_STATE_REMOVE;
    pClient->ObjectType = GPC_ENUM_INVALID;

    //
    // release the client's mapping handle
    //
    
    FreeHandle(pClient->ClHandle);    

    //
    // remove the client from the CF list and return the index back
    //

#if 0
    NDIS_DPR_LOCK(&pCf->Lock);

    GpcRemoveEntryList(&pClient->ClientLinkage);
    ReleaseClientIndex(pCf->ClientIndexes, pClient->AssignedIndex);
#endif

    //
    // decrease number of clients
    //
        
    if (NdisInterlockedDecrement(&pCf->NumberOfClients) == 0) {
        
        TRACE(CLIENT, pClient, pCf->NumberOfClients, "NumberOfClients");
        
        //
        // last client on the CF, we may release all db
        //
        
        //UninitializeGenericDb(&pCf->pGenericDb, pCf->MaxPriorities);
    }    
        
    StatInc(DeletedCf);
    StatDec(CurrentCf);

#if 0
    NDIS_DPR_UNLOCK(&pCf->Lock);
#endif

    NDIS_UNLOCK(&pClient->Lock);

    //
    // release the client block
    //

    REFDEL(&pClient->RefCount, 'CLNT');
    
    TRACE(REGISTER, Status, 0, "GpcDeregisterClient==>");

    return Status;
}

/*
************************************************************************

GpcAddCfInfo -

Add A new blob. The blob is copied into the GPC and the GPC notifies
other client for the same CF about the installation.

Arguments
	ClientHandle		- client handle
    CfInfoSize			- size of the blob
    pClientCfInfoPtr	- pointer to the blob
    ClientCfInfoContext	- client's context to associate with the blob
    pGpcCfInfoHandle	- OUT, returned blob handle

Returns
	GPC_STATUS: SUCCESS, PENDING or FAILURE

************************************************************************
*/
GPC_STATUS
GpcAddCfInfo(
	IN	GPC_HANDLE				ClientHandle,
    IN	ULONG					CfInfoSize,
    IN	PVOID					pClientCfInfoPtr,
    IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
    OUT PGPC_HANDLE	    		pGpcCfInfoHandle
    )
{
    GPC_STATUS			Status = GPC_STATUS_SUCCESS;
    GPC_STATUS          Status1;
    PCLIENT_BLOCK		pClient;
    PCLIENT_BLOCK		pNotifyClient;
    PCLIENT_BLOCK		pNotifyClient2;
    PBLOB_BLOCK			pBlob;
    PCF_BLOCK			pCf;
    PLIST_ENTRY			pEntry, pHead;
    int                 i;
    GPC_CLIENT_HANDLE	ReturnedCtx;
    KIRQL				irql;

	TRACE(BLOB, ClientHandle, ClientCfInfoContext, "GpcAddCfInfo");

    VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);

    *pGpcCfInfoHandle = NULL;

    //
    // cast the client handle to the block
    //

    pClient = (PCLIENT_BLOCK)ClientHandle;
    
    ASSERT(pClient);

    pCf = pClient->pCfBlock;

    ASSERT(pCf);

    //
    // create a new blob block and copy the user data into
    //

    pBlob = CreateNewBlobBlock(CfInfoSize, pClientCfInfoPtr);

    if (pBlob) {

#if NO_USER_PENDING

        //
        // this will be only required until we implement the user level
        // pending report
        //

        CTEInitBlockStruc(&pBlob->WaitBlock);

#endif

        //
        // Add one reference count to the blob since if during
        // completion, it might be deleted (if the client fails)
        //

        REFADD(&pBlob->RefCount, 'ADCF');

        //
        // set the calling client context inside the blob
        //
        
        pBlob->arClientCtx[pClient->AssignedIndex] = ClientCfInfoContext;

        //
        // set the owner client's context
        //

        pBlob->OwnerClientCtx = ClientCfInfoContext;

        //
        // set pointer to installer and the state
        //

        pBlob->pOwnerClient = pClient;
        pBlob->State = GPC_STATE_ADD;

        //
        // init the client status array to keep track
        // of how many client have succeeded so far
        //
        
        RtlZeroMemory(pBlob->arpClientStatus, sizeof(pBlob->arpClientStatus));
        pBlob->ClientStatusCountDown = 0;

        //
        // notify each client
        //

        //NDIS_LOCK(&pCf->Lock);

        RSC_READ_LOCK(&pCf->ClientSync, &irql);

        pHead = &pCf->ClientList;
        pEntry = pHead->Flink;

        while (pEntry != pHead && (Status == GPC_STATUS_SUCCESS || 
                                   Status == GPC_STATUS_PENDING)) {

            //
            // get the notified client block
            //

            pNotifyClient = CONTAINING_RECORD(pEntry, 
                                              CLIENT_BLOCK, 
                                              ClientLinkage);

            if (pNotifyClient != pClient 
                && 
                !IS_USERMODE_CLIENT(pNotifyClient) ) {

                //
                // don't notify the caller
                //

                REFADD(&pNotifyClient->RefCount, 'ADCF');

                //
                // okay, we have bumped the ref count for this
                // client. No need to keep the lock 
                //

                RSC_READ_UNLOCK(&pCf->ClientSync, irql);
                //NDIS_UNLOCK(&pCf->Lock);
        
                //
                // increase number of count down clients,
                // so we keep track how many clients are still
                // pending. We do it *before* the call, since
                // the completion might be called before the notification
                // returns.
                //
                
                Status1 = ClientAddCfInfo
                    (pNotifyClient,
                     pBlob,
                     &ReturnedCtx
                     );

                if (Status1 == GPC_STATUS_PENDING) {
                    
                    pBlob->arClientCtx[pNotifyClient->AssignedIndex] = 
                        ReturnedCtx;
                    Status = GPC_STATUS_PENDING;
                    
                    if (pBlob->pNotifiedClient == NULL &&
                        pNotifyClient->FuncList.ClGetCfInfoName) {

                        TRACE(BLOB, pBlob, ReturnedCtx, "GpcAddCfInfo: (client)");

                        //ASSERT(ReturnedCtx);

                        //
                        // assume that is the client returned PENDING
                        // it has some interest in the blob...
                        //
                        
                        pBlob->pNotifiedClient = pNotifyClient;
                        pBlob->NotifiedClientCtx = ReturnedCtx;
                    }

                } else if (!NT_SUCCESS(Status1)) {
                    
                    //
                    // some failure, notify each client that reported
                    // success on the add blob, to remove it
                    //

                    //
                    // change the state to 'remove'
                    //
                    
                    pBlob->State = GPC_STATE_REMOVE;

                    //
                    // set the last status to the failure status
                    //

                    pBlob->LastStatus = Status = Status1;

                    REFDEL(&pNotifyClient->RefCount, 'ADCF');

                    for (i = 0; i < MAX_CLIENTS_CTX_PER_BLOB; i++) {

                        //
                        // only clients with none zero entries
                        // have succefully installed the blob
                        //

                        if (pNotifyClient = pBlob->arpClientStatus[i]) {
                            
                            //
                            // notify each client to remove the blob
                            //
                            
                            Status1 = ClientRemoveCfInfo
                                (
                                 pNotifyClient,
                                 pBlob,
                                 pBlob->arClientCtx[pNotifyClient->AssignedIndex]
                                 );
                            
                            if (Status1 != GPC_STATUS_PENDING) {
                                
                                //
                                // error or success
                                //

                                pBlob->arpClientStatus[i] = NULL;

                                //DereferenceClient(pNotifyClient);
                            }
                            
                        }

                    } // for

                    //
                    // don't notify other clients
                    //

                    //NDIS_LOCK(&pCf->Lock);
                    RSC_READ_LOCK(&pCf->ClientSync, &irql);
                    
                    break;

                } else {

                    //
                    // status success or ignored reported
                    //

                    if (Status1 == GPC_STATUS_SUCCESS) {
                        
                        pBlob->arClientCtx[pNotifyClient->AssignedIndex] = 
                            ReturnedCtx;
                        pBlob->arpClientStatus[pNotifyClient->AssignedIndex] = 
                            pNotifyClient;

                        if (pBlob->pNotifiedClient == NULL &&
                            pNotifyClient->FuncList.ClGetCfInfoName) {

                            TRACE(BLOB, pBlob, ReturnedCtx, "GpcAddCfInfo: (client 2)");
                            
                            //ASSERT(ReturnedCtx);

                            //
                            // update the notified client
                            //
                            
                            pBlob->pNotifiedClient = pNotifyClient;
                            pBlob->NotifiedClientCtx = ReturnedCtx;
                        }

                    }

                }

                //
                // This is a tricky part,
                // we need to let go of the ref count of the current client object
                // but get the next one...
                //
                
                //NDIS_LOCK(&pCf->Lock);
                RSC_READ_LOCK(&pCf->ClientSync, &irql);

                pEntry = pEntry->Flink;

                if (pEntry != pHead) {
                    
                    pNotifyClient2 = CONTAINING_RECORD(pEntry, 
                                                       CLIENT_BLOCK, 
                                                       ClientLinkage);

                    REFADD(&pNotifyClient2->RefCount, 'ADCF');

                }

                //
                // release the list lock since the next call will try to get it
                //

                RSC_READ_UNLOCK(&pCf->ClientSync, irql);
                 
                REFDEL(&pNotifyClient->RefCount, 'ADCF');

                RSC_READ_LOCK(&pCf->ClientSync, &irql);

                if (pEntry != pHead) {
                    
                    //
                    // safe to do since the list is locked
                    //

                    REFDEL(&pNotifyClient2->RefCount, 'ADCF');
                }

            } else {   // if (pNotifyClient != pClient)

                //
                // advance to the next client block
                //
                
                pEntry = pEntry->Flink;
            }
                
        } // while


        //
        // release the CF lock still got
        //

        //NDIS_UNLOCK(&pCf->Lock);

        RSC_READ_UNLOCK(&pCf->ClientSync, irql);

    } else { // if (pBlob)...
        
        //
        // error - no more memory?!?
        //

        Status = GPC_STATUS_RESOURCES;
    }

    if (NT_SUCCESS(Status)) {
        
        ASSERT(pBlob);

        *pGpcCfInfoHandle = (GPC_CLIENT_HANDLE)pBlob;

        if (Status == GPC_STATUS_SUCCESS) {

            //
            // add the blob to the CF and client lists
            //
            
            GpcInterlockedInsertTailList(&pClient->BlobList, 
                                         &pBlob->ClientLinkage,
                                         &pClient->Lock
                                         );
            GpcInterlockedInsertTailList(&pCf->BlobList, 
                                         &pBlob->CfLinkage,
                                         &pCf->Lock
                                         );
            
            pBlob->State = GPC_STATE_READY;
        }

    } else {
        
        //
        // failed - remove the blob
        //

        if (pBlob)
            REFDEL(&pBlob->RefCount, 'BLOB');
    }

    if (pBlob) {

        //
        // release the first refcount we got up there...
        //
        REFDEL(&pBlob->RefCount, 'ADCF');

    }

	TRACE(BLOB, pBlob, Status, "GpcAddCfInfo==>");

    if (Status == GPC_STATUS_SUCCESS) {

        CfStatInc(pCf->AssignedIndex,CreatedBlobs);
        CfStatInc(pCf->AssignedIndex,CurrentBlobs);

    } else if (Status != GPC_STATUS_PENDING) {

        CfStatInc(pCf->AssignedIndex,RejectedBlobs);
        
    }

    return Status;
}




/*
************************************************************************

GpcAddPattern -

This will install a pattern into the GPC database. The pattern is hooked
to a blob. The pattern can be specific or general.
Adding a specific pattern:
It goes into the specific hash table (per protocol block)
....
return a classification handle

Adding general pattern:
It goes into a separate Rhizome per CF and into its priority slot.
....

Arguments
	ClientHandle			- client handle
    ProtocolTemplate		- the protocol template ID to use
    Pattern					- pattern
    Mask					- patern mask
    Priority				- pattern priority in case of conflict
    GpcCfInfoHandle			- associated blob handle
    pGpcPatternHandle		- OUT, returned pattern handle
    pClassificationHandle	- OUT, for specific pattern only

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GpcAddPattern(
	IN	GPC_HANDLE				ClientHandle,
    IN	ULONG					ProtocolTemplate,
    IN	PVOID					Pattern,
    IN	PVOID					Mask,
    IN	ULONG					Priority,
    IN	GPC_HANDLE				GpcCfInfoHandle,
    OUT	PGPC_HANDLE				pGpcPatternHandle,
    OUT	PCLASSIFICATION_HANDLE  pClassificationHandle
    )
{
    GPC_STATUS				Status;
    PCLIENT_BLOCK			pClient;
    PBLOB_BLOCK				pBlob;
    PPATTERN_BLOCK			pPattern, pCreatedPattern;
    PGENERIC_PATTERN_DB		pGenericDb;
    PCLASSIFICATION_BLOCK	pCB;
    ULONG					i;
    PUCHAR					p;
    ULONG					Flags;
    PPROTOCOL_BLOCK			pProtocolBlock;
    ULONG					CfIndex;
    PGPC_IP_PATTERN			pIpPattern;
    REQUEST_BLOCK           Request, *pRequest;
    PLIST_ENTRY             pLinkage;

	TRACE(PATTERN, ClientHandle, Pattern, "GpcAddPattern");

    VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);
    //VERIFY_OBJECT(GpcCfInfoHandle, GPC_ENUM_CFINFO_TYPE);

    ASSERT(pGpcPatternHandle);
    ASSERT(pClassificationHandle);

    *pGpcPatternHandle = NULL;
    *pClassificationHandle = (CLASSIFICATION_HANDLE)0;

    //
    // NdisInitializeEvent must run at PASSIVE (isnt that sad)
    //
    RtlZeroMemory(&Request, sizeof(REQUEST_BLOCK));
    NdisInitializeEvent(
                        &Request.RequestEvent
                        );
    
    //
    // cast the client handle to the block
    // and the CfInfo handle to a blob block
    //

    pClient = (PCLIENT_BLOCK)ClientHandle;
    pBlob = (PBLOB_BLOCK)GpcCfInfoHandle;

    ASSERT(pClient);

    CfIndex = pClient->pCfBlock->AssignedIndex;

    if (Priority >= pClient->pCfBlock->MaxPriorities ||
        ProtocolTemplate >= GPC_PROTOCOL_TEMPLATE_MAX ) {

        return GPC_STATUS_INVALID_PARAMETER;
    }

    if (pBlob != NULL) {
        NDIS_LOCK(&pBlob->Lock);

        if (pBlob->ObjectType != GPC_ENUM_CFINFO_TYPE) {

            NDIS_UNLOCK(&pBlob->Lock);
            return GPC_STATUS_INVALID_PARAMETER;
        }

    }

    NDIS_LOCK(&glData.RequestListLock);

    if (pBlob != NULL && pBlob->State != GPC_STATE_READY) {
     
        //
        // Block until it is safe to restart the work.
        //
        InsertTailList(&glData.gRequestList, &Request.Linkage);
            
        NDIS_UNLOCK(&glData.RequestListLock);
        
        //
        // doing something else
        //
        NDIS_UNLOCK(&pBlob->Lock);

        if (TRUE == NdisWaitEvent(
                                  &Request.RequestEvent,
                                  0
                                  )) {
            
            //
            // The wait was successful, continue with regularly scheduled programming.
            // This lock needs to be taken when we get out.
            NDIS_LOCK(&pBlob->Lock);
            
        } else {

            //
            // How could this happen? I dont know. 
            // Definitely need to investigate.
            //

            TRACE(PATTERN, GPC_STATUS_FAILURE, 0, "GpcAddPattern: The conflict <-> wait <-> resume plan has FAILED!\n");
            ASSERT(FALSE);
            return GPC_STATUS_NOTREADY;
        }

    } else {

        NDIS_UNLOCK(&glData.RequestListLock);

    }

    //
    // determine if the pattern is specific or generic
    //

    pProtocolBlock = &glData.pProtocols[ProtocolTemplate];

    if (ProtocolTemplate == GPC_PROTOCOL_TEMPLATE_IP) {

        //
        // 
        //

        pIpPattern = (PGPC_IP_PATTERN)Pattern;
        pIpPattern->Reserved[0] = pIpPattern->Reserved[1] = pIpPattern->Reserved[2] = 0;

        pIpPattern = (PGPC_IP_PATTERN)Mask;
        pIpPattern->Reserved[0] = pIpPattern->Reserved[1] = pIpPattern->Reserved[2] = 0xff;
    }

    for (i = 0, p=(PUCHAR)Mask; i < pProtocolBlock->PatternSize; i++, p++) {
        
        if (*p != 0xff)
            break;
        
    }

    //
    // set the Flags
    //

    Flags = (i < pProtocolBlock->PatternSize) ? 0 : PATTERN_SPECIFIC;

    if (pBlob != NULL) {

        //
        // change the blob state to ADD, so no one can delete it
        // while the pattern is being added to its list
        //
        
        pBlob->State = GPC_STATE_ADD;
        
        NDIS_UNLOCK(&pBlob->Lock);
    }

    //
    // increment ref counting
    //

    //NdisInterlockedIncrement(&pClient->RefCount);

    //
    // cerate a new pattern block
    //

    pPattern = CreateNewPatternBlock(Flags);

    pCreatedPattern = pPattern;

#if DBG

    {
        PGPC_IP_PATTERN	pIp = (PGPC_IP_PATTERN)Pattern;
        PGPC_IP_PATTERN	pMask = (PGPC_IP_PATTERN)Mask;

        DBGPRINT(PATTERN, ("GpcAddPattern: Client=%X %s - ", 
                           pClient,
                           TEST_BIT_ON(Flags, PATTERN_SPECIFIC)?"Specific":"Generic"));
        DBGPRINT(PATTERN, ("IP: ifc={%d,%d} src=%08X:%04x, dst=%08X:%04x, prot=%d rsv=%x,%x,%x\n", 
                           pIp->InterfaceId.InterfaceId,
                           pIp->InterfaceId.LinkId,
                           pIp->SrcAddr,
                           pIp->gpcSrcPort,
                           pIp->DstAddr,
                           pIp->gpcDstPort,
                           pIp->ProtocolId,
                           pIp->Reserved[0],
                           pIp->Reserved[1],
                           pIp->Reserved[2]
                           ));
        DBGPRINT(PATTERN, ("Mask: ifc={%x,%x} src=%08X:%04x, dst=%08X:%04x, prot=%x rsv=%x,%x,%x\n", 
                           pMask->InterfaceId.InterfaceId,
                           pMask->InterfaceId.LinkId,
                           pMask->SrcAddr,
                           pMask->gpcSrcPort,
                           pMask->DstAddr,
                           pMask->gpcDstPort,
                           pMask->ProtocolId,
                           pMask->Reserved[0],
                           pMask->Reserved[1],
                           pMask->Reserved[2]
                           ));
    }
#endif

    if (pPattern) {
        
        //
        // add one reference count to the pattern, so when we add it
        // to the db, we're sure it stays there
        //
        
        //pPattern->RefCount++;
        pPattern->Priority = Priority;
        pPattern->ProtocolTemplate = ProtocolTemplate;

        if (TEST_BIT_ON(Flags, PATTERN_SPECIFIC)) {

            //
            // add a specific pattern
            //
            
            Status = AddSpecificPattern(
                                        pClient,
                                        Pattern,
                                        Mask,
                                        pBlob,
                                        pProtocolBlock,
                                        &pPattern,  // output pattern pointer
                                        pClassificationHandle
                                        );

        } else {
            
            //
            // add a generic pattern
            //
            
            Status = AddGenericPattern(
                                       pClient,
                                       Pattern,
                                       Mask,
                                       Priority,
                                       pBlob,
                                       pProtocolBlock,
                                       &pPattern   // output pattern pointer
                                       );
            
        }

        // [OferBar]
        // release the extra ref count that was added
        // in the case of a specific pattern, this might be a totally different
        // one, but it should still have the extra ref-count
        // if there was an error, this will release the pattern
        // REFDEL(&pPattern->RefCount, 'FILT');


        // [ShreeM]
        // A reference FILT is added to a filter on creation. This will be substituted by 'ADSP' or
        // 'ADGP' whether it was a Generic Pattern or a Specific Pattern. However, it is likely that
        // in the AddSpecificPattern function, the pPattern got changed to something else because a
        // filter already existed. We want to ensure that the tag subsitution happens only in the 
        // case where pPattern was not replaced with the existing pattern in AddSpecificPattern.
        // 
        REFDEL(&pCreatedPattern->RefCount, 'FILT');

        //
        // check if failure, and if so - release the pattern block
        //
        
        if (NT_SUCCESS(Status)) {

            //
            // fill the output handle
            //
            
            *pGpcPatternHandle = (GPC_HANDLE)pPattern;
        }

    } else {

        Status = GPC_STATUS_RESOURCES;
    }

    if (pBlob != NULL) {

        //
        // change the state back to ready, so others can work on this blob
        //

        pBlob->State = GPC_STATE_READY;
    }

    //
    // release the extra ref count
    //

    //NdisInterlockedDecrement(&pClient->RefCount);

    TRACE(PATTERN, pPattern, Status, "GpcAddPattern==>");
        
    if (NT_SUCCESS(Status)) {

        if (TEST_BIT_ON(Flags, PATTERN_SPECIFIC)) {

            ProtocolStatInc(ProtocolTemplate,
                            CreatedSp);
            ProtocolStatInc(ProtocolTemplate,
                            CurrentSp);

            NdisInterlockedIncrement(&pProtocolBlock->SpecificPatternCount);            
            
            ASSERT(pProtocolBlock->SpecificPatternCount > 0);

        } else {

            ProtocolStatInc(ProtocolTemplate,
                            CreatedGp);
            ProtocolStatInc(ProtocolTemplate,
                            CurrentGp);

            NdisInterlockedIncrement(&pProtocolBlock->GenericPatternCount);            
            
            ASSERT(pProtocolBlock->GenericPatternCount > 0);

        }

    } else {

        if (TEST_BIT_ON(Flags, PATTERN_SPECIFIC)) {
            
            ProtocolStatInc(ProtocolTemplate,
                            RejectedSp);

        } else {

            ProtocolStatInc(ProtocolTemplate,
                            RejectedGp);
        }        
    }

    //
    // Check if some requests got queued while we were in there.
    //
    
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    NDIS_LOCK(&glData.RequestListLock);
    
    if (!IsListEmpty(&glData.gRequestList)) {

        pLinkage = RemoveHeadList(&glData.gRequestList);

        NDIS_UNLOCK(&glData.RequestListLock);

        pRequest = CONTAINING_RECORD(pLinkage, REQUEST_BLOCK, Linkage);
        
        NdisSetEvent(&pRequest->RequestEvent);
        
    } else {

        NDIS_UNLOCK(&glData.RequestListLock);

    }

    return Status;
}



/*
************************************************************************

GpcAddCfInfoNotifyComplete -

A completion routine that the client will call after the GPC called into
the client's ClAddCfInfoNotify handler, but returned PENDING.
After all the clients have completed, a callback to the calling client's
ClAddCfInfoComplete is done to complete the GpcAddCfInfo call.

Arguments
	ClientHandle	- client handle
    GpcCfInfoHandle	- the blob handle
    Status			- completion status

Returns
	void

************************************************************************
*/
VOID
GpcAddCfInfoNotifyComplete(
	IN	GPC_HANDLE			ClientHandle,
    IN	GPC_HANDLE			GpcCfInfoHandle,
    IN	GPC_STATUS			Status,
	IN	GPC_CLIENT_HANDLE	ClientCfInfoContext
    )
{
    PCLIENT_BLOCK		pClient, pNotifyClient, pFirstClient;
    PBLOB_BLOCK			pBlob;
    //GPC_CLIENT_HANDLE	ClientCtx;
    //ULONG				cd;
    int                 i;
    GPC_STATUS          LastStatus, Status1;

	TRACE(BLOB, GpcCfInfoHandle, Status, "GpcAddCfInfoNotifyComplete");

    //VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);
    //VERIFY_OBJECT(GpcCfInfoHandle, GPC_ENUM_CFINFO_TYPE);

    pClient = (PCLIENT_BLOCK)ClientHandle;
    pBlob = (PBLOB_BLOCK)GpcCfInfoHandle;

    ASSERT(pBlob);
    ASSERT(pClient);
    ASSERT(Status != GPC_STATUS_PENDING);
    ASSERT(pBlob->ClientStatusCountDown > 0);

    if (NT_SUCCESS(Status)) {

        //
        // success reported, save the reporting client handle
        // so we can notify him to remove the blob in case of an error
        // down the road by another client for the same blob
        //

        ASSERT(pBlob->arpClientStatus[pClient->AssignedIndex] == NULL);

        pBlob->arpClientStatus[pClient->AssignedIndex] = pClient;

    } else {

        //
        // error reported, update the last status code.
        //

        pBlob->LastStatus = Status;

    }

    if (NdisInterlockedDecrement(&pBlob->ClientStatusCountDown) == 0) {
        
        //
        // all clients have reported
        //
        
        //
        // save the client's blob data, cuz it might get deleted
        // 

        //ClientCtx = pBlob->arClientCtx[pClient->AssignedIndex];
        LastStatus = pBlob->LastStatus;
        pFirstClient = pBlob->pOwnerClient;

        if (NT_ERROR(LastStatus)) {

            //
            // error has been previously reported by a client
            // tell each client that reported success to remove
            // the blob (sorry...)
            //

#if 0
            NDIS_LOCK(&pBlob->pOwnerClient->pCfBlock->Lock);
            
            GpcRemoveEntryList(&pBlob->CfLinkage);
            
            NDIS_DPR_LOCK(&pBlob->pOwnerClient->Lock);    
            GpcRemoveEntryList(&pBlob->ClientLinkage);
            NDIS_DPR_UNLOCK(&pBlob->pOwnerClient->Lock);

            NDIS_UNLOCK(&pBlob->pOwnerClient->pCfBlock->Lock);
#endif

            CTEInitBlockStruc(&pBlob->WaitBlockAddFailed);

            Status1 = GPC_STATUS_SUCCESS;

            for (i = 0; i < MAX_CLIENTS_CTX_PER_BLOB; i++) {
                
                //
                // only clients with none zero entries
                // have succefully installed the blob
                //
                
                if (pNotifyClient = pBlob->arpClientStatus[i]) {
                    
                    //
                    // notify each client to remove the blob
                    //
                    
                    if (ClientRemoveCfInfo
                        (
                         pNotifyClient,
                         pBlob,
                         pBlob->arClientCtx[pNotifyClient->AssignedIndex]
                         ) == GPC_STATUS_PENDING)

                        {
                            Status1 = GPC_STATUS_PENDING;

                        } else {

                            //DereferenceClient(pNotifyClient);
                        }
                }
                
            } // for
            
            if (Status1 == GPC_STATUS_PENDING) {

                //
                // Block on completion of all removals...
                //
                
                Status1 = CTEBlock(&pBlob->WaitBlockAddFailed);
                
            }

        } else {	// if (NT_ERROR(LastStats))...

            //
            // store the returned client context, since the call can be completed
            // before the notification handler returns.
            //

            pBlob->arClientCtx[pClient->AssignedIndex] = ClientCfInfoContext;

            //
            // add the blob to the CF and client lists
            //
            
            GpcInterlockedInsertTailList(&pBlob->pOwnerClient->BlobList, 
                                         &pBlob->ClientLinkage,
                                         &pBlob->pOwnerClient->Lock
                                         );
            GpcInterlockedInsertTailList(&pBlob->pOwnerClient->pCfBlock->BlobList, 
                                         &pBlob->CfLinkage,
                                         &pBlob->pOwnerClient->pCfBlock->Lock
                                         );
            
        }

        //
        // complete the request to the client
        //

        ClientAddCfInfoComplete(
                                pFirstClient, // first guy who made the call
                                pBlob,        // completing blob
                                LastStatus    // status
                                );
        
    }

    //
    // this will be done after the last client completes
    //

    //DereferenceClient(pClient);
}



/*
************************************************************************

GpcModifyCfInfo -

The client calls this to modify a blob. Each other client on the CF will
get notified. This routine returns PENDING and starts a working thread
to do the main job.

Arguments
	ClientHandle	- client handle
    GpcCfInfoHandle	- the handle of the blob to modify
    CfInfoSize		- new blob size
    pClientCfInfo	- new blob data pointer

Returns
	GPC_STATUS, PENDING is valid

************************************************************************
*/
GPC_STATUS
GpcModifyCfInfo(
	IN	GPC_HANDLE				ClientHandle,
    IN	GPC_HANDLE	    		GpcCfInfoHandle,
    IN	ULONG					CfInfoSize,
    IN  PVOID	    			pClientCfInfoPtr
    )
{
    GPC_STATUS			Status = GPC_STATUS_SUCCESS;
    GPC_STATUS          Status1;
    PCLIENT_BLOCK		pClient;
    PCLIENT_BLOCK		pNotifyClient;
    PCLIENT_BLOCK		pNotifyClient2;
    PBLOB_BLOCK			pBlob;
    PCF_BLOCK			pCf;
    PLIST_ENTRY			pEntry, pHead;
    int                 i;
    KIRQL				irql;

	TRACE(BLOB, ClientHandle, GpcCfInfoHandle, "GpcModifyCfInfo");

    VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);
    //VERIFY_OBJECT(GpcCfInfoHandle, GPC_ENUM_CFINFO_TYPE);

    ASSERT(pClientCfInfoPtr);

    //
    // cast the client handle to the block
    //

    pClient = (PCLIENT_BLOCK)ClientHandle;
    pBlob = (PBLOB_BLOCK)GpcCfInfoHandle;
    pCf = pClient->pCfBlock;

    ASSERT(pClient);
    ASSERT(pBlob);

    NDIS_LOCK(&pBlob->Lock);

    if (pBlob->ObjectType != GPC_ENUM_CFINFO_TYPE) {

        NDIS_UNLOCK(&pBlob->Lock);
        return GPC_STATUS_INVALID_PARAMETER;
    }

    //
    // check the blob is in READY state and change it to MODIFY state
    //

    if (pBlob->State != GPC_STATE_READY) {

        NDIS_UNLOCK(&pBlob->Lock);
        return GPC_STATUS_NOTREADY;
    }

    //
    // allocate private memory in the GPC to copy the client's data
    // into
    //

    GpcAllocMem(&pBlob->pNewClientData, CfInfoSize, CfInfoDataTag);

    if (pBlob->pNewClientData == NULL) {

        NDIS_UNLOCK(&pBlob->Lock);
        return GPC_STATUS_RESOURCES;
    }

    pBlob->NewClientDataSize = CfInfoSize;
    pBlob->State = GPC_STATE_MODIFY;

    //
    // we set the calling client here so we can notify it when the 
    // the modification is completed
    //

    pBlob->pCallingClient = pClient;

    NDIS_UNLOCK(&pBlob->Lock);

#if NO_USER_PENDING

    //
    // this will be only required until we implement the user level
    // pending report
    //
    
    CTEInitBlockStruc(&pBlob->WaitBlock);
    
#endif

    //
    // copy the memory
    //
    
    RtlMoveMemory(pBlob->pNewClientData, pClientCfInfoPtr, CfInfoSize);

    //
    // init the client status array to keep track
    // of how many client have succeeded so far
    //
    
    //RtlZeroMemory(pBlob->arpClientStatus, sizeof(pBlob->arpClientStatus));
    pBlob->ClientStatusCountDown = 0;
    pBlob->LastStatus = GPC_STATUS_SUCCESS;

    //
    // notify each client
    //
    
    //NDIS_LOCK(&pCf->Lock);

    RSC_READ_LOCK(&pCf->ClientSync, &irql);
    
    pHead = &pCf->ClientList;
    pEntry = pHead->Flink;
    
    while (pEntry != pHead && (Status == GPC_STATUS_SUCCESS || 
                               Status == GPC_STATUS_PENDING)) {

        //
        // get the notified client block
        //
        
        pNotifyClient = CONTAINING_RECORD(pEntry, CLIENT_BLOCK, ClientLinkage);
        
        if (pNotifyClient != pClient 
            &&
            pBlob->arpClientStatus[pNotifyClient->AssignedIndex]
            && 
            !IS_USERMODE_CLIENT(pNotifyClient) ) {

            //
            // don't notify the caller
            //

            REFADD(&pNotifyClient->RefCount, 'CFMF');
       
            //
            // okay, we have bumped the ref count for this
            // client. No need to keep the lock 
            //

            //NDIS_UNLOCK(&pCf->Lock);
            RSC_READ_UNLOCK(&pCf->ClientSync, irql);
            
            //
            // increase number of count down clients,
            // so we keep track how many clients are still
            // pending. We do it *before* the call, since
            // the completion might be called before the notification
            // returns.
            //
                
            Status1 = ClientModifyCfInfo
                (pNotifyClient,
                 pBlob,
                 CfInfoSize,
                 pBlob->pNewClientData
                 );

            TRACE(BLOB, pBlob, Status1, "GpcModifyCfInfo: (client)");

            //
            // grab the lock again since we're walking the list
            //
            
            //NDIS_LOCK(&pCf->Lock);
                
            //
            // now we check the Status1 code
            // the rules are:
            //  we stop on failure
            //  ignore GPC_STATUS_IGNORE
            //  and save PENDING status
            // 

            if (Status1 == GPC_STATUS_PENDING
                       && 
                       !NT_SUCCESS(pBlob->LastStatus)) {

                //
                // we've got back pending, but the client
                // actually completed the request
                // behind our back
                //

                Status = GPC_STATUS_PENDING;

                REFDEL(&pNotifyClient->RefCount, 'CFMF');

                RSC_READ_LOCK(&pCf->ClientSync, &irql);

                break;
                
            } else if (!NT_SUCCESS(Status1)) {
                    
                //
                // don't notify other clients
                //

                pBlob->LastStatus = Status = Status1;

                REFDEL(&pNotifyClient->RefCount, 'CFMF');

                RSC_READ_LOCK(&pCf->ClientSync, &irql);
                
                break;
                
            } else if (Status1 == GPC_STATUS_SUCCESS
                       ||
                       Status1 == GPC_STATUS_PENDING) {

                pBlob->arpClientStatus[pNotifyClient->AssignedIndex] = 
                    pNotifyClient;

                if (Status1 == GPC_STATUS_PENDING) {
                    Status = GPC_STATUS_PENDING;
                }

            }

            RSC_READ_LOCK(&pCf->ClientSync, &irql);

            pEntry = pEntry->Flink;

            if (pEntry != pHead) {
                
                pNotifyClient2 = CONTAINING_RECORD(pEntry, 
                                                   CLIENT_BLOCK, 
                                                   ClientLinkage);
                
                REFADD(&pNotifyClient2->RefCount, 'CFMF');

            }

            //
            // release the list lock since the next call will try to get it
            //
            
            RSC_READ_UNLOCK(&pCf->ClientSync, irql);
            
            REFDEL(&pNotifyClient->RefCount, 'CFMF');

            RSC_READ_LOCK(&pCf->ClientSync, &irql);
            
            if (pEntry != pHead) {
                
                //
                // safe to do since the list is locked
                //
                REFDEL(&pNotifyClient2->RefCount, 'CFMF');
                
            }
            
        } else {   // if (pNotifyClient != pClient)
        
            //
            // grab the next client block, 
            //
            
            pEntry = pEntry->Flink;

        }

    } // while
    
    
    //
    // release the CF lock still got
    //

    //NDIS_UNLOCK(&pCf->Lock);
    RSC_READ_UNLOCK(&pCf->ClientSync, irql);

    //
    // Status code should be either:
    //
    // GPC_STATUS_SUCCESS - all clients have been notified and returned SUCCESS
    // GPC_STATUS_PENDING - all clients have been notified, at least one
    //						return PENDING
    // Error code - at least one client failed
    //

    if (Status != GPC_STATUS_PENDING) {

        //
        // Note: the status here can be either FAILED or SUCCESS
        //
        // no client has been pending, so we complete the modification
        // back to the clients (except the caling client)
        //

        ModifyCompleteClients(pClient, pBlob);

        //
        // restore READY state
        //

        pBlob->State = GPC_STATE_READY;

    }

	TRACE(BLOB, pBlob, Status, "GpcModifyCfInfo==>");

    if (NT_SUCCESS(Status)) {

        CfStatInc(pCf->AssignedIndex,ModifiedBlobs);
        
    }

    return Status;
}





/*
************************************************************************

GpcModifyCfInfoNotifyComplete -

Called by clients to complete a previous call to ClModifyCfInfoNotify
made by the GPC.


Arguments
	ClientHandle	- client handle
    GpcCfInfoHandle	- the blob handle
    Status			- completion status

Returns
	GPC_STATUS

************************************************************************
*/
VOID
GpcModifyCfInfoNotifyComplete(
	IN	GPC_HANDLE		ClientHandle,
    IN	GPC_HANDLE		GpcCfInfoHandle,
    IN	GPC_STATUS		Status
    )
{
    PCLIENT_BLOCK		pClient, pNotifyClient;
    PBLOB_BLOCK			pBlob;

	TRACE(BLOB, GpcCfInfoHandle, Status, "GpcModifyCfInfoNotifyComplete");

    //VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);
    //VERIFY_OBJECT(GpcCfInfoHandle, GPC_ENUM_CFINFO_TYPE);

    pClient = (PCLIENT_BLOCK)ClientHandle;
    pBlob = (PBLOB_BLOCK)GpcCfInfoHandle;

    ASSERT(pBlob);
    ASSERT(pClient);
    ASSERT(Status != GPC_STATUS_PENDING);
    ASSERT(pBlob->ClientStatusCountDown > 0);

    if (NT_SUCCESS(Status)) {

        //
        // success reported, save the reporting client handle
        // so we can notify him to remove the blob in case of an error
        // down the road by another client for the same blob
        //

        ASSERT(pBlob->arpClientStatus[pClient->AssignedIndex] == pClient);

        //pBlob->arpClientStatus[pClient->AssignedIndex] = pClient;
        
    } else {

        //
        // error reported, update the last status code.
        //

        pBlob->LastStatus = Status;

    }

    if (NdisInterlockedDecrement(&pBlob->ClientStatusCountDown) == 0) {
        
        //
        // all clients have reported
        //
        
        ModifyCompleteClients(pClient, pBlob);

#if NO_USER_PENDING

        //
        // the user is blocking on this call
        //

        CTESignal(&pBlob->WaitBlock, Status);

#else
            
        //
        // now, complete the call back to the calling client
        //

        ClientModifyCfInfoComplete(
                                   pBlob->pCallingClient,
                                   pBlob,
                                   pBlob->LastStatus
                                   );

        pBlob->State = GPC_STATE_READY;

#endif
        
    }

	TRACE(BLOB, pClient, Status, "GpcModifyCfInfoNotifyComplete==>");
}




/*
************************************************************************

privateGpcRemoveCfInfo - 

Remove a blob from GPC. 


Arguments
	ClientHandle	- client handle
    GpcCfInfoHandle	- blob handle

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
privateGpcRemoveCfInfo(
	IN	GPC_HANDLE		ClientHandle,
    IN	GPC_HANDLE		GpcCfInfoHandle,
    IN   ULONG			Flags
    )
{
    GPC_STATUS	    Status = GPC_STATUS_SUCCESS;
    GPC_STATUS      Status1;
    PCLIENT_BLOCK   pClient;
    PCLIENT_BLOCK   pNotifyClient;
    PCLIENT_BLOCK   pNotifyClient2;
    PBLOB_BLOCK     pBlob;
    PCF_BLOCK       pCf;
    PPATTERN_BLOCK	pPattern;
    PLIST_ENTRY     pHead, pEntry;
    KIRQL			irql;
    PPROTOCOL_BLOCK pProtocol;
    ULONG           cClientRef;

	TRACE(BLOB, ClientHandle, GpcCfInfoHandle, "privateGpcRemoveCfInfo");

    VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);
    
    pClient = (PCLIENT_BLOCK)ClientHandle;
    pBlob   = (PBLOB_BLOCK)GpcCfInfoHandle;
    pCf     = pClient->pCfBlock;

    NDIS_LOCK(&pBlob->Lock);

    if (pBlob->ObjectType != GPC_ENUM_CFINFO_TYPE) {

        NDIS_UNLOCK(&pBlob->Lock);
        return GPC_STATUS_INVALID_PARAMETER;
    }


    if (pBlob->State != GPC_STATE_READY) {

        if (pBlob->pCallingClient2) {

            //
            // Can't handle more than 2 removals for the 
            // same flow.
            // another client has already requested the removal of 
            // this flow, we should fail here
            //

            NDIS_UNLOCK(&pBlob->Lock);

            TRACE(BLOB, GPC_STATUS_NOTREADY, 0, "privateGpcRemoveCfInfo==>");
            
            return GPC_STATUS_NOTREADY;

        }
         
        //
        // the flow is being removed when another client
        // requested its removal. we save this client handle
        // and we'll coplete it later
        //
        
        pBlob->pCallingClient2 = pClient;
    
        NDIS_UNLOCK(&pBlob->Lock);
        
        TRACE(BLOB, GPC_STATUS_PENDING, 0, "privateGpcRemoveCfInfo==>");
        
        return GPC_STATUS_PENDING;
    }
    
    //
    // remove the supported patterns on the cfinfo
    // there are two cases:
    //
    // 1. from a user - traffic.dll requires that ALL the filters
    //	  would have been deleted, therefore this case is a nop.
    //
    // 2. from a kernel client - in this case we MUST remove the 
    //    patterns before proceesing to delete the cfinfo,
    //    since we can't rely on traffic.dll to do it
    //

    //
    // grab a refcount on this blob so it doesn't go away due
    // to some funky client that decides to complete before
    // it return any status code (and most of them do!)
    // this should be released before we exit the routine,
    // so that the blob may actually go away on the last deref
    //

    REFADD(&pBlob->RefCount, 'RMCF');

    //
    // set the removing client
    //
    
    pBlob->pCallingClient = pClient;
    

    //
    // don't allow the user mode owner client to remove this flow
        // if there are any patterns on it....
    // ...unless the REMOVE_CB_BLOB bit ahs been set,
    // for example: when the calling process dies
    //

    if (!IsListEmpty(&pBlob->PatternList) &&
        TEST_BIT_ON(pClient->Flags, GPC_FLAGS_USERMODE_CLIENT) &&
        (pClient == pBlob->pOwnerClient) &&
         TEST_BIT_OFF(pBlob->Flags, PATTERN_REMOVE_CB_BLOB)
       )
    {

        NDIS_UNLOCK(&pBlob->Lock);

        return GPC_STATUS_NOT_EMPTY;
    
    } else {

        //
        // Since we have decided to remove the patterns, we should
        // mark this as invalid
        //

        pBlob->ObjectType = GPC_ENUM_INVALID;
    }

    while (!IsListEmpty(&pBlob->PatternList)) {

        pPattern = CONTAINING_RECORD(pBlob->PatternList.Flink,
                                     PATTERN_BLOCK,
                                     BlobLinkage[pCf->AssignedIndex]);

        NDIS_DPR_LOCK(&pPattern->Lock);

        REFADD(&pPattern->RefCount, 'RMCF');

        pPattern->State = GPC_STATE_FORCE_REMOVE;
        
        //
        // If it is an AUTO PATTERN, remove it from the list and 
        // unset the flag.
        //
        if (TEST_BIT_ON( pPattern->Flags, PATTERN_AUTO)) {
    
            pProtocol = &glData.pProtocols[pPattern->ProtocolTemplate];
            
            pPattern->Flags |= ~PATTERN_AUTO;

            NDIS_DPR_LOCK(&pProtocol->PatternTimerLock[pPattern->WheelIndex]);
    
            GpcRemoveEntryList(&pPattern->TimerLinkage);
    
            NDIS_DPR_UNLOCK(&pProtocol->PatternTimerLock[pPattern->WheelIndex]);
                
            InitializeListHead(&pPattern->TimerLinkage);
            
            NDIS_DPR_UNLOCK(&pPattern->Lock);

            NDIS_UNLOCK(&pBlob->Lock);

            privateGpcRemovePattern(ClientHandle, (GPC_HANDLE)pPattern, TRUE);        

            InterlockedDecrement(&pProtocol->AutoSpecificPatternCount);

        } else {

            NDIS_DPR_UNLOCK(&pPattern->Lock);
            NDIS_UNLOCK(&pBlob->Lock);

        }
        
        privateGpcRemovePattern(ClientHandle, (GPC_HANDLE)pPattern, TRUE);        
        
        REFDEL(&pPattern->RefCount, 'RMCF');

        NDIS_LOCK(&pBlob->Lock);
    }


    //
    // set the state
    //
    
    pBlob->State = GPC_STATE_REMOVE;

    NDIS_UNLOCK(&pBlob->Lock);

#if NO_USER_PENDING

    //
    // this will be only required until we implement the user level
    // pending report
    //
    
    CTEInitBlockStruc(&pBlob->WaitBlock);
    
#endif


    SuspendHandle(pBlob->ClHandle);

    //
    // init the client status array to keep track
    // of how many client have succeeded so far
    //
        
    //RtlZeroMemory(pBlob->arpClientStatus, sizeof(pBlob->arpClientStatus));
    pBlob->ClientStatusCountDown = 0;
    pBlob->LastStatus = GPC_STATUS_SUCCESS;

    //
    // notify each client
    //

    NDIS_LOCK(&pCf->Lock);
    GpcRemoveEntryList(&pBlob->CfLinkage);
    NDIS_UNLOCK(&pCf->Lock);

    //NDIS_LOCK(&pClient->Lock);    

    RSC_READ_LOCK(&pCf->ClientSync, &irql);
    
    NDIS_LOCK(&pClient->Lock);
    GpcRemoveEntryList(&pBlob->ClientLinkage);
    NDIS_UNLOCK(&pClient->Lock);

    //NDIS_UNLOCK(&pClient->Lock);

    //
    // the blob is not on the CF or on the client list
    // okay to change the object type so further handle lookup will fail
    //

    pHead = &pCf->ClientList;
    pEntry = pHead->Flink;
    
    while (pEntry != pHead && (Status == GPC_STATUS_SUCCESS || 
                               Status == GPC_STATUS_PENDING)) {

        //
        // get the notified client block
        //
        
        pNotifyClient = CONTAINING_RECORD(pEntry, CLIENT_BLOCK, ClientLinkage);
        
        if (pNotifyClient != pClient
            &&
            pBlob->arpClientStatus[pNotifyClient->AssignedIndex] ) {

            //
            // don't notify the caller
            //
            
            REFADD(&pNotifyClient->RefCount, 'PRCF');

            //NDIS_UNLOCK(&pCf->Lock);
            RSC_READ_UNLOCK(&pCf->ClientSync, &irql);

            Status1 = ClientRemoveCfInfo
                (pNotifyClient,
                 pBlob,
                 pBlob->arClientCtx[pNotifyClient->AssignedIndex]
                 );
            
            TRACE(BLOB, pBlob, Status, "privateGpcRemoveCfInfo: (client)");

            RSC_READ_LOCK(&pCf->ClientSync, &irql);

            if (Status1 == GPC_STATUS_PENDING) {
                                
                Status = GPC_STATUS_PENDING;
              
            } else {

                if (NT_ERROR(Status1)) {
                
                    Status = pBlob->LastStatus = Status1;
                
                } else {
                    
                    //
                    // status success
                    //
                
                    pBlob->arpClientStatus[pNotifyClient->AssignedIndex] = 
                        pNotifyClient;

                    NDIS_DPR_LOCK(&pBlob->Lock);

                    if (pNotifyClient == pBlob->pNotifiedClient) {

                        pBlob->pNotifiedClient = NULL;
                        pBlob->NotifiedClientCtx = NULL;
                    }

                    NDIS_DPR_UNLOCK(&pBlob->Lock);

                }
                
                //
                // not pending - no need to hold the ref count to this client
                //

                //DereferenceClient(pNotifyClient);
            }
            
            //
            // advance to the next client block, and release the ref count
            // for this client
            //
            
            //NDIS_LOCK(&pCf->Lock);

            pEntry = pEntry->Flink;

            if (pEntry != pHead) {
                
                pNotifyClient2 = CONTAINING_RECORD(pEntry, 
                                                   CLIENT_BLOCK, 
                                                   ClientLinkage);
                
                REFADD(&pNotifyClient2->RefCount, 'PRCF');

            }

            //
            // release the list lock since the next call will try to get it
            //
            
            RSC_READ_UNLOCK(&pCf->ClientSync, irql);
            
            REFDEL(&pNotifyClient->RefCount, 'PRCF');

            RSC_READ_LOCK(&pCf->ClientSync, &irql);

            if (pEntry != pHead) {
                
                //
                // safe to do since the list is locked
                //
                
                REFDEL(&pNotifyClient2->RefCount, 'PRCF');
            }

        } else {      // if (pNotifyClient != pClient)
            
            pEntry = pEntry->Flink;
        }
        
    } // while
        
    //NDIS_UNLOCK(&pCf->Lock);

    RSC_READ_UNLOCK(&pCf->ClientSync, irql);

    if (Status != GPC_STATUS_PENDING) {

        NDIS_LOCK(&pBlob->Lock);

        //
        // notify any pending client about the status
        //
        
        if (pClient = pBlob->pCallingClient2) {

            pClient = pBlob->pCallingClient2;
            pBlob->pCallingClient2 = NULL;

            NDIS_UNLOCK(&pBlob->Lock);

            //
            // complete the request to this client
            //
            
            ClientRemoveCfInfoComplete
                (
                 pClient,  			// the guy who made the call
                 pBlob,             // completing blob
                 Status        		// status
                 );
            
            //pBlob->pCallingClient2 = NULL;

        } else {

            NDIS_UNLOCK(&pBlob->Lock);
        }

        if (Status != GPC_STATUS_SUCCESS) {

            //
            // failed to remove the blob
            //

            pBlob->State = GPC_STATE_READY;
            pBlob->ObjectType = GPC_ENUM_CFINFO_TYPE;

            //
            // resume the suspended handle
            //

            ResumeHandle(pBlob->ClHandle);
        }
    }

    if (Status == GPC_STATUS_SUCCESS) {
        
        //
        // release the mapping handle 
        //
        
        FreeHandle(pBlob->ClHandle);
        
        //
        // all done, we can remove the blob from memory
        //
        
        REFDEL(&pBlob->RefCount, 'BLOB');
        
        CfStatInc(pCf->AssignedIndex,DeletedBlobs);
        CfStatDec(pCf->AssignedIndex,CurrentBlobs);
    }           

    //
    // release the extra refcount we got in the begining
    // this is to avoid the problem of the blob going away,
    // since some clients may complete the remove before we get
    // here, and this will cause the blob structure to be released
    // it's not a pretty sight....
    //

    REFDEL(&pBlob->RefCount, 'RMCF');
    
    TRACE(BLOB, Status, 0, "privateGpcRemoveCfInfo==>");

    return Status;
}




/*
************************************************************************

GpcRemoveCfInfo - 

	This must have been called from kernel. We simply pass the call
    to the private routine with Flags=0.


Arguments
	ClientHandle	- client handle
    GpcCfInfoHandle	- blob handle

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GpcRemoveCfInfo(
	IN	GPC_HANDLE		ClientHandle,
    IN	GPC_HANDLE		GpcCfInfoHandle
    )
{

    return privateGpcRemoveCfInfo(
                                  ClientHandle,
                                  GpcCfInfoHandle,
                                  0
                                  );
}




/*
************************************************************************

GpcRemoveCfInfoNotifyComplete -

Called by clients who are completing a ClRemoveCfInfoNotify that was PENDING.
This may have been called for two reasons:
1. A client issued a GpcRemoveCfInfo request.
2. A client issued a GpcAddCfInfo request, but one of the other clients
   failed, so we are removing the successfully installed blobs.

Arguments
	ClientHandle	- client handle
    GpcCfInfoHandle	- the blob handle
    Status			- completion status

Returns
	void

************************************************************************
*/
VOID
GpcRemoveCfInfoNotifyComplete(
	IN	GPC_HANDLE		ClientHandle,
    IN	GPC_HANDLE		GpcCfInfoHandle,
    IN	GPC_STATUS		Status
    )
{
    PCLIENT_BLOCK		pClient;
    PBLOB_BLOCK			pBlob;
    PCLIENT_BLOCK		pClient2;

	TRACE(BLOB, GpcCfInfoHandle, Status, "GpcRemoveCfInfoNotifyComplete");

    //VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);
    //VERIFY_OBJECT(GpcCfInfoHandle, GPC_ENUM_CFINFO_TYPE);

    pClient = (PCLIENT_BLOCK)ClientHandle;
    pBlob = (PBLOB_BLOCK)GpcCfInfoHandle;

    ASSERT(pBlob);
    ASSERT(pClient);
    ASSERT(Status != GPC_STATUS_PENDING);
    ASSERT(pBlob->ClientStatusCountDown > 0);

    if (!NT_ERROR(pBlob->LastStatus) || NT_ERROR(Status)) {

        //
        // save the last error code
        //

        pBlob->LastStatus = Status;
    }

    NDIS_LOCK(&pBlob->Lock);
    
    if (Status == GPC_STATUS_SUCCESS && pClient == pBlob->pNotifiedClient) {
        
        pBlob->pNotifiedClient = NULL;
        pBlob->NotifiedClientCtx = NULL;
    }
    
    NDIS_UNLOCK(&pBlob->Lock);

    if (NdisInterlockedDecrement(&pBlob->ClientStatusCountDown) == 0) {

        if (pBlob->State == GPC_STATE_REMOVE) {
            
            if (pBlob->pCallingClient->State == GPC_STATE_READY) {

                //
                // complete the request to the client
                //
                
                ClientRemoveCfInfoComplete
                    (
                     pBlob->pCallingClient,   // first guy who made the call
                     pBlob,                   // completing blob
                     pBlob->LastStatus        // status
                     );

                NDIS_LOCK(&pBlob->Lock);

                //
                // notify any pending client about the status
                //
                
                if (pClient2 = pBlob->pCallingClient2) {

                    pBlob->pCallingClient2 = NULL;

                    NDIS_UNLOCK(&pBlob->Lock);

                    //
                    // complete the request to this client
                    //
                    
                    ClientRemoveCfInfoComplete
                        (
                         pClient2,  			// the guy who made the call
                         pBlob,                 // completing blob
                         pBlob->LastStatus		// status
                         );
                } else {

                    NDIS_UNLOCK(&pBlob->Lock);
                }
                
                //pBlob->State = GPC_STATE_READY;

                if (pBlob->LastStatus == GPC_STATUS_SUCCESS) {

                    //
                    // release the mapping handle 
                    //
                    
                    FreeHandle(pBlob->ClHandle);
                    
                    //
                    // all clients have reported
                    // remove the blob
                    //
                
                    REFDEL(&pBlob->RefCount, 'BLOB');
                    //DereferenceBlob(&pBlob);

                } else {

                    //
                    // blob not removed - restore the object type
                    //

                    pBlob->ObjectType = GPC_ENUM_CFINFO_TYPE;

                    //
                    // resume the mapping handle
                    //
                    
                    ResumeHandle(pBlob->ClHandle);
                }
            }

        } else { // if (pBlob->State....)

            //
            // we are removing the blob since we failed to add it
            // to ALL clients.
            //

            ASSERT(pBlob->State == GPC_STATE_ADD);

            //
            // Release the AddFailed block so that the AddComplete
            // will resume
            //

            CTESignal(&pBlob->WaitBlockAddFailed, pBlob->LastStatus);
            
        }
    }

    //
    // release the one we got earlier
    //

    //DereferenceClient(pClient);

	TRACE(BLOB, 0, 0, "GpcRemoveCfInfoNotifyComplete==>");
}




/*
************************************************************************

GpcRemovePattern -

Called by the client to remove a pattern from the database.

Arguments
	ClientHandle		- client handle
    GpcPatternHandle	- pattern handle

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GpcRemovePattern(
	IN	GPC_HANDLE		ClientHandle,
    IN	GPC_HANDLE		GpcPatternHandle
    )
{

    return(privateGpcRemovePattern(
                            ClientHandle,
                            GpcPatternHandle,
                            FALSE
                            ));

}


/*
************************************************************************

privateGpcRemovePattern -

Internal call in the GPC to indicate whether this is forceful removal.

Arguments
	ClientHandle		- client handle
    GpcPatternHandle	- pattern handle

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
privateGpcRemovePattern(
	IN	GPC_HANDLE		ClientHandle,
    IN	GPC_HANDLE		GpcPatternHandle,
    IN  BOOLEAN         ForceRemoval
    )
{

    GPC_STATUS	    Status = GPC_STATUS_SUCCESS;
    PPATTERN_BLOCK  pPattern;
    PCLIENT_BLOCK   pClient;
    PPROTOCOL_BLOCK pProtocol;
    ULONG           Flags;
    ULONG			CfIndex;
    ULONG			ProtocolId;

	TRACE(PATTERN, ClientHandle, GpcPatternHandle, "GpcRemovePattern");

    DBGPRINT(PATTERN, ("GpcRemovePattern: Client=%X Pattern=%X\n", 
                       ClientHandle, GpcPatternHandle));

    VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);
    VERIFY_OBJECT(GpcPatternHandle, GPC_ENUM_PATTERN_TYPE);

    pClient = (PCLIENT_BLOCK)ClientHandle;
    pPattern = (PPATTERN_BLOCK)GpcPatternHandle;

    ASSERT(pClient);
    ASSERT(pPattern);

    CfIndex = pClient->pCfBlock->AssignedIndex;
    ProtocolId = pPattern->ProtocolTemplate;
    pProtocol = &glData.pProtocols[ProtocolId];

    //
    // If the pattern has already been removed by the ADAPTER (mostly WAN link)
    // going down, just return with an error. The memory is valid since the 
    // ProxyRemovePattern function added a REF.
    // 
    NDIS_LOCK(&pPattern->Lock);

    if (!ForceRemoval && (pPattern->State != GPC_STATE_READY)) {

        NDIS_UNLOCK(&pPattern->Lock);
        
        return GPC_STATUS_INVALID_HANDLE;

    } else {
        
        NDIS_UNLOCK(&pPattern->Lock);

    }

	//
	// determine weather its a specific or generic pattern
	//

    Flags = pPattern->Flags;

    if (TEST_BIT_ON(Flags, PATTERN_SPECIFIC)) {

        //
        // this is a specific pattern, call the appropriate routine
        // to remove from db
        //

        Status = RemoveSpecificPattern(
                                       pClient,
                                       pProtocol,
                                       pPattern,
                                       ForceRemoval
                                       );
    } else {

        //
        // this is a generic pattern, call the appropriate routine
        // to remove from db
        //

        Status = RemoveGenericPattern(
                                      pClient,
                                      pProtocol,
                                      pPattern
                                      );
    }

	TRACE(PATTERN, Status, 0, "GpcRemovePattern==>");

    if (NT_SUCCESS(Status)) {

        if (TEST_BIT_ON(Flags, PATTERN_SPECIFIC)) {

            ProtocolStatInc(ProtocolId,DeletedSp);
            ProtocolStatDec(ProtocolId,CurrentSp);

            NdisInterlockedDecrement(&pProtocol->SpecificPatternCount);            
            

        } else {

            ProtocolStatInc(ProtocolId,DeletedGp);
            ProtocolStatDec(ProtocolId,CurrentGp);

            NdisInterlockedDecrement(&pProtocol->GenericPatternCount);            
            

        }

    }

    DBGPRINT(PATTERN, ("GpcRemovePattern: Client=%X Pattern=%X, Status=%X\n", 
                       ClientHandle, GpcPatternHandle,Status));

    return Status;
}




/*
************************************************************************

GpcClassifyPattern -

Called by the client to classify a pattern and get back a client blob
context and a classification handle.

Arguments
	ClientHandle			- client handle
    ProtocolTemplate		- the protocol template to use
    pPattern				- pointer to pattern
    pClientCfInfoContext	- OUT, the client's blob context
    pClassificationHandle	- OUT, classification handle

Returns
	GPC_STATUS: GPC_STATUS_NOT_FOUND

************************************************************************
*/
GPC_STATUS
GpcClassifyPattern(
	IN		GPC_HANDLE				ClientHandle,
    IN		ULONG					ProtocolTemplate,
    IN		PVOID			        pPattern,
    OUT		PGPC_CLIENT_HANDLE		pClientCfInfoContext,	// optional
    IN OUT	PCLASSIFICATION_HANDLE	pClassificationHandle,
    IN		ULONG					Offset,
    IN		PULONG					pValue,
    IN		BOOLEAN					bNoCache
    )
{
    GPC_STATUS		Status;
    PPATTERN_BLOCK	pPatternBlock;
    PCLIENT_BLOCK	pClient;
    PPROTOCOL_BLOCK	pProtocol;
    PGPC_IP_PATTERN	pIp = (PGPC_IP_PATTERN)pPattern;
    KIRQL           CHirql;
    PBLOB_BLOCK     pBlob;

	TRACE(CLASSIFY, ClientHandle, *pClassificationHandle, "GpcClassifyPattern<==");

    VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);

    ASSERT(ClientHandle);
    ASSERT(pPattern);
    //ASSERT(pClientCfInfoContext);
    ASSERT(pClassificationHandle);

    Status = GPC_STATUS_SUCCESS;

    if (ProtocolTemplate >= GPC_PROTOCOL_TEMPLATE_MAX) {

        return GPC_STATUS_INVALID_PARAMETER;
    }

    pProtocol = &glData.pProtocols[ProtocolTemplate];

    //
    // Optimization - check if there are any patterns installed
    //

    if (pProtocol->SpecificPatternCount == 0 
        &&
        pProtocol->GenericPatternCount == 0 ) {
        
        if (pClientCfInfoContext) {
            *pClientCfInfoContext = NULL;
        }
        *pClassificationHandle = (CLASSIFICATION_HANDLE)0;

        DBGPRINT(CLASSIFY, ("GpcClassifyPattern: Client=%X no patterns returned %X\n", 
                            ClientHandle, GPC_STATUS_NOT_FOUND));

        TRACE(CLASSIFY, ClientHandle, GPC_STATUS_NOT_FOUND, "GpcClassifyPattern (1)" );

        return GPC_STATUS_NOT_FOUND;
    }

    pClient = (PCLIENT_BLOCK)ClientHandle;

    if (ProtocolTemplate == GPC_PROTOCOL_TEMPLATE_IP) {

        pIp = (PGPC_IP_PATTERN)pPattern;
        pIp->Reserved[0] = pIp->Reserved[1] = pIp->Reserved[2] = 0;

        DBGPRINT(CLASSIFY, ("GpcClassifyPattern: Client=%X, CH=%d\n", 
                            ClientHandle, *pClassificationHandle));
        DBGPRINT(CLASSIFY, ("IP: ifc={%d,%d} src=%08X:%04x, dst=%08X:%04x, prot=%d rsv=%x,%x,%x\n", 
                            pIp->InterfaceId.InterfaceId,
                            pIp->InterfaceId.LinkId,
                            pIp->SrcAddr,
                            pIp->gpcSrcPort,
                            pIp->DstAddr,
                            pIp->gpcDstPort,
                            pIp->ProtocolId,
                            pIp->Reserved[0],
                            pIp->Reserved[1],
                            pIp->Reserved[2]
                            ));
    }

    ProtocolStatInc(ProtocolTemplate, ClassificationRequests);

    //
    // verify the classification handle, if it's valid, simply return
    //

    if (*pClassificationHandle && (pClientCfInfoContext || pValue)) {

        Status = GetClientCtxAndUlongFromCfInfo(ClientHandle,
                                                pClassificationHandle,
                                                pClientCfInfoContext,
                                                Offset,
                                                pValue
                                                );

        ProtocolStatInc(ProtocolTemplate, PatternsClassified);

        DBGPRINT(CLASSIFY, ("GpcClassifyPattern: Client=%X returned immediate CH %d\n", 
                            pClient, *pClassificationHandle));

        TRACE(CLASSIFY, pClient, *pClassificationHandle, "GpcClassifyPattern (2)" );

        return Status;
    }

    //
    // there pattern needs to be classified
    // this should find the classification handle
    //

    Status = InternalSearchPattern(
                                    pClient, 
                                    pProtocol, 
                                    pPattern,
                                    &pPatternBlock,
                                    pClassificationHandle,
                                    bNoCache
                                    );
    
    if (*pClassificationHandle && (pClientCfInfoContext || pValue)) {

        Status = GetClientCtxAndUlongFromCfInfo(ClientHandle,
                                                pClassificationHandle,
                                                pClientCfInfoContext,
                                                Offset,
                                                pValue
                                                );

    } else if ((!NT_SUCCESS(Status)) && 
                pPatternBlock && 
                pClientCfInfoContext) {
        // it is likely that we could not allocate the Auto Specific pattern
        // just try to send the context anyway.

        READ_LOCK(&glData.ChLock, &CHirql);
        
        pBlob = GetBlobFromPattern(pPatternBlock, GetCFIndexFromClient(ClientHandle));

        if(pBlob) {

            *pClientCfInfoContext = pBlob->arClientCtx[GetClientIndexFromClient(ClientHandle)];

        } else {

            Status = GPC_STATUS_NOT_FOUND;

        }

        READ_UNLOCK(&glData.ChLock, CHirql); 

    } else if (!*pClassificationHandle) {

        //
        // none found, 
        //

        if (pClientCfInfoContext) {
            *pClientCfInfoContext = NULL;
        }

        Status = GPC_STATUS_NOT_FOUND;
    
    } else {

        Status = GPC_STATUS_SUCCESS;

    }

    if (pPatternBlock) {

        //DereferencePattern(pPatternBlock, pClient->pCfBlock);

        ProtocolStatInc(ProtocolTemplate, PatternsClassified);
    }

	TRACE(CLASSIFY, pPatternBlock, Status, "GpcClassifyPattern==>");

    DBGPRINT(CLASSIFY, ("GpcClassifyPattern: Client=%X returned Pattern=%X, CH=%d, Status=%X\n", 
                        pClient, pPattern, *pClassificationHandle, Status));
    return Status;
}



/*
************************************************************************

GpcClassifyPacket -

Called by the client to classify a packet and get back a client blob
context and a classification handle.
Content is extracted from the packet and placed into a protocol specific
structure (IP).
For IP, if fragmentation is ON for the client:
   o First fragment will create a hash table entry
   o Other fragments will be looked in the hash by the packet ID
   o Last fragment will cause entry to be deleted.

Arguments
	ClientHandle			- client handle
    ProtocolTemplate		- the protocol template
    pNdisPacket				- ndis packet
    TransportHeaderOffset	- byte offset of the start of the transport
							  header from the beginning of the packet
    pClientCfInfoContext	- OUT, client blob context
    pClassificationHandle	- OUT, classification handle

Returns
	GPC_STATUS

************************************************************************
*/

GPC_STATUS
GpcClassifyPacket(
	IN	GPC_HANDLE				ClientHandle,
    IN	ULONG					ProtocolTemplate,
    IN	PVOID					pPacket,
    IN	ULONG					TransportHeaderOffset,
    IN  PTC_INTERFACE_ID		pInterfaceId,
    OUT	PGPC_CLIENT_HANDLE		pClientCfInfoContext,	//optional
    OUT	PCLASSIFICATION_HANDLE	pClassificationHandle
    )
{
    GPC_STATUS				Status = GPC_STATUS_SUCCESS;
    PNDIS_PACKET			pNdisPacket = NULL;
    PCLIENT_BLOCK			pClient;
    PCF_BLOCK				pCf;
    PPATTERN_BLOCK			pPattern = NULL;
    PPROTOCOL_BLOCK			pProtocol;
    PBLOB_BLOCK				pBlob = NULL;
    ULONG					CfIndex;
    int						i;
    GPC_IP_PATTERN			IpPattern;
    GPC_IPX_PATTERN			IpxPattern;
    PVOID					pKey = NULL;
    PVOID					pAddr;
    UINT					Len, Tot;
    PNDIS_BUFFER			pNdisBuf1, pNdisBuf2;
    PIP_HEADER              pIpHdr;
    PIPX_HEADER             pIpxHdr;
    USHORT         			PacketId;
    USHORT         			FragOffset;
    UINT           			IpHdrLen;
    PUDP_HEADER    			pUDPHdr;
    UCHAR          			PktProtocol;
    BOOLEAN					bFragment = FALSE;
    BOOLEAN					bLastFragment = FALSE;
    BOOLEAN					bFirstFragment = FALSE;

	TRACE(CLASSIFY, ClientHandle, pNdisPacket, "GpcClassifyPacket");
    
    DBGPRINT(CLASSIFY, ("GpcClassifyPacket: Client=%X CH=%d\n", 
                        ClientHandle, *pClassificationHandle));

    VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);

    ASSERT(pPacket);
    ASSERT(ClientHandle);
    //ASSERT(pClientCfInfoContext);
    ASSERT(pClassificationHandle);

    if (ProtocolTemplate >= GPC_PROTOCOL_TEMPLATE_MAX) {

        return GPC_STATUS_INVALID_PARAMETER;
    }

    pProtocol = &glData.pProtocols[ProtocolTemplate];

    //
    // Optimization - check if there are any patterns installed
    //

    if (pProtocol->SpecificPatternCount == 0
        &&
        pProtocol->GenericPatternCount == 0 ) {
        
        if (pClientCfInfoContext) {
            *pClientCfInfoContext = NULL;
        }
        *pClassificationHandle = 0;

        DBGPRINT(CLASSIFY, ("GpcClassifyPacket: Client=%X no patterns returned %X\n", 
                            ClientHandle, GPC_STATUS_NOT_FOUND));

        return GPC_STATUS_NOT_FOUND;
    }

    pClient = (PCLIENT_BLOCK)ClientHandle;
    pNdisPacket = (PNDIS_PACKET)pPacket;

    //
    // get the classification handle from the packet
    // if there - extract the blob pointer and the client blob context
    // directly and return
    //

    //
    // o/w, we need to look inside the packet
    // Parse the packet into a pattern and make a db search
    // first match a specific pattern, and then search the generic
    // database(s) for the given CF
    //

    pCf = pClient->pCfBlock;

    CfIndex = pCf->AssignedIndex;

    ProtocolStatInc(ProtocolTemplate,ClassificationRequests);

    *pClassificationHandle = 0;

    //
    // get the pattern from the packet
    //

    //
    // get the first NDIS buffer - assuming it is a MAC header
    //

    NdisGetFirstBufferFromPacket(pNdisPacket,
                                 &pNdisBuf1,   // Ndis buffer 1 desc.
                                 &pAddr,       // buffer VA
                                 &Len,         // buffer length
                                 &Tot          // total length (all buffs)
                                 );

    ASSERT(Tot > TransportHeaderOffset);

    while (Len <= TransportHeaderOffset) {
        
        //
        // Transport header is not in this buffer,
        // try the next buffer
        //

        TransportHeaderOffset -= Len;
        NdisGetNextBuffer(pNdisBuf1, &pNdisBuf2);
        ASSERT(pNdisBuf2); // should never happen!!
        NdisQueryBuffer(pNdisBuf2, &pAddr, &Len);
        pNdisBuf1 = pNdisBuf2;
    }

    switch (ProtocolTemplate) {

    case GPC_PROTOCOL_TEMPLATE_IP:

        //
        // fill the pattern with '0'
        //
        
        RtlZeroMemory(&IpPattern, sizeof(IpPattern));

        //
        // parse IP packet here...
        //

        pIpHdr = (PIP_HEADER)(((PUCHAR)pAddr) + TransportHeaderOffset);
        IpHdrLen = (pIpHdr->iph_verlen & (uchar)~IP_VER_FLAG) << 2;
        
        FragOffset = pIpHdr->iph_offset & IP_OFFSET_MASK;
        FragOffset = net_short(FragOffset) * 8;

        PacketId = pIpHdr->iph_id;

        //
        // check for fragmentation
        //

        bFragment = (pIpHdr->iph_offset & IP_MF_FLAG) || (FragOffset > 0);
        bFirstFragment = bFragment && (FragOffset == 0);
        bLastFragment = bFragment && 
            TEST_BIT_OFF(pIpHdr->iph_offset, IP_MF_FLAG);

        //
        // sanity check - doesn't make sense to have a single fragment
        //

        ASSERT(!bFirstFragment || !bLastFragment);

        if (TEST_BIT_ON(pClient->Flags, GPC_FLAGS_FRAGMENT) &&
            (bFragment && ! bFirstFragment)) {
            
            //
            // client is interested in fragmentation and this is a
            // a fragment, but not the first one.
            // It will be handled later when we find the pattern
            //

            Status = HandleFragment(
                                    pClient,
                                    pProtocol,
                                    bFirstFragment,    // first frag
                                    bLastFragment,     // last frag
                                    PacketId,
                                    &pPattern,
                                    &pBlob
                                    );

        } else {

            //
            // not a fragment, or is the first one - we have to search db
            //

            IpPattern.SrcAddr = pIpHdr->iph_src;
            IpPattern.DstAddr = pIpHdr->iph_dest;
            IpPattern.ProtocolId = pIpHdr->iph_protocol;
            
            //
            // case the ProtocolId and fill the appropriate union
            //
            
            switch (IpPattern.ProtocolId) {
                
            case IPPROTO_IP:
                //
                // we have everything so far
                //

                break;


            case IPPROTO_TCP:
            case IPPROTO_UDP:

                //
                // need to get those port numbers
                //

                if (IpHdrLen < Len) {

                    //
                    // the UDP/TCP header is in the same buffer
                    // 

                    pUDPHdr = (PUDP_HEADER)((PUCHAR)pIpHdr + IpHdrLen);
                    
                } else {

                    //
                    // get the next buffer
                    //
                    
                    NdisGetNextBuffer(pNdisBuf1, &pNdisBuf2);
                    ASSERT(pNdisBuf2);
            
                    if (IpHdrLen > Len) {
                
                        //
                        // There is an optional header buffer, so get the next
                        // buffer to reach the udp/tcp header
                        //
                        
                        pNdisBuf1 = pNdisBuf2;
                        NdisGetNextBuffer(pNdisBuf1, &pNdisBuf2);
                        ASSERT(pNdisBuf2);
                    }
            
                    NdisQueryBuffer(pNdisBuf2, &pUDPHdr, &Len);
                }

                IpPattern.gpcSrcPort = pUDPHdr->uh_src;
                IpPattern.gpcDstPort = pUDPHdr->uh_dest;
#if INTERFACE_ID
                IpPattern.InterfaceId.InterfaceId = pInterfaceId->InterfaceId;
                IpPattern.InterfaceId.LinkId = pInterfaceId->LinkId;
#endif
                break;
                
            case IPPROTO_ICMP:
            case IPPROTO_IGMP:
            default:

                // 
                // The default will cover all IP_PROTO_RAW packets. Note that in this case, all we care about
                // is the InterfaceID
                //
#if INTERFACE_ID
                IpPattern.InterfaceId.InterfaceId = pInterfaceId->InterfaceId;
                IpPattern.InterfaceId.LinkId = pInterfaceId->LinkId;
#endif
                break;

            case IPPROTO_IPSEC:

                pKey = NULL;
                Status = GPC_STATUS_NOT_SUPPORTED;
            }
            
            pKey = &IpPattern;
            break;
        }
        
        DBGPRINT(CLASSIFY, ("IP: ifc={%d,%d} src=%X:%x, dst=%X:%x, prot=%x, rsv=%x,%x,%x \n", 
                            IpPattern.InterfaceId.InterfaceId,
                            IpPattern.InterfaceId.LinkId,
                            IpPattern.SrcAddr,
                            IpPattern.gpcSrcPort,
                            IpPattern.DstAddr,
                            IpPattern.gpcDstPort,
                            IpPattern.ProtocolId,
                            IpPattern.Reserved[0],
                            IpPattern.Reserved[1],
                            IpPattern.Reserved[2]
                            ));
        break;
        

    case GPC_PROTOCOL_TEMPLATE_IPX:

        //
        // fill the pattern with '0'
        //
        
        RtlZeroMemory(&IpxPattern, sizeof(IpxPattern));

        //
        // parse IPX packet here...
        //

        pIpxHdr = (PIPX_HEADER)(((PUCHAR)pAddr) + TransportHeaderOffset);

        //
        // source
        //
        IpxPattern.Src.NetworkAddress = *(ULONG *)pIpxHdr->SourceNetwork;
        RtlMoveMemory(IpxPattern.Src.NodeAddress, pIpxHdr->SourceNode,6);
        IpxPattern.Src.Socket = pIpxHdr->SourceSocket;

        //
        // destination
        //
        IpxPattern.Dest.NetworkAddress = *(ULONG *)pIpxHdr->DestinationNetwork;
        RtlMoveMemory(IpxPattern.Dest.NodeAddress, pIpxHdr->DestinationNode,6);
        IpxPattern.Dest.Socket = pIpxHdr->DestinationSocket;

        pKey = &IpxPattern;

        break;
        
    default:
        Status = GPC_STATUS_INVALID_PARAMETER;

    }

    if (NT_SUCCESS(Status) && pPattern == NULL) {

        //
        // no failure so far but no pattern found either
        // search for the pattern
        //

        ASSERT(pKey);

        //
        // if there is a match, the pattern ref count will be bumped
        // up and we need to release it when we're done.
        //

        Status = InternalSearchPattern(
                                         pClient, 
                                         pProtocol, 
                                         pKey,
                                         &pPattern,
                                         pClassificationHandle,
                                         FALSE
                                         );
    }

    if (*pClassificationHandle) {
        
        if (pClientCfInfoContext) {

            Status = GpcGetCfInfoClientContext(ClientHandle,
                                              *pClassificationHandle,
                                              pClientCfInfoContext);
        }

        ProtocolStatInc(ProtocolTemplate, PacketsClassified);

    } else {

        //ASSERT(pBlob == NULL);

        //
        // none found, or some other error occured.
        //

        if (pClientCfInfoContext) {
            *pClientCfInfoContext = NULL;
        }

        *pClassificationHandle = 0;

        Status = GPC_STATUS_NOT_FOUND;
    }

	TRACE(CLASSIFY, pPattern, Status, "GpcClassifyPacket==>");

    DBGPRINT(CLASSIFY, ("GpcClassifyPacket: Client=%X returned Pattern=%X, CH=%d, Status=%X\n", 
                        pClient, pPattern, *pClassificationHandle, Status));
    return Status;
}





/*
************************************************************************

GpcEnumCfInfo -

	Called to enumerate CfInfo's (and attached filters).
    For each CfInfo, GPC will return the CfInfo blob and the list of 
    pattern attached to it.

Arguments

	ClientHandle	- the calling client
    pBlob			- the next cfinfo to enumerate, NULL for the first
    pBlobCount		- in: requested; out: returned
    pBufferSize		- in: allocated; out: bytes returned
    Buffer			- output buffer

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
GpcEnumCfInfo(
	IN     GPC_HANDLE				ClientHandle,
    IN OUT PHANDLE					pCfInfoHandle,
    OUT    PHANDLE					pCfInfoMapHandle,
    IN OUT PULONG					pCfInfoCount,
    IN OUT PULONG					pBufferSize,
    IN     PGPC_ENUM_CFINFO_BUFFER	Buffer
    )
{
    GPC_STATUS			Status = GPC_STATUS_SUCCESS;
    GPC_STATUS 			st;
    PBLOB_BLOCK			pBlob = NULL;
    PCF_BLOCK			pCf;
    PLIST_ENTRY			pEntry, pHead;
    PPATTERN_BLOCK		pPattern;
    ULONG				cCfInfo = 0;
    ULONG				cTotalBytes = 0;
    ULONG				cPatterns, cValidPatterns;
    ULONG				size, cValidSize;
    ULONG				PatternMaskLen;
    ULONG				PatternSize;
    ULONG				i;
    PCHAR				p, q;
    PGENERIC_PATTERN_DB	pGenDb;
    UNICODE_STRING		CfInfoName;
    PGPC_GEN_PATTERN	pGenPattern;
    BOOLEAN				bEnum;
    KIRQL				ReadIrql;
    KIRQL				irql;
    PCLIENT_BLOCK		pNotifiedClient;
    GPC_CLIENT_HANDLE	NotifiedClientCtx;
    BOOLEAN             found = FALSE;
    UNICODE_STRING      UniStr;

    //
    //  debug checks
    //

    ASSERT(ClientHandle);
    ASSERT(pCfInfoHandle);
    ASSERT(pCfInfoMapHandle);
    ASSERT(pCfInfoCount);
    ASSERT(pBufferSize);
    ASSERT(Buffer);

    cValidPatterns  = 0;

    VERIFY_OBJECT(ClientHandle, GPC_ENUM_CLIENT_TYPE);

    pCf = ((PCLIENT_BLOCK)ClientHandle)->pCfBlock;

    //NDIS_LOCK(&pCf->Lock);
    
    RSC_WRITE_LOCK(&pCf->ClientSync, &irql);

    //
    // check if we start from a previous blob
    //

    if (*pCfInfoHandle) {

        pBlob = (PBLOB_BLOCK)*pCfInfoHandle;

        NDIS_LOCK(&pBlob->Lock);

        if (pBlob->State == GPC_STATE_REMOVE) {
            
            //
            // the blob has been marked for removal
            //

            NDIS_UNLOCK(&pBlob->Lock);
            //NDIS_UNLOCK(&pCf->Lock);

            RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);
            
            *pCfInfoMapHandle = NULL;

            return STATUS_DATA_ERROR;
        }

        //NDIS_UNLOCK(&pBlob->Lock);

    } else {

        //
        // find the first (good) blob to enumerate.
        //
            
        //
        // Need to take pCf->Lock to manipulate or 
        // traverse the Blobs on it
        //
        NDIS_LOCK(&pCf->Lock);

        if (IsListEmpty(&pCf->BlobList)) {

            //
            // no blobs to enumerate
            //

            *pCfInfoCount = 0;
            *pBufferSize = 0;
            *pCfInfoMapHandle = NULL;

            //NDIS_UNLOCK(&pCf->Lock);

            NDIS_UNLOCK(&pCf->Lock);

            RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);

            return GPC_STATUS_SUCCESS;

        } else {

            //
            // Find a good Blob (something that's not getting deleted)
            //
            pEntry = pCf->BlobList.Flink;

            while (&pCf->BlobList != pEntry) {
            
                pBlob = CONTAINING_RECORD(pEntry, BLOB_BLOCK, CfLinkage);
                NDIS_LOCK(&pBlob->Lock);

                if ((pBlob->State == GPC_STATE_READY) && 
                    (pBlob->ObjectType != GPC_ENUM_INVALID)) {
                    
                    found = TRUE;
                    break;


                } else {

                    //Aha! The first Blob is bad!!
                    pEntry = pEntry->Flink;
                    NDIS_UNLOCK(&pBlob->Lock);
                }

            }
            
            //
            // Couldn't find anything to enumerate.
            if (!found) {
                
                //No Blobs to enumerate

                *pCfInfoCount = 0;
                *pBufferSize = 0;
                *pCfInfoMapHandle = NULL;
    
                NDIS_UNLOCK(&pCf->Lock);

                //NDIS_UNLOCK(&pCf->Lock);
                RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);
    
                return GPC_STATUS_SUCCESS;

            }
        }
        
        NDIS_UNLOCK(&pCf->Lock);

    }

    ASSERT(pBlob);

    *pCfInfoMapHandle = pBlob->ClHandle;

    //
    // at this point, we should have a blob pointer that we can 
    // start enumerating. The CF is still lock, so we can safely
    // walk the BlobList
    // The blob lock is also taken so we can scan the pattern list
    //

    for ( ; ; ) {	// we'll break out from this

        //NDIS_LOCK(&pBlob->Lock);

        //NdisInterlockedIncrement(&pBlob->RefCount);

        //ASSERT (pBlob->State != GPC_STATE_REMOVE);
 
        //NDIS_UNLOCK(&pBlob->Lock);

        pHead = &pBlob->PatternList;
        pEntry = pHead->Flink;
        
        //
        // Calculate how much space is needed for just one CfInfo
        // and all of its filters
        //
        
        size = sizeof(GPC_ENUM_CFINFO_BUFFER) + pBlob->ClientDataSize;

        // 
        // patterns might become invalid while we try to enum the CF, so we set cValidSize here
        // we have to align cValidSize so that the next CfInfo starts at a word boundary.
        //

        size = ((size + (sizeof(PVOID)-1)) & ~(sizeof(PVOID)-1));
        cValidSize = size;

        //
        // Count the patterns
        //
       
        for (cPatterns = 0, PatternMaskLen = 0;
             pHead != pEntry; 
             cPatterns++, pEntry = pEntry->Flink) {

            pPattern = CONTAINING_RECORD(pEntry, 
                                         PATTERN_BLOCK, 
                                         BlobLinkage[pCf->AssignedIndex]);
            
            PatternMaskLen += (sizeof(GPC_GEN_PATTERN) +
                               2 * glData.pProtocols[pPattern->ProtocolTemplate].PatternSize);

        }

        //
        // check if we have enough buffer space
        //
        size += PatternMaskLen;
        cValidPatterns = 0;

        if ((cTotalBytes + size) <= *pBufferSize) {

            //
            // yes, we can squeeze one more...
            //
            pEntry = pHead->Flink;

            pGenPattern = &Buffer->GenericPattern[0];

            for (i = 0; 
                 ((i < cPatterns) && (pEntry != pHead)); 
                 i++, pEntry = pEntry->Flink) {

                //
                // fill all the patterns + masks in
                //

                pPattern = CONTAINING_RECORD(pEntry, 
                                             PATTERN_BLOCK,
                                             BlobLinkage[pCf->AssignedIndex] );

                NDIS_LOCK(&pPattern->Lock);
                
                // Check for pattern's state...
                //

                if (GPC_STATE_READY != pPattern->State) {
                    
                    // don't try to list it out if its being removed!
                    NDIS_UNLOCK(&pPattern->Lock);
                    continue;

                }

                cValidSize += (sizeof(GPC_GEN_PATTERN) +
                         2 * glData.pProtocols[pPattern->ProtocolTemplate].PatternSize);


                PatternSize = glData.pProtocols[pPattern->ProtocolTemplate].PatternSize;
                pGenPattern->ProtocolId = pPattern->ProtocolTemplate;
                pGenPattern->PatternSize = PatternSize;
                pGenPattern->PatternOffset = sizeof(GPC_GEN_PATTERN);
                pGenPattern->MaskOffset = pGenPattern->PatternOffset + PatternSize;

                p = ((PUCHAR)pGenPattern) + pGenPattern->PatternOffset;

                cValidPatterns++;

                //
                // get the pattern and mask bits
                //

                if (TEST_BIT_ON(pPattern->Flags, PATTERN_SPECIFIC)) {

                    //
                    // this is a specific pattern
                    //

                    READ_LOCK(&glData.pProtocols[pPattern->ProtocolTemplate].SpecificDb.Lock, &ReadIrql);

                    ASSERT(pPattern->DbCtx);

                    q = GetKeyPtrFromSpecificPatternHandle
                        (((SpecificPatternHandle)pPattern->DbCtx));

                    RtlMoveMemory(p, q, PatternSize);
                    
                    p += PatternSize;

                    //
                    // that's a specific pattern, remember?
                    //

                    NdisFillMemory(p, PatternSize, (CHAR)0xff);

                    READ_UNLOCK(&glData.pProtocols[pPattern->ProtocolTemplate].SpecificDb.Lock, ReadIrql);

                } else {

                    pGenDb = &pCf->arpGenericDb[pPattern->ProtocolTemplate][pPattern->Priority];

                    READ_LOCK(&pGenDb->Lock, &ReadIrql);

                    //
                    // generic pattern
                    //

                    ASSERT(pPattern->DbCtx);

                    q = GetKeyPtrFromPatternHandle(pGenDb->pRhizome, 
                                                   pPattern->DbCtx);

                    RtlMoveMemory(p, q, PatternSize);
                    
                    p += PatternSize;

                    //
                    // mask
                    //

                    q = GetMaskPtrFromPatternHandle(pGenDb->pRhizome, 
                                                    pPattern->DbCtx);

                    RtlMoveMemory(p, q, PatternSize);

                    READ_UNLOCK(&pGenDb->Lock, ReadIrql);

                }
                
                p += PatternSize;
                pGenPattern = (PGPC_GEN_PATTERN)p;
                
                NDIS_UNLOCK(&pPattern->Lock);
                    
            } // for (i = 0; ...)

            //
            // we can now fill the CfInfo data.
            // 'pGenPattern' now points to the place where we can safely
            // store the CfInfo structure, and update the pointer
            //

            Buffer->InstanceNameLength = 0;
            pNotifiedClient = pBlob->pNotifiedClient;
            NotifiedClientCtx = pBlob->NotifiedClientCtx;

            st = GPC_STATUS_FAILURE;

            if (pNotifiedClient) {

                if (pNotifiedClient->FuncList.ClGetCfInfoName &&
                    NotifiedClientCtx) {

                    st = pNotifiedClient->FuncList.ClGetCfInfoName(
                                           pNotifiedClient->ClientCtx,
                                           NotifiedClientCtx,
                                           &CfInfoName
                                           );
                
                    if (CfInfoName.Length >= MAX_STRING_LENGTH * sizeof(WCHAR))
                            CfInfoName.Length = (MAX_STRING_LENGTH-1) * sizeof(WCHAR);
                    
                    //
                    // RajeshSu claims this can never happen.
                    //
                    ASSERT(NT_SUCCESS(st));

                }

            } 

            if (NT_SUCCESS(st)) {

                //
                // copy the instance name
                //
                
                Buffer->InstanceNameLength = CfInfoName.Length;
                RtlMoveMemory(Buffer->InstanceName, 
                              CfInfoName.Buffer,
                              CfInfoName.Length
                              );
            } else {

                //
                // generate a default name
                //
                if (NotifiedClientCtx) {

                    RtlInitUnicodeString(&UniStr, L"Flow <ClientNotified>");

                } else {

                    RtlInitUnicodeString(&UniStr, L"Flow <unknown name>");

                }


                RtlCopyMemory(Buffer->InstanceName, UniStr.Buffer, UniStr.Length);

                Buffer->InstanceNameLength = UniStr.Length;
                
            }

            Buffer->InstanceName[Buffer->InstanceNameLength/sizeof(WCHAR)] = L'\0';
                
            //
            // 'pGenPattern' should point to the location right after the last
            // mask, so we fill the CfInfo data there
            //

            //NDIS_LOCK(&pBlob->Lock);

            RtlMoveMemory(pGenPattern, 
                          pBlob->pClientData, 
                          pBlob->ClientDataSize);

            Buffer->Length          = cValidSize;
            Buffer->CfInfoSize      = pBlob->ClientDataSize;
            
            Buffer->CfInfoOffset    = (ULONG)((PCHAR)pGenPattern 
                                              - (PCHAR)Buffer);	// offset to structure
            Buffer->PatternCount    = cValidPatterns;
            Buffer->PatternMaskLen  = PatternMaskLen;
            Buffer->OwnerClientCtx  = pBlob->pOwnerClient->ClientCtx;

            //
            // release the blob lock we've got earlier
            //
            NDIS_UNLOCK(&pBlob->Lock);
            
            //
            // update total counts
            //
            cCfInfo++;
            cTotalBytes += cValidSize;
            Buffer = (PGPC_ENUM_CFINFO_BUFFER)((PCHAR)Buffer + cValidSize);

            pEntry = pBlob->CfLinkage.Flink;

            //
            // advance to the next blob in the list
            //

            if (pEntry == &pCf->BlobList) {

                //
                // end of blob list, reset the blob to NULL and return 
                //
                
                pBlob = NULL;
                *pCfInfoMapHandle = NULL;
                
                break;
            }

            pBlob = CONTAINING_RECORD(pEntry,
                                       BLOB_BLOCK, 
                                       CfLinkage);
            *pCfInfoMapHandle = pBlob->ClHandle;

            if (cCfInfo == *pCfInfoCount) {

                //
                // enough CfInfo's filled
                //

                break;
            }

            //
            // lock the blob for the next cycle
            //

            NDIS_LOCK(&pBlob->Lock);

        } else { // if (cTotalBytes + size <= *pBufferSize)...

            //
            // size is too small, set return values and break
            //

            //DereferenceBlob(&pBlob);

            if (cCfInfo == 0) {

                Status = GPC_STATUS_INSUFFICIENT_BUFFER;
            }

            //
            // release the blob lock we've got earlier
            //

            NDIS_UNLOCK(&pBlob->Lock);

            break;

        }

    } // for (;;")

    //NDIS_UNLOCK(&pCf->Lock);

    RSC_WRITE_UNLOCK(&pCf->ClientSync, irql);
    
    *pCfInfoHandle = (GPC_HANDLE)pBlob;
    *pCfInfoCount = cCfInfo;
    *pBufferSize = cTotalBytes;

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\gpcmap.c ===
/*
************************************************************************

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    gpcmap.c

Abstract:

    This file contains mapping routines like user handles to
    kernel handles.

Author:

    Ofer Bar - July 14, 1997

Environment:

    Kernel mode

Revision History:


************************************************************************
*/

#include "gpcpre.h"


/*
/////////////////////////////////////////////////////////////////
//
//   globals
//
/////////////////////////////////////////////////////////////////
*/

static MRSW_LOCK		HandleLock;
static HandleFactory   *pMapHandles = NULL;

/*
/////////////////////////////////////////////////////////////////
//
//   prototypes
//
/////////////////////////////////////////////////////////////////
*/



HANDLE
AllocateHandle(
    OUT HANDLE *OutHandle,           
    IN  PVOID  Reference
    )
/*++

Routine Description:

    This function creates a handle.

Arguments:

    OutHandle - a pointer to a location to fill in the result handle
    Reference - to associate with the handle

Return Value:

	The handle factory handle, or NULL in case of en error

--*/
{
    HFHandle	Handle;
    KIRQL		irql;
    
    ASSERT(OutHandle);

	TRACE(MAPHAND, Reference, OutHandle, "AllocateHandle <==");

    WRITE_LOCK( &HandleLock, &irql );

    *OutHandle = (HANDLE) UIntToPtr((Handle = assign_HF_handle(pMapHandles, Reference)));
    
    WRITE_UNLOCK( &HandleLock, irql );

    StatInc(InsertedHF);

	TRACE(MAPHAND, Reference, Handle, "AllocateHandle ==>");

    return (HANDLE) UIntToPtr(Handle);
}


VOID
FreeHandle(
    IN 	HANDLE    Handle
    )
/*++

Routine Description:

    This function frees the handle

Arguments:

    Handle - 

Return Value:

--*/
{
    int  		r;
    KIRQL		irql;

	TRACE(MAPHAND, Handle, 0, "FreeHandle <==");

    if (Handle) {

        WRITE_LOCK( &HandleLock, &irql );
        
        r = release_HF_handle(pMapHandles, (HFHandle)(UINT_PTR)Handle);

        StatInc(RemovedHF);

        //ASSERT(r == 0);
        
        WRITE_UNLOCK( &HandleLock, irql );
    }

	TRACE(MAPHAND, Handle, r, "FreeHandle ==>");
}




VOID
SuspendHandle(
    IN 	HANDLE    Handle
    )
/*++

Routine Description:

    This function suspends the handle

Arguments:

    Handle - 

Return Value:

--*/
{
    int  		r;
    KIRQL		irql;

	TRACE(MAPHAND, Handle, 0, "SuspendHandle <==");

    if (Handle) {

        WRITE_LOCK( &HandleLock, &irql );
        
        r = suspend_HF_handle(pMapHandles, (HFHandle)(UINT_PTR)Handle);

        //ASSERT(r == 0);
        
        WRITE_UNLOCK( &HandleLock, irql );
    }

	TRACE(MAPHAND, Handle, r, "SuspendHandle ==>");
}




VOID
ResumeHandle(
    IN 	HANDLE    Handle
    )
/*++

Routine Description:

    This function resumess the handle

Arguments:

    Handle - 

Return Value:

--*/
{
    int  		r;
    KIRQL		irql;

	TRACE(MAPHAND, Handle, 0, "ResumeHandle <==");

    if (Handle) {

        WRITE_LOCK( &HandleLock, &irql );
        
        r = reinstate_HF_handle(pMapHandles, (HFHandle)(UINT_PTR)Handle);

        //ASSERT(r == 0);
        
        WRITE_UNLOCK( &HandleLock, irql );
    }

	TRACE(MAPHAND, Handle, r, "ResumeHandle ==>");
}




PVOID
GetHandleObject(
	IN  HANDLE					h,
    IN  GPC_ENUM_OBJECT_TYPE	ObjType
    )
{
    GPC_ENUM_OBJECT_TYPE   *p;
    KIRQL					irql;

	TRACE(MAPHAND, h, ObjType, "GetHandleObject <==");

    READ_LOCK(&HandleLock, &irql);

    p = (GPC_ENUM_OBJECT_TYPE *)dereference_HF_handle(pMapHandles, 
                                                      (HFHandle)(UINT_PTR)h);

    if (p != NULL) {

        //
        // we found a reference for the handle
        // we verify that it's the right object type
        //

        if (*p != ObjType) {

            //
            // sorry, wrong type
            //

            p = NULL;
        }
        
    }

    READ_UNLOCK(&HandleLock, irql);
    
	TRACE(MAPHAND, h, p, "GetHandleObject ==>");

    return (PVOID)p;
}




PVOID
GetHandleObjectWithRef(
	IN  HANDLE					h,
    IN  GPC_ENUM_OBJECT_TYPE	ObjType,
    IN  ULONG                   Ref
    )
{
    GPC_ENUM_OBJECT_TYPE   *p;
    KIRQL		irql;
    
	TRACE(MAPHAND, h, ObjType, "GetHandleObjectWithRef ==>");

    READ_LOCK( &HandleLock, &irql );
    
    p = dereference_HF_handle(pMapHandles, (HFHandle)(ULONG_PTR)h);

    if (p != NULL) {

        //
        // we found a reference for the handle
        // we verify that it's the right object type
        //

        if (*p != ObjType) {

            //
            // sorry, wrong type
            //

            p = NULL;
        }
        
    }

    if (p != NULL) {

        switch (ObjType) {

        case GPC_ENUM_CFINFO_TYPE:
            REFADD(&((PBLOB_BLOCK)p)->RefCount, Ref);
            break;

        case GPC_ENUM_CLIENT_TYPE:
            
            REFADD(&((PCLIENT_BLOCK)p)->RefCount, Ref);
            break;

        case GPC_ENUM_PATTERN_TYPE:
            REFADD(&((PPATTERN_BLOCK)p)->RefCount, Ref);
            break;

        default:
            ASSERT(0);
        }
    }
    
    READ_UNLOCK( &HandleLock, irql );

	TRACE(MAPHAND, h, p, "GetHandleObjectWithRef <==");

    return (PVOID)p;
}



/*
************************************************************************

InitMapHandles - 

The initialization handle mapping table

Arguments
	none

Returns
	GPC_STATUS

************************************************************************
*/
GPC_STATUS
InitMapHandles(VOID)
{
    GPC_STATUS Status = GPC_STATUS_SUCCESS;

	TRACE(INIT, 0, 0, "InitMapping");

	INIT_LOCK(&HandleLock);

    NEW_HandleFactory(pMapHandles);

    if (pMapHandles != NULL ) {
        
        if (constructHandleFactory(pMapHandles)) {
            
            FreeHandleFactory(pMapHandles);

            Status = GPC_STATUS_RESOURCES;
        } 
            
    } else {
        
        Status = GPC_STATUS_RESOURCES;
    }
    
	TRACE(INIT, pMapHandles, Status, "InitMapping");

    return Status;
}


/*
************************************************************************

UninitMapHandles - 

	release handle mapping table resources

Arguments
	none

Returns
	void

************************************************************************
*/
VOID
UninitMapHandles(VOID)
{
    GPC_STATUS Status = GPC_STATUS_SUCCESS;

	TRACE(INIT, 0, 0, "UninitMapHandles");

	//NdisFreeSpinLock(&HandleLock);

    destructHandleFactory(pMapHandles);

    FreeHandleFactory(pMapHandles);

	TRACE(INIT, pMapHandles, Status, "UninitMapHandles");

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\handfact.c ===
/*
 *  handfact.c
 *
 *  author:	John R. Douceur
 *  date:	26 January 1998
 *
 *  This source file provides functions that implement assignment, release, and
 *  dereferencing operations with a handle_factory.  The code is object-oriented
 *  C, transliterated from a C++ implementation.
 *
 *  The handle factory is a component that generates and validates handles.  It
 *  is intended to be used in a software module that provides client software
 *  modules with means to refer to information structures contained within the
 *  provider.  While such a means could simply be a pointer, this would not
 *  enable the deletion of the information structures without explicitly
 *  notifying the clients of such deletion.  Unlike pointers, the handles
 *  generated by the handle factory can be examined (by the handle factory)
 *  to determine their validity.
 *
 *  Handles can be invalidated in one of two ways.  The handle can be released
 *  by calling the release_HF_handle() function, indicating to the handle
 *  factory that the handle is no longer necessary and that future requests
 *  to dereference this handle should be met with a null pointer.  Alternately,
 *  the handle can be revoked by the handle factory; this will happen unter two
 *  circumstances.  If a large number of handles (more than four billion) are
 *  issued and subsequently released, it becomes necessary to reuse portions of
 *  the handle space for future assignments; under these circumstances, very
 *  old handles will be revoked well before this recycling occurs, to give the
 *  holders of those handles ample opportunity to notice that their handles
 *  have become invalid and to request new handles.  The other situation in
 *  which revokation can occur is if the amount of available memory becomes
 *  too small to allocate additional space to expand the handle database; then,
 *  if the assignment of a new handle is requested, the least-recently-assigned
 *  handle will be revoked to make room for the new request.
 *
 *  Use of the handle factory in a multi-threaded environment requires a lock.
 *  This lock must be taken by a single thread for the execution of either
 *  assign_HF_handle() or release_HF_handle().  Use of dereference_HF_handle()
 *  does not require taking a lock, since synchronization is handled internally
 *  through careful sequencing of read and write operations.
 *
 *  None of the code or comments in this file need to be understood by writers
 *  of client code; all explanatory information for clients is found in the
 *  associated header file, handfact.h.
 *
 */

#include "gpcpre.h"

/*
 *  There are a number of aspects to the handle factory that must be understood
 *  by anyone wishing to modify this code.  The description in this comment
 *  block is intended to provide a progressive overview of the handle factory.
 *
 *  The basic system comprises a table of entries.  Each assigned handle
 *  corresponds to a single, unique entry, as determined by the handle value
 *  modulo the table size.  A handle is validated by comparing the handle value
 *  to the stored handle value in the entry.  The unassigned entries are kept
 *  on a list; when an entry is released (or revoked), it is put on the tail of
 *  the list, and when an entry is needed for an assignment, it is taken from
 *  the head of the list.
 *
 *  If there are no unassigned entries in the table when a new handle is
 *  requested, a new table of twice the size is allocated, and all assigned
 *  handles are relocated to the new table.  All unassigned handles in the new
 *  table are placed on the unassigned list.
 *
 *  As handles are released, the space required for handle entries is reduced.
 *  The table can be contracted into a table of half the size if no two assigned
 *  handles will yield the same entry address.  Two handles which will yield
 *  the same entry address in a half-size table are called a pair, and the
 *  number of such pairs is tracked in the variable pair_count, which must be
 *  zero in order to contract the table.  In order to minimize the number of
 *  pairs in the table, there are actually two lists of unassigned entries.
 *  Assigning an entry from the primary list will not increase the pair count,
 *  whereas assigning an entry from the secondary list will increase the pair
 *  count.  Thus, assignments are always made from the primary list, if it is
 *  not empty.
 *
 *  Assigned handles are also kept on a list, in order of assignment.  If it
 *  becomes necessary to revoke a handle to make room for another, the oldest
 *  handle will be revoked, and it will be found at the head of this list.
 *
 */

// This macro allocates an array of HFEntry structures.  The size of the array
// is provided as an argument to the macro.
//
//#define NEW_HFEntry_array(array_size) \
//	((HFEntry *)malloc(array_size * sizeof(HFEntry)))
#define NEW_HFEntry_array(_a,array_size) \
	GpcAllocMem(&_a,array_size * sizeof(HFEntry), HandleFactoryTag)

// This macro allocates an array of integers.  The size of the array is
// provided as an argument to the macro.
//
//#define NEW_int_array(array_size) \
//	((int *)malloc(array_size * sizeof(int)))
#define NEW_int_array(_a,array_size) \
	GpcAllocMem(&_a,array_size * sizeof(int), HandleFactoryTag)

/*
 *  Following are prototypes for static functions that are used internally by
 *  the handle factory routines.
 *
 */

// This function doubles the size of the table in which the handles and pointers
// are stored.  It is called by assign_HF_handle() when there is insufficient
// space in the table to assign the newly requested handle.  If the expansion
// is successful, the function returns a value of 0.  If the expansion fails
// (due, for example, to an inability to allocate memory), the function returns
// a value of 1.
//
int expand_HF_table(
	HandleFactory *hfact);

// This function halves the size of the table in which the handles and pointers
// are stored.  In order to reduce the amount of space consumed by the handle
// factory, this function is called called by release_HF_handle() and
// revoke_ancient_HF_handles() when they determine that the table can and should
// be contracted.  The table can be contracted when pair_count == 0 and
// table_size > 2.  However, the table may not be contracted then, because
// hysteresis is employed both to keep the mean assignment and release times
// constant and to minimize the allocation chatter of rapidly expanding and
// contracting the table.  If the contraction is successful, the function
// returns a value of 0.  If the contraction fails, the function returns a
// value of 1.
//
int contract_HF_table(
	HandleFactory *hfact);

// This function revokes handles that are between handle_base and handle_base
// + 2 * HANDLE_RANGE_STEP - 1, inclusive.  It then increments the value of
// handle_base by HANDLE_RANGE_STEP.  Suspended handles will be revoked one
// revokation pass later than non-suspended handles.
//
void revoke_ancient_HF_handles(
	HandleFactory *hfact);

// Every entry is on one of three lists, and the heads and tails of these lists
// are maintained in the entry_list[] array.  The index of this array is given
// by the following three manifest constants.
//
#define LD_PRIMARY 0       // first list from which to select an entry to assign
#define LD_SECONDARY 1    // second list from which to select an entry to assign
#define LD_ASSIGNED 2    // list of assigned entries, in order of assignment age

// When the handle space is recycled, there is a danger of handle collisions.
// In order to substantially reduce the likelihood of these collisions, very
// old handles are revoked well before their recycling begins, to give the
// holders of these handles ample opportunity to notice that their handles
// have become invalid and to request new handles.  Thus, handles are revoked
// when they become more than MAX_HANDLE_RANGE less than the currently generated
// handles.  To reduce overhead, revokations are performed in batches of size
// determined by HANDLE_RANGE_STEP.
//
// A handle may be suspended by incrementing the handle value by
// HANDLE_RANGE_STEP.  This causes the comparison in dereference_HF_handle() to
// fail, so the handle is judged to be invalid.  To reinstate the handle, the
// handle value is decremented by HANDLE_RANGE_STEP, returning the handle to its
// original value.  A handle that is suspended will be revoked one revokation
// pass later than it would have been if it hadn't been suspended.
//
#define HANDLE_RANGE_STEP ((HFHandle)0x20000000)
#define MAX_HANDLE_RANGE ((HFHandle)0x90000000)

// To keep the mean assignment and release times constant (and, indirectly, to
// minimize the allocation chatter of rapidly expanding and contracting the
// table), the table is not necessarily contracted as soon as possible.
// Hysteresis is employed to postpone the contraction until the computational
// cost of previous expansions and contractions is distributed over a sufficient
// number of assignment or release operations to maintain a constant cost per
// operation ratio.  The cost of each expansion is equal to the overhead of
// memory allocation and deallocation plus the cost to split each entry into
// two entries.  The cost of each contraction is equal to the overhead of
// memory allocation and deallocation plus the cost to merge each pair of
// entries into one entry.  The cost of memory allocation and deallocation is
// equal to ALLOCATION_COST times the mean cost of a single split or merge
// operation.  This value was determined by empirical measurement.
//
#define ALLOCATION_COST 12

// Since this is not C++, the HandleFactory structure is not self-constructing;
// therefore, the following constructor code must be called on the HandleFactory
// structure after it is allocated.  If the construction is successful, the
// function returns a value of 0.  If the construction fails (due, for example,
// to an inability to allocate memory), the function returns a value of 1.
//
int
constructHandleFactory(
	HandleFactory *hfact)
{
	// The table size is initially set to 2, and it will never be smaller.
	hfact->table_size = 2;
	// Allocate space for the initial table.
	NEW_HFEntry_array(hfact->entries,hfact->table_size);
	if (hfact->entries == 0)
	{
		// Memory could not be allocated for the array of entries created by
		// the constructor.  Therefore, we return an indication of failure to
		// the client.
		return 1;
	}
	hfact->verifier0 = 0;   // the verifiers are initialized with the same value
	hfact->verifier1 = 0;   // the verifiers are initialized with the same value
	hfact->handle_base = 0;                         // handles will start with 0
	hfact->population = 0;                      // no handles initially assigned
	hfact->pair_count = 0;                // since no assigned handles, no pairs
	hfact->hysteresis_debt = 0;
	// Initialize the two entries that are initially allocated.  Both are marked
	// as unassigned; the larger value (2) is put on the secondary list, and the
	// smaller value (1) on the secondary list.  Record 0 contains an initial
	// handle value of 2 instead of 0 because a handle value of 0 is reserved.
	hfact->entries[0].handle = hfact->handle_base + hfact->table_size;
	hfact->entries[0].next_handle = hfact->handle_base + hfact->table_size;
	hfact->entries[0].reference = 0;
	hfact->entries[0].next_entry = &hfact->entry_list[LD_SECONDARY];
	hfact->entries[0].prev_entry = &hfact->entry_list[LD_SECONDARY];
	hfact->entries[1].handle = hfact->handle_base + 1;
	hfact->entries[1].next_handle = hfact->handle_base + 1;
	hfact->entries[1].reference = 0;
	hfact->entries[1].next_entry = &hfact->entry_list[LD_PRIMARY];
	hfact->entries[1].prev_entry = &hfact->entry_list[LD_PRIMARY];
	// Initialize the primary list.  This list initially contains entry 1.
	hfact->entry_list[LD_PRIMARY].handle = 0;
	hfact->entry_list[LD_PRIMARY].next_handle = 0;
	hfact->entry_list[LD_PRIMARY].reference = 0;
	hfact->entry_list[LD_PRIMARY].next_entry = &hfact->entries[1];
	hfact->entry_list[LD_PRIMARY].prev_entry = &hfact->entries[1];
	// Initialize the secondary list.  This list initially contains entry 0.
	hfact->entry_list[LD_SECONDARY].handle = 0;
	hfact->entry_list[LD_SECONDARY].next_handle = 0;
	hfact->entry_list[LD_SECONDARY].reference = 0;
	hfact->entry_list[LD_SECONDARY].next_entry = &hfact->entries[0];
	hfact->entry_list[LD_SECONDARY].prev_entry = &hfact->entries[0];
	// Initialize the assigned list.  This list initially is empty.
	hfact->entry_list[LD_ASSIGNED].handle = 0;
	hfact->entry_list[LD_ASSIGNED].next_handle = 0;
	hfact->entry_list[LD_ASSIGNED].reference = 0;
	hfact->entry_list[LD_ASSIGNED].next_entry = &hfact->entry_list[LD_ASSIGNED];
	hfact->entry_list[LD_ASSIGNED].prev_entry = &hfact->entry_list[LD_ASSIGNED];
	// Reduce handle_base by HANDLE_RANGE_STEP so that suspended handles will
	// not slip through revokation.
	hfact->handle_base -= HANDLE_RANGE_STEP;
	// return an indication of success to the client.
	return 0;
}

// Since this is not C++, the HandleFactory structure is not self-destructing;
// therefore, the following destructor code must be called on the HandleFactory
// structure before it is deallocated.
//
void
destructHandleFactory(
	HandleFactory *hfact)
{
	// Free the space consumed by the table of handles.
	GpcFreeMem(hfact->entries, HandleFactoryTag);
}

// This function generates a new handle value, associates the handle value with
// the provided reference pointer, and returns the handle value.  Barring
// highly unusual circumstances, this handle will remain valid until it is
// explicitly released by a call to release_HF_handle().  However, there is no
// guarantee that the handle will persist for an arbitrary duration; it may
// become necessary for the handle factory to revoke the handle under some
// circumstances, particularly when the handle becomes very old or when memory
// becomes scarce.
//
// The assign_HF_handle() function will never return a handle value of zero.
// Thus, the client program is free to use a zero handle value as an escape
// indicator, if desired.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// release_HF_handle().
//
HFHandle
assign_HF_handle(
	HandleFactory *hfact,
	void *reference)
{
	int list;
	HFEntry *entry;
	volatile HFEntry *seq_entry;                // volatile to ensure sequencing
	HFHandle handle;
	HFHandle handle_range;

	if (hfact->population >= hfact->table_size)
	{
		// All entries in the table are assigned, so it is necessary to
		// increase the table size.
		int expansion_failure = expand_HF_table(hfact);
		if (expansion_failure)
		{
            //
            // just fail
            //

            return 0;
#if 0

            // Expanding the table failed, presumably due to inability to
			// allocate sufficient memory.  So, instead, we revoke the least-
			// recently assigned handle.  First, remove the entry from the
			// assigned list and place it on the secondary list.
			entry = hfact->entry_list[LD_ASSIGNED].next_entry;
			entry->next_entry->prev_entry = &hfact->entry_list[LD_ASSIGNED];
			hfact->entry_list[LD_ASSIGNED].next_entry = entry->next_entry;
			entry->next_entry = &hfact->entry_list[LD_SECONDARY];
			entry->prev_entry = hfact->entry_list[LD_SECONDARY].prev_entry;
			hfact->entry_list[LD_SECONDARY].prev_entry->next_entry = entry;
			hfact->entry_list[LD_SECONDARY].prev_entry = entry;
			// Then, invalidate the handle.  The order of the operations is
			// important to correct multi-threaded operation.
			seq_entry = entry;
			seq_entry->handle = entry->next_handle;   // first invalidate handle
			seq_entry->reference = 0;                    // then clear reference
			// Decrement the pair count and population, so that when they are
			// incremented in the code below, they will have correct values.
			hfact->pair_count--;
			hfact->population--;
#endif
		}
	}
	// At this point, there is at least one available entry.  If there is any
	// entry on the primary list, it should be selected.
	list = LD_PRIMARY;
	if (hfact->entry_list[LD_PRIMARY].next_entry ==
		&hfact->entry_list[LD_PRIMARY])
	{
		// The primary list is empty, so we take from the secondary list.  By
		// definition, this will increase the pair count.
		list = LD_SECONDARY;
		hfact->pair_count++;
	}
	// Remove the entry from the head of the appropriate list and place it on
	// the assigned list.
	entry = hfact->entry_list[list].next_entry;
	handle = entry->handle;
	entry->next_entry->prev_entry = entry->prev_entry;
	entry->prev_entry->next_entry = entry->next_entry;
	entry->next_entry = &hfact->entry_list[LD_ASSIGNED];
	entry->prev_entry = hfact->entry_list[LD_ASSIGNED].prev_entry;
	hfact->entry_list[LD_ASSIGNED].prev_entry->next_entry = entry;
	hfact->entry_list[LD_ASSIGNED].prev_entry = entry;
	// Set the reference pointer to that provided as an argument.
	entry->reference = reference;
	// The next handle for this entry will be greater by the table size.  It
	// is important to set this value in this routine because unequal values of
	// handle and next_handle indicate an assigned entry.
	entry->next_handle = handle + hfact->table_size;
	if (entry->next_handle == 0)
	{
		// The handle value has wrapped around back to zero; however, zero is
		// a reserved value, so we instead set the next handle to the subsequent
		// legal value, which is the table size.
		entry->next_handle = hfact->table_size;
	}
	// The population has increased by one.
	hfact->population++;
	// We're being tricky with unsigned integer math here.  We revoke ancient
	// handles if the value of the handle we are currently issuing is greater
	// than the handle base by more than MAX_HANDLE_RANGE, modulo the size of
	// the handle space.  The modulo is implicit.
	handle_range = handle - hfact->handle_base;
	if (handle_range > MAX_HANDLE_RANGE)
	{
		revoke_ancient_HF_handles(hfact);
	}
	// This assignment operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// Return the newly assigned handle.
	return handle;
}

// This function releases a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned, then it is released, and the function
// returns a value of 0.  If the handle is not currently assigned, the function
// aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle().
//
int
release_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	int entry_index;
	HFEntry *entry;
	HFEntry *other_entry;
	int list;
	HFHandle adjusted_next_handle;
	HFHandle adjusted_other_next_handle;
	volatile HFEntry *seq_entry;                // volatile to ensure sequencing

	// Compute the index of the entry by taking the handle value modulo the
	// table size.  Since the table size is a power of two, we can simply
	// subtract one to produce a mask and then conjoin the mask with the
	// handle value.
	entry_index = handle & hfact->table_size - 1;
	entry = &hfact->entries[entry_index];
	if ((entry->handle != handle && entry->handle != handle + HANDLE_RANGE_STEP)
		|| entry->handle == entry->next_handle)
	{
		// Either the indexed entry does not refer to the provided handle nor to
		// the provided handle's suspension value, or the entry is unassigned.
		// In any of these cases, abort and return an error code to the client.
		return 1;
	}
	// The "other entry" is the entry that would have to be merged with the
	// indexed entry if the table size were to be contracted in half.
	other_entry = &hfact->entries[entry_index ^ hfact->table_size / 2];
	if (other_entry->handle == other_entry->next_handle)
	{
		// We're being tricky with unsigned integer math here.  Before comparing
		// the two next handles, we subtract from each the value of handle_base,
		// modulo the size of the handle space (the modulo is implicit).  This
		// allows the effective comparison of their logical acyclic values
		// rather than their actual cyclic values.
		adjusted_next_handle = entry->next_handle - hfact->handle_base;
		adjusted_other_next_handle =
			other_entry->next_handle - hfact->handle_base;
		if (adjusted_other_next_handle < adjusted_next_handle)
		{
			// The other entry is unassigned and has a smaller handle value
			// than the indexed entry.  Thus, the other entry should be moved
			// from the secondary list to the primary list, and the indexed
			// entry should be placed on the secondary list.
			other_entry->next_entry->prev_entry = other_entry->prev_entry;
			other_entry->prev_entry->next_entry = other_entry->next_entry;
			other_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
			other_entry->prev_entry = hfact->entry_list[LD_PRIMARY].prev_entry;
			hfact->entry_list[LD_PRIMARY].prev_entry->next_entry = other_entry;
			hfact->entry_list[LD_PRIMARY].prev_entry = other_entry;
			list = LD_SECONDARY;
		}
		else
		{
			// The other entry is unassigned and has a larger handle value
			// than the indexed entry.  Thus, the indexed entry should be
			// placed on the secondary list.
			list = LD_PRIMARY;
		}
	}
	else
	{
		// The other entry is assigned.  Thus, the indexed entry should be
		// placed on the secondary list.  Also, since the two entries were
		// both assigned, they formed a pair.  Since we are releasing one of
		// them, the pair count drops by one.
		list = LD_SECONDARY;
		hfact->pair_count--;
	}
	// Remove the entry from the assigned list and place it on the
	// appropriate list.
	entry->next_entry->prev_entry = entry->prev_entry;
	entry->prev_entry->next_entry = entry->next_entry;
	entry->next_entry = &hfact->entry_list[list];
	entry->prev_entry = hfact->entry_list[list].prev_entry;
	hfact->entry_list[list].prev_entry->next_entry = entry;
	hfact->entry_list[list].prev_entry = entry;
	// Invalidate the handle.  The order of the operations is important to
	// correct multi-threaded operation.
	seq_entry = entry;
	seq_entry->handle = entry->next_handle;           // first invalidate handle
	seq_entry->reference = 0;                            // then clear reference
	// The population has decreased by one.
	hfact->population--;
	// This release operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// To contract the table, there must be no pairs, because otherwise two
	// assigned handles would yield the same entry index and thereby conflict.
	// Furthermore, the table size must be greater than 2, because much of the
	// handle factory code assumes that the table is at least of size 2.  In
	// addition to these strict requirements, hysteresis is employed both to
	// keep the mean assignment and release times constant and to minimize the
	// allocation chatter of rapidly expanding and contracting the table.  Only
	// if the hysteresis debt is zero will the table be contracted.
	if (hfact->pair_count == 0 && hfact->table_size > 2 &&
		hfact->hysteresis_debt == 0)
	{
		contract_HF_table(hfact);
		// Note that we ignore the return code.  If the contraction is
		// unsuccessful, we just continue as usual.  There is no real harm in
		// not contracting the table, except that we consume more space than
		// necessary.
	}
	// return an indication of success to the client.
	return 0;
}

// This function suspends a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle, unless and until
// reinstate_HF_handle() is called on the handle value.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned and not suspended, then it is suspended,
// and the function returns a value of 0.  If the handle is not currently
// assigned or has already been suspended, the function aborts and returns a
// value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and reinstate_HF_handle().
//
int
suspend_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	int entry_index;
	HFEntry *entry;

	// Compute the index of the entry by taking the handle value modulo the
	// table size.  Since the table size is a power of two, we can simply
	// subtract one to produce a mask and then conjoin the mask with the
	// handle value.
	entry_index = handle & hfact->table_size - 1;
	entry = &hfact->entries[entry_index];
	if (entry->handle != handle || entry->handle == entry->next_handle)
	{
		// Either the indexed entry does not refer to the provided handle, or
		// the entry is unassigned.  In either case, abort and return an error
		// code to the client.
		return 1;
	}
	// Suspend the handle.
	entry->handle += HANDLE_RANGE_STEP;
	// This suspension operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// return an indication of success to the client.
	return 0;
}

// This function reinstates a suspended handle, indicating that further attempts
// to dereference the handle should result in the pointer value that was
// originally assigned to the handle, rather than the null pointer value to
// which a suspended handle dereferences.  The handle factory checks the
// validity of the handle and returns a corresponding status code. If the handle
// is currently assigned and suspended, then it is reinstated, and the function
// returns a value of 0.  If the handle is not currently assigned or is not
// suspended, the function aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and suspend_HF_handle().
//
int
reinstate_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	int entry_index;
	HFEntry *entry;

	// Compute the index of the entry by taking the handle value modulo the
	// table size.  Since the table size is a power of two, we can simply
	// subtract one to produce a mask and then conjoin the mask with the
	// handle value.
	entry_index = handle & hfact->table_size - 1;
	entry = &hfact->entries[entry_index];
	if (entry->handle != handle + HANDLE_RANGE_STEP ||
		entry->handle == entry->next_handle)
	{
		// Either the indexed entry does not refer to the provided handle's
		// suspension value, or the entry is unassigned.  In either case, abort
		// and return an error code to the client.
		return 1;
	}
	// Reinstate the handle.
	entry->handle -= HANDLE_RANGE_STEP;
	// This reinstatement operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// return an indication of success to the client.
	return 0;
}

// This function validates a handle and returns either the associated pointer
// (if the handle is valid) or a null pointer value (if the handle is invalid).
// If the handle has not been released but a null value is returned, then the
// handle has been revoked by the handle factory.  This is expected to be a
// highly unusual occurrence; however, since it can happen, any program that
// employs the handle factory must have some auxiliary mechanism for retrieving
// the desired pointer information.  Once the pointer is retrieved through this
// (presumably expensive) auxiliary means, a new handle can be reassigned to
// the pointer by another call to assign_HF_handle().
//
// Even in a multi-threaded environment, it is not necessary to take a lock
// prior to calling this function.  Careful sequencing of read and write
// operations inside the handle factory code obviates the need to explicitly
// lock the data structure for dereferencing handles.
//
void *
dereference_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	HFHandle entry_handle;
	void *reference;
	//int verifier;
	int entry_index;
	/*volatile*/ HFEntry *entry;                    // volatile to ensure sequencing

	// This loop spins until the verifier variables begin and end a pass of
	// the loop with the same value. There is an extremely short sequence
	// of instructions in the expand and contract routines that modifies the
	// values of the entries and table_size variables, and these modifications
	// are bracketed by increments of the verifier variables in the reverse
	// order as they are here read.  As long as the verifiers have the same
	// value, then entries and table_size are in a consistent state.  This loop
	// should very rarely be executed more than once, since the modification in
	// the other routines is so short.
	do
	{
		//verifier = hfact->verifier1;
		// Compute the index of the entry by taking the handle value modulo the
		// table size.  Since the table size is a power of two, we can simply
		// subtract one to produce a mask and then conjoin the mask with the
		// handle value.
		entry_index = handle & hfact->table_size - 1;
		entry = &hfact->entries[entry_index];
		// Get local copies of the reference pointer and handle value.  The
		// order of the operations is important to correct multi-threaded
		// operation.
		reference = entry->reference;                     // first get reference
		entry_handle = entry->handle;       // then get handle to check validity
	}	while (0 /*verifier != hfact->verifier0*/);
	if (entry_handle == handle)
	{
		// The stored handle matches the provided handle, so the latter is
		// valid.  We thus return the reference pointer.
		return reference;
	}
	else
	{
		// The stored handle does not match the provided handle, so the latter
		// is invalid.  We thus return a null pointer.
		return 0;
	}
}



void *
dereference_HF_handle_with_cb(
	HandleFactory *hfact,
	HFHandle handle,
    ULONG    offset)
{
	HFHandle entry_handle;
	void *reference;
	//int verifier;
	int entry_index;
	/*volatile*/ HFEntry *entry;                    // volatile to ensure sequencing

	// This loop spins until the verifier variables begin and end a pass of
	// the loop with the same value. There is an extremely short sequence
	// of instructions in the expand and contract routines that modifies the
	// values of the entries and table_size variables, and these modifications
	// are bracketed by increments of the verifier variables in the reverse
	// order as they are here read.  As long as the verifiers have the same
	// value, then entries and table_size are in a consistent state.  This loop
	// should very rarely be executed more than once, since the modification in
	// the other routines is so short.
	do
	{
		//verifier = hfact->verifier1;
		// Compute the index of the entry by taking the handle value modulo the
		// table size.  Since the table size is a power of two, we can simply
		// subtract one to produce a mask and then conjoin the mask with the
		// handle value.
		entry_index = handle & hfact->table_size - 1;
		entry = &hfact->entries[entry_index];
		// Get local copies of the reference pointer and handle value.  The
		// order of the operations is important to correct multi-threaded
		// operation.

        if ((entry->reference) && (entry->handle == handle)) {

            ASSERT(((PCLASSIFICATION_BLOCK)entry->reference)->NumberOfElements > offset);
            reference = (void *)((PCLASSIFICATION_BLOCK)entry->reference)->arpBlobBlock[offset];
            TRACE(CLASSIFY, entry->reference, reference, "dereference_HF_handle_with_cb");

            return reference;

        } else {

            reference = 0;
            return 0;

        }

	}	while (0 /*verifier != hfact->verifier0*/);

}




#ifdef _TEST_HANDFACT

// This is a test routine that simply verifies the internal valididy of the
// handle factory's data structures.  By defining the constant _TEST_HANDFACT,
// this routine will be compiled and available to the client code.  It can be
// called at any time, unless running in a multi-threaded environment, in which
// case the caller must first take the same lock used for assign_HF_handle()
// and release_HF_handle.  If the routine returns any value other than zero,
// then the internal lists of records are in an inconsistent state.
//
int
verify_HF_lists(
	HandleFactory *hfact)
{
	int entry_count[3];
	int list;
	HFEntry *entry;
	for (list = 0; list < 3; list++)
	{
		entry_count[list] = 0;
		entry = &hfact->entry_list[list];
		do
		{
			entry_count[list]++;
			if (entry->next_entry->prev_entry != entry)
			{
				return 1;
			}
			entry = entry->next_entry;
		}	while (entry != &hfact->entry_list[list]);
		entry_count[list]--;
	}
	if (entry_count[2] != hfact->population)
	{
		return 2;
	}
	if (entry_count[0] + entry_count[2] - 2 * hfact->pair_count !=
		entry_count[1])
	{
		return 3;
	}
	if (entry_count[0] + entry_count[1] + entry_count[2] != hfact->table_size)
	{
		return 4;
	}
	return 0;
}

#endif /* _TEST_HANDFACT */

// This function doubles the size of the table in which the handles and pointers
// are stored.  It is called by assign_HF_handle() when there is insufficient
// space in the table to assign the newly requested handle.  If the expansion
// is successful, the function returns a value of 0.  If the expansion fails
// (due, for example, to an inability to allocate memory), the function returns
// a value of 1.
//
int expand_HF_table(
	HandleFactory *hfact)
{
	int double_size;
	HFEntry *new_entries;
	HFEntry *old_entries;
	HFEntry *old_entry;
	HFEntry *low_entry;
	HFEntry *high_entry;
	HFEntry *assigned_entry;
	HFEntry *secondary_entry;
	HFEntry *other_entry;
	HFHandle handle;
	HFHandle next_handle;
	HFHandle other_handle;
	void *reference;
	int other_entry_index;
	int index;

	// Expanded table is double the size of the old table.
	double_size = hfact->table_size * 2;
	// Allocate space for the expanded table.
	NEW_HFEntry_array(new_entries,double_size);
	if (new_entries == 0)
	{
		// Memory could not be allocated for the new array of entries.
		// Therefore, we return an indication of failure.
		return 1;
	}
	// Since we are doubling the table size, we will be treating one more bit
	// of each handle as a bit of the entry index.  The value of this bit
	// determines the index of the entry in the new table.  For each entry,
	// we have to determine the value of this bit and relocate the entry to
	// the indicated location.
	for (index = 0; index < hfact->table_size; index++)
	{
		old_entry = &hfact->entries[index];
		low_entry = &new_entries[index];
		high_entry = &new_entries[hfact->table_size + index];
		handle = old_entry->handle;
		next_handle = old_entry->next_handle;
		reference = old_entry->reference;
		// One of the two entries in the new table that correspond to the
		// indexed entry in the old table will have a next handle value equal
		// to the next handle value of the entry in the old table, and one will
		// have a handle value equal to the indexed entry's next handle plus
		// the old table size.
		other_handle = next_handle + hfact->table_size;
		if (other_handle == 0)
		{
			// The handle value has wrapped around back to zero; however, zero
			// is a reserved value, so we instead set the next handle to the
			// subsequent legal value, which is the new table size.
			other_handle = double_size;
		}
		if ((handle & hfact->table_size) == 0)
		{
			// The handle of the old entry has a zero in its next bit, so the
			// old entry will be located in the lower half of the new table.
			if ((next_handle & hfact->table_size) == 0)
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the lower entry
				// and the other next handle value will be the next handle
				// value for the higher entry.  The high entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->handle = other_handle;
				high_entry->next_handle = other_handle;
				low_entry->next_handle = next_handle;
			}
			else
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the higher entry
				// and the other next handle value will be the next handle
				// value for the lower entry.  The high entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->handle = next_handle;
				high_entry->next_handle = next_handle;
				low_entry->next_handle = other_handle;
			}
			// The high entry is unassigned, so set its reference to null.
			// Copy the information from the old entry to the low entry.
			// Remove the old entry from the assigned list, and replace it
			// with the low entry.
			high_entry->reference = 0;
			low_entry->handle = handle;
			low_entry->reference = reference;
			old_entry->next_entry->prev_entry = low_entry;
			old_entry->prev_entry->next_entry = low_entry;
			low_entry->next_entry = old_entry->next_entry;
			low_entry->prev_entry = old_entry->prev_entry;
		}
		else
		{
			// The handle of the old entry has a one in its next bit, so the
			// old entry will be located in the higher half of the new table.
			if ((next_handle & hfact->table_size) == 0)
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the lower entry
				// and the other next handle value will be the next handle
				// value for the higher entry.  The low entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->next_handle = other_handle;
				low_entry->handle = next_handle;
				low_entry->next_handle = next_handle;
			}
			else
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the higher entry
				// and the other next handle value will be the next handle
				// value for the lower entry.  The low entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->next_handle = next_handle;
				low_entry->handle = other_handle;
				low_entry->next_handle = other_handle;
			}
			// The low entry is unassigned, so set its reference to null.
			// Copy the information from the old entry to the high entry.
			// Remove the old entry from the assigned list, and replace it
			// with the high entry.
			low_entry->reference = 0;
			high_entry->handle = handle;
			high_entry->reference = reference;
			old_entry->next_entry->prev_entry = high_entry;
			old_entry->prev_entry->next_entry = high_entry;
			high_entry->next_entry = old_entry->next_entry;
			high_entry->prev_entry = old_entry->prev_entry;
		}
	}
	// All of the unassigned entries in the new table will be placed on the
	// secondary list.  We loop through the assigned list and place the
	// unassigned entry corresponding each assigned entry onto the secondary
	// list.  Doing the list assignment in this manner tends to approximately
	// sort the secondary list according to handle value, since the assigned
	// list is sorted according to assignment order, and this approximately
	// correlates to the handle value.
	assigned_entry = hfact->entry_list[LD_ASSIGNED].next_entry;
	secondary_entry = &hfact->entry_list[LD_SECONDARY];
	while (assigned_entry != &hfact->entry_list[LD_ASSIGNED])
	{
		other_entry_index =
			assigned_entry->handle + hfact->table_size & double_size - 1;
		other_entry = &new_entries[other_entry_index];
		secondary_entry->next_entry = other_entry;
		other_entry->prev_entry = secondary_entry;
		secondary_entry = other_entry;
		assigned_entry = assigned_entry->next_entry;
	}
	// Wrap up lists by connecting in tails.
	secondary_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
	hfact->entry_list[LD_SECONDARY].prev_entry = secondary_entry;
	// This expansion increases the hysteresis debt by the cost of one set of
	// allocation and deallocation operations plus the cost of splitting each
	// entry into two entries.
	hfact->hysteresis_debt += ALLOCATION_COST + hfact->table_size;
	// Save a pointer to the old entry table so that it can be deallocated.
	old_entries = hfact->entries;
	// Note that we have not modified the handle, next_handle, or reference
	// fields of any entries in the old table.  Therefore, any calls to the
	// dereference_HF_handle() routine that may have been made by other threads
	// during the above operations would have been performed successfully.
	// We are now about to increase the table size and update the entries
	// variable to point to the new table.  These operations must be performed
	// atomically in order for the dereference routine to perform correctly.
	// We thus bracket the operations with increments to the verifier variables.
	// When the verifiers have the same value, the table_size and entries
	// variables are in a consistent state.  This is checked by the dereference
	// routine.
	hfact->verifier0++;                                // begin critical section
	hfact->entries = new_entries;
	hfact->table_size = double_size;
	hfact->verifier1 = hfact->verifier0;                 // end critical section
	// Deallocate the old table.
	GpcFreeMem(old_entries, handleFactoryTag);
	// Since the new table was created by expanding a half-size table, the pair
	// count must be zero.
	hfact->pair_count = 0;
	// return an indication of success.
	return 0;
}

// This function halves the size of the table in which the handles and pointers
// are stored.  In order to reduce the amount of space consumed by the handle
// factory, this function is called called by release_HF_handle() and
// revoke_ancient_HF_handles() when they determine that the table can and should
// be contracted.  The table can be contracted when pair_count == 0 and
// table_size > 2.  However, the table may not be contracted then, because
// hysteresis is employed both to keep the mean assignment and release times
// constant and to minimize the allocation chatter of rapidly expanding and
// contracting the table.  If the contraction is successful, the function
// returns a value of 0.  If the contraction fails, the function returns a
// value of 1.
//
int contract_HF_table(
	HandleFactory *hfact)
{
	HFEntry *new_entries;
	HFEntry *old_entries;
	int *list;
	int half_size;
	int quarter_size;
	int index;
	HFEntry *high_entry1;
	HFEntry *high_entry0;
	HFEntry *low_entry1;
	HFEntry *low_entry0;
	HFEntry *new_entry1;
	HFEntry *new_entry0;
	HFHandle adjusted_high_next_handle1;
	HFHandle adjusted_low_next_handle1;
	HFHandle next_handle1;
	HFHandle adjusted_high_next_handle0;
	HFHandle adjusted_low_next_handle0;
	HFHandle next_handle0;
	HFHandle adjusted_new_handle0;
	HFHandle adjusted_new_handle1;
	HFEntry *entry;
	HFEntry *primary_entry;
	HFEntry *secondary_entry;

	// Contracted table is half the size of the old table.
	half_size = hfact->table_size / 2;
	quarter_size = half_size / 2;
	// Allocate space for the contracted table.
	NEW_HFEntry_array(new_entries,half_size);
	if (new_entries == 0)
	{
		// Memory could not be allocated for the new array of entries, so we
		// are ironically prevented from reducing the amount of memory that
		// the handle factory is consuming. Therefore, we return an indication
		// of failure.
		return 1;
	}
	// Allocate space for auxiliary array of list indicators
	NEW_int_array(list,half_size);
	if (list == 0)
	{
		// Memory could not be allocated for the auxiliary array, so again we
		// are ironically prevented from reducing the amount of memory that
		// the handle factory is consuming. Therefore, we return an indication
		// of failure.  First, however, we must free the memory allocated for
		// the new array of entries above.
		GpcFreeMem(new_entries, handleFactoryTag);
		return 1;
	}
	// Since we are halving the size of the table, it might seem reasonable to
	// loop through each index of the new table and merge the two corresponding
	// entries from the old table.  This is in fact what the following routine
	// does; however, it does it by looping through only half of the new indices
	// and processing two merges for each index.  It does this so that it can
	// then examine the two new entries to determine on which list to place each
	// of them.
	for (index = 0; index < quarter_size; index++)
	{
		// We're looking at four entries at once.  First we merge high_entry1
		// and low_entry1, and then we independently merge high_entry0 and
		// low_entry0.  After the two merges, we examine the results jointly.
		high_entry1 = &hfact->entries[half_size + quarter_size + index];
		high_entry0 = &hfact->entries[half_size + index];
		low_entry1 = &hfact->entries[quarter_size + index];
		low_entry0 = &hfact->entries[index];
		new_entry1 = &new_entries[quarter_size + index];
		new_entry0 = &new_entries[index];
		// When merging two entries, the next handle value for the combined
		// entry is equal to the larger next handle value of the two, minus
		// the new table size.  However, the determination of which is larger
		// must be made with respect to their logical acyclic values rather
		// than their actual cyclic values, so we subtract from each the value
		// of handle_base, modulo the size of the handle space.  The modulo is
		// implicit.
		adjusted_high_next_handle1 =
			high_entry1->next_handle - hfact->handle_base;
		adjusted_low_next_handle1 =
			low_entry1->next_handle - hfact->handle_base;
		next_handle1 = __max(adjusted_high_next_handle1,
			adjusted_low_next_handle1) + hfact->handle_base - half_size;
		// Since handle 1 is -- by definition -- in either the second or fourth
		// quarter of the table, there is no need to check for the reserved
		// value of zero.
		if (high_entry1->handle != high_entry1->next_handle)
		{
			// The high entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry1->handle = high_entry1->handle;
			new_entry1->reference = high_entry1->reference;
			high_entry1->next_entry->prev_entry = new_entry1;
			high_entry1->prev_entry->next_entry = new_entry1;
			new_entry1->next_entry = high_entry1->next_entry;
			new_entry1->prev_entry = high_entry1->prev_entry;
		}
		else if (low_entry1->handle != low_entry1->next_handle)
		{
			// The low entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry1->handle = low_entry1->handle;
			new_entry1->reference = low_entry1->reference;
			low_entry1->next_entry->prev_entry = new_entry1;
			low_entry1->prev_entry->next_entry = new_entry1;
			new_entry1->next_entry = low_entry1->next_entry;
			new_entry1->prev_entry = low_entry1->prev_entry;
		}
		else
		{
			// Neither entry is assigned, so we indicate an unassigned condition
			// in the new entry.
			new_entry1->handle = next_handle1;
			new_entry1->reference = 0;
			if (adjusted_high_next_handle1 < adjusted_low_next_handle1)
			{
				// The high entry next handle has a lesser value than the low
				// entry next handle, so the high entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				high_entry1->next_entry->prev_entry = new_entry1;
				high_entry1->prev_entry->next_entry = new_entry1;
				new_entry1->next_entry = high_entry1->next_entry;
				new_entry1->prev_entry = high_entry1->prev_entry;
			}
			else
			{
				// The low entry next handle has a lesser value than the high
				// entry next handle, so the low entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				low_entry1->next_entry->prev_entry = new_entry1;
				low_entry1->prev_entry->next_entry = new_entry1;
				new_entry1->next_entry = low_entry1->next_entry;
				new_entry1->prev_entry = low_entry1->prev_entry;
			}
		}
		// Set the next handle for the new entry.
		new_entry1->next_handle = next_handle1;
		// When merging two entries, the next handle value for the combined
		// entry is equal to the larger next handle value of the two, minus
		// the new table size.  However, the determination of which is larger
		// must be made with respect to their logical acyclic values rather
		// than their actual cyclic values, so we subtract from each the value
		// of handle_base, modulo the size of the handle space.  The modulo is
		// implicit.
		adjusted_high_next_handle0 =
			high_entry0->next_handle - hfact->handle_base;
		adjusted_low_next_handle0 =
			low_entry0->next_handle - hfact->handle_base;
		next_handle0 = __max(adjusted_high_next_handle0,
			adjusted_low_next_handle0) + hfact->handle_base - half_size;
		if (next_handle0 == 0)
		{
			// The handle value has wrapped around back to zero; however, zero
			// is a reserved value, so we instead set the next handle to the
			// subsequent legal value, which is the new table size.
			next_handle0 = half_size;
		}
		if (high_entry0->handle != high_entry0->next_handle)
		{
			// The high entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry0->handle = high_entry0->handle;
			new_entry0->reference = high_entry0->reference;
			high_entry0->next_entry->prev_entry = new_entry0;
			high_entry0->prev_entry->next_entry = new_entry0;
			new_entry0->next_entry = high_entry0->next_entry;
			new_entry0->prev_entry = high_entry0->prev_entry;
		}
		else if (low_entry0->handle != low_entry0->next_handle)
		{
			// The low entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry0->handle = low_entry0->handle;
			new_entry0->reference = low_entry0->reference;
			low_entry0->next_entry->prev_entry = new_entry0;
			low_entry0->prev_entry->next_entry = new_entry0;
			new_entry0->next_entry = low_entry0->next_entry;
			new_entry0->prev_entry = low_entry0->prev_entry;
		}
		else
		{
			// Neither entry is assigned, so we indicate an unassigned condition
			// in the new entry.
			new_entry0->handle = next_handle0;
			new_entry0->reference = 0;
			if (adjusted_high_next_handle0 < adjusted_low_next_handle0)
			{
				// The high entry next handle has a lesser value than the low
				// entry next handle, so the high entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				high_entry0->next_entry->prev_entry = new_entry0;
				high_entry0->prev_entry->next_entry = new_entry0;
				new_entry0->next_entry = high_entry0->next_entry;
				new_entry0->prev_entry = high_entry0->prev_entry;
			}
			else
			{
				// The low entry next handle has a lesser value than the high
				// entry next handle, so the low entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				low_entry0->next_entry->prev_entry = new_entry0;
				low_entry0->prev_entry->next_entry = new_entry0;
				new_entry0->next_entry = low_entry0->next_entry;
				new_entry0->prev_entry = low_entry0->prev_entry;
			}
		}
		// Set the next handle for the new entry.
		new_entry0->next_handle = next_handle0;
		// Now that we have merged high_entry1 and low_entry1 into new_entry1,
		// and independently merged high_entry0 and low_entry0 into new_entry0,
		// we examine the two new entries to determine on which list to place
		// each of them.  Note that we do not actually manipulate the lists in
		// this portion of the code; we merely make decisions and record these
		// decisions for the future.
		if (new_entry0->handle == new_entry0->next_handle &&
			new_entry1->handle == new_entry1->next_handle)
		{
			// Both new_entry0 and new_entry1 are unassigned, so one of them
			// belongs on the primary list and the other on the secondary list.
			// Which goes on which is determined by a comparison of their handle
			// values.  We're being tricky with unsigned integer math here.
			// Before comparing the two handles, we subtract from each the value
			// of handle_base, modulo the size of the handle space (the modulo
			// is implicit).  This allows the effective comparison of their
			// logical acyclic values rather than their actual cyclic values.
			adjusted_new_handle0 = new_entry0->handle - hfact->handle_base;
			adjusted_new_handle1 = new_entry1->handle - hfact->handle_base;
			if (adjusted_new_handle0 < adjusted_new_handle1)
			{
				// The handle value for new_entry0 is lower, so new_entry0
				// belongs on the primary list and new_entry1 on the secondary
				// list.  We indicate this decision in the list array.
				list[index] = LD_PRIMARY;
				list[quarter_size + index] = LD_SECONDARY;
			}
			else
			{
				// The handle value for new_entry1 is lower, so new_entry1
				// belongs on the primary list and new_entry0 on the secondary
				// list.  We indicate this decision in the list array.
				list[index] = LD_SECONDARY;
				list[quarter_size + index] = LD_PRIMARY;
			}
		}
		else
		{
			// Either new_entry0 or new_entry1 (or both) is assigned, and it is
			// therefore already on the assigned list.  If one of the entries
			// is not assigned, it belongs on the secondary list.  We indicate
			// this decision in both places of the list array, which is safe to
			// do since the assigned entry's list indicator will never be
			// examined.
			list[index] = LD_SECONDARY;
			list[quarter_size + index] = LD_SECONDARY;
		}
		if (new_entry0->handle != new_entry0->next_handle &&
			new_entry1->handle != new_entry1->next_handle)
		{
			// Both new_entry0 and new_entry1 are assigned, so they form a pair.
			// We thus increment the pair count.  Note that we never set the
			// pair count to zero above, but this was not necessary since the
			// table could not be contracted unless the pair count was zero.
			hfact->pair_count++;
		}
	}
	// At this point, the table has been completely contracted except for the
	// reassembly of the unassigned lists.  In the code above, any entries that
	// had previously been on the secondary list were merged with assigned
	// entries, so they are no longer relevant.  Only those entries that had
	// previously been (and are still) on the primary list will still be
	// unassigned.  We now loop through the primary list and place each list
	// element on the appropriate list, as indicated by the list array.  Doing
	// the list assignment in these two steps preserves the general order of
	// the entries, which has some value since they will tend to be partially
	// sorted.
	entry = hfact->entry_list[LD_PRIMARY].next_entry;
	primary_entry = &hfact->entry_list[LD_PRIMARY];
	secondary_entry = &hfact->entry_list[LD_SECONDARY];
	while (entry != &hfact->entry_list[LD_PRIMARY])
	{
		if (list[entry->handle & half_size - 1] == LD_PRIMARY)
		{
			// The list array indicates the primary list, so place the entry
			// onto the primary list.
			primary_entry->next_entry = entry;
			entry->prev_entry = primary_entry;
			primary_entry = entry;
		}
		else
		{
			// The list array indicates the secondary list, so place the entry
			// onto the secondary list.
			secondary_entry->next_entry = entry;
			entry->prev_entry = secondary_entry;
			secondary_entry = entry;
		}
		entry = entry->next_entry;
	}
	// Wrap up lists by connecting in tails.
	primary_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
	hfact->entry_list[LD_PRIMARY].prev_entry = primary_entry;
	secondary_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
	hfact->entry_list[LD_SECONDARY].prev_entry = secondary_entry;
	// This contraction increases the hysteresis debt by the cost of one set of
	// allocation and deallocation operations plus the cost of merging each
	// pair of entries into a single entry.
	hfact->hysteresis_debt += ALLOCATION_COST + half_size;
	// Save a pointer to the old entry table so that it can be deallocated.
	old_entries = hfact->entries;
	// Note that we have not modified the handle, next_handle, or reference
	// fields of any entries in the old table.  Therefore, any calls to the
	// dereference_HF_handle() routine that may have been made by other threads
	// during the above operations would have been performed successfully.
	// We are now about to decrease the table size and update the entries
	// variable to point to the new table.  These operations must be performed
	// atomically in order for the dereference routine to perform correctly.
	// We thus bracket the operations with increments to the verifier variables.
	// When the verifiers have the same value, the table_size and entries
	// variables are in a consistent state.  This is checked by the dereference
	// routine.
	hfact->verifier0++;                                // begin critical section
	hfact->table_size = half_size;
	hfact->entries = new_entries;
	hfact->verifier1 = hfact->verifier0;                 // end critical section
	
    // Deallocate the old table and the auxiliary list indicator array.
	GpcFreeMem(old_entries, handleFactoryTag);
	GpcFreeMem(list, handleFactoryTag);
	// return an indication of success.
	return 0;
}

// This function revokes handles that are between handle_base and handle_base
// + 2 * HANDLE_RANGE_STEP - 1, inclusive.  It then increments the value of
// handle_base by HANDLE_RANGE_STEP.  Suspended handles will be revoked one
// revokation pass later than non-suspended handles.
//
void revoke_ancient_HF_handles(
	HandleFactory *hfact)
{
	HFHandle new_handle_base;
	int half_size;
	int index;
	HFEntry *high_entry;
	HFEntry *low_entry;
	HFHandle adjusted_high_handle;
	HFHandle adjusted_low_handle;
	HFHandle adjusted_high_next_handle;
	HFHandle adjusted_low_next_handle;
	HFHandle handle;
	volatile HFEntry *seq_entry;                // volatile to ensure sequencing

	// Compute new handle base.
	new_handle_base = hfact->handle_base + HANDLE_RANGE_STEP;
	// It might seem reasonable to loop through each index of the table and
	// determine whether to revoke the handle of each entry.  This is in fact
	// what the following routine does; however, it does it by looping through
	// only half of the indices and examining two entries for each index.  It
	// does this so that it can compare the two entries to determine on which
	// list to place each of them.
	half_size = hfact->table_size / 2;
	for (index = 0; index < half_size; index++)
	{
		// We're looking at two entries at once.
		high_entry = &hfact->entries[half_size + index];
		low_entry = &hfact->entries[index];
		// We're being tricky with unsigned integer math here.  Before making
		// comparisons on either handle, we subtract from it the value of
		// handle_base, modulo the size of the handle space (the modulo is
		// implicit).  This allows the effective comparison of its logical
		// acyclic value rather than its actual cyclic value.
		adjusted_high_handle = high_entry->handle - hfact->handle_base;
		adjusted_low_handle = low_entry->handle - hfact->handle_base;
		if (adjusted_high_handle < 2 * HANDLE_RANGE_STEP ||
			adjusted_low_handle < 2 * HANDLE_RANGE_STEP)
		{
			// At least one of the handles is less than twice HANDLE_RANGE_STEP
			// more than the current handle base, so it will need to be updated.
			// For the vast majority of cases, this test is expected to fail,
			// and so all of the following work can be skipped.
			if (high_entry->handle != high_entry->next_handle &&
				low_entry->handle != low_entry->next_handle)
			{
				// Both of the entries are assigned, so, since at least one of
				// them will be revoked, we will be losing one pair.
				hfact->pair_count--;
			}
			if (high_entry->handle == high_entry->next_handle ||
				adjusted_high_handle < 2 * HANDLE_RANGE_STEP)
			{
				// Either the high entry is unassigned or in need of revokation
				// (after which it will be unassigned), so we remove it from
				// whatever list it is on.  We do this because all unassigned
				// entries will be added to the appropriate list below.
				high_entry->next_entry->prev_entry = high_entry->prev_entry;
				high_entry->prev_entry->next_entry = high_entry->next_entry;
				// Zeroing these pointers is unnecessary, but it will help to
				// catch any mistakes made further down.
				high_entry->next_entry = 0;
				high_entry->prev_entry = 0;
			}
			if (adjusted_high_handle < 2 * HANDLE_RANGE_STEP)
			{
				// The high handle needs to be updated.
				if (high_entry->handle != high_entry->next_handle)
				{
					// The high handle is assigned, so this updating will
					// revoke the handle.  Thus, we decrement the population.
					hfact->population--;
				}
				// Compute the handle value as the maximum of (1) the next
				// handle and (2) the new handle base plus the entry index.
				// We're being tricky with unsigned integer math here.  The
				// maximum involves partial decomposition of the sums, from
				// which we then subtract the value of handle_base, modulo the
				// size of the handle space (the modulo is implicit).  Thus,
				// the maximum is taken with respect to the logical acyclic
				// values rather than the actual cyclic values.
				adjusted_high_next_handle =
					high_entry->next_handle - hfact->handle_base;
				handle = __max(adjusted_high_next_handle,
					HANDLE_RANGE_STEP + half_size + index) + hfact->handle_base;
				// Since the high handle is -- by definition -- in the upper
				// half of the table, there is no need to check for the reserved
				// value of zero.
				// Update the handle value.  Since this updating will invalidate
				// the handle if it is currently assigned, the order of the
				// operations is important to correct multi-threaded operation.
				seq_entry = high_entry;
				seq_entry->next_handle = handle;
				seq_entry->handle = handle;           // first invalidate handle
				seq_entry->reference = 0;                // then clear reference
			}
			if (low_entry->handle == low_entry->next_handle ||
				adjusted_low_handle < 2 * HANDLE_RANGE_STEP)
			{
				// Either the low entry is unassigned or in need of revokation
				// (after which it will be unassigned), so we remove it from
				// whatever list it is on.  We do this because all unassigned
				// entries will be added to the appropriate list below.
				low_entry->next_entry->prev_entry = low_entry->prev_entry;
				low_entry->prev_entry->next_entry = low_entry->next_entry;
				// Zeroing these pointers is unnecessary, but it will help to
				// catch any mistakes made further down.
				low_entry->next_entry = 0;
				low_entry->prev_entry = 0;
			}
			if (adjusted_low_handle < 2 * HANDLE_RANGE_STEP)
			{
				// The low handle needs to be updated.
				if (low_entry->handle != low_entry->next_handle)
				{
					// The low handle is assigned, so this updating will
					// revoke the handle.  Thus, we decrement the population.
					hfact->population--;
				}
				// Compute the handle value as the maximum of (1) the next
				// handle and (2) the new handle base plus the entry index.
				// We're being tricky with unsigned integer math here.  The
				// maximum involves partial decomposition of the sums, from
				// which we then subtract the value of handle_base, modulo the
				// size of the handle space (the modulo is implicit).  Thus,
				// the maximum is taken with respect to the logical acyclic
				// values rather than the actual cyclic values.
				adjusted_low_next_handle =
					low_entry->next_handle - hfact->handle_base;
				handle = __max(adjusted_low_next_handle,
					HANDLE_RANGE_STEP + index) + hfact->handle_base;
				if (handle == 0)
				{
					// The handle value has wrapped around back to zero;
					// however, zero is a reserved value, so we instead set the
					// handle to the subsequent legal value, which is the table
					// size.
					handle = hfact->table_size;
				}
				// Update the handle value.  Since this updating will invalidate
				// the handle if it is currently assigned, the order of the
				// operations is important to correct multi-threaded operation.
				seq_entry = low_entry;
				seq_entry->next_handle = handle;
				seq_entry->handle = handle;           // first invalidate handle
				seq_entry->reference = 0;                // then clear reference
			}
			if (high_entry->handle != high_entry->next_handle)
			{
				// The high entry is still assigned, so the low entry belongs
				// on the secondary list.
				low_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
				low_entry->prev_entry =
					hfact->entry_list[LD_SECONDARY].prev_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
					low_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry = low_entry;
			}
			else if (low_entry->handle != low_entry->next_handle)
			{
				// The low entry is still assigned, so the high entry belongs
				// on the secondary list.
				high_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
				high_entry->prev_entry =
					hfact->entry_list[LD_SECONDARY].prev_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
					high_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry = high_entry;
			}
			else
			{
				// Neither entry is still assigned, so one entry belongs on the
				// primary list and one on the secondary list.  Which goes on
				// which is determined by a comparison of their handle values.
				// We're being tricky with unsigned integer math here.  Before
				// comparing the two handles, we subtract from each the value
				// of handle_base, modulo the size of the handle space (the
				// modulo is implicit).  This allows the effective comparison
				// of their logical acyclic values rather than their actual
				// cyclic values.
				adjusted_high_next_handle =
					high_entry->next_handle - new_handle_base;
				adjusted_low_next_handle =
					low_entry->next_handle - new_handle_base;
				if (adjusted_low_next_handle < adjusted_high_next_handle)
				{
					// The handle value for the low entry is smaller, so it
					// belongs on the primary list and the high entry on the
					// secondary list.
					high_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
					high_entry->prev_entry =
						hfact->entry_list[LD_SECONDARY].prev_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
						high_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry = high_entry;
					low_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
					low_entry->prev_entry =
						hfact->entry_list[LD_PRIMARY].prev_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry->next_entry =
						low_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry = low_entry;
				}
				else
				{
					// The handle value for the high entry is smaller, so it
					// belongs on the primary list and the low entry on the
					// secondary list.
					high_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
					high_entry->prev_entry =
						hfact->entry_list[LD_PRIMARY].prev_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry->next_entry =
						high_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry = high_entry;
					low_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
					low_entry->prev_entry =
						hfact->entry_list[LD_SECONDARY].prev_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
						low_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry = low_entry;
				}
			}
		}
	}
	// Update the handle base with the new handle base.
	hfact->handle_base = new_handle_base;
	// To contract the table, there must be no pairs, because otherwise two
	// assigned handles would yield the same entry index and thereby conflict.
	// Furthermore, the table size must be greater than 2, because much of the
	// handle factory code assumes that the table is at least of size 2.  In
	// addition to these strict requirements, hysteresis is employed both to
	// keep the mean assignment and release times constant and to minimize the
	// allocation chatter of rapidly expanding and contracting the table.  Only
	// if the hysteresis debt is zero will the table be contracted.
	if (hfact->pair_count == 0 && hfact->table_size > 2 &&
		hfact->hysteresis_debt == 0)
	{
		contract_HF_table(hfact);
		// Note that we ignore the return code.  If the contraction is
		// unsuccessful, we just continue as usual.  There is no real harm in
		// not contracting the table, except that we consume more space than
		// necessary.
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\pathash.c ===
/*
 *  pathash.c
 *
 *  author:	John R. Douceur
 *  date:	5 May 1997
 *
 *  This source file provides functions that implement insertion, removal,
 *  search, scan, and flush operations on the pat-hash table database.  The
 *  code is object-oriented C, transliterated from a C++ implementation.
 *
 *  The pat-hash database is a combination of a dynamically sized, separately
 *  chained hash table and a Patricia tree.  The hash table dynamically grows
 *  and shrinks as needed, and the workload of modifying the table size is
 *  distributed evenly among the insertion or removal operations that cause
 *  the growth or shrinkage.
 *
 *  The insertion and removal operations manage both a hash table and a Patricia
 *  tree, but the search routine uses only the hash table for performing the
 *  search.  The Patrica tree is present to support a scan operation, which
 *  searches the database for all entries that match a given pattern, where the
 *  pattern that is scanned may contain wildcards.
 *
 *  None of the code or comments in this file needs to be understood by writers
 *  of client code; all explanatory information for clients is found in the
 *  associated header file, rhizome.h.
 *
 */

#include "gpcpre.h"

#define MAGIC_NUMBER 0x9e4155b9     // Fibonacci hash multiplier (see Knuth 6.4)

// This macro allocates a new pat-hash table entry structure.  The size of
// the structure is a function of the value of keybytes, since the entry stores
// a copy of the pattern.  The value array, which is the last field in the
// structure, is declared as having a single element, but this array will
// actually extend beyond the defined end of the structure into additional
// space that is allocated for it by the following macro.
//
//#define NEW_PHTableEntry \
//	((PHTableEntry *)malloc(sizeof(PHTableEntry) + phtable->keybytes - 1))
#define NEW_PHTableEntry(_pe) \
	GpcAllocMem(&_pe,\
                sizeof(PHTableEntry) + phtable->keybytes - 1,\
                PathHashTag)

// This macro allocates a new pat-hash table group structure.  The size of
// the structure is a function of the size of the group.  The entry_list array,
// which is the last field in the structure, is declared as having a single
// element, but this array will actually extend beyond the defined end of the
// structure into additional space that is allocated for it by the following
// macro.
//
//#define NEW_PHTableGroup(group_size) \
//	((PHTableGroup *)malloc(sizeof(PHTableGroup) + \
//	((group_size) - 1) * sizeof(PHTableEntry *)))
#define NEW_PHTableGroup(group_size, _pg) \
	GpcAllocMem(&_pg,\
                sizeof(PHTableGroup) + \
                ((group_size) - 1) * sizeof(PHTableEntry *),\
                PathHashTag)

// This macro gets the indexed bit of the value, where the most-significant bit
// is defined as bit 0.
//
#define BIT_OF(value, index) \
	(((value)[(index) >> 3] >> (7 - ((index) & 0x7))) & 0x1)

// Following is a prototype for a static function that is used internally by
// the implementation of the pat-hash routines.

void
node_scan(
	PatHashTable *phtable,
	PHTableEntry *node,
	int prev_bit,
	char *value,
	char *mask,
	void *context,
	ScanCallback func);

// Since this is not C++, the PatHashTable structure is not self-constructing;
// therefore, the following constructor code must be called on the PatHashTable
// structure after it is allocated.  The argument keybits specifies the size
// (in bits) of each pattern that will be stored in the database.  The usage
// ratio is the target ratio of database entries to discrete hash chains, which
// is also the mean length of a hash chain.  The usage histeresis is the
// histeresis between resizing operations due to insertions and removals.
// Allocation histeresis is the histeresis between allocation and deallocation
// of groups, specified as a binary exponent.  The maximum free list size
// determines the maximum number of elements that will be placed on a free
// list, rather than deallocated, when they are removed.
//
int
constructPatHashTable(
	PatHashTable *phtable,
	int keybits,
	int usage_ratio,
	int usage_histeresis,
	int allocation_histeresis,
	int max_free_list_size)
{
	PHTableGroup *group;
	phtable->keybits = keybits;
	phtable->keybytes = (keybits - 1) / 8 + 1;
	phtable->usage_ratio = usage_ratio;
	phtable->usage_histeresis = usage_histeresis;
	phtable->allocation_histeresis = allocation_histeresis;
	phtable->max_free_list_size = max_free_list_size;
	NEW_PHTableGroup(1, phtable->initial_group);
	phtable->top_group = phtable->initial_group;
	phtable->allocation_exponent = 0;
	phtable->size_exponent = 0;
	phtable->extension_size = 0;
	phtable->population = 0;
	phtable->root = 0;
	phtable->free_list = 0;
	phtable->free_list_size = 0;
	NEW_PHTableGroup(1, group);
	if (phtable->initial_group == 0 || group == 0)
	{
		// Memory could not be allocated for one of the two groups created by
		// the constructor.  Therefore, we return an indication of failure to
		// the client.
        
        // 286334 : Not so fast! Please free memory before leaving...
        if (phtable->initial_group != 0) {
            GpcFreeMem(phtable->initial_group, PatHashTag);
        }

        if (group != 0) {
            GpcFreeMem(group, PatHashTag);
        }

		return 1;
	}
	group->previous = 0;
	group->entry_list[0] = 0;
	phtable->initial_group->previous = group;
	return 0;
}

// Since this is not C++, the PatHashTable structure is not self-destructing;
// therefore, the following destructor code must be called on the PatHashTable
// structure before it is deallocated.
//
void
destructPatHashTable(
	PatHashTable *phtable)
{
	PHTableGroup *group, *previous;
	PHTableEntry *entry, *next;
	int index, size;
	// First, free all groups that are allocated but not currently used.
	group = phtable->top_group;
	while (group != phtable->initial_group)
	{
		previous = group->previous;
		GpcFreeMem(group, PatHashTag);
		group = previous;
	}
	// Then, free the entries in the initial group.  Since not all fields
	// in the initial group's table may be valid, only check those whose
	// indices are less than the extension size.
	for (index = phtable->extension_size - 1; index >= 0; index--)
	{
		entry = group->entry_list[index];
		while (entry != 0)
		{
			next = entry->next;
			GpcFreeMem(entry, PatHashTag);
			entry = next;
		}
	}
	// Then free the initial group.
	previous = group->previous;
	GpcFreeMem(group, PatHashTag);
	group = previous;
	// Scan through all remaining groups except the last one, freeing all
	// entries in each group, and thereafter freeing the group.
	size = 1 << (phtable->size_exponent - 1);
	while (group->previous != 0)
	{
		for (index = size - 1; index >= 0; index--)
		{
			entry = group->entry_list[index];
			while (entry != 0)
			{
				next = entry->next;
				GpcFreeMem(entry, PatHashTag);
				entry = next;
			}
		}
		previous = group->previous;
		GpcFreeMem(group, PatHashTag);
		group = previous;
		size >>= 1;
	}
	// The last group is special, since it has a size of one, but the logic
	// used in the preceding loop would have calculated its size as zero.
	// Rather than complicating the previous loop with a check for a single
	// special case, we simply free the last group and its entries in the
	// following code.
	entry = group->entry_list[0];
	while (entry != 0)
	{
		next = entry->next;
		GpcFreeMem(entry, PatHashTag);
		entry = next;
	}
	GpcFreeMem(group, PatHashTag);
	// Finally, free all of the entries in the free list.
	while (phtable->free_list != 0)
	{
		next = phtable->free_list->next;
		GpcFreeMem(phtable->free_list, PatHashTag);
		phtable->free_list = next;
	}
}

// This function inserts a new specific pattern into the database, passed as
// an array of bytes.  The client supplies a digested form of the pattern as
// the chyme argument.
//
// The client specifies a void pointer reference value to associate with the
// specific pattern.  When the specific pattern is installed, the insert
// routine returns a pointer to a SpecificPatternHandle.
//
// If the submitted pattern has already been installed in the database, then
// the insertion does not occur, and the SpecificPatternHandle of the
// previously installed pattern is returned.
//
// The insertion routine inserts the new pattern into both the hash table and
// the Patricia tree, and the two insertions are almost completely independent
// except for the shared entry structure.
//
SpecificPatternHandle
insertPatHashTable(
	PatHashTable *phtable,
	char *pattern,
	unsigned int chyme,
	void *reference)
{
	unsigned int hash, address, small_address, split_point;
	PHTableGroup *group;
	PHTableEntry **entry, *new_entry;
	char *value;
	int index, group_size, pivot_bit, bit_value;
	// The first portion of this routine inserts the new pattern into the hash
	// table.  To begin, we determine whether the number of hash chains needs
	// to be increased in order to maintain the desired usage ratio.
	group_size = 1 << phtable->size_exponent;
	if (phtable->population >=
		(group_size + phtable->extension_size) * phtable->usage_ratio)
	{
		// The number of hash chains needs to be increased.  So, determine
		// whether the initial group is completely full.
		if (phtable->extension_size == group_size)
		{
			// The initial group is completely full.  So, determine whether
			// all allocated groups are currently in use.
			if (phtable->allocation_exponent == phtable->size_exponent)
			{
				// All allocated groups are currently in use.  So, allocate
				// a new group and set its previous pointer to point to the
				// initial group.  Update the allocation values of the structure
				// to reflect the new allocation.
				NEW_PHTableGroup(group_size << 1, group);
				if (group == 0)
				{
					// Memory could not be allocated for the new group.
					// Therefore, we return an indication of falure to the
					// client.
					return 0;
				}
				group->previous = phtable->initial_group;
				phtable->top_group = group;
				phtable->allocation_exponent++;
			}
			else
			{
				// Not all allocated groups are in use.  So, scanning backward
				// from the top group, find the group that immediately follows
				// the initial group.
				group = phtable->top_group;
				while (group->previous != phtable->initial_group)
				{
					group = group->previous;
				}
			}
			// We now have either a newly allocated group or a previously
			// allocated group that immediately follows the initial group.
			// Set this group to be the new initial group, and set the extension
			// size to zero.
			phtable->initial_group = group;
			phtable->size_exponent++;
			phtable->extension_size = 0;
		}
		else
		{
			// The initial group is not completely full.  So, select the initial
			// group.
			group = phtable->initial_group;
		}
		// We now have a group that is not completely full, either because it
		// wasn't completely full when the insert routine was entered, or
		// because it has just been allocated.  In either case, we now split
		// a hash chain from a smaller group into two hash chains, one of which
		// will be placed into an unused entry in the new group.  The address
		// of the hash chain to be split is determined by the extension size.
		// First we find the group that contains this address.
		group = group->previous;
		address = phtable->extension_size;
		while ((address & 0x1) == 0 && group->previous != 0)
		{
			address >>= 1;
			group = group->previous;
		}
		// Then, we scan through the entry list at the given address for the
		// appropriate split point.  The entries are stored in sorted order,
		// and we are essentially shifting one more bit into the address for
		// this value, so the split point can be found by searching for the
		// first entry with the bit set.
		address >>= 1;
		entry = &group->entry_list[address];
		split_point = ((phtable->extension_size << 1) | 0x1)
			<< (31 - phtable->size_exponent);
		while (*entry != 0 && (*entry)->hash < split_point)
		{
 			entry = &(*entry)->next;
		}
		// Now that we have found the split point, we move the split-off
		// piece of the list to the new address, and increment the extension
		// size.
		phtable->initial_group->entry_list[phtable->extension_size] = *entry;
		*entry = 0;
		phtable->extension_size++;
	}
	// Now that the memory management aspects of the hash table insertion have
	// been taken care of, we can perform the actual insertion.  First, we find
	// the address by hashing the chyme value.
	group = phtable->initial_group;
	hash = MAGIC_NUMBER * chyme;
	address = hash >> (31 - phtable->size_exponent);
	// There are two possible values for the address depending upon whether
	// the hash chain pointer is below the extension size.  If it is, then the
	// larger (by one bit) address is used; otherwise, the smaller address is
	// used.
	small_address = address >> 1;
	if ((int)small_address >= phtable->extension_size)
	{
		address = small_address;
		group = group->previous;
	}
	// Next we find the group that contains this address.
	while ((address & 0x1) == 0 && group->previous != 0)
	{
		address >>= 1;
		group = group->previous;
	}
	// Then, we scan through the entry list at the given address for the first
	// entry whose hash value is equal to or greater than the hash of the search
	// key.  The entries are stored in sorted order to improve the search speed.
	address >>= 1;
	entry = &group->entry_list[address];
	while (*entry != 0 && (*entry)->hash < hash)
	{
		entry = &(*entry)->next;
	}
	// Now, we check all entries whose hash value matches that of the search
	// key.
	while (*entry != 0 && (*entry)->hash == hash)
	{
		// For each value whose hash matches, check the actual value to see
		// if it matches the search key.
		value = (*entry)->value;
		for (index = phtable->keybytes-1; index >= 0; index--)
		{
			if (value[index] != pattern[index])
			{
				break;
			}
		}
		if (index < 0)
		{
			// A match is found, so we return the SpecificPatternHandle of the
			// matching entry to the client.
			return *entry;
		}
		entry = &(*entry)->next;
	}
	// A match was not found, so we insert the new entry into the hash chain.
	// First we check to see if there is an entry avalable on the free list.
	if (phtable->free_list != 0)
	{
		// There is an entry available on the free list, so grab it and
		// decrement the size of the free list.
		new_entry = phtable->free_list;
		phtable->free_list = phtable->free_list->next;
		phtable->free_list_size--;
	}
	else
	{
		// There is no entry available on the free list, so allocate a new one.
		NEW_PHTableEntry(new_entry);
		if (new_entry == 0)
		{
			// Memory could not be allocated for the new entry.  Therefore,
			// we return an indication of falure to the client.
			return 0;
		}
	}
	// Set the fields of the new entry to the appropriate information and add
	// the entry to the hash chain.
	new_entry->hash = hash;
	new_entry->reference = reference;
	new_entry->next = *entry;
	for (index = phtable->keybytes - 1; index >= 0; index--)
	{
		new_entry->value[index] = pattern[index];
	}
	*entry = new_entry;
	// The hash table insertion is now complete.  Here we begin the insertion
	// of the new entry into the Patricia tree.  We have to treat an empty
	// tree as a special case.
	if (phtable->root == 0)
	{
		// The Patricia tree is empty, so we set the root to point to the new
		// entry.  This entry is special, since it serves only as a leaf of
		// the Patricia search and not also as a branch node.  A Patricia tree
		// always contains one fewer branch node than the number of leaves.
		// Since a leaf is determined by a pivot bit that is less than or equal
		// to the pivot bit of the parent branch node, a pivot bit of -1 flags
		// this node as always a leaf.
		new_entry->pivot_bit = -1;
		new_entry->children[0] = 0;
		new_entry->children[1] = 0;
		phtable->root = new_entry;
	}
	else
	{
		// The Patricia tree is not empty, so we proceed with the normal
		// insertion process.  Beginning at the root, scan through the tree
		// according to the bits of the new pattern, until we reach a leaf.
		entry = &phtable->root;
		index = -1;
		while ((*entry)->pivot_bit > index)
		{
			index = (*entry)->pivot_bit;
			entry = &(*entry)->children[BIT_OF(pattern, index)];
		}
		// Now, compare the new pattern, bit by bit, to the pattern stored at
		// the leaf, until a non-matching bit is found.  There is no need to
		// check for an exact match, since the hash insert above would have
		// aborted if an exact match had been found.
		value = (*entry)->value;
		pivot_bit = 0;
		while (BIT_OF(value, pivot_bit) == BIT_OF(pattern, pivot_bit))
		{
			pivot_bit++;
		}
		// Now, scan a second time through the tree, until finding either a leaf
		// or a branch with a pivot bit greater than the bit of the non-match.
		entry = &phtable->root;
		index = -1;
		while ((*entry)->pivot_bit > index && (*entry)->pivot_bit < pivot_bit)
		{
			index = (*entry)->pivot_bit;
			entry = &(*entry)->children[BIT_OF(pattern, index)];
		}
		// This is the point at which the new branch must be inserted.  Since
		// each node is both a branch and a leaf, the new entry serves as the
		// new branch, and one of its children points to itself as a leaf.  The
		// other child points to the remaining subtree below the insertion
		// point.
		bit_value = BIT_OF(value, pivot_bit);
		new_entry->pivot_bit = pivot_bit;
		new_entry->children[1 - bit_value] = new_entry;
		new_entry->children[bit_value] = *entry;
		*entry = new_entry;
	}
	// Having inserted the new entry in both the hash table and the Patricia
	// tree, we increment the population and return the SpecificPatternHandle
	// of the new entry.
	phtable->population++;
	return new_entry;
}

// This function removes a pattern from the pat-hash table.  The pattern is
// specified by the SpecificPatternHandle that was returned by the insert
// routine.  No checks are performed to insure that this is a valid handle.
//
// The removal routine removes the pattern from both the hash table and the
// Patricia tree, and the two removals are almost completely independent
// except for the shared entry structure.
//
void
removePatHashTable(
	PatHashTable *phtable,
	SpecificPatternHandle sphandle)
{
	unsigned int hash, address, small_address;
	PHTableGroup *group;
	PHTableEntry **entry, **branch, **parent, *epoint, *bpoint;
	char *value;
	int index, group_size;
	// The first portion of this routine removess the new pattern from the hash
	// table.  First, we find the address by hashing the chyme value.
	group = phtable->initial_group;
	hash = sphandle->hash;
	address = hash >> (31 - phtable->size_exponent);
	// There are two possible values for the address depending upon whether
	// the hash chain pointer is below the extension size.  If it is, then the
	// larger (by one bit) address is used; otherwise, the smaller address is
	// used.
	small_address = address >> 1;
	if ((int)small_address >= phtable->extension_size)
	{
		address = small_address;
		group = group->previous;
	}
	// Next we find the group that contains this address.
	while ((address & 0x1) == 0 && group->previous != 0)
	{
		address >>= 1;
		group = group->previous;
	}
	// Then, we scan through the entry list at the given address for the entry
	// that matches the given SpecificPatternHandle.
	address >>= 1;
	entry = &group->entry_list[address];
	while (*entry != sphandle)
	{
		entry = &(*entry)->next;
	}
	// We then remove the entry from the hash chain and decrement the
	// population.
	*entry = sphandle->next;
	phtable->population--;
	// This completes the actual removal of the entry from the hash table, but
	// we now have to determine whether to reduce the number of hash chains in
	// order to maintain the desired usage ratio.  Note that the usage
	// histeresis is factored into the calculation.
	group_size = 1 << phtable->size_exponent;
	if (phtable->population + phtable->usage_histeresis <
		(group_size + phtable->extension_size - 1) * phtable->usage_ratio)
	{
		// The number of hash chains needs to be reduced.  So, we coalesce two
		// hash chains into a single hash chain.  The address of the hash chains
		// is determined by the extension size.  First we decrement the
		// extension size and find the group that contains the address of the
		// hash chain that is being retained.
		phtable->extension_size--;
		group = phtable->initial_group->previous;
		address = phtable->extension_size;
		while ((address & 0x1) == 0 && group->previous != 0)
		{
			address >>= 1;
			group = group->previous;
		}
		// Then, we find the end of the entry list at the given address.
		address >>= 1;
		entry = &group->entry_list[address];
		while (*entry != 0)
		{
 			entry = &(*entry)->next;
		}
		// We then make the last entry in the hash chain point to the first
		// entry in the other hash chain that is being coalesced.  We do not
		// need to update the group's pointer to the other hash chain, since
		// it is now beyond the extension size, and it will thus never be seen.
		*entry = phtable->initial_group->entry_list[phtable->extension_size];
		// Now, we check to see whether a group has been completely emptied.
		// We also check the size exponent, since even if we have just emptied
		// the first non-special group, we do not remove it.
		if (phtable->extension_size == 0  && phtable->size_exponent > 0)
		{
			// The initial group has just been completely emptied, so we set
			// the previous group as the new initial group.  Update all
			// housekeeping information accordingly.
			phtable->size_exponent--;
			phtable->extension_size = group_size >> 1;
			phtable->initial_group = phtable->initial_group->previous;
			// We now determine whether we should deallocate a group.  Note
			// that the allocation histeresis is factored into the calculation.
			if (phtable->size_exponent + phtable->allocation_histeresis <
				phtable->allocation_exponent)
			{
				// We should deallocate a group, so we deallocate the top group.
				phtable->allocation_exponent--;
				group = phtable->top_group->previous;
				GpcFreeMem(phtable->top_group, PatHashTag);
				phtable->top_group = group;
			}
		}
	}
	// Now, the hash table removal operation is complete, including the memory
	// management functions.  Here we begin the removal of the entry from the
	// Patricia tree.  First, we scan through the tree according to the bits of
	// the pattern being removed, until we reach a leaf.  We keep track of the
	// branch that immediately precedes the leaf, and we also note the parent
	// of the pattern, in the latter's capacity as a branch node.
	value = sphandle->value;
	entry = &phtable->root;
	branch = entry;
	parent = 0;
	index = -1;
	while ((*entry)->pivot_bit > index)
	{
		if ((*entry) == sphandle)
		{
			parent = entry;
		}
		branch = entry;
		index = (*entry)->pivot_bit;
		entry = &(*entry)->children[BIT_OF(value, index)];
	}
	// We set the branch that points to the leaf to instead point to the child
	// of the leaf that is not selected by the bit of the removed pattern, thus
	// removing the branch from the tree.
	epoint = *entry;
	bpoint = *branch;
	*branch = bpoint->children[1 - BIT_OF(value, index)];
	// If the branch that was removed is also the leaf that contains the
	// pattern, then the removal from the Patricia tree is complete.  Otherwise,
	// we replace the leaf that is being removed with the branch that is not
	// being removed.
	if (epoint != bpoint)
	{
		bpoint->pivot_bit = epoint->pivot_bit;
		bpoint->children[0] = epoint->children[0];
		bpoint->children[1] = epoint->children[1];
		// In the case of the special node that is not a branch node, we do
		// not update its parent to point to the replacing branch, since this
		// node has no parent.
		if (parent != 0)
		{
			*parent = bpoint;
		}
	}
	// The removal from the Patricia tree is now complete.  If appropriate, we
	// place the removed entry onto the free list.  If not, we simply free it.
	if (phtable->free_list_size < phtable->max_free_list_size)
	{
		sphandle->next = phtable->free_list;
		phtable->free_list = sphandle;
		phtable->free_list_size++;
	}
	else
	{
		GpcFreeMem(sphandle, PatHashTag);
	}
}

// This function searches the database for the specific pattern that matches
// the given key, which is passed as an array of bytes.  The client supplies
// a digested form of the pattern as the chyme argument.  If a match is found,
// the SpecificPatternHandle of that matching specific pattern is returned.
// If no match is found, then a value of 0 is returned.
//
// This search uses only the hash table; the Patricia tree is not used at all.
//
SpecificPatternHandle
searchPatHashTable(
	PatHashTable *phtable,
	char *key,
	unsigned int chyme)
{
	unsigned int hash, address, small_address;
	PHTableGroup *group;
	PHTableEntry *entry;
	char *value;
	int index;
	// First, we find the address by hashing the chyme value.
	group = phtable->initial_group;
	hash = MAGIC_NUMBER * chyme;
	address = hash >> (31 - phtable->size_exponent);
	// There are two possible values for the address depending upon whether
	// the hash chain pointer is below the extension size.  If it is, then the
	// larger (by one bit) address is used; otherwise, the smaller address is
	// used.
	small_address = address >> 1;
	if ((int)small_address >= phtable->extension_size)
	{
		address = small_address;
		group = group->previous;
	}
	// Next we find the group that contains this address.
	while ((address & 0x1) == 0 && group->previous != 0)
	{
		address >>= 1;
		group = group->previous;
	}
	// Then, we scan through the entry list at the given address for the first
	// entry whose hash value is equal to or greater than the hash of the search
	// key.  The entries are stored in sorted order to improve the search speed.
	address >>= 1;
	entry = group->entry_list[address];
	while (entry != 0 && entry->hash < hash)
	{
		entry = entry->next;
	}
	// Now, we check all entries whose hash value matches that of the search
	// key.
	while (entry != 0 && entry->hash == hash)
	{
		// For each value whose hash matches, check the actual value to see
		// if it matches the search key.
		value = entry->value;
		for (index = phtable->keybytes-1; index >= 0; index--)
		{
			if (value[index] != key[index])
			{
				break;
			}
		}
		if (index < 0)
		{
			// A match is found, so we return the SpecificPatternHandle of the
			// matching entry to the client.
			return entry;
		}
		entry = entry->next;
	}
	// A match was not found, so we return a null pointer to the client.
	return 0;
}

// This function searches the database for all specific patterns that match a
// given general pattern.  The general pattern is specified by a value and a
// mask.  For each specific pattern in the database that matches the supplied
// general pattern, a client-supplied callback function is called with the
// SpecificPatternHandle of the matching specific pattern.  This callback
// function is also passed a context (as a void pointer) that is supplied by
// the client in the call to the scan routine.
//
// This scan uses only the Patricia tree; the hash table is not used at all.
//
void
scanPatHashTable(
	PatHashTable *phtable,
	char *value,
	char *mask,
	void *context,
	ScanCallback func)
{
	// Call the recursive node_scan routine, starting at the root of the
	// Patricia tree.
	if (phtable->root != 0)
	{
		node_scan(phtable, phtable->root, -1, value, mask, context, func);
	}
}

// This function recursively scans the Patricia tree for all specific patterns
// that match a given general pattern.
void
node_scan(
	PatHashTable *phtable,
	PHTableEntry *node,
	int prev_bit,
	char *value,
	char *mask,
	void *context,
	ScanCallback func)
{
	int mask_bit, index;
	// Partial recursion removal.  The while loop takes the place of one of the
	// recursive calls to node_scan().  We remain in the while loop while we
	// are still examining branch nodes.
	while (node->pivot_bit > prev_bit)
	{
		// For each branch node, determine which way(s) to branch based upon
		// the bit of the general pattern.  If the mask bit is a zero, then
		// branch both ways, requiring a recursive call.  If the mask bit is
		// a one, then branch in the direction indicated by the value bit.
		mask_bit = BIT_OF(mask, node->pivot_bit);
		if (mask_bit == 0)
		{
			// The general pattern has a wildcard for this node's pivot bit,
			// so we must branch both ways.  We branch on child one through
			// an actual recursive call.
			node_scan(phtable, node->children[1], node->pivot_bit,
				value, mask, context, func);
		}
		// We then branch either to the child selected by the value bit (if
		// the mask bit is one) or to child zero (if the mask bit is zero).
		prev_bit = node->pivot_bit;
		node = node->children[BIT_OF(value, node->pivot_bit) & mask_bit];
	}
	// We have reached a leaf node.  Examine its specific pattern to see if
	// it matches the given general pattern.  If it doesn't match, then just
	// return; otherwise, call the client's callback function.
	for (index = phtable->keybytes-1; index >= 0; index--)
	{
		if ((mask[index] & value[index]) !=
			(mask[index] & node->value[index]))
		{
			return;
		}
	}
	func(context, node);
}

// This function forces the pat-hash table to release all of the memory that
// it currently can, by deallocating all unneeded groups and entries.
//
void
flushPatHashTable(
	PatHashTable *phtable)
{
	PHTableGroup *group, *previous;
	PHTableEntry *entry, *next;
	// First, free all groups that are allocated but not currently used.
	group = phtable->top_group;
	while (group != phtable->initial_group)
	{
		previous = group->previous;
		GpcFreeMem(group, PatHashTag);
		group = previous;
	}
	phtable->top_group = phtable->initial_group;
	phtable->allocation_exponent = phtable->size_exponent;
	// Then, free all of the entries in the free list.
	entry = phtable->free_list;
	while (entry != 0)
	{
		next = entry->next;
		GpcFreeMem(entry, PatHashTag);
		entry = next;
	}
	phtable->free_list = 0;
	phtable->free_list_size = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\pathash.h ===
/*
 *  pathash.h
 *
 *  author:	John R. Douceur
 *  date:	5 May 1997
 *
 *  This header file defines structures, function prototypes, and macros for
 *  the pat-hash table database.  The code is object-oriented C, transliterated
 *  from a C++ implementation.
 *
 *  The pat-hash database is a combination of a dynamically sized, separately
 *  chained hash table and a Patricia tree.  The hash table dynamically grows
 *  and shrinks as needed, and the workload of modifying the table size is
 *  distributed evenly among the insertion or removal operations that cause
 *  the growth or shrinkage.
 *
 *  The insertion and removal operations manage both a hash table and a Patricia
 *  tree, but the search routine uses only the hash table for performing the
 *  search.  The Patrica tree is present to support a scan operation, which
 *  searches the database for all entries that match a given pattern, where the
 *  pattern that is scanned may contain wildcards.
 *
 *  Because this code is C, rather than C++, it is not possible to hide as
 *  much of the implementation from the client code as one might wish.
 *  Nonetheless, there is an attempt to isolate the client from some of the
 *  implementation details through the use of macros.  Below is described each
 *  of the functions and macros necessary to use the pat-hash table.
 *
 */

#ifndef _INC_PATHASH

#define _INC_PATHASH

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  There are three basic structures employed: the PHTableEntry, the
 *  PHTableGroup, and the PatHashTable.  Ideally, these would be completely
 *  hidden from the client, but the macro GetReferenceFromSpecificPatternHandle
 *  requires knowledge of the structure's definition.  It is strongly urged
 *  that the client not directly refer to any of the fields of either of these
 *  structures.  To support the documentation of the accompanying pathash.c
 *  file, these structures are annotated with internal comments, but these can
 *  be ignored by the reader who wishes only to understand how to write client
 *  code for the pat-hash table.
 *
 *  The values stored in the pat-hash table are known as specific patterns,
 *  where the term "specific" implies that the patterns do not contain
 *  wildcards.  The client refers to a pattern by its SpecificPatternHandle.
 *  This is typedefed to a pointer to PHTableEntry, but this fact should be
 *  ignored by the client, since it is an implementation detail.
 *
 */

    //#include <stdlib.h>
    //#include <malloc.h>

struct _PHTableEntry
{
	// This is the element in which a specific pattern is stored.  It is both
	// a component of a hash chain (linked list) that is indexed by a hash
	// table and also a component of a Patricia tree.

	// hash table fields:
	unsigned int hash;                                             // hash value
	struct _PHTableEntry *next;          // pointer to next entry in linked list

	// Patricia tree fields
	int pivot_bit;                              // bit of key on which to branch
	struct _PHTableEntry *children[2];                // pointers to child nodes

	// general:
	void *reference;                       // reference value supplied by client
	char value[1];                            // space for storing pattern value
};

typedef struct _PHTableEntry PHTableEntry;

struct _PHTableGroup
{
	// The hash table that indexes the hash chain of entries is itself a
	// linked list of structures called groups.  Each group is a table of
	// pointers to the hash chains of entries, and the group also contains
	// a pointer to the previous group, meaning that the groups are backwardly
	// linked.  The groups are sized in powers of two, so, in addition to one
	// special group of size one, there is a group of size one, a group of size
	// two, a group of size four, a group of size eight, and so on, up to the
	// number of groups necessary to hold the table.

	struct _PHTableGroup *previous;      // pointer to immediately smaller group
	PHTableEntry *entry_list[1];        // space to hold table of chain pointers
};

typedef struct _PHTableGroup PHTableGroup;

struct _PatHashTable
{
	int keybits;                                        // number of bits in key
	int keybytes;             // number of bytes in key, calculated from keybits
	int usage_ratio;                  // desired ratio of entries to hash chains
	int usage_histeresis;    // histeresis between insertion and removal resizes
	int allocation_histeresis;  // histeresis between insert and removal mallocs
	int max_free_list_size;                   // maximum size of free entry list
	PHTableGroup *initial_group;             // pointer to first group to search
	PHTableGroup *top_group;               // pointer to largest group allocated
	int allocation_exponent;       // binary exponent of current allocation size
	int size_exponent;                  // binary exponent of current group size
	int extension_size;               // number of slots in use in initial group
	int population;                             // number of entries in database
	PHTableEntry *root;                                 // root of Patricia tree
	PHTableEntry *free_list;                    // list of free (unused) entries
	int free_list_size;             // number of elements currently on free list
};

typedef struct _PatHashTable PatHashTable;

// The client uses SpecificPatternHandle to refer to values in the database.
typedef PHTableEntry *SpecificPatternHandle;

/*
 *  The client interface to the pat-hash table is provided by seven functions
 *  and two macros.  It is expected that the client will first instantiate a
 *  database, either on the stack or the heap, and then insert specific patterns
 *  with corresponding reference information into the database.  The client can
 *  then search the database for the specific patterns that were stored, and
 *  it can scan the database for all specific patterns that match a general
 *  pattern containing wildcards.
 *
 */

// A pat-hash table may be allocated on the stack simply by declaring a variable
// of type PatHashTable.  To allocate it on the heap, the following macro
// returns a pointer to a new PatHashTable structure.  If this macro is used, a
// corresponding call to free() must be made to deallocate the structure from
// the heap.
//
//#define NEW_PatHashTable ((PatHashTable *)malloc(sizeof(PatHashTable)))

#define AllocatePatHashTable(_ph)    GpcAllocMem(&_ph, \
                                                 sizeof(PatHashTable), \
                                                 PathHashTag)
#define FreePatHashTable(_ph)        GpcFreeMem(_ph,PathHashTag)

// Since this is not C++, the PatHashTable structure is not self-constructing;
// therefore, the following constructor code must be called on the PatHashTable
// structure after it is allocated.  The argument keybits specifies the size
// (in bits) of each pattern that will be stored in the database.  The remaining
// arguments are parameters to the various control systems that govern the size
// of the database.
//
// The usage ratio is the target ratio of database entries to discrete hash
// chains, which is also the mean length of a hash chain:  The minimum value
// is one; a larger value slightly decreases memory utilization and
// insertion/removal time at the expense of increasing search time.  There is
// benefit to choosing a power of two for this value.  Recommended values are
// 2 and 4.
//
// The usage histeresis is the histeresis between resizing operations due to
// insertions and removals.  The minimum value is zero, providing no histeresis;
// in this case, if an insertion that causes a increase in table size is
// immediately followed by a removal, the table size will be decreased.  Thus,
// a zero histeresis maintains low memory usage, but it engenders resizing
// chatter if insertions and removals are frequent.
//
// Allocation histeresis is the histeresis between allocation and deallocation
// of groups.  A group is allocated immediately when it is required by a size
// increase in the table, but it is not necessarily deallocated immediately
// following a size decrease, if the allocation histeresis is set to a value
// greater than zero.  Because groups are allocated in powers of two, the
// histeresis value is specified as a binary exponent.  A value of 1 causes a
// group to be deallocated when the table is half of the size that will cause
// the group to be re-allocated.  A value of 2 causes the group to be
// deallocated when the table is one quarter of the size that will cause the
// group to be re-allocated, and so forth.
//
// The maximum free list size determines the maximum number of elements that
// will be placed on a free list, rather than deallocated, when they are
// removed.  Setting this value to zero keeps memory utilization low, but it
// can result in more frequent allocations and deallocation operations, which
// are expensive.
//
int
constructPatHashTable(
	PatHashTable *phtable,
	int keybits,
	int usage_ratio,
	int usage_histeresis,
	int allocation_histeresis,
	int max_free_list_size);

// Since this is not C++, the PatHashTable structure is not self-destructing;
// therefore, the following destructor code must be called on the PatHashTable
// structure before it is deallocated.
//
void
destructPatHashTable(
	PatHashTable *phtable);

// Once the PatHashTable structure has been allocated and constructed, patterns
// can be inserted into the database.  Each pattern is passed as an array of
// bytes.
//
// Since the PatHashTable structure specifies the size of each pattern, it is
// theoretically possible for the insert routine to digest the submitted
// pattern and produce a hash value therefrom; however, general mechanisms for
// accomplishing this digestion are not very efficient.  Therefore, the client
// is responsible for providing a digested form of its input as the chyme
// parameter.  If the pattern is no bigger than an unsigned int, then the chyme
// can simply be equal to the pattern.  If it is larger, then it should be set
// to something like the exclusive-or of the pattern's fields; however, care
// should be taken to ensure that two patterns are not likely to digest to the
// same chyme value, since this will substantially decrease the efficiency of
// the hash table.  One common way of accomplishing this is by rotating the
// fields by varying amounts prior to the exclusive-or.
//
// The client also specifies a reference value, as a void pointer, that it
// wishes to associate with this pattern.  When the pattern is installed, the
// insert routine returns a pointer to a SpecificPatternHandle.  From the
// SpecificPatternHandle can be gotten the reference value via the macro
// GetReferenceFromSpecificPatternHandle.
//
// If the submitted pattern has already been installed in the database, then
// the insertion does not occur, and the SpecificPatternHandle of the
// previously installed pattern is returned.
//
SpecificPatternHandle
insertPatHashTable(
	PatHashTable *phtable,
	char *pattern,
	unsigned int chyme,
	void *reference);

// This function removes a pattern from the pat-hash table.  The pattern is
// specified by the SpecificPatternHandle that was returned by the insert
// routine.  No checks are performed to insure that this is a valid handle.
//
void
removePatHashTable(
	PatHashTable *phtable,
	SpecificPatternHandle sphandle);

// This function searches the database for the specific pattern that matches
// the given key, which is passed as an array of bytes.  If a match is found,
// the SpecificPatternHandle of that matching specific pattern is returned.
// From the SpecificPatternHandle can be gotten the reference value via the
// macro GetReferenceFromSpecificPatternHandle.  If no match is found, then a
// value of 0 is returned as the SpecificPatternHandle.
//
// As with the insert routine, the client is expected to provide a digested
// form of the key as the chyme argument to the routine.  This chyme value
// must be calculated in the exact same way for the search routine as it is
// for the insert routine; otherwise, the search will not be able to find the
// matching pattern.
//
SpecificPatternHandle
searchPatHashTable(
	PatHashTable *phtable,
	char *key,
	unsigned int chyme);

// The scan routine (described below) requires the client to supply a callback
// function to be called for each specific pattern that matches the supplied
// general pattern.  The following typedef defines the ScanCallback function
// pointer, which specifies the prototype of the callback function that the
// client must provide.  The client's callback function must accept a void
// pointer (which is a client-supplied context) and a SpecificPatternHandle.
// The return type of the client's callback function is void.
//
typedef void (*ScanCallback)(void *, SpecificPatternHandle);

// This function searches the database for all specific patterns that match a
// given general pattern.  The general pattern is specified by a value and a
// mask.  Each bit of the mask determines whether the bit position is specified
// or is a wildcard:  A 1 in a mask bit indicates that the value of that bit is
// specified by the general pattern; a 0 indicates that the value of that bit
// is a wildcard.  If a mask bit is 1, then the corresponding bit in the value
// field indicates the specified value of that bit.  Value and mask fields are
// passed as arrays of bytes.
//
// For each specific pattern in the database that matches the supplied general
// pattern, a client-supplied callback function is called with the
// SpecificPatternHandle of the matching specific pattern.  This callback
// function is also passed a context (as a void pointer) that is supplied by
// the client in the call to the scan routine.
//
void
scanPatHashTable(
	PatHashTable *phtable,
	char *value,
	char *mask,
	void *context,
	ScanCallback func);

// To get the client-supplied reference value from a SpecificPatternHandle, the
// following macro should be used.  The client should not make assumptions
// about the details of the PHTableEntry structure, nor should it even assume
// that the SpecificPatternHandle is a pointer to a PHTableEntry.
// Also, get the key pointer (value)
//
#define GetReferenceFromSpecificPatternHandle(sphandle) (sphandle)->reference
#define GetKeyPtrFromSpecificPatternHandle(sphandle) (sphandle)->value

// As described above in the comments on the constructor, if the allocation
// histeresis is non-zero, then the groups will not be deallocated as soon as
// they can be.  Similarly, if max free list size is non-zero, then entries
// will not be deallocated as soon as they can be.  Thus, unused pieces of
// memory may accumulate, up to a limit.  If the client wishes to force the
// pat-hash table to release all of the memory that it currently can, then it
// should call the flush routine, which will deallocate all unneeded groups
// and entries.
//
void
flushPatHashTable(
	PatHashTable *phtable);

#ifdef __cplusplus
}
#endif

#endif	/* _INC_PATHASH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\ioctl.c ===
#include "gpcpre.h"

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Creates symbolic link to receive ioctls from user mode and contains the
    ioctl case statement.

Author:

    Yoram Bernet (yoramb) May, 7th. 1997

Environment:

    Kernel Mode

Revision History:

	Ofer Bar (oferbar) 	Oct 1, 1997		- revision II

--*/

#pragma hdrstop

VOID
IoctlCleanup(
    ULONG ShutdownMask
    );

NTSTATUS
GPCIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
CancelPendingIrpCfInfo(
    IN PDEVICE_OBJECT  Device,
    IN PIRP            Irp
    );

VOID
CancelPendingIrpNotify(
    IN PDEVICE_OBJECT  Device,
    IN PIRP            Irp
    );

NTSTATUS
ProxyGpcRegisterClient(
    PVOID 			ioBuffer,
    ULONG 			inputBufferLength,
    ULONG 			*outputBufferLength,
    PFILE_OBJECT	FileObject
    );

NTSTATUS
ProxyGpcDeregisterClient(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength
    );

NTSTATUS
ProxyGpcAddCfInfo(
    PVOID 		ioBuffer,
    ULONG 		inputBufferLength,
    ULONG 		*outputBufferLength,
    PIRP		Irp
    );

NTSTATUS
ProxyGpcModifyCfInfo(
    PVOID 		ioBuffer,
    ULONG 		inputBufferLength,
    ULONG 		*outputBufferLength,
    PIRP		Irp
    );

NTSTATUS
ProxyGpcRemoveCfInfo(
    PVOID 		ioBuffer,
    ULONG 		inputBufferLength,
    ULONG 		*outputBufferLength,
    PIRP		Irp
    );

NTSTATUS
ProxyGpcAddPattern(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength
    );

NTSTATUS
ProxyGpcRemovePattern(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength
    );

NTSTATUS
ProxyGpcEnumCfInfo(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength
    );



GPC_CLIENT_FUNC_LIST 	CallBackProxyList;
PDEVICE_OBJECT 			GPCDeviceObject;
LIST_ENTRY 				PendingIrpCfInfoList;
LIST_ENTRY 				PendingIrpNotifyList;
LIST_ENTRY 				QueuedNotificationList;
LIST_ENTRY 				QueuedCompletionList;

/* End Forward */

#pragma NDIS_PAGEABLE_FUNCTION(GPCIoctl)

UNICODE_STRING GpcDriverName = {sizeof(DD_GPC_DEVICE_NAME)-2,
                                sizeof(DD_GPC_DEVICE_NAME),
                                DD_GPC_DEVICE_NAME};
NTSTATUS
IoctlInitialize(
    PDRIVER_OBJECT 	DriverObject,
    PULONG 			InitShutdownMask
    )

/*++

Routine Description:

    Perform initialization 

Arguments:

    DriverObject - pointer to DriverObject from DriverEntry
    InitShutdownMask - pointer to mask used to indicate which events have been
        successfully init'ed

Return Value:

    STATUS_SUCCESS if everything worked ok

--*/

{
    NTSTATUS Status;
    UINT FuncIndex;

    InitializeListHead(&PendingIrpCfInfoList);
    InitializeListHead(&PendingIrpNotifyList);
    InitializeListHead(&QueuedNotificationList);
    InitializeListHead(&QueuedCompletionList);

    //
    // Initialize the driver object's entry points
    //

    DriverObject->FastIoDispatch = NULL;

    for (FuncIndex = 0; FuncIndex <= IRP_MJ_MAXIMUM_FUNCTION; FuncIndex++) {
        DriverObject->MajorFunction[FuncIndex] = GPCIoctl;
    }

    Status = IoCreateDevice(DriverObject,
                            0,
                            &GpcDriverName,
                            FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &GPCDeviceObject);

    if ( NT_SUCCESS( Status )) {

        *InitShutdownMask |= SHUTDOWN_DELETE_DEVICE;

        GPCDeviceObject->Flags |= DO_BUFFERED_IO;

/*      yoramb - don't need a symbolic link for now...

        Status = IoCreateSymbolicLink( &GPCSymbolicName, &GPCDriverName );

        if ( NT_SUCCESS( Status )) {

            *InitShutdownMask |= SHUTDOWN_DELETE_SYMLINK;
        } else {
            DBGPRINT(IOCTL, ("IoCreateSymbolicLink Failed (%08X): %ls -> %ls\n",
            Status, GPCSymbolicName.Buffer, PSDriverName.Buffer));
        }
*/
    } else {
        DbgPrint("IoCreateDevice failed. Status = %x\n", Status);
        GPCDeviceObject = NULL;
    }

    //
    // Initialize the callback functions. These are called by the
    // kernel Gpc and turned into async notifications to the user. 
    // For now, the user does not get callbacks, so they are NULL. 
    //

    CallBackProxyList.GpcVersion = GpcMajorVersion;
    CallBackProxyList.ClAddCfInfoCompleteHandler = NULL;
    CallBackProxyList.ClAddCfInfoNotifyHandler = NULL;
    CallBackProxyList.ClModifyCfInfoCompleteHandler = NULL;
    CallBackProxyList.ClModifyCfInfoNotifyHandler = NULL;
    CallBackProxyList.ClRemoveCfInfoCompleteHandler = NULL;
    CallBackProxyList.ClRemoveCfInfoNotifyHandler = NULL;

    return Status;
}


NTSTATUS
GPCIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object
    Irp      - pointer to an I/O Request Packet

Return Value:

    None

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PVOID               ioBuffer;
    ULONG               inputBufferLength;
    ULONG               outputBufferLength;
    ULONG               ioControlCode;
    UCHAR				saveControlFlags;
    NTSTATUS            Status = STATUS_SUCCESS;
#if DBG
    KIRQL				irql = KeGetCurrentIrql();
    KIRQL				irql2;
    HANDLE				thrd = PsGetCurrentThreadId();
#endif

    PAGED_CODE();

    //
    // Init to default settings- we only expect 1 type of
    //     IOCTL to roll through here, all others an error.
    //

    Irp->IoStatus.Status      = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
    saveControlFlags = irpStack->Control;

    TRACE(LOCKS, thrd, irql, "GPCIoctl");

    switch (irpStack->MajorFunction) {

    case IRP_MJ_CREATE:
        DBGPRINT(IOCTL, ("IRP Create\n"));
        break;

    case IRP_MJ_READ:
        DBGPRINT(IOCTL, ("IRP Read\n"));
        break;

    case IRP_MJ_CLOSE:
        DBGPRINT(IOCTL, ("IRP Close\n"));
        TRACE(IOCTL, irpStack->FileObject, 0, "IRP Close");

        //
        // make sure we clean all the objects for this particular
        // file object, since it's closing right now.
        //

        CloseAllObjects(irpStack->FileObject, Irp);

        break;

    case IRP_MJ_CLEANUP:
        DBGPRINT(IOCTL, ("IRP Cleanup\n"));
        break;

    case IRP_MJ_SHUTDOWN:
        DBGPRINT(IOCTL, ("IRP Shutdown\n"));
        break;

    case IRP_MJ_DEVICE_CONTROL:

        DBGPRINT(IOCTL, ("GPCIoctl: ioctl=0x%X, IRP=0x%X\n", 
                         ioControlCode, (ULONG_PTR)Irp));

        TRACE(IOCTL, ioControlCode, Irp, "GPCIoctl.irp:");

        //
        // Mark the IRP as Pending BEFORE calling any dispatch routine.
        // If Status is actually set to STATUS_PENDING, we assume the IRP
        // is ready to be returned. 
        // It is possible the IoCompleteRequest has been called async for the
        // IRP, but this should be taken care of by the IO subsystem.
        //

        IoMarkIrpPending(Irp);

        switch (ioControlCode) {

        case IOCTL_GPC_REGISTER_CLIENT:


            Status = ProxyGpcRegisterClient(ioBuffer,
                                            inputBufferLength,
                                            &outputBufferLength,
                                            irpStack->FileObject);

            
            break;
            
        case IOCTL_GPC_DEREGISTER_CLIENT:

            
            Status = ProxyGpcDeregisterClient(ioBuffer,
                                              inputBufferLength,
                                              &outputBufferLength);

            break;
            
        case IOCTL_GPC_ADD_CF_INFO:
            
            Status = ProxyGpcAddCfInfo(ioBuffer,
                                       inputBufferLength,
                                       &outputBufferLength,
                                       Irp
                                       );

            break;
            
        case IOCTL_GPC_MODIFY_CF_INFO:
            
            Status = ProxyGpcModifyCfInfo(ioBuffer,
                                          inputBufferLength,
                                          &outputBufferLength,
                                          Irp
                                          );
            
            break;
            
        case IOCTL_GPC_REMOVE_CF_INFO:
            
            Status = ProxyGpcRemoveCfInfo(ioBuffer,
                                          inputBufferLength,
                                          &outputBufferLength,
                                          Irp
                                          );
            
            break;
            
        case IOCTL_GPC_ADD_PATTERN:
            
            Status = ProxyGpcAddPattern(ioBuffer,
                                        inputBufferLength,
                                        &outputBufferLength);
            
            break;
            
        case IOCTL_GPC_REMOVE_PATTERN:
            
            Status = ProxyGpcRemovePattern(ioBuffer,
                                           inputBufferLength,
                                           &outputBufferLength);
            
            break;
            
        case IOCTL_GPC_ENUM_CFINFO:
            
            Status = ProxyGpcEnumCfInfo(ioBuffer,
                                        inputBufferLength,
                                        &outputBufferLength);
            
            break;
            
        case IOCTL_GPC_NOTIFY_REQUEST:
            
            //
            // request to pend an IRP
            //

            Status = CheckQueuedNotification(Irp, &outputBufferLength);

            break;

            
        case IOCTL_GPC_GET_ENTRIES:

#ifdef STANDALONE_DRIVER

            //
            // Return the exported calls in the buffer
            //
            
            if (outputBufferLength >= sizeof(glGpcExportedCalls)) {
                
                NdisMoveMemory(ioBuffer, 
                               &glGpcExportedCalls, 
                               sizeof(glGpcExportedCalls));
                

                outputBufferLength = sizeof(glGpcExportedCalls);

            } else {
                
                outputBufferLength = sizeof(glGpcExportedCalls);
                Status = GPC_STATUS_INSUFFICIENT_BUFFER;
            }
#else
            Status = STATUS_INVALID_PARAMETER;
#endif
            break;

        default:
            DBGPRINT(IOCTL, ("GPCIoctl: Unknown IRP_MJ_DEVICE_CONTROL\n = %X\n",
                             ioControlCode));

            Status = STATUS_INVALID_PARAMETER;
            break;
            
        }	// switch (ioControlCode)
        
        break;


    default:
        DBGPRINT(IOCTL, ("GPCIoctl: Unknown IRP major function = %08X\n", 
                         irpStack->MajorFunction));

        Status = STATUS_UNSUCCESSFUL;
        break;
    }

    DBGPRINT(IOCTL, ("GPCIoctl: Status=0x%X, IRP=0x%X, outSize=%d\n",
                     Status, (ULONG_PTR)Irp,  outputBufferLength));
    
    TRACE(IOCTL, Irp, Status, "GPCIoctl.Complete:");

    if (Status != STATUS_PENDING) {

        //
        // IRP completed and it's not Pending, we need to restore the Control flags,
        // since it might have been marked as Pending before...
        //

        irpStack->Control = saveControlFlags;
        
        Irp->IoStatus.Status = Status;
        Irp->IoStatus.Information = outputBufferLength;
        
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    }

#if DBG
    irql2 = KeGetCurrentIrql();
    ASSERT(irql == irql2);
#endif

    TRACE(LOCKS, thrd, irql2, "GPCIoctl (end)");

    return Status;

} // GPCIoctl




VOID
IoctlCleanup(
    ULONG ShutdownMask
    )

/*++

Routine Description:

    Cleanup code for Initialize

Arguments:

    ShutdownMask - mask indicating which functions need to be cleaned up

Return Value:

    None

--*/

{
/*
    if ( ShutdownMask & SHUTDOWN_DELETE_SYMLINK ) {

        IoDeleteSymbolicLink( &PSSymbolicName );
    }
*/

    if ( ShutdownMask & SHUTDOWN_DELETE_DEVICE ) {

        IoDeleteDevice( GPCDeviceObject );
    }
}

NTSTATUS
ProxyGpcRegisterClient(
    PVOID 			ioBuffer,
    ULONG 			inputBufferLength,
    ULONG 			*outputBufferLength,
    PFILE_OBJECT	FileObject
    )
{
    NTSTATUS 					Status;
    PCLIENT_BLOCK				pClient;
    PGPC_REGISTER_CLIENT_REQ 	GpcReq; 
    PGPC_REGISTER_CLIENT_RES 	GpcRes; 

    if (inputBufferLength < sizeof(GPC_REGISTER_CLIENT_REQ) 
        ||
        *outputBufferLength < sizeof(GPC_REGISTER_CLIENT_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    GpcReq = (PGPC_REGISTER_CLIENT_REQ)ioBuffer;
    GpcRes = (PGPC_REGISTER_CLIENT_RES)ioBuffer;

    Status = GpcRegisterClient(GpcReq->CfId,
                               GpcReq->Flags | GPC_FLAGS_USERMODE_CLIENT,
                               GpcReq->MaxPriorities,
                               &CallBackProxyList,
                               GpcReq->ClientContext,
                               (PGPC_HANDLE)&pClient);

    ASSERT(Status != GPC_STATUS_PENDING);

    if (Status == STATUS_SUCCESS) {

        ASSERT(pClient);

        pClient->pFileObject = FileObject;

        GpcRes->ClientHandle = AllocateHandle(&pClient->ClHandle, (PVOID)pClient);
    }

    GpcRes->Status = Status;

    *outputBufferLength = sizeof(GPC_REGISTER_CLIENT_RES);

    return STATUS_SUCCESS;
}
                                   
NTSTATUS
ProxyGpcDeregisterClient(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength
    )
{
    NTSTATUS 					Status;
    PGPC_DEREGISTER_CLIENT_REQ 	GpcReq;
    PGPC_DEREGISTER_CLIENT_RES 	GpcRes;
    GPC_HANDLE					GpcClientHandle;

    if (inputBufferLength < sizeof(GPC_DEREGISTER_CLIENT_REQ) 
        ||
        *outputBufferLength < sizeof(GPC_DEREGISTER_CLIENT_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    GpcReq = (PGPC_DEREGISTER_CLIENT_REQ)ioBuffer;
    GpcRes = (PGPC_DEREGISTER_CLIENT_RES)ioBuffer;

    GpcClientHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->ClientHandle,
                                                         GPC_ENUM_CLIENT_TYPE,
                                                         'PGDC');

    if (GpcClientHandle) {

        Status = GpcDeregisterClient(GpcClientHandle);

    } else {

        Status = STATUS_INVALID_HANDLE;
    }
        
    if (GpcClientHandle) {

        REFDEL(&((PCLIENT_BLOCK)GpcClientHandle)->RefCount, 'PGDC');
    }

    ASSERT(Status != GPC_STATUS_PENDING);

    GpcRes->Status = Status;
        
    *outputBufferLength = sizeof(GPC_DEREGISTER_CLIENT_RES);
                                   
    return STATUS_SUCCESS;
}

NTSTATUS
ProxyGpcAddCfInfo(
    PVOID 		ioBuffer,
    ULONG 		inputBufferLength,
    ULONG 		*outputBufferLength,
    PIRP		Irp
    )
{        
    NTSTATUS 				Status;
    GPC_HANDLE 				GpcClientHandle;
    PGPC_ADD_CF_INFO_REQ 	GpcReq; 
    PGPC_ADD_CF_INFO_RES 	GpcRes; 
    PBLOB_BLOCK				pBlob = NULL;
    QUEUED_COMPLETION		QItem;
    UNICODE_STRING 			CfInfoName;
    USHORT					NameLen = 0;

    if (inputBufferLength < sizeof(GPC_ADD_CF_INFO_REQ)
        ||
        *outputBufferLength < sizeof(GPC_ADD_CF_INFO_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    GpcReq = (PGPC_ADD_CF_INFO_REQ)ioBuffer;
    GpcRes = (PGPC_ADD_CF_INFO_RES)ioBuffer;

    if (GpcReq->CfInfoSize > 
        inputBufferLength - FIELD_OFFSET(GPC_ADD_CF_INFO_REQ, CfInfo)) {

        return STATUS_INVALID_BUFFER_SIZE;
    }

    GpcClientHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->ClientHandle,
                                                         GPC_ENUM_CLIENT_TYPE,
                                                         'PGAC');
    if (GpcClientHandle) {

        Status = GpcAddCfInfo(GpcClientHandle,
                              GpcReq->CfInfoSize,
                              &GpcReq->CfInfo,
                              GpcReq->ClientCfInfoContext,
                              (PGPC_HANDLE)&pBlob);

        if (NT_SUCCESS(Status)) {

            //
            // including PENDING
            //

            if (Status == GPC_STATUS_PENDING) {

                QItem.OpCode = OP_ADD_CFINFO;
                QItem.ClientHandle = GpcClientHandle;
                QItem.CfInfoHandle = (GPC_HANDLE)pBlob;

                Status = CheckQueuedCompletion(&QItem, Irp);

            }

            if (Status == GPC_STATUS_SUCCESS) {
                
                GPC_STATUS			st = GPC_STATUS_FAILURE;
                GPC_CLIENT_HANDLE	NotifiedClientCtx = pBlob->NotifiedClientCtx;
                PCLIENT_BLOCK		pNotifiedClient = pBlob->pNotifiedClient;

                GpcRes->GpcCfInfoHandle = (GPC_HANDLE)AllocateHandle(&pBlob->ClHandle, (PVOID)pBlob);

                // what if we cant allocate a handle? fail the add!
                if (!GpcRes->GpcCfInfoHandle) {
                    
                    GpcRemoveCfInfo(GpcClientHandle,
                                    pBlob);

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    
                    goto exit;
        
                }
                     

                if (pNotifiedClient) {

                    if (pNotifiedClient->FuncList.ClGetCfInfoName &&
                        NotifiedClientCtx) {
                    
                        st = pNotifiedClient->FuncList.ClGetCfInfoName(
                                       pNotifiedClient->ClientCtx,
                                       NotifiedClientCtx,
                                       &CfInfoName
                                       );
                        if (CfInfoName.Length >= MAX_STRING_LENGTH * sizeof(WCHAR))
                            CfInfoName.Length = (MAX_STRING_LENGTH-1) * sizeof(WCHAR);
                        //
                        // RajeshSu claims this can never happen.
                        //
                        ASSERT(NT_SUCCESS(st));

                    }
                }
                
                if (NT_SUCCESS(st)) {
                    
                    //
                    // copy the instance name
                    //
                    
                    GpcRes->InstanceNameLength = NameLen = CfInfoName.Length;
                    RtlMoveMemory(GpcRes->InstanceName, 
                                  CfInfoName.Buffer,
                                  CfInfoName.Length
                                  );
                } else {
                    
                    //
                    // generate a default name
                    //
                    
                    if (NotifiedClientCtx)
                        swprintf(GpcRes->InstanceName, L"Flow %08X", NotifiedClientCtx);
                    else
                        swprintf(GpcRes->InstanceName, L"Flow <unkonwn name>");
                    GpcRes->InstanceNameLength = NameLen = wcslen(GpcRes->InstanceName)*sizeof(WCHAR);
                
                }
                
                GpcRes->InstanceName[GpcRes->InstanceNameLength/sizeof(WCHAR)] = L'\0';
                
            } else {

                pBlob = NULL;
            }

        }

        //
        // release the ref count we got earlier
        //
exit:

        REFDEL(&((PCLIENT_BLOCK)GpcClientHandle)->RefCount, 'PGAC');

    } else {

      ASSERT(pBlob == NULL);
      Status = GPC_STATUS_INVALID_HANDLE;
    }

    GpcRes->InstanceNameLength = NameLen;
    GpcRes->Status = Status;
    *outputBufferLength = sizeof(GPC_ADD_CF_INFO_RES);

    return (Status == GPC_STATUS_PENDING) ? STATUS_PENDING : STATUS_SUCCESS;
}



NTSTATUS
ProxyGpcAddPattern(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength
    )
{
    NTSTATUS 				Status;
    GPC_HANDLE 				GpcClientHandle;
    GPC_HANDLE 				GpcCfInfoHandle;
    CLASSIFICATION_HANDLE 	ClassificationHandle;
    PGPC_ADD_PATTERN_REQ 	GpcReq;
    PGPC_ADD_PATTERN_RES 	GpcRes;
    PVOID 					Pattern;
    PVOID 					Mask;
    PPATTERN_BLOCK			pPattern;

    if (inputBufferLength < sizeof(GPC_ADD_PATTERN_REQ)
        ||
        *outputBufferLength < sizeof(GPC_ADD_PATTERN_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    GpcReq = (PGPC_ADD_PATTERN_REQ)ioBuffer;
    GpcRes = (PGPC_ADD_PATTERN_RES)ioBuffer;

    if (GpcReq->PatternSize > MAX_PATTERN_SIZE) {
        
        return STATUS_INVALID_PARAMETER;
    }

    if (inputBufferLength - FIELD_OFFSET(GPC_ADD_PATTERN_REQ, PatternAndMask)
        < 2 * GpcReq->PatternSize) {
        
        return STATUS_BUFFER_TOO_SMALL;
    }

    GpcClientHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->ClientHandle,
                                                         GPC_ENUM_CLIENT_TYPE,
                                                         'PGAP');
    
    GpcCfInfoHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->GpcCfInfoHandle,
                                                         GPC_ENUM_CFINFO_TYPE,
                                                         'PGAP');
    
    if (GpcClientHandle && GpcCfInfoHandle) {
        
        Pattern = (PVOID)&GpcReq->PatternAndMask;
        Mask = (PVOID)((PCHAR)(&GpcReq->PatternAndMask) + GpcReq->PatternSize);

        Status = GpcAddPattern(GpcClientHandle,
                               GpcReq->ProtocolTemplate,
                               Pattern,
                               Mask,
                               GpcReq->Priority,
                               GpcCfInfoHandle,
                               (PGPC_HANDLE)&pPattern,
                               &ClassificationHandle);

        if (Status == GPC_STATUS_SUCCESS) {
            
            ASSERT(Pattern);

            GpcRes->GpcPatternHandle = AllocateHandle(&pPattern->ClHandle, (PVOID)pPattern);

            //
            // In certain circs, alloc_HF_handle could return 0. 
            // check for that and clean up the mess.
            //
            if (!GpcRes->GpcPatternHandle) {

                //
                // remove the pattern that was just added.
                //
                Status = GpcRemovePattern(GpcClientHandle,
                                          pPattern);

                //
                // This was really the problem why we got a NULL handle
                //
                Status = STATUS_INSUFFICIENT_RESOURCES;

            }
        }

    } else {

        //
        // Something went wrong and we dont know WHAT!!
        //
        Status = STATUS_INVALID_HANDLE;
    }

    if (GpcCfInfoHandle) {

        REFDEL(&((PBLOB_BLOCK)GpcCfInfoHandle)->RefCount, 'PGAP');
    }

    if (GpcClientHandle) {

        //
        // release the ref count we got earlier
        //

        REFDEL(&((PCLIENT_BLOCK)GpcClientHandle)->RefCount, 'PGAP');
    }

    ASSERT(Status != GPC_STATUS_PENDING);

    GpcRes->Status = Status;
    GpcRes->ClassificationHandle = ClassificationHandle;
        
    *outputBufferLength = sizeof(GPC_ADD_PATTERN_RES);

    return STATUS_SUCCESS;
}


                                   
NTSTATUS
ProxyGpcModifyCfInfo(
    PVOID 		ioBuffer,
    ULONG 		inputBufferLength,
    ULONG 		*outputBufferLength,
    PIRP		Irp
    )
{
    NTSTATUS                Status;
    GPC_HANDLE				GpcClientHandle;
    GPC_HANDLE				GpcCfInfoHandle;
    PGPC_MODIFY_CF_INFO_REQ GpcReq;
    PGPC_MODIFY_CF_INFO_RES GpcRes;
    QUEUED_COMPLETION		QItem;

    if (inputBufferLength < sizeof(GPC_MODIFY_CF_INFO_REQ)
        ||
        *outputBufferLength < sizeof(GPC_MODIFY_CF_INFO_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    GpcReq = (PGPC_MODIFY_CF_INFO_REQ)ioBuffer;
    GpcRes = (PGPC_MODIFY_CF_INFO_RES)ioBuffer;

    if (GpcReq->CfInfoSize > 
        inputBufferLength - FIELD_OFFSET(GPC_MODIFY_CF_INFO_REQ, CfInfo)) {

        return STATUS_INVALID_BUFFER_SIZE;
    }

    GpcClientHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->ClientHandle,
                                                         GPC_ENUM_CLIENT_TYPE,
                                                         'PGMP');
    
    GpcCfInfoHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->GpcCfInfoHandle,
                                                         GPC_ENUM_CFINFO_TYPE,
                                                         'PGMP');
    
    if (GpcClientHandle && GpcCfInfoHandle) {

        Status = GpcModifyCfInfo(GpcClientHandle,
                                 GpcCfInfoHandle,
                                 GpcReq->CfInfoSize,
                                 &GpcReq->CfInfo
                             );

        if (Status == GPC_STATUS_PENDING) {
            
            QItem.OpCode = OP_MODIFY_CFINFO;
            QItem.ClientHandle = GpcClientHandle;
            QItem.CfInfoHandle = GpcCfInfoHandle;
            
            Status = CheckQueuedCompletion(&QItem, Irp);
            
        }

    } else { 

        Status = STATUS_INVALID_HANDLE;
    }
                          
    if (GpcCfInfoHandle) {

        REFDEL(&((PBLOB_BLOCK)GpcCfInfoHandle)->RefCount, 'PGMP');
    }

    if (GpcClientHandle) {

        //
        // release the ref count we got earlier
        //

        REFDEL(&((PCLIENT_BLOCK)GpcClientHandle)->RefCount, 'PGMP');
    }

    GpcRes->Status = Status;
        
    *outputBufferLength = sizeof(GPC_MODIFY_CF_INFO_RES);

    return (Status == GPC_STATUS_PENDING) ? STATUS_PENDING : STATUS_SUCCESS;
}


                                   
NTSTATUS
ProxyGpcRemoveCfInfo(
    PVOID 		ioBuffer,
    ULONG 		inputBufferLength,
    ULONG 		*outputBufferLength,
    PIRP		Irp
    )
{
    NTSTATUS 				Status;
    GPC_HANDLE				GpcClientHandle;
    GPC_HANDLE				GpcCfInfoHandle;
    PGPC_REMOVE_CF_INFO_REQ GpcReq;
    PGPC_REMOVE_CF_INFO_RES GpcRes;
    QUEUED_COMPLETION		QItem;

    if (inputBufferLength < sizeof(GPC_REMOVE_CF_INFO_REQ)
        ||
        *outputBufferLength < sizeof(GPC_REMOVE_CF_INFO_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    GpcReq = (PGPC_REMOVE_CF_INFO_REQ)ioBuffer;
    GpcRes = (PGPC_REMOVE_CF_INFO_RES)ioBuffer;

    GpcClientHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->ClientHandle,
                                                         GPC_ENUM_CLIENT_TYPE,
                                                         'PGRC');
    
    GpcCfInfoHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->GpcCfInfoHandle,
                                                         GPC_ENUM_CFINFO_TYPE,
                                                         'PGRC');
    
    if (GpcClientHandle && GpcCfInfoHandle) {
        
        Status = privateGpcRemoveCfInfo(GpcClientHandle, 
                                        GpcCfInfoHandle,
                                        GPC_FLAGS_USERMODE_CLIENT );
        
        if (Status == GPC_STATUS_PENDING) {
            
            QItem.OpCode = OP_REMOVE_CFINFO;
            QItem.ClientHandle = GpcClientHandle;
            QItem.CfInfoHandle = GpcCfInfoHandle;
            
            Status = CheckQueuedCompletion(&QItem, Irp);
            
        }

    } else {

        Status = STATUS_INVALID_HANDLE;
    }
        
    if (GpcCfInfoHandle) {
        
        //
        // release the ref count we got earlier
        //

        REFDEL(&((PBLOB_BLOCK)GpcCfInfoHandle)->RefCount, 'PGRC');
    }

    if (GpcClientHandle) {

        //
        // release the ref count we got earlier
        //

        REFDEL(&((PCLIENT_BLOCK)GpcClientHandle)->RefCount, 'PGRC');
    }

    GpcRes->Status = Status;
        
    *outputBufferLength = sizeof(GPC_REMOVE_CF_INFO_RES);
                                   
    return (Status == GPC_STATUS_PENDING) ? STATUS_PENDING : STATUS_SUCCESS;
}


                                   
NTSTATUS
ProxyGpcRemovePattern(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength
    )
{
    NTSTATUS 				Status;
    GPC_HANDLE				GpcClientHandle;
    GPC_HANDLE				GpcPatternHandle;
    PGPC_REMOVE_PATTERN_REQ GpcReq;
    PGPC_REMOVE_PATTERN_RES GpcRes;

    if (inputBufferLength < sizeof(GPC_REMOVE_PATTERN_REQ)
        ||
        *outputBufferLength < sizeof(GPC_REMOVE_PATTERN_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    GpcReq = (PGPC_REMOVE_PATTERN_REQ)ioBuffer;
    GpcRes = (PGPC_REMOVE_PATTERN_RES)ioBuffer;

    GpcClientHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->ClientHandle,
                                                         GPC_ENUM_CLIENT_TYPE,
                                                         'PGRP');
    
    GpcPatternHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->GpcPatternHandle,
                                                          GPC_ENUM_PATTERN_TYPE,
                                                          'PGRP');
    
    if (GpcClientHandle && GpcPatternHandle) {

        Status = GpcRemovePattern(GpcClientHandle, 
                                  GpcPatternHandle);


    } else {

        //
        // Something is wrong. Set the status to invalid handle!
        //
        Status = STATUS_INVALID_HANDLE;
        
    }

    if (GpcPatternHandle) {
        
        REFDEL(&((PPATTERN_BLOCK)GpcPatternHandle)->RefCount, 'PGRP');
    }

    if (GpcClientHandle) {

        //
        // release the ref count we got earlier
        //

        REFDEL(&((PCLIENT_BLOCK)GpcClientHandle)->RefCount, 'PGRP');
    }

    ASSERT(Status != GPC_STATUS_PENDING);

    GpcRes->Status = Status;
        
    *outputBufferLength = sizeof(GPC_REMOVE_PATTERN_RES);
                                   
    return STATUS_SUCCESS;
}
                                   


NTSTATUS
ProxyGpcEnumCfInfo(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    ULONG *outputBufferLength
    )
{
    NTSTATUS 				Status;
    PGPC_ENUM_CFINFO_REQ 	GpcReq;
    PGPC_ENUM_CFINFO_RES 	GpcRes;
    ULONG					Size;
    ULONG					TotalCount;
    GPC_HANDLE				GpcClientHandle;
    GPC_HANDLE				GpcCfInfoHandle;
    GPC_HANDLE				EnumHandle;
    PBLOB_BLOCK				pBlob;

    if (inputBufferLength < sizeof(GPC_ENUM_CFINFO_REQ)
        ||
        *outputBufferLength < sizeof(GPC_ENUM_CFINFO_RES)
        ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    GpcReq = (PGPC_ENUM_CFINFO_REQ)ioBuffer;
    GpcRes = (PGPC_ENUM_CFINFO_RES)ioBuffer;
    
    GpcClientHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->ClientHandle,
                                                         GPC_ENUM_CLIENT_TYPE,
                                                         'PGEC');

    GpcCfInfoHandle = (GPC_HANDLE)GetHandleObjectWithRef(GpcReq->EnumHandle,
                                                         GPC_ENUM_CFINFO_TYPE,
                                                         'PGEC');
    
    if (GpcReq->EnumHandle != NULL && GpcCfInfoHandle == NULL) {

        //
        // the flow has been deleted during enumeration
        //
        
        Status = STATUS_DATA_ERROR;

    } else if (GpcClientHandle) {

        TotalCount = GpcReq->CfInfoCount;
        EnumHandle = GpcReq->EnumHandle;
        Size = *outputBufferLength - FIELD_OFFSET(GPC_ENUM_CFINFO_RES, 
                                                  EnumBuffer);

        //
        // save the blob pointer with the one extra ref count
        // since we called GetHandleObjectWithRef
        //

        pBlob = (PBLOB_BLOCK)GpcCfInfoHandle;

        Status = GpcEnumCfInfo(GpcClientHandle,
                               &GpcCfInfoHandle,
                               &EnumHandle,
                               &TotalCount,
                               &Size,
                               GpcRes->EnumBuffer
                               );

        if (pBlob) {

            REFDEL(&pBlob->RefCount, 'PGEC');

        }

        if (Status == GPC_STATUS_SUCCESS) {

            //
            // fill in the results
            //

            GpcRes->TotalCfInfo = TotalCount;
            GpcRes->EnumHandle = EnumHandle;
            *outputBufferLength = Size + FIELD_OFFSET(GPC_ENUM_CFINFO_RES, 
                                                      EnumBuffer);
        }

    } else {

        if (GpcCfInfoHandle) {
            
            REFDEL(&((PBLOB_BLOCK)GpcCfInfoHandle)->RefCount, 'PGEC');
        }

        Status = STATUS_INVALID_HANDLE;
    }

    if (GpcClientHandle) {

        //
        // release the ref count we got earlier
        //

        REFDEL(&((PCLIENT_BLOCK)GpcClientHandle)->RefCount, 'PGEC');
    }

    ASSERT(Status != GPC_STATUS_PENDING);

    GpcRes->Status = Status;
    
    return STATUS_SUCCESS;
}
                                   


VOID
CancelPendingIrpCfInfo(
	IN PDEVICE_OBJECT  Device,
    IN PIRP            Irp
    )

/*++

Routine Description:

	Cancels an outstanding IRP request for a CfInfo request.

Arguments:

    Device       - The device on which the request was issued.
    Irp          - Pointer to I/O request packet to cancel.

Return Value:

    None

Notes:

    This function is called with cancel spinlock held. It must be
    released before the function returns.

    The cfinfo block associated with this request cannot be
    freed until the request completes. The completion routine will
    free it.

--*/

{
    PPENDING_IRP        pPendingIrp = NULL;
    PPENDING_IRP        pItem;
    PLIST_ENTRY        	pEntry;
#if DBG
    KIRQL				irql = KeGetCurrentIrql();
    HANDLE				thrd = PsGetCurrentThreadId();
#endif

    DBGPRINT(IOCTL, ("CancelPendingIrpCfInfo: Irp=0x%X\n", 
                     (ULONG_PTR)Irp));

    TRACE(IOCTL, Irp, 0, "CancelPendingIrpCfInfo:");
    TRACE(LOCKS, thrd, irql, "CancelPendingIrpCfInfo:");

    for ( pEntry = PendingIrpCfInfoList.Flink;
          pEntry != &PendingIrpCfInfoList;
          pEntry = pEntry->Flink ) {

        pItem = CONTAINING_RECORD(pEntry, PENDING_IRP, Linkage);

        if (pItem->Irp == Irp) {

            pPendingIrp = pItem;
            GpcRemoveEntryList(pEntry);

            IoSetCancelRoutine(pPendingIrp->Irp, NULL);

            break;
        }
    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    if (pPendingIrp != NULL) {

        DBGPRINT(IOCTL, ("CancelPendingIrpCfInfo: found PendingIrp=0x%X\n", 
                         (ULONG_PTR)pPendingIrp));

        TRACE(IOCTL, Irp, pPendingIrp, "CancelPendingIrpCfInfo.PendingIrp:");

        //
        // Free the PENDING_IRP structure. The control block will be freed
        // when the request completes.
        //

        GpcFreeToLL(pPendingIrp, &PendingIrpLL, PendingIrpTag);

        //
        // Complete the IRP.
        //

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    } else {

        DBGPRINT(IOCTL, ("CancelPendingIrpCfInfo: PendingIrp not found\n"));
        TRACE(IOCTL, Irp, 0, "CancelPendingIrpCfInfo.NoPendingIrp:");

    }

#if DBG
    irql = KeGetCurrentIrql();
#endif

    TRACE(LOCKS, thrd, irql, "CancelPendingIrpCfInfo (end)");

	return;
}




VOID
CancelPendingIrpNotify(
	IN PDEVICE_OBJECT  Device,
    IN PIRP            Irp
    )

/*++

Routine Description:

	Cancels an outstanding IRP request for a notification.

Arguments:

    Device       - The device on which the request was issued.
    Irp          - Pointer to I/O request packet to cancel.

Return Value:

    None

Notes:

    This function is called with cancel spinlock held. It must be
    released before the function returns.

--*/

{
    PPENDING_IRP        pPendingIrp = NULL;
    PPENDING_IRP        pItem;
    PLIST_ENTRY        	pEntry;
#if DBG
    KIRQL				irql = KeGetCurrentIrql();
    HANDLE				thrd = PsGetCurrentThreadId();
#endif

    DBGPRINT(IOCTL, ("CancelPendingIrpNotify: Irp=0x%X\n", 
                     (ULONG_PTR)Irp));
    TRACE(IOCTL, Irp, 0, "CancelPendingIrpNotify:");
    TRACE(LOCKS, thrd, irql, "CancelPendingIrpNotify:");

    for ( pEntry = PendingIrpNotifyList.Flink;
          pEntry != &PendingIrpNotifyList;
          pEntry = pEntry->Flink ) {

        pItem = CONTAINING_RECORD(pEntry, PENDING_IRP, Linkage);

        if (pItem->Irp == Irp) {

            pPendingIrp = pItem;
            GpcRemoveEntryList(pEntry);

            IoSetCancelRoutine(pPendingIrp->Irp, NULL);

            break;
        }
    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    if (pPendingIrp != NULL) {

        DBGPRINT(IOCTL, ("CancelPendingIrpNotify: Found a PendingIrp=0x%X\n", 
                         (ULONG_PTR)pPendingIrp));
        TRACE(IOCTL, Irp, pPendingIrp, "CancelPendingIrpNotify.PendingIrp:");

        //
        // Free the PENDING_IRP structure. 
        //

        GpcFreeToLL(pPendingIrp, &PendingIrpLL, PendingIrpTag);

        //
        // Complete the IRP.
        //

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    } else {

        DBGPRINT(IOCTL, ("CancelPendingIrpNotify: PendingIrp not found\n"));
        TRACE(IOCTL, Irp, 0, "CancelPendingIrpNotify.NoPendingIrp:");
    }

#if DBG
    irql = KeGetCurrentIrql();
#endif

    TRACE(LOCKS, thrd, irql, "CancelPendingIrpNotify (end)");

	return;
}




VOID
UMClientRemoveCfInfoNotify(
	IN	PCLIENT_BLOCK			pClient,
    IN	PBLOB_BLOCK				pBlob
    )

/*++

Routine Description:

	Notify user mode client that the CfInfo is deleted.
    This will dequeue a pending IRP and will complete it.
    If there is no pending IRP, a GPC_NOTIFY_REQUEST_RES buffer
    will be queued until we get an IRP down the stack.

Arguments:

	pClient	- the notified client
	pBlob	- the deleted cfinfo

Return Value:

    None

--*/

{
    KIRQL                 	oldIrql;
    PIRP                  	pIrp;
    PPENDING_IRP          	pPendingIrp = NULL;
    PLIST_ENTRY           	pEntry;
    PQUEUED_NOTIFY			pQItem;
    PGPC_NOTIFY_REQUEST_RES	GpcRes;

    ASSERT(pClient == pBlob->pOwnerClient);

    DBGPRINT(IOCTL, ("UMClientRemoveCfInfoNotify: pClient=0x%X, pBlob=0x%X\n", 
                     (ULONG_PTR)pClient, (ULONG_PTR)pBlob));
    TRACE(IOCTL, pClient, pBlob, "UMClientRemoveCfInfoNotify:");

    //
    // Find the request IRP on the pending list.
    //
    IoAcquireCancelSpinLock(&oldIrql);

    for ( pEntry = PendingIrpNotifyList.Flink;
          pEntry != &PendingIrpNotifyList;
          pEntry = pEntry->Flink ) {

        pPendingIrp = CONTAINING_RECORD( pEntry, PENDING_IRP, Linkage);

        if (pPendingIrp->FileObject == pClient->pFileObject) {

            //
            // that's the pending request
            //

            pIrp = pPendingIrp->Irp;
            IoSetCancelRoutine(pIrp, NULL);
            GpcRemoveEntryList(pEntry);
            break;

        } else {
            
            pPendingIrp = NULL;
        }
    }

    if (pPendingIrp == NULL) {

        //
        // No IRP, we need to queue the notification block
        //

        DBGPRINT(IOCTL, ("UMClientRemoveCfInfoNotify: No pending IRP found\n"
                         ));
        TRACE(IOCTL, 
              pClient->ClientCtx, 
              pBlob->arClientCtx[pClient->AssignedIndex],
              "UMClientRemoveCfInfoNotify.NoPendingIrp:");

        GpcAllocFromLL(&pQItem, &QueuedNotificationLL, QueuedNotificationTag);

        if (pQItem) {

            pQItem->FileObject = pClient->pFileObject;

            //
            // fill the item
            //

            pQItem->NotifyRes.ClientCtx = pClient->ClientCtx;
            pQItem->NotifyRes.NotificationCtx = 
                (ULONG_PTR)pBlob->arClientCtx[pClient->AssignedIndex];
            pQItem->NotifyRes.SubCode = GPC_NOTIFY_CFINFO_CLOSED;
            pQItem->NotifyRes.Reason = 0;	// for now...
            pQItem->NotifyRes.Param1 = 0;	// for now...

            GpcInsertTailList(&QueuedNotificationList, &pQItem->Linkage);

        }

    }

    IoReleaseCancelSpinLock(oldIrql);

    if (pPendingIrp) {

        //
        // found an IRP, fill and complete
        //

        DBGPRINT(IOCTL, ("UMClientRemoveCfInfoNotify: Pending IRP found=0x%X\n",
                         (ULONG_PTR)pIrp));
        TRACE(IOCTL, 
              pClient->ClientCtx, 
              pBlob->arClientCtx[pClient->AssignedIndex],
              "UMClientRemoveCfInfoNotify.PendingIrp:");

        GpcRes = (PGPC_NOTIFY_REQUEST_RES)pIrp->AssociatedIrp.SystemBuffer;

        GpcRes->ClientCtx = pClient->ClientCtx;
        GpcRes->NotificationCtx = 
            (ULONG_PTR)pBlob->arClientCtx[pClient->AssignedIndex];
        GpcRes->SubCode = GPC_NOTIFY_CFINFO_CLOSED;
        GpcRes->Reason = 0;	// for now...
        GpcRes->Param1 = 0;	// for now...
        
        //
        // complete the IRP
        //

        pIrp->IoStatus.Information = sizeof(GPC_NOTIFY_REQUEST_REQ);
        pIrp->IoStatus.Status = STATUS_SUCCESS;

        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

        //
        // We can free the pending irp item
        //

        GpcFreeToLL(pPendingIrp, &PendingIrpLL, PendingIrpTag);

    }

    //
    // for now - complete the operation
    // we should probably let the User Mode client do it,
    // but this complicates things a little...
    //

    GpcRemoveCfInfoNotifyComplete((GPC_HANDLE)pClient,
                                  (GPC_HANDLE)pBlob,
                                  GPC_STATUS_SUCCESS
                                  );
    
    return;
}


VOID
UMCfInfoComplete(
	IN	GPC_COMPLETION_OP		OpCode,
	IN	PCLIENT_BLOCK			pClient,
    IN	PBLOB_BLOCK             pBlob,
    IN	GPC_STATUS				Status
    )

/*++

Routine Description:

	This is the completion routine for any pending CfInfo request.
    It will search the pending IRP CfInfo list for a matching CfInfo
    structure that has been stored while the Add, Modify or Remove
    request returned PENDING. The client must be the CfInfo owner,
    otherwise we would have never got here. 
    If an IRP is not found, it means the operation completed *before*
    we got back the PENDING status, which is perfectly legal.
    In this case, we queue a completion item and return.

Arguments:

	OpCode  - the code of the completion (add, modify or remove)
	pClient	- the notified client
	pBlob	- the deleted cfinfo
	Status  - the reported status

Return Value:

    None

--*/

{
    typedef   union _GPC_CF_INFO_RES {
        GPC_ADD_CF_INFO_RES		AddRes;
        GPC_MODIFY_CF_INFO_RES	ModifyRes;
        GPC_REMOVE_CF_INFO_RES	RemoveRes;
    } GPC_CF_INFO_RES;
        
    KIRQL                 	oldIrql;
    PIRP                  	pIrp;
    PIO_STACK_LOCATION    	pIrpSp;
    PPENDING_IRP          	pPendingIrp = NULL;
    PLIST_ENTRY           	pEntry;
    GPC_CF_INFO_RES			*GpcRes;
    ULONG					outputBuferLength;
    //PQUEUED_COMPLETION		pQItem;

    //ASSERT(pClient == pBlob->pOwnerClient);

    DBGPRINT(IOCTL, ("UMCfInfoComplete: pClient=0x%X, pBlob=0x%X, Status=0x%X\n", 
                     (ULONG_PTR)pClient, (ULONG_PTR)pBlob, Status));
    TRACE(IOCTL, OpCode, pClient, "UMCfInfoComplete:");
    TRACE(IOCTL, pBlob, Status, "UMCfInfoComplete:");
    
    //
    // Find the request IRP on the pending list.
    //
    IoAcquireCancelSpinLock(&oldIrql);

    for ( pEntry = PendingIrpCfInfoList.Flink;
          pEntry != &PendingIrpCfInfoList;
          pEntry = pEntry->Flink ) {

        pPendingIrp = CONTAINING_RECORD( pEntry, PENDING_IRP, Linkage);

        if (pPendingIrp->QComp.CfInfoHandle == (GPC_HANDLE)pBlob
            &&
            pPendingIrp->QComp.OpCode == OpCode ) {

            //
            // that's the pending request
            //

            pIrp = pPendingIrp->Irp;
            ASSERT(pIrp);
            IoSetCancelRoutine(pIrp, NULL);
            GpcRemoveEntryList(pEntry);
            break;

        } else {

            pPendingIrp = NULL;
        }
    }

    if (pPendingIrp == NULL) {

        //
        // No IRP, we need to queue a completion block
        //

        DBGPRINT(IOCTL, ("UMCfInfoComplete: No pending IRP found\n"));
        TRACE(IOCTL, pBlob, Status, "UMCfInfoComplete.NoPendingIrp:");

        GpcAllocFromLL(&pPendingIrp, &PendingIrpLL, PendingIrpTag);

        if (pPendingIrp) {

            pPendingIrp->Irp = NULL;
            pPendingIrp->FileObject = pClient->pFileObject;
            pPendingIrp->QComp.OpCode = OpCode;
            pPendingIrp->QComp.ClientHandle = (GPC_HANDLE)pClient;
            pPendingIrp->QComp.CfInfoHandle = (GPC_HANDLE)pBlob;
            pPendingIrp->QComp.Status = Status;

            GpcInsertTailList(&QueuedCompletionList, &pPendingIrp->Linkage);

        }

        IoReleaseCancelSpinLock(oldIrql);

        return;
    }

    IoReleaseCancelSpinLock(oldIrql);

    ASSERT(pPendingIrp && pIrp);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    GpcRes = (GPC_CF_INFO_RES *)pIrp->AssociatedIrp.SystemBuffer;

    DBGPRINT(IOCTL, ("UMCfInfoComplete: Pending IRP found=0x%X, Ioctl=0x%X\n",
                     (ULONG_PTR)pIrp,
                     pIrpSp->Parameters.DeviceIoControl.IoControlCode
                     ));

    TRACE(IOCTL, 
          pIrp, 
          pIrpSp->Parameters.DeviceIoControl.IoControlCode, 
          "UMCfInfoComplete.PendingIrp:");

    switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_GPC_ADD_CF_INFO:

        ASSERT(OpCode == OP_ADD_CFINFO);
        ASSERT(pBlob->State == GPC_STATE_ADD);

        GpcRes->AddRes.Status = Status;

        GpcRes->AddRes.ClientCtx = pClient->ClientCtx;
        GpcRes->AddRes.CfInfoCtx = pBlob->OwnerClientCtx;
        GpcRes->AddRes.GpcCfInfoHandle = pBlob->ClHandle;
            
        if (Status == GPC_STATUS_SUCCESS) {
            
            UNICODE_STRING CfInfoName;
            
            if (pBlob->pNotifiedClient) {
                
                GPC_STATUS	st = GPC_STATUS_FAILURE;

                if (pBlob->pNotifiedClient->FuncList.ClGetCfInfoName) {

                    ASSERT(pBlob->NotifiedClientCtx);

                    pBlob->pNotifiedClient->FuncList.ClGetCfInfoName(
                                       pBlob->pNotifiedClient->ClientCtx,
                                       pBlob->NotifiedClientCtx,
                                       &CfInfoName
                                       );
                    
                    if (CfInfoName.Length >= MAX_STRING_LENGTH * sizeof(WCHAR))
                            CfInfoName.Length = (MAX_STRING_LENGTH-1) * sizeof(WCHAR);
                }

                if (!NT_SUCCESS(st)) {

                    //
                    // generate a default name
                    //

                    swprintf(CfInfoName.Buffer, L"Flow %08X", pBlob->NotifiedClientCtx);
                    CfInfoName.Length = wcslen(CfInfoName.Buffer)*sizeof(WCHAR);

                }

                //
                // copy the instance name
                //
                    
                GpcRes->AddRes.InstanceNameLength = CfInfoName.Length;
                NdisMoveMemory(GpcRes->AddRes.InstanceName, 
                               CfInfoName.Buffer,
                               CfInfoName.Length
                               );
            }
        }

        outputBuferLength = sizeof(GPC_ADD_CF_INFO_RES);
        break;

    case IOCTL_GPC_MODIFY_CF_INFO:

        ASSERT(OpCode == OP_MODIFY_CFINFO);
        ASSERT(pBlob->State == GPC_STATE_MODIFY);

        GpcRes->ModifyRes.Status = Status;
        GpcRes->ModifyRes.ClientCtx = pClient->ClientCtx;
        GpcRes->ModifyRes.CfInfoCtx = pBlob->OwnerClientCtx;

        outputBuferLength = sizeof(GPC_MODIFY_CF_INFO_RES);
        break;

    case IOCTL_GPC_REMOVE_CF_INFO:

        ASSERT(OpCode == OP_REMOVE_CFINFO);
        ASSERT(pBlob->State == GPC_STATE_REMOVE);

        GpcRes->RemoveRes.Status = Status;
        GpcRes->RemoveRes.ClientCtx = pClient->ClientCtx;
        GpcRes->RemoveRes.CfInfoCtx = pBlob->OwnerClientCtx;

        outputBuferLength = sizeof(GPC_REMOVE_CF_INFO_RES);
        break;
        
    default:
        ASSERT(0);
    }
        
    GpcFreeToLL(pPendingIrp, &PendingIrpLL, PendingIrpTag);

    //
    // Complete the IRP.
    //

    pIrp->IoStatus.Information = outputBuferLength;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    DBGPRINT(IOCTL, ("UMCfInfoComplete: Completing IRP =0x%X, Status=0x%X\n",
                     (ULONG_PTR)pIrp, Status ));

    TRACE(IOCTL, pIrp, Status, "UMCfInfoComplete.Completing:");

    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    return;
}


NTSTATUS
CheckQueuedNotification(
	IN		PIRP	Irp,
    IN OUT  ULONG 	*outputBufferLength
    )
/*++

Routine Description:

	This routine will check for a queued notification structrue,
    and it will fill the ioBuffer in the IRP if one has been found
    and return STATUS_SUCCESS. This should cover the case where
    the IRP was not available when the notification was generated.
    O/w the routine returns STATUS_PENDING.

Arguments:

	Irp - the incoming IRP

Return Value:

    STATUS_SUCCESS or STATUS_PENDING

--*/

{
    KIRQL                 	oldIrql;
    PIO_STACK_LOCATION    	pIrpSp;
    PQUEUED_NOTIFY          pQItem = NULL;
    PLIST_ENTRY           	pEntry;
    NTSTATUS				Status;
    PPENDING_IRP			pPendingIrp;

    DBGPRINT(IOCTL, ("CheckQueuedNotification: IRP =0x%X\n",
                     (ULONG_PTR)Irp));

    TRACE(IOCTL, Irp, 0, "CheckQueuedNotification:");

    if (*outputBufferLength < sizeof(GPC_NOTIFY_REQUEST_RES)) {

        return STATUS_BUFFER_TOO_SMALL;
    }

    pIrpSp = IoGetCurrentIrpStackLocation(Irp);

    IoAcquireCancelSpinLock(&oldIrql);

    for ( pEntry = QueuedNotificationList.Flink;
          pEntry != &QueuedNotificationList;
          pEntry = pEntry->Flink ) {

        pQItem = CONTAINING_RECORD( pEntry, QUEUED_NOTIFY, Linkage);

        if (pQItem->FileObject == pIrpSp->FileObject) {

            //
            // the queued item if for this file object
            //

            GpcRemoveEntryList(pEntry);
            break;

        } else {

            pQItem = NULL;
        }
    }

    if (pQItem) {

        //
        // We found something on the queue, copy it to the IRP
        // and delete the item
        //

        DBGPRINT(IOCTL, ("CheckQueuedNotification: found QItem =0x%X\n",
                         (ULONG_PTR)pQItem));

        TRACE(IOCTL, 
              pQItem, 
              pQItem->NotifyRes.ClientCtx, 
              "CheckQueuedNotification.QItem:");

        ASSERT(*outputBufferLength >= sizeof(GPC_NOTIFY_REQUEST_RES));

        NdisMoveMemory(Irp->AssociatedIrp.SystemBuffer,
                       &pQItem->NotifyRes,
                       sizeof(GPC_NOTIFY_REQUEST_RES) );

        GpcFreeToLL(pQItem, &QueuedNotificationLL, QueuedNotificationTag);

        *outputBufferLength = sizeof(GPC_NOTIFY_REQUEST_RES);

        Status = STATUS_SUCCESS;

    } else {

        DBGPRINT(IOCTL, ("CheckQueuedNotification: QItem not found...PENDING\n"
                         ));

        TRACE(IOCTL, 0, 0, "CheckQueuedNotification.NoQItem:");

        GpcAllocFromLL(&pPendingIrp, &PendingIrpLL, PendingIrpTag);

        if (pPendingIrp != NULL) {

            //
            // add the IRP on the pending notification list
            //

            DBGPRINT(IOCTL, ("CheckQueuedNotification: adding IRP=0x%X to list=0x%X\n",
                             (ULONG_PTR)Irp, (ULONG_PTR)pIrpSp ));
            TRACE(IOCTL, Irp, pIrpSp, "CheckQueuedNotification.Irp:");

            pPendingIrp->Irp = Irp;
            pPendingIrp->FileObject = pIrpSp->FileObject;

            if (!Irp->Cancel) {
            
                IoSetCancelRoutine(Irp, CancelPendingIrpNotify);
                GpcInsertTailList(&PendingIrpNotifyList, &(pPendingIrp->Linkage));

                Status = STATUS_PENDING;

            } else {

                DBGPRINT(IOCTL, ("CheckQueuedNotification: Status Cacelled: IRP=0x%X\n",
                                 (ULONG_PTR)Irp ));

                TRACE(IOCTL, Irp, pIrpSp, "CheckQueuedNotification.Cancelled:");
                GpcFreeToLL(pPendingIrp, &PendingIrpLL, PendingIrpTag);

                Status = STATUS_CANCELLED;
            }

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        *outputBufferLength = 0;
        
    }

    IoReleaseCancelSpinLock(oldIrql);

    return Status;
}



NTSTATUS
CheckQueuedCompletion(
	IN PQUEUED_COMPLETION	pQItem,
    IN PIRP              	Irp
    )
/*++

Routine Description:

	This routine will check for a queued completion structrue
    with the same CfInfoHandle, and it will return it if found.
    The original queued memory block is release here.
    If not found, the returned status is PENDING, o/w the queued status
    is returned.

Arguments:

	pQItem - pass in the CfInfoHandle and ClientHandle

Return Value:

    Queued status or STATUS_PENDING

--*/

{
    KIRQL                 	oldIrql;
    PLIST_ENTRY           	pEntry;
    NTSTATUS				Status;
    PPENDING_IRP			pPendingIrp = NULL;
    PIO_STACK_LOCATION		irpStack;

    DBGPRINT(IOCTL, ("CheckQueuedCompletion: pQItem=0x%X\n",
                     (ULONG_PTR)pQItem));

    TRACE(IOCTL, 
          pQItem->OpCode, 
          pQItem->ClientHandle, 
          "CheckQueuedCompletion:");
    TRACE(IOCTL, 
          pQItem->CfInfoHandle, 
          pQItem->Status, 
          "CheckQueuedCompletion:");

    IoAcquireCancelSpinLock(&oldIrql);

    for ( pEntry = QueuedCompletionList.Flink;
          pEntry != &QueuedCompletionList;
          pEntry = pEntry->Flink ) {

        pPendingIrp = CONTAINING_RECORD( pEntry, PENDING_IRP, Linkage);

        if ((pQItem->OpCode == OP_ANY_CFINFO || 
             pQItem->OpCode == pPendingIrp->QComp.OpCode)
            &&
            pPendingIrp->QComp.ClientHandle == (PVOID)pQItem->ClientHandle
            &&
            pPendingIrp->QComp.CfInfoHandle == (PVOID)pQItem->CfInfoHandle) {

            //
            // the queued item if for this file object
            // and the OpCode match
            // and it has the same CfInfo memory pointer
            //
            
            GpcRemoveEntryList(pEntry);
            break;

        } else {

            pPendingIrp = NULL;
        }
    }

    if (pPendingIrp) {

        //
        // get the status and free the queued completion item
        //

        DBGPRINT(IOCTL, ("CheckQueuedCompletion: found pPendingIrp=0x%X, Status=0x%X\n",
                         (ULONG_PTR)pPendingIrp, pPendingIrp->QComp.Status));


        TRACE(IOCTL, 
              pPendingIrp->QComp.OpCode, 
              pPendingIrp->QComp.ClientHandle, 
              "CheckQueuedCompletion.Q:");
        TRACE(IOCTL, 
              pPendingIrp->QComp.CfInfoHandle, 
              pPendingIrp->QComp.Status, 
              "CheckQueuedCompletion.Q:");

#if DBG
        if (pQItem->OpCode != OP_ANY_CFINFO) {

            ASSERT(pPendingIrp->QComp.OpCode == pQItem->OpCode);
            ASSERT(pPendingIrp->QComp.ClientHandle == pQItem->ClientHandle);
        }
#endif

        Status = pPendingIrp->QComp.Status;

        GpcFreeToLL(pPendingIrp, &PendingIrpLL, PendingIrpTag);

    } else {

        DBGPRINT(IOCTL, ("CheckQueuedCompletion: pPendingIrp not found...PENDING\n"
                         ));

        TRACE(IOCTL, 0, 0, "CheckQueuedCompletion.NopQ:");

        GpcAllocFromLL(&pPendingIrp, &PendingIrpLL, PendingIrpTag);

        if (pPendingIrp != NULL) {

            //
            // add the IRP on the pending CfInfo list
            //

            irpStack = IoGetCurrentIrpStackLocation(Irp);

            DBGPRINT(IOCTL, ("CheckQueuedCompletion: adding IRP=0x%X\n",
                             (ULONG_PTR)Irp ));
            TRACE(IOCTL, Irp, irpStack, "CheckQueuedCompletion.Irp:");

            pPendingIrp->Irp = Irp;
            pPendingIrp->FileObject = irpStack->FileObject;
            pPendingIrp->QComp.OpCode = pQItem->OpCode;
            pPendingIrp->QComp.ClientHandle = pQItem->ClientHandle;
            pPendingIrp->QComp.CfInfoHandle = pQItem->CfInfoHandle;
            pPendingIrp->QComp.Status = pQItem->Status;

            if (!Irp->Cancel) {
            
                IoSetCancelRoutine(Irp, CancelPendingIrpCfInfo);
                GpcInsertTailList(&PendingIrpCfInfoList, &(pPendingIrp->Linkage));

                Status = STATUS_PENDING;

            } else {

                DBGPRINT(IOCTL, ("CheckQueuedCompletion: Status Cacelled: IRP=0x%X\n",
                                 (ULONG_PTR)Irp ));

                TRACE(IOCTL, Irp, irpStack, "CheckQueuedCompletion.Cancelled:");
                GpcFreeToLL(pPendingIrp, &PendingIrpLL, PendingIrpTag);

                Status = STATUS_CANCELLED;
            }

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        
    }

    IoReleaseCancelSpinLock(oldIrql);

    return Status;
}



/* end ioctl.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\refcnt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    refcnt.c

Abstract:

    This module exports Reference Counting support functions. By 
    including a Reference Count Control Block (REF_CNT) in a
    dynamic type, and using this API, a Reference scheme can be
    implemented for that type.

Author:

    Edward Buchwalter (v-edbuc)    14-Aug-1996

Revision History:

    Shreedhar Madhavapeddi (ShreeM) 16-April-1999
    
    Adapted for NT and GPC by ShreeM\MBert.
    
--*/

//
// Include Files
//

#include "gpcpre.h"

#define EXPAND_TAG(t)   ((CHAR *)(&Tag))[0],((CHAR *)(&Tag))[1],((CHAR *)(&Tag))[2],((CHAR *)(&Tag))[3]
VOID
ReferenceInit 
(
    IN PREF_CNT pRefCnt,
    PVOID       InstanceHandle,
    VOID        (*DeleteHandler)( PVOID )
)

/*++

Routine Description:

    ReferenceInit initializes and adds one reference to the
    supplied Reference Control Block. If provided, an instance
    handle and delete handler are saved for use by the ReferenceRemove 
    function when all references to the instance are removed.

Arguments:

    pRefCnt - pointer to uninitialized Reference Control Block
    InstanceHandle - handle to the managed instance.
    DeleteHandler - pointer to delete function, NULL is OK.

Return Value:

    The function's value is VOID.

--*/

{
    TRACE(REFCOUNT, pRefCnt, InstanceHandle, "ReferenceInit( 0x%x, 0x%x )\n");
    ASSERT( pRefCnt );

    // Set the reference to 1 and save the instance 
    // handle and the delete handler.

    pRefCnt->Count         = 0;
    pRefCnt->Instance      = InstanceHandle;
    pRefCnt->DeleteHandler = DeleteHandler;
    
#if DBG
    pRefCnt->Sig = REF_SIG;

    RtlZeroMemory(pRefCnt->Tags, sizeof(REF_TAG) * TAG_CNT);
    
    pRefCnt->Tags[0].Tag = 'LTOT';
    
    CTEInitLock(&pRefCnt->Lock);
    
#endif
        
}

VOID
ReferenceAdd
(
    IN  PREF_CNT pRefCnt
)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    ASSERT( pRefCnt );

    InterlockedIncrement(&pRefCnt->Count);
    TRACE(REFCOUNT, pRefCnt->Count, 0, "R+%d\n");

}

VOID
ReferenceAddCount
(
    IN  PREF_CNT    pRefCnt,
    IN  UINT        Count
)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    ASSERT( pRefCnt->Count > 0 );

    CTEInterlockedExchangeAdd(&pRefCnt->Count, Count);
}

PVOID
ReferenceRemove 
(
    IN PREF_CNT  pRefCnt
)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    ASSERT( pRefCnt );

    // Trap remove reference on a zero count

    ASSERT( pRefCnt->Count > 0 );

    // If the decremented count is non zero return the instance handle

    if (InterlockedDecrement(&pRefCnt->Count) > 0 )
    {
        TRACE(REFCOUNT, pRefCnt->Count, 0, "R-%d\n");        
        TRACE(REFCOUNT, pRefCnt->Count, 0, "ReferenceRemove:remaining: %d\n");
        return( pRefCnt->Instance );
    }

    // Delete this instance if a delete handler is available

    if( pRefCnt->DeleteHandler )
    {
        TRACE(REFCOUNT, 0, 0, "Executing DeleteHandler\n");

        (pRefCnt->DeleteHandler)( pRefCnt->Instance );
    }

    // Indicate no active references to this instance

    return( NULL );
}

//
// API Test Support
//

#if DBG

VOID
ReferenceApiTest( VOID )
{
REF_CNT  RefCnt;

    TRACE(REFCOUNT, 0, 0, "\nReferenceApiTest\n");
    TRACE(REFCOUNT, 0, 0, "\nTest #1: NULL delete handler\n");

    ReferenceInit( &RefCnt, &RefCnt, NULL );

    ReferenceAdd( &RefCnt );
    ReferenceAdd( &RefCnt );
    ReferenceAdd( &RefCnt );

    while( ReferenceRemove( &RefCnt ) )
    {
        ;
    }

    TRACE( REFCOUNT, 0, 0, "\nTest #2: Delete Handler - TBD\n");
}

VOID
ReferenceAddDbg(PREF_CNT pRefCnt, ULONG Tag)
{
    int             i;
    CTELockHandle   hLock;
    int             TotalPerArray = 0;
    
    ASSERT(pRefCnt->Sig == REF_SIG);
    
    TRACE(REFCOUNT, EXPAND_TAG(Tag), pRefCnt->Count, ("GPC REF: add (%c%c%c%c) %d\n"));
    
    CTEGetLock(&pRefCnt->Lock, &hLock);
    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == 0 || pRefCnt->Tags[i].Tag == Tag)
        {
            pRefCnt->Tags[i].Tag = Tag;
            InterlockedIncrement(&pRefCnt->Tags[i].Count);
            break;
        }
    }
    
    ASSERT(i < TAG_CNT);
    
    InterlockedIncrement(&pRefCnt->Tags[0].Count);
    
    InterlockedIncrement(&pRefCnt->Count);
    
    ASSERT(pRefCnt->Tags[0].Count == pRefCnt->Count);

    // sanity check
/*    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }

    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgBreakPoint();
    }        
    

*/    
    CTEFreeLock(&pRefCnt->Lock, hLock);
}

VOID
ReferenceRemoveDbg(PREF_CNT pRefCnt, ULONG Tag)
{
    int             i;
    CTELockHandle   hLock;
    int             TotalPerArray = 0;
    BOOLEAN         FoundIt = FALSE;
    
    ASSERT(pRefCnt->Sig == REF_SIG);

    TRACE(REFCOUNT, EXPAND_TAG(Tag), pRefCnt->Count, "GPC REF: remove (%c%c%c%c) %d\n");
             
    CTEGetLock(&pRefCnt->Lock, &hLock);
        
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == Tag)
        {
            FoundIt = TRUE;
            
            ASSERT(pRefCnt->Tags[i].Count > 0);
            
            InterlockedDecrement(&pRefCnt->Tags[i].Count);
            if (pRefCnt->Tags[i].Count == 0)
                pRefCnt->Tags[i].Tag = Tag; 
            break;
        }
    }

    ASSERT(FoundIt);
  
    ASSERT(pRefCnt->Tags[0].Count > 0);
        
    ASSERT(pRefCnt->Tags[0].Count == pRefCnt->Count);
      
    InterlockedDecrement(&pRefCnt->Tags[0].Count);
    
    if (InterlockedDecrement(&pRefCnt->Count) > 0 )
    {
        CTEFreeLock(&pRefCnt->Lock, hLock);
    } 
    else if (pRefCnt->DeleteHandler)
    {
        TRACE(REFCOUNT, 0 , 0, "Executing DeleteHandler\n");
        
        CTEFreeLock(&pRefCnt->Lock, hLock);
        
        (pRefCnt->DeleteHandler)( pRefCnt->Instance );
    }
    else
    {
        CTEFreeLock(&pRefCnt->Lock, hLock);   
    }
        
/*
    // sanity check
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }
    
    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgPrint(TEXT("Tag %X, RefCnt %X, perArray %d, total %d\n"), Tag, pRefCnt,
                  TotalPerArray, pRefCnt->Tags[0].Count);
                  
        DbgBreakPoint();
    }    
    

*/    
}



VOID
ReferenceCheckForZeroRef(PREF_CNT pRefCnt, ULONG Tag)
{
    int             i;
    CTELockHandle   hLock;
    int             TotalPerArray = 0;
    BOOLEAN         FoundIt = FALSE;
    
    ASSERT(pRefCnt->Sig == REF_SIG);

    CTEGetLock(&pRefCnt->Lock, &hLock);
        
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == Tag)
        {
            FoundIt = TRUE;
            
            ASSERT(pRefCnt->Tags[i].Count == 0);

            break;
        }
    }

    ASSERT(FoundIt);
  
    CTEFreeLock(&pRefCnt->Lock, hLock);   
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\handfact.h ===
/*
 *  handfact.h
 *
 *  author:	John R. Douceur
 *  date:	26 January 1998
 *
 *  This header file defines structures, function prototypes, and macros for
 *  the handle factory.  The code is object-oriented C, transliterated from a
 *  C++ implementation.
 *
 *  The handle factory is a component that generates and validates handles.  It
 *  is intended to be used in a software module that provides client software
 *  modules with means to refer to information structures contained within the
 *  provider.  While such a means could simply be a pointer, this would not
 *  enable the deletion of the information structures without explicitly
 *  notifying the clients of such deletion.  Unlike pointers, the handles
 *  generated by the handle factory can be examined (by the handle factory)
 *  to determine their validity.
 *
 *  Handles can be invalidated in one of two ways.  The handle can be released
 *  by calling the release_HF_handle() function, indicating to the handle
 *  factory that the handle is no longer necessary and that future requests
 *  to dereference this handle should be met with a null pointer.  Alternately,
 *  the handle can be revoked by the handle factory; this will happen unter two
 *  circumstances.  If a large number of handles (more than four billion) are
 *  issued and subsequently released, it becomes necessary to reuse portions of
 *  the handle space for future assignments; under these circumstances, very
 *  old handles will be revoked well before this recycling occurs, to give the
 *  holders of those handles ample opportunity to notice that their handles
 *  have become invalid and to request new handles.  The other situation in
 *  which revokation can occur is if the amount of available memory becomes
 *  too small to allocate additional space to expand the handle database; then,
 *  if the assignment of a new handle is requested, the least-recently-assigned
 *  handle will be revoked to make room for the new request.
 *
 *  Use of the handle factory in a multi-threaded environment requires a lock.
 *  This lock must be taken by a single thread for the execution of either
 *  assign_HF_handle() or release_HF_handle().  Use of dereference_HF_handle()
 *  does not require taking a lock, since synchronization is handled internally
 *  through careful sequencing of read and write operations.
 *
 *  Because this code is C, rather than C++, it is not possible to hide as
 *  much of the implementation from the client code as one might wish.
 *  Nonetheless, there is an attempt to isolate the client from some of the
 *  implementation details through the use of macros.  Below is described each
 *  of the functions and macros necessary to use the handle factory.
 *
 */

#ifndef _INC_HANDFACT

#define _INC_HANDFACT

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  There are two basic structures employed: the HFEntry and the HandleFactory.
 *  Ideally, these would be completely hidden from the client, but the size of
 *  the HandleFactory structure structure needs to be known by the client for
 *  allocation purposes, and this is most easily accomplished by declaring the
 *  structure itself here in the header file, which in turn requires declaring
 *  the HFEntry structure.  It is strongly urged that the client not directly
 *  refer to any of the fields of either of these structures.  To support the
 *  documentation of the accompanying rhizome.c file, these structures are
 *  annotated with internal comments, but these can be ignored by the reader
 *  who wishes only to understand how to write client code that makes use of
 *  the handle factory.
 *
 *  The handles generated by the handle factory are of type HFHandle.  This is
 *  typedefed to an unsigned int, but this fact can be ignored by the client,
 *  since it is an implementation detail.
 *
 */

//#include <stdlib.h>
//#include <malloc.h>

// HFHandle is the type of the handles generated by the handle factory.
//
typedef unsigned int HFHandle;

struct _HFEntry;

typedef struct _HFEntry HFEntry;

struct _HFEntry
{
	// This is the element in which each handle and its associated pointer are
	// stored.  If handle == next_handle, the entry is not assigned, and it is
	// available for assignment to a pointer via the assign_HF_handle()
	// function.  If handle != next_handle, then the entry is assigned to the
	// pointer in the reference field.
	//
	// Each entry is on one of three lists: the primary free list, the secondary
	// free list, or the assigned list.  Each of these lists is maintained via
	// the next_entry and prev_entry pointers.

	HFHandle handle;                                          // value of handle
	HFHandle next_handle;         // next value given to handle when invalidated
	void *reference;                           // pointer to which handle refers
	HFEntry *next_entry;                        // pointer to next entry in list
	HFEntry *prev_entry;                    // pointer to previous entry in list
};

struct _HandleFactory;

typedef struct _HandleFactory HandleFactory;

struct _HandleFactory
{
	// This structure contains private member variables for the handle factory.
	// The first four fields are marked volatile to insure that the operations
	// performed on them occur in the specified sequence.  The handle factory
	// can operate in a multi-threaded environment without requiring that a
	// lock be taken before calling dereference_HF_handle(), and this is
	// accomplished by careful sequencing of the read and write operations on
	// these four variables.
	//
	// The verifier variables are used to provide a simple synchronization
	// mechanism.  When the variables have the same value, then the table_size
	// and entries variables are in a consistent state.
	//
	// The table that holds the handles can only be contracted (shrunk in half)
	// when for each assigned handle in the lower half of the table, there is
	// no assigned handle in the corresponding upper half of the table.  The
	// number of correspondences between the two table halves is given by
	// pair_count.

	volatile int table_size;                // size of table for storing entries
	HFEntry *volatile entries;                   // pointer to tables of entries
	volatile int verifier0;                          // synchronization variable
	volatile int verifier1;                          // synchronization variable
	HFHandle handle_base;                // rolling point of lowest handle value
	int population;                      // number of handles currently assigned
	int pair_count;               // contractions can occur when pair_count == 0
	int hysteresis_debt;                      // must be zero before contraction
	HFEntry entry_list[3];                     // array of all three entry lists
};

/*
 *  The client interface to the handle factory is provided by seven functions
 *  and one macro.  It is expected that the provider will first instantiate a
 *  handle factory, either in the static data segment, on the stack, or on the
 *  heap.  Then, the provider will assign handles to various pointers by
 *  calling assign_HF_handle(), which it will distribute to its clients.  When
 *  the provider wishes to release these handles, it will do so by calling
 *  release_HF_handle().  Each time a client presents a handle to the provider,
 *  the provider can validate the handle and retrieve the associated pointer
 *  by calling dereference_HF_handle().  A client can temporarily suspend a
 *  handle by calling suspend_HF_handle(), after which it can either reinstate
 *  the handle by calling reinstate_HF_handle() or release the handle by calling
 *  release_HF_handle().
 *
 */

// A handle factory may be allocated in the static data segment or on the stack
// simply by declaring a variable of type HandleFactory.  To allocate it on the
// heap, the following macro returns a pointer to a new HandleFactory structure.
// If this macro is used, a corresponding call to free() must be made to
// deallocate the structure from the heap.
//
#define NEW_HandleFactory(_h)   GpcAllocMem(&(_h),\
                                            sizeof(HandleFactory),\
                                            HandleFactoryTag)

#define FreeHandleFactory(_h)   GpcFreeMem((_h),\
                                           HandleFactoryTag)

// Since this is not C++, the HandleFactory structure is not self-constructing;
// therefore, the following constructor code must be called on the HandleFactory
// structure after it is allocated.  If the construction is successful, the
// function returns a value of 0.  If the construction fails (due, for example,
// to an inability to allocate memory), the function returns a value of 1.
//
int
constructHandleFactory(
	HandleFactory *hfact);

// Since this is not C++, the HandleFactory structure is not self-destructing;
// therefore, the following destructor code must be called on the HandleFactory
// structure before it is deallocated.
//
void
destructHandleFactory(
	HandleFactory *hfact);

// This function generates a new handle value, associates the handle value with
// the provided reference pointer, and returns the handle value.  Barring
// highly unusual circumstances, this handle will remain valid until it is
// explicitly released by a call to release_HF_handle().  However, there is no
// guarantee that the handle will persist for an arbitrary duration; it may
// become necessary for the handle factory to revoke the handle under some
// circumstances, particularly when the handle becomes very old or when memory
// becomes scarce.
//
// The assign_HF_handle() function will never return a handle value of zero.
// Thus, the client program is free to use a zero handle value as an escape
// indicator, if desired.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// release_HF_handle(), suspend_HF_handle(), and reinstate_HF_handle().
//
HFHandle
assign_HF_handle(
	HandleFactory *hfact,
	void *reference);

// This function releases a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned, then it is released, and the function
// returns a value of 0.  If the handle is not currently assigned, the function
// aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), suspend_HF_handle(), and reinstate_HF_handle().
//
int
release_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);

// This function suspends a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle, unless and until
// reinstate_HF_handle() is called on the handle value.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned and not suspended, then it is suspended,
// and the function returns a value of 0.  If the handle is not currently
// assigned or has already been suspended, the function aborts and returns a
// value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and reinstate_HF_handle().
//
int
suspend_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);

// This function reinstates a suspended handle, indicating that further attempts
// to dereference the handle should result in the pointer value that was
// originally assigned to the handle, rather than the null pointer value to
// which a suspended handle dereferences.  The handle factory checks the
// validity of the handle and returns a corresponding status code. If the handle
// is currently assigned and suspended, then it is reinstated, and the function
// returns a value of 0.  If the handle is not currently assigned or is not
// suspended, the function aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and suspend_HF_handle().
//
int
reinstate_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);

// This function validates a handle and returns either the associated pointer
// (if the handle is valid) or a null pointer value (if the handle is invalid).
// If the handle has not been released or suspended but a null value is
// returned, then the handle has been revoked by the handle factory.  This is
// expected to be a highly unusual occurrence; however, since it can happen, any
// program that employs the handle factory must have some auxiliary mechanism
// for retrieving the desired pointer information.  Once the pointer is
// retrieved through this (presumably expensive) auxiliary means, a new handle
// can be reassigned to the pointer by another call to assign_HF_handle().
//
// Even in a multi-threaded environment, it is not necessary to take a lock
// prior to calling this function.  Careful sequencing of read and write
// operations inside the handle factory code obviates the need to explicitly
// lock the data structure for dereferencing handles.
//
void *
dereference_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);


void *
dereference_HF_handle_with_cb(
	HandleFactory *hfact,
	HFHandle handle,
    ULONG offset);

#ifdef _TEST_HANDFACT

// This is a test routine that simply verifies the internal valididy of the
// handle factory's data structures.  By defining the constant _TEST_HANDFACT,
// this routine will be compiled and available to the client code.  It can be
// called at any time, unless running in a multi-threaded environment, in which
// case the caller must first take the same lock used for assign_HF_handle(),
// release_HF_handle(), suspend_HF_handle(), and reinstate_HF_handle().  If the
// routine returns any value other than zero, then the internal lists of records
// are in an inconsistent state.
//
int
verify_HF_lists(
	HandleFactory *hfact);

#if DBG
#define VERIFY_HF_HFACT(_hfact) ASSERT(verify_HF_lists(_hfact)==0)
#else
#define VERIFY_HF_HFACT(_hfact)
#endif

#endif /* _TEST_HANDFACT */

#ifdef __cplusplus
}
#endif

#endif	/* _INC_HANDFACT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\rhizome.c ===
/*
 *  rhizome.c
 *
 *  author:	John R. Douceur
 *  date:	28 April 1997
 *
 *  This source file provides functions that implement insertion, removal, and
 *  search operations on the rhizome database.  The code is object-oriented C,
 *  transliterated from a C++ implementation.
 *
 *  The rhizome is a database that stores patterns containing wildcards.
 *  Each pattern defines a set of keys that it matches; if a pattern contains
 *  N wildcards, then it matches 2^N keys.  Since each pattern can match
 *  multiple keys, it is possible for a given key to match multiple patterns
 *  in the database.  The rhizome requires that all patterns stored therein
 *  have a strict hierarchical interrelationship.  Two patterns may match no
 *  common keys (in which case the patterns are said to be independent), or
 *  one pattern may match all the keys matched by a second pattern as well as
 *  additonal keys (in which case the second pattern is said to be more general
 *  than the first, and the first more specific than the second).  The database
 *  will not accept two patterns which match some keys in common but each of
 *  which also matches additional keys that the other does not.
 *
 *  The database can be searched for patterns that match a given search key.
 *  When the database is searched for a given key, the most specifically
 *  matching pattern is found.  If no patterns in the database match the key,
 *  an appropriate indication is returned.
 *
 *  None of the code or comments in this file needs to be understood by writers
 *  of client code; all explanatory information for clients is found in the
 *  associated header file, rhizome.h.
 *
 */

#include "gpcpre.h"

// The fields of the RhizomeNode structure are accessed through the following
// macros.  The first three are obvious; the subsequent three rely on an agreed
// usage of the cdata array in the RhizomeNode.  The first keybytes locations
// of the cdata array are used to store the value field of the node; the second
// keybytes locations store the mask field; and the third keybytes locations
// store the imask field.
//
#define CHILDREN udata.branch.children
#define REFERENCE udata.leaf.reference
#define GODPARENT udata.leaf.godparent
#define VALUE(pointer) (pointer->cdata)
#define MASK(pointer) (pointer->cdata + rhizome->keybytes)
#define IMASK(pointer) (pointer->cdata + 2 * rhizome->keybytes)

// This macro allocates a new rhizome node structure.  The size of the structure
// is a function of the value of keybytes, since three bytes of information
// need to be stored in the structure for each byte of pattern length.  The
// cdata array, which is the last field in the structure, is declared as a
// having a single element, but this array will actually extend beyond the
// defined end of the structure into additional space that is allocated for it
// by the following macro.
//
#define NEW_RhizomeNode(_pa) \
	GpcAllocMem(_pa,\
                sizeof(RhizomeNode) + 3 * rhizome->keybytes - 1,\
                RhizomeTag);\
    TRACE(RHIZOME, *_pa, sizeof(RhizomeNode) + 3 * rhizome->keybytes - 1, "NEW_RhizomeNode")


// This macro gets the indexed bit of the value, where the most-significant bit
// is defined as bit 0.
//
#define BIT_OF(value, index) \
	(((value)[(index) >> 3] >> (7 - ((index) & 0x7))) & 0x1)

// Following are prototypes for static functions that are used internally by
// the implementation of the rhizome routines.

static int
node_insert(
	Rhizome *rhizome,
	RhizomeNode *new_leaf,
	RhizomeNode **ppoint,
	int prev_bit);

static void
node_remove(
	Rhizome *rhizome,
	RhizomeNode *leaf,
	RhizomeNode **ppoint);

static RhizomeNode *
replicate(
	Rhizome *rhizome,
	RhizomeNode *source,
	int pivot_bit);

static void
eliminate(
	Rhizome *rhizome,
	RhizomeNode *point);

static void
coalesce(
	Rhizome *rhizome,
	RhizomeNode **leaf_list,
	RhizomeNode *point);


// Since this is not C++, the Rhizome structure is not self-constructing;
// therefore, the following constructor code must be called on the Rhizome
// structure after it is allocated.  The argument keybits specifies the size
// (in bits) of each pattern that will be stored in the database.
//
void
constructRhizome(
	Rhizome *rhizome,
	int keybits)
{
	rhizome->keybits = keybits;
	rhizome->keybytes = (keybits - 1) / 8 + 1;
	rhizome->root = 0;
}

// Since this is not C++, the Rhizome structure is not self-destructing;
// therefore, the following destructor code must be called on the Rhizome
// structure before it is deallocated.
//
// If the structure is non-empty, call coalesce() to eliminate
// all branch nodes and to string leaf nodes into a list; then delete list.
//
void
destructRhizome(
	Rhizome *rhizome)
{
	RhizomeNode *leaf_list, *next;
	if (rhizome->root != 0)
	{
		leaf_list = 0;
		coalesce(rhizome, &leaf_list, rhizome->root);
		while (leaf_list != 0)
		{
			next = leaf_list->GODPARENT;
			GpcFreeMem(leaf_list, RhizomeTag);
			leaf_list = next;
		}
	}
}

// This function searches the database for the pattern that most specifically
// matches the given key.  The key is passed as an array of bytes.  When the
// most specific match is found, the PatternHandle of that matching pattern is
// returned.  From the PatternHandle can be gotten the reference value via the
// macro GetReferenceFromPatternHandle.  If no pattern in the database is found
// to match the key, then a value of 0 is returned as the PatternHandle.
//
PatternHandle
searchRhizome(
	Rhizome *rhizome,
	char *key)
{
	int index;
	RhizomeNode *point;
	// If tree is empty, search fails.
	if (rhizome->root == 0)
	{
		return 0;
	}
	// Otherwise, start at rhizome->root and navigate tree until reaching a leaf.
	point = rhizome->root;
	while (point->pivot_bit < rhizome->keybits)
	{
		point = point->CHILDREN[BIT_OF(key, point->pivot_bit)];
	}
	// Check value for match, one byte at a time.  If any byte fails to match,
	// continue checking godparent with same byte; since previous bytes matched
	// godchild, they are guaranteed to match godparent also.
	index = 0;
	while (index < rhizome->keybytes)
	{
		if ((((key)[index]) & MASK(point)[index]) != VALUE(point)[index])
		{
			if (point->GODPARENT != 0)
			{
				point = point->GODPARENT;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			index++;
		}
	}
	return point;
}

// This function inserts a new pattern into the database.  The pattern is
// specified by a value and a mask.  Each bit of the mask determines whether
// the bit position is specified or is a wildcard:  A 1 in a mask bit indicates
// that the value of that bit is specified by the pattern; a 0 indicates that
// the value of that bit is a wildcard.  If a mask bit is 1, then the
// corresponding bit in the value field indicates the specified value of that
// bit.  Value and mask fields are passed as arrays of bytes.
//
// The client specifies a void pointer reference value to associate with the
// pattern.  When the pattern is installed, the insertRhizome function returns
// a pointer to a PatternHandle.
//
// If the new pattern conflicts with a pattern already installed in the
// database, meaning that the two patterns match some keys in common but each
// also matches additional keys that the other does not, then the new pattern
// is not inserted, and a value of 0 is returned as the PatternHandle.
//
PatternHandle
insertRhizome(
	Rhizome *rhizome,
	char *value,
	char *mask,
	void *reference,
    ulong *status)
{
	RhizomeNode *new_leaf;
	int index0, insert_status;
    
    *status = GPC_STATUS_SUCCESS;

	// Create new leaf and copy data into it; restrict set bits of value to
	// those set in mask, since later code assumes this is the case.  Add new
	// leaf to reference table.
	NEW_RhizomeNode(&new_leaf);
	if (new_leaf == 0)
	{
		// Memory could not be allocated for this new node.  Therefore, we
		// return an indication of failure to the client.
        *status = GPC_STATUS_RESOURCES;
		return 0;
	}
	for (index0 = 0; index0 < rhizome->keybytes; index0++)
	{
		VALUE(new_leaf)[index0] = value[index0] & mask[index0];
		MASK(new_leaf)[index0] = mask[index0];
		IMASK(new_leaf)[index0] = mask[index0];
	}
	new_leaf->REFERENCE = reference;
	new_leaf->pivot_bit = rhizome->keybits;
	new_leaf->GODPARENT = 0;
	// If tree is empty, leaf becomes first node; otherwise, attempt to insert
	// using recursive node_insert() routine.  If new leaf conflicts with
	// existing leaf, node_insert() throws exception; then remove new leaf and
	// return failure code.
	if (rhizome->root == 0)
	{
		rhizome->root = new_leaf;
	}
	else
	{
		insert_status = node_insert(rhizome, new_leaf, &rhizome->root, -1);
		if (insert_status != GPC_STATUS_SUCCESS)
		{
			removeRhizome(rhizome, new_leaf);
            *status = GPC_STATUS_CONFLICT;
			return 0;                                     // return null pointer
		};
	}
	return new_leaf;
}

// This function removes a pattern from the rhizome.  The pattern is specified
// by the PatternHandle that was returned by the insertRhizome function.  No
// checks are performed to insure that this is a valid handle.
//
void
removeRhizome(
	Rhizome *rhizome,
	PatternHandle phandle)
{
	// Call recursive node_remove() routine to remove all references to leaf;
	// then delete leaf.
	node_remove(rhizome, phandle, &rhizome->root);
    TRACE(RHIZOME, rhizome, phandle, "removeRhizome")
	GpcFreeMem(phandle, RhizomeTag);
}

// Insert new_leaf into subtree pointed to by *ppoint.  Update *ppoint to point
// to newly created nodes if necessary.  Index of most recently examined bit
// is given by prev_bit.  The return value is a status code:  Normally, it
// returns GPC_STATUS_SUCCESS; if there is a conflict, then it returns NDIS_STATUS_CONFLICT;
// if there is insufficient memory available to perform the insertion, then it
// returns GPC_STATUS_RESOURCES.
//
static int
node_insert(
	Rhizome *rhizome,
	RhizomeNode *new_leaf,
	RhizomeNode **ppoint,
	int prev_bit)
{
	int index, index0, bit_value, insert_status;
	char sub, super;
	RhizomeNode *point, *child, *new_branch;
	// This routine has a recursive structure, but unnecessary recursions have
	// been replaced by iteration, in order to improve performance.  This
	// recursion removal has introduced a forever loop which encloses the
	// entirety of the routine; looping back to the beginning of this loop is
	// thus the equivalent of recursing.
	while (1)
	{
		point = *ppoint;
		// Examine each bit index beginnig with that following last bit index
		// examined previously.  Continue examining bits until pivot bit of
		// current node is reached (unless loop is terminated prematurely).
		for (index = prev_bit + 1; index < point->pivot_bit; index++)
		{
			// If some leaf in the current subtree cares about the value of the
			// current bit, and if the new leaf cares about the value of the
			// current bit, and these two leaves disagree about the value of
			// this bit, then a new branch node should be inserted here.
			if (BIT_OF(MASK(new_leaf), index) == 1 &&
				BIT_OF(MASK(point), index) == 1 &&
				BIT_OF(VALUE(new_leaf), index) != BIT_OF(VALUE(point), index))
			{
				// Create new branch node; insert into tree; and set fields.
				bit_value = BIT_OF(VALUE(new_leaf), index);
				NEW_RhizomeNode(&new_branch);
				if (new_branch == 0)
				{
					// Memory could not be allocated for this new node.
					// Therefore, we pass an indication of failure up the stack.
					return GPC_STATUS_RESOURCES;
				}
				*ppoint = new_branch;
				for (index0 = 0; index0 < rhizome->keybytes; index0++)
				{
					VALUE(new_branch)[index0] =
						VALUE(point)[index0] | VALUE(new_leaf)[index0];
					MASK(new_branch)[index0] =
						MASK(point)[index0] | MASK(new_leaf)[index0];
					IMASK(new_branch)[index0] =
						IMASK(point)[index0] & IMASK(new_leaf)[index0];
				}
				// Pivot bit of new branch node is the bit that inspired the
				// creation of this branch.
				new_branch->pivot_bit = index;
				// The earlier subtree becomes the child whose bit disagreed
				// with that of the new leaf.
				new_branch->CHILDREN[1 - bit_value] = point;
				// If every leaf in the subtree cares about the value of this
				// bit, then we can insert the new leaf as the other child of
				// this branch.
				if (BIT_OF(IMASK(point), index) == 1)
				{
					// Insert new leaf here and return.
					new_branch->CHILDREN[bit_value] = new_leaf;
					return GPC_STATUS_SUCCESS;
				}
				// Otherwise, at least one leaf in the earlier subtree does not
				// care about the value of this bit.  Copy all such leaves
				// (and necessary branches) to the other child of the new
				// branch node.
				child = replicate(rhizome, point, index);
				if (child == 0)
				{
					// Memory could not be allocated for the replica.
					// Therefore, we remove the new node from the structure,
					// delete the new node, and pass an indication of failure
					// up the stack.
					*ppoint = point;
					GpcFreeMem(new_branch, RhizomeTag);
					return GPC_STATUS_RESOURCES;
				}
				new_branch->CHILDREN[bit_value] = child;
				// Continue search on newly copied subtree.
				ppoint = &new_branch->CHILDREN[bit_value];
				point = *ppoint;
			}
		}
		// All bits have been examined up to the pivot bit of the current node.
		// If this node is a leaf, then we have found a leaf with which the new
		// leaf has no disagreements over bit values.
		if (point->pivot_bit >= rhizome->keybits)
		{
			// Loop up the chain of godparents until one of the four cases
			// below causes an exit from the subroutine.
			while (1)
			{
				// Case 1:  We have reached the end of the godparent chain.
				if (point == 0)
				{
					// Insert new leaf at this point and return.
					*ppoint = new_leaf;
					return GPC_STATUS_SUCCESS;
				}
				// Case 2:  We discover that we have already inserted this leaf
				// at the appropriate location.  This can happen because two
				// leaves in separate parts of the tree may have a common god-
				// ancestor, and a leaf which is a further god-ancestor of that
				// leaf will be reached more than once.  Since the first
				// occasion inserted the leaf, the second one can return without
				// performing any action.
				if (point == new_leaf)
				{
					return GPC_STATUS_SUCCESS;
				}
				// Compare mask bits of the new leaf to the current leaf.
				sub = 0;
				super = 0;
				for (index = 0; index < rhizome->keybytes; index++)
				{
					sub |= MASK(new_leaf)[index] & ~MASK(point)[index];
					super |= ~MASK(new_leaf)[index] & MASK(point)[index];
				}
				// Case 3:  The new leaf cares about at least one bit that the
				// current leaf does not; and the current leaf does not care
				// about any bits that the new leaf does not; thus, the new leaf
				// should be a godchild of the current leaf.
				if (sub != 0 && super == 0)
				{
					// Update imask field of new leaf; insert into chain;
					// and return.
					for (index0 = 0; index0 < rhizome->keybytes; index0++)
					{
						IMASK(new_leaf)[index0] &= IMASK(point)[index0];
					}
					new_leaf->GODPARENT = point;
					*ppoint = new_leaf;
					return GPC_STATUS_SUCCESS;
				}
				// Case 4:  Either the new leaf has the same value and mask as
				// the current leaf, or there is a hierarchy conflict between
				// the two leaves.  In either case, terminate the insertion
				// process and clean up (in insert() routine) anything done
				// already.
				if (sub != 0 || super == 0)
				{
					return GPC_STATUS_CONFLICT;
				}
				// None of the above cases occurred; thus, the new leaf should
				// be a god-ancestor of the current leaf.  Update the imask
				// field of the current leaf, and continue with godparent of
				// current leaf.
				for (index0 = 0; index0 < rhizome->keybytes; index0++)
				{
					IMASK(point)[index0] &= IMASK(new_leaf)[index0];
				}
				ppoint = &point->GODPARENT;
				point = *ppoint;
			}
		}
		// The current node is not a leaf node.  Thus, we recurse on one or both
		// of the child nodes of the current node.  First, update the fields of
		// the current node to reflect the insertion of the new leaf into the
		// subtree.
		for (index0 = 0; index0 < rhizome->keybytes; index0++)
		{
			VALUE(point)[index0] |= VALUE(new_leaf)[index0];
			MASK(point)[index0] |= MASK(new_leaf)[index0];
			IMASK(point)[index0] &= IMASK(new_leaf)[index0];
		}
		// If the new leaf doesn't care about the value of the pivot bit of the
		// current leaf, then we must recurse on both children.  We can only
		// replace a single recursive call with iteration, so we perform a true
		// recursion in this case, and we recurse on child 1.
		if (BIT_OF(MASK(new_leaf), point->pivot_bit) == 0)
		{
			insert_status =
				node_insert(rhizome, new_leaf, &point->CHILDREN[1],
				point->pivot_bit);
			if (insert_status != GPC_STATUS_SUCCESS)
			{
				return insert_status;
			}
		}
		// Update the values of prev_bit and ppoint to reflect the same
		// conditions that would hold in a recursive call.  The pseudo-recursion
		// is performed on the bit indicated by the value of the pivot bit of
		// the new leaf.  If the new leaf does not care about this bit, then
		// this value will be a 0, and we recursed on child 1 above.  If the new
		// leaf does care about the value of this bit, then we continue down the
		// appropriate path.
		prev_bit = point->pivot_bit;
		ppoint = &point->CHILDREN[BIT_OF(VALUE(new_leaf), point->pivot_bit)];
	}
}

// Remove references to leaf from subtree pointed to by *ppoint.  Update *ppoint
// if necessary due to removal of branch nodes.
//
static void
node_remove(
	Rhizome *rhizome,
	RhizomeNode *leaf,
	RhizomeNode **ppoint)
{
	int pivot_bit, bit_value, index0;
	RhizomeNode *point, *child, *child0, *child1;
	point = *ppoint;
	pivot_bit = point->pivot_bit;
	if (pivot_bit < rhizome->keybits)
	{
		// The current node is a branch node.
		if (BIT_OF(MASK(leaf), pivot_bit) == 1)
		{
			// The leaf to be removed cares about this node's pivot bit;
			// therefore, we need only recurse on one of the current node's
			// children.
			bit_value = BIT_OF(VALUE(leaf), pivot_bit);
			node_remove(rhizome, leaf, &point->CHILDREN[bit_value]);
			child = point->CHILDREN[bit_value];
			if (child != 0 && BIT_OF(MASK(child), pivot_bit) == 1)
			{
				// Some leaf in the same subtree as the removed leaf cares about
				// the value of this node's pivot bit; therefore, this node
				// still has reason to exist.  Update its fields to reflect the
				// change in one of its subtrees.
				child0 = point->CHILDREN[0];
				child1 = point->CHILDREN[1];
				for (index0 = 0; index0 < rhizome->keybytes; index0++)
				{
					VALUE(point)[index0] =
						VALUE(child0)[index0] | VALUE(child1)[index0];
					MASK(point)[index0] =
						MASK(child0)[index0] | MASK(child1)[index0];
					IMASK(point)[index0] =
						IMASK(child0)[index0] & IMASK(child1)[index0];
				}
			}
			else
			{
				// No leaf in the same subtree as the removed leaf cares about
				// the value of this node's pivot bit; therefore, there is no
				// longer any reason for this node to exist.  Have the other
				// subtree take the current node's place in the tree; call
				// remove() to remove the unneeded subtree; and delete the
				// current node.
				*ppoint = point->CHILDREN[1 - bit_value];
				if (child != 0)
				{
					eliminate(rhizome, child);
				}
				GpcFreeMem(point, RhizomeTag);
			}
		}
		else
		{
			// The leaf to be removed does not care about this node's pivot bit;
			// therefore, we must recurse on both of the current node's
			// children.  This node must still be necessary, since we have not
			// removed any leaf which cares about this node's value.  So we
			// update its fields to reflect the change in its two subtrees.
			node_remove(rhizome, leaf, &point->CHILDREN[0]);
			node_remove(rhizome, leaf, &point->CHILDREN[1]);
			child0 = point->CHILDREN[0];
			child1 = point->CHILDREN[1];
			for (index0 = 0; index0 < rhizome->keybytes; index0++)
			{
				VALUE(point)[index0] =
					VALUE(child0)[index0] | VALUE(child1)[index0];
				MASK(point)[index0] =
					MASK(child0)[index0] | MASK(child1)[index0];
				IMASK(point)[index0] =
					IMASK(child0)[index0] & IMASK(child1)[index0];
			}
		}
	}
	else
	{
		// The current node is a leaf node.
		if (point == leaf)
		{
			// The current node is the leaf to be removed; therefore, remove it
			// from chain of godparents.
			*ppoint = leaf->GODPARENT;
		}
		else
		{
			// The current node is not leaf to be removed.  Therefore, if this
			// node has a godparent, then recurse on that godparent.  If this
			// node does not have a godparent, then the to-be-removed leaf
			// either already was removed by a different path, or it was never
			// inserted to begin with.  The latter might be the case if remove()
			// was called from the catch clause of insert().
			if (point->GODPARENT != 0)
			{
				node_remove(rhizome, leaf, &point->GODPARENT);
			}
			// We are now popping back up the recursion stack.  If this node
			// does not have a godparent, or if it did but it does not anymore,
			// then initialize imask to mask; otherwise, copy the godparent's
			// value of imask.  Since the godparent chain follows a strict
			// hierarchy, and since imask is formed by successive conjunction,
			// all leaves in any given godparent chain will have the same value
			// of imask, namely the mask value of the highest god-ancestor.
			if (point->GODPARENT == 0)
			{
				for (index0 = 0; index0 < rhizome->keybytes; index0++)
				{
					IMASK(point)[index0] = MASK(point)[index0];
				}
			}
			else
			{
				for (index0 = 0; index0 < rhizome->keybytes; index0++)
				{
					IMASK(point)[index0] = IMASK(point->GODPARENT)[index0];
				}
			}
		}
	}
}

// Replicate all nodes in a subtree which do not care about the value of
// pivot_bit.
//
static RhizomeNode *
replicate(
	Rhizome *rhizome,
	RhizomeNode *source,
	int pivot_bit)
{
	int index0, current_bit;
	RhizomeNode *new_node, *child0, *child1;
	// If this routine were fully recursive, the following while statement
	// would be an if statement.  However, recursion has been replaced by
	// iteration where possible, so the following code loops until bottoming
	// out when a leaf node is reached.
	while (source->pivot_bit < rhizome->keybits)
	{
		if (BIT_OF(IMASK(source->CHILDREN[0]), pivot_bit) == 0)
		{
			if (BIT_OF(IMASK(source->CHILDREN[1]), pivot_bit) == 0)
			{
				// Both subtrees contain leaves which do not care about the
				// pivot bit; therefore, we may need to make a copy of the
				// current node.  It is not guaranteed that we need to make
				// a copy, since it may be a common leaf in both subtrees
				// that does not care about the pivot bit.  This may happen
				// for a leaf which is a godparent of two leaves, one in each
				// subtree.  Recurse on each child and examine results.
				child0 = replicate(rhizome, source->CHILDREN[0], pivot_bit);
				if (child0 == 0)
				{
					// Memory could not be allocated for the child replica.
					// Therefore, we abort the replication process and pass an
					// indication of failure op the stack.
					return 0;
				}
				child1 = replicate(rhizome, source->CHILDREN[1], pivot_bit);
				if (child1 == 0)
				{
					// Memory could not be allocated for the child replica.
					// Therefore, we abort the replication process, eliminate
					// the other child replica, and pass an indication of
					// failure op the stack.
					eliminate(rhizome, child0);
					return 0;                             // return null pointer
				}
				current_bit = source->pivot_bit;
				if (BIT_OF(MASK(child0), current_bit) == 1)
				{
					if (BIT_OF(MASK(child1), current_bit) == 1)
					{
						// Both replicated child subtrees contain leaves which
						// care about the current node's bit.  Since any node
						// which is a godparent of nodes in both subtrees could
						// not possibly care about the current node's bit, we
						// know that we need to make a copy of the current node.
						NEW_RhizomeNode(&new_node);
						if (new_node == 0)
						{
							// Memory could not be allocated for this new node.
							// Therefore, we have to eliminate both children
							// and pass an indication of failure up the stack.
							eliminate(rhizome, child0);
							eliminate(rhizome, child1);
							return 0;                     // return null pointer
						}
						for (index0 = 0; index0 < rhizome->keybytes; index0++)
						{
							VALUE(new_node)[index0] =
								VALUE(child0)[index0] | VALUE(child1)[index0];
							MASK(new_node)[index0] =
								MASK(child0)[index0] | MASK(child1)[index0];
							IMASK(new_node)[index0] =
								IMASK(child0)[index0] & IMASK(child1)[index0];
						}
						new_node->pivot_bit = current_bit;
						new_node->CHILDREN[0] = child0;
						new_node->CHILDREN[1] = child1;
						return new_node;
					}
					// Child 0's subtree contains a leaf that cares about the
					// current bit; however, child 1's subtree does not.  Thus,
					// all leaves which are in child 1's subtree are also in
					// child 0's subtree, so we only need to keep the latter.
					// We therefore eliminate child 1's subtree, and we return
					// child 0 as the new subtree at this location, since we
					// do not need to create a new branch node here.
					eliminate(rhizome, child1);
					return child0;
				}
				// Child 0's subtree does not contain a leaf that cares about
				// the current node's bit.  Thus, all leaves which are in child
				// 0's subtree are also in child 1's subtree, so we only need to
				// keep the latter.  We therefore eliminate child 0's subtree,
				// and we return child 1 as the new subtree at this location,
				// since we do not need to create a new branch node here.
				eliminate(rhizome, child0);
				return child1;
			}
			// Child 0's subtree contains a leaf which does not care about the
			// pivot bit; however, child 1's subtree does not.  Therefore, we
			// recurse on child 0.  Rather than truly recursing, we update the
			// value of source and iterate once through the while loop.
			source = source->CHILDREN[0];
		}
		else
		{
			// Child 0's subtree does not contain a leaf which does not care
			// about the pivot bit.  Child 1's subtree must contain such a leaf,
			// since the current node's subtree contains such a leaf.  Thus, we
			// recurse on child 1.  Rather than truly recursing, we update the
			// value of source and iterate once through the while loop.
			source = source->CHILDREN[1];
		}
	}
	// A leaf node has been reached.  We now iterate through the godparents of
	// the leaf until we find one which does not care about the pivot bit.
	// Once we find it, we know that all godparents of that leaf also do not
	// care about the pivot bit, since the godparents are arranged in a strict
	// hierarchy.  We thus return the first leaf found which does not care about
	// the value of the pivot bit.
	while (BIT_OF(MASK(source), pivot_bit) == 1)
	{
		source = source->GODPARENT;
	}
	return source;
}

// Eliminate an entire subtree.
//
static void
eliminate(
	Rhizome *rhizome,
	RhizomeNode *point)
{
	RhizomeNode *child;
	// Partial recursion removal.  The while loop takes the place of one of the
	// recursive calls to eliminate().  We eliminate each node and recursively
	// eleminate each subtree under the node.  We do not eliminate leaves, since
	// there is only one copy of each leaf stored in the entire structure.
	while (point->pivot_bit < rhizome->keybits)
	{
		eliminate(rhizome, point->CHILDREN[0]);
		child = point->CHILDREN[1];
		GpcFreeMem(point, RhizomeTag);
		point = child;
	}
}

// Coalesce leaves of subtree into a linked list and eliminate subtree.  This
// routine is called by the destructor so that it can deallocate the leaf nodes
// after the branch nodes are eliminated.
//
static void
coalesce(
	Rhizome *rhizome,
	RhizomeNode **leaf_list,
	RhizomeNode *point)
{
	RhizomeNode *child, *godparent;
	// Partial recursion removal.  This while loop takes the place of one of
	// the recursive calls to coalesce().  This performs an inorder traversal.
	// We delete each branch node after we have visited it, just as in the
	// eliminate() routine.
	while (point->pivot_bit < rhizome->keybits && point->pivot_bit >= 0)
	{
		coalesce(rhizome, leaf_list, point->CHILDREN[0]);
		child = point->CHILDREN[1];
		GpcFreeMem(point, RhizomeTag);
		point = child;
	}
	// Once we have found a leaf, we search through the chain of godparents,
	// adding to the list each leaf node that is not already in the list.
	// A pivot_bit of -1 indicates that the leaf is already in the list.
	// If a leaf is in the list, then so are all of its godparents.
	while (point != 0 && point->pivot_bit >= 0)
	{
		godparent = point->GODPARENT;
		point->pivot_bit = -1;
		point->GODPARENT = *leaf_list;
		*leaf_list = point;
		point = godparent;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\refcnt.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    refcnt.h

Abstract:


Author:

    Edward Buchwalter (v-edbuc)    15-Aug-1996

Revision History:

    Shreedhar Madhavapeddi (ShreeM) 16-April-1999
    Adapted for GPC.
    
--*/

#ifndef REFCNT_H
#define REFCNT_H

//
// Reference Count Control Block
//
//  Elements:
//
//  - Count:            number of outstanding references
//  - Instance:      user supplied context 
//  - UserDeleteFunc:   user supplied delete function
//

#define TAG_CNT 16
#define REF_SIG 0x7841eeee

typedef struct
{
    ULONG   Tag;
    LONG    Count;
} REF_TAG;    

typedef struct  reference_count_control
{
    INT         Count;
    PVOID       Instance;
    VOID        (*DeleteHandler)( PVOID );
#if DBG    
    int         Sig;
    REF_TAG     Tags[TAG_CNT];
    CTELock     Lock;
#endif     
}
REF_CNT, *PREF_CNT;


VOID    
ReferenceInit 
( 
    IN PREF_CNT pRefCnt, 
    PVOID       InstanceHandle, 
    VOID        (*DeleteHandler)( PVOID ) 
);

VOID
ReferenceAdd
(
    IN 	PREF_CNT  pRefCnt
);

VOID
ReferenceAddCount
(
    IN 	PREF_CNT    pRefCnt,
	IN	UINT	    Count
);

PVOID
ReferenceRemove 
(
    IN PREF_CNT  pRefCnt
);

VOID
ReferenceApiTest
( 
	VOID 
);

#if DBG

VOID ReferenceAddDbg(PREF_CNT pRefCnt, ULONG Tag);
VOID ReferenceRemoveDbg(PREF_CNT pRefCnt, ULONG Tag);
VOID ReferenceCheckForZeroRef(PREF_CNT pRefCnt, ULONG Tag);

#define REFADD(Rc, Tag)         ReferenceAddDbg(Rc, Tag)
#define REFDEL(Rc, Tag)         ReferenceRemoveDbg(Rc, Tag)
#define REFZEROCHECK(Rc, Tag)   ReferenceCheckForZeroRef(Rc, Tag)

#else

#define REFADD(Rc, Tag)  ReferenceAdd(Rc);
#define REFDEL(Rc, Tag)  ReferenceRemove(Rc);
#define REFZEROCHECK(Rc, Tag)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\gpc\rhizome.h ===
/*
 *  rhizome.h
 *
 *  author:	John R. Douceur
 *  date:	28 April 1997
 *
 *  This header file defines structures, function prototypes, and macros for
 *  the rhizome database.  The code is object-oriented C, transliterated from
 *  a C++ implementation.
 *
 *  The rhizome is a database that stores patterns containing wildcards.
 *  Each pattern defines a set of keys that it matches; if a pattern contains
 *  N wildcards, then it matches 2^N keys.  Since each pattern can match
 *  multiple keys, it is possible for a given key to match multiple patterns
 *  in the database.  The rhizome requires that all patterns stored therein
 *  have a strict hierarchical interrelationship.  Two patterns may match no
 *  common keys (in which case the patterns are said to be independent), or
 *  one pattern may match all the keys matched by a second pattern as well as
 *  additonal keys (in which case the second pattern is said to be more general
 *  than the first, and the first more specific than the second).  The database
 *  will not accept two patterns which match some keys in common but each of
 *  which also matches additional keys that the other does not.
 *
 *  The database can be searched for patterns that match a given search key.
 *  When the database is searched for a given key, the most specifically
 *  matching pattern is found.  If no patterns in the database match the key,
 *  an appropriate indication is returned.
 *
 *  Because this code is C, rather than C++, it is not possible to hide as
 *  much of the implementation from the client code as one might wish.
 *  Nonetheless, there is an attempt to isolate the client from some of the
 *  implementation details through the use of macros.  Below is described each
 *  of the functions and macros necessary to use the rhizome database.
 *
 */

#ifndef _INC_RHIZOME

#define _INC_RHIZOME

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  There are two basic structures employed: the RhizomeNode and the Rhizome.
 *  Ideally, these would be completely hidden from the client, but the macro
 *  GetReferenceFromPatternHandle requires knowledge of the structure's
 *  definition.  It is strongly urged that the client not directly refer to any
 *  of the fields of either of these structures.  To support the documentation
 *  of the accompanying rhizome.c file, these structures are annotated with
 *  internal comments, but these can be ignored by the reader who wishes only
 *  to understand how to write client code for the rhizome.
 *
 *  The client refers to a pattern by its PatternHandle.  This is typedefed to
 *  a pointer to RhizomeNode, but this fact should be ignored by the client,
 *  since it is an implementation detail.
 *
 */

    //#include <stdlib.h>
    //#include <malloc.h>

struct _RhizomeNode
{
	// This structure is used for both branch nodes and leaf nodes.  The two
	// are distinguished by the value of the pivot_bit field.  For branch
	// nodes, pivot_bit < keybits, and for leaf nodes, pivot_bit == keybits.

	int pivot_bit;            // for branch nodes, bit of key on which to branch
	union
	{
		struct                                           // data for branch node
		{
			struct _RhizomeNode *children[2];  // pointers to children in search
		} branch;
		struct                                             // data for leaf node
		{
			void *reference;               // reference value supplied by client
			struct _RhizomeNode *godparent;   // pointer to more general pattern
		} leaf;
	} udata;
	char cdata[1];            // space for storing value, mask, and imask fields
};

typedef struct _RhizomeNode RhizomeNode;

struct _Rhizome
{
	int keybits;          // number of bits in key
	int keybytes;         // number of bytes in key, calculated from keybits
	RhizomeNode *root;    // root of search trie
};

typedef struct _Rhizome Rhizome;

// The client uses PatternHandle to refer to patterns stored in the database.
typedef RhizomeNode *PatternHandle;

/*
 *  The client interface to the rhizome is provided by five functions and two
 *  macros.  It is expected that the client will first instantiate a database,
 *  either on the stack or the heap, and then insert patterns with corresponding
 *  reference information into the database.  When the client then performs a
 *  search on a key, the client wishes to know which pattern most specifically
 *  matches the key, and it ultimately wants the reference information
 *  associated with the most specifically matching pattern.
 *
 */

// A rhizome may be allocated on the stack simply by declaring a variable of
// type Rhizome.  To allocate it on the heap, the following macro returns a
// pointer to a new Rhizome structure.  If this macro is used, a corresponding
// call to free() must be made to deallocate the structure from the heap.
//
//#define NEW_Rhizome ((Rhizome *)malloc(sizeof(Rhizome)))

#define AllocateRhizome(_r)   GpcAllocMem(&(_r), sizeof(Rhizome), RhizomeTag)
#define FreeRhizome(_r)       GpcFreeMem((_r), RhizomeTag)

// Since this is not C++, the Rhizome structure is not self-constructing;
// therefore, the following constructor code must be called on the Rhizome
// structure after it is allocated.  The argument keybits specifies the size
// (in bits) of each pattern that will be stored in the database.
//
void
constructRhizome(
	Rhizome *rhizome,
	int keybits);

// Since this is not C++, the Rhizome structure is not self-destructing;
// therefore, the following destructor code must be called on the Rhizome
// structure before it is deallocated.  However, if the client code can be
// sure, based upon its usage of the database, that all patterns have been
// removed before the structure is deallocated, then this function is
// unnecessary.
//
void
destructRhizome(
	Rhizome *rhizome);

// Once the Rhizome structure has been allocated and constructed, patterns can
// be inserted into the database.  Each pattern is specified by a value and a
// mask.  Each bit of the mask determines whether the bit position is specified
// or is a wildcard:  A 1 in a mask bit indicates that the value of that bit is
// specified by the pattern; a 0 indicates that the value of that bit is a
// wildcard.  If a mask bit is 1, then the corresponding bit in the value field
// indicates the specified value of that bit.  Value and mask fields are passed
// as arrays of bytes.
//
// The client also specifies a reference value, as a void pointer, that it
// wishes to associate with this pattern.  When the pattern is installed, the
// insertRhizome function returns a pointer to a PatternHandle.  From the
// PatternHandle can be gotten the reference value via the macro
// GetReferenceFromPatternHandle.
//
// If the new pattern conflicts with a pattern already installed in the
// database, meaning that the two patterns match some keys in common but each
// also matches additional keys that the other does not, then the new pattern
// is not inserted, and a value of 0 is returned as the PatternHandle.
//
PatternHandle
insertRhizome(
	Rhizome *rhizome,
	char *value,
	char *mask,
	void *reference,
    ulong *status);

// This function removes a pattern from the rhizome.  The pattern is specified
// by the PatternHandle that was returned by the insertRhizome function.  No
// checks are performed to insure that this is a valid handle, so the client
// must discard the handle after it has called removeRhizome.
//
void
removeRhizome(
	Rhizome *rhizome,
	PatternHandle phandle);

// This function searches the database for the pattern that most specifically
// matches the given key.  The key is passed as an array of bytes.  When the
// most specific match is found, the PatternHandle of that matching pattern is
// returned.  From the PatternHandle can be gotten the reference value via the
// macro GetReferenceFromPatternHandle.  If no pattern in the database is found
// to match the key, then a value of 0 is returned as the PatternHandle.
//
PatternHandle
searchRhizome(
	Rhizome *rhizome,
	char *key);

// To get the client-supplied reference value from a PatternHandle, the
// following macro should be used.  The client should not make assumptions
// about the details of the RhizomeNode structure, nor should it even assume
// that the PatternHandle is a pointer to a RhizomeNode.
//
#define GetReferenceFromPatternHandle(phandle) ((PatternHandle)phandle)->udata.leaf.reference
#define GetKeyPtrFromPatternHandle(_r,phandle) (((PatternHandle)phandle)->cdata)
#define GetMaskPtrFromPatternHandle(_r,phandle) (((PatternHandle)phandle)->cdata + (_r)->keybytes)
#define GetKeySizeBytes(_r) ((_r)->keybytes)

#ifdef __cplusplus
}
#endif

#endif	/* _INC_RHIZOME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\kdext\dsocode.c ===
/****************************** Module Header ******************************\
* Module Name: dsocode.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file contains the dump structure offset (dso) extension. It is
*  included by $(ALT_PROJECT)\dsotable.c which is generated by structo.exe
*
* History:
* 06/17/96 GerardoB Created
* 10/06/98 Rajeshsu edited to use wdbgexts.h
\***************************************************************************/

#define DsoPrint(x) dprintf("%.*s", nIndent, "                      "); dprintf x

#define OFLAG(l)        (1L << ((DWORD)#@l - (DWORD)'a'))
#define EvalExp GetExpression

#define EXACT_MATCH 0xFFFF

int gnIndent = 0; // caller should set and restore this appropriately.

VOID moveBlock(
    PVOID pdst,
    PVOID src,
    DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;
    
    try {
        if (!ReadMemory((DWORD_PTR)src, pdst, size, &Result)) {
            fSuccess = FALSE;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //dprintf(pszMoveException, pszExtName);
        fSuccess = FALSE;
    }

    if (!fSuccess) {
        dprintf("moveBlock(%x, %x, %x) failed.\n", pdst, src, size);
    }
}


/***************************************************************************\
* dsoTerminateString
*
* This is used to "parse" the command line. It null-terminates a space
*  delimited string, returns its size and a pointer to the begining
*  of next string
*
* 06/17/96 Created Gerardob
\***************************************************************************/
LPSTR dsoTerminateString(LPSTR psz, PDWORD pdwSize)
{
    LPSTR pszWork = psz;

    while (*pszWork != 0) {
        if (*pszWork == ' ') {
            *pszWork++ = 0;
            break;
        }
        pszWork++;
    }

    *pdwSize = (DWORD)(pszWork - psz);
    if (*pszWork != 0) {
        (*pdwSize)--;
    }

    while ((*pszWork != 0) && (*pszWork == ' ')) {
        pszWork++;
    }

    return pszWork;
}
/***************************************************************************\
* dsoGetOffset
*
* If the highest order bit of psot->dwOffset is set, then the value is a
*  relative offset from the previous field; otherwise, it is the
*  actual field offset from the beginnig of the structure
*
* 06/20/96 Created Gerardob
\***************************************************************************/
UINT dsoGetOffset (PSTRUCTUREOFFSETSTABLE psot)
{
    if (!(psot->dwOffset & 0x80000000)) {
        return psot->dwOffset;
    } else {
        return ((psot->dwOffset & ~0x80000000) + dsoGetOffset(psot - 1));
    }
}
/***************************************************************************\
* dsoGetSize
*
* The field size is calculated by substracting its offset from the next
*  field's offset. If the struct has unions, several "fields" might have
*  the same offset, or a given table entry (i.e., a field) might have an
*  offset value greater than the offset value for the next entry (a union
*  of two structures).
*
* 06/26/96 Created Gerardob
\***************************************************************************/
UINT dsoGetSize (PSTRUCTUREOFFSETSTABLE psot, DWORD dwOffset)
{
    DWORD dwNextFieldOffset;

    do {
        psot++;
        dwNextFieldOffset = dsoGetOffset(psot);
    } while (dwNextFieldOffset <= dwOffset);

    return dwNextFieldOffset - dwOffset;
}
/***************************************************************************\
* dsoGetStruct
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTURESTABLE dsoGetStruct (LPSTR pszStruct, DWORD dwSize)
{
    PSTRUCTURESTABLE pst = gst;

    /*
     * If dwSize is EXACT_MATCH, we try an exact
     * case sensitive match
     */
    if (dwSize == EXACT_MATCH) {
        while (pst->pszName != NULL) {
            if (!strcmp(pszStruct, pst->pszName)) {
                return pst;
            }
            pst++;
        }
        return NULL;
    }
    /*
     * Try an exact case insensitive match
     */
    while (pst->pszName != NULL) {
        if (!_stricmp(pszStruct, pst->pszName)) {
            return pst;
        }
        pst++;
    }

    /*
     * Partial prefix match
     */
    pst = gst;
    while (pst->pszName != NULL) {
        if (!_strnicmp(pszStruct, pst->pszName, dwSize)) {
            return pst;
        }
        pst++;
    }

    return NULL;

}
/***************************************************************************\
* dsoGetField
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTUREOFFSETSTABLE dosGetField (PSTRUCTUREOFFSETSTABLE psot, LPSTR pszField, DWORD dwSize)
{
    PSTRUCTUREOFFSETSTABLE psotFirst = psot;

    /*
     * try an exact match
     */
    while (psot->pszField != NULL) {
        if (!_stricmp(pszField, psot->pszField)) {
            return psot;
        }
        psot++;
    }

    /*
     * Partial prefix match
     */
    psot = psotFirst;
    while (psot->pszField != NULL) {
        if (!_strnicmp(pszField, psot->pszField, dwSize)) {
            return psot;
        }
        psot++;
    }
    return NULL;

}
/***************************************************************************\
* Idso
*
* !dso StructName [FieldName] [Address]
*
* 06/17/96 Created Gerardob
* 05/12/97 MCostea Added bit field support
\***************************************************************************/

#define NFIELDS 2  // per row.

BOOL Idso(DWORD opts, LPSTR pszCmdLine)
{
    BOOL fOneField = FALSE;
    DWORD dwValue, dwSize, dwBytesRead, dwOffset, dwOffsetNext, dwFieldsPerRow, dwMoveSize;
    DWORD dwBuffer [20];  /* Make sure it has an even number of elemnts and at least 4*/
    const DWORD *pcdwLimit = dwBuffer + (sizeof(dwBuffer) / sizeof(*dwBuffer));
    DWORD *pdwValue;
    LPSTR pszField, pszAddress;
    PBYTE pBufferOffset;
    PSTRUCTURESTABLE pst, pstNested;
    PSTRUCTUREOFFSETSTABLE psot;
    PVOID pAddress = NULL;

    int   cBFStart, cBFLength;   /* for printing bit field values: keeps count of field location */
    char* pTmp;
    DWORD dwMask;
    BOOL  fBF;
    int   cBF;                   /* no of dwords this set of bit-fields spread till now */
    int   cchName;               /* length of field name */
    int   nIndent = gnIndent;    /* amount to indent */

    UNREFERENCED_PARAMETER(opts);

    if (pszCmdLine == NULL) {
        return FALSE;
    }

    /*
     * Find the struct table
     */
    pszField = dsoTerminateString(pszCmdLine, &dwSize);
    pst = dsoGetStruct (pszCmdLine, dwSize);
    if (pst == NULL) {
        DsoPrint(("Structure not found: %s\n", pszCmdLine));
        return TRUE;
    }

    /*
     * Got a table
     */
    psot = pst->psot;

    /*
     * If there is another argument, let's assume a field name follows
     */
    if (*pszField != 0) {
        /*
         * Find the field
         */
        pszAddress = dsoTerminateString(pszField, &dwSize);
        psot = dosGetField (psot, pszField, dwSize);

        /*
         * If it didn't find the field and an address was provided, game over.
         * Otherwise, the second parameter might be the address
         */
        if (psot == NULL) {
            if (*pszAddress != 0) {
                DsoPrint(("Field not found: %s. Struct: %s\n", pszField, pst->pszName));
                return TRUE;
            } else {
                pszAddress = pszField;
                /*
                 * Reset psot since this argument was not a field
                 */
                psot = pst->psot;
            }
        } else {
            fOneField = TRUE;
        }
    
        /*
         * Get the pointer to the struct
         */
        if (*pszAddress != 0) {
            pAddress = (PVOID) EvalExp(pszAddress);
            if (pAddress == NULL) {
                /*
                 * EvalExp displayed the error message, so return silently
                 */
                return TRUE;
            }
        }

    } /* if (*pszField != 0) */


    /*
     * If a field name was specified, dump that field only
     * Otherwise, dump the whole table.
     */
    if (fOneField) {
        /*
         * If no address available, just display the field name and offset
         */
        dwOffset = dsoGetOffset(psot);

        DsoPrint(("Structure %s - Size: %#lx\n", pst->pszName, pst->dwSize));

        /*
         * Try to see if the fields are not nested structures
         */
        if (*psot->pszField >= 'A' && *psot->pszField <= 'Z') {
            /*
             * Probably the field is a nested structure
             */
            if (pstNested = dsoGetStruct (psot->pszField, EXACT_MATCH)) {
                DWORD dwNestedOffset = dsoGetOffset(psot);
                char cmdLine[80];
                DsoPrint(("\nNested at offset %03lx: ", dwNestedOffset));
                if (pAddress) {
                    sprintf(cmdLine, "%s %p", psot->pszField, (PBYTE)pAddress + dwNestedOffset);
                    pTmp = cmdLine;
                }
                else {
                    pTmp = psot->pszField;
                }
                return Idso(opts, pTmp);
            }
        }

        DsoPrint(("Field: %s - Offset: %#lx\n", psot->pszField, dwOffset));
        if (pAddress == NULL) {
            return TRUE;
        }

        /*
         * Printing field value
         */

        /*123456789 1*/
        DsoPrint(("Address   Value\n"));

        dwBytesRead = 0;
        dwSize = dsoGetSize(psot, dwOffset);
        /*
         * Print 4 DWORDS per row; one row per loop
         */

        do { /* while ((int)dwSize > 0) */

            /*
             * Read values for next row
             */
            if (4 * sizeof(DWORD) >= dwSize) {
                dwMoveSize = dwSize;
            } else {
                dwMoveSize = 4 * sizeof(DWORD);
            }
            moveBlock(dwBuffer, (PBYTE)pAddress + dwOffset + dwBytesRead, dwMoveSize);
            pBufferOffset = (PBYTE)dwBuffer;

            /*
             * Print the address
             */
            DsoPrint(("%p  ", (DWORD_PTR)((PBYTE)pAddress + dwOffset + dwBytesRead)));
            /*
             * Keep track of bytes read (dwBytesRead) and bytes
             *  remaining to be read (dwSize)
             */
            dwBytesRead += dwMoveSize;
            dwSize -= dwMoveSize;
            /*
             * Print the values, one dword at the time
             */
            while (dwMoveSize >= sizeof(DWORD)) {
                DsoPrint(("%08lx ", *((DWORD *)pBufferOffset)));
                pBufferOffset += sizeof(DWORD);
                dwMoveSize -= sizeof(DWORD);
            }
            /*
             * If less than a DWORD left, zero extend and print a DWORD
             */
            if (dwMoveSize > 0) {
                dwValue = 0;
                memcpy(&dwValue, pBufferOffset, dwMoveSize);
                DsoPrint(("%0*lx", dwMoveSize * 2, dwValue));
            }
            dprintf("\n");

        } while ((int)dwSize > 0);

        return TRUE;

    } /* if (fOneField) */


    /*
     * Printing all the fields.
     */
    if (pAddress != NULL) {
        DsoPrint(("Structure %s %#lx - Size: %#lx", pst->pszName, pAddress, pst->dwSize));
    } else {
        DsoPrint(("Structure %s - Size: %#lx", pst->pszName, pst->dwSize));
    }

    dwOffset = 0;
    pBufferOffset = NULL; /* Forces the local buffer to be loaded */
    dwFieldsPerRow = NFIELDS;
    cBFStart = 0;
    cBF = 0;

    /*
     * Loop through all fields in the table. Print one field per loop
     */

    while (psot->pszField != NULL) {

        /*
         * Print two fields per row
         */
        if (dwFieldsPerRow == NFIELDS) {
            dprintf("\n");
            dwFieldsPerRow = 1;
            cchName = 24 - gnIndent/NFIELDS;
            nIndent = gnIndent;
            // Print("cchName = %d\n", cchName);
        } else {
            dwFieldsPerRow++;
            cchName = 24 - (gnIndent + 1)/NFIELDS;
            nIndent = 0;
            // Print("cchName = %d\n", cchName);
        }

        /*
         * -v functionality
         * Try to see if the fields are not nested structures
         * The naming convention assigns Uppercase names for them
         */
        if (opts & OFLAG(v)) {
            if (*psot->pszField >= 'A' && *psot->pszField <= 'Z') {
                /*
                 * Probably the field is a nested structure
                 */
                if (pstNested = dsoGetStruct (psot->pszField, EXACT_MATCH)) {
                    DWORD dwNestedOffset = dsoGetOffset(psot);
                    char cmdLine[80];
                    DsoPrint(("\nNested at offset %03lx: ", dwNestedOffset));
                    if (pAddress) {
                        sprintf(cmdLine, "%s %p", psot->pszField, (PBYTE)pAddress + dwNestedOffset);
                        pTmp = cmdLine;
                    }
                    else {
                        pTmp = psot->pszField;
                    }
                    Idso(opts, pTmp);
                    dwOffsetNext = dsoGetOffset(psot + 1);
                    dwFieldsPerRow = 0;
                    goto Continue;
                }
            }
        }

        /*
         * If no address provided, Print field name(s) and offset(s) only
         */
        if (pAddress == NULL) {
            DsoPrint(("%03lx %-*.*s", dsoGetOffset(psot),
                      cchName, cchName, psot->pszField));
        } else {
            /*
             * Printing offsets and values.
             *
             * Get the size of the value and max it to one DWORD
             */
            dwOffsetNext = dsoGetOffset(psot + 1);
            if (dwOffsetNext > dwOffset) {
                dwSize = dwOffsetNext - dwOffset;
            } else {
                dwSize = dsoGetSize(psot, dwOffset);
            }
            if (dwSize > sizeof(DWORD)) {
                dwSize = sizeof(DWORD);
            }

            /*
             * Get a pointer to the value in the local buffer
             * If the value is not in the buffer, load it
             */
            pdwValue = (PDWORD)(pBufferOffset + dwOffset);
            if ((pdwValue < dwBuffer) || (pdwValue + dwSize > pcdwLimit)) {
                pBufferOffset = (PBYTE)dwBuffer - dwOffset;
                pdwValue = dwBuffer;

                if (sizeof(dwBuffer) >= pst->dwSize - dwOffset) {
                    dwMoveSize = pst->dwSize - dwOffset;
                } else {
                    dwMoveSize = sizeof(dwBuffer);
                }
                moveBlock((PBYTE)dwBuffer, (PBYTE)pAddress + dwOffset, dwMoveSize);

            }

            /*
             * Copy the value and print it
             */
            dwValue = 0; /* in case size < sizeof(DWORD) */
            memcpy(&dwValue, pdwValue, dwSize);

            /*
             * Deal with bit fields
             */
            fBF = FALSE;
            pTmp = psot->pszField;
            while (*pTmp) {
                if (*pTmp++ == ':') {

                    fBF = TRUE;
                    while ((*pTmp == ' ') || (*pTmp == '\t')) {     /* skip white spaces */
                        ++pTmp;
                    }
                    cBFLength = *(pTmp++) - '0';      /* now get the bit size, maybe 2 digits */
                    if ((*pTmp >= '0') && (*pTmp <= '9'))
                        cBFLength = cBFLength*10 + (*pTmp - '0');

                    if (cBFStart == 0) {
                        DsoPrint(("(%03lx) %08lx BIT FIELDS\n", dwOffset, dwValue));
                        dwFieldsPerRow = 1;
                    }
                    else if (cBFStart >= 8*sizeof(DWORD)) {   /* check for multi-dword fields */
                        cBF ++;
                        cBFStart %= 8*sizeof(DWORD);
                    }

                    dwMask = (1L << cBFLength) - 1;
                    dwMask <<= cBFStart;
                    /* print byte offset and the bit offset inside it */
                    DsoPrint(("(%03lx) (%d)   %-2x %-*.*s", dwOffset + cBF*sizeof(DWORD) + cBFStart/8, cBFStart & 7,
                           (dwMask & dwValue) >> cBFStart,
                            cchName, cchName, psot->pszField));
                    cBFStart += cBFLength;
                    cBFLength = 0;
                    break;
                }
            }
            if (!fBF) {
                int width = 8;
                if (dwSize == sizeof(BYTE)) {
                    dwValue &= 0xff;
                    width = 2;
                } else if (dwSize == sizeof(WORD)) {
                    dwValue &= 0xffff;
                    width = 4;
                }
                DsoPrint(("(%03lx) %*s%0*lx %-*.*s", dwOffset, 8 - width, "", width, dwValue,
                          cchName, cchName, psot->pszField));
                cBFStart = 0;
                cBF = 0;
            }

        } /* if (pAddress == NULL) */

Continue:
        dwOffset = dwOffsetNext;
        psot++;

    } /* while (psot->pszField != NULL) */

    dprintf("\n");

    return TRUE;
}

DECLARE_API( gpcdso )
{
    LPSTR pszCmdLine; 
    DWORD opts = 0;

    pszCmdLine = (LPSTR) args;
    Idso(opts, pszCmdLine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\kdext\kdgpc.c ===
#include "precomp.h"

//
// The ExtensionApis is a mandatory global variable, which should
// have this exact name. All definitions of callbacks to the windbg
// are using this variable.
//

WINDBG_EXTENSION_APIS ExtensionApis;
USHORT  g_MajorVersion;
USHORT  g_MinorVersion;


//
// Prototypes
//
VOID
PrintCf(
        PCF_BLOCK       pCf
        );

VOID
PrintClient(
        PCLIENT_BLOCK   pClient
        );

VOID
PrintBlob(
        PBLOB_BLOCK     pBlob
        );

VOID
PrintPattern(
        PPATTERN_BLOCK  pPattern
        );

VOID
PrintStat(
                PGPC_STAT               pStat
        );

BOOL
GetDwordExpr(
             char* expr,
             DWORD* pdwAddress,
             DWORD* pValue
             );


//
// API's
//

LPEXT_API_VERSION
ExtensionApiVersion(
    void
    )

/*++

Function Description:

    Windbg calls this function to match between the version of windbg and the
    extension. If the versions doesn't match, windbg will not load the extension.

--*/

{
    static EXT_API_VERSION ApiVersion =
        { 3, 5, EXT_API_VERSION_NUMBER, 0 };

    return &ApiVersion;
}


void
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS  lpExtensionApis,
    USHORT                  MajorVersion,
    USHORT                  MinorVersion
    )

/*++

Function Description:

    When windbg loads the extension, it first call this function. You can
    perform various intialization here.

Arguments:

    lpExtensionApis - A structure that contains the callbacks to functions that
        I can use to do standard operation. I must store this in a global
        variable called 'ExtensionApis'.

    MajorVersion - Indicates if target machine is running checked build or free.
        0x0C - Checked build.
        0x0F - Free build.

    MinorVersion - The Windows NT build number (for example, 1381 for NT4).

--*/

{
    ExtensionApis = *lpExtensionApis;

    g_MajorVersion = MajorVersion;
    g_MinorVersion = MinorVersion;
}


DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf("KDGPC: %s Extension dll for Build %d debugging %s kernel for Build %d\n",
            DebuggerType,
            VER_PRODUCTBUILD,
            g_MajorVersion == 0x0c ? "Checked" : "Free",
            g_MinorVersion
            );
}




VOID
CheckVersion(
    VOID
    )

/*++

Function Description:

    This function is called before every command. It gives the extension
    a chance to compare between the versions of the target and the extension.
    In this demo, I don't do much with that.

--*/

{
#if DBG
    if ((g_MajorVersion != 0x0c) || (g_MinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                (VER_PRODUCTBUILD, g_MinorVersion, g_MajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
//    if ((g_MajorVersion != 0x0f) || (g_MinorVersion != VER_PRODUCTBUILD)) {
//        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
//                (VER_PRODUCTBUILD, g_MinorVersion, (g_MajorVersion==0x0f) ? "Free" : "Checked" );
//    }
#endif
}



DECLARE_API( help )

/*++

Function Description:

    This is the implementation of the '!help' extension command. It lists
    all available command in this debugger extension.

--*/

{
    dprintf(
        "help      - shows this list\n"
        "cf        - print the CF list\n"
        "client [addr]  - print the client block"
        "blob [addr]  - print the blob list for the QoS CF, or the specified blob\n"
        "pattern [addr] - print the pattern block\n"
        "stat      - print the statistics"
        );
}


DECLARE_API( cf )

/*++

Function Description:

    This function prints all the CF in the list. If args is specified, only that CF
    will be printed. Currently these are supported:

    0 - for CF_QOS

--*/

{
    DWORD                       TargetGlobalData;
    GLOBAL_BLOCK        LocalGlobalData;
    PLIST_ENTRY         pHead, pEntry;
    DWORD                       TargetCf;
    CF_BLOCK            LocalCf;
    ULONG           result;
    ULONG                       CfIndex = (-1);
    char                        *lerr;

    TargetGlobalData = GetExpression( "MSGPC!glData" );

    if( !TargetGlobalData )
    {
        dprintf( "Can't find the address of 'glData'" );
        return;
    }

    //

    if ( !ReadMemory(
                     TargetGlobalData,
                     &LocalGlobalData,
                     sizeof(LocalGlobalData),
                     &result
                     )) {

        dprintf( "Can't read memory from 0x%x", TargetGlobalData );
        return;
    }

    //
    //
    //

    if ( args )
        CfIndex = strtol( args, &lerr, 10 );

    pHead = (PLIST_ENTRY)((PUCHAR)TargetGlobalData + FIELD_OFFSET(GLOBAL_BLOCK, CfList));
    pEntry = LocalGlobalData.CfList.Flink;

    while ( pHead != pEntry ) {

        TargetCf = (DWORD)CONTAINING_RECORD( pEntry, CF_BLOCK, Linkage );

        if ( !ReadMemory( TargetCf,
                          &LocalCf,
                          sizeof(LocalCf),
                          &result ) ) {

            dprintf( "Can't read memory from 0x%x", TargetCf );

        } else if ( CfIndex == (-1) || LocalCf.AssignedIndex == CfIndex ) {

            PrintCf( &LocalCf );
        }

        pEntry = LocalCf.Linkage.Flink;

    }

}



DECLARE_API( blob )

/*++

Function Description:

    This function prints all the blob in the QoS CF list.
    If args is specified it is used as the blob addr.

--*/

{
    DWORD                       TargetGlobalData;
    GLOBAL_BLOCK        LocalGlobalData;
    PLIST_ENTRY         pHead, pEntry;
    DWORD                       TargetCf;
    CF_BLOCK            LocalCf;
    ULONG           result;
    ULONG                       TargetBlob = 0;
    BLOB_BLOCK          LocalBlob;
    char                        *lerr;

    if ( args )
        TargetBlob = GetExpression( args );

    if (TargetBlob) {

        if ( !ReadMemory( TargetBlob,
                          &LocalBlob,
                          sizeof(LocalBlob),
                          &result ) ) {

            dprintf( "Can't read memory from 0x%x", TargetBlob );

        } else {

            PrintBlob( &LocalBlob );
        }
        return;
    }

#if 0
    //
    // scan the blob list for the QoS CF
    //

    TargetGlobalData = GetExpression( "MSGPC!glData" );

    if( !TargetGlobalData )
    {
        dprintf( "Can't find the address of 'glData'" );
        return;
    }

    //

    if ( !ReadMemory(
                     TargetGlobalData,
                     &LocalGlobalData,
                     sizeof(LocalGlobalData),
                     &result
                     )) {

        dprintf( "Can't read memory from 0x%x", TargetGlobalData );
        return;
    }

    //
    //
    //

    pHead = (PLIST_ENTRY)((PUCHAR)TargetGlobalData + FIELD_OFFSET(GLOBAL_BLOCK, CfList));
    pEntry = LocalGlobalData.CfList.Flink;

    while ( pHead != pEntry ) {

        TargetCf = (DWORD)CONTAINING_RECORD( pEntry, CF_BLOCK, Linkage );

        if ( !ReadMemory( TargetCf,
                          &LocalCf,
                          sizeof(LocalCf),
                          &result ) ) {

            dprintf( "Can't read memory from 0x%x", TargetCf );

        } else if ( CfIndex == (-1) || LocalCf.AssignedIndex == CfIndex ) {

            PrintCf( &LocalCf );
        }

        pEntry = LocalCf.Linkage.Flink;

    }
#endif

}



DECLARE_API( client )

/*++

Function Description:

    This function prints either the client addr or all the clients

--*/

{
    DWORD                       TargetGlobalData;
    GLOBAL_BLOCK        LocalGlobalData;
    PLIST_ENTRY         pHead, pEntry;
    PLIST_ENTRY         pHead1, pEntry1;
    DWORD                       TargetCf;
    CF_BLOCK            LocalCf;
    ULONG           result;
    ULONG                       TargetClient = 0;
    CLIENT_BLOCK        LocalClient;
    int                         i = 0;

    if ( args )
        TargetClient = GetExpression( args );

    if (TargetClient) {

        if ( !ReadMemory( TargetClient,
                          &LocalClient,
                          sizeof(LocalClient),
                          &result ) ) {

            dprintf( "Can't read memory from 0x%x", TargetClient );

        } else {

            dprintf( "Client = 0x%X: ", TargetClient );
            PrintClient( &LocalClient );
        }
        return;
    }

    //
    // scan the client list for the QoS CF
    //

    TargetGlobalData = GetExpression( "MSGPC!glData" );

    if( !TargetGlobalData )
    {
        dprintf( "Can't find the address of 'glData'" );
        return;
    }

    //

    if ( !ReadMemory(
                     TargetGlobalData,
                     &LocalGlobalData,
                     sizeof(LocalGlobalData),
                     &result
                     )) {

        dprintf( "Can't read memory from 0x%x", TargetGlobalData );
        return;
    }

    //
    //
    //

    pHead = (PLIST_ENTRY)((PUCHAR)TargetGlobalData + FIELD_OFFSET(GLOBAL_BLOCK, CfList));
    pEntry = LocalGlobalData.CfList.Flink;

    while ( pHead != pEntry ) {

        TargetCf = (DWORD)CONTAINING_RECORD( pEntry, CF_BLOCK, Linkage );

        if ( !ReadMemory( TargetCf,
                          &LocalCf,
                          sizeof(LocalCf),
                          &result ) ) {

            dprintf( "Can't read memory from 0x%x", TargetCf );
            return;

        } else {

            dprintf( "\nClients for CF=%d\n", LocalCf.AssignedIndex );

            pHead1 = (PLIST_ENTRY)((PUCHAR)TargetCf + FIELD_OFFSET(CF_BLOCK, ClientList));
            pEntry1 = LocalCf.ClientList.Flink;

            while ( pHead1 != pEntry1 ) {

                TargetClient = (DWORD)CONTAINING_RECORD( pEntry1, CLIENT_BLOCK, ClientLinkage );

                if ( !ReadMemory( TargetClient,
                                  &LocalClient,
                                  sizeof(LocalClient),
                                  &result ) ) {

                    dprintf( "Can't read memory from 0x%x", TargetClient );
                    return;

                } else {

                    dprintf( "Client [%d] = 0x%X: ", i++, TargetClient );
                    PrintClient( &LocalClient );
                }
                pEntry1 = LocalClient.ClientLinkage.Flink;
            }
        }

        pEntry = LocalCf.Linkage.Flink;

    }
}




BOOL
GetDwordExpr(
             char* expr,
             DWORD* pdwAddress,
             DWORD* pValue
             )

/*++

Function Description:

    This function gets as an argument a string which represent a DWORD
    variable. The funciton finds its address (if the symbols are loaded),
    and then grab the dword value from that address.

Arguments:

    expr [in] - A null terminated string, represent the variable.

    pdwAddress [out, optional] - Optinally return the address of the variable.

    pValue [out] - returns the value of the DWORD variable.

Return Value:

    true/false, if the function succeeded or failed.

--*/

{
    ULONG result;
    DWORD dwAddress;

    if( pdwAddress )
        *pdwAddress = 0;
    *pValue = 0;

    dwAddress = GetExpression( expr );
    if( !dwAddress )
        return FALSE;

    if( !ReadMemory( dwAddress, pValue, sizeof(DWORD), &result ) )
        return FALSE;

    if( pdwAddress )
        *pdwAddress = dwAddress;

    return TRUE;
}




VOID
PrintCf(
    PCF_BLOCK   pCf
    )

/*++

Function Description:

    This function gets as an argument a CF block pointer,
    and does a pretty print.

Arguments:

    pCf - pointer to CF block

Return Value:

    none

--*/

{
    int                 i;

    dprintf( "  Linkage = { 0x%X, 0x%X }\n", pCf->Linkage.Flink, pCf->Linkage.Blink );
    dprintf( "  ClientList = { 0x%X, 0x%X }\n",
             pCf->ClientList.Flink,
             pCf->ClientList.Blink );
    dprintf( "  BlobList = { 0x%X, 0x%X }\n",
             pCf->BlobList.Flink,
             pCf->BlobList.Blink );
    dprintf( "  NumberOfClients = %d\n", pCf->NumberOfClients );
    dprintf( "  AssignedIndex = 0x%x\n", pCf->AssignedIndex );
    dprintf( "  ClientIndexes = %d\n", pCf->ClientIndexes );
    dprintf( "  MaxPriorities = %d\n", pCf->MaxPriorities );
    dprintf( "  arpGenericDb = 0x%X\n", &pCf->arpGenericDb );

    for ( i = GPC_PROTOCOL_TEMPLATE_IP; i < GPC_PROTOCOL_TEMPLATE_MAX; i++ ) {

        dprintf( "     [%d] = %d\n", i, (ULONG)pCf->arpGenericDb[i] );

    }
}




VOID
PrintBlob(
    PBLOB_BLOCK pBlob
    )

/*++

Function Description:

    This function gets as an argument a BLOB block pointer,
    and does a pretty print.

Arguments:

    pBlob - pointer to BLOB block

Return Value:

    none

--*/

{
    int                 i;

    dprintf( "  ObjectType = %d\n", pBlob->ObjectType );
    dprintf( "  ClientLinkage = { 0x%X, 0x%X }\n",
             pBlob->ClientLinkage.Flink,
             pBlob->ClientLinkage.Blink );
    dprintf( "  PatternList = { 0x%X, 0x%X }\n",
             pBlob->PatternList.Flink,
             pBlob->PatternList.Blink );
    dprintf( "  CfLinkage = { 0x%X, 0x%X }\n",
             pBlob->CfLinkage.Flink,
             pBlob->CfLinkage.Blink );
    dprintf( "  RefCount = %d\n", pBlob->RefCount );
    dprintf( "  State = 0x%x\n", pBlob->State );

    dprintf( "  arClientCtx[]:\n" );
    for ( i = 0; i < MAX_CLIENTS_CTX_PER_BLOB; i++ ) {

        dprintf( "     [%d] = 0x%x\n", i, (ULONG)pBlob->arClientCtx[i] );

    }


}




VOID
PrintClient(
    PCLIENT_BLOCK       pClient
    )

/*++

Function Description:

    This function gets as an argument a CLIENT block pointer,
    and does a pretty print.

Arguments:

    pClient - pointer to CLIENT block

Return Value:

    none

--*/

{
    DWORD                       TargetCf;
    CF_BLOCK            LocalCf;
    ULONG           result;

    TargetCf = (DWORD)pClient->pCfBlock;

    if ( !ReadMemory( TargetCf,
                      &LocalCf,
                      sizeof(LocalCf),
                      &result ) ) {

        dprintf( "Can't read memory from 0x%x", TargetCf );
        return;
    }

    if (pClient->Flags & GPC_FLAGS_USERMODE_CLIENT) {
        dprintf( "  User Mode Client\n" );
    } else {
        if (GetExpression( "PSCHED!AddCfInfoNotify" ) == (DWORD)pClient->FuncList.ClAddCfInfoNotifyHandler
            && (LocalCf.AssignedIndex == GPC_CF_QOS || LocalCf.AssignedIndex == GPC_CF_CLASS_MAP)) {
            dprintf( "  Probably PSCHED client\n" );
        } else if (GetExpression( "TCPIP!GPCcfInfoAddNotify" ) == (DWORD)pClient->FuncList.ClAddCfInfoNotifyHandler
            && (LocalCf.AssignedIndex == GPC_CF_QOS || LocalCf.AssignedIndex == GPC_CF_IPSEC)) {
            dprintf( "  Probably TCPIP client\n" );
        } else if (GetExpression( "ATMARPC!AtmArpGpcAddCfInfoComplete" ) == (DWORD)pClient->FuncList.ClAddCfInfoNotifyHandler
            && (LocalCf.AssignedIndex == GPC_CF_QOS)) {
            dprintf( "  Probably ATMARPC client\n" );
        } else if (0 == (DWORD)pClient->FuncList.ClAddCfInfoNotifyHandler
            && (LocalCf.AssignedIndex == GPC_CF_IPSEC)) {
            dprintf( "  Probably IPSEC client\n" );
        } else {
            dprintf( "  Unknown client\n" );
        }
    }

    dprintf( "  ObjectType = %d\n", pClient->ObjectType );
    dprintf( "  ClientLinkage = { 0x%X, 0x%X }\n",
             pClient->ClientLinkage.Flink,
             pClient->ClientLinkage.Blink );
    dprintf( "  BlobList = { 0x%X, 0x%X }\n",
             pClient->BlobList.Flink,
             pClient->BlobList.Blink );
    dprintf( "  Parrent CF = 0x%X\n", pClient->pCfBlock );
    dprintf( "  Client Ctx = 0x%X\n", pClient->ClientCtx );
    dprintf( "  AssignedIndex = %d\n", pClient->AssignedIndex );
    dprintf( "  Flags = 0x%X %s %s \n",
             pClient->Flags,
             (pClient->Flags & GPC_FLAGS_USERMODE_CLIENT)?"UserMode":"" ,
             (pClient->Flags & GPC_FLAGS_FRAGMENT)?"Handle Fragments":""
             );
    dprintf( "  State = %d\n", pClient->State );
    dprintf( "  RefCount = %d\n", pClient->RefCount );
    dprintf( "  File Object = 0x%X\n", pClient->pFileObject );
    dprintf( "  Client Handle = %d\n", pClient->ClHandle );

    dprintf( "  Client Handlers:\n" );
    dprintf( "    Add Notify = 0x%X\n", pClient->FuncList.ClAddCfInfoCompleteHandler );
    dprintf( "    Add Complete = 0x%X\n", pClient->FuncList.ClAddCfInfoNotifyHandler );
    dprintf( "    Modify Notify = 0x%X\n", pClient->FuncList.ClModifyCfInfoCompleteHandler );
    dprintf( "    Modify Complete = 0x%X\n", pClient->FuncList.ClModifyCfInfoNotifyHandler );
    dprintf( "    Remove Notify = 0x%X\n", pClient->FuncList.ClRemoveCfInfoCompleteHandler );
    dprintf( "    Remove Complete = 0x%X\n", pClient->FuncList.ClRemoveCfInfoNotifyHandler );
    dprintf( "    Get CfInfo Name = 0x%X\n", pClient->FuncList.ClGetCfInfoName );

}




VOID
PrintPattern(
    PPATTERN_BLOCK      pPattern
    )

/*++

Function Description:

    This function gets as an argument a PATTERN block pointer,
    and does a pretty print.

Arguments:

    pPattern - pointer to PATTERN block

Return Value:

    none

--*/

{
    int                 i;

    dprintf( "  ObjectType = %d\n", pPattern->ObjectType );
    dprintf( "  BlobLinkage[]:\n" );
    for ( i = 0; i < GPC_CF_MAX; i++ ) {

        dprintf( "     [%d] = {0x%X,0x%X}\n", i,
                 pPattern->BlobLinkage[i].Flink,
                 pPattern->BlobLinkage[i].Blink
                 );
    }
    dprintf( "  TimerLinkage = { 0x%X, 0x%X }\n",
             pPattern->TimerLinkage.Flink,
             pPattern->TimerLinkage.Blink );
    dprintf( "  Owner client = 0x%X\n", pPattern->pClientBlock );
    dprintf( "  Auto client = 0x%X\n", pPattern->pAutoClient );
    dprintf( "  Classification block = 0x%X\n", pPattern->pClassificationBlock );
    dprintf( "  Ref Count = %d\n", pPattern->RefCount );
    dprintf( "  Client Ref Count = %d\n", pPattern->ClientRefCount );
    dprintf( "  Flags = 0x%x %s %s \n", pPattern->Flags ,
             (pPattern->Flags & PATTERN_SPECIFIC)?"Specific":"",
             (pPattern->Flags & PATTERN_AUTO)?"Auto":""
             );
    dprintf( "  Priority = %d\n", pPattern->Priority );
    dprintf( "  Client handle = 0x%x\n", pPattern->ClHandle );
    dprintf( "  Protocol = 0x%x\n", pPattern->ProtocolTemplate );
}




VOID
PrintStat(
    PGPC_STAT   pStat
    )

/*++

Function Description:

    Prints the GPC stat structure

Arguments:

    pStat - pointer to GPC stat strucutre

Return Value:

    none

--*/

{
    PPROTOCOL_STAT  pProtocol;
    int                         i;

    dprintf( "Created CF = %d\n", pStat->CreatedCf );
    dprintf( "Deleted Cf = %d\n", pStat->DeletedCf );
    dprintf( "Rejected Cf = %d\n", pStat->RejectedCf );
    dprintf( "Current Cf = %d\n", pStat->CurrentCf );
    dprintf( "Inserted HF= %d\n", pStat->InsertedHF );
    dprintf( "Removed HF= %d\n", pStat->RemovedHF );

    for( i = 0; i < GPC_CF_MAX; i++) {

        dprintf( "CF[%d] info:\n", i);
        dprintf( "  Created Blobs = %d\n", pStat->CfStat[i].CreatedBlobs );
        dprintf( "  Modified Blobs = %d\n", pStat->CfStat[i].ModifiedBlobs );
        dprintf( "  Deleted Blobs = %d\n", pStat->CfStat[i].DeletedBlobs );
        dprintf( "  Rejected Blobs = %d\n", pStat->CfStat[i].RejectedBlobs );
        dprintf( "  Current Blobs = %d\n", pStat->CfStat[i].CurrentBlobs );
        dprintf( "  Deref Blobs to zero = %d\n", pStat->CfStat[i].DerefBlobs2Zero );
        dprintf( "\n" );
    }

    pProtocol = &pStat->ProtocolStat[GPC_PROTOCOL_TEMPLATE_IP];
    dprintf( "IP stats:   Specific Patterns   Generic Patterns   Auto Patterns\n" );
    dprintf( "  Created  =       %8d           %8d          %8d\n",
             pProtocol->CreatedSp, pProtocol->CreatedGp, pProtocol->CreatedAp );
    dprintf( "  Deleted  =       %8d           %8d          %8d\n",
             pProtocol->DeletedSp, pProtocol->DeletedGp, pProtocol->DeletedAp );
    dprintf( "  Rejected =       %8d           %8d          %8d\n",
             pProtocol->RejectedSp, pProtocol->RejectedGp, pProtocol->RejectedAp );
    dprintf( "  Current  =       %8d           %8d          %8d\n",
             pProtocol->CurrentSp, pProtocol->CurrentGp, pProtocol->CurrentAp );
    dprintf( "\n" );
    dprintf( "  Classification Requests = %d\n", pProtocol->ClassificationRequests );
    dprintf( "  Patterns Classified = %d\n", pProtocol->PatternsClassified );
    dprintf( "  Packets Classified = %d\n", pProtocol->PacketsClassified );
    dprintf( "\n" );
    dprintf( "  Deref Patterns to zero = %d\n", pProtocol->DerefPattern2Zero );
    dprintf( "  First Frags Count = %d\n", pProtocol->FirstFragsCount );
    dprintf( "  Last Frags Count = %d\n", pProtocol->LastFragsCount );
    dprintf( "\n" );
    dprintf( "  Inserted PH= %d\n", pProtocol->InsertedPH );
    dprintf( "  Removed PH= %d\n", pProtocol->RemovedPH );
    dprintf( "  Inserted Rz= %d\n", pProtocol->InsertedRz );
    dprintf( "  Removed Rz= %d\n", pProtocol->RemovedRz );
    dprintf( "  Inserted CH= %d\n", pProtocol->InsertedCH );
    dprintf( "  Removed CH= %d\n", pProtocol->RemovedCH );

}




DECLARE_API( pattern )

/*++

Function Description:

    This function prints all the pattern in the QoS CF list.
    If args is specified it is used as the blob addr.

--*/

{
    DWORD                       TargetGlobalData;
    GLOBAL_BLOCK        LocalGlobalData;
    PLIST_ENTRY         pHead, pEntry;
    DWORD                       TargetCf;
    CF_BLOCK            LocalCf;
    ULONG           result;
    ULONG                       TargetPattern = 0;
    PATTERN_BLOCK       LocalPattern;
    char                        *lerr;

    if ( args )
        TargetPattern = GetExpression( args );

    if (TargetPattern) {

        if ( !ReadMemory( TargetPattern,
                          &LocalPattern,
                          sizeof(LocalPattern),
                          &result ) ) {

            dprintf( "Can't read memory from 0x%x", TargetPattern );

        } else {

            PrintPattern( &LocalPattern );
        }
        return;
    }

#if 0
    //
    // scan the blob list for the QoS CF
    //

    TargetGlobalData = GetExpression( "MSGPC!glData" );

    if( !TargetGlobalData )
    {
        dprintf( "Can't find the address of 'glData'" );
        return;
    }

    //

    if ( !ReadMemory(
                     TargetGlobalData,
                     &LocalGlobalData,
                     sizeof(LocalGlobalData),
                     &result
                     )) {

        dprintf( "Can't read memory from 0x%x", TargetGlobalData );
        return;
    }

    //
    //
    //

    pHead = (PLIST_ENTRY)((PUCHAR)TargetGlobalData + FIELD_OFFSET(GLOBAL_BLOCK, CfList));
    pEntry = LocalGlobalData.CfList.Flink;

    while ( pHead != pEntry ) {

        TargetCf = (DWORD)CONTAINING_RECORD( pEntry, CF_BLOCK, Linkage );

        if ( !ReadMemory( TargetCf,
                          &LocalCf,
                          sizeof(LocalCf),
                          &result ) ) {

            dprintf( "Can't read memory from 0x%x", TargetCf );

        } else if ( CfIndex == (-1) || LocalCf.AssignedIndex == CfIndex ) {

            PrintCf( &LocalCf );
        }

        pEntry = LocalCf.Linkage.Flink;

    }
#endif

}




DECLARE_API( stat )

/*++

Function Description:

    This function prints all the stat structure

--*/

{
    DWORD                       TargetStat;
    GPC_STAT            LocalStat;
    PLIST_ENTRY         pHead, pEntry;
    DWORD                       TargetCf;
    CF_BLOCK            LocalCf;
    ULONG           result;

    TargetStat = GetExpression( "MSGPC!glStat" );

    if( !TargetStat )
    {
        dprintf( "Can't find the address of 'glStat'" );
        return;
    }

    if ( !ReadMemory( TargetStat,
                      &LocalStat,
                      sizeof(LocalStat),
                      &result ) ) {

        dprintf( "Can't read memory from 0x%x", TargetStat );

    } else {

        PrintStat( &LocalStat );
    }

}

DECLARE_API( autopatterns )

/*++

Function Description:

    This function prints all the CF in the list. If args is specified, only that CF
    will be printed. Currently these are supported:

    0 - for CF_QOS

--*/

{
    DWORD               TargetGlobalData, TargetProtocolBlock;
    GLOBAL_BLOCK        LocalGlobalData;
    PROTOCOL_BLOCK      LocalProtocolBlock;
    PLIST_ENTRY         pHead, pEntry;
    LIST_ENTRY          listentry;
    DWORD               TargetPattern;
    PATTERN_BLOCK       LocalPattern;
    ULONG               result;
    INT                 i, j;
    ULONG               CfIndex = (-1);
    char                *lerr;

    TargetGlobalData = GetExpression( "MSGPC!glData" );

    if( !TargetGlobalData )
    {
        dprintf( "Can't find the address of 'glData'" );
        return;
    }

    //

    if ( !ReadMemory(
                     TargetGlobalData,
                     &LocalGlobalData,
                     sizeof(LocalGlobalData),
                     &result
                     )) {

        dprintf( "Can't read memory from 0x%x", TargetGlobalData );
        return;
    }

    //
    //
    //
    TargetProtocolBlock = (DWORD) LocalGlobalData.pProtocols;
    if ( !ReadMemory(
                     TargetProtocolBlock,
                     &LocalProtocolBlock,
                     sizeof(LocalProtocolBlock),
                     &result
                     )) {

        dprintf( "Can't read memory from 0x%x", TargetProtocolBlock );
        return;
    }

    for (i = 0; i < NUMBER_OF_WHEELS; i++) {

        j = 0;

        pHead = (PLIST_ENTRY) ((DWORD)TargetProtocolBlock + (i * sizeof(listentry)));
        pEntry = LocalProtocolBlock.TimerPatternList[i].Flink;
        dprintf("Printing TimerWheel %d Head = %X and pEntry = %X ******************\n", i, pHead, pEntry);

        while ( (pHead != pEntry) && (j < 1000) ) {

            j++;
            TargetPattern = (DWORD)CONTAINING_RECORD( pEntry, PATTERN_BLOCK, TimerLinkage );

            if ( !ReadMemory( TargetPattern,
                              &LocalPattern,
                              sizeof(LocalPattern),
                              &result ) ) {

                dprintf( "Can't read memory from 0x%x", TargetPattern );

            } else {

                dprintf("Pattern = %X and ClassificationBlock = %X\n", TargetPattern, LocalPattern.pClassificationBlock);
                // PrintPattern( &LocalPattern );
            }

            pEntry = LocalPattern.TimerLinkage.Flink;

        }
    }
    dprintf("Done printing all Timer Wheels\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\kdext\precomp.h ===
#if DBG
#define DEBUG 1
#endif

#define NT 1
#define _PNP_POWER  1
#define SECFLTR 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windows.h>
#include <ntosp.h>

#include <ndis.h>
#include <cxport.h>

#include <wdbgexts.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include "gpcifc.h"
#include "rhizome.h"
#include "pathash.h"
#include "handfact.h"
#include "ntddgpc.h"
#include "gpcstruc.h"
#include "refcnt.h"
#include "gpcdef.h"
#include "gpcdbg.h"
#include "gpcmap.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\kdext\makefile.inc ===
$(O)\precomp.pph: ..\gpc\gpcdef.h makefile.inc
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

$(O)\dsogpc.c: dso.txt $(O)\precomp.pph makefile.inc
    @echo Creating $@
    @cd $(O)
    structo -i h -p -s $(MAKEDIR)\dso.txt -o dsogpc.c precomp.pph
    @cd $(MAKEDIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\kdext\logger.c ===
/*
Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This function contains some example KD debugger extensions

Author:

    John Vert (jvert) 6-Aug-1992

Revision History:

--*/

#include "precomp.h"


typedef BOOLEAN
(*PRINT_FUNC) (
    IN PROW Row
);

HANDLE     FileHandle;
PRINT_FUNC Print;

DWORD
MyOpenFile (
    IN PCHAR Name,
    IN PWINDBG_OUTPUT_ROUTINE out,
    OUT HANDLE *File
    )

{
    HANDLE hFile;
    hFile = CreateFile(Name,
                          GENERIC_WRITE | GENERIC_READ,
                          0,
                          NULL,
                          CREATE_ALWAYS ,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);

    if (INVALID_HANDLE_VALUE == hFile) {
        out ("MyOpenFile: CreateFile Failed.\n");
    }

    *File = hFile;

    return(INVALID_HANDLE_VALUE == hFile ? (!(ERROR_SUCCESS)) : ERROR_SUCCESS);
}

BOOLEAN MyWriteFile(PROW lRow)
{
    LONG  len;
    BOOL  bRv;
    DWORD dwWritten;
    CHAR  buffer[1024];

    dprintf(".");
    wsprintf(buffer, "[%4d] 0x%x:0x%x:0x%x:0x%x: %s\n", lRow->Line, lRow->P1, lRow->P2, lRow->P3, lRow->P4, lRow->Row);
    len = strlen(buffer);
    bRv = WriteFile( FileHandle, buffer, len, &dwWritten, NULL );

    if (!bRv) {
        dprintf("WriteFile: Puked\n");
    }

    return bRv ? TRUE :FALSE;
}

BOOLEAN MyWriteConsole(PROW lRow)
{
    dprintf("[%4d] 0x%x:0x%x:0x%x:0x%x: %s\n", lRow->Line, lRow->P1, lRow->P2, lRow->P3, lRow->P4, lRow->Row);
    return TRUE;
}

DECLARE_API( tt )
{
    UINT i, max, total = 0;
    DWORD hostAddress;
    LOG   LLog;
    ULONG status, success;
    ULONG bytesread;
    CHAR DeviceName[] = "c:\\tmp\\";
    CHAR buffer[255];

    char LogBase[]   = {"&msgpc!Log"};

    hostAddress =  GetExpression(LogBase);

    if ( *args != '\0' ) {

        strcpy( buffer, DeviceName );
        strcat( buffer, args );
        status = MyOpenFile( buffer, dprintf, &FileHandle );
        if ( status == ERROR_SUCCESS ) {
            Print = MyWriteFile;
            max = LOGSIZE;
        }
        else {
            goto cleanup;
        }

        dprintf( "handle =%x status=%x \n", FileHandle, status);
    }
    else {
        Print = MyWriteConsole;
        max = 100;
    }

    if (!hostAddress){
        dprintf("bad string conversion (%s) \n", LogBase);
        goto cleanup;
    }

    success = ReadMemory((ULONG)hostAddress, &LLog, sizeof(LOG), &bytesread );
    if (!success){
        dprintf("problems reading memory at %x for %x bytes\n", hostAddress, sizeof(LOG));
        goto cleanup;
    }

    dprintf( "TT Log dumping %d entries\n", max);
    for(i = LLog.Index; (i < LOGSIZE) && (total < max); i++, total++)
    {
         PROW pRow;
         ROW  lRow;

         pRow = &LLog.Buffer[i];

         success = ReadMemory((ULONG)pRow, &lRow, sizeof(ROW), &bytesread);

         if(!success) {

              dprintf("problems reading memory at %x for %x bytes\n", pRow, sizeof(LOG));
              goto cleanup;
         }

         (*Print)(&lRow);

    }

    if (total < max) {
        dprintf( "TT Log dumping the rest (%d) from the top....\n", LLog.Index);
    }

    for(i = 0; (i < LLog.Index) && (total < max); i++, total++)
    {
         PROW pRow;
         ROW  lRow;

         pRow = &LLog.Buffer[i];

         success = ReadMemory((ULONG)pRow, &lRow, sizeof(ROW), &bytesread);

         if(!success) {

              dprintf("problems reading memory at %x for %x bytes\n", pRow, sizeof(LOG));
              goto cleanup;
         }

         (*Print)(&lRow);

    }

cleanup:
    if ( *args != '\0' ) {
         CloseHandle(FileHandle);
    }
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\kdext\kdutil.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    kdutil.h

Abstract:

    Packet scheduler KD extension utilities.

Author:

    Rajesh Sundaram (1st Aug, 1998)

Revision History:

--*/

/* Prototypes of the utilities */

ushort IPHeaderXsum(void *Buffer, int Size);

//
// Useful macros
//
#define KD_READ_MEMORY(Target, Local, Size)                                               \
{                                                                                         \
    ULONG _BytesRead;                                                                     \
    BOOL  _Success;                                                                       \
                                                                                          \
    _Success = ReadMemory( (ULONG_PTR)(Target), (Local), (Size), &_BytesRead);                \
                                                                                          \
    if(_Success == FALSE) {                                                               \
        dprintf("Problem reading memory at 0x%x for %d bytes \n", Target, Size);          \
        return;                                                                     \
    }                                                                                     \
    if(_BytesRead < (Size)) {                                                            \
        dprintf("Memory 0x%x. Wrong byte count. Expected to read %d, read %d \n", Target,(Size),(_BytesRead)); \
        return;                                                                     \
    }                                                                                     \
}

VOID
DumpGpcClientVc(PCHAR indent, PGPC_CLIENT_VC TargetVc, PGPC_CLIENT_VC LocalVc);

VOID
DumpCallParameters(
    PGPC_CLIENT_VC Vc,
    PCHAR Indent
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\kdext\kdutil.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    kdutil.c

Abstract:

    Packet scheduler KD extension utilities.

Author:

    Rajesh Sundaram (1st Aug, 1998)

Revision History:

--*/

#include "precomp.h"

EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
ULONG                  GpcClientVcTag = '1CSP';

PCHAR ClientVCState[] = { 
    "", 
    "CL_VC_INITIALIZED", 
    "CL_CALL_PENDING",
    "CL_INTERNAL_CALL_COMPLETE",
    "CL_CALL_COMPLETE", 
    "CL_MODIFY_PENDING",
    "CL_GPC_CLOSE_PENDING", 
    "CL_INTERNAL_CLOSE_PENDING"
};

PCHAR ServiceTypeLabels[] = {
    "No Traffic",
    "Best Effort",
    "Controlled Load",
    "Guaranteed",
    "Network Unavailable",
    "General Information",
    "No Change",
    "",
    "",
    "Non Conforming",
    "Network Control",
    "Custom1",
    "Custom2",
    "Custom3"
};

PCHAR SDMode[]= {
    "Borrow",
    "Shape",
    "Discard",
    "Borrow Plus"};

ushort
IPHeaderXsum(void *Buffer, int Size)
{
    ushort  UNALIGNED *Buffer1 = (ushort UNALIGNED *)Buffer; // Buffer expres
    ulong   csum = 0;

    while (Size > 1) {
        csum += *Buffer1++;
        Size -= sizeof(ushort);
    }

    if (Size)
        csum += *(uchar *)Buffer1;              // For odd buffers, add in la

    csum = (csum >> 16) + (csum & 0xffff);
    csum += (csum >> 16);
    return (ushort)~csum;
}


VOID
CheckVersion(
    VOID
    )
{
#if 0
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target "
                "system(%d %s)\r\n\r\n", VER_PRODUCTBUILD, SavedMinorVersion, 
                (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target "
                "system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, 
                (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
#endif
}


LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf("%s Extension dll for Build %d debugging %s kernel for Build %d\n",
            DebuggerType,
            VER_PRODUCTBUILD,
            SavedMajorVersion == 0x0c ? "Checked" : "Free",
            SavedMinorVersion
            );
}

VOID
DumpGpcClientVc(PCHAR indent, PGPC_CLIENT_VC TargetClientVC, PGPC_CLIENT_VC LocalClientVC) 
{
    PWSTR  Name;
    ULONG bytes;

#if DBG
    if ( LocalClientVC->LLTag != GpcClientVcTag ) {
        dprintf( "%s ClientVC @ %08X has the wrong type \n", indent, TargetClientVC );
        return;
    }
#endif

    dprintf( "%s ClientVC @ %08X\n\n", indent, TargetClientVC );

    dprintf( "%s Refcount               = %d \n", indent, LocalClientVC->RefCount);
    dprintf( "%s VC State               = %s\n", indent, ClientVCState[ LocalClientVC->ClVcState ]);
    dprintf( "%s Adapter                = 0x%x \n", indent, LocalClientVC->Adapter);
    dprintf( "%s Flags                  = 0x%x \n", indent, LocalClientVC->Flags);
    dprintf( "%s Lock                   @ %08X \n", indent, &TargetClientVC->Lock);

    if(LocalClientVC->InstanceName.Length) {
        bytes = LocalClientVC->InstanceName.Length;
        Name = (PWSTR)malloc( bytes );
        if ( Name != NULL ) {
            KD_READ_MEMORY((LocalClientVC->InstanceName.Buffer), Name, bytes);
        }
    }
    else {
        Name = 0;
    }
    dprintf( "%s Instance Name          = %ws \n", indent, Name);
    dprintf( "%s CfInfo Handle          = %08X \n", indent, LocalClientVC->CfInfoHandle);
    dprintf( "%s CfType                 = %d \n", indent, LocalClientVC->CfType);
    dprintf( "%s TOS non conforming     = %X \n", indent, LocalClientVC->IPPrecedenceNonConforming);
    dprintf( "%s 802.1p conforming      = %X \n", indent, LocalClientVC->UserPriorityConforming);
    dprintf( "%s 802.1p non conforming  = %X \n", indent, LocalClientVC->UserPriorityNonConforming);

    dprintf( "%s Flow Context           = %x \n", indent, LocalClientVC->PsFlowContext);
    dprintf( "%s TokenRateChange        = %x \n", indent, LocalClientVC->TokenRateChange);

    //
    // Control by a flag later on.... to much junk otherwize
    //

    if(LocalClientVC->CallParameters) {

        dprintf("%s Call Parameters \n", indent);

        DumpCallParameters(LocalClientVC, "    ");
    }

    if(Name)
        free(Name);

    return;
}

VOID
DumpFlowSpec(
    PFLOWSPEC Flow,
    PCHAR Indent
    )
{
    dprintf( "%sTokenRate          = %u (%08X)\n", Indent, Flow->TokenRate, Flow->TokenRate );
    dprintf( "%sTokenBucketSize    = %u (%08X)\n", Indent, Flow->TokenBucketSize, Flow->TokenBucketSize );
    dprintf( "%sPeakBandwidth      = %u (%08X)\n", Indent, Flow->PeakBandwidth, Flow->PeakBandwidth );
    dprintf( "%sLatency            = %u (%08X)\n", Indent, Flow->Latency, Flow->Latency );
    dprintf( "%sDelayVariation     = %u (%08X)\n", Indent, Flow->DelayVariation, Flow->DelayVariation );

    if ( (LONG)(Flow->ServiceType) != -1 ) {

        dprintf( "%sServiceType    = %s\n", Indent, ServiceTypeLabels[ Flow->ServiceType ] );
    } else {

        dprintf( "%sServiceType    = Unspecified\n", Indent );
    }

    dprintf( "%sMaxSduSize         = %u (%08X)\n", Indent, Flow->MaxSduSize, Flow->MaxSduSize );
    dprintf( "%sMinimumPolicedSize = %u (%08X)\n", Indent, Flow->MinimumPolicedSize, Flow->MinimumPolicedSize );
}

VOID
DumpSpecific(
    ULONG Length,
    PCO_CALL_MANAGER_PARAMETERS TargetCMParams,
    PCHAR Indent
    )
{
    LONG ParamsLength;
    LPQOS_OBJECT_HDR lQoSObject = malloc(Length);
    CO_CALL_MANAGER_PARAMETERS CM;
    ULONG Address;

    if(!lQoSObject)
        return;

    Address = (ULONG)TargetCMParams +  FIELD_OFFSET(CO_CALL_MANAGER_PARAMETERS, CallMgrSpecific) +
                   FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters);

    KD_READ_MEMORY(Address,
                   lQoSObject, 
                   Length);

    ParamsLength = Length;

    while(ParamsLength > 0) {

        switch(lQoSObject->ObjectType) {

          case QOS_OBJECT_SHAPING_RATE:
          {
              LPQOS_SHAPING_RATE pShapingRate = (LPQOS_SHAPING_RATE)(lQoSObject);
              dprintf("%s QOS_OBJECT_SHAPING_RATE (Shaping Rate = %d (0x%x) \n", Indent,
                      pShapingRate->ShapingRate, pShapingRate->ShapingRate);
              break;
          }

          case QOS_OBJECT_DS_CLASS:
          {
              LPQOS_DS_CLASS pDClass = (LPQOS_DS_CLASS)(lQoSObject);
              dprintf("%s QOS_OBJECT_DS_CLASS (DSCP = %d (0x%x) \n", Indent,
                      pDClass->DSField, pDClass->DSField);
              break;

          }

          case QOS_OBJECT_TRAFFIC_CLASS:
          {
              LPQOS_TRAFFIC_CLASS pDClass = (LPQOS_TRAFFIC_CLASS)(lQoSObject);
              dprintf("%s QOS_OBJECT_TRAFFIC_CLASS (DSCP = %d (0x%x) \n", Indent,
                      pDClass->TrafficClass, pDClass->TrafficClass);
              break;

          }

          case QOS_OBJECT_PRIORITY:
          {
              LPQOS_PRIORITY pPri = (LPQOS_PRIORITY)(lQoSObject);
              dprintf("%s QOS_OBJECT_PRIORITY \n", Indent);
              dprintf("%s%s SendPriority = %d \n", Indent, Indent, pPri->SendPriority);
              dprintf("%s%s RecvPriority = %d \n", Indent, Indent, pPri->ReceivePriority);
              dprintf("%s%s SendFlags    = %d \n", Indent, Indent, pPri->SendFlags);
              break;
          }

          case QOS_OBJECT_SD_MODE:
          {
              LPQOS_SD_MODE pSDMode = (LPQOS_SD_MODE)(lQoSObject);
              dprintf("%s QOS_OBJECT_SD_MODE (SD mode = %s) \n", 
                      Indent, 
                      SDMode[pSDMode->ShapeDiscardMode]);
              break;
          }

          case QOS_OBJECT_DIFFSERV:
          {
              LPQOS_DIFFSERV qD = (LPQOS_DIFFSERV)(lQoSObject);
              ULONG DSFieldCount = qD->DSFieldCount;
              LPQOS_DIFFSERV_RULE pDiffServRule = (LPQOS_DIFFSERV_RULE) qD->DiffservRule;
              ULONG i;

              dprintf("%s QOS_OBJECT_DIFFSERV \n\n", Indent);

              for(i=0; i<DSFieldCount; i++, pDiffServRule++) {

                  dprintf("%s%sInboundDSField        = %3d (0x%x) \n", Indent, Indent, 
                          pDiffServRule->InboundDSField,
                          pDiffServRule->InboundDSField);

                  dprintf("%s%sConforming     DS     = %3d (0x%x) \n", Indent, Indent, 
                          pDiffServRule->ConformingOutboundDSField,
                          pDiffServRule->ConformingOutboundDSField);

                  dprintf("%s%sNon Conforming DS     = %3d (0x%x) \n", Indent, Indent, 
                          pDiffServRule->NonConformingOutboundDSField,
                          pDiffServRule->NonConformingOutboundDSField);

                  dprintf("%s%sConforming     802.1p = %3d (0x%x) \n", Indent, Indent, 
                          pDiffServRule->ConformingUserPriority,
                          pDiffServRule->ConformingUserPriority);

                  dprintf("%s%sNon Conforming 802.1p = %3d (0x%x) \n", Indent, Indent, 
                          pDiffServRule->NonConformingUserPriority,
                          pDiffServRule->NonConformingUserPriority);

                  dprintf("\n");
              }

              break;
          }

              
        }

        if(
            ((LONG)lQoSObject->ObjectLength <= 0) ||
            ((LONG)lQoSObject->ObjectLength > ParamsLength)
            ){

            return;
        }

        ParamsLength -= lQoSObject->ObjectLength;
        lQoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)lQoSObject + 
                                       lQoSObject->ObjectLength);
    }

    if(lQoSObject) {

        free(lQoSObject);
    }

}

VOID
DumpCallParameters(
    PGPC_CLIENT_VC Vc,
    PCHAR Indent
    )
{
    PCO_CALL_PARAMETERS     tCp = Vc->CallParameters;
    CO_CALL_PARAMETERS     lCp;
    LONG bytes = sizeof( CO_CALL_MANAGER_PARAMETERS );
    LONG IndentLen;
    PCHAR NewIndent;

    IndentLen = strlen( Indent );

    NewIndent = malloc( IndentLen + 8 );

    if(!NewIndent)
        return;

    strcpy( NewIndent, Indent );
    strcat( NewIndent, "        " );

    //
    // Read CallParameters out of memory
    //
    KD_READ_MEMORY(tCp, &lCp, sizeof(CO_CALL_PARAMETERS));

    //
    // Dump it
    //

    dprintf("%sFlags                0x%x \n", Indent, lCp.Flags);
    dprintf("%sCallManager Parameters \n", Indent);
    
    {
        //
        // read CMParams struct out of target's memory
        //
        CO_CALL_MANAGER_PARAMETERS LocalCMParams;
        PCO_CALL_MANAGER_PARAMETERS TargetCMParams;
        
        TargetCMParams = lCp.CallMgrParameters;
        KD_READ_MEMORY((ULONG)TargetCMParams, &LocalCMParams,sizeof( CO_CALL_MANAGER_PARAMETERS));

        dprintf( "%s    Transmit\n", Indent );
        DumpFlowSpec( &LocalCMParams.Transmit, NewIndent );

        dprintf( "%s    Receive\n", Indent );
        DumpFlowSpec( &LocalCMParams.Receive, NewIndent );

        dprintf( "%s    Specific\n", Indent );
        DumpSpecific( LocalCMParams.CallMgrSpecific.Length, 
                      TargetCMParams, 
                      NewIndent );
    }
    dprintf("%sMediaParameters \n", Indent);
    {
        CO_MEDIA_PARAMETERS             lM;
        PCO_MEDIA_PARAMETERS    pM;
        
        pM = lCp.MediaParameters;
        KD_READ_MEMORY((ULONG)pM, &lM,sizeof(CO_MEDIA_PARAMETERS));
        dprintf( "%s    Flags            %x \n", Indent, lM.Flags);
        dprintf( "%s    ReceivePriority  %x \n", Indent, lM.ReceivePriority );
        dprintf( "%s    ReceiveSizeHint  %x \n", Indent, lM.ReceiveSizeHint );
        dprintf( "%s    Specific\n", Indent );
        //DumpSpecific( &lM.MediaSpecific, NewIndent );
    }

    free( NewIndent );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\kdext\dsocode.c ===
/****************************** Module Header ******************************\
* Module Name: dsocode.c
*
* Copyright (c) 1985-1999, Microsoft Corporation
*
* This file contains the dump structure offset (dso) extension. It is
*  included by $(ALT_PROJECT)\dsotable.c which is generated by structo.exe
*
* History:
* 06/17/96 GerardoB Created
* 10/06/98 Rajeshsu edited to use wdbgexts.h
\***************************************************************************/

#define DsoPrint(x) dprintf("%.*s", nIndent, "                      "); dprintf x

#define OFLAG(l)        (1L << ((DWORD)#@l - (DWORD)'a'))
#define EvalExp (PVOID)GetExpression

#define EXACT_MATCH 0xFFFF

int gnIndent = 0; // caller should set and restore this appropriately.

VOID moveBlock(
    PVOID pdst,
    PVOID src,
    DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;
    
    try {
        if (!ReadMemory((DWORD_PTR)src, pdst, size, &Result)) {
            fSuccess = FALSE;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //dprintf(pszMoveException, pszExtName);
        fSuccess = FALSE;
    }

    if (!fSuccess) {
        dprintf("moveBlock(%x, %x, %x) failed.\n", pdst, src, size);
    }
}


/***************************************************************************\
* dsoTerminateString
*
* This is used to "parse" the command line. It null-terminates a space
*  delimited string, returns its size and a pointer to the begining
*  of next string
*
* 06/17/96 Created Gerardob
\***************************************************************************/
LPSTR dsoTerminateString(LPSTR psz, PDWORD pdwSize)
{
    LPSTR pszWork = psz;

    while (*pszWork != 0) {
        if (*pszWork == ' ') {
            *pszWork++ = 0;
            break;
        }
        pszWork++;
    }

    *pdwSize = (DWORD)(pszWork - psz);
    if (*pszWork != 0) {
        (*pdwSize)--;
    }

    while ((*pszWork != 0) && (*pszWork == ' ')) {
        pszWork++;
    }

    return pszWork;
}
/***************************************************************************\
* dsoGetOffset
*
* If the highest order bit of psot->dwOffset is set, then the value is a
*  relative offset from the previous field; otherwise, it is the
*  actual field offset from the beginnig of the structure
*
* 06/20/96 Created Gerardob
\***************************************************************************/
UINT dsoGetOffset (PSTRUCTUREOFFSETSTABLE psot)
{
    if (!(psot->dwOffset & 0x80000000)) {
        return psot->dwOffset;
    } else {
        return ((psot->dwOffset & ~0x80000000) + dsoGetOffset(psot - 1));
    }
}
/***************************************************************************\
* dsoGetSize
*
* The field size is calculated by substracting its offset from the next
*  field's offset. If the struct has unions, several "fields" might have
*  the same offset, or a given table entry (i.e., a field) might have an
*  offset value greater than the offset value for the next entry (a union
*  of two structures).
*
* 06/26/96 Created Gerardob
\***************************************************************************/
UINT dsoGetSize (PSTRUCTUREOFFSETSTABLE psot, DWORD dwOffset)
{
    DWORD dwNextFieldOffset;

    do {
        psot++;
        dwNextFieldOffset = dsoGetOffset(psot);
    } while (dwNextFieldOffset <= dwOffset);

    return dwNextFieldOffset - dwOffset;
}
/***************************************************************************\
* dsoGetStruct
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTURESTABLE dsoGetStruct (LPSTR pszStruct, DWORD dwSize)
{
    PSTRUCTURESTABLE pst = gst;

    /*
     * If dwSize is EXACT_MATCH, we try an exact
     * case sensitive match
     */
    if (dwSize == EXACT_MATCH) {
        while (pst->pszName != NULL) {
            if (!strcmp(pszStruct, pst->pszName)) {
                return pst;
            }
            pst++;
        }
        return NULL;
    }
    /*
     * Try an exact case insensitive match
     */
    while (pst->pszName != NULL) {
        if (!_stricmp(pszStruct, pst->pszName)) {
            return pst;
        }
        pst++;
    }

    /*
     * Partial prefix match
     */
    pst = gst;
    while (pst->pszName != NULL) {
        if (!_strnicmp(pszStruct, pst->pszName, dwSize)) {
            return pst;
        }
        pst++;
    }

    return NULL;

}
/***************************************************************************\
* dsoGetField
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTUREOFFSETSTABLE dosGetField (PSTRUCTUREOFFSETSTABLE psot, LPSTR pszField, DWORD dwSize)
{
    PSTRUCTUREOFFSETSTABLE psotFirst = psot;

    /*
     * try an exact match
     */
    while (psot->pszField != NULL) {
        if (!_stricmp(pszField, psot->pszField)) {
            return psot;
        }
        psot++;
    }

    /*
     * Partial prefix match
     */
    psot = psotFirst;
    while (psot->pszField != NULL) {
        if (!_strnicmp(pszField, psot->pszField, dwSize)) {
            return psot;
        }
        psot++;
    }
    return NULL;

}
/***************************************************************************\
* Idso
*
* !dso StructName [FieldName] [Address]
*
* 06/17/96 Created Gerardob
* 05/12/97 MCostea Added bit field support
\***************************************************************************/

#define NFIELDS 2  // per row.

BOOL Idso(DWORD opts, LPSTR pszCmdLine)
{
    BOOL fOneField = FALSE;
    DWORD dwValue, dwSize, dwBytesRead, dwOffset, dwOffsetNext, dwFieldsPerRow, dwMoveSize;
    DWORD dwBuffer [20];  /* Make sure it has an even number of elemnts and at least 4*/
    const DWORD *pcdwLimit = dwBuffer + (sizeof(dwBuffer) / sizeof(*dwBuffer));
    DWORD *pdwValue;
    LPSTR pszField, pszAddress;
    PBYTE pBufferOffset;
    PSTRUCTURESTABLE pst, pstNested;
    PSTRUCTUREOFFSETSTABLE psot;
    PVOID pAddress = NULL;

    int   cBFStart, cBFLength;   /* for printing bit field values: keeps count of field location */
    char* pTmp;
    DWORD dwMask;
    BOOL  fBF;
    int   cBF;                   /* no of dwords this set of bit-fields spread till now */
    int   cchName;               /* length of field name */
    int   nIndent = gnIndent;    /* amount to indent */

    UNREFERENCED_PARAMETER(opts);

    if (pszCmdLine == NULL) {
        return FALSE;
    }

    /*
     * Find the struct table
     */
    pszField = dsoTerminateString(pszCmdLine, &dwSize);
    pst = dsoGetStruct (pszCmdLine, dwSize);
    if (pst == NULL) {
        DsoPrint(("Structure not found: %s\n", pszCmdLine));
        return TRUE;
    }

    /*
     * Got a table
     */
    psot = pst->psot;

    /*
     * If there is another argument, let's assume a field name follows
     */
    if (*pszField != 0) {
        /*
         * Find the field
         */
        pszAddress = dsoTerminateString(pszField, &dwSize);
        psot = dosGetField (psot, pszField, dwSize);

        /*
         * If it didn't find the field and an address was provided, game over.
         * Otherwise, the second parameter might be the address
         */
        if (psot == NULL) {
            if (*pszAddress != 0) {
                DsoPrint(("Field not found: %s. Struct: %s\n", pszField, pst->pszName));
                return TRUE;
            } else {
                pszAddress = pszField;
                /*
                 * Reset psot since this argument was not a field
                 */
                psot = pst->psot;
            }
        } else {
            fOneField = TRUE;
        }
    
        /*
         * Get the pointer to the struct
         */
        if (*pszAddress != 0) {
            pAddress = EvalExp(pszAddress);
            if (pAddress == NULL) {
                /*
                 * EvalExp displayed the error message, so return silently
                 */
                return TRUE;
            }
        }

    } /* if (*pszField != 0) */


    /*
     * If a field name was specified, dump that field only
     * Otherwise, dump the whole table.
     */
    if (fOneField) {
        /*
         * If no address available, just display the field name and offset
         */
        dwOffset = dsoGetOffset(psot);

        DsoPrint(("Structure %s - Size: %#lx\n", pst->pszName, pst->dwSize));

        /*
         * Try to see if the fields are not nested structures
         */
        if (*psot->pszField >= 'A' && *psot->pszField <= 'Z') {
            /*
             * Probably the field is a nested structure
             */
            if (pstNested = dsoGetStruct (psot->pszField, EXACT_MATCH)) {
                DWORD dwNestedOffset = dsoGetOffset(psot);
                char cmdLine[80];
                DsoPrint(("\nNested at offset %03lx: ", dwNestedOffset));
                if (pAddress) {
                    sprintf(cmdLine, "%s %p", psot->pszField, (PBYTE)pAddress + dwNestedOffset);
                    pTmp = cmdLine;
                }
                else {
                    pTmp = psot->pszField;
                }
                return Idso(opts, pTmp);
            }
        }

        DsoPrint(("Field: %s - Offset: %#lx\n", psot->pszField, dwOffset));
        if (pAddress == NULL) {
            return TRUE;
        }

        /*
         * Printing field value
         */

        /*123456789 1*/
        DsoPrint(("Address   Value\n"));

        dwBytesRead = 0;
        dwSize = dsoGetSize(psot, dwOffset);
        /*
         * Print 4 DWORDS per row; one row per loop
         */

        do { /* while ((int)dwSize > 0) */

            /*
             * Read values for next row
             */
            if (4 * sizeof(DWORD) >= dwSize) {
                dwMoveSize = dwSize;
            } else {
                dwMoveSize = 4 * sizeof(DWORD);
            }
            moveBlock(dwBuffer, (PBYTE)pAddress + dwOffset + dwBytesRead, dwMoveSize);
            pBufferOffset = (PBYTE)dwBuffer;

            /*
             * Print the address
             */
            DsoPrint(("%p  ", (DWORD_PTR)((PBYTE)pAddress + dwOffset + dwBytesRead)));
            /*
             * Keep track of bytes read (dwBytesRead) and bytes
             *  remaining to be read (dwSize)
             */
            dwBytesRead += dwMoveSize;
            dwSize -= dwMoveSize;
            /*
             * Print the values, one dword at the time
             */
            while (dwMoveSize >= sizeof(DWORD)) {
                DsoPrint(("%08lx ", *((DWORD *)pBufferOffset)));
                pBufferOffset += sizeof(DWORD);
                dwMoveSize -= sizeof(DWORD);
            }
            /*
             * If less than a DWORD left, zero extend and print a DWORD
             */
            if (dwMoveSize > 0) {
                dwValue = 0;
                memcpy(&dwValue, pBufferOffset, dwMoveSize);
                DsoPrint(("%0*lx", dwMoveSize * 2, dwValue));
            }
            dprintf("\n");

        } while ((int)dwSize > 0);

        return TRUE;

    } /* if (fOneField) */


    /*
     * Printing all the fields.
     */
    if (pAddress != NULL) {
        DsoPrint(("Structure %s %#lx - Size: %#lx", pst->pszName, pAddress, pst->dwSize));
    } else {
        DsoPrint(("Structure %s - Size: %#lx", pst->pszName, pst->dwSize));
    }

    dwOffset = 0;
    pBufferOffset = NULL; /* Forces the local buffer to be loaded */
    dwFieldsPerRow = NFIELDS;
    cBFStart = 0;
    cBF = 0;

    /*
     * Loop through all fields in the table. Print one field per loop
     */

    while (psot->pszField != NULL) {

        /*
         * Print two fields per row
         */
        if (dwFieldsPerRow == NFIELDS) {
            dprintf("\n");
            dwFieldsPerRow = 1;
            cchName = 24 - gnIndent/NFIELDS;
            nIndent = gnIndent;
            // Print("cchName = %d\n", cchName);
        } else {
            dwFieldsPerRow++;
            cchName = 24 - (gnIndent + 1)/NFIELDS;
            nIndent = 0;
            // Print("cchName = %d\n", cchName);
        }

        /*
         * -v functionality
         * Try to see if the fields are not nested structures
         * The naming convention assigns Uppercase names for them
         */
        if (opts & OFLAG(v)) {
            if (*psot->pszField >= 'A' && *psot->pszField <= 'Z') {
                /*
                 * Probably the field is a nested structure
                 */
                if (pstNested = dsoGetStruct (psot->pszField, EXACT_MATCH)) {
                    DWORD dwNestedOffset = dsoGetOffset(psot);
                    char cmdLine[80];
                    DsoPrint(("\nNested at offset %03lx: ", dwNestedOffset));
                    if (pAddress) {
                        sprintf(cmdLine, "%s %p", psot->pszField, (PBYTE)pAddress + dwNestedOffset);
                        pTmp = cmdLine;
                    }
                    else {
                        pTmp = psot->pszField;
                    }
                    Idso(opts, pTmp);
                    dwOffsetNext = dsoGetOffset(psot + 1);
                    dwFieldsPerRow = 0;
                    goto Continue;
                }
            }
        }

        /*
         * If no address provided, Print field name(s) and offset(s) only
         */
        if (pAddress == NULL) {
            DsoPrint(("%03lx %-*.*s", dsoGetOffset(psot),
                      cchName, cchName, psot->pszField));
        } else {
            /*
             * Printing offsets and values.
             *
             * Get the size of the value and max it to one DWORD
             */
            dwOffsetNext = dsoGetOffset(psot + 1);
            if (dwOffsetNext > dwOffset) {
                dwSize = dwOffsetNext - dwOffset;
            } else {
                dwSize = dsoGetSize(psot, dwOffset);
            }
            if (dwSize > sizeof(DWORD)) {
                dwSize = sizeof(DWORD);
            }

            /*
             * Get a pointer to the value in the local buffer
             * If the value is not in the buffer, load it
             */
            pdwValue = (PDWORD)(pBufferOffset + dwOffset);
            if ((pdwValue < dwBuffer) || (pdwValue + dwSize > pcdwLimit)) {
                pBufferOffset = (PBYTE)dwBuffer - dwOffset;
                pdwValue = dwBuffer;

                if (sizeof(dwBuffer) >= pst->dwSize - dwOffset) {
                    dwMoveSize = pst->dwSize - dwOffset;
                } else {
                    dwMoveSize = sizeof(dwBuffer);
                }
                moveBlock((PBYTE)dwBuffer, (PBYTE)pAddress + dwOffset, dwMoveSize);

            }

            /*
             * Copy the value and print it
             */
            dwValue = 0; /* in case size < sizeof(DWORD) */
            memcpy(&dwValue, pdwValue, dwSize);

            /*
             * Deal with bit fields
             */
            fBF = FALSE;
            pTmp = psot->pszField;
            while (*pTmp) {
                if (*pTmp++ == ':') {

                    fBF = TRUE;
                    while ((*pTmp == ' ') || (*pTmp == '\t')) {     /* skip white spaces */
                        ++pTmp;
                    }
                    cBFLength = *(pTmp++) - '0';      /* now get the bit size, maybe 2 digits */
                    if ((*pTmp >= '0') && (*pTmp <= '9'))
                        cBFLength = cBFLength*10 + (*pTmp - '0');

                    if (cBFStart == 0) {
                        DsoPrint(("(%03lx) %08lx BIT FIELDS\n", dwOffset, dwValue));
                        dwFieldsPerRow = 1;
                    }
                    else if (cBFStart >= 8*sizeof(DWORD)) {   /* check for multi-dword fields */
                        cBF ++;
                        cBFStart %= 8*sizeof(DWORD);
                    }

                    dwMask = (1L << cBFLength) - 1;
                    dwMask <<= cBFStart;
                    /* print byte offset and the bit offset inside it */
                    DsoPrint(("(%03lx) (%d)   %-2x %-*.*s", dwOffset + cBF*sizeof(DWORD) + cBFStart/8, cBFStart & 7,
                           (dwMask & dwValue) >> cBFStart,
                            cchName, cchName, psot->pszField));
                    cBFStart += cBFLength;
                    cBFLength = 0;
                    break;
                }
            }
            if (!fBF) {
                int width = 8;
                if (dwSize == sizeof(BYTE)) {
                    dwValue &= 0xff;
                    width = 2;
                } else if (dwSize == sizeof(WORD)) {
                    dwValue &= 0xffff;
                    width = 4;
                }
                DsoPrint(("(%03lx) %*s%0*lx %-*.*s", dwOffset, 8 - width, "", width, dwValue,
                          cchName, cchName, psot->pszField));
                cBFStart = 0;
                cBF = 0;
            }

        } /* if (pAddress == NULL) */

Continue:
        dwOffset = dwOffsetNext;
        psot++;

    } /* while (psot->pszField != NULL) */

    dprintf("\n");

    return TRUE;
}

DECLARE_API( psdso )
{
    LPSTR pszCmdLine = (LPSTR)args;
    DWORD opts = 0;

    Idso(opts, pszCmdLine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\kdext\kdps.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    kdps.c

Abstract:

    Packet scheduler KD extension  

Author:

    Rajesh Sundaram (1st Aug, 1998)

Revision History:

--*/

#include "precomp.h"
#include <winsock.h>


//
// forwards
//

//
// globals
//

PCHAR AdapterMode[] = {
    "",
    "Diffserv",
    "RSVP"
};

PCHAR AdapterState[] = { 
    "", 
    "AdapterStateInitializing",
    "AdapterStateRunning",
    "AdapterStateWaiting",
    "AdapterStateDisabled",
    "AdapterStateClosing",
    "AdapterStateClosed"
};



/* forwards */

VOID
DumpAdapterStats(
    PPS_ADAPTER_STATS Stats,
    PCHAR Indent
    );

/* end forwards */

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}

DECLARE_API( adapter )
/*
 *   dump a PS adapter structure
 */
{
    PADAPTER     TargetAdapter;
    ADAPTER      LocalAdapter;
    PADAPTER     LastAdapter;
    LIST_ENTRY   LocalListHead;
    PLIST_ENTRY  TargetListHead;
    PWSTR        PSName;
    PWSTR        MPName;
    PWSTR        WMIName;
    PWSTR        ProfileName;
    PWSTR        RegistryPath;
    BOOLEAN      DumpAllAdapters = FALSE;
    ULONG        bytes;

    if ( *args == '\0' ) {

        //
        // run down the adapter list, dumping the contents of each one
        //

        TargetListHead = (PLIST_ENTRY)GetExpression( "PSCHED!AdapterList" );

        if ( !TargetListHead ) {

            dprintf("Can't convert psched!AdapterList symbol\n");
            return;
        }

        PSName = 0;
        MPName = 0;
        WMIName = 0;
        ProfileName = 0;
        RegistryPath = 0;
        //
        // read adapter listhead out of target's memory
        //
        KD_READ_MEMORY(TargetListHead, &LocalListHead, sizeof(LIST_ENTRY));

        TargetAdapter = (PADAPTER)LocalListHead.Flink;

        LastAdapter = (PADAPTER)TargetListHead;

        DumpAllAdapters = TRUE;

    } else {

        TargetAdapter =  (PADAPTER)GetExpression( args );

        if ( !TargetAdapter ) {

            dprintf("bad string conversion (%s) \n", args );

            return;

        }

        LastAdapter = 0;
    }

    while ( TargetAdapter != LastAdapter ) {

        //
        // read adapter struct out of target's memory
        //
        KD_READ_MEMORY(TargetAdapter, &LocalAdapter, sizeof(ADAPTER));

        PSName = 0;
        MPName = 0;
        WMIName = 0;
        ProfileName = 0;
        RegistryPath = 0;

        //
        // alloc some mem for the PS and MP device names and get them too
        //
        if(LocalAdapter.UpperBinding.Length) {
            bytes = ( LocalAdapter.UpperBinding.Length + 1);
            PSName = (PWSTR)malloc( bytes );
            if ( PSName != NULL ) {
                KD_READ_MEMORY(LocalAdapter.UpperBinding.Buffer, PSName, bytes-1);
            }
        }

        if(LocalAdapter.MpDeviceName.Length) {
            bytes = ( LocalAdapter.MpDeviceName.Length + 1);
            MPName = (PWSTR)malloc( bytes );
            if ( MPName != NULL ) {
                KD_READ_MEMORY((ULONG)(LocalAdapter.MpDeviceName.Buffer),
                               MPName,
                               bytes-1);
            }
        }

        if(LocalAdapter.WMIInstanceName.Length) {

            bytes = ( LocalAdapter.WMIInstanceName.Length + 1);
            WMIName = (PWSTR)malloc( bytes );
            if ( WMIName != NULL ) {
                KD_READ_MEMORY(LocalAdapter.WMIInstanceName.Buffer, WMIName, bytes-1);
    
            }
        }

        if(LocalAdapter.ProfileName.Length) {
            bytes = ( LocalAdapter.ProfileName.Length + 1 );
            ProfileName = (PWSTR)malloc( bytes );
            if ( ProfileName != NULL ) {
                KD_READ_MEMORY(LocalAdapter.ProfileName.Buffer, ProfileName, bytes-1);
                
            }
        }

        if(LocalAdapter.RegistryPath.Length) {
            bytes = ( LocalAdapter.RegistryPath.Length + 1 );
            RegistryPath = (PWSTR)malloc( bytes );
            if ( RegistryPath != NULL ) {
                KD_READ_MEMORY(LocalAdapter.RegistryPath.Buffer, RegistryPath, bytes-1);
            }

        }

        dprintf( "\nAdapter @ %08X \n\n", TargetAdapter);

        dprintf( "    Next Adapter              @ %08X ", &TargetAdapter->Linkage);
       
        if(&TargetAdapter->Linkage == LocalAdapter.Linkage.Flink) {

            dprintf("  (empty) ");
        }
        dprintf( " \n");

        dprintf( "    Lock                           @ %08X\n", &TargetAdapter->Lock);
        dprintf( "    RefCount                       = %d\n", LocalAdapter.RefCount );
        dprintf( "    MpDeviceName                   = %ws \n", MPName);
        dprintf( "    UpperBinding                   = %ws \n", PSName);
        dprintf( "    WMIInstanceName                = %ws \n", WMIName);
        dprintf( "    ProfileName                    = %ws \n", ProfileName);
        dprintf( "    RegistryPath                   = %ws \n", RegistryPath);
        dprintf( "    MiniportHandle (PsNdisHandle)  = %x \n", LocalAdapter.PsNdisHandle);
        dprintf( "    BindingHandle  (LowerMpHandle) = %x \n", LocalAdapter.LowerMpHandle);

        dprintf( "    Outstanding NDIS request       = %d \n", LocalAdapter.OutstandingNdisRequests);
        
        dprintf( "    ShutdownMask                   = \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_CLOSE_WAN_ADDR_FAMILY)
            dprintf("           SHUTDOWN_CLOSE_WAN_ADDR_FAMILY \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_DELETE_PIPE      )  
            dprintf("           SHUTDOWN_DELETE_PIPE \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_FREE_PS_CONTEXT  )  
            dprintf("           SHUTDOWN_FREE_PS_CONTEXT \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_UNBIND_CALLED    )  
            dprintf("           SHUTDOWN_UNBIND_CALLED \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_MPHALT_CALLED    )  
            dprintf("           SHUTDOWN_MPHALT_CALLED \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_CLEANUP_ADAPTER   ) 
            dprintf("           SHUTDOWN_CLEANUP_ADAPTER \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_PROTOCOL_UNLOAD    )
            dprintf("           SHUTDOWN_PROTOCOL_UNLOAD \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_BIND_CALLED   )     
            dprintf("           SHUTDOWN_BIND_CALLED \n");

        if(LocalAdapter.ShutdownMask & SHUTDOWN_MPINIT_CALLED )
            dprintf("           SHUTDOWN_MPINIT_CALLED \n");
        

        if(!DumpAllAdapters) {
        dprintf( "    IpNetAddressList          @ %08X \n", LocalAdapter.IpNetAddressList);
        dprintf( "    IpxNetAddressList         @ %08X \n", LocalAdapter.IpxNetAddressList);
        dprintf( "    PsMpState                 = %s\n", AdapterState [ LocalAdapter.PsMpState]);
        dprintf( "    BlockingEvent             @ %08X\n", &TargetAdapter->BlockingEvent );
        dprintf( "    FinalStatus               = %08X\n", LocalAdapter.FinalStatus );
        dprintf( "    Media Type                = %d\n", LocalAdapter.MediaType );
        dprintf( "    Total Size                = %d\n", LocalAdapter.TotalSize );
        dprintf( "    HeaderSize                = %d\n", LocalAdapter.HeaderSize );
        dprintf( "    IPHeaderOffset            = %d\n", LocalAdapter.IPHeaderOffset );
        dprintf( "\n");
        
        dprintf( "    Admission Control details \n");
        dprintf( "    ------------------------- \n");
        dprintf( "        RawLinkSpeed              = %d \n", LocalAdapter.RawLinkSpeed);
        dprintf( "        BestEffortLimit           = %d \n", LocalAdapter.BestEffortLimit);
        dprintf( "        NonBestEffortLimit        = %d \n", LocalAdapter.NonBestEffortLimit);
        dprintf( "        ReservationLimitValue     = %d \n", LocalAdapter.ReservationLimitValue);
        dprintf( "        Link Speed                = %dbps\n", LocalAdapter.LinkSpeed);
        dprintf( "        RemainingBandWidth        = %dBps\n", LocalAdapter.RemainingBandWidth );
        dprintf( "        VCIndex                   = %d\n", LocalAdapter.VcIndex.QuadPart );
        dprintf( "        PipeHasResources          = %s \n", LocalAdapter.PipeHasResources ? "TRUE" : "FALSE");
        dprintf( "\n");

        dprintf( "    NDIS Handles, etc \n");
        dprintf( "    ----------------- \n");
        dprintf( "        BindContext               = %08X \n", LocalAdapter.BindContext);
        dprintf( "        Send PacketPoolHandle     = %08X \n", LocalAdapter.SendPacketPool);
        dprintf( "        Recv PacketPoolHandle     = %08X \n", LocalAdapter.RecvPacketPool);

        dprintf( "\n");
        

        dprintf( "    Best Effort VC \n");
        dprintf( "    -------------- \n");
        dprintf( "        BestEffortVc              = %08X \n", &TargetAdapter->BestEffortVc);
        dprintf( "        GPC Client VC List        @ %08X ",   &TargetAdapter->GpcClientVcList);

        if(&TargetAdapter->GpcClientVcList == LocalAdapter.GpcClientVcList.Flink) 
        {
            dprintf( " (empty) ");
        }
        dprintf("\n");
        dprintf( "        CfinfosInstalled          = %d \n", LocalAdapter.CfInfosInstalled);
        dprintf( "        FlowsInstalled            = %d \n", LocalAdapter.FlowsInstalled); 
#if DBG
        dprintf( "        GpcNotifyPending          = %d \n", LocalAdapter.GpcNotifyPending); 
#endif
        
        dprintf( " \n");

        dprintf( "    Scheduling Components \n");
        dprintf( "    --------------------- \n");
        dprintf( "        PsComponent               = %08X \n", LocalAdapter.PsComponent);
        dprintf( "        PsPipeContext             = %08X \n", LocalAdapter.PsPipeContext);
        dprintf( "        PipeContextLength         = %d \n", LocalAdapter.PipeContextLength);
        dprintf( "        FlowContextLength         = %d \n", LocalAdapter.FlowContextLength);
        dprintf( "        PacketContextLength       = %d \n", LocalAdapter.PacketContextLength);
        dprintf( "        ClassMapContextLength     = %d \n", LocalAdapter.ClassMapContextLength);
        dprintf( "        PipeFlags                 = %08X\n", LocalAdapter.PipeFlags );
        dprintf( "        MaxOutstandingSends       = 0x%08X \n", LocalAdapter.MaxOutstandingSends);
        dprintf( "\n");

        dprintf( "\n");
        dprintf( "    NDISWAN \n");
        dprintf( "    ------- \n");
        dprintf( "        WanCmHandle               = %08X \n", LocalAdapter.WanCmHandle);
        dprintf( "        WanBindingState           = %08X \n", LocalAdapter.WanBindingState);
        dprintf( "        WanLinkCount              = %08X \n", LocalAdapter.WanLinkCount);
        dprintf( "        WanLinkList               @ %08X ", &TargetAdapter->WanLinkList);

        if(&TargetAdapter->WanLinkList == LocalAdapter.WanLinkList.Flink) {
            dprintf( " (empty) \n");
        }
        else {
            dprintf( " Next = %08X \n", LocalAdapter.WanLinkList.Flink);
        }
        dprintf( "        ISSLOWPacketSize          = %08X \n", LocalAdapter.ISSLOWPacketSize);
        dprintf( "        ISSLOWFragmentSize        = %08X \n", LocalAdapter.ISSLOWFragmentSize);
        dprintf( "        ISSLOWTokenRate           = %08X \n", LocalAdapter.ISSLOWTokenRate);
        dprintf("\n");
        dprintf( "    Adaptermode               = %s   \n", AdapterMode[LocalAdapter.AdapterMode]);
        }
        dprintf( "\n" );


        if ( PSName != NULL )
            free( PSName );

        if ( MPName != NULL )
            free( MPName );

        if ( WMIName != NULL) 
            free ( WMIName);

        if ( RegistryPath != NULL)
            free(RegistryPath);

        if ( ProfileName != NULL)
            free(ProfileName);

        if ( !DumpAllAdapters ) {

            break;

        } else {

            TargetAdapter = (PADAPTER)LocalAdapter.Linkage.Flink;
        }

        if (CheckControlC()) {
            return;
        }
    }
} // adapter


DECLARE_API( cvc )
{
    GPC_CLIENT_VC LocalClientVC;
    PGPC_CLIENT_VC TargetClientVC;

    if ( *args == '\0' ) {

        dprintf("ClientVC <address of ClientVC structure>\n");
        return;
    }

    TargetClientVC =  (PGPC_CLIENT_VC)GetExpression( args );

    if ( !TargetClientVC) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read ClientVC struct out of target's memory
    //
    KD_READ_MEMORY(TargetClientVC, &LocalClientVC, sizeof(GPC_CLIENT_VC));

    DumpGpcClientVc("", TargetClientVC, &LocalClientVC);

} // cvc


DECLARE_API( astats )
/*
 *   dump an adapter's stats structure
 */
{
    PADAPTER TargetAdapter;
    ADAPTER LocalAdapter;
    PADAPTER LastAdapter;
    LIST_ENTRY LocalListHead;
    PLIST_ENTRY TargetListHead;
    PWSTR Name;
    BOOLEAN DumpAllAdapters = FALSE;
    ULONG bytes;

    if ( *args == '\0' ) {

        //
        // run down the adapter list, dumping the contents of each one
        //

        TargetListHead = (PLIST_ENTRY)GetExpression( "psched!AdapterList" );

        if ( !TargetListHead ) {

            dprintf("Can't convert psched!AdapterList symbol\n");
            return;
        }

        //
        // read adapter listhead out of target's memory
        //
        KD_READ_MEMORY(TargetListHead, &LocalListHead, sizeof(LIST_ENTRY));

        TargetAdapter = (PADAPTER)LocalListHead.Flink;
        LastAdapter = (PADAPTER)TargetListHead;
        DumpAllAdapters = TRUE;

    } else {

        TargetAdapter =  (PADAPTER)GetExpression( args );

        if ( !TargetAdapter ) {

            dprintf("bad string conversion (%s) \n", args );
            return;

        }

        LastAdapter = 0;
    }

    while ( TargetAdapter != LastAdapter ) {

        //
        // read adapter struct out of target's memory
        //
        KD_READ_MEMORY(TargetAdapter, &LocalAdapter, sizeof(ADAPTER));


        //
        // alloc some mem for the name and get that too
        //

        bytes = ( LocalAdapter.WMIInstanceName.Length + 1 ) * sizeof( WCHAR );
        Name = (PWSTR)malloc( bytes );
        if ( Name != NULL ) {

            KD_READ_MEMORY(((PADAPTER)TargetAdapter+1), Name, bytes);

        }

        dprintf( "\nAdapter Stats @ %08X (%ws)\n\n", TargetAdapter, Name );
        DumpAdapterStats( &LocalAdapter.Stats, "    " );

        if ( Name != NULL )
            free( Name );

        if ( !DumpAllAdapters ) {

            break;
        } else {

            TargetAdapter = (PADAPTER)LocalAdapter.Linkage.Flink;
        }

        if (CheckControlC()) {
            return;
        }
    }
} // astats


VOID
DumpAdapterStats(
    PPS_ADAPTER_STATS Stats,
    PCHAR Indent
    )
{
    dprintf( "%sOut of Packets = %d\n", Indent, Stats->OutOfPackets );

    dprintf( "%sFlows Opened = %d\n", Indent, Stats->FlowsOpened );
    dprintf( "%sFlows Closed = %d\n", Indent, Stats->FlowsClosed );
    dprintf( "%sFlows Rejected = %d\n", Indent, Stats->FlowsRejected );
    dprintf( "%sFlows Modified = %d\n", Indent, Stats->FlowsModified );
    dprintf( "%sFlows ModsRejected = %d\n", Indent, Stats->FlowModsRejected );
    dprintf( "%sFlows MaxSimultaneousFlows = %d\n", Indent, Stats->MaxSimultaneousFlows );

}

DECLARE_API( help )
{
    dprintf("PS kd extensions\n\n");
    dprintf("adapter    [address]           - dump adapter structure\n");
    dprintf("astats     [adapter address]   - dump adapter stats\n");
    dprintf("cvc        <address>           - dump client VC struct\n");
    dprintf("diff       <address>           - dump diffserv mapping \n");
    dprintf("fstats     [vc address]        - dump VC stats\n");
    dprintf("help                           - This help screen \n");
    dprintf("iph        <address>           - Dumps the IP header \n");
    dprintf("list       <address>           - Dumps the entries of a list \n");
    dprintf("lock       <address>           - Dumps the lock info \n");
    dprintf("ndisp      <address>           - Dumps the NDIS_PACKET \n");
    dprintf("netl       <address>           - Dumps the NETWORK_ADDRESS_LIST structure \n");
    dprintf("psdso      Struct [<address>]  - Structo on the structure \n");
    dprintf("tt         [<filename>]        - Dumps psched log on c:\\tmp\\<filename> or stdout \n");
    dprintf("upri       <address>           - Dumps the 802.1p value \n");
    dprintf("vc         <adapter address>   - Dumps the list of VCs on an adapter \n");
    dprintf("version                        - Displays version information \n");
    dprintf("wan        <adapter address>   - Dumps the list of WanLinks on an adapter \n");
    dprintf("wanlink    <address>           - Dumps the Wanlink Structure\n");

}

    
DECLARE_API( ndisp )
{
    PNDIS_PACKET TargetPacket;
    NDIS_PACKET  LocalPacket;
    MDL  *CurrentMdl;
    LONG MDLCnt = 0;

    if ( *args == '\0' ) {

        dprintf("ndisp <address of NDIS_PACKET> \n");
        return;
    }

    TargetPacket =  (PNDIS_PACKET)GetExpression( args );

    if ( !TargetPacket ) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read client struct out of target's memory
    //
    KD_READ_MEMORY((ULONG)TargetPacket, &LocalPacket, sizeof(NDIS_PACKET));

    dprintf("\nNDIS_PACKET @ %08X \n", TargetPacket);
    dprintf("    Private \n");
    dprintf("        Physical Count         : 0x%x (%d) \n", LocalPacket.Private.PhysicalCount,
            LocalPacket.Private.PhysicalCount);
    dprintf("        TotalLength            : 0x%x (%d) \n", LocalPacket.Private.TotalLength,
            LocalPacket.Private.TotalLength);
    dprintf("        Head                   : 0x%x      \n", LocalPacket.Private.Head);
    dprintf("        Tail                   : 0x%x      \n", LocalPacket.Private.Tail);
    dprintf("        Pool                   : 0x%x      \n", LocalPacket.Private.Pool);
    dprintf("        Count                  : 0x%x (%d) \n", LocalPacket.Private.Count,
            LocalPacket.Private.Count);
    dprintf("        Flags                  : 0x%x (%d) \n", LocalPacket.Private.Flags, 
            LocalPacket.Private.Flags);
    dprintf("        ValidCounts            : 0x%x (%d) \n", LocalPacket.Private.ValidCounts,
            LocalPacket.Private.ValidCounts);
    dprintf("        NdisPacketFlags        : 0x%x (%d) \n", LocalPacket.Private.NdisPacketFlags,
            LocalPacket.Private.NdisPacketFlags);
    dprintf("        NdisPacketOobOffset    : 0x%x (%d) \n", LocalPacket.Private.NdisPacketOobOffset,
            LocalPacket.Private.NdisPacketOobOffset);

    CurrentMdl = LocalPacket.Private.Head;


    while(CurrentMdl != 0) {

        MDL *TargetMdl;
        MDL LocalMdl;
        
        dprintf("\n    MDL # %d\n", ++MDLCnt);
        TargetMdl = CurrentMdl;

        if ( !TargetMdl ) {

            dprintf("bad string conversion (%s) \n", CurrentMdl );
            return;
        }

        //
        // read client struct out of target's memory
        //

        KD_READ_MEMORY( TargetMdl, &LocalMdl, sizeof(MDL));

        dprintf("        Next                   : 0x%x       \n", LocalMdl.Next);
        dprintf("        Size                   : 0x%x (%d)  \n", LocalMdl.Size, LocalMdl.Size);
        dprintf("        MdlFlags               : 0x%x (%d)  \n", LocalMdl.MdlFlags, 
                LocalMdl.MdlFlags);
        dprintf("        Process                : 0x%x       \n", LocalMdl.Process);
        dprintf("        MappedSystemVa         : 0x%x       \n", LocalMdl.MappedSystemVa);
        dprintf("        StartVa                : 0x%x       \n", LocalMdl.StartVa);
        dprintf("        ByteCount              : 0x%x (%d)  \n", LocalMdl.ByteCount, 
                LocalMdl.ByteCount);
        dprintf("        ByteOffset             : 0x%x (%d)  \n", LocalMdl.ByteOffset, 
                LocalMdl.ByteOffset);

        CurrentMdl = LocalMdl.Next;
    }
}

DECLARE_API(iph) 
{
    IPHeader *TargetPacket;
    IPHeader  LocalPacket;
    LONG MDLCnt = 0;

    if ( *args == '\0' ) {

        dprintf("iph <address of IP header> \n");
        return;
    }

    TargetPacket =  (IPHeader *) GetExpression( args );

    if ( !TargetPacket ) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read client struct out of target's memory
    //

    KD_READ_MEMORY(TargetPacket, &LocalPacket, sizeof(IPHeader));

    dprintf("IPHeader @ %08X \n", TargetPacket);
    dprintf("    Version                  : %x \n", (LocalPacket.iph_verlen >> 4 ) & 0x0f);
    dprintf("    Header Length            : %x \n", LocalPacket.iph_verlen & 0x0f);
    dprintf("    TOS                      : %x \n", LocalPacket.iph_tos);
    dprintf("    Length                   : %x \n", ntohs(LocalPacket.iph_length));
    dprintf("    ID                       : %x \n", ntohs(LocalPacket.iph_id));
    dprintf("    Offset                   : %x \n", ntohs(LocalPacket.iph_offset));
    dprintf("    TTL                      : %x \n", LocalPacket.iph_ttl);
    dprintf("    Protocol                 : ");

    switch(LocalPacket.iph_protocol) {
        case 1:
            dprintf("ICMP (%d) \n", LocalPacket.iph_protocol);
            break;
        case 2:
            dprintf("IGMP (%d) \n", LocalPacket.iph_protocol);
            break;
        case 6:
            dprintf("TCP  (%d) \n", LocalPacket.iph_protocol);
            break;
        case 17:
            dprintf("UDP  (%d) \n", LocalPacket.iph_protocol);
            break;
        default:
            dprintf("Unknown (%d) \n", LocalPacket.iph_protocol);
            break;
    }

    //
    // Validate Header checksum
    //
    dprintf("    Checksum                 : %x ", LocalPacket.iph_xsum);
    if(IPHeaderXsum(&LocalPacket, sizeof(IPHeader)) == 0) {
        dprintf("(Good) \n");
    }
    else {
        dprintf("(Bad) \n");
    }

    {
        struct in_addr ip;
        ip.s_addr = LocalPacket.iph_src;
        dprintf("    Source                   : %s \n", inet_ntoa(ip));
        ip.s_addr = LocalPacket.iph_dest;
        dprintf("    Dest                     : %s \n", inet_ntoa(ip));
    }

}

DECLARE_API( upri )
{
    PNDIS_PACKET TargetPacket;
    NDIS_PACKET  LocalPacket;
    MDL  *CurrentMdl;
    LONG MDLCnt = 0;
    NDIS_PACKET_EXTENSION PerPacketInfo;

    if ( *args == '\0' ) {

        dprintf("ndisp <address of NDIS_PACKET> \n");
        return;
    }

    TargetPacket =  (PNDIS_PACKET)GetExpression( args );

    if ( !TargetPacket ) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read client struct out of target's memory
    //
    KD_READ_MEMORY(TargetPacket, &LocalPacket, sizeof(NDIS_PACKET));

    TargetPacket = (PNDIS_PACKET)((PUCHAR)TargetPacket +
                       LocalPacket.Private.NdisPacketOobOffset +
                        sizeof(NDIS_PACKET_OOB_DATA));

    KD_READ_MEMORY(TargetPacket, &PerPacketInfo, sizeof(NDIS_PACKET_EXTENSION));
    dprintf("802.1p Priority in packet is 0x%x \n", 
            PerPacketInfo.NdisPacketInfo[Ieee8021pPriority]);

    return;
}

DECLARE_API( wanlink )
{
    PPS_WAN_LINK Target;
    PS_WAN_LINK  Local;

    PCHAR DialUsage[] = {"DU_CALLIN", "DU_CALLOUT", "DU_ROUTER"}; 

    if ( *args == '\0' ) {

        dprintf("wanlink <address of wanlink> \n");
        return;
    }

    Target=  (PPS_WAN_LINK) GetExpression( args );

    if ( !Target) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read client struct out of target's memory
    //
    KD_READ_MEMORY(Target, &Local, sizeof(PS_WAN_LINK));

    dprintf("WanLink @ %08X \n", Target);
    dprintf("    RefCount                     : %d \n", Local.RefCount);
    dprintf("    Dial Usage                   : %s \n", DialUsage[Local.DialUsage]);
    dprintf("    RawLinkSpeed                 : %d \n", Local.RawLinkSpeed);
    dprintf("    LinkSpeed                    : %d \n", Local.LinkSpeed);
    dprintf("    Lock                         : 0x%x \n", Local.Lock);
    dprintf("    Stats                        @ 0x%x \n", &Target->Stats);

    dprintf("    Addresses \n");
    dprintf("    --------- \n");
    dprintf("        Remote Address           : %02x:%02x:%02x:%02x:%02x:%02x \n",
            Local.OriginalRemoteMacAddress[0], Local.OriginalRemoteMacAddress[1],
            Local.OriginalRemoteMacAddress[2], Local.OriginalRemoteMacAddress[3], 
            Local.OriginalRemoteMacAddress[4], Local.OriginalRemoteMacAddress[5]);
    dprintf("        Local Address            : %02x:%02x:%02x:%02x:%02x:%02x \n",
            Local.OriginalLocalMacAddress[0], Local.OriginalLocalMacAddress[1],
            Local.OriginalLocalMacAddress[2], Local.OriginalLocalMacAddress[3], 
            Local.OriginalLocalMacAddress[4], Local.OriginalLocalMacAddress[5]);

    dprintf("    Protocol \n");
    dprintf("    -------- \n");
    dprintf("        ProtocolType             : ");

    switch(Local.ProtocolType) {
      case PROTOCOL_IP:
          {
              struct in_addr ip;
              dprintf("IP \n");
              ip.s_addr = Local.LocalIpAddress;
              dprintf("        Address (Local)          : %s \n", inet_ntoa(ip));
              ip.s_addr = Local.RemoteIpAddress;
              dprintf("        Address (Remote)         : %s \n", inet_ntoa(ip));
          }
          break;
          
      case PROTOCOL_IPX:
          dprintf("IPX \n");
          dprintf("        Address (Local)          : %d \n", Local.LocalIpxAddress);
          dprintf("        Address (Remote)         : %d \n", Local.RemoteIpxAddress);
          break;

      default:
          dprintf("Unknown \n");
          break;
    }

    return;
}

DECLARE_API( vc )
/*
 *   dump all the VCs on an adapter
 */
{
    PADAPTER TargetAdapter;
    ADAPTER  LocalAdapter;
    PGPC_CLIENT_VC Target;
    GPC_CLIENT_VC  Local;
    LIST_ENTRY  TargetList;
    PLIST_ENTRY pL;
    ULONG        bytes;

    if ( *args != '\0' ) {

        TargetAdapter =  (PADAPTER)GetExpression( args );

        if ( !TargetAdapter ) {

            dprintf("bad string conversion (%s) \n", args );

            return;

        }

        //
        // read adapter struct out of target's memory
        //
        KD_READ_MEMORY(TargetAdapter, &LocalAdapter, sizeof(ADAPTER));


        TargetList = LocalAdapter.GpcClientVcList;

        pL = (PLIST_ENTRY) TargetList.Flink;

        while ( pL != &TargetAdapter->GpcClientVcList) {

            //
            // read ClientVC struct out of target's memory
            //

            Target = CONTAINING_RECORD(pL, GPC_CLIENT_VC, Linkage);

            KD_READ_MEMORY(Target, &Local, sizeof(GPC_CLIENT_VC));

            dprintf(" ---------------------------------------------- \n");

            dprintf( "      GpcClientVc @ %08X: State %d, Flags 0x%x, Ref %d \n\n", Target, 
                     Local.ClVcState, Local.Flags, Local.RefCount);

            pL =  Local.Linkage.Flink;

        }
    }
}

DECLARE_API(fstats)
{

    GPC_CLIENT_VC LocalClientVC;
    PGPC_CLIENT_VC TargetClientVC;

    if ( *args == '\0' ) {

        dprintf("Flow Stats <address of ClientVC structure>\n");
        return;
    }

    TargetClientVC =  (PGPC_CLIENT_VC) GetExpression( args );

    if ( !TargetClientVC) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read ClientVC struct out of target's memory
    //
    KD_READ_MEMORY(TargetClientVC, &LocalClientVC, sizeof(GPC_CLIENT_VC));

    dprintf( " Stats for Vc %x \n", TargetClientVC);
    dprintf( " ----------------- \n");

    dprintf( " VC Stats \n");
    dprintf( "    Dropped Packets        = %d \n", LocalClientVC.Stats.DroppedPackets);
    dprintf( "    Packets Scheduled      = %d \n", LocalClientVC.Stats.PacketsScheduled);
    dprintf( "    Packets Transmitted    = %d \n", LocalClientVC.Stats.PacketsTransmitted);
    dprintf( "    Bytes   Transmitted    = %ld\n", LocalClientVC.Stats.BytesTransmitted.QuadPart);
    dprintf( "    Bytes   Scheduled      = %ld\n", LocalClientVC.Stats.BytesScheduled.QuadPart);

    dprintf( " Conformr Stats \n");

    dprintf( " Shaper stats \n");

    dprintf( " SequencerStats \n");

}

DECLARE_API(netl)
{
    PNETWORK_ADDRESS_LIST Target;
    NETWORK_ADDRESS_LIST Local;
    LONG i;

    if ( *args == '\0' ) {

        dprintf("netl <address>\n");
        return;
    }

    Target =  (PNETWORK_ADDRESS_LIST) GetExpression( args );

    if ( !Target) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read ClientVC struct out of target's memory
    //
    KD_READ_MEMORY(Target, &Local, FIELD_OFFSET(NETWORK_ADDRESS_LIST,Address));

    dprintf("Network Address List @ 0x%x \n", Target);

    dprintf("    AddressCount          = %d \n", Local.AddressCount);
    dprintf("    AddressType           = %d \n\n", Local.AddressType);

        Target = (PNETWORK_ADDRESS_LIST)((PUCHAR)Target + FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address));

    for(i=0; i<Local.AddressCount; i++)
    {
        NETWORK_ADDRESS_IP  ipAddr;
        NETWORK_ADDRESS_IPX ipxAddr;
        NETWORK_ADDRESS LocalN;

        //
        // Parse the NETWORK_ADDRESS
        //
        KD_READ_MEMORY(Target, &LocalN, FIELD_OFFSET(NETWORK_ADDRESS, Address));

        dprintf("        AddressLength     = %d \n", LocalN.AddressLength);
        dprintf("        AddressType       = %d \n", LocalN.AddressType);

        //
        // Read the Address
        //

        Target = (PNETWORK_ADDRESS_LIST)((PUCHAR)Target + FIELD_OFFSET(NETWORK_ADDRESS, Address));
    
        switch(LocalN.AddressType)
        {
            case NDIS_PROTOCOL_ID_TCP_IP:
            {
                struct in_addr ip;
                KD_READ_MEMORY(Target, &ipAddr, sizeof(NETWORK_ADDRESS_IP));
                ip.s_addr = ipAddr.in_addr;
                dprintf("        sin_port          = %d \n", ipAddr.sin_port);
                dprintf("        in_addr           = %s \n", inet_ntoa(ip));
                break;
            }

            default:
                dprintf("        *** ERROR : Unrecognized protocol \n");
                break;
        }

        dprintf("        ---------------------------- \n");
    }
    
}

DECLARE_API( wan )
/*
 *   dump all the VCs on an adapter
 */
{
    PADAPTER TargetAdapter;
    ADAPTER  LocalAdapter;
    PPS_WAN_LINK Target;
    PS_WAN_LINK  Local;
    LIST_ENTRY  TargetList;
    PLIST_ENTRY pL;
    ULONG        bytes;

    if ( *args != '\0' ) {

        TargetAdapter =  (PADAPTER)GetExpression( args );

        if ( !TargetAdapter ) {

            dprintf("bad string conversion (%s) \n", args );

            return;

        }

        //
        // read adapter struct out of target's memory
        //
        KD_READ_MEMORY(TargetAdapter, &LocalAdapter, sizeof(ADAPTER));


        TargetList = LocalAdapter.WanLinkList;

        pL = (PLIST_ENTRY) TargetList.Flink;

        while ( pL != &TargetAdapter->WanLinkList) {

            //
            // read ClientVC struct out of target's memory
            //

            Target = CONTAINING_RECORD(pL, PS_WAN_LINK, Linkage);

            KD_READ_MEMORY(Target, &Local, sizeof(PS_WAN_LINK));

            dprintf(" ---------------------------------------------- \n");

            dprintf( "     WanLink @ %08X\n\n", Target);

            pL =  Local.Linkage.Flink;

        }
    }
}

DECLARE_API( lock )
{
#if DBG
    PPS_SPIN_LOCK Target;
    PS_SPIN_LOCK  Local;
    ULONG        bytes;

    if ( *args != '\0' ) {

        Target =  (PPS_SPIN_LOCK)GetExpression( args );

        if ( !Target) {

            dprintf("bad string conversion (%s) \n", args );

            return;

        }

        //
        // read adapter struct out of target's memory
        //
        KD_READ_MEMORY(Target, &Local, sizeof(PS_SPIN_LOCK));

        if(Local.LockAcquired == TRUE)
        {
                dprintf("    Acquired          : TRUE \n");
                dprintf("    LastAcquiredFile  : %s \n", Local.LastAcquiredFile);
                dprintf("    LastAcquiredLine  : %d \n", Local.LastAcquiredLine);
        }
        else
        {
                dprintf("    Acquired          : FALSE \n");
                dprintf("    LastReleasedFile  : %s \n", Local.LastReleasedFile);
                dprintf("    LastReleasedLine  : %d \n", Local.LastReleasedLine);
        }
    }

    return;
#endif

}

DECLARE_API(diff)
{
    PDIFFSERV_MAPPING TargetA;
    DIFFSERV_MAPPING LocalA;
    int i;

    if ( *args == '\0' )
    {
        dprintf("diff <address>\n");
        return;
    }

    TargetA =  (PDIFFSERV_MAPPING)GetExpression( args );

    if ( !TargetA) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }


    dprintf("TOS    : The Entire 8 bit DSField as it appears in the IP header \n");
    dprintf("DSCP   : The differentiated services code point (higher order 6 bits of above) \n");
    dprintf("Prec   : The precedence value (above field with bits swapped around \n");
    dprintf("OC-TOS : The Entire 8 bit DS field on outbound packets for conforming packets\n");
    dprintf("ONC-TOS: The Entire 8 bit DS field on outbound packets for non-conforming packets\n");
    dprintf("\n");

    dprintf("TOS    DSCP    Prec   OC-TOS  ONC-TOS     VC \n");
    dprintf("---------------------------------------------------------------------------------------\n");
    for(i=0; i<PREC_MAX_VALUE; i++)
    {
        //
        // read ClientVC struct out of target's memory
        //
        KD_READ_MEMORY(TargetA, &LocalA, sizeof(DIFFSERV_MAPPING));

        TargetA = (PDIFFSERV_MAPPING)((PUCHAR)TargetA + sizeof(DIFFSERV_MAPPING));

        //if(LocalA.Vc != 0)
        {
            dprintf("0x%2x   0x%2x    0x%2x    0x%2x    0x%2x    0x%8x\n",
                     i<<2,
                     i,
                     //BitShift(i),
                     0,
                     LocalA.ConformingOutboundDSField,
                     LocalA.NonConformingOutboundDSField,
                     LocalA.Vc);
        }
    }
    dprintf("---------------------------------------------------------------------------------------\n");
}

DECLARE_API( list )
{
    LIST_ENTRY  Target, Local, TargetList;
    PLIST_ENTRY head, pL;
    ULONG        bytes;

    if ( *args != '\0' ) {

        head = pL = (PLIST_ENTRY) GetExpression( args );

        if ( !pL) {

            dprintf("bad string conversion (%s) \n", args );

            return;

        }

        //
        // read adapter struct out of target's memory
        //
        KD_READ_MEMORY(pL, &Local, sizeof(LIST_ENTRY));

        while ( Local.Flink != head) 
        {
            pL = Local.Flink;

            if(pL == 0)
            {   
                dprintf("Local = %x %x \n", Local.Flink, Local.Blink);
            }
            else 
            {
                dprintf("%x \n", pL);
            }

            KD_READ_MEMORY(pL, &Local, sizeof(LIST_ENTRY));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\kdext\logger.c ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This function contains some example KD debugger extensions

Author:

    John Vert (jvert) 6-Aug-1992

Revision History:

--*/

#include "precomp.h"

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

// Forward function definitions 

PCHAR
FindPreamble(
    CHAR * BufferPointer,
    BOOLEAN FirstTime
    );

VOID
ParseBuffer(
    CHAR * DataStart,
    ULONG SkipCnt
    );

PCHAR 
ParseOidRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    );

PCHAR
ParseTimeRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    );

PCHAR
ParseStringRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    );

PCHAR
ParseSchedRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    );

PCHAR
ParseRecvRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    );

PCHAR
ParseSendRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    );

static PCHAR SchedModules[] = {
    "NOP",
    "TB CONFORMER",
    "SHAPER",
    "DRR SEQ",
    "CBQ"};

static PCHAR SchedActions[] = {
    "NOP",
    "ENQUEUE",
    "DEQUEUE",
    "CONFORMANCE",
    "DISCARD"};

static PCHAR SendRecvActions[] = {
    "",
    "ENTER",
    "NO_RESOURCES",
    "LOW_RESOURCES",
    "INDICATING",
    "RETURNED",
    "NOT_OURS",
    "OURS",
    "RETURNING",
    "TRANSFERRING",
    "NOT READY"};

static PCHAR RecvEvents[] = {
    "",
    "CL_RECV_PACKET",
    "MP_RETURN_PACKET",
    "CL_RECV_INDICATION",
    "CL_RECV_COMPLETE",
    "MP_TRANSFER_DATA",
    "CL_TRANSFER_COMPLETE"};

static PCHAR SendEvents[] = {
    "",
    "MP_SEND",
    "MP_CO_SEND",
    "DUP_PACKET",
    "DROP_PACKET",
    "CL_SEND_COMPLETE" };

        

//
// globals
//

CHAR Preamble[] = {(CHAR)0xef,(CHAR)0xbe,(CHAR)0xad,(CHAR)0xde};

ULONG  ByteCheck = 0;
ULONG  SafetyLimit;

BOOL
SafeRead(
    DWORD offset, 
    LPVOID lpBuffer, 
    DWORD cb, 
    LPDWORD lpcbBytesRead
    )
{
    if(ByteCheck <= SafetyLimit){
        ReadMemory(offset, lpBuffer, cb, lpcbBytesRead);
        ByteCheck += cb;
        return TRUE;
    }
    else{
        dprintf("SafetyLimit of %d, exceeded, quitting!\n", SafetyLimit);
        return FALSE;
    }
}

DWORD
MyOpenFile (
    IN PCHAR Name,
    IN PWINDBG_OUTPUT_ROUTINE out,
    OUT HANDLE *File
    )

{
    HANDLE hFile;
    hFile = CreateFile(Name,
                          GENERIC_WRITE | GENERIC_READ,
                          0,
                          NULL,
                          CREATE_ALWAYS ,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);

    if (INVALID_HANDLE_VALUE == hFile) {
        out ("MyOpenFile: CreateFile Failed.\n");
    }

    *File = hFile;

    return(INVALID_HANDLE_VALUE == hFile ? (!(ERROR_SUCCESS)) : ERROR_SUCCESS);
}

VOID
MyWriteFile (
    PCHAR buffer,
    HANDLE file,
    IN PWINDBG_OUTPUT_ROUTINE out
    )

{
    LONG  len;
    BOOL bRv;
        DWORD dwWritten;

        if (!buffer) {
        out("MyWriteFile: Buffer is null\n");
    }

    len = strlen(buffer);

    bRv = WriteFile( file, buffer, len, &dwWritten, NULL );

    if (!bRv) {
        out("WriteFile: Puked\n");
        }
}

CHAR * BufferBase;          // Start address of trace buffer, in host memory
CHAR * BufferEnd;           // End address of trace buffer, in host memory
CHAR * BufferPointer;       // Current location in host memory buffer
LONG   BufferSize;          // Total size of host memory buffer, in bytes.
LONG   BufferCount;         // Total count of traced bytes.
LONG   TotalValidBytesRead = 0;

#define OUTPUT_ERROR   0
#define OUTPUT_FILE    1
#define OUTPUT_CONSOLE 2

CHAR   FileIt;
HANDLE FileHandle;
ULONG   LineNumber = 0;

DECLARE_API( tt )
{
    DWORD hostAddress;
    CHAR  DeviceName[] = "c:\\tmp\\";
    CHAR  buffer[255];
    DWORD status;
    LONG  pBufferBase;
    LONG  pBufferCount;
    LONG  pBufferSize;
    BOOL  success;
    DWORD bytesread;
    CHAR *s, *dataStart;
    ULONG skip=0;

    char SchedBufBase[]   = {"&psched!SchedTraceBuffer"};
    char SchedCount[]     = {"&psched!SchedTraced"};
    char BuffSize[]       = {"&psched!SchedBufferSize"};

    TotalValidBytesRead = 0;
    LineNumber = 0;
    FileIt = OUTPUT_ERROR;
    
    if ( *args != '\0' ) {

        // First argument is the file name.
        s = strtok((LPSTR)args, " ");

        strcpy( buffer, DeviceName );
        strcat( buffer, s );

        // next arg is the optional args.
        while((s = strtok(NULL, " ")) != NULL)
        {
            if(s[0] == '-')
            {
                switch(s[1])
                {
                  case 's':
                  case 'S':
                      skip = atoi(&s[2]);
                      break;

                  default:
                      dprintf("Usage: !tt [filename] [-S<#>] \n");
                      dprintf("       S : No of records (from head) to skip \n");
                      goto cleanup;

                }
            }
        }
        
        status = MyOpenFile( buffer, dprintf, &FileHandle );
        if ( status == ERROR_SUCCESS ) {
            FileIt = OUTPUT_FILE;
        }
        else {
            goto cleanup;
        }
        dprintf( "handle =%x status=%x FileIt=%d\n", FileHandle, status, FileIt );
    }
    else {
        FileIt = OUTPUT_CONSOLE;
    }

    hostAddress =  GetExpression(SchedBufBase);
    pBufferBase =  (LONG)hostAddress;
    
    if (!pBufferBase){
        dprintf("bad string conversion (%s) \n", SchedBufBase);
        goto cleanup;
    }

    hostAddress  = GetExpression(SchedCount);
    pBufferCount = hostAddress;

    if (!pBufferCount) {
        dprintf( " bad string conversion (%s) \n", SchedCount );
        goto cleanup;
    }

    hostAddress =  GetExpression(BuffSize);
    pBufferSize = hostAddress;

    if (!pBufferSize) {
        dprintf( " bad string conversion (%s) \n", SchedCount );
        goto cleanup;
    }

    success = ReadMemory((ULONG)pBufferCount, &BufferCount, sizeof(LONG), &bytesread );
    if (!success){
        dprintf("problems reading memory at %x for %x bytes\n", pBufferCount, sizeof(LONG));
        goto cleanup;
    }

    success = ReadMemory((ULONG)pBufferSize, &BufferSize, sizeof(LONG), &bytesread );
    if (!success){
        dprintf("problems reading memory at %x for %x bytes\n", pBufferSize, sizeof(LONG));
        goto cleanup;
    }

    success = ReadMemory((ULONG)pBufferBase, &BufferBase, sizeof(LONG), &bytesread );
    if (!success){
        dprintf("problems reading memory at %x for %x bytes\n", pBufferBase, sizeof(LONG));
        goto cleanup;
    }

    SafetyLimit = (ULONG)-1;

    if(!BufferCount){
        dprintf("No data in buffer.\n");
        goto cleanup;
    }

    dprintf("struct@%x, total bytes traced: %d, buffer size: %d\n", BufferBase, BufferCount, BufferSize);

    // Find the starting point. If we haven't wrapped the buffer, it's at BufferBase.
    // If we have wrapped the buffer, we start right after our current pointer.
    // In either case, BufferPointer is the host address at which we should 
    // start looking for data.

    if(BufferCount <= BufferSize){
        BufferPointer = BufferBase;
    }
    else{
        BufferPointer = BufferBase + (BufferCount % BufferSize);
    } 

    BufferEnd = BufferBase + BufferSize;

    // dataStart will point to the first location after the
    // first preamble (in host memory), or - will be zero,
    // indicating that no preamble was found.

    dataStart = FindPreamble(BufferPointer, TRUE);

    if(dataStart){
        ParseBuffer(dataStart, skip);
    }
    else{
        dprintf("Error reading token trace buffer. Could not find preamble.\n");
    }

cleanup:
    if(FileIt == OUTPUT_FILE){
        CloseHandle( FileHandle );
    }
}

PCHAR
FindPreamble(
    CHAR * BufferPointer,
    BOOLEAN FirstTime
    )
{
    LONG count;
    LONG i;
    CHAR * readFrom;
    CHAR hold;
    BOOL success;
    DWORD bytesread;

    count = 0;
    i = 0;

    readFrom = BufferPointer;
    
    while(TRUE){
    
        success = SafeRead((ULONG)readFrom, &hold, 1, &bytesread );

        if (!success){
            dprintf("problems reading memory at %x for %x bytes\n", readFrom, 1);
            break;
        }

        if(hold == Preamble[i]){
            i++;
        }
        else{
            i=0;
        }

        if(i == sizeof(TRACE_PREAMBLE)){
            if(FirstTime){
                dprintf("Found start of first record at %d.\n", readFrom+1 - BufferBase);
            }
            TotalValidBytesRead += sizeof(TRACE_PREAMBLE);
            readFrom++;
            break;
        }

        readFrom++;

        if(readFrom > BufferEnd){
            readFrom = BufferBase;
        }

        count++;

        if(count == TRACE_BUFFER_SIZE){
            readFrom = 0;
            break;
        }
    }

    return(readFrom);
}

VOID
ParseBuffer(
    CHAR * DataStart,
    ULONG  SkipCnt
    )
{
    CHAR * dataStart;
    CHAR * recordEnd;
    LONG records;
    BOOL success;
    CHAR hold;
    DWORD bytesread;

    records = 0;
    dataStart = DataStart;

    while(TRUE){

        success = SafeRead((ULONG)dataStart, &hold, 1, &bytesread );

        if (!success){
            dprintf("problems reading memory at %x for %x bytes\n", dataStart, 1);
            break;
        }

        switch(hold){

        case RECORD_TSTRING:

            recordEnd = ParseStringRecord(dataStart, SkipCnt);
            break;

        case RECORD_OID:
            recordEnd = ParseOidRecord(dataStart,  SkipCnt);
            break;

        case RECORD_SCHED:

            recordEnd = ParseSchedRecord(dataStart,  SkipCnt);
            break;

        case RECORD_RECV:
            recordEnd = ParseRecvRecord(dataStart,  SkipCnt);
            break;

        case RECORD_SEND:
            recordEnd = ParseSendRecord(dataStart,  SkipCnt);
            break;
        default:

            dprintf("Unrecognized record type!\n");
        }

        records++;

        if(TotalValidBytesRead >= BufferCount){
            dprintf("\nCompleted parsing trace buffer. %d records found.\n", records);
            break;
        }

        dataStart = FindPreamble(recordEnd, FALSE);

        if(dataStart == DataStart){
            dprintf("\nCompleted parsing trace buffer. %d records found.\n", records);
            break;
        }
    }
}
    
VOID
GetBytesToRead(
    CHAR * DataStart,
    LONG RecordSize,
    LONG * BytesToReadFirst,
    LONG * BytesToReadNext
    )
{
    if((DataStart + RecordSize - sizeof(TRACE_PREAMBLE)) > BufferEnd){
        *BytesToReadFirst = BufferEnd - DataStart;
        *BytesToReadNext = RecordSize - sizeof(TRACE_PREAMBLE) - *BytesToReadFirst;
    }
    else{
        *BytesToReadFirst = RecordSize - sizeof(TRACE_PREAMBLE);
        *BytesToReadNext = 0;
    }
}

PCHAR
ParseAnyRecord(
    CHAR * DataStart,
    CHAR * Record,
    LONG   RecordSize
    )
{
    LONG bytesToReadFirst;
    LONG bytesToReadNext;
    BOOL success;
    CHAR * nextDataStart;
    DWORD bytesread;
    CHAR * pRecordData;
    CHAR buffer[255];
    
    GetBytesToRead(DataStart, RecordSize, &bytesToReadFirst, &bytesToReadNext);
    pRecordData = Record + sizeof(TRACE_PREAMBLE);
    
    success = SafeRead((ULONG)DataStart, pRecordData, bytesToReadFirst, &bytesread );
    TotalValidBytesRead += bytesToReadFirst;

    if (!success){
        dprintf("problems reading memory at %x for %x bytes\n", DataStart, 1);
    }

    nextDataStart = DataStart + bytesToReadFirst;

    if(bytesToReadNext){

        success = SafeRead((ULONG)BufferBase, 
                             pRecordData + bytesToReadFirst, 
                             bytesToReadNext, 
                             &bytesread);

        TotalValidBytesRead += bytesToReadNext;

        if (!success){
            dprintf("problems reading memory at %x for %x bytes\n", BufferBase, 1);
        }

        nextDataStart = BufferBase + bytesToReadNext;
    }

    return(nextDataStart);
}

PCHAR 
ParseOidRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    )
{
    TRACE_RECORD_OID record;
    CHAR buffer[255];
    CHAR * nextDataStart;
    static PCHAR OIDActions[] = 
    {
        "",
        "MpSetInformation",
        "MpQueryInformation",
        "SetRequestComplete",
        "QueryRequestComplete"
    };

    nextDataStart = ParseAnyRecord(DataStart, (CHAR *)&record, sizeof(TRACE_RECORD_OID));

    if(++LineNumber < SkipCnt)
        return nextDataStart;
    if(record.Now.QuadPart){

        wsprintf(buffer, "[%4d]:[%u.%u]: OID: %5s:%9s:%08X:%08X:%08X \n",
                 LineNumber,
                 record.Now.HighPart,
                 record.Now.LowPart,
                 OIDActions[record.Action],
                 record.Local == TRUE?"Local":"Non Local",
                 record.Adapter,
                 record.Oid,
                 record.Status);
    }
    else {
        wsprintf(buffer, "[%4d]: OID: %5s:%9s:%08X:%08X:%08X \n",
                 LineNumber,
                 OIDActions[record.Action],
                 record.Local == TRUE?"Local":"Non Local",
                 record.Adapter,
                 record.Oid,
                 record.Status);
    }

    switch(FileIt)
    {
        case OUTPUT_FILE:
            MyWriteFile(buffer, FileHandle, dprintf);
            break;
        case OUTPUT_CONSOLE:
            dprintf(buffer);
            break;
        default:
            dprintf("Failed to create file! Check for tmp directory.\n");
            break;
    }
    
    return(nextDataStart);
}


PCHAR
ParseStringRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    )
{
    TRACE_RECORD_STRING record;
    LONG bytesToReadFirst;
    LONG bytesToReadNext;
    BOOL success;
    CHAR * nextDataStart;
    DWORD bytesread;
    CHAR * pRecordData;
    CHAR buffer[255];
    
    nextDataStart = ParseAnyRecord(DataStart, (CHAR *)&record, sizeof(TRACE_RECORD_STRING));

    if(++LineNumber < SkipCnt)
        return nextDataStart;

    if(record.Now.QuadPart){
        wsprintf(buffer, "[%4d]:[%u.%u]:%s",
                LineNumber,
                record.Now.HighPart,
                record.Now.LowPart,
                record.StringStart);
    }
    else{
        wsprintf(buffer, "[%4d]:%s",
                LineNumber,
                record.StringStart);
    }
                
    switch(FileIt)
    {
        case OUTPUT_FILE:
            MyWriteFile(buffer, FileHandle, dprintf);
            break;
        case OUTPUT_CONSOLE:
            dprintf(buffer);
            break;
        default:
            dprintf("Failed to create file! Check for tmp directory.\n");
            break;
    }
    
    return(nextDataStart);
}

PCHAR
ParseSchedRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    )
{
    TRACE_RECORD_SCHED record;
    LONG bytesToReadFirst;
    LONG bytesToReadNext;
    BOOL success;
    CHAR * nextDataStart;
    DWORD bytesread;
    CHAR * pRecordData;
    ULONG now;
    CHAR buffer[255];
    LARGE_INTEGER ConformanceTime;
    
    nextDataStart = ParseAnyRecord(DataStart, (CHAR *)&record, sizeof(TRACE_RECORD_SCHED));
    if(++LineNumber < SkipCnt)
        return nextDataStart;
    ConformanceTime.QuadPart = record.ConformanceTime;

    wsprintf(buffer,
            "[%4d]:[%u.%u]:%s:VC %x:%x:%u:%s:%d:%d:%u:%u\n",
            LineNumber,
            record.Now.HighPart,
            record.Now.LowPart,
            SchedModules[record.SchedulerComponent],
            record.VC,
            record.Packet,
            record.PacketLength,
            SchedActions[record.Action],
            record.Priority,
            ConformanceTime.HighPart,
            ConformanceTime.LowPart,
            record.PacketsInComponent);
                
    switch(FileIt)
    {
        case OUTPUT_FILE:
            MyWriteFile(buffer, FileHandle, dprintf);
            break;
        case OUTPUT_CONSOLE:
            dprintf(buffer);
            break;
        default:
            dprintf("Failed to create file! Check for tmp directory.\n");
            break;
    }
    
    return(nextDataStart);
}

PCHAR
ParseRecvRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    )
{
    TRACE_RECORD_RECV record;
    LONG bytesToReadFirst;
    LONG bytesToReadNext;
    BOOL success;
    CHAR * nextDataStart;
    DWORD bytesread;
    CHAR * pRecordData;
    CHAR buffer[255];
    
    nextDataStart = ParseAnyRecord(DataStart, (CHAR *)&record, 
                                   sizeof(TRACE_RECORD_RECV));

    if(++LineNumber < SkipCnt)
        return nextDataStart;
    wsprintf(buffer,
            "[%4d]:[%u.%u]:Adapter %08X:%s:%s:%x:%x \n",
            LineNumber,
            record.Now.HighPart,
            record.Now.LowPart,
            record.Adapter,
            RecvEvents[record.Event],
            SendRecvActions[record.Action],
            record.Packet1,
            record.Packet2);
                
    switch(FileIt)
    {
        case OUTPUT_FILE:
            MyWriteFile(buffer, FileHandle, dprintf);
            break;
        case OUTPUT_CONSOLE:
            dprintf(buffer);
            break;
        default:
            dprintf("Failed to create file! Check for tmp directory.\n");
            break;
    }
    
    return(nextDataStart);
}

PCHAR
ParseSendRecord(
    CHAR * DataStart,
    ULONG SkipCnt
    )
{
    TRACE_RECORD_SEND record;
    LONG bytesToReadFirst;
    LONG bytesToReadNext;
    BOOL success;
    CHAR * nextDataStart;
    DWORD bytesread;
    CHAR * pRecordData;
    CHAR buffer[255];
    
    nextDataStart = ParseAnyRecord(DataStart, (CHAR *)&record, 
                                   sizeof(TRACE_RECORD_SEND));

    if(++LineNumber < SkipCnt)
        return nextDataStart;
    wsprintf(buffer,
            "[%4d]:[%u.%u]:Adapter %08X:%s:%s:%x:%x:%x\n",
            LineNumber,
            record.Now.HighPart,
            record.Now.LowPart,
            record.Adapter,
            SendEvents[record.Event],
            SendRecvActions[record.Action],
            record.Vc,
            record.Packet1,
            record.Packet2);
                
    switch(FileIt)
    {
        case OUTPUT_FILE:
            MyWriteFile(buffer, FileHandle, dprintf);
            break;
        case OUTPUT_CONSOLE:
            dprintf(buffer);
            break;
        default:
            dprintf("Failed to create file! Check for tmp directory.\n");
            break;
    }
    
    return(nextDataStart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\proxy\gpcprx.c ===
#include <ndis.h>
#include <ntddndis.h>
#include <cxport.h>

#include "gpcifc.h"
#include "gpcstruc.h"

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    gpcprx.c

Abstract:

    A GPC proxy to load msgpc.sys on demand

Author:

    Ofer Bar (Oferbar)  Nov 7, 1997

Environment:

    Kernel Mode

Revision History:


--*/


NTSTATUS
NTAPI
ZwLoadDriver(
	IN PUNICODE_STRING Name
    );

NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );


NTSTATUS
GpcInitialize(
	OUT	PGPC_EXPORTED_CALLS		pGpcEntries
    )
{
    NTSTATUS			Status;
    OBJECT_ATTRIBUTES	ObjAttr;
    HANDLE				FileHandle;
    IO_STATUS_BLOCK		IoStatusBlock;
    UNICODE_STRING		DriverName;
    UNICODE_STRING		DeviceName;

    ASSERT(pGpcEntries);

    RtlZeroMemory(pGpcEntries, sizeof(GPC_EXPORTED_CALLS));

    RtlInitUnicodeString(&DriverName, 
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Gpc");

    RtlInitUnicodeString(&DeviceName, DD_GPC_DEVICE_NAME);

    InitializeObjectAttributes(&ObjAttr,
                               &DeviceName,
                               0,
                               NULL,
                               NULL
                               );
    
    Status = ZwCreateFile(
                          &FileHandle,
                          GENERIC_READ | GENERIC_WRITE,
                          &ObjAttr,
                          &IoStatusBlock,
                          0,						// AllocationSize
                          FILE_ATTRIBUTE_NORMAL,	// FileAttributes
                          0,						// ShareAccess
                          FILE_OPEN_IF,				// CreateDisposition
                          0,						// CreateOptions
                          NULL,						// EaBuffer
                          0							// EaLength
                          );

    if (Status != STATUS_SUCCESS) {

        //
        // The GPC is not loaded yet, so we need to load it now
        // 

        Status = ZwLoadDriver(&DriverName);

        if (Status != STATUS_SUCCESS) {

            return Status;
        }

        //
        // try again...
        //

        Status = ZwCreateFile(&FileHandle,
                              GENERIC_READ | GENERIC_WRITE,
                              &ObjAttr,
                              &IoStatusBlock,
                              0,						// AllocationSize
                              FILE_ATTRIBUTE_NORMAL,	// FileAttributes
                              0,						// ShareAccess
                              FILE_OPEN_IF,				// CreateDisposition
                              0,						// CreateOptions
                              NULL,						// EaBuffer
                              0							// EaLength
                              );
     
        if (Status != STATUS_SUCCESS) {

            return Status;
        }
    }

    Status = ZwDeviceIoControlFile(FileHandle,
                                   NULL,				// Event
                                   NULL,				// ApcRoutine
                                   NULL,				// ApcContext
                                   &IoStatusBlock,
                                   IOCTL_GPC_GET_ENTRIES,
                                   NULL,
                                   0,
                                   (PVOID)pGpcEntries,
                                   sizeof(GPC_EXPORTED_CALLS)
                                   );
    
    pGpcEntries->Reserved = FileHandle;
    
    return Status;
}



NTSTATUS
GpcDeinitialize(
	IN	PGPC_EXPORTED_CALLS		pGpcEntries
    )
{
    NTSTATUS	Status;

    Status = ZwClose(pGpcEntries->Reserved);

    if (NT_SUCCESS(Status)) {
        RtlZeroMemory(pGpcEntries, sizeof(GPC_EXPORTED_CALLS));
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\kdext\makefile.inc ===
$(O)\precomp.pph: sched.h ..\sys\globals.h ..\..\inc\pktsched.h $(SDK_INC_PATH)\ntddpsch.h $(DDK_INC_PATH)\ndis.h
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

$(O)\dsotable.c: dso.txt $(O)\precomp.pph
    @echo Creating $@
    structo -p -s dso.txt -o $@ $(O)\precomp.pph
    del $(O)\precomp.pph

clean:
    del $(O)\dsotable.c $(O)\precomp.pph
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-netsh\prstring.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    routing\netsh\ip\protocols\prstring.h

Abstract:

    Definitions of command line option tag strings and their values. 

Revision History:

    Dave Thaler             11/11/98  Created

--*/

#define MSG_HELP_START L"%1!-14s! - "
#define MSG_NEWLINE _T("\n")


#define TOKEN_ROUTER                           _T("router")
#define TOKEN_MIB                              _T("mib")

    // tokens for commands
#define TOKEN_COMMAND_ADD                      _T("add")
#define TOKEN_COMMAND_DELETE                   _T("delete")
#define TOKEN_COMMAND_SET                      _T("set")
#define TOKEN_COMMAND_SHOW                     _T("show")
#define TOKEN_COMMAND_SHOW_HELPER              _T("show helper")
#define TOKEN_COMMAND_HELP                      _T("help")
#define TOKEN_COMMAND_INSTALL                  _T("install")
#define TOKEN_COMMAND_UNINSTALL                _T("uninstall")

#define TOKEN_COMMAND_HELP1                     _T("/?")
#define TOKEN_COMMAND_HELP2                     _T("-?")

    // Tokens for RIP MIB
#define TOKEN_RIP_MIB_OBJECT_STATS             _T("globalstats")
#define TOKEN_RIP_MIB_OBJECT_IFSTATS           _T("ifstats")
#define TOKEN_RIP_MIB_OBJECT_IFBINDING         _T("ifbinding")
#define TOKEN_RIP_MIB_OBJECT_PEERSTATS         _T("neighbor")
#define CMD_RIP_MIB_SHOW_STATS                 L"show globalstats"
#define CMD_RIP_MIB_SHOW_IFSTATS               L"show ifstats"
#define CMD_RIP_MIB_SHOW_IFBINDING             L"show ifbinding"
#define CMD_RIP_MIB_SHOW_PEERSTATS             L"show neighbor"

    // Tokens for BOOTP MIB
#define TOKEN_BOOTP_MIB_OBJECT_GLOBAL_CONFIG   _T("globalconfig")
#define TOKEN_BOOTP_MIB_OBJECT_IF_CONFIG       _T("ifconfig")
#define TOKEN_BOOTP_MIB_OBJECT_IF_BINDING      _T("ifbinding")
#define TOKEN_BOOTP_MIB_OBJECT_IF_STATS        _T("ifstats")
#define CMD_BOOTP_MIB_SHOW_GLOBAL_CONFIG       L"show globalconfig"
#define CMD_BOOTP_MIB_SHOW_IF_CONFIG           L"show ifconfig"
#define CMD_BOOTP_MIB_SHOW_IF_BINDING          L"show ifbinding"
#define CMD_BOOTP_MIB_SHOW_IF_STATS            L"show ifstats"

    // Tokens for OSPF MIB
#define TOKEN_OSPF_MIB_OBJECT_AREA              L"areastats"
#define TOKEN_OSPF_MIB_OBJECT_LSDB              L"lsdb"
#define TOKEN_OSPF_MIB_OBJECT_NEIGHBOR          L"neighbor"
#define TOKEN_OSPF_MIB_OBJECT_VIRTUALIF         L"virtifstats"
#define CMD_OSPF_MIB_SHOW_AREA                  L"show areastats"
#define CMD_OSPF_MIB_SHOW_LSDB                  L"show lsdb"
#define CMD_OSPF_MIB_SHOW_NEIGHBOR              L"show neighbor"
#define CMD_OSPF_MIB_SHOW_VIRTUALIF             L"show virtifstats"

    // Tokens for IGMP MIB
#define TOKEN_IGMP_MIB_OBJECT_IF_STATS          L"ifstats"
#define TOKEN_IGMP_MIB_OBJECT_IF_TABLE          L"iftable"
#define TOKEN_IGMP_MIB_OBJECT_GROUP_TABLE       L"grouptable"
#define TOKEN_IGMP_MIB_OBJECT_RAS_GROUP_TABLE   L"rasgrouptable"
#define TOKEN_IGMP_MIB_OBJECT_PROXY_GROUP_TABLE L"proxygrouptable"
#define CMD_IGMP_MIB_SHOW_IF_STATS              L"show ifstats"
#define CMD_IGMP_MIB_SHOW_IF_TABLE              L"show iftable"
#define CMD_IGMP_MIB_SHOW_GROUP_TABLE           L"show grouptable"
#define CMD_IGMP_MIB_SHOW_RAS_GROUP_TABLE       L"show rasgrouptable"
#define CMD_IGMP_MIB_SHOW_PROXY_GROUP_TABLE     L"show proxygrouptable"


    // tokens for router command options' tags
#define TOKEN_OPT_NAME                         _T("name")

        // filter options
#define TOKEN_OPT_ADDR                          _T("addr")
#define TOKEN_OPT_MASK                          _T("mask")
#define TOKEN_OPT_FILTER                        _T("filter")

        // NAT options
#define TOKEN_OPT_PUBLIC                       _T("public")
#define TOKEN_OPT_PRIVATE                      _T("private")
#define TOKEN_OPT_INBOUNDSESSIONS              _T("inboundsessions")
#define TOKEN_OPT_START                        _T("start")
#define TOKEN_OPT_END                          _T("end")
#define TOKEN_OPT_PROTO                        _T("proto")
#define TOKEN_OPT_PUBLICIP                     _T("publicip")
#define TOKEN_OPT_PUBLICPORT                   _T("publicport")
#define TOKEN_OPT_PRIVATEIP                    _T("privateip")
#define TOKEN_OPT_PRIVATEPORT                  _T("privateport")
#define TOKEN_OPT_TCPTIMEOUTMINS               _T("tcptimeoutmins")
#define TOKEN_OPT_UDPTIMEOUTMINS               _T("udptimeoutmins")
#define TOKEN_OPT_LOG_LEVEL                    _T("loglevel")

        // protocol options
#define TOKEN_OPT_SERVER                       _T("server")
#define TOKEN_OPT_AUTHENTICATION               _T("auth")
#define TOKEN_OPT_PASSWORD                     _T("password")
#define TOKEN_OPT_PEER_MODE                    _T("peermode")

            // BOOTP Interface options
#define TOKEN_OPT_RELAY_MODE                   _T("relaymode")
#define TOKEN_OPT_MAX_HOP                      _T("maxhop")
#define TOKEN_OPT_MIN_SECS                     _T("minsecs")

            // AUTODHCP/DNSPROXY Interface options
#define TOKEN_OPT_MODE                         _T("mode")
#define TOKEN_OPT_EXCLUSION                    _T("exclusion")
#define TOKEN_OPT_SCOPENETWORK                 _T("scopenetwork")
#define TOKEN_OPT_SCOPEMASK                    _T("scopemask")
#define TOKEN_OPT_QUERY_TIMEOUT                _T("querytimeout")
#define TOKEN_OPT_LEASETIME                    _T("leasetime")
#define TOKEN_OPT_DNSMODE                      _T("dnsmode")
#define TOKEN_OPT_WINSMODE                     _T("winsmode")

            // RIP global options
#define TOKEN_OPT_MIN_TRIG_INTR                _T("mintrig")

            // RIP Interface Options
#define TOKEN_OPT_UPDATE_MODE                  _T("updatemode")
#define TOKEN_OPT_ANNOUNCE_MODE                _T("announce")
#define TOKEN_OPT_ACCEPT_MODE                  _T("accept")
#define TOKEN_OPT_FLAG                         _T("flag")
#define TOKEN_OPT_FLAGS                        _T("flags")
#define TOKEN_OPT_EXPIRE_INTR                  _T("expire")
#define TOKEN_OPT_REMOVE_INTR                  _T("remove")
#define TOKEN_OPT_UPDATE_INTR                  _T("update")
#define TOKEN_OPT_AUTH_MODE                    _T("authmode")
#define TOKEN_OPT_ROUTE_TAG                    _T("tag")
#define TOKEN_OPT_UNICAST_MODE                 _T("unicast")
#define TOKEN_OPT_ACCEPT_FILTER_MODE           _T("accfiltmode")
#define TOKEN_OPT_ANNOUNCE_FILTER_MODE         _T("annfiltmode")
#define TOKEN_OPT_ACCEPT_FILTER                _T("accfilt")
#define TOKEN_OPT_ANNOUNCE_FILTER              _T("annfilt")

            // IGMP Interface options
#define TOKEN_OPT_PROTO_TYPE                   _T("igmpprototype")
#define TOKEN_OPT_ROBUSTNESS_VARIABLE          _T("robustvar")
#define TOKEN_OPT_GEN_QUERY_INTERVAL           _T("genqueryinterval")
#define TOKEN_OPT_GEN_QUERY_RESPONSE_TIME      _T("genqueryresptime")
#define TOKEN_OPT_INTERFACE_ENABLED            _T("ifenabled")
#define TOKEN_OPT_STARTUP_QUERY_COUNT          _T("startupquerycount")
#define TOKEN_OPT_STARTUP_QUERY_INTERVAL       _T("startupqueryinterval")
#define TOKEN_OPT_LASTMEM_QUERY_COUNT          _T("lastmemquerycount")
#define TOKEN_OPT_LASTMEM_QUERY_INTERVAL       _T("lastmemqueryinterval")
#define TOKEN_OPT_STATIC_GROUP                 _T("staticgroup")
#define TOKEN_OPT_STATIC_JOIN_MODE             _T("joinmode")
#define TOKEN_OPT_RTRALERT_PKTS                _T("accnonrtralertpkts")

            // OSPF Global Options
#define TOKEN_OPT_ROUTER_ID                    _T("routerid")
#define TOKEN_OPT_BORDER                       _T("asborder")



            // OSPF Area/Area Range Options
#define TOKEN_OPT_AREA_ID                      _T("areaid")
#define TOKEN_OPT_STUB_AREA                    _T("stubarea")
#define TOKEN_OPT_SUMMARY_ADVERTISEMENTS       _T("sumadv")
#define TOKEN_OPT_AREA_RANGE                   _T("range")

            // OSPF Virtual Interface Options
#define TOKEN_OPT_TRANSIT_AREA_ID              _T("transareaid")
#define TOKEN_OPT_VIRT_NBR_ROUTER_ID           _T("virtnbrid")

            // OSPF External routing
#define TOKEN_OPT_PROTOCOL_FILTER              _T("protofilter")
#define TOKEN_OPT_ACTION                       _T("action")

#define TOKEN_OPT_ROUTE_FILTER                 _T("routefilter")

            // OSPF Interface Options
#define TOKEN_OPT_IF_STATE                     _T("state")
#define TOKEN_OPT_PRIORITY                     _T("prio")
#define TOKEN_OPT_TRANS_DELAY                  _T("transdelay")
#define TOKEN_OPT_RETRANS_INTR                 _T("retrans")
#define TOKEN_OPT_HELLO_INTR                   _T("hello")
#define TOKEN_OPT_DEAD_INTR                    _T("dead")
#define TOKEN_OPT_POLL_INTR                    _T("poll")
#define TOKEN_OPT_MTU_SIZE                     _T("mtu")
            // QOS Interface options
#define TOKEN_OPT_IF_STATE                     _T("state")

            // QOS Flow options
#define TOKEN_OPT_FLOW_NAME                    _T("flowname")
#define TOKEN_OPT_FLOWSPEC                     _T("flowspec")
#define TOKEN_OPT_DIRECTION                    _T("direction")

            // QOS FlowSpec options
#define TOKEN_OPT_SERVICE_TYPE                 _T("servicetype")
#define TOKEN_OPT_TOKEN_RATE                   _T("tokenrate")
#define TOKEN_OPT_TOKEN_BUCKET_SIZE            _T("tokenbucketsize")
#define TOKEN_OPT_PEAK_BANDWIDTH               _T("peakbandwidth")
#define TOKEN_OPT_LATENCY                      _T("latency")
#define TOKEN_OPT_DELAY_VARIATION              _T("delayvariation")
#define TOKEN_OPT_MAX_SDU_SIZE                 _T("maxsdusize")
#define TOKEN_OPT_MIN_POLICED_SIZE             _T("minpolicedsize")

            // QOS Flowspec Direction Options
#define TOKEN_OPT_DIRECTION_INBOUND            _T("inbound")
#define TOKEN_OPT_DIRECTION_OUTBOUND           _T("outbound")
#define TOKEN_OPT_DIRECTION_BIDIRECTIONAL      _T("bidirectional")

            // QOS Object Options
#define TOKEN_OPT_QOSOBJECT                    _T("qosobject")

#define TOKEN_OPT_QOSOBJECT_TYPE               _T("type")

#define TOKEN_OPT_QOSOBJECT_DIFFSERV           _T("diffserv")
#define TOKEN_OPT_QOSOBJECT_SD_MODE            _T("sdmode")
            // QOS ServiceType options
#define TOKEN_OPT_SERVICE_BESTEFFORT           _T("besteffort")
#define TOKEN_OPT_SERVICE_CONTROLLEDLOAD       _T("controlledload")
#define TOKEN_OPT_SERVICE_GUARANTEED           _T("guaranteed")
#define TOKEN_OPT_SERVICE_QUALITATIVE          _T("qualitative")

            // QOS SD Mode options
#define TOKEN_OPT_SHAPING_MODE                 _T("shaping")

#define TOKEN_OPT_SDMODE_BORROW                _T("borrow")
#define TOKEN_OPT_SDMODE_SHAPE                 _T("shape")
#define TOKEN_OPT_SDMODE_DISCARD               _T("discard")
#define TOKEN_OPT_SDMODE_BORROW_PLUS           _T("borrowplus")

            // QOS Diffserv Rule options
#define TOKEN_OPT_INBOUND_DS_FIELD             _T("dsin")
#define TOKEN_OPT_CONF_OUTBOUND_DS_FIELD       _T("dsoutconf")
#define TOKEN_OPT_NONCONF_OUTBOUND_DS_FIELD    _T("dsoutnonconf")
#define TOKEN_OPT_CONF_USER_PRIORITY           _T("priconf")
#define TOKEN_OPT_NONCONF_USER_PRIORITY        _T("prinonconf")

            // OSPF Neighbor option
#define TOKEN_OPT_NBR_ADDR                     _T("nbraddr")
#define TOKEN_OPT_NBR_PRIO                     _T("nbrprio")

#define TOKEN_OPT_TYPE                         _T("type")
#define TOKEN_OPT_METRIC                       _T("metric")

            // Router discovery options
#define TOKEN_DISCOVERY                         L"disc"
#define TOKEN_MIN_DISC_INTERVAL                 L"minint"
#define TOKEN_MAX_DISC_INTERVAL                 L"maxint"
#define TOKEN_LIFETIME                          L"life"
#define TOKEN_LEVEL                             L"level"

        // Protocol types
#define TOKEN_OPT_VALUE_RTRMGR                 _T("ROUTERMANAGER")
#define TOKEN_OPT_VALUE_RIP                    _T("RIP")
#define TOKEN_OPT_VALUE_OSPF                   _T("OSPF")
#define TOKEN_OPT_VALUE_BOOTP                  _T("BOOTP")
#define TOKEN_OPT_VALUE_IGMP                   _T("IGMP")
#define TOKEN_OPT_VALUE_AUTO_DHCP              _T("AUTODHCP")
#define TOKEN_OPT_VALUE_DNS_PROXY              _T("DNSPROXY")

#define TOKEN_OPT_VALUE_TCP                    _T("TCP")
#define TOKEN_OPT_VALUE_UDP                    _T("UDP")
#define TOKEN_OPT_VALUE_ICMP                   _T("ICMP")
#define TOKEN_OPT_VALUE_NETMGMT                _T("SNMP")
#define TOKEN_OPT_VALUE_LOCAL                  _T("LOCAL")
#define TOKEN_OPT_VALUE_STATIC                 _T("STATIC")
#define TOKEN_OPT_VALUE_AUTOSTATIC             _T("AUTOSTATIC")
#define TOKEN_OPT_VALUE_NONDOD                 _T("NONDOD")
#define TOKEN_OPT_VALUE_ANY                    _T("ANY")


        // Igmp protocol types
#define TOKEN_OPT_VALUE_IGMPRTRV1              _T("IGMPRTRV1")
#define TOKEN_OPT_VALUE_IGMPRTRV2              _T("IGMPRTRV2")
#define TOKEN_OPT_VALUE_IGMPPROXY              _T("IGMPPROXY")

#define TOKEN_OPT_VALUE_TRUE                   _T("TRUE")
#define TOKEN_OPT_VALUE_FALSE                  _T("FALSE")
#define TOKEN_OPT_VALUE_HOST_JOIN              _T("HOSTJOIN")
#define TOKEN_OPT_VALUE_MGM_ONLY_JOIN          _T("MGMONLYJOIN")


        // Accept/Announce types
#define TOKEN_OPT_VALUE_RIP1                   _T("RIP1")
#define TOKEN_OPT_VALUE_RIP1_COMPAT            _T("RIP1COMPAT")
#define TOKEN_OPT_VALUE_RIP2                   _T("RIP2")

        // log level types
#define TOKEN_OPT_VALUE_ERROR                  _T("ERROR")
#define TOKEN_OPT_VALUE_WARN                   _T("WARN")
#define TOKEN_OPT_VALUE_INFO                   _T("INFO")

        // unicast peer modes
#define TOKEN_OPT_VALUE_ALSO                   _T("ALSO")
#define TOKEN_OPT_VALUE_ONLY                   _T("ONLY")

        // RIP Interface flag modes
#define TOKEN_OPT_VALUE_CLEAR                  _T("Clear")
#define TOKEN_OPT_VALUE_SPLIT_HORIZON          _T("SplitHorizon")
#define TOKEN_OPT_VALUE_POISON_REVERSE         _T("PoisonReverse")
#define TOKEN_OPT_VALUE_TRIGGERED_UPDATES      _T("TriggeredUpdates")
#define TOKEN_OPT_VALUE_CLEANUP_UPDATES        _T("CleanupUpdates")
#define TOKEN_OPT_VALUE_ACCEPT_HOST_ROUTES     _T("AcceptHostRoutes")
#define TOKEN_OPT_VALUE_SEND_HOST_ROUTES       _T("SendHostRoutes")
#define TOKEN_OPT_VALUE_ACCEPT_DEFAULT_ROUTES  _T("AcceptDefaultRoutes")
#define TOKEN_OPT_VALUE_SEND_DEFAULT_ROUTES    _T("SendDefaultRoutes")
#define TOKEN_OPT_VALUE_SUBNET_SUMMARY         _T("NoSubnetSummary")



        // filter modes
#define TOKEN_OPT_VALUE_INCLUDE                _T("INCLUDE")
#define TOKEN_OPT_VALUE_EXCLUDE                _T("EXCLUDE")

        // Misc. option vlues
#define TOKEN_OPT_VALUE_INPUT                  _T("INPUT")
#define TOKEN_OPT_VALUE_OUTPUT                 _T("OUTPUT")
#define TOKEN_OPT_VALUE_DIAL                   _T("DIAL")

#define TOKEN_OPT_VALUE_ENABLE                 _T("enable")
#define TOKEN_OPT_VALUE_DISABLE                _T("disable")
#define TOKEN_OPT_VALUE_DEFAULT                _T("default")

#define TOKEN_OPT_VALUE_FULL                   _T("FULL")
#define TOKEN_OPT_VALUE_YES                    _T("YES")
#define TOKEN_OPT_VALUE_NO                     _T("NO")

#define TOKEN_OPT_VALUE_NONE                   _T("NONE")
#define TOKEN_OPT_VALUE_PASSWORD               _T("PASSWORD")

#define TOKEN_OPT_VALUE_DROP                   _T("DROP")
#define TOKEN_OPT_VALUE_FORWARD                _T("FORWARD")
#define TOKEN_OPT_VALUE_ACCEPT                 _T("ACCEPT")

#define TOKEN_OPT_VALUE_DEMAND                 _T("DEMAND")
#define TOKEN_OPT_VALUE_PERIODIC               _T("PERIODIC")

#define TOKEN_OPT_VALUE_NBMA                   _T("NBMA")
#define TOKEN_OPT_VALUE_POINT_TO_POINT         _T("P2P")
#define TOKEN_OPT_VALUE_BROADCAST              _T("BROADCAST")

#define TOKEN_OPT_VALUE_ADDRESSONLY            _T("ADDRESSONLY")
#define TOKEN_OPT_VALUE_PRIVATE                _T("PRIVATE")

#define TOKEN_OPT_VALUE_AUTH_NONE              _T("AUTHNONE")
#define TOKEN_OPT_VALUE_AUTH_SIMPLE_PASSWORD    _T("AUTHSIMPLEPASSWORD")

#define TOKEN_HLPER_RIP                        _T("rip")
#define TOKEN_HLPER_RIPMIB                     _T("ripmib")
#define TOKEN_HLPER_OSPF                       _T("ospf")
#define TOKEN_HLPER_OSPFMIB                    _T("ospfmib")

    // Commands for configuring the various protocols

    // tokens for commands required by most protocols

#define CMD_GROUP_ADD                          _T("add")
#define CMD_GROUP_DELETE                       _T("delete")
#define CMD_GROUP_SET                          _T("set")
#define CMD_GROUP_SHOW                         _T("show")

#define CMD_SHOW_HELPER                        _T("show helper")
#define CMD_INSTALL                            _T("install")
#define CMD_UNINSTALL                          _T("uninstall")
#define CMD_DUMP                               _T("dump")
#define CMD_HELP1                              _T("help")
#define CMD_HELP2                              _T("?")
#define CMD_MIB                                _T("mib")
#define CMD_ADD_HELPER                         _T("add helper")
#define CMD_DEL_HELPER                         _T("delete helper")

    // ip commands

#define CMD_IP_ADD_IF                          _T("add interface")
#define CMD_IP_DEL_IF                          _T("delete interface")
#define CMD_IP_ADD_IF_FILTER                   _T("add filter")
#define CMD_IP_DEL_IF_FILTER                   _T("delete filter")
#define CMD_IP_ADD_PROTO                       _T("add protocol")
#define CMD_IP_DEL_PROTO                       _T("delete protocol")
#define CMD_IP_ADD_ROUTEPREF                   _T("add routepref")
#define CMD_IP_DEL_ROUTEPREF                   _T("delete routepref")
#define CMD_IP_SET_IF                          _T("set interface")
#define CMD_IP_SET_IF_FILTER                   _T("set filter")
#define CMD_IP_SET_ROUTEPREF                   _T("set routepref")
#define CMD_IP_SET                             _T("set")

#define CMD_IP_SHOW_IF_FILTER                  _T("show filter")
#define CMD_IP_SHOW_IF                         _T("show interface")
#define CMD_IP_SHOW_ROUTEPREF                  _T("show routepref")
#define CMD_IP_SHOW_PROTOCOL                   _T("show protocol")
#define CMD_IP_SHOW                            _T("show")

    // rip add commands

#define CMD_RIP_ADD_PF                         _T("add peerfilter")
#define CMD_RIP_ADD_IF_ACCF                    _T("add acceptfilter")
#define CMD_RIP_ADD_IF_ANNF                    _T("add announcefilter")
#define CMD_RIP_ADD_IF_NBR                     _T("add neighbor")
#define CMD_RIP_ADD_IF                         _T("add interface")

    // rip delete commands

#define CMD_RIP_DEL_PF                         _T("delete peerfilter")
#define CMD_RIP_DEL_IF_ACCF                    _T("delete acceptfilter")
#define CMD_RIP_DEL_IF_ANNF                    _T("delete announcefilter")
#define CMD_RIP_DEL_IF_NBR                     _T("delete neighbor")
#define CMD_RIP_DEL_IF                         _T("delete interface")

    // rip set commands

#define CMD_RIP_SET_IF                         _T("set interface")
#define CMD_RIP_SET_FLAGS                      _T("set flags")
#define CMD_RIP_SET_GLOBAL                     _T("set global")

    // rip show commands

#define CMD_RIP_SHOW_IF                        _T("show interface")
#define CMD_RIP_SHOW_FLAGS                     _T("show flags")
#define CMD_RIP_SHOW_GLOBAL                    _T("show global")

    // DHCP relay agent add commands

#define CMD_BOOTP_ADD                          _T("add")
#define CMD_BOOTP_ADD_IF                       _T("add interface")
#define CMD_BOOTP_ADD_DHCP_SERVER              _T("add dhcpserver")

    // DHCP relay agent delete commands

#define CMD_BOOTP_DEL                          _T("delete")
#define CMD_BOOTP_DEL_IF                       _T("delete interface")
#define CMD_BOOTP_DEL_DHCP_SERVER              _T("delete dhcpserver")

    // DHCP relay agent set commands

#define CMD_BOOTP_SET_GLOBAL                   _T("set global")
#define CMD_BOOTP_SET_IF                       _T("set interface")

    // DHCP relay agent show commands

#define CMD_BOOTP_SHOW_GLOBAL                  _T("show global")
#define CMD_BOOTP_SHOW_IF                      _T("show interface")

    // IGMP commands

#define CMD_IGMP_ADD_IF_STATICGROUP            _T("add staticgroup")
#define CMD_IGMP_ADD_IF                        _T("add interface")

#define CMD_IGMP_DEL_IF_STATICGROUP            _T("delete staticgroup")
#define CMD_IGMP_DEL_IF                        _T("delete interface")

#define CMD_IGMP_SET_IF                        _T("set interface")
#define CMD_IGMP_SET_GLOBAL                    _T("set global")

#define CMD_IGMP_SHOW_IF                       _T("show interface")
#define CMD_IGMP_SHOW_GLOBAL                   _T("show global")

    // DHCP allocator commands
#define CMD_AUTODHCP_ADD_EXCLUSION             _T("add exclusion")
#define CMD_AUTODHCP_DELETE_EXCLUSION          _T("delete exclusion")
#define CMD_AUTODHCP_SET_GLOBAL                _T("set global")
#define CMD_AUTODHCP_SET_INTERFACE             _T("set interface")
#define CMD_AUTODHCP_SHOW_GLOBAL               _T("show global")
#define CMD_AUTODHCP_SHOW_INTERFACE            _T("show interface")

    // DNS proxy commands
#define CMD_DNSPROXY_SET_GLOBAL                _T("set global")
#define CMD_DNSPROXY_SET_INTERFACE             _T("set interface")
#define CMD_DNSPROXY_SHOW_GLOBAL               _T("show global")
#define CMD_DNSPROXY_SHOW_INTERFACE            _T("show interface")

    // NAT commands
#define CMD_NAT_ADD_ADDRESS_MAPPING            _T("add addressmapping")
#define CMD_NAT_ADD_ADDRESS_RANGE              _T("add addressrange")
#define CMD_NAT_ADD_DIRECTPLAY                 _T("add directplay")
#define CMD_NAT_ADD_H323                       _T("add h323")
#define CMD_NAT_ADD_INTERFACE                  _T("add interface")
#define CMD_NAT_ADD_PORT_MAPPING               _T("add portmapping")
#define CMD_NAT_DELETE_ADDRESS_MAPPING         _T("delete addressmapping")
#define CMD_NAT_DELETE_ADDRESS_RANGE           _T("delete addressrange")
#define CMD_NAT_DELETE_DIRECTPLAY              _T("delete directplay")
#define CMD_NAT_DELETE_H323                    _T("delete h323")
#define CMD_NAT_DELETE_INTERFACE               _T("delete interface")
#define CMD_NAT_DELETE_PORT_MAPPING            _T("delete portmapping")
#define CMD_NAT_SET_GLOBAL                     _T("set global")
#define CMD_NAT_SET_INTERFACE                  _T("set interface")
#define CMD_NAT_SHOW_GLOBAL                    _T("show global")
#define CMD_NAT_SHOW_INTERFACE                 _T("show interface")

    // RDISC commands
#define CMD_RDISC_ADD_INTERFACE                 L"add interface"
#define CMD_RDISC_DELETE_INTERFACE              L"delete interface"
#define CMD_RDISC_SET_INTERFACE                 L"set interface"
#define CMD_RDISC_SHOW_INTERFACE                L"show interface"

    // QOS commands

#define CMD_QOS_ADD_FILTER_TO_FLOW             _T("add filter")
#define CMD_QOS_ADD_QOSOBJECT_ON_FLOW          _T("add qoonflow")
#define CMD_QOS_ADD_FLOWSPEC_ON_FLOW           _T("add fsonflow")
#define CMD_QOS_ADD_FLOW_ON_IF                 _T("add flow")
#define CMD_QOS_ADD_IF                         _T("add interface")
#define CMD_QOS_ADD_DSRULE                     _T("add dsrule")
#define CMD_QOS_ADD_SDMODE                     _T("add sdmode")
#define CMD_QOS_ADD_FLOWSPEC                   _T("add flowspec")

#define CMD_QOS_DEL_FILTER_FROM_FLOW           _T("delete filter")
#define CMD_QOS_DEL_QOSOBJECT_ON_FLOW          _T("delete qoonflow")
#define CMD_QOS_DEL_FLOWSPEC_ON_FLOW           _T("delete fsonflow")
#define CMD_QOS_DEL_FLOW_ON_IF                 _T("delete flow")
#define CMD_QOS_DEL_IF                         _T("delete interface")
#define CMD_QOS_DEL_DSRULE                     _T("delete dsrule")
#define CMD_QOS_DEL_SDMODE                     _T("delete sdmode")
#define CMD_QOS_DEL_QOSOBJECT                  _T("delete qosobject")
#define CMD_QOS_DEL_FLOWSPEC                   _T("delete flowspec")

#define CMD_QOS_SET_FILTER_ON_FLOW             _T("set filter")
#define CMD_QOS_SET_FLOW_ON_IF                 _T("set flow")
#define CMD_QOS_SET_IF                         _T("set interface")
#define CMD_QOS_SET_GLOBAL                     _T("set global")

#define CMD_QOS_SHOW_FILTER_ON_FLOW            _T("show filter")
#define CMD_QOS_SHOW_FLOW_ON_IF                _T("show flow")
#define CMD_QOS_SHOW_IF                        _T("show interface")
#define CMD_QOS_SHOW_DSMAP                     _T("show dsmap")
#define CMD_QOS_SHOW_SDMODE                    _T("show sdmode")
#define CMD_QOS_SHOW_QOSOBJECT                 _T("show qosobject")
#define CMD_QOS_SHOW_FLOWSPEC                  _T("show flowspec")
#define CMD_QOS_SHOW_GLOBAL                    _T("show global")

    // Common dump commands

#define DMP_POPD L"\n\npopd\n"
#define DMP_UNINSTALL L"uninstall\n"

    // Igmp dump commands

#define DMP_IGMP_PUSHD L"\
pushd routing ip igmp\n"

#define DMP_IGMP_INSTALL _T("\
install\n")

#define DMP_IGMP_UNINSTALL _T("\
uninstall\n")

#define DMP_IGMP_SET_GLOBAL _T("\
set global loglevel = %1!s!\n")

#define DMP_IGMP_ADD_INTERFACE_RTRV1 _T("\
add interface name=%1!s! igmpprototype=%2!s!\
 ifenabled=%3!s!\
 robustvar=%4!d!\
 startupquerycount=%5!d!\
 startupqueryinterval=%6!d!\
 genqueryinterval=%7!d!\
 genqueryresptime=%8!d!\
 accnonrtralertpkts=%9!s!\n")

#define DMP_IGMP_ADD_INTERFACE_RTRV2 _T("\
add interface name=%1!s! igmpprototype=%2!s!\
 ifenabled=%3!s!\
 robustvar=%4!d!\
 startupquerycount=%5!d!\
 startupqueryinterval=%6!d!\
 genqueryinterval=%7!d!\
 genqueryresptime=%8!d!\
 lastmemquerycount=%9!d!\
 lastmemqueryinterval=%10!d!\
 accnonrtralertpkts=%11!s!\n")

#define DMP_IGMP_ADD_INTERFACE_PROXY _T("\
add interface name=%1!s! igmpprototype=%2!s! ifenabled=%3!s!\n")

#define DMP_IGMP_DELETE_INTERFACE _T("\
delete interface name=%1!s!\n")

#define DMP_IGMP_STATIC_GROUP _T("\
add staticgroup name=%1!s! staticgroup=%2!s! joinmode=%3!s!\n")

    // Rip dump commands

#define DMP_RIP_PUSHD L"\
pushd routing ip rip\n"

#define DMP_RIP_INSTALL _T("\
install\n")

#define DMP_RIP_UNINSTALL _T("\
uninstall\n")

#define DMP_RIP_SET_GLOBAL _T("\
set global loglevel=%1!s! mintrig=%2!d! peermode=%3!s!\n\n")

#define DMP_RIP_PEER_ADDR _T("\
add peerfilter server=%1!s!\n")

#define DMP_RIP_DELETE_INTERFACE _T("\
delete interface name=%1!s! \n")

#define DMP_RIP_ADD_INTERFACE _T("\
add interface name=%1!s! \n")

#define DMP_RIP_SET_INTERFACE _T("\
set interface name=%1!s!\
 metric=%2!d!\
 updatemode=%3!s!\
 announce=%4!s!\
 accept=%5!s!\
 expire=%6!d!\
 remove=%7!d!\
 update=%8!d!\
 authmode=%9!s!\
 tag=%10!d!\
 unicast=%11!s!\
 accfiltmode=%12!s!\
 annfiltmode=%13!s!\n")

#define DMP_RIP_SET_INTERFACE_PASSWORD _T("\
set interface name=%1!s!\
 password=%2!s!\n")

 
#define DMP_RIP_SET_FLAGS _T("\
set flags name=%1!s!\
 flag=%2!s!\n\n")

#define DMP_RIP_IF_UNICAST_PEER _T("\
add neighbor name=%1!s! server=%2!s!\n")

#define DMP_RIP_IF_ACC_FILTER _T("\
add acceptfilter name=%1!s! addr=%2!s! mask=%3!s!\n")

#define DMP_RIP_IF_ANN_FILTER _T("\
add announcefilter name=%1!s! addr=%2!s! mask=%3!s!\n")

    // QOS dump commands

#define DMP_QOS_PUSHD L"\
pushd routing ip qos\n"

#define DMP_QOS_INSTALL _T("\
install\n")

#define DMP_QOS_UNINSTALL _T("\
uninstall\n")


#define DMP_QOS_HEADER _T("\
\n")

#define DMP_QOS_FOOTER _T("\
\n")


#define DMP_QOS_GLOBAL_HEADER _T("\
\n")

#define DMP_QOS_GLOBAL_FOOTER _T("\
\n\n")

#define DMP_QOS_SET_GLOBAL _T("\
set global loglevel=%1!s!\n\n")


#define DMP_QOS_INTERFACE_HEADER _T("\
\n")

#define DMP_QOS_INTERFACE_FOOTER _T("\
\n\n")

#define DMP_QOS_ADD_INTERFACE _T("\
add interface name=%1!s!\
 state=%2!s!\n")

#define DMP_QOS_SET_INTERFACE _T("\
set interface name=%1!s!\
 state=%2!s!\n")

#define DMP_QOS_DELETE_INTERFACE _T("\
delete interface name=%1!s! \n")


#define DMP_QOS_ADD_FLOWSPEC _T("\
add flowspec name=%1!s!\
 servicetype=%2!s!\
 tokenrate=%3!d!\
 tokenbucketsize=%4!d!\
 peakbandwidth=%5!d!\
 latency=%6!d!\
 delayvariation=%7!d!\
 maxsdusize=%8!d!\
 minpolicedsize=%9!d!\n")

#define DMP_QOS_DELETE_FLOWSPEC _T("\
delete flowspec name=%1!s! \n")


#define DMP_QOS_ADD_SDMODE _T("\
add sdmode name=%1!s! shaping=%2!s!\n")

#define DMP_QOS_DEL_SDMODE _T("\
delete sdmode name=%1!s! \n")


#define DMP_QOS_DSMAP_HEADER _T("\
\n")

#define DMP_QOS_DSMAP_FOOTER _T("\
\n")

#define DMP_QOS_ADD_DSRULE _T("\
add dsrule name=%1!s! dsin=%2!d!\
 dsoutconf=%3!d! dsoutnonconf=%4!d!\
 priconf=%5!d! prinonconf=%6!d!\n")

#define DMP_QOS_DELETE_DSRULE _T("\
delete dsrule name=%1!s! dsin=%2!d!\n")


#define DMP_QOS_ADD_FLOW _T("\
add flow name=%1!s! flowname=%2!s!\n")

#define DMP_QOS_DELETE_FLOW _T("\
delete flow name=%1!s! flowname=%2!s!\n")


#define DMP_QOS_ADD_FLOWSPEC_ON_FLOW_IN  _T("\
add fsonflow name=%1!s! flowname=%2!s! flowspec=%3!s! inbound\n")

#define DMP_QOS_ADD_FLOWSPEC_ON_FLOW_OUT  _T("\
add fsonflow name=%1!s! flowname=%2!s! flowspec=%3!s! outbound\n")

#define DMP_QOS_ADD_FLOWSPEC_ON_FLOW_BI  _T("\
add fsonflow name=%1!s! flowname=%2!s! flowspec=%3!s! bidirectional\n")


#define DMP_QOS_ADD_QOSOBJECT_ON_FLOW  _T("\
add qoonflow name=%1!s! flowname=%2!s! qosobject=%3!s!\n")

    // Router-discovery commands

#define DMP_RDISC_PUSHD L"\
pushd routing ip routerdiscovery\n"

#define DMP_RDISC_ADD_INTERFACE L"\
add interface name=%1!s! disc=%2!s! minint=%3!d!\
 maxint=%4!d! life=%5!d! level=%6!d!\n"

    //
    // DHCP relay commands
    //

#define DMP_BOOTP_PUSHD L"\
pushd routing ip relay\n"

#define DMP_BOOTP_INSTALL _T("\
install\n")

#define DMP_BOOTP_UNINSTALL _T("\
uninstall\n")

#define DMP_BOOTP_SET_GLOBAL _T("\
set global loglevel=%1!s!\n\n")

#define DMP_BOOTP_DHCP_SERVER_ADD _T("\
add dhcpserver server=%1!s!\n")

#define DMP_BOOTP_DELETE_INTERFACE _T("\
delete interface name=%1!s! \n")

#define DMP_BOOTP_ADD_INTERFACE _T("\
add interface name=%1!s! \n")

#define DMP_BOOTP_SET_INTERFACE _T("\
set interface name=%1!s! relaymode=%2!s! maxhop=%3!d! minsecs=%4!d!\n\n")

    //
    // DHCP allocator commands
    //
#define DMP_AUTODHCP_EXCLUSION _T("\
add exclusion %1!s!=%2!s!\n")

#define DMP_AUTODHCP_INSTALL _T("\
install\n")

#define DMP_AUTODHCP_PUSHD L"\
pushd routing ip autodhcp\n"

#define DMP_AUTODHCP_SET_GLOBAL _T("\
set global %1!s!=%2!s! %3!s!=%4!s! %5!s!=%6!s! %7!s!=%8!s!\n")

#define DMP_AUTODHCP_SET_INTERFACE _T("\
set interface %1!s!=\"%2!s!\" %3!s!=%4!s!\n")

#define DMP_AUTODHCP_UNINSTALL _T("\
uninstall\n")

    //
    // DNS proxy commands
    //
#define DMP_DNSPROXY_INSTALL _T("\
install\n")

#define DMP_DNSPROXY_PUSHD L"\
pushd routing ip dnsproxy\n"

#define DMP_DNSPROXY_SET_GLOBAL _T("\
set global %1!s!=%2!s! %3!s!=%4!s! %5!s!=%6!s! %7!s!=%8!s!\n")

#define DMP_DNSPROXY_SET_INTERFACE _T("\
set interface %1!s!=\"%2!s!\" %3!s!=%4!s!\n")

#define DMP_DNSPROXY_UNINSTALL _T("\
uninstall\n")

    //
    // NAT commands
    //
#define DMP_NAT_ADD_INTERFACE _T("\
add interface %1!s!=\"%2!s!\" %3!s!=%4!s!\n")

#define DMP_NAT_ADDRESS_MAPPING _T("\
add addressmapping %1!s!=\"%2!s!\" %3!s!=%4!s! %5!s!=%6!s! %7!s!=%8!s!\n")

#define DMP_NAT_ADDRESS_RANGE _T("\
add addressrange %1!s!=\"%2!s!\" %3!s!=%4!s! %5!s!=%6!s! %7!s!=%8!s!\n")

#define DMP_NAT_PORT_MAPPING _T("\
add portmapping %1!s!=\"%2!s!\" %3!s!=%4!s! %5!s!=%6!s! %7!s!=%8!s! %9!s!=%10!s! %11!s!=%12!s!\n")

#define DMP_NAT_INSTALL _T("\
install\n")

#define DMP_NAT_PUSHD L"\
pushd routing ip nat\n"

#define DMP_NAT_SET_GLOBAL _T("\
set global %1!s!=%2!s! %3!s!=%4!s! %5!s!=%6!s!\n")

#define DMP_NAT_UNINSTALL _T("\
uninstall\n")

    // Ospf dump commands

#define DMP_OSPF_PUSHD _T("\
\npushd routing ip ospf")

#define DMP_OSPF_INSTALL _T("\
\ninstall")

#define DMP_OSPF_UNINSTALL _T("\
\nuninstall")

#define DMP_OSPF_SET_GLOBAL _T("\
\nset global routerid=%1!s! asborder=%2!s! loglevel=%3!s!")

#define DMP_OSPF_ROUTE_FILTER_HEADER _T("\
\n\n#Route filter configuration\n")

#define DMP_OSPF_ADD_ROUTE_FILTER _T("\
\nadd routefilter filter=%1!s! %2!s!")

#define DMP_OSPF_SET_ROUTE_FILTER_ACTION _T("\
\nset routefilter action = %1!s!")

#define DMP_OSPF_ADD_PROTO_FILTER _T("\
\nadd protofilter filter=%1!s!")

#define DMP_OSPF_PROTOCOL_FILTER_HEADER _T("\
\n\n#Protocol filter configuration\n")

#define DMP_OSPF_SET_PROTO_FILTER_ACTION _T("\
\nset protofilter action = %1!s!")

#define DMP_OSPF_DELETE_INTERFACE _T("\
\ndelete interface name=%1!s!")

#define DMP_OSPF_ADD_INTERFACE _T("\
\nadd interface name=%1!s! area=%2!s!")

#define DMP_OSPF_ADD_MULT_INTERFACE _T("\
\nadd interface name=%1!s!\
    area=%2!s!\
    addr=%3!s!\
    mask=%4!s!")

#define DMP_OSPF_SET_INTERFACE _T("\
\nset interface name=%1!s!\
    state=%2!s!\
    area=%3!s!\
    type=%4!s!\
    prio=%5!d!\
    transdelay=%6!d!\
    retrans=%7!d!\
    hello=%8!d!\
    dead=%9!d!\
    poll=%10!d!\
    metric=%11!d!\
    mtu=%12!d!")

#define DMP_OSPF_SET_MULT_INTERFACE _T("\
\nset interface name=%1!s!\
    addr=%2!s!\
    mask=%3!s!\
    state=%4!s!\
    area=%5!s!\
    type=%6!s!\
    prio=%7!d!\
    transdelay=%8!d!\
    retrans=%9!d!\
    hello=%10!d!\
    dead=%11!d!\
    poll=%12!d!\
    metric=%13!d!\
    mtu=%14!d!")

#define DMP_OSPF_SET_INTERFACE_PASSWORD _T("\
\nset interface name=%1!s!\
    password=%2!s!")
    
#define DMP_OSPF_SET_MULT_INTERFACE_PASSWORD _T("\
\nset interface name=%1!s!\
    addr=%2!s!\
    mask=%3!s!\
    password=%4!s!")


#define DMP_OSPF_AREA_HEADER _T("\
\n\n# Configuration for area %1!s!\n")

#define DMP_OSPF_DELETE_AREA _T("\
\ndelete area areaid=%1!s!")

#define DMP_OSPF_ADD_AREA _T("\
\nadd area areaid=%1!s!")

#define DMP_OSPF_SET_AREA _T("\
\nset area areaid=%1!s! auth=%2!s! stubarea=%3!s! metric=%4!d! sumadv=%5!s!")

#define DMP_OSPF_ADD_AREA_RANGE _T("\
\nadd range areaid=%1!s!\
    range=%2!s! %3!s!")

#define DMP_OSPF_NEIGHBOR_HEADER _T("\
\n\n#Neighbor configuration for %1!s!\n")

#define DMP_OSPF_ADD_NEIGHBOR _T("\
\nadd neighbor name=%1!s! addr=%2!s! nbraddr=%3!s! nbrprio=%4!d!")

#define DMP_OSPF_DELETE_NEIGHBOR _T("\
\ndelete neighbor name=%1!s! addr=%2!s! nbraddr=%3!s!")

#define DMP_OSPF_VIRTUAL_INTERFACE_HEADER _T("\
\n\n#Configuration for virtual interface AREA %1!s! NEIGHBOR %2!s!\n")

#define DMP_OSPF_ADD_VIRTUAL_INTERFACE _T("\
\nadd virtif transareaid=%1!s! virtnbrid=%2!s!")

#define DMP_OSPF_DELETE_VIRTUAL_INTERFACE _T("\
\ndelete virtif transareaid=%1!s! virtnbrid=%2!s!")

#define DMP_OSPF_SET_VIRTUAL_INTERFACE _T("\
\nset virtif transareaid=%1!s! virtnbrid=%2!s!\
    transdelay=%3!d! retrans=%4!d! hello=%5!d!\
    dead=%6!d!")

#define DMP_OSPF_SET_VIRTUAL_INTERFACE_PASSWORD _T("\
\nset virtif transareaid=%1!s! virtnbrid=%2!s!\
    password=%3!s!")

    // Ospf hlp commands

#define CMD_OSPF_ADD_AREA_RANGE                _T("add range")
#define CMD_OSPF_ADD_AREA                      _T("add area")
#define CMD_OSPF_ADD_VIRTIF                    _T("add virtif")
#define CMD_OSPF_ADD_IF_NBR                    _T("add neighbor")
#define CMD_OSPF_ADD_IF                        _T("add interface")
#define CMD_OSPF_ADD_ROUTE_FILTER              _T("add routefilter")
#define CMD_OSPF_ADD_PROTO_FILTER              _T("add protofilter")
#define CMD_OSPF_ADD                           _T("add")

#define CMD_OSPF_DEL_AREA_RANGE                _T("delete range")
#define CMD_OSPF_DEL_AREA                      _T("delete area")
#define CMD_OSPF_DEL_VIRTIF                    _T("delete virtif")
#define CMD_OSPF_DEL_IF_NBR                    _T("delete neighbor")
#define CMD_OSPF_DEL_IF                        _T("delete interface")
#define CMD_OSPF_DEL_ROUTE_FILTER              _T("delete routefilter")
#define CMD_OSPF_DEL_PROTO_FILTER              _T("delete protofilter")
#define CMD_OSPF_DEL                           _T("delete")

#define CMD_OSPF_SET_AREA                      _T("set area")
#define CMD_OSPF_SET_VIRTIF                    _T("set virtif")
#define CMD_OSPF_SET_IF                        _T("set interface")
#define CMD_OSPF_SET_GLOBAL                    _T("set global")
#define CMD_OSPF_SET_ROUTE_FILTER              _T("set routefilter")
#define CMD_OSPF_SET_PROTO_FILTER              _T("set protofilter")

#define CMD_OSPF_SHOW_GLOBAL                   _T("show global")
#define CMD_OSPF_SHOW_AREA                     _T("show area")
#define CMD_OSPF_SHOW_VIRTIF                   _T("show virtif")
#define CMD_OSPF_SHOW_IF                       _T("show interface")
#define CMD_OSPF_SHOW_ROUTE_FILTER             _T("show routefilter")
#define CMD_OSPF_SHOW_PROTO_FILTER             _T("show protofilter")
#define CMD_OSPF_SHOW                          _T("show")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-netsh\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>
#include <ntdef.h>

#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>
#include <winsock2.h>



#include <fltdefs.h>
#include <rtutils.h>
#include <mprerror.h>
#include <routprot.h>
#include <ipinfoid.h>
#include <iprtrmib.h>
#include <rtinfo.h>
#include <iprtinfo.h>
#include <priopriv.h>
#include <ipriprm.h>
#include <ipbootp.h>
#include <ospf_cfg.h>
#include <mprapi.h>
#include <ipinfoid.h>
#include <igmprm.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <snmp.h>
#include <internal.h>

#define  INITGUID
#include <tcguid.h>
#include <ndisguid.h>
#include <ntddndis.h>
#include <qos.h>
#include <traffic.h>
#include <tcerror.h>
#include <ipqosrm.h>

#include <macros.h>
#include <netsh.h>
#include <ipmontr.h>
#include "ipprodefs.h"
#include "common.h"
#include "utils.h"
#include "strdefs.h"
#include "prstring.h"
#include "igmp.h"

#include "igmpcfg.h"
#include "igmpgetopt.h"
#include "igmpmib.h"
#include "rip.h"
#include "ripcfg.h"
#include "ripgetopt.h"
#include "ripmib.h"
#include "qosp.h"
#include "ospf.h"
#include "ospfcfg.h"
#include "ospfgetopt.h"
#include "ospfmib.h"
#include "bootp.h"
#include "bootpcfg.h"
#include "bootpopt.h"
#include "bootpmib.h"
#include "nathlp.h"
#include "nathlpcfg.h"
#include "nathlpopt.h"
#include "rdisc.h"
#include "rdiscopt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\ipqosrm.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    ipqosrm.h

Abstract:

    The file contains the IP router manager
    interface for the QOS Mgr Protocol.

Revision History:

--*/

#ifndef __IPQOSRM_H_
#define __IPQOSRM_H_

//
// Constants
//

//
// Current QOS configuration version
//
#define QOS_CONFIG_VERSION_500       500


//
// Constants for the field 
// IPQOS_GLOBAL_CONFIG::LoggingLevel
//
#define IPQOS_LOGGING_NONE           0
#define IPQOS_LOGGING_ERROR          1
#define IPQOS_LOGGING_WARN           2
#define IPQOS_LOGGING_INFO           3


//
// Constants identifying QOS's MIB tables
//
#define IPQOS_GLOBAL_STATS_ID        0
#define IPQOS_GLOBAL_CONFIG_ID       1
#define IPQOS_IF_STATS_ID            2
#define IPQOS_IF_CONFIG_ID           3


//
// Structures
//

//
// In the following structures, all IP
// addresses are in network byte order
//

typedef struct _IPQOS_NAMED_FLOWSPEC
{
    WCHAR              FlowspecName[MAX_STRING_LENGTH];
    FLOWSPEC           FlowspecDesc;
}
IPQOS_NAMED_FLOWSPEC, *PIPQOS_NAMED_FLOWSPEC;

typedef struct _IPQOS_NAMED_QOSOBJECT
{
    WCHAR              QosObjectName[MAX_STRING_LENGTH];
    QOS_OBJECT_HDR     QosObjectHdr;
}
IPQOS_NAMED_QOSOBJECT, *PIPQOS_NAMED_QOSOBJECT;

//
// This MIB entry stores global config
// info for IP QOS MGR protocol.
//
typedef struct _IPQOS_GLOBAL_CONFIG 
{
    DWORD                  LoggingLevel;  // Detail of debug logging in qos

    ULONG                  NumFlowspecs;  // Number of flowspecs defined
    ULONG                  NumQosObjects; // Number of qos objects defined

//  IPQOS_NAMED_FLOWSPEC   FlowSpecs[0];  // Array of all flowspecs
//  
//  IPQOS_NAMED_QOSOBJECTS QosObjects[0]; // Array of all q objects
} 
IPQOS_GLOBAL_CONFIG, *PIPQOS_GLOBAL_CONFIG;

//
// Macros to operate on global config
//

#define IPQOS_GET_FIRST_FLOWSPEC_IN_CONFIG(Config)                     \
        (PIPQOS_NAMED_FLOWSPEC)((PUCHAR)(Config) +                     \
                                sizeof(IPQOS_GLOBAL_CONFIG))           \

#define IPQOS_GET_NEXT_FLOWSPEC_IN_CONFIG(Flowspec)                    \
        (Flowspec + 1)

#define IPQOS_GET_FIRST_QOSOBJECT_IN_CONFIG(Config)                    \
        (PIPQOS_NAMED_QOSOBJECT)((PUCHAR)(Config) +                    \
                                 sizeof(IPQOS_GLOBAL_CONFIG) +         \
                                 (Config->NumFlowspecs *               \
                                  sizeof(IPQOS_NAMED_FLOWSPEC)))

#define IPQOS_GET_NEXT_QOSOBJECT_IN_CONFIG(QosObject)                  \
        (PIPQOS_NAMED_QOSOBJECT)((PUCHAR) QosObject +                  \
                                 FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT,   \
                                              QosObjectHdr) +          \
                                 QosObject->QosObjectHdr.ObjectLength)

typedef struct _IPQOS_NAMED_FLOW
{
    WCHAR                SendingFlowspecName[MAX_STRING_LENGTH];
    WCHAR                RecvingFlowspecName[MAX_STRING_LENGTH];
    ULONG                NumTcObjects;

//  WCHAR                TcObjectNames[0];
}
IPQOS_NAMED_FLOW, *PIPQOS_NAMED_FLOW;

//
// Macros to operate on a named flow
//

#define IPQOS_GET_FIRST_OBJECT_NAME_ON_NAMED_FLOW(FlowDesc) \
        (PWCHAR) ((PUCHAR)(FlowDesc) + sizeof(IPQOS_NAMED_FLOW))

#define IPQOS_GET_NEXT_OBJECT_NAME_ON_NAMED_FLOW(ObjectName) \
        (ObjectName + MAX_STRING_LENGTH)

//
// Describes a generic flow description
//
typedef struct _IPQOS_IF_FLOW
{
    WCHAR              FlowName[MAX_STRING_LENGTH];
                                       // Name used to identify the flow
    ULONG              FlowSize;       // Number of bytes in description
    IPQOS_NAMED_FLOW   FlowDesc;       // Traffic Control API def'nd flow
} 
IPQOS_IF_FLOW, *PIPQOS_IF_FLOW;

//
// This MIB entry describes per-interface 
// config for IP QOS MGR protocol
//
typedef struct _IPQOS_IF_CONFIG
{
    DWORD              QosState;       // QOS State on this interface
    ULONG              NumFlows;       // Number of flows on this "if"

//  IPQOS_IF_FLOW      Flows[0];       // Variable length list of flows
} 
IPQOS_IF_CONFIG, *PIPQOS_IF_CONFIG;

// State of IF
#define IPQOS_STATE_DISABLED    0x00
#define IPQOS_STATE_ENABLED     0x01

//
// Macros to operate on if config
//

#define IPQOS_GET_FIRST_FLOW_ON_IF(Config) \
        (PIPQOS_IF_FLOW) ((PUCHAR)(Config) + sizeof(IPQOS_IF_CONFIG))

#define IPQOS_GET_NEXT_FLOW_ON_IF(CurrFlow) \
        (PIPQOS_IF_FLOW) ((PUCHAR)(CurrFlow) + (CurrFlow)->FlowSize)

//
// This MIB entry stores per-interface 
// statistics for IP QOS MGR protocol.
//
typedef struct _IPQOS_GLOBAL_STATS
{
    DWORD              LoggingLevel;    // Detail of debug logging in qos
} 
IPQOS_GLOBAL_STATS, *PIPQOS_GLOBAL_STATS;


//
// This MIB entry stores per-interface 
// statistics for IP QOS MGR protocol.
//
typedef struct _IPQOS_IF_STATS
{
    DWORD              QosState;       // QOS State on this interface
    ULONG              NumFlows;       // Number of flows on this "if"
} 
IPQOS_IF_STATS, *PIPQOS_IF_STATS;


//
// This is passed as input data for MibSet
// Note that only the global config and 
// interface config are writable structs.
//
typedef struct _IPQOS_MIB_SET_INPUT_DATA
{
    DWORD       TypeID;
    DWORD       IfIndex;
    DWORD       BufferSize;
    DWORD       Buffer[1];
}
IPQOS_MIB_SET_INPUT_DATA, *PIPQOS_MIB_SET_INPUT_DATA;


//
// This is passed as input data for - 
// MibGet, MibGetFirst and MibGetNext
//
typedef struct _IPQOS_MIB_GET_INPUT_DATA
{
    DWORD       TypeID;
    DWORD       IfIndex;
}
IPQOS_MIB_GET_INPUT_DATA, *PIPQOS_MIB_GET_INPUT_DATA;


//
// This is passed as output data for -
// MibGet, MibGetFirst, and MibGetNext.
// [
//    Note that at the end of a table 
//    MibGetNext wraps to the next,
//    and therefore the value TypeID
//    should be examined to see the 
//    type of data returned in output
// ]
//
typedef struct _IPQOS_MIB_GET_OUTPUT_DATA
{
    DWORD       TypeID;
    DWORD       IfIndex;
    BYTE        Buffer[1];
}
IPQOS_MIB_GET_OUTPUT_DATA, *PIPQOS_MIB_GET_OUTPUT_DATA;

#endif // __IPQOSRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\kdext\precomp.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Packet scheduler KD extension utilities.

Author:

    Rajesh Sundaram (1st Aug, 1998)

Revision History:

--*/
#if DBG
#define DEBUG 1
#endif

#define NT 1
#define _PNP_POWER  1
#define SECFLTR 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>
#include <winuser.h>
#include <ntosp.h>
#include <ndis.h>

#include <wdbgexts.h>
#include <stdio.h>

#include "psched.h"
#include "kdutil.h"
#include "sched.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\kdext\sched.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    DRRSeq.c

Abstract:

    Priority/DRR Sequencer.  This module is a scheduling component that
    determines the order in which submitted packets should be sent.

Author:


Environment:

    Kernel Mode

Revision History:

--*/

#ifndef _DRRSEQ_H_FILE

#define _DRRSEQ_H_FILE

// The sequencer classifies each flow into an internal "priority group" based
// on the flow's service type and conformance status. Within each priority
// group, there may be one or more priority levels or offsets.  The total
// number of internal priority levels is the sum of the priority levels for
// each priority group.  The internal priority assigned to each flow is
// calculated from the priority group and the relative priority within the
// group, which is obtained from the QOS Priority object.  The 802.1 priority,
// is set by the wrapper. The non conforming values are obtained from the 
// packet.
//
// The flows of the following servicetypes have no internal priority.
//     SERVICETYPE_BESTEFFORT
//     SERVICETYPE_NONCONFORMING
//     SERVICETYPE_QUALITATIVE.
// 
// SERVICETYPE_BESTEFFORT is treated as SERVICETYPE_QUALITATIVE in the sequencer, so the no of priority
// groups is 1 less than the no. of servicetypes.

#define RELATIVE_PRIORITIES             8
#define PRIORITY_GROUPS                 (NUM_TC_SERVICETYPES - 1)
#define INTERNAL_PRIORITIES             (((PRIORITY_GROUPS - 2) * RELATIVE_PRIORITIES) + 2)
#define DEFAULT_PRIORITY_OFFSET         3
#define DEFAULT_MIN_QUANTUM             1500

#define PRIORITY_GROUP_NON_CONFORMING   0
#define PRIORITY_GROUP_BEST_EFFORT      1
#define PRIORITY_GROUP_CONTROLLED_LOAD  2
#define PRIORITY_GROUP_GUARANTEED       3
#define PRIORITY_GROUP_NETWORK_CONTROL  4

//
// For maintaining stats
//
#define SEQUENCER_AVERAGING_ARRAY_SIZE      256
#define NETCARD_AVERAGING_ARRAY_SIZE        256
#define SEQUENCER_FLOW_AVERAGING_ARRAY_SIZE     256


// The DRR Sequencer's pipe information

typedef struct _DSEQ_PIPE {

    // ContextInfo -            Generic context info
    // Lock -                   Protects pipe and flow data
    // Flags -                  See below
    // Flows -                  List of all installed flows
    // ActiveFlows -            Lists of flows that are waiting to send packets
    // PriorityLevels -         Number of priority offsets for each priority group
    // StartPriority -          Lowest internal priority value for each priority group
    // ActiveFlowCount -        Number of active flows for each service type
    // MaxOutstandingSends -    Maximum number of outstanding sends
    // OutstandingSends -       Number of outstanding sends
    // PacketsInNetcardAveragingArray
    // PacketsInSequencer -     Current number packets in sequencer
    // PacketsInSequencerAveragingArray
    // Bandwidth -              Link speed
    // MinimumQuantum -         Minimum quantum size for DRR
    // MinimumRate -            Smallest rate currently assigned to a flow
    // TimerResolution -        Timer resolution in OS time units
    // PsFlags -                Flags from pipe parameters
    // PsPipeContext -          PS's pipe context value

    PS_PIPE_CONTEXT ContextInfo;
#ifdef INSTRUMENT
    PS_DRRSEQ_STATS Stats;
    PRUNNING_AVERAGE PacketsInNetcardAveragingArray;
    ULONG PacketsInSequencer;
    PRUNNING_AVERAGE PacketsInSequencerAveragingArray;
#endif
    NDIS_SPIN_LOCK Lock;
    ULONG Flags;
    LIST_ENTRY Flows;
    LIST_ENTRY ActiveFlows[INTERNAL_PRIORITIES];
    ULONG PriorityLevels[PRIORITY_GROUPS];
    ULONG StartPriority[PRIORITY_GROUPS];
    ULONG ActiveFlowCount[PRIORITY_GROUPS];
    ULONG TotalActiveFlows;
    ULONG MaxOutstandingSends;
    ULONG OutstandingSends;
    ULONG Bandwidth;
    ULONG MinimumQuantum;
    ULONG MinimumRate;
    ULONG TimerResolution;
    ULONG PsFlags;
    HANDLE PsPipeContext;
    PPS_PROCS PsProcs;
    PSU_SEND_COMPLETE PreviousUpcallsSendComplete;
    PPS_PIPE_CONTEXT   PreviousUpcallsSendCompletePipeContext;
} DSEQ_PIPE, *PDSEQ_PIPE;

// Pipe flag values

#define DSEQ_DEQUEUE            1
#define DSEQ_PASSTHRU           2

typedef enum _FLOW_STATE {
    DRRSEQ_FLOW_CREATED = 1,
    DRRSEQ_FLOW_DELETED
} FLOW_STATE;

// The DRR Sequencer's flow information

typedef struct _DSEQ_FLOW {

    // ContextInfo -            Generic context info
    // ActiveLinks -            Links in active flow list
    // Links -                  Links in installed flow list
    // PacketQueue -            Self-explanatory
    // PacketSendTime -         Send time for current packet
    // LastConformanceTime -    Absolute conformance time of last packet
    // TokenRate -              TokenRate from GQOS
    // UserPriority -           Priority offset assigned by user
    // Priority -               Internal priority
    // PriorityGroup -          Priority group for flow
    // Quantum -                Quantum assigned to flow for DRR
    // DeficitCounter -         Current value of DRR deficit counter
    // Flags -                  See below
    // PsFlowContext -          PS's flow context value
    // BucketSize -             TokenBucketSize from GQOS
    // NumPacketsInSeq -                Number of packets from this flow in the sequencer
    // PacketsInSeqAveragingArray-Data for computing average packets in seq from this flow

    PS_FLOW_CONTEXT ContextInfo;
    LIST_ENTRY ActiveLinks;
    LIST_ENTRY Links;
    LIST_ENTRY PacketQueue;
    LARGE_INTEGER PacketSendTime;
    LARGE_INTEGER LastConformanceTime;
    ULONG TokenRate;
    ULONG UserPriority;
    ULONG Priority;
    ULONG PriorityGroup;
    ULONG Quantum;
    ULONG DeficitCounter;
    ULONG Flags;
    HANDLE PsFlowContext;
    ULONG BucketSize;
#ifdef INSTRUMENT
        ULONG PacketsInSequencer;
    PS_DRRSEQ_STATS Stats;
        PRUNNING_AVERAGE PacketsInSeqAveragingArray;
#endif
    FLOW_STATE State;
} DSEQ_FLOW, *PDSEQ_FLOW;

#define MAX_DEQUEUED_PACKETS            8

#define FLOW_USER_PRIORITY              0x00000002

// The following macro checks a packet for conformance based on the flow's
// LastPacketTime, the current time, and the timer resolution.

#define PacketIsConforming(_flow, _curtime, _r) \
    ( (_flow)->PacketSendTime.QuadPart <= ((_curtime).QuadPart + (_r)) )

#define AdjustLastPacketTime(_flow, _curtime, _r) \
    if ((_curtime).QuadPart > ((_flow)->PacketSendTime.QuadPart + (_r))) \
        if ((_curtime).QuadPart > ((_flow)->LastConformanceTime.QuadPart - (_r))) \
            (_flow)->PacketSendTime = (_flow)->LastConformanceTime; \
        else \
            (_flow)->PacketSendTime = (_curtime);



// The Shaper's pipe information

typedef struct _TS_PIPE {

    // ContextInfo -            Generic context info
    // Lock -                   Protects pipe data
    // ActiveFlows -            List of flows that are waiting to send packets
    // Timer -                  Timer struct
    // TimerStatus -            Status of timer
    // TimerResolution -        Timer resolution in OS time units
    // PsPipeContext -          PS's pipe context value
    // DropPacket -             PS's drop packet routine
    // ControlledLoadMode -     Default mode for non-conforming traffic from
    //                          controlled load flows
    // GuaranteedMode -         Default mode for non-conforming traffic from
    //                          guaranteed service flows
    // IntermediateSystem -     TRUE if "IS" mode should be used for implementing discard semantics
    // Stats -                  Per Pipe stats.
    // PacketsInShaperAveragingArray

    PS_PIPE_CONTEXT ContextInfo;
#ifdef INSTRUMENT
    PS_SHAPER_STATS Stats;
    PRUNNING_AVERAGE PacketsInShaperAveragingArray;
    ULONG PacketsInShaper;
#endif
    NDIS_SPIN_LOCK Lock;
    LIST_ENTRY ActiveFlows;
    NDIS_MINIPORT_TIMER Timer;
    ULONG TimerStatus;
    ULONG TimerResolution;
    HANDLE PsPipeContext;
    PPS_PROCS PsProcs;
    ULONG ControlledLoadMode;
    ULONG GuaranteedMode;
    ULONG NetworkControlMode;
    ULONG Qualitative;
    ULONG IntermediateSystem;
} TS_PIPE, *PTS_PIPE;

#define TIMER_UNINITIALIZED     0
#define TIMER_INACTIVE          1
#define TIMER_SET               2
#define TIMER_PROC_EXECUTING    3


// The Shaper's flow information

typedef struct _TS_FLOW {

    // ContextInfo -            Generic context info
    // Flags -                  See below
    // Links -                  Links in active flow list
    // Mode -                   Shape/Discard mode
    // Shape -                  Indicates whether to shape traffic
    // PacketQueue -            Self-explanatory
    // FlowEligibilityTime -    Absolute conformance time of 1st packet in queue
    // PsFlowContext -          PS's flow context value
    // Stats -                  Per flow stats.
    // PacketsInShaperAveragingArray - Per flow averaging data
    // State -                  State of the flow

    PS_FLOW_CONTEXT ContextInfo;
    ULONG Flags;
    LIST_ENTRY Links;
    ULONG Mode;
    ULONG Shape;
    LIST_ENTRY PacketQueue;
    LARGE_INTEGER FlowEligibilityTime;
    HANDLE PsFlowContext;
#ifdef QUEUE_LIMIT
    ULONG QueueSize;
    ULONG QueueSizeLimit;
    ULONG DropOverLimitPacketsFromHead;
    ULONG UseDefaultQueueLimit;
#endif // QUEUE_LIMIT
#ifdef INSTRUMENT
    ULONG PacketsInShaper;
    PS_SHAPER_STATS Stats;
        PRUNNING_AVERAGE PacketsInShaperAveragingArray;
#endif
    FLOW_STATE State;
} TS_FLOW, *PTS_FLOW;

typedef struct _TBC_PIPE {

    // ContextInfo -            Generic context info
    // MaxPacket -              Maximum packet size for pipe
    // PsPipeContext -          PS's pipe context value
    // DropPacket -             PS's drop packet routine
    // HeaderLength -           Length of MAC header for this pipe
    // ControlledLoadMode -     Default mode for non-conforming traffic from
    //                          controlled load flows
    // GuaranteedMode -         Default mode for non-conforming traffic from
    //                          guaranteed service flows
    // IntermediateSystem -     TRUE if "IS" mode should be used for implementing discard semantics
    // Stats -                  Per Pipe stats.

    PS_PIPE_CONTEXT ContextInfo;
#ifdef INSTRUMENT
    PS_CONFORMER_STATS Stats;
#endif // INSTRUMENT
    ULONG MaxPacket;
    HANDLE PsPipeContext;
    ULONG TimerResolution;
    PPS_PROCS PsProcs;
    ULONG HeaderLength;
    ULONG ControlledLoadMode;
    ULONG GuaranteedMode;
    ULONG NetworkControlMode;
    ULONG Qualitative;
    ULONG IntermediateSystem;
} TBC_PIPE, *PTBC_PIPE;

// The conformer's flow information

typedef struct _TBC_FLOW {

    // ContextInfo -            Generic context info
    // Lock -                   Protects flow data
    // TokenRate -              TokenRate from generic QoS
    // Capacity -               TokenBucketSize from generic QoS
    // PeakRate -               PeakBandwidth from generic QoS
    // MinPolicedUnit -         MinimumPolicedUnit from generic QoS
    // Mode -                   Flow S/D mode
    // NoConformance -          Indicates whether flow is exempt from conformance algorithm
    // LastConformanceTime -    Absolute tb conformance time of last non-discarded packet
    // LastPeakTime -           Absolute peak conformance time of last non-discarded packet 
    // PeakConformanceTime -    Earliest time next packet can be sent, based on peak rate
    // LastConformanceCredits - Number of credits at LastConformanceTime
    // PsFlowContext -          PS's flow context value
    // Stats -                  Per flow stats.

    PS_FLOW_CONTEXT ContextInfo;
    NDIS_SPIN_LOCK Lock;
    ULONG TokenRate;
    ULONG Capacity;
    ULONG PeakRate;
    ULONG MinPolicedUnit;
    ULONG Mode;
    ULONG NoConformance;
    LARGE_INTEGER LastConformanceTime;
    LARGE_INTEGER LastPeakTime;
    LARGE_INTEGER PeakConformanceTime;
    ULONG LastConformanceCredits;
    HANDLE PsFlowContext;
#ifdef INSTRUMENT
    PS_CONFORMER_STATS Stats;
#endif // INSTRUMENT
} TBC_FLOW, *PTBC_FLOW;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-netsh\qos.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    qos.c

Abstract:

    IP QOS Command dispatcher.

Revision History:

--*/

#include "precomp.h"

#pragma hdrstop

//
// Declare and Init Global Variables for QOS Extension
//

#ifdef ALLOW_CHILD_HELPERS
PIP_CONTEXT_TABLE_ENTRY g_QosContextTable  = NULL;
DWORD                   g_dwNumQosContexts = 0;
#endif

//
// The table of Add, Delete, Set, Show Commands for QOS
//

//
// The commands are prefix-matched with the command-line, in sequential
// order. So a command like 'ADD INTERFACE FLOW' must come before
// the command 'ADD INTERFACE' in the table.
//

CMD_ENTRY  g_QosAddCmdTable[] = {
/* CREATE_CMD_ENTRY(QOS_ADD_FILTER_TO_FLOW, HandleQosAttachFilterToFlow),*/
    CREATE_CMD_ENTRY(QOS_ADD_QOSOBJECT_ON_FLOW, HandleQosAddQosObjectOnIfFlow),
    CREATE_CMD_ENTRY(QOS_ADD_FLOWSPEC_ON_FLOW, HandleQosAddFlowspecOnIfFlow),
    CREATE_CMD_ENTRY(QOS_ADD_FLOW_ON_IF, HandleQosAddFlowOnIf),
    CREATE_CMD_ENTRY(QOS_ADD_IF, HandleQosAddIf),
    CREATE_CMD_ENTRY(QOS_ADD_DSRULE, HandleQosAddDsRule),
    CREATE_CMD_ENTRY(QOS_ADD_SDMODE, HandleQosAddSdMode),
    CREATE_CMD_ENTRY(QOS_ADD_FLOWSPEC, HandleQosAddFlowspec),
#ifdef ALLOW_CHILD_HELPERS
    CREATE_CMD_ENTRY(ADD_HELPER, HandleQosAddHelper),
#endif
};

CMD_ENTRY  g_QosDelCmdTable[] = {
/* CREATE_CMD_ENTRY(QOS_DEL_FILTER_FROM_FLOW, HandleQosDetachFilterFromFlow),*/
    CREATE_CMD_ENTRY(QOS_DEL_QOSOBJECT_ON_FLOW, HandleQosDelQosObjectOnIfFlow),
    CREATE_CMD_ENTRY(QOS_DEL_FLOWSPEC_ON_FLOW, HandleQosDelFlowspecOnIfFlow),
    CREATE_CMD_ENTRY(QOS_DEL_FLOW_ON_IF, HandleQosDelFlowOnIf),
    CREATE_CMD_ENTRY(QOS_DEL_IF, HandleQosDelIf),
    CREATE_CMD_ENTRY(QOS_DEL_DSRULE, HandleQosDelDsRule),
    CREATE_CMD_ENTRY(QOS_DEL_SDMODE, HandleQosDelQosObject),
    CREATE_CMD_ENTRY(QOS_DEL_QOSOBJECT, HandleQosDelQosObject),
    CREATE_CMD_ENTRY(QOS_DEL_FLOWSPEC, HandleQosDelFlowspec),
#ifdef ALLOW_CHILD_HELPERS
    CREATE_CMD_ENTRY(DEL_HELPER, HandleQosDelHelper),
#endif
};

CMD_ENTRY  g_QosSetCmdTable[] = {
/* CREATE_CMD_ENTRY(QOS_SET_FILTER_ON_FLOW, HandleQosModifyFilterOnFlow),*/
/* CREATE_CMD_ENTRY(QOS_SET_IF, HandleQosSetIf), */
   CREATE_CMD_ENTRY(QOS_SET_GLOBAL, HandleQosSetGlobal)
};

CMD_ENTRY  g_QosShowCmdTable[] = {
/* CREATE_CMD_ENTRY(QOS_SHOW_FILTER_ON_FLOW, HandleQosShowFilterOnFlow),*/
    CREATE_CMD_ENTRY(QOS_SHOW_FLOW_ON_IF, HandleQosShowFlowOnIf),
    CREATE_CMD_ENTRY(QOS_SHOW_IF, HandleQosShowIf),
    CREATE_CMD_ENTRY(QOS_SHOW_DSMAP, HandleQosShowDsMap),
    CREATE_CMD_ENTRY(QOS_SHOW_SDMODE, HandleQosShowSdMode),
    CREATE_CMD_ENTRY(QOS_SHOW_QOSOBJECT, HandleQosShowQosObject),
    CREATE_CMD_ENTRY(QOS_SHOW_FLOWSPEC, HandleQosShowFlowspec),
    CREATE_CMD_ENTRY(QOS_SHOW_GLOBAL, HandleQosShowGlobal),
#ifdef ALLOW_CHILD_HELPERS
    CREATE_CMD_ENTRY(SHOW_HELPER, HandleQosShowHelper),
#endif
};

CMD_GROUP_ENTRY g_QosCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_QosAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_QosDelCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_QosSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_QosShowCmdTable),
};

ULONG   g_ulQosNumGroups = sizeof(g_QosCmdGroups)/sizeof(CMD_GROUP_ENTRY);

CMD_ENTRY g_QosCmds[] =
{
    CREATE_CMD_ENTRY(INSTALL, HandleQosInstall),
    CREATE_CMD_ENTRY(UNINSTALL, HandleQosUninstall),
};

ULONG g_ulQosNumTopCmds = sizeof(g_QosCmds)/sizeof(CMD_ENTRY);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-netsh\common.c ===
#include "precomp.h"
#pragma hdrstop

// {0705ECA3-7AAC-11d2-89DC-006008B0E5B9}
const GUID g_MyGuid = 
{ 0x705eca3, 0x7aac, 0x11d2, { 0x89, 0xdc, 0x0, 0x60, 0x8, 0xb0, 0xe5, 0xb9 } };

static const GUID g_IpGuid = IPMONTR_GUID;

#define IPPROMON_HELPER_VERSION 1

// shell functions

PNS_REGISTER_HELPER     RegisterHelper;
PNS_MATCH_CMD_LINE      MatchCmdToken;
PNS_MATCH_TOKEN         MatchToken;
PNS_MATCH_ENUM_TAG      MatchEnumTag;
PNS_MATCH_TAGS_IN_CMD_LINE     MatchTagsInCmdLine;
PNS_MAKE_STRING         MakeString;
PNS_FREE_STRING         FreeString;
PNS_MAKE_QUOTED_STRING  MakeQuotedString;
PNS_FREE_QUOTED_STRING  FreeQuotedString;
PNS_DISPLAY_ERR         DisplayError;
PNS_DISPLAY_MSG         DisplayMessage;
PNS_DISPLAY_MSG_T       DisplayMessageT;
PNS_EXECUTE_HANDLER     ExecuteHandler;
PNS_INIT_CONSOLE        InitializeConsole;
PNS_DISPLAY_MSG_CONSOLE DisplayMessageMib;
PNS_REFRESH_CONSOLE     RefreshConsole;
PNS_UPDATE_NEW_CONTEXT  UpdateNewContext;
PNS_PREPROCESS_COMMAND  PreprocessCommand;

ULONG StartedCommonInitialization, CompletedCommonInitialization ;
HANDLE g_hModule;
MIB_SERVER_HANDLE g_hMibServer;

VOID
CommonNetshInit(
    IN  PNETSH_ATTRIBUTES           pUtilityTable
    )
{
    //
    // common utility functions exported by the shell
    //
        
    RegisterHelper              = pUtilityTable->pfnRegisterHelper;
    MatchCmdToken               = pUtilityTable->pfnMatchCmdLine;
    MatchToken                  = pUtilityTable->pfnMatchToken;
    MatchEnumTag                = pUtilityTable->pfnMatchEnumTag;
    MatchTagsInCmdLine          = pUtilityTable->pfnMatchTagsInCmdLine;
    MakeString                  = pUtilityTable->pfnMakeString;
    FreeString                  = pUtilityTable->pfnFreeString;
    MakeQuotedString            = pUtilityTable->pfnMakeQuotedString;
    FreeQuotedString            = pUtilityTable->pfnFreeQuotedString;
    DisplayError                = pUtilityTable->pfnDisplayError;
    DisplayMessage              = pUtilityTable->pfnDisplayMessage;
    DisplayMessageT             = pUtilityTable->pfnDisplayMessageT;
    ExecuteHandler              = pUtilityTable->pfnExecuteHandler;
    InitializeConsole           = pUtilityTable->pfnInitializeConsole;
    DisplayMessageMib           = pUtilityTable->pfnDisplayMessageToConsole;
    RefreshConsole              = pUtilityTable->pfnRefreshConsole;
    UpdateNewContext            = pUtilityTable->pfnUpdateNewContext;
    PreprocessCommand           = pUtilityTable->pfnPreprocessCommand;
}

BOOL WINAPI
DllMain(
    HINSTANCE hInstDll,
    DWORD fdwReason,
    LPVOID pReserved
    )
{
    HANDLE     hDll;
    
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            // printf("Trying to attach\n");
            
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            //
            // Clean up any structures used for commit
            //
            
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}

DWORD WINAPI
IppromonStartHelper(
    IN CONST GUID *pguidParent,
    IN PVOID       pfnRegisterContext,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    PNS_REGISTER_CONTEXT RegisterContext 
        = (PNS_REGISTER_CONTEXT) pfnRegisterContext;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    // If you add any more contexts, then this should be converted
    // to use an array instead of duplicating code!

    // Register the IGMP context

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes)); 

    attMyAttributes.pwszContext = L"igmp";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = IgmpDump;
    attMyAttributes.ulNumTopCmds= g_ulNumIgmpTopCmds;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_IgmpCmds;
    attMyAttributes.ulNumGroups = g_ulIgmpNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_IgmpCmdGroups;

    dwErr = RegisterContext( &attMyAttributes );

    // Register the RIP context

    attMyAttributes.pwszContext = L"rip";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = RipDump;
    attMyAttributes.ulNumTopCmds= g_ulRipNumTopCmds;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_RipCmds;
    attMyAttributes.ulNumGroups = g_ulRipNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_RipCmdGroups;

    dwErr = RegisterContext( &attMyAttributes );

    // Register the OSPF context

    attMyAttributes.pwszContext = L"ospf";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = OspfDump;
    attMyAttributes.ulNumTopCmds= g_ulOspfNumTopCmds;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_OspfCmds;
    attMyAttributes.ulNumGroups = g_ulOspfNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_OspfCmdGroups;

    dwErr = RegisterContext( &attMyAttributes );

    // Register the RouterDiscovery relay context

    attMyAttributes.pwszContext = L"routerdiscovery";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = RdiscDump;
    attMyAttributes.ulNumTopCmds= g_RdiscTopCmdCount;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_RdiscTopCmdTable;
    attMyAttributes.ulNumGroups = g_RdiscCmdGroupCount;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_RdiscCmdGroupTable;

    dwErr = RegisterContext( &attMyAttributes );

    // Register the DHCP relay context

    attMyAttributes.pwszContext = L"relay";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = BootpDump;
    attMyAttributes.ulNumTopCmds= g_ulBootpNumTopCmds;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_BootpTopCmds;
    attMyAttributes.ulNumGroups = g_ulBootpNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_BootpCmdGroups;

    dwErr = RegisterContext( &attMyAttributes );

    // Register the Connection sharing contexts

    attMyAttributes.pwszContext = L"autodhcp";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = AutoDhcpDump;
    attMyAttributes.ulNumTopCmds= g_AutoDhcpTopCmdCount;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_AutoDhcpTopCmdTable;
    attMyAttributes.ulNumGroups = g_AutoDhcpCmdGroupCount;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_AutoDhcpCmdGroupTable;

    dwErr = RegisterContext( &attMyAttributes );
    
    attMyAttributes.pwszContext = L"dnsproxy";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = DnsProxyDump;
    attMyAttributes.ulNumTopCmds= g_DnsProxyTopCmdCount;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_DnsProxyTopCmdTable;
    attMyAttributes.ulNumGroups = g_DnsProxyCmdGroupCount;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_DnsProxyCmdGroupTable;

    dwErr = RegisterContext( &attMyAttributes );
    
    attMyAttributes.pwszContext = L"nat";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = NatDump;
    attMyAttributes.ulNumTopCmds= g_NatTopCmdCount;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_NatTopCmdTable;
    attMyAttributes.ulNumGroups = g_NatCmdGroupCount;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_NatCmdGroupTable;

    dwErr = RegisterContext( &attMyAttributes );

    attMyAttributes.pwszContext = L"qos";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = QosDump;
    attMyAttributes.ulNumTopCmds= g_ulQosNumTopCmds;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_QosCmds;
    attMyAttributes.ulNumGroups = g_ulQosNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_QosCmdGroups;

    dwErr = RegisterContext( &attMyAttributes );
    
    return dwErr;
}

DWORD WINAPI
InitHelperDll(
    IN  PNETSH_ATTRIBUTES        pUtilityTable,
    OUT PNS_DLL_ATTRIBUTES       pDllTable
    )
{
    DWORD dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    CommonNetshInit( pUtilityTable );

    pDllTable->dwVersion = NETSH_VERSION_50;
    pDllTable->pfnStopFn = NULL;

    // Register helpers.  We could either register 1 helper which
    // registers three contexts, or we could register 3 helpers
    // which each register one context.  There's only a difference
    // if we support sub-helpers, which this DLL does not.
    // If we later support sub-helpers, then it's better to have
    // 3 helpers so that sub-helpers can register with 1 of them,
    // since it registers with a parent helper, not a parent context.
    // For now, we just use a single 3-context helper for efficiency.

    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.guidHelper         = g_MyGuid;
    attMyAttributes.dwVersion          = IPPROMON_HELPER_VERSION;
    attMyAttributes.pfnStart           = IppromonStartHelper;
    attMyAttributes.pfnStop            = NULL;

    dwErr = RegisterHelper( &g_IpGuid, &attMyAttributes );

    return dwErr;
}

BOOL
IsProtocolInstalled(
    DWORD  dwProtoId,
    DWORD  dwNameId,
    DWORD dwErrorLog
    )
/*++

Routine Description:

    Finds if the protocol is already installed

Arguments:

    dwProtoId      - protocol id
    pswzName       - protocol name
    dwErrorLog     - TRUE(if not installed display error)
                     FALSE(if installed display error)
                     -1 (do not display error log)
Return Value:

    TRUE if protocol already installed, else FALSE

--*/

{
    PVOID       pvStart;
    DWORD       dwCount, dwBlkSize, dwRes;
    WCHAR      *pwszName;

    dwRes = IpmontrGetInfoBlockFromGlobalInfo(dwProtoId,
                                       (PBYTE *) NULL,
                                       &dwBlkSize,
                                       &dwCount);

    if ((dwRes isnot NO_ERROR) && (dwErrorLog == TRUE))
    {
        pwszName = MakeString( g_hModule, dwNameId);
        DisplayError(g_hModule, EMSG_PROTO_NOT_INSTALLED, pwszName);
        FreeString(pwszName);
    }
    else if ((dwRes == NO_ERROR) && (dwErrorLog == FALSE))
    {
        pwszName = MakeString( g_hModule, dwNameId);
        DisplayError(g_hModule, EMSG_PROTO_INSTALLED, pwszName);
        FreeString(pwszName);
    }

    return (dwRes == NO_ERROR) ? TRUE : FALSE;
}

DWORD
GetMIBIfIndex(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
    )
/*++

Routine Description:

    Gets the interface index.

Arguments:

    pptcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command

Return Value:

    NO_ERROR

--*/
{
    DWORD dwErr = NO_ERROR;

    *pdwNumParsed = 1;

    // If index was specified just use it

    if (iswdigit(pptcArguments[dwCurrentIndex][0]))
    {
        pdwIndices[0] = _tcstoul(pptcArguments[dwCurrentIndex],NULL,10);

        return NO_ERROR;
    }

    // Try converting a friendly name to an ifindex

    return IpmontrGetIfIndexFromFriendlyName( g_hMibServer,
                                       pptcArguments[dwCurrentIndex],
                                       &pdwIndices[0] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-netsh\qoscfg.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    qoscfg.c

Abstract:

    Fns to change configuration for IP QOS

Revision History:

--*/

#include "precomp.h"

#pragma hdrstop


static IPQOS_GLOBAL_CONFIG
g_ipqosGlobalDefault = {
    IPQOS_LOGGING_ERROR                 // Logging level
};

static BYTE* g_pIpqosGlobalDefault = (BYTE*)&g_ipqosGlobalDefault;

static IPQOS_IF_CONFIG
g_ipqosInterfaceDefault = {
    IPQOS_STATE_ENABLED,
    0                                   // NULL flow list
};

static BYTE* g_pIpqosInterfaceDefault = (BYTE*)&g_ipqosInterfaceDefault;


//
// If one of the arguments is specified with a name tag
// then all arguments must come with name tags.
// If no name tags, then arguments are assumed to be in a certain order
//

DWORD
MakeQosGlobalInfo(
    OUT      PBYTE                    *ppbStart,
    OUT      PDWORD                   pdwSize
    )
/*++

Routine Descqostion:

    Creates a QOS global info block.

Arguments:

    ppbStart  - Pointer to the info block
    pdwSize   - Pointer to size of the info block
    
Return Value:

    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    *pdwSize = sizeof(IPQOS_GLOBAL_CONFIG);

    *ppbStart = HeapAlloc(GetProcessHeap(), 0, *pdwSize);

    if (*ppbStart is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    CopyMemory( *ppbStart, g_pIpqosGlobalDefault, *pdwSize);
    
    return NO_ERROR;
}

DWORD
ShowQosGlobalInfo (
    HANDLE hFile
    )
/*++

Routine Descqostion:

    Displays QOS global config info

Arguments:

Return Value:

    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    VALUE_TOKEN    vtLogLevelTable1[] 
                                = {IPQOS_LOGGING_NONE,TOKEN_OPT_VALUE_NONE,
                                   IPQOS_LOGGING_ERROR,TOKEN_OPT_VALUE_ERROR,
                                   IPQOS_LOGGING_WARN,TOKEN_OPT_VALUE_WARN,
                                   IPQOS_LOGGING_INFO,TOKEN_OPT_VALUE_INFO};

    VALUE_STRING   vtLogLevelTable2[] 
                                = {IPQOS_LOGGING_NONE,STRING_LOGGING_NONE,
                                   IPQOS_LOGGING_ERROR,STRING_LOGGING_ERROR,
                                   IPQOS_LOGGING_WARN,STRING_LOGGING_WARN,
                                   IPQOS_LOGGING_INFO,STRING_LOGGING_INFO};

    PIPQOS_GLOBAL_CONFIG pigc = NULL;
    PTCHAR   ptszLogLevel = NULL;
    DWORD    dwBlkSize, dwCount, dwRes;
    
    do
    {
        dwRes = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                                  (PBYTE *) &pigc,
                                                  &dwBlkSize,
                                                  &dwCount);
        if (dwBlkSize is 0)
        {
            dwRes = ERROR_NOT_FOUND;
        }
        
        if ( dwRes isnot NO_ERROR )
        {
            break;
        }

        //
        // getting logging mode string
        //

        if (hFile) 
        {
            dwRes = GetDisplayStringT(g_hModule,
                                      pigc->LoggingLevel,
                                      vtLogLevelTable1,
                                      NUM_VALUES_IN_TABLE(vtLogLevelTable1),
                                      &ptszLogLevel) ;
        } 
        else 
        {
            dwRes = GetDisplayString(g_hModule,
                                     pigc->LoggingLevel,
                                     vtLogLevelTable2,
                                     NUM_VALUES_IN_TABLE(vtLogLevelTable1),
                                     &ptszLogLevel) ;
        }

        if (dwRes != NO_ERROR)
            return dwRes ;
        

        if ( ptszLogLevel == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (hFile)
        {
            //
            // dump qos global info
            //
            
            // DisplayMessageT(DMP_QOS_GLOBAL_HEADER) ;

            // DisplayMessageT(DMP_QOS_UNINSTALL) ;
            
            DisplayMessageT(DMP_QOS_INSTALL) ;
            
            DisplayMessageT(DMP_QOS_SET_GLOBAL,
                            ptszLogLevel);

            // DisplayMessageT(DMP_QOS_GLOBAL_FOOTER) ;
        }
        else
        {
            //
            // display qos global info
            //

            DisplayMessage(g_hModule, 
                           MSG_QOS_GLOBAL_INFO,
                           ptszLogLevel);
        }

        dwRes = NO_ERROR;

    } while ( FALSE );

    HEAP_FREE_NOT_NULL(pigc);
    
    if ( ptszLogLevel ) { FreeString( ptszLogLevel ); }

    if (hFile is NULL)
    {
        switch(dwRes)
        {
            case NO_ERROR:
                break;
    
            case ERROR_NOT_FOUND:
                DisplayMessage(g_hModule, EMSG_PROTO_NO_GLOBAL_INFO);
                break;
                
            case ERROR_NOT_ENOUGH_MEMORY:
                DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                break;
    
            default:
                DisplayError(g_hModule, dwRes);
                break;
        }
    }
    
    return NO_ERROR;
}


DWORD
UpdateQosGlobalConfig(
    PIPQOS_GLOBAL_CONFIG   pigcGlobalCfg,
    DWORD                  dwBitVector
    )
/*++

Routine Descqostion:

    Updates QOS global config info

Arguments:

    pigcGlobalCfg - The new values to be set
    dwBitVector   - Which fields need to be modified
    
Return Value:

    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{

    DWORD                   dwRes = (DWORD) -1, dwIndex     = (DWORD) -1;
    DWORD                   dwSize      = 0, dwCount, i, j;
    DWORD                   dwBlkSize, dwNewBlkSize, dwQosCount;
    PDWORD                  pdwAddrTable= NULL, pdwNewAddrTable = NULL;
    PDWORD                  pdwSrcAddrTable = NULL;
    PIPQOS_GLOBAL_CONFIG    pigcSrc     = NULL, pigcDst     = NULL;
    PBOOL                   pbToDelete;


    DEBUG("In UpdateQosGlobalConfig");

    if (dwBitVector is 0)
    {
        return ERROR_OKAY;
    }

    //
    // Get Global Config info from Registry first
    //

    do
    {
        dwRes = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                                  (PBYTE *) &pigcSrc,
                                                  &dwBlkSize,
                                                  &dwQosCount);
    
        if (dwRes != NO_ERROR)
        {
            break;
        }
        
        if ( pigcSrc == NULL )
        {
            dwRes = ERROR_NOT_FOUND;
            break;
        }

        //
        // We have a fixed len global info - so
        // no reallocation and recopy necessary
        //
        dwNewBlkSize = dwBlkSize;

        pigcDst = pigcSrc;

        if (dwBitVector & QOS_LOG_MASK)
        {
            pigcDst->LoggingLevel = pigcGlobalCfg->LoggingLevel;
        }

        //
        // Set the info
        //
        
        dwRes = IpmontrSetInfoBlockInGlobalInfo(MS_IP_QOSMGR,
                                                (PBYTE) pigcDst,
                                                dwNewBlkSize,
                                                dwQosCount);
        if (dwRes != NO_ERROR)
        {
            break;
        }
        
            
    } while (FALSE);
    
    HEAP_FREE_NOT_NULL(pigcSrc);

    //
    // error processing
    //

    switch(dwRes)
    {
    case NO_ERROR:

        dwRes = ERROR_OKAY;

        break;

    case ERROR_NOT_FOUND:

        DisplayMessage(g_hModule, EMSG_PROTO_NO_GLOBAL_INFO );

        dwRes = ERROR_SUPPRESS_OUTPUT;

        break;

    default:

        break;
    }

    return dwRes;
}


DWORD
MakeQosInterfaceInfo(
    IN      ROUTER_INTERFACE_TYPE   rifType,
    OUT     PBYTE                   *ppbStart,
    OUT     PDWORD                  pdwSize
    )
/*++

Routine Descqostion:

    Creates a QOS interface info block.

Arguments:

    rifType   - Interface type
    ppbStart  - Pointer to the info block
    pdwSize   - Pointer to size of the info block
    
Return Value:

    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    *pdwSize = sizeof(IPQOS_IF_CONFIG);

    *ppbStart = HeapAlloc(GetProcessHeap(), 0, *pdwSize);

    if (*ppbStart is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory( *ppbStart, g_pIpqosInterfaceDefault, *pdwSize);

    return NO_ERROR;
}


DWORD
ShowQosAllInterfaceInfo(
    IN    HANDLE    hFile
    )
/*++

Routine Descqostion:

    Displays config info for all
    qos enabled interfaces

Arguments:

    hFile - NULL, or file handle
    
--*/
{
    DWORD               dwErr, dwCount, dwTotal;
    DWORD               dwNumParsed, i, dwNumBlocks=1, dwSize, dwIfType;
    PBYTE               pBuffer;
    PMPR_INTERFACE_0    pmi0;
    WCHAR               wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];


    //
    // dump qos config for all interfaces
    //

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0,
                                 &dwCount,
                                 &dwTotal);
    if(dwErr != NO_ERROR)
    {
        return dwErr;
    }

    for(i = 0; i < dwCount; i++)
    {
        // make sure that Qos is configured on that interface

        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pmi0[i].wszInterfaceName,
                                                     MS_IP_QOSMGR,
                                                     &pBuffer,
                                                     &dwSize,
                                                     &dwNumBlocks,
                                                     &dwIfType);
        if (dwErr isnot NO_ERROR) {
            continue;
        }
        else {
            HEAP_FREE(pBuffer) ;
        }


        ShowQosInterfaceInfo(hFile, pmi0[i].wszInterfaceName) ;

        //
        // At this point we do not have any flags on interface
        // 
        // if (hFile)
        // {
        //    //
        //    // only for dump include the flag setting as part of
        //    // interface settings.  Otherwise Interface flag settings
        //    // are handled by the show flags command
        //    //
        // 
        //    ShowQosInterfaceFlags(hFile, pmi0[i].wszInterfaceName);
        // }
    }
    return NO_ERROR ;

}


DWORD
ShowQosInterfaceInfo(
    IN    HANDLE    hFile,
    IN    PWCHAR    pwszIfGuid
    )
/*++

Routine Descqostion:

    Displays QOS interface config info

Arguments:

    pwszIfGuid - Interface name
    
Return Value:

    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    WCHAR   wszInterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ] = L"\0";
    PWCHAR  pwszFriendlyIfName = NULL;

    DWORD   dwBufferSize = sizeof(wszInterfaceName);

    DWORD                   dwRes           = (DWORD) -1,
                            dwCnt           = 0;

    PDWORD                  pdwAddr         = NULL;

    PIPQOS_IF_CONFIG        piic            = NULL;

    PTCHAR                  ptszState       = NULL;

    VALUE_TOKEN  vtStateTable1[] 
                             = {IPQOS_STATE_ENABLED,TOKEN_OPT_VALUE_ENABLE,
                                IPQOS_STATE_DISABLED,TOKEN_OPT_VALUE_DISABLE};

    VALUE_STRING vtStateTable2[] 
                             = {IPQOS_STATE_ENABLED,STRING_ENABLED,
                                IPQOS_STATE_DISABLED,STRING_DISABLED};

    DWORD                   dwBlkSize, dwIfType, dwCount;
    
    do
    {
        dwRes = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfGuid,
                                                     MS_IP_QOSMGR,
                                                     (PBYTE *) &piic,
                                                     &dwBlkSize,
                                                     &dwCount,
                                                     &dwIfType);
        
        if (dwBlkSize is 0)
            dwRes = ERROR_NOT_FOUND;

        if (dwRes isnot NO_ERROR)
        {
            break;
        }

        //
        // get friendly name for interface
        //
    
        dwRes = IpmontrGetFriendlyNameFromIfName( pwszIfGuid,
                                                  wszInterfaceName,
                                                  &dwBufferSize );
    
        if ( dwRes isnot NO_ERROR )
        {
            break;
        }
    
        pwszFriendlyIfName = MakeQuotedString( wszInterfaceName );
    
        if ( pwszFriendlyIfName == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
    
            break;
        }

        //
        // get state of the interface
        //

        GetAltDisplayString(g_hModule, hFile,
                      piic->QosState,
                      vtStateTable1,
                      vtStateTable2,
                      NUM_VALUES_IN_TABLE(vtStateTable1),
                      &ptszState);

        if ( ptszState == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (hFile)
        {
            DisplayMessageT(DMP_QOS_INTERFACE_HEADER,
                            pwszFriendlyIfName);

            DisplayMessageT(DMP_QOS_DELETE_INTERFACE,
                           pwszFriendlyIfName);

            DisplayMessageT(DMP_QOS_ADD_INTERFACE,
                           pwszFriendlyIfName,
                           ptszState);

            DisplayMessageT(DMP_QOS_SET_INTERFACE,
                           pwszFriendlyIfName,
                           ptszState);

            ShowQosFlowsOnIf(hFile, pwszIfGuid, NULL);

            DisplayMessageT(DMP_QOS_INTERFACE_FOOTER,
                            pwszFriendlyIfName);
        }
        else
        {
            DisplayMessage(g_hModule, MSG_QOS_IF_INFO,
                           pwszFriendlyIfName,
                           ptszState);

            ShowQosFlowsOnIf(hFile, pwszIfGuid, NULL);
        }


        dwRes = NO_ERROR;

    } while ( FALSE );

    HEAP_FREE_NOT_NULL(piic);

    FREE_STRING_NOT_NULL( ptszState ) ;

    if ( pwszFriendlyIfName )
    {
        FreeQuotedString( pwszFriendlyIfName );
    }

    switch(dwRes)
    {
        case NO_ERROR:
            break;

        case ERROR_NOT_FOUND:
            DisplayMessage(g_hModule, EMSG_PROTO_NO_IF_INFO,
                                L"RouterInterfaceConfig");
            break;
            
        default:
            DisplayError(g_hModule, dwRes);
            break;
    }

    return NO_ERROR;
}

DWORD
UpdateQosInterfaceConfig( 
    IN    PWCHAR              pwszIfGuid,                         
    IN    PIPQOS_IF_CONFIG    pChangeCfg,
    IN    DWORD               dwBitVector,
    IN    BOOL                bAddSet
    )
/*++

Routine Descqostion:

    Updates QOS interface config info

Arguments:

    pwszIfGuid    - Interface name
    pFinalCfg     - The old config(if bSet), or default config(if bAdd)
    pChangeCfg    - The changes to be applied to pFinalCfg (specified 
                    on cmd line)
    dwBitVector   - Which fields need to be modified
    bAddSet       - Is the interface being added or set.
    
Return Value:

    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    DWORD                   dwErr       = NO_ERROR, dwSize = 0, dwQosCount=1;
    DWORD                   i, dwIfType;
    PIPQOS_IF_CONFIG        pFinalCfg, piicDst     = NULL;

    DEBUG("In UpdateQosInterfaceConfig");

    do
    {
        if (bAddSet) {

            //
            // Create default protocol info block
            //

            dwErr = IpmontrGetInterfaceType(pwszIfGuid, &dwIfType);
            
            if (dwErr isnot NO_ERROR)
            {
                break;
            }


            dwErr = MakeQosInterfaceInfo(dwIfType,(PBYTE *)&pFinalCfg,&dwSize);

            if (dwErr isnot NO_ERROR)
            {
                break;
            }


        }
        else {
            
            //
            // get current interface config
            //

            dwErr = GetInfoBlockFromInterfaceInfoEx(pwszIfGuid,
                                                    MS_IP_QOSMGR,
                                                    (PBYTE *)&pFinalCfg,
                                                    &dwSize,
                                                    &dwQosCount,
                                                    &dwIfType);

            if (dwErr isnot NO_ERROR)
            {
                return dwErr;
            }
        }

        piicDst = HeapAlloc(GetProcessHeap(), 0, dwSize);

        if ( piicDst == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Update the state on interface (and other vars)
        //

        *piicDst = *pFinalCfg;

        if (dwBitVector & QOS_IF_STATE_MASK)
        {
            piicDst->QosState = pChangeCfg->QosState;
        }

        //
        // Set the info
        //
        
        dwErr = IpmontrSetInfoBlockInInterfaceInfo(pwszIfGuid,
                                                   MS_IP_QOSMGR,
                                                   (PBYTE) piicDst,
                                                   dwSize,
                                                   dwQosCount);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

    } while ( FALSE );

    HEAP_FREE_NOT_NULL(pFinalCfg);
    HEAP_FREE_NOT_NULL(piicDst);

    return dwErr;
}

DWORD
UpdateAllInterfaceConfigs(
    VOID
    )
{
    PMPR_INTERFACE_0    pmi0;
    PIPQOS_IF_CONFIG    piicBlk;
    DWORD               dwErr, dwCount, dwTotal, i;
    DWORD               dwBlkSize, dwBlkCount, dwIfType;

    //
    // Enumerate all interfaces applicable to QOS
    //

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0,
                                 &dwCount,
                                 &dwTotal);

    if(dwErr != NO_ERROR)
    {
        DisplayError(g_hModule, dwErr);

        return dwErr;
    }

    for (i = 0; i < dwCount; i++)
    {
        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pmi0[i].wszInterfaceName,
                                                     MS_IP_QOSMGR,
                                                     (PBYTE *) &piicBlk,
                                                     &dwBlkSize,
                                                     &dwBlkCount,
                                                     &dwIfType);

        if (dwErr == NO_ERROR)
        {
            //
            // Get and set back the interface info
            //

            dwErr =IpmontrSetInfoBlockInInterfaceInfo(pmi0[i].wszInterfaceName,
                                                      MS_IP_QOSMGR,
                                                      (PBYTE) piicBlk,
                                                      dwBlkSize,
                                                      dwBlkCount);
            HEAP_FREE(piicBlk);
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-netsh\strdefs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:


Abstract:

    

Author:

    Amritansh Raghav  01/25/1996

Revision History:

    V Raman            05/15/1996        Rearranged stringtable ids.
        
--*/

#ifndef __STRDEFS_H__
#define __STRDEFS_H__


// The string table entries that are identified here are arranged  
// in a hierachy as follows

    // Command line tokens
        // command class
        // commands
        // command objects
            // Router command objects
            // MIB comand objects
        // command option tags
            // interface options
            // filter options
            // Protocol Options
                // OSPF options
                // RIP options
                // Igmp options
            // Route options
        // Micellaneous options
        // Option values
            // Interface types
            // Router discovery types
            // Protocol types
            // Accept/Announce types
            // Misc. option values

    // command usage messages
        // show command usage 
        // add command usage 
        // delete command usage 
        // set command usage 

    // Output messages
        // Router messages
            // Interface messages
            // Filter messages
            // Route messages
            // Global info. messages
            // OSPF messages
        // MIB messages

    // Strings
        // Interface Types
        // TCP constants
        // TCP states
        // Protocol types
        // IP Route types
        // IP net types
        // Interface types
        // transmission types
        // Miscellaneous strings
        
    // Error Messages

#define MSG_NULL                                1000

#define MAX_ROUTER_OBJECTS                      \
    (TOKEN_RTR_OBJECT_IPIPTUNNEL - TOKEN_RTR_OBJECT_INTERFACE + 1)

#define MAX_MIB_OBJECTS                         \
    (TOKEN_MIB_OBJECT_MFESTATS - TOKEN_MIB_OBJECT_INTERFACE + 1)

#define DMP_IGMP_HEADER                         7017
#define DMP_IGMP_FOOTER                         7019
#define DMP_IGMP_INTERFACE_HEADER               7018

#define DMP_RDISC_HEADER                        7021

#define DMP_RIP_HEADER                          7033
#define DMP_RIP_INTERFACE_HEADER                7034
#define DMP_RIP_FOOTER                          7042

#define DMP_BOOTP_GLOBAL_HEADER                 7050
#define DMP_BOOTP_INTERFACE_HEADER              7055
#define DMP_BOOTP_FOOTER                        7059

#define DMP_OSPF_HEADER                         7063
#define DMP_OSPF_INTERFACE_HEADER               7064
#define DMP_OSPF_FOOTER                         7076

#define DMP_AUTODHCP_HEADER                     7080
#define DMP_AUTODHCP_FOOTER                     7081
#define DMP_AUTODHCP_INTERFACE_HEADER           7082

#define DMP_DNSPROXY_HEADER                     7085
#define DMP_DNSPROXY_FOOTER                     7086
#define DMP_DNSPROXY_INTERFACE_HEADER           7087

#define DMP_NAT_HEADER                          7090
#define DMP_NAT_FOOTER                          7091
#define DMP_NAT_INTERFACE_HEADER                7092

#define MSG_QOS_HEADER                          7101
#define MSG_QOS_FOOTER                          7102
#define MSG_QOS_GLOBAL_HEADER                   7103
#define MSG_QOS_GLOBAL_FOOTER                   7104
#define MSG_QOS_INTERFACE_HEADER                7105
#define MSG_QOS_INTERFACE_FOOTER                7106

#define MSG_FLOWSPEC_ALREADY_EXISTS             7201
#define MSG_FLOWSPEC_NOT_FOUND                  7202
#define MSG_FLOW_ALREADY_EXISTS                 7203
#define MSG_FLOW_NOT_FOUND                      7204
#define MSG_QOSOBJECT_ALREADY_EXISTS            7205
#define MSG_QOSOBJECT_NOT_FOUND                 7206
#define MSG_DSRULE_NOT_FOUND                    7207

// commmon hlp messages

#define HLP_HELP                                8400
#define HLP_HELP_EX                             8401
#define HLP_HELP1                               HLP_HELP
#define HLP_HELP1_EX                            HLP_HELP_EX
#define HLP_HELP2                               HLP_HELP
#define HLP_HELP2_EX                            HLP_HELP_EX
#define HLP_SHOW_HELPER                         8412
#define HLP_SHOW_HELPER_EX                      8413
#define HLP_INSTALL                             8414
#define HLP_INSTALL_EX                          8415
#define HLP_UNINSTALL                           8416
#define HLP_UNINSTALL_EX                        8417
#define HLP_DUMP                                8418
#define HLP_DUMP_EX                             8419
#define HLP_GROUP_ADD                           8420
#define HLP_GROUP_DELETE                        8421
#define HLP_GROUP_SET                           8422
#define HLP_GROUP_SHOW                          8423
#define HLP_ADD_HELPER                          8424
#define HLP_ADD_HELPER_EX                       8425
#define HLP_DEL_HELPER                          8426
#define HLP_DEL_HELPER_EX                       8427


// rip add hlp

#define HLP_RIP_ADD_PF                          9000
#define HLP_RIP_ADD_PF_EX                       9001
#define HLP_RIP_ADD_IF_ACCF                     9002
#define HLP_RIP_ADD_IF_ACCF_EX                  9003
#define HLP_RIP_ADD_IF_ANNF                     9004
#define HLP_RIP_ADD_IF_ANNF_EX                  9005
#define HLP_RIP_ADD_IF_NBR                      9006
#define HLP_RIP_ADD_IF_NBR_EX                   9007
#define HLP_RIP_ADD_IF                          9008
#define HLP_RIP_ADD_IF_EX                       9009

// rip delete hlp

#define HLP_RIP_DEL_PF                          9020
#define HLP_RIP_DEL_PF_EX                       9021
#define HLP_RIP_DEL_IF_ACCF                     9022
#define HLP_RIP_DEL_IF_ACCF_EX                  9023
#define HLP_RIP_DEL_IF_ANNF                     9024
#define HLP_RIP_DEL_IF_ANNF_EX                  9025
#define HLP_RIP_DEL_IF_NBR                      9026
#define HLP_RIP_DEL_IF_NBR_EX                   9027
#define HLP_RIP_DEL_IF                          9028
#define HLP_RIP_DEL_IF_EX                       9029

// rip set hlp

#define HLP_RIP_SET_IF                          9040
#define HLP_RIP_SET_IF_EX                       9041
#define HLP_RIP_SET_FLAGS                       9042
#define HLP_RIP_SET_FLAGS_EX                    9043
#define HLP_RIP_SET_GLOBAL                      9044
#define HLP_RIP_SET_GLOBAL_EX                   9045

// rip show hlp

#define HLP_RIP_SHOW_IF                         9050
#define HLP_RIP_SHOW_IF_EX                      9051
#define HLP_RIP_SHOW_FLAGS                      9052
#define HLP_RIP_SHOW_FLAGS_EX                   9053
#define HLP_RIP_SHOW_GLOBAL                     9054
#define HLP_RIP_SHOW_GLOBAL_EX                  9055

// ospf add hlp

#define HLP_OSPF_ADD_AREA_RANGE                 9100
#define HLP_OSPF_ADD_AREA_RANGE_EX              9101
#define HLP_OSPF_ADD_AREA                       9102
#define HLP_OSPF_ADD_AREA_EX                    9103
#define HLP_OSPF_ADD_VIRTIF                     9104
#define HLP_OSPF_ADD_VIRTIF_EX                  9105
#define HLP_OSPF_ADD_IF_NBR                     9106
#define HLP_OSPF_ADD_IF_NBR_EX                  9107
#define HLP_OSPF_ADD_IF                         9108
#define HLP_OSPF_ADD_IF_EX                      9109
#define HLP_OSPF_ADD_ROUTE_FILTER               9110
#define HLP_OSPF_ADD_ROUTE_FILTER_EX            9111
#define HLP_OSPF_ADD_PROTO_FILTER               9112
#define HLP_OSPF_ADD_PROTO_FILTER_EX            9113
#define HLP_OSPF_INSTALL                        9114
#define HLP_OSPF_INSTALL_EX                     9115

#define HLP_OSPF_DEL_AREA_RANGE                 9120
#define HLP_OSPF_DEL_AREA_RANGE_EX              9121
#define HLP_OSPF_DEL_AREA                       9122
#define HLP_OSPF_DEL_AREA_EX                    9123
#define HLP_OSPF_DEL_VIRTIF                     9124
#define HLP_OSPF_DEL_VIRTIF_EX                  9125
#define HLP_OSPF_DEL_IF_NBR                     9126
#define HLP_OSPF_DEL_IF_NBR_EX                  9127
#define HLP_OSPF_DEL_IF                         9128
#define HLP_OSPF_DEL_IF_EX                      9129
#define HLP_OSPF_DEL_ROUTE_FILTER               9130
#define HLP_OSPF_DEL_ROUTE_FILTER_EX            9131
#define HLP_OSPF_DEL_PROTO_FILTER               9132
#define HLP_OSPF_DEL_PROTO_FILTER_EX            9133
#define HLP_OSPF_UNINSTALL                      9134
#define HLP_OSPF_UNINSTALL_EX                   9135

#define HLP_OSPF_SET_AREA                       9140
#define HLP_OSPF_SET_AREA_EX                    9141
#define HLP_OSPF_SET_VIRTIF                     9142
#define HLP_OSPF_SET_VIRTIF_EX                  9143
#define HLP_OSPF_SET_IF                         9144
#define HLP_OSPF_SET_IF_EX                      9145
#define HLP_OSPF_SET_GLOBAL                     9146
#define HLP_OSPF_SET_GLOBAL_EX                  9147
#define HLP_OSPF_SET_ROUTE_FILTER               9148
#define HLP_OSPF_SET_ROUTE_FILTER_EX            9149
#define HLP_OSPF_SET_PROTO_FILTER               9150
#define HLP_OSPF_SET_PROTO_FILTER_EX            9151

#define HLP_OSPF_SHOW_GLOBAL                    9160
#define HLP_OSPF_SHOW_GLOBAL_EX                 9161
#define HLP_OSPF_SHOW_AREA                      9162
#define HLP_OSPF_SHOW_AREA_EX                   9163
#define HLP_OSPF_SHOW_VIRTIF                    9164
#define HLP_OSPF_SHOW_VIRTIF_EX                 9165
#define HLP_OSPF_SHOW_IF                        9166
#define HLP_OSPF_SHOW_IF_EX                     9167
#define HLP_OSPF_SHOW                           9168
#define HLP_OSPF_SHOW_EX                        9169
#define HLP_OSPF_SHOW_ROUTE_FILTER              9170
#define HLP_OSPF_SHOW_ROUTE_FILTER_EX           9171
#define HLP_OSPF_SHOW_PROTO_FILTER              9172
#define HLP_OSPF_SHOW_PROTO_FILTER_EX           9173

#define HLP_IGMP_ADD_IF_STATICGROUP             9300
#define HLP_IGMP_ADD_IF_STATICGROUP_EX          9301
#define HLP_IGMP_ADD_IF                         9302
#define HLP_IGMP_ADD_IF_EX                      9303
#define HLP_IGMP_INSTALL                        9304
#define HLP_IGMP_INSTALL_EX                     9305

#define HLP_IGMP_DEL_IF_STATICGROUP             9310
#define HLP_IGMP_DEL_IF_STATICGROUP_EX          9312
#define HLP_IGMP_DEL_IF                         9313
#define HLP_IGMP_DEL_IF_EX                      9314
#define HLP_IGMP_UNINSTALL                      9315
#define HLP_IGMP_UNINSTALL_EX                   9316
 
#define HLP_IGMP_SET_IF                         9320
#define HLP_IGMP_SET_IF_EX                      9321
#define HLP_IGMP_SET_GLOBAL                     9322 
#define HLP_IGMP_SET_GLOBAL_EX                  9323

#define HLP_IGMP_SHOW_IF                        9330
#define HLP_IGMP_SHOW_IF_EX                     9331
#define HLP_IGMP_SHOW_GLOBAL                    9332
#define HLP_IGMP_SHOW_GLOBAL_EX                 9333

// BOOTP help messages

#define HLP_BOOTP_ADD                           9401
#define HLP_BOOTP_ADD_EX                        9402
#define HLP_BOOTP_ADD_IF                        9403
#define HLP_BOOTP_ADD_IF_EX                     9404
#define HLP_BOOTP_ADD_DHCP_SERVER               9405
#define HLP_BOOTP_ADD_DHCP_SERVER_EX            9406

#define HLP_BOOTP_DEL                           9411
#define HLP_BOOTP_DEL_EX                        9412
#define HLP_BOOTP_DEL_IF                        9413
#define HLP_BOOTP_DEL_IF_EX                     9414
#define HLP_BOOTP_DEL_DHCP_SERVER               9415
#define HLP_BOOTP_DEL_DHCP_SERVER_EX            9416

#define HLP_BOOTP_SET_GLOBAL                    9421
#define HLP_BOOTP_SET_GLOBAL_EX                 9422
#define HLP_BOOTP_SET_IF                        9423
#define HLP_BOOTP_SET_IF_EX                     9424

#define HLP_BOOTP_SHOW_GLOBAL                   9431
#define HLP_BOOTP_SHOW_GLOBAL_EX                9432
#define HLP_BOOTP_SHOW_IF                       9433
#define HLP_BOOTP_SHOW_IF_EX                    9434

// DHCP allocator help messages
#define HLP_AUTODHCP_ADD_EXCLUSION              9441
#define HLP_AUTODHCP_ADD_EXCLUSION_EX           9442
#define HLP_AUTODHCP_DELETE_EXCLUSION           9443
#define HLP_AUTODHCP_DELETE_EXCLUSION_EX        9444
#define HLP_AUTODHCP_SET_GLOBAL                 9445
#define HLP_AUTODHCP_SET_GLOBAL_EX              9446
#define HLP_AUTODHCP_SET_INTERFACE              9447
#define HLP_AUTODHCP_SET_INTERFACE_EX           9448
#define HLP_AUTODHCP_SHOW_GLOBAL                9449
#define HLP_AUTODHCP_SHOW_GLOBAL_EX             9450
#define HLP_AUTODHCP_SHOW_INTERFACE             9451
#define HLP_AUTODHCP_SHOW_INTERFACE_EX          9452

// DNS proxy help messages
#define HLP_DNSPROXY_SET_GLOBAL                 9461
#define HLP_DNSPROXY_SET_GLOBAL_EX              9462
#define HLP_DNSPROXY_SET_INTERFACE              9463
#define HLP_DNSPROXY_SET_INTERFACE_EX           9464
#define HLP_DNSPROXY_SHOW_GLOBAL                9465
#define HLP_DNSPROXY_SHOW_GLOBAL_EX             9466
#define HLP_DNSPROXY_SHOW_INTERFACE             9467
#define HLP_DNSPROXY_SHOW_INTERFACE_EX          9468

// NAT help messages
#define HLP_NAT_ADD_ADDRESS_MAPPING             9471
#define HLP_NAT_ADD_ADDRESS_MAPPING_EX          9472
#define HLP_NAT_ADD_ADDRESS_RANGE               9473
#define HLP_NAT_ADD_ADDRESS_RANGE_EX            9474
#define HLP_NAT_ADD_PORT_MAPPING                9475
#define HLP_NAT_ADD_PORT_MAPPING_EX             9476
#define HLP_NAT_DELETE_ADDRESS_MAPPING          9477
#define HLP_NAT_DELETE_ADDRESS_MAPPING_EX       9478
#define HLP_NAT_DELETE_ADDRESS_RANGE            9479
#define HLP_NAT_DELETE_ADDRESS_RANGE_EX         9480
#define HLP_NAT_DELETE_PORT_MAPPING             9481
#define HLP_NAT_DELETE_PORT_MAPPING_EX          9482
#define HLP_NAT_SET_GLOBAL                      9483
#define HLP_NAT_SET_GLOBAL_EX                   9484
#define HLP_NAT_SET_INTERFACE                   9485
#define HLP_NAT_SET_INTERFACE_EX                9486
#define HLP_NAT_SHOW_GLOBAL                     9487
#define HLP_NAT_SHOW_GLOBAL_EX                  9488
#define HLP_NAT_ADD_INTERFACE                   9489
#define HLP_NAT_ADD_INTERFACE_EX                9490
#define HLP_NAT_DELETE_INTERFACE                9491
#define HLP_NAT_DELETE_INTERFACE_EX             9492
#define HLP_NAT_SHOW_INTERFACE                  9493
#define HLP_NAT_SHOW_INTERFACE_EX               9494
#define HLP_NAT_ADD_DIRECTPLAY                  9495
#define HLP_NAT_ADD_DIRECTPLAY_EX               9496
#define HLP_NAT_ADD_H323                        9497
#define HLP_NAT_ADD_H323_EX                     9498
#define HLP_NAT_DELETE_DIRECTPLAY               9499
#define HLP_NAT_DELETE_DIRECTPLAY_EX            9500
#define HLP_NAT_DELETE_H323                     9501
#define HLP_NAT_DELETE_H323_EX                  9502

// RDISC help messages
#define HLP_RDISC_ADD_INTERFACE                 9601
#define HLP_RDISC_ADD_INTERFACE_EX              9602
#define HLP_RDISC_DELETE_INTERFACE              9603
#define HLP_RDISC_DELETE_INTERFACE_EX           9604
#define HLP_RDISC_SET_INTERFACE                 9605
#define HLP_RDISC_SET_INTERFACE_EX              9606
#define HLP_RDISC_SHOW_INTERFACE                9607
#define HLP_RDISC_SHOW_INTERFACE_EX             9608
// QOS help messages

#define HLP_QOS_ADD_FILTER_TO_FLOW              9701
#define HLP_QOS_ADD_FILTER_TO_FLOW_EX           9702
#define HLP_QOS_ADD_QOSOBJECT_ON_FLOW           9703
#define HLP_QOS_ADD_QOSOBJECT_ON_FLOW_EX        9704
#define HLP_QOS_ADD_FLOWSPEC_ON_FLOW            9705
#define HLP_QOS_ADD_FLOWSPEC_ON_FLOW_EX         9706
#define HLP_QOS_ADD_FLOW_ON_IF                  9707
#define HLP_QOS_ADD_FLOW_ON_IF_EX               9708
#define HLP_QOS_ADD_IF                          9709
#define HLP_QOS_ADD_IF_EX                       9710
#define HLP_QOS_ADD_DSRULE                      9711
#define HLP_QOS_ADD_DSRULE_EX                   9712
#define HLP_QOS_ADD_SDMODE                      9713
#define HLP_QOS_ADD_SDMODE_EX                   9714
#define HLP_QOS_ADD_FLOWSPEC                    9715
#define HLP_QOS_ADD_FLOWSPEC_EX                 9716


#define HLP_QOS_DEL_FILTER_FROM_FLOW            9721
#define HLP_QOS_DEL_FILTER_FROM_FLOW_EX         9722
#define HLP_QOS_DEL_QOSOBJECT_ON_FLOW           9723
#define HLP_QOS_DEL_QOSOBJECT_ON_FLOW_EX        9724
#define HLP_QOS_DEL_FLOWSPEC_ON_FLOW            9725
#define HLP_QOS_DEL_FLOWSPEC_ON_FLOW_EX         9726
#define HLP_QOS_DEL_FLOW_ON_IF                  9727
#define HLP_QOS_DEL_FLOW_ON_IF_EX               9728
#define HLP_QOS_DEL_IF                          9729
#define HLP_QOS_DEL_IF_EX                       9730
#define HLP_QOS_DEL_DSRULE                      9731
#define HLP_QOS_DEL_DSRULE_EX                   9732
#define HLP_QOS_DEL_SDMODE                      9733
#define HLP_QOS_DEL_SDMODE_EX                   9734
#define HLP_QOS_DEL_QOSOBJECT                   9735
#define HLP_QOS_DEL_QOSOBJECT_EX                9736
#define HLP_QOS_DEL_FLOWSPEC                    9737
#define HLP_QOS_DEL_FLOWSPEC_EX                 9738

#define HLP_QOS_SET_FILTER_ON_FLOW              9741
#define HLP_QOS_SET_FILTER_ON_FLOW_EX           9742
#define HLP_QOS_SET_FLOW_ON_IF                  9743
#define HLP_QOS_SET_FLOW_ON_IF_EX               9744
#define HLP_QOS_SET_IF                          9745
#define HLP_QOS_SET_IF_EX                       9746
#define HLP_QOS_SET_GLOBAL                      9747
#define HLP_QOS_SET_GLOBAL_EX                   9748

#define HLP_QOS_SHOW_FILTER_ON_FLOW             9761
#define HLP_QOS_SHOW_FILTER_ON_FLOW_EX          9762
#define HLP_QOS_SHOW_FLOW_ON_IF                 9763
#define HLP_QOS_SHOW_FLOW_ON_IF_EX              9764
#define HLP_QOS_SHOW_IF                         9765
#define HLP_QOS_SHOW_IF_EX                      9766
#define HLP_QOS_SHOW_DSMAP                      9767
#define HLP_QOS_SHOW_DSMAP_EX                   9768
#define HLP_QOS_SHOW_SDMODE                     9769
#define HLP_QOS_SHOW_SDMODE_EX                  9770
#define HLP_QOS_SHOW_QOSOBJECT                  9771
#define HLP_QOS_SHOW_QOSOBJECT_EX               9772
#define HLP_QOS_SHOW_FLOWSPEC                   9773
#define HLP_QOS_SHOW_FLOWSPEC_EX                9774
#define HLP_QOS_SHOW_GLOBAL                     9775
#define HLP_QOS_SHOW_GLOBAL_EX                  9776


// Output messages

        // OSPF messages
#define MSG_OSPF_GLOBAL_INFO                    20401
#define MSG_OSPF_AREA_INFO                      20402
#define MSG_OSPF_INTERFACE_INFO                 20403
#define MSG_OSPF_IF_NBR_HEADER                  20404
#define MSG_OSPF_NEIGHBOR_INFO                  20405
#define MSG_OSPF_VIRTUAL_INTERFACE_INFO         20406
#define MSG_OSPF_AREA_RANGE_HEADER              20407
#define MSG_OSPF_AREA_RANGE_INFO                20408
#define MSG_OSPF_PROTOCOL_FILTER_ACTION         20410
#define MSG_OSPF_PROTOCOL_FILTER                20411
#define MSG_OSPF_NO_PROTOCOL_FILTER             20412
#define MSG_OSPF_ROUTE_FILTER_ACTION            20413
#define MSG_OSPF_ROUTE_FILTER                   20414
#define MSG_OSPF_NO_ROUTE_FILTER                20415
#define MSG_OSPF_PROTOCOL_FILTER_HEADER         20416
#define MSG_OSPF_ROUTE_FILTER_HEADER            20417


        // RIP messages
#define MSG_RIP_GLOBAL_INFO                     20501
#define MSG_RIP_PEER_HEADER                     20502
#define MSG_RIP_PEER_ADDR                       20503

#define MSG_RIP_IF_INFO                         20551
#define MSG_RIP_FLAGS                           20552
#define MSG_RIP_IF_UNICAST_HEADER               20553
#define MSG_RIP_IF_UNICAST_PEER                 20554
#define MSG_RIP_IF_ACCEPT_FILTER_HEADER         20555
#define MSG_RIP_IF_ANNOUNCE_FILTER_HEADER       20556
#define MSG_RIP_IF_FILTER                       20557

        // BOOTP messages
#define MSG_BOOTP_GLOBAL_INFO                   20601
#define MSG_BOOTP_SERVER_HEADER                 20602
#define MSG_BOOTP_SERVER_ADDR                   20603
#define MSG_BOOTP_IF_INFO                       20604

        // IGMP messages
#define MSG_IGMP_GLOBAL_INFO                    20701
#define MSG_IGMP_IF_INFO_V1                     20702
#define MSG_IGMP_IF_INFO_V2                     20703
#define MSG_IGMP_STATIC_GROUP_HEADER            20704
#define MSG_IGMP_STATIC_GROUP_ENTRY             20705
#define MSG_IGMP_PROXY_IF_INFO                  20706

        // Connection sharing messages
#define MSG_AUTODHCP_GLOBAL_INFO                20801
#define MSG_AUTODHCP_INTERFACE_INFO             20802
#define MSG_AUTODHCP_EXCLUSION_HEADER           20803
#define MSG_AUTODHCP_EXCLUSION                  20804
#define MSG_DNSPROXY_GLOBAL_INFO                20811
#define MSG_DNSPROXY_INTERFACE_INFO             20812
#define MSG_NAT_GLOBAL_INFO                     20821
#define MSG_NAT_INTERFACE_INFO                  20822
#define MSG_NAT_ADDRESS_MAPPING_HEADER          20823
#define MSG_NAT_ADDRESS_MAPPING                 20824
#define MSG_NAT_ADDRESS_RANGE_HEADER            20825
#define MSG_NAT_ADDRESS_RANGE                   20826
#define MSG_NAT_PORT_MAPPING_HEADER             20827
#define MSG_NAT_PORT_MAPPING                    20828

    // RDISC messages
#define MSG_RDISC_IF_INFO                       20901
#define MSG_RDISC_IF_ENTRY                      20902
#define MSG_RDISC_IF_HEADER                     20903

    // MIB messages
#define MSG_MIB_IGMP_ROUTER_INTERFACE           21041
#define MSG_MIB_IGMP_RAS_CLIENT_GROUP_TABLE     21042
#define MSG_MIB_IGMP_PROXY_INTERFACE            21043
#define MSG_MIB_IGMP_ROUTER_GROUP_TABLE         21044
#define MSG_MIB_IGMP_PROXY_GROUP_TABLE          21045
#define MSG_MIB_IGMP_ROUTER_GROUP_INFO          21046
#define MSG_MIB_IGMP_PROXY_GROUP_INFO           21047
#define MSG_MIB_IGMP_ROUTER_NO_ENTRIES          21048
#define MSG_MIB_IGMP_PROXY_NO_ENTRIES           21049
#define MSG_MIB_IGMP_GROUP_IF_TABLE             21050
#define MSG_MIB_GROUP_IF_INFO                   21051
#define MSG_MIB_IGMP_GROUP_NO_ENTRIES           21053
#define MSG_MIB_IGMP_GROUP_NO_ENTRY             21054

        // QOS messages
#define MSG_QOS_GLOBAL_INFO                     21101
#define MSG_QOS_FLOWSPEC_INFO                   21111
#define MSG_QOS_SDMODE_INFO                     21121
#define MSG_QOS_DSMAP_INFO                      21131
#define MSG_QOS_DSRULE_INFO                     21132
#define MSG_QOS_IF_INFO                         21141
#define MSG_QOS_FLOW_INFO                       21151
#define MSG_QOS_QOSOBJECT_INFO                  21161

     // !@#
#define MSG_IP_ADDR_NOT_FOUND                   21502
#define MSG_IP_BAD_IP_ADDR                      21503
#define MSG_IF_NBR_NOT_FOUND                    21506
#define EMSG_NO_INTERFACE                       21512
#define MSG_NO_HELPER                           21516
#define MSG_NO_HELPERS                          21517
#define EMSG_INTERFACE_EXISTS                   21525
#define EMSG_PROTO_NOT_INSTALLED                21526
#define EMSG_PROTO_INSTALLED                    21527
#define MSG_IP_BAD_IP_MASK                      21528
#define MSG_IP_ADDR_PRESENT                     21529
#define MSG_CTRL_C_TO_QUIT                      21530

#define MSG_BOOTP_MIB_OPT                       21552


    // RIP MIB
#define MSG_RIP_MIB_GS                          22000
#define MSG_RIP_MIB_PS                          22001
#define MSG_RIP_MIB_PS_HDR                      22002
#define MSG_RIP_MIB_IFSTATS                     22003
#define MSG_RIP_MIB_IFSTATS_HDR                 22004
#define MSG_RIP_MIB_IFBIND_HDR                  22005
#define MSG_RIP_MIB_IFBIND                      22006
#define MSG_RIP_MIB_IFBIND_ADDR                 22007
#define MSG_RIP_MIB_LINE                        22008


    // DHCP relay agent messages
    
#define MSG_BOOTP_MIB_GC                        22051
#define MSG_BOOTP_MIB_DHCP_SERVER_HEADER        22052
#define MSG_BOOTP_MIB_DHCP_SERVER               22053
#define MSG_BOOTP_MIB_IF_CONFIG                 22054
#define MSG_BOOTP_MIB_IF_BINDING                22055
#define MSG_BOOTP_MIB_IF_ADDRESS_HEADER         22056
#define MSG_BOOTP_MIB_IF_ADDRESS                22057
#define MSG_BOOTP_MIB_IF_STATS                  22058


     // OSPF MIB

#define MSG_OSPF_MIB_AREA                       22100
#define MSG_OSPF_MIB_AREA_HDR                   22101
#define MSG_OSPF_MIB_LSDB                       22102
#define MSG_OSPF_MIB_LSDB_HDR                   22103
#define MSG_OSPF_MIB_VIRTIF                     22104
#define MSG_OSPF_MIB_VIRTIF_HDR                 22105
#define MSG_OSPF_MIB_NBR                        22106
#define MSG_OSPF_MIB_NBR_HDR                    22107

#define EMSG_PROTO_NO_GLOBAL_INFO               25010           
#define EMSG_PROTO_NO_IF_INFO                   25011
#define EMSG_RSVD_KEYWORD                       25013
#define EMSG_BAD_IF_TYPE                        25014


// Strings

    // Protocol types
#define STRING_PROTO_OTHER                      33001
#define STRING_PROTO_RIP                        33008
#define STRING_PROTO_OSPF                       33013
#define STRING_PROTO_BOOTP                      33015
#define STRING_PROTO_IGMP                       33017
#define STRING_PROTO_NAT                        33025
#define STRING_PROTO_DNS_PROXY                  33026
#define STRING_PROTO_DHCP_ALLOCATOR             33027
#define STRING_PROTO_QOS_MANAGER                33028

    // transmission types
#define STRING_BROADCAST                        37001
#define STRING_NBMA                             37002
#define STRING_PT2PT                            37003

    // Miscellaneous strings
#define STRING_CREATED                          38001
#define STRING_DELETED                          38002
#define STRING_ENABLED                          38003
#define STRING_DISABLED                         38004

#define STRING_YES                              38013
#define STRING_NO                               38014
#define STRING_Y                                38015
#define STRING_N                                38016

#define STRING_NONE                             38021
#define STRING_PASSWD                           38022

#define STRING_LOGGING_NONE                     38051
#define STRING_LOGGING_ERROR                    38052
#define STRING_LOGGING_WARN                     38053
#define STRING_LOGGING_INFO                     38054

#define STRING_FILTER_INCLUDE                   38061
#define STRING_FILTER_EXCLUDE                   38062

#define STRING_BOUND                            38071
#define STRING_BOUND_ENABLED                    38072
#define STRING_UNBOUND                          38073

#define STRING_UP                               38074
#define STRING_DOWN                             38075


//rip
#define STRING_RIP1                             38081
#define STRING_RIP1COMPAT                       38082
#define STRING_RIP2                             38083

#define STRING_PEER_ALSO                        38091
#define STRING_PEER_ONLY                        38092

#define STRING_PERIODIC                         38101
#define STRING_DEMAND                           38102

#define STRING_RIP_IF_ENABLED                   38103
#define STRING_RIP_IF_BOUND                     38104

//qos
#define STRING_QOS_IF_ENABLED                   38081
#define STRING_QOS_IF_BOUND                     38082

#define STRING_SERVICE_BESTEFFORT               38086
#define STRING_SERVICE_CONTROLLEDLOAD           38087
#define STRING_SERVICE_GUARANTEED               38088
#define STRING_SERVICE_QUALITATIVE              38089

#define STRING_SDMODE_BORROW                    38095
#define STRING_SDMODE_SHAPE                     38096
#define STRING_SDMODE_DISCARD                   38097
#define STRING_SDMODE_BORROW_PLUS               38098


//igmp
#define STRING_IGMP_ROUTER_V1                   38111
#define STRING_IGMP_ROUTER_V2                   38112
#define STRING_IGMP_PROXY                       38113

#define STRING_IGMP_IFTYPE_PERMANENT            38114
#define STRING_IGMP_IFTYPE_RAS_ROUTER           38115
#define STRING_IGMP_IFTYPE_RAS_SERVER           38116
#define STRING_IGMP_IFTYPE_RAS_CLIENT           38117
#define STRING_IGMP_IFTYPE_PERMANENT_PROXY      38118
#define STRING_IGMP_IFTYPE_DEMANDDIAL_PROXY     38119
#define STRING_IGMP_IFTYPE_UNKNOWN              38120
    
#define STRING_IGMP_NOT_BOUND                   38132
#define STRING_IGMP_ENABLED_BY_RTRMGR           38133
#define STRING_IGMP_ENABLED_IN_CONFIG           38134
#define STRING_IGMP_ENABLED_BY_MGM              38135
#define STRING_IGMP_FORWARD_JOINS_TO_MGM        38136
#define STRING_IGMP_QUERIER                     38137
#define STRING_IGMP_NON_QUERIER                 38138
#define STRING_IGMP_FLAG_L                      38139
#define STRING_IGMP_FLAG_S                      38140
#define STRING_IGMP_SPACE                       38141
#define STRING_IGMP_INFINITY                    38142
#define STRING_IGMP_Y                           38143
#define STRING_IGMP_DASH                        38144



#define STRING_FULL_XLATE                       38201
#define STRING_ADDRESS_XLATE                    38202
#define STRING_PRIVATE_XLATE                    38203
#define STRING_DEFAULT_INTERFACE                38206
#define STRING_TCP                              38207
#define STRING_UDP                              38208


//ospf

#define STRING_STUB                             38301
#define STRING_ROUTER                           38302
#define STRING_NETWORK                          38303
#define STRING_SUMMARY                          38304
#define STRING_ASSUMMARY                        38305
#define STRING_ASEXTERN                         38306

#define STRING_ATTEMPT                          38321
#define STRING_INIT                             38322
#define STRING_TWOWAY                           38323
#define STRING_EXCHSTART                        38324
#define STRING_EXCHANGE                         38325
#define STRING_LOADING                          38326
#define STRING_FULL                             38327

#define STRING_LOOPBACK                         38331
#define STRING_WAITING                          38332
#define STRING_DR                               38333
#define STRING_BDR                              38334


#define STRING_UNKNOWN                          50001




// Error messages
#define MSG_IP_DIM_ERROR                        60006
#define MSG_IP_NO_ENTRIES                       60015
#define EMSG_CORRUPT_INFO                       60016
#define MSG_IP_NO_GLOBAL_INFO                   60017
#define EMSG_NOT_ENOUGH_MEMORY                  60024
#define EMSG_BAD_OPTION_VALUE                   60025
#define EMSG_BAD_OPTION_ENUMERATION             60028
#define EMSG_VALID_OPTION_VALUE                 60029

#define MSG_IP_AREA_NOT_FOUND                   60103
#define MSG_IP_INTERFACE_NOT_FOUND              60112

// OSPF error messages
#define MSG_IP_AREA_NO_BACKBONE                 60201
#define MSG_IP_VI_NO_BACKBONE                   60202
#define MSG_IP_BAD_TRANSIT_AREA                 60203
#define MSG_IP_STUB_TRANSIT_AREA                60204
#define MSG_IP_TRANSIT_AREA_NOT_FOUND           60205
#define MSG_IP_BAD_RANGE                        60206
#define MSG_IP_NO_AREA                          60208
#define MSG_IP_BAD_ADDR_MASK                    60209

#define MSG_IP_OSPF_INTERFACE_NOT_FOUND         60220
#define MSG_IP_OSPF_MULTIPLE_INTERFACE_PARAM    60221
#define MSG_IP_OSPF_DEFAULT_PRESENT             60222
#define MSG_IP_OSPF_DEFAULT_NOT_ALLOWED         60223
#define MSG_IP_OSPF_ADDRESS_NOT_FOUND           60224

// RIP error messages
#define MSG_IP_RIP_FILTER_PRESENT               60211
#define MSG_IP_RIP_FILTER_NOT_PRESENT           60212
#define MSG_IP_RIP_INVALID_FILTER               60213

// NAT messages
#define MSG_IP_NAT_NO_ADDRESS_POOL              60251
#define MSG_IP_NAT_NO_ADDRESS_RANGE             60252
#define MSG_IP_NAT_ADDRESS_MAPPING_NEEDS_RANGE  60253
#define MSG_IP_NAT_PORT_MAPPING_NEEDS_RANGE     60254
#define MSG_IP_NAT_BAD_RANGE_END                60255
#define MSG_IP_AUTODHCP_BAD_EXCLUSION           60256
#define MSG_IP_NAT_ADDRESS_MAPPING_INVALID      60257
#define MSG_IP_NAT_PORT_MAPPING_INVALID         60258

// igmp
#define EMSG_STATIC_MGM_GROUP_FOR_PROXY         60301
#define EMSG_STATIC_GROUP_EXISTS                60302
#define EMSG_STATIC_GROUP_NOT_FOUND             60303
#define EMSG_IGMP_MULTIPLE_STATIC_GROUPS        60304
#define EMSG_IGMP_PROXY_EXISTS                  60305

//
// Error messages for mib calls
//

#define HLP_RIP_MIB_SHOW_STATS                63001
#define HLP_RIP_MIB_SHOW_STATS_EX             63002
#define HLP_RIP_MIB_SHOW_IFSTATS              63003
#define HLP_RIP_MIB_SHOW_IFSTATS_EX           63004
#define HLP_RIP_MIB_SHOW_IFBINDING            63005
#define HLP_RIP_MIB_SHOW_IFBINDING_EX         63006
#define HLP_RIP_MIB_SHOW_PEERSTATS            63007
#define HLP_RIP_MIB_SHOW_PEERSTATS_EX         63008

#define HLP_IGMP_MIB_SHOW_IF_STATS             63101
#define HLP_IGMP_MIB_SHOW_IF_STATS_EX          63102
#define HLP_IGMP_MIB_SHOW_IF_TABLE             63103
#define HLP_IGMP_MIB_SHOW_IF_TABLE_EX          63104
#define HLP_IGMP_MIB_SHOW_GROUP_TABLE         63105
#define HLP_IGMP_MIB_SHOW_GROUP_TABLE_EX      63106
#define HLP_IGMP_MIB_SHOW_RAS_GROUP_TABLE     63107
#define HLP_IGMP_MIB_SHOW_RAS_GROUP_TABLE_EX  63108
#define HLP_IGMP_MIB_SHOW_PROXY_GROUP_TABLE   63109
#define HLP_IGMP_MIB_SHOW_PROXY_GROUP_TABLE_EX 63110

#define HLP_OSPF_MIB_SHOW_AREA                63201
#define HLP_OSPF_MIB_SHOW_AREA_EX             63202
#define HLP_OSPF_MIB_SHOW_LSDB                63203
#define HLP_OSPF_MIB_SHOW_LSDB_EX             63204
#define HLP_OSPF_MIB_SHOW_NEIGHBOR            63205
#define HLP_OSPF_MIB_SHOW_NEIGHBOR_EX         63206
#define HLP_OSPF_MIB_SHOW_VIRTUALIF           63207
#define HLP_OSPF_MIB_SHOW_VIRTUALIF_EX        63208

#define HLP_BOOTP_MIB_SHOW_GLOBAL_CONFIG      63301
#define HLP_BOOTP_MIB_SHOW_GLOBAL_CONFIG_EX   63302
#define HLP_BOOTP_MIB_SHOW_IF_CONFIG          63303
#define HLP_BOOTP_MIB_SHOW_IF_CONFIG_EX       63304
#define HLP_BOOTP_MIB_SHOW_IF_BINDING         63305
#define HLP_BOOTP_MIB_SHOW_IF_BINDING_EX      63306
#define HLP_BOOTP_MIB_SHOW_IF_STATS           63307
#define HLP_BOOTP_MIB_SHOW_IF_STATS_EX        63308

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-netsh\qosopt.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    qosopt.c

Abstract:

    Fns to parse QOS commands

Revision History:

--*/

#include "precomp.h"

#pragma hdrstop


//
// Install, Uninstall Handlers
//

DWORD
HandleQosInstall(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Gets options for adding QOS global info

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR or Error Code
    
--*/

{
    PBYTE    pbInfoBlk;
    DWORD    dwSize, dwErr;
    
    //
    // No options expected for add command.
    //

    if (dwCurrentIndex != dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_INVALID_SYNTAX;
    }

    pbInfoBlk = NULL;

    do
    {
        dwErr = MakeQosGlobalInfo( &pbInfoBlk, &dwSize);

        if (dwErr != NO_ERROR)
        {
            break;
        }

        //
        // Add Qos to global block
        //
    
        dwErr = IpmontrSetInfoBlockInGlobalInfo(MS_IP_QOSMGR,
                                                pbInfoBlk,
                                                dwSize,
                                                1);

        if (dwErr == NO_ERROR)
        {
            UpdateAllInterfaceConfigs();
        }
    } 
    while (FALSE);

    HEAP_FREE_NOT_NULL(pbInfoBlk);
   
    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}

DWORD
HandleQosUninstall(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Gets options for deleting QOS global info

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR or Error Code
    
--*/

{
    DWORD dwErr;

    //
    // No options expected for add command.
    //

    if (dwCurrentIndex != dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_INVALID_SYNTAX;
    }

    dwErr = IpmontrDeleteProtocol(MS_IP_QOSMGR);

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}



//
// Add, Del, Show Child Helpers
//


//
// Set and Show Global Handlers
//

DWORD
HandleQosSetGlobal(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for setting QOS global info

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR or Error Code
    
--*/
{
    DWORD                  dwBitVector;
    DWORD                  dwErr, dwRes;
    DWORD                  dwNumArg, i, j;
    IPQOS_GLOBAL_CONFIG    igcGlobalCfg;
    TAG_TYPE               pttTags[] = {{TOKEN_OPT_LOG_LEVEL,FALSE,FALSE}};
    DWORD                  pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    dwBitVector = 0;

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                //
                // Tag LOGLEVEL
                //
                
                TOKEN_VALUE    rgEnums[] = 
                    {{TOKEN_OPT_VALUE_NONE, IPQOS_LOGGING_NONE},
                     {TOKEN_OPT_VALUE_ERROR, IPQOS_LOGGING_ERROR},
                     {TOKEN_OPT_VALUE_WARN, IPQOS_LOGGING_WARN},
                     {TOKEN_OPT_VALUE_INFO, IPQOS_LOGGING_INFO}};

                GET_ENUM_TAG_VALUE();
                
                igcGlobalCfg.LoggingLevel = dwRes;

                dwBitVector |= QOS_LOG_MASK;

                break;
            }
            
            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }
    }

    if (dwErr == NO_ERROR)
    {
        if (dwBitVector)
        {
            dwErr = UpdateQosGlobalConfig(&igcGlobalCfg,
                                          dwBitVector);
        }
    }

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}



DWORD
HandleQosShowGlobal(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for showing QOS global info

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // Does not expect any arguments. If any are specified, report error.
    //

    if (dwCurrentIndex != dwArgCount)
    {
        return ERROR_INVALID_SYNTAX;
    }

    return ShowQosGlobalInfo(NULL);
}



//
// Add, Del, Set, Show If Handlers
//

DWORD
HandleQosAddIf(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for add interface 

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    dwErr
    
--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD       dwErr, dwIfType, dwBlkSize, dwBitVector = 0, dwCount;
    IPQOS_IF_CONFIG ChangeCfg;

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // get optional parameters that are also being set
    //

    ZeroMemory(&ChangeCfg, sizeof(IPQOS_IF_CONFIG));

    dwErr = GetQosSetIfOpt(pptcArguments,
                            dwCurrentIndex,
                            dwArgCount,
                            wszInterfaceName,
                            sizeof(wszInterfaceName),
                            &ChangeCfg,
                            &dwBitVector,
                            ADD_FLAG
                            );

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    do
    {
        //
        // make sure that the interface does not already exist in the config
        //
        {
            PIPQOS_IF_CONFIG pTmpCfg;

            dwErr = IpmontrGetInfoBlockFromInterfaceInfo(wszInterfaceName,
                                                         MS_IP_QOSMGR,
                                                         (PBYTE *) &pTmpCfg,
                                                         &dwBlkSize,
                                                         &dwCount,
                                                         &dwIfType);

            if (dwErr is NO_ERROR && pTmpCfg != NULL) 
            {
                HEAP_FREE(pTmpCfg);
                
                DisplayMessage(g_hModule, EMSG_INTERFACE_EXISTS,
                               wszInterfaceName);

                return ERROR_SUPPRESS_OUTPUT;
            }
        }


        //
        // check if Qos global info is set. else add Qos global info
        //
        {
            PIPQOS_GLOBAL_CONFIG pGlobalConfig = NULL;
            DWORD                dwBlkSize, dwCount;

            dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                                      (PBYTE *) &pGlobalConfig,
                                                      &dwBlkSize,
                                                      &dwCount);

            HEAP_FREE_NOT_NULL(pGlobalConfig);
            
            if ((dwErr is ERROR_NOT_FOUND) || (dwBlkSize == 0))
            {
                // create qos global info
                
                dwErr = HandleQosInstall(pwszMachine,
                                         NULL, 
                                         0, 
                                         0, 
                                         dwFlags,
                                         hMibServer,
                                         pbDone);
            }
            
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }

        
        //
        // set the interface info
        //

        dwErr = UpdateQosInterfaceConfig(wszInterfaceName,
                                         &ChangeCfg,
                                         dwBitVector,
                                         ADD_FLAG);
    }
    while (FALSE);
    
    // no error message

    return (dwErr == NO_ERROR) ? ERROR_OKAY: dwErr;
}

DWORD
HandleQosDelIf(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for del interface 

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    NO_ERROR
    
--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD       dwErr, dwIfType, dwBlkSize, dwBitVector = 0, dwCount;
    IPQOS_IF_CONFIG ChangeCfg; //will not be used

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // get interface name.
    //

    ZeroMemory( &ChangeCfg, sizeof(IPQOS_IF_CONFIG) );

    dwErr = GetQosSetIfOpt(pptcArguments,
                            dwCurrentIndex,
                            dwArgCount,
                            wszInterfaceName,
                            sizeof(wszInterfaceName),
                            &ChangeCfg,
                            &dwBitVector,
                            ADD_FLAG
                            );

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    //
    // make sure that no other option is set.
    //
    if (dwBitVector) 
    {
        return ERROR_INVALID_SYNTAX;
    }
    
    //
    // delete interface info
    //

    dwErr = IpmontrDeleteInfoBlockFromInterfaceInfo(wszInterfaceName,
                                                    MS_IP_QOSMGR);

    return (dwErr == NO_ERROR) ? ERROR_OKAY: dwErr;
}

DWORD
HandleQosSetIf(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for set interface 

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    NO_ERROR
    
--*/

{
    IPQOS_IF_CONFIG     ChangeCfg; //no variable parts can be set
    DWORD               dwBitVector = 0,
                        dwErr = NO_ERROR;
    WCHAR               wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // get the optional interface parameters
    //
    
    ZeroMemory( &ChangeCfg, sizeof(IPQOS_IF_CONFIG) );

    dwErr = GetQosSetIfOpt(pptcArguments,
                           dwCurrentIndex,
                           dwArgCount,
                           wszIfName,
                           sizeof(wszIfName),
                           &ChangeCfg,
                           &dwBitVector,
                           SET_FLAG
                           );

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }
    
    if (dwBitVector)
    {
        // 
        // Call UpdateInterfaceCfg
        //

        dwErr = UpdateQosInterfaceConfig(wszIfName,
                                         &ChangeCfg,
                                         dwBitVector,
                                         SET_FLAG);
    }

    return (dwErr == NO_ERROR) ? ERROR_OKAY: dwErr;
}


DWORD
HandleQosShowIf(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for showing QOS interface info

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    DWORD         i, j, dwErr = NO_ERROR, dwNumOpt;
    WCHAR         wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD         dwNumArg,
                  dwBufferSize = sizeof(wszInterfaceName);
    DWORD         dwSize, dwRes;

    TAG_TYPE      pttTags[] = {{TOKEN_OPT_NAME,FALSE,FALSE}};
    DWORD         pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    if (dwCurrentIndex == dwArgCount) {

        dwErr = ShowQosAllInterfaceInfo( NULL ) ;

        return dwErr;
    }

    //
    // Parse command line
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, NUM_TAGS_IN_TABLE(pttTags),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
        case 0 :
            IpmontrGetIfNameFromFriendlyName(pptcArguments[i + dwCurrentIndex],
                                             wszInterfaceName,&dwBufferSize);

            break;

        default:
            i = dwNumArg;
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr == NO_ERROR)
    {
        dwErr = ShowQosInterfaceInfo(NULL, wszInterfaceName);
    }

    return dwErr;
}


//
// Dump Handlers
//


DWORD
DumpQosInformation (
    HANDLE hFile
    )

/*++

Routine Description:

    Dumps Qos information to a text file

Arguments:


Return Value:

    NO_ERROR

--*/

{

    //DisplayMessageT( DMP_QOS_HEADER );
    DisplayMessage(g_hModule, MSG_QOS_HEADER);
    DisplayMessageT( DMP_QOS_PUSHD );
    DisplayMessageT( DMP_QOS_UNINSTALL );

    //DisplayMessageT(DMP_QOS_GLOBAL_HEADER) ;

    //
    // dump qos global information
    //
    
    ShowQosGlobalInfo( hFile ) ;

    //
    // dump flowspecs at the end
    // of the global information
    //

    ShowQosFlowspecs(hFile, NULL);

    //
    // dump qos objects that occur
    // at the end of flowspec info
    //

    ShowQosObjects(hFile, 
                   NULL, 
                   QOS_OBJECT_END_OF_LIST);

    //DisplayMessageT(DMP_QOS_GLOBAL_FOOTER);

    //
    // dump qos config for all interfaces
    //

    ShowQosAllInterfaceInfo( hFile );

    DisplayMessageT( DMP_POPD );
    //DisplayMessageT( DMP_QOS_FOOTER );
    DisplayMessage( g_hModule, MSG_QOS_FOOTER );

    return NO_ERROR ;
}

DWORD
QosDump(
    PWCHAR    pwszMachine,
    WCHAR     **ppwcArguments,
    DWORD     dwArgCount,
    PVOID     pvData
    )
{
    return DumpQosInformation((HANDLE) -1);
}

//
// Help Handlers
//


//
// Flowspec Add, Del, Set Handlers
//


DWORD
HandleQosAddFlowspec(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for adding flowspecs to the
    global info.

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    NO_ERROR
    
--*/
{
    return GetQosAddDelFlowspecOpt(pptcArguments,
                                   dwCurrentIndex,
                                   dwArgCount,
                                   TRUE);
}

DWORD
HandleQosDelFlowspec(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for deleting flowspecs from the
    global info.

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    NO_ERROR
    
--*/
{
    return GetQosAddDelFlowspecOpt(pptcArguments,
                                   dwCurrentIndex,
                                   dwArgCount,
                                   FALSE);
}

DWORD
HandleQosShowFlowspec(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for showing flowspecs in the
    global info.

Arguments:

    None

Return Value:

    None

--*/

{
    TAG_TYPE           pttTags[] = {{TOKEN_OPT_NAME,FALSE,FALSE}};
    PTCHAR             pszFlowspec;
    DWORD              dwNumOpt, dwRes;
    DWORD              dwNumArg, i, j;
    DWORD              dwTagType, dwErr;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);
    
    if (dwCurrentIndex == dwArgCount)
    {
        //
        // No arguments - show all flowspecs
        //

        pszFlowspec = NULL;
    }
    else {

        //
        // Get name of the flowspec to show
        //

        dwErr = PreprocessCommand(
                    g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                    pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                    1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                    );

        if ( dwErr != NO_ERROR )
        {
            return dwErr;
        }

        dwNumArg = dwArgCount - dwCurrentIndex;

        if (dwNumArg != 1)
        {
            return ERROR_INVALID_SYNTAX;
        }

        pszFlowspec = pptcArguments[dwCurrentIndex];
    }

    return ShowQosFlowspecs(NULL, pszFlowspec);
}


//
// DsRule Add, Del, Show Handlers
//

DWORD
HandleQosAddDsRule(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for adding diffserv rules to the
    diffserv maps in global info. If the diffserv
    map in not already present, a new one will be
    created when adding the first rule.

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    return GetQosAddDelDsRuleOpt(pptcArguments,
                                 dwCurrentIndex,
                                 dwArgCount,
                                 TRUE);
}

DWORD
HandleQosDelDsRule(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for deleting diffserv ruless from
    an existing diffserv map in the global info. If
    this is the last diffserv rule in the diffserv
    map, the diffserv map is removed from the global
    info.

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    NO_ERROR
    
--*/
{
    return GetQosAddDelDsRuleOpt(pptcArguments,
                                 dwCurrentIndex,
                                 dwArgCount,
                                 FALSE);
}

DWORD
HandleQosShowDsMap(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for showing diffserv maps
    in the global info.

Arguments:

    None

Return Value:

    None

--*/

{
    return HandleQosShowGenericQosObject(QOS_OBJECT_DIFFSERV,
                                         pptcArguments,
                                         dwCurrentIndex,
                                         dwArgCount,
                                         pbDone);
}

//
// Flow Add, Del, Set Handlers
//


DWORD
HandleQosAddFlowOnIf(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for adding flows on an interface

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    NO_ERROR
    
--*/
{
    return GetQosAddDelIfFlowOpt(pptcArguments,
                                 dwCurrentIndex,
                                 dwArgCount,
                                 TRUE);
}

DWORD
HandleQosDelFlowOnIf(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Gets options for deleting flows on an interface

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    
Return Value:

    NO_ERROR
    
--*/
{
    return GetQosAddDelIfFlowOpt(pptcArguments,
                                 dwCurrentIndex,
                                 dwArgCount,
                                 FALSE);
}

DWORD
HandleQosShowFlowOnIf(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    WCHAR              wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD              dwBufferSize = sizeof(wszInterfaceName);
    TAG_TYPE           pttTags[] = {{TOKEN_OPT_NAME,FALSE,FALSE},
                                    {TOKEN_OPT_FLOW_NAME,FALSE,FALSE}};
    PTCHAR             pszIfName;
    PTCHAR             pszFlow;
    DWORD              dwNumOpt, dwRes;
    DWORD              dwNumArg, i, j;
    DWORD              dwErr;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    pszIfName = pszFlow = NULL;
    
    if (dwCurrentIndex == dwArgCount)
    {
        //
        // No arguments - show all flows on all interfaces
        //

        dwErr = NO_ERROR;
    }
    else {

        //
        // Get name of the flow to show
        //

        dwErr = PreprocessCommand(
                    g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                    pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                    1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                    );

        if ( dwErr != NO_ERROR )
        {
            return dwErr;
        }

        dwNumArg = dwArgCount - dwCurrentIndex;

        for ( i = 0; i < dwNumArg; i++ )
        {
            switch (pdwTagType[i])
            {
            case 0: // Interfacename

                IpmontrGetIfNameFromFriendlyName(pptcArguments[i + dwCurrentIndex],
                                                 wszInterfaceName,
                                                 &dwBufferSize);
                pszIfName = wszInterfaceName;
                break;

            case 1: // Flowname

                pszFlow = pptcArguments[dwCurrentIndex + i];
                break;

            default:

                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }
    }

    if (dwErr == NO_ERROR)
    {
        dwErr = ShowQosFlows(NULL, pszIfName, pszFlow);
    }

    return dwErr;
}


//
// FlowspecOnFlow Add, Del Handlers
//

DWORD
HandleQosAddFlowspecOnIfFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return GetQosAddDelFlowspecOnFlowOpt(pptcArguments,
                                         dwCurrentIndex,
                                         dwArgCount,
                                         TRUE);
}

DWORD
HandleQosDelFlowspecOnIfFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return GetQosAddDelFlowspecOnFlowOpt(pptcArguments,
                                         dwCurrentIndex,
                                         dwArgCount,
                                         FALSE);
}

//
// QosObject Del, Show Handlers
//

DWORD
HandleQosDelQosObject(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Gets options for deleting qos objects
    in the global info.

Arguments:

    None

Return Value:

    None

--*/

{
    TAG_TYPE           pttTags[] = {{TOKEN_OPT_NAME,TRUE,FALSE}};
    PWCHAR             pwszQosObject;
    DWORD              dwNumArg;
    DWORD              dwErr;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    if (dwNumArg != 1)
    {
        return ERROR_INVALID_SYNTAX;
    }

    //
    // Get name of the qosobject to delete
    //

    pwszQosObject = pptcArguments[dwCurrentIndex];

    return GetQosAddDelQosObject(pwszQosObject, NULL, FALSE);
}


DWORD
HandleQosShowQosObject(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Gets options for showing qos objects
    in the global info.

Arguments:

    None

Return Value:

    None

--*/

{
    TAG_TYPE           pttTags[] = {{TOKEN_OPT_NAME,FALSE,FALSE},
                                    {TOKEN_OPT_QOSOBJECT_TYPE,FALSE,FALSE}};
    PTCHAR             pszQosObject;
    ULONG              dwObjectType;
    DWORD              dwNumOpt, dwRes;
    DWORD              dwNumArg, i, j;
    DWORD              dwTagType, dwErr;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    // Init type to indicate a "generic" object
    dwObjectType = QOS_OBJECT_END_OF_LIST;

    pszQosObject = NULL;

    if (dwCurrentIndex < dwArgCount)
    {
        //
        // Get name of the qosobject to show
        //

        dwErr = PreprocessCommand(
                    g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                    pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                    1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                    );

        if ( dwErr != NO_ERROR )
        {
            return dwErr;
        }

        dwNumArg = dwArgCount - dwCurrentIndex;

        for (i = 0; i < dwNumArg; i++)
        {
            switch (pdwTagType[i])
            {
            case 0 :
                // QOS OBJECT NAME
                pszQosObject = pptcArguments[i + dwCurrentIndex];
                break;

            case 1 :
            {
                // QOS OBJECT TYPE
                
                TOKEN_VALUE    rgEnums[] = 
                    {{TOKEN_OPT_QOSOBJECT_DIFFSERV, QOS_OBJECT_DIFFSERV},
                     {TOKEN_OPT_QOSOBJECT_SD_MODE,  QOS_OBJECT_SD_MODE}};

                GET_ENUM_TAG_VALUE();

                dwObjectType = dwRes;

                break;
            }
            
            default:
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }

        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
    }

    return ShowQosObjects(NULL, pszQosObject, dwObjectType);
}

DWORD
HandleQosShowGenericQosObject(
    DWORD     dwQosObjectType,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Gets options for showing qos objects
    in the global info.

Arguments:

    None

Return Value:

    None

--*/

{
    TAG_TYPE           pttTags[] = {{TOKEN_OPT_NAME,FALSE,FALSE}};
    PTCHAR             pszQosObject;
    DWORD              dwNumArg;
    DWORD              dwTagType, dwErr;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    pszQosObject = NULL;
    
    if (dwCurrentIndex < dwArgCount)
    {
        //
        // Get name of the qosobject to show
        //

        dwErr = PreprocessCommand(
                    g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                    pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                    1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                    );

        if ( dwErr != NO_ERROR )
        {
            return dwErr;
        }

        dwNumArg = dwArgCount - dwCurrentIndex;

        if (dwNumArg != 1)
        {
            return ERROR_INVALID_SYNTAX;
        }

        pszQosObject = pptcArguments[dwCurrentIndex];
    }

    return ShowQosObjects(NULL, pszQosObject, dwQosObjectType);
}

//
// SDMode Add, Del, Show Handlers
//

DWORD
HandleQosAddSdMode(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Gets options for adding shape modes
    to the global info.

Arguments:

    None

Return Value:

    None

--*/

{
    TAG_TYPE           pttTags[] = {{TOKEN_OPT_NAME,TRUE,FALSE},
                                    {TOKEN_OPT_SHAPING_MODE,TRUE,FALSE}};
    QOS_SD_MODE        qsdMode;
    PTCHAR             pszSdMode;
    DWORD              dwSdMode, dwNumArg, i, j, dwErr, dwRes;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    // Init to -1 to indicate value not filled in
    dwSdMode = -1;

    dwNumArg = dwArgCount - dwCurrentIndex;

    //
    // Process the arguments now
    //

    for (i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
                // SDMODE_NAME
                pszSdMode = pptcArguments[i + dwCurrentIndex];
                break;

            case 1:
            {
                // SHAPING
                TOKEN_VALUE    rgEnums[] = 
                    {{TOKEN_OPT_SDMODE_BORROW, TC_NONCONF_BORROW},
                     {TOKEN_OPT_SDMODE_SHAPE, TC_NONCONF_SHAPE},
                     {TOKEN_OPT_SDMODE_DISCARD, TC_NONCONF_DISCARD},
                     {TOKEN_OPT_SDMODE_BORROW_PLUS, TC_NONCONF_BORROW_PLUS}};
                
                GET_ENUM_TAG_VALUE();

                dwSdMode = dwRes;

                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }       
        }        
    }

    if (dwErr == NO_ERROR)
    {
#if 0
        // interface name should be present
        // and also the shaping mode value
    
        if ((!pttTags[0].bPresent) ||
            (!pttTags[1].bPresent))
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
#endif
        // Create a new QOS object with inp
        qsdMode.ObjectHdr.ObjectType   = QOS_OBJECT_SD_MODE ;
        qsdMode.ObjectHdr.ObjectLength = sizeof(QOS_SD_MODE);
        qsdMode.ShapeDiscardMode = dwSdMode;
        
        dwErr = GetQosAddDelQosObject(pszSdMode, 
                                      (QOS_OBJECT_HDR *)&qsdMode,
                                      TRUE);
    }

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}


DWORD
HandleQosShowSdMode(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Gets options for showing shape modes
    in the global info.

Arguments:

    None

Return Value:

    None

--*/

{
    return HandleQosShowGenericQosObject(QOS_OBJECT_SD_MODE,
                                         pptcArguments,
                                         dwCurrentIndex,
                                         dwArgCount,
                                         pbDone);
}

//
// QosObjectOnFlow Add, Del Handlers
//

DWORD
HandleQosAddQosObjectOnIfFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return GetQosAddDelQosObjectOnFlowOpt(pptcArguments,
                                          dwCurrentIndex,
                                          dwArgCount,
                                          TRUE);
}

DWORD
HandleQosDelQosObjectOnIfFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return GetQosAddDelQosObjectOnFlowOpt(pptcArguments,
                                          dwCurrentIndex,
                                          dwArgCount,
                                          FALSE);
}

//
// Filter Add, Del, Set Handlers
//

DWORD
HandleQosAttachFilterToFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return ERROR_NOT_SUPPORTED;
}

DWORD
HandleQosDetachFilterFromFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return ERROR_NOT_SUPPORTED;
}

DWORD
HandleQosModifyFilterOnFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return ERROR_NOT_SUPPORTED;
}

DWORD
HandleQosShowFilterOnFlow(
    PWCHAR    pwszMachine,
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    return ERROR_NOT_SUPPORTED;
}

//
// If Helper functions
//

DWORD
GetQosSetIfOpt(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      PWCHAR                  wszIfName,
    IN      DWORD                   dwSizeOfwszIfName,
    OUT     PIPQOS_IF_CONFIG        pChangeCfg,
    OUT     DWORD                  *pdwBitVector,
    IN      BOOL                    bAddSet
    )

/*++
Routine Description:

    Gets options for set interface, add interface

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    wszIfName       - Interface name.
    dwSizeOfwszIfName-Size of the wszIfName buffer
    pChangeCfg      - The config containing changes values
    pdwBitVector    - Bit vector specifying what values have changed
    bAddSet         - Called when If entry is being created or set
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD              dwErr = NO_ERROR,dwRes;
    TAG_TYPE           pttTags[] = {{TOKEN_OPT_NAME,TRUE,FALSE},
                                    {TOKEN_OPT_IF_STATE,FALSE,FALSE}};
    DWORD              dwNumOpt;
    DWORD              dwNumArg, i, j;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                //
                // INTERFACE_NAME
                //

                IpmontrGetIfNameFromFriendlyName(pptcArguments[i + dwCurrentIndex],
                                                 wszIfName,&dwSizeOfwszIfName);
    
                break;
            }

            case 1:
            {
                //
                // STATE
                //

                TOKEN_VALUE    rgEnums[] =
                       {{TOKEN_OPT_VALUE_DISABLE, IPQOS_STATE_DISABLED},
                        {TOKEN_OPT_VALUE_ENABLE,  IPQOS_STATE_ENABLED}};

                GET_ENUM_TAG_VALUE();

                pChangeCfg->QosState = dwRes;

                *pdwBitVector |= QOS_IF_STATE_MASK;

                break;
            }
     
            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }       
        }
    }

#if 0

    // interface name should be present
    
    if (!pttTags[0].bPresent)
    {
        dwErr = ERROR_INVALID_SYNTAX;
    }

#endif

    return dwErr;    
}


//
// Flow Helper functions
//

DWORD
GetQosAddDelIfFlowOpt(
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    )
/*++

Routine Description:

    Gets options for add/del/set(modify) flows

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    bAdd            - Adding or deleting flows
    
Return Value:

    NO_ERROR
    
--*/
{
    PIPQOS_IF_CONFIG      piicSrc = NULL, piicDst = NULL;
    DWORD                 dwBlkSize, dwNewBlkSize, dwQosCount;
    DWORD                 i, j, dwErr = NO_ERROR, dwNumOpt;
    DWORD                 dwSkip, dwOffset, dwSize, dwBitVector = 0;
    DWORD                 dwIfType;
    WCHAR                 wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD                 dwBufferSize = sizeof(wszIfName);
    PIPQOS_IF_FLOW        pNextFlow, pDestFlow;
    PWCHAR                pwszFlowName;
    DWORD                 dwNumArg;
    PUCHAR                pFlow;
    TAG_TYPE              pttTags[] = {{TOKEN_OPT_NAME,TRUE,FALSE},
                                       {TOKEN_OPT_FLOW_NAME,TRUE,FALSE}};
    DWORD                 pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    for ( i = 0; i < dwNumArg; i++ )
    {
        switch (pdwTagType[i])
        {
        case 0:
                /* Get interface name for the flow */
                IpmontrGetIfNameFromFriendlyName(pptcArguments[i + dwCurrentIndex],
                                                 wszIfName, &dwBufferSize);
                break;

        case 1: 
                /* Get the flow name for the flow */
                pwszFlowName = pptcArguments[i + dwCurrentIndex];
                break;

        default:

                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
        }
    }

    do
    {
        if (dwErr != NO_ERROR)
        {
            break;
        }

#if 0
        // interface and flow names should be present
    
        if ((!pttTags[0].bPresent) || (!pttTags[1].bPresent))
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
#endif

        //
        // Get the interface info and check if flow already exists
        //

        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(wszIfName,
                                                     MS_IP_QOSMGR,
                                                     (PBYTE *) &piicSrc,
                                                     &dwBlkSize,
                                                     &dwQosCount,
                                                     &dwIfType);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        if ( piicSrc == NULL )
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

       pNextFlow = (PIPQOS_IF_FLOW)((PUCHAR)piicSrc + sizeof(IPQOS_IF_CONFIG));

        for (j = 0; j < piicSrc->NumFlows; j++)
        {
            if (!_wcsicmp(pNextFlow->FlowName, pwszFlowName))
            {
                break;
            }

            pNextFlow = (PIPQOS_IF_FLOW)
                  ((PUCHAR) pNextFlow + pNextFlow->FlowSize);
        }

        if (bAdd)
        {
            if (j < piicSrc->NumFlows)
            {
                //
                // We already have a flow by this name
                //

                DisplayMessage(g_hModule, 
                               MSG_FLOW_ALREADY_EXISTS,
                               pwszFlowName);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }
        }
        else
        {
            if (j == piicSrc->NumFlows)
            {
                //
                // We do not have a flow by this name
                //

                DisplayMessage(g_hModule, 
                               MSG_FLOW_NOT_FOUND,
                               pwszFlowName);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            // Flow was found at 'pNextFlow' position
        }

        if (bAdd)
        {
            //
            // We have a new flow definition - update config
            //

            dwNewBlkSize = dwBlkSize + sizeof(IPQOS_IF_FLOW);

            piicDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!piicDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            // Copy all the existing flows to the new config
            memcpy(piicDst, piicSrc, dwBlkSize);

            //
            // Stick the new flow as the last flow in array
            //

            pDestFlow = (PIPQOS_IF_FLOW)((PUCHAR) piicDst + dwBlkSize);

            wcscpy(pDestFlow->FlowName, pwszFlowName);

            pDestFlow->FlowSize = sizeof(IPQOS_IF_FLOW);

            pDestFlow->FlowDesc.SendingFlowspecName[0] = L'\0';
            pDestFlow->FlowDesc.RecvingFlowspecName[0] = L'\0';
            pDestFlow->FlowDesc.NumTcObjects = 0;

            piicDst->NumFlows++;
        }
        else
        {
            //
            // We have to del old flowspec defn - update config
            //

            dwNewBlkSize = dwBlkSize - pNextFlow->FlowSize;

            piicDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!piicDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            
            dwOffset = (PUCHAR)pNextFlow - (PUCHAR)piicSrc;

            // Copy the all the flowspecs that occur before
            memcpy(piicDst, piicSrc, dwOffset);

            // Copy the rest of the flowspecs as they are
            dwSkip = dwOffset + pNextFlow->FlowSize;
            memcpy((PUCHAR) piicDst + dwOffset,
                   (PUCHAR) piicSrc + dwSkip,
                   dwBlkSize - dwSkip);

            piicDst->NumFlows--;
        }

        // Update the interface config by setting new info

        dwErr = IpmontrSetInfoBlockInInterfaceInfo(wszIfName,
                                                   MS_IP_QOSMGR,
                                                   (PBYTE) piicDst,
                                                   dwNewBlkSize,
                                                   dwQosCount);
    }
    while (FALSE);

    HEAP_FREE_NOT_NULL(piicSrc);
    HEAP_FREE_NOT_NULL(piicDst);

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}

DWORD
ShowQosFlows(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  pwszIfGuid,
    IN      PWCHAR                  wszFlowName
    )
{
    PMPR_INTERFACE_0    pmi0;
    DWORD               dwErr, dwCount, dwTotal, i;

    if (pwszIfGuid)
    {
        return ShowQosFlowsOnIf(hFile, pwszIfGuid, wszFlowName);
    }
    else
    {
        //
        // Enumerate all interfaces applicable to QOS
        //

        dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0,
                                     &dwCount,
                                     &dwTotal);

        if(dwErr != NO_ERROR)
        {
            return dwErr;
        }

        for(i = 0; i < dwCount; i++)
        {
            ShowQosFlowsOnIf(hFile, 
                             pmi0[i].wszInterfaceName, 
                             wszFlowName);
        }
    }

    return NO_ERROR;
}

DWORD
ShowQosFlowsOnIf(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  pwszIfGuid,
    IN      PWCHAR                  wszFlowName
    )
{
    WCHAR   wszInterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ] = L"\0";
    DWORD   dwBufferSize = sizeof(wszInterfaceName);
    PWCHAR  pwszFriendlyIfName = NULL;

    PIPQOS_IF_CONFIG piicSrc;
    DWORD dwBlkSize,dwQosCount;
    DWORD dwIfType, dwErr, j, k;
    PIPQOS_IF_FLOW  pNextFlow;
    PWCHAR pwszFlowName = NULL;
    PWCHAR pwszNextObject, pwszObjectName = NULL;
    PWCHAR pwszSendingFlowspec, pwszRecvingFlowspec;

    dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfGuid,
                                                 MS_IP_QOSMGR,
                                                 (PBYTE *) &piicSrc,
                                                 &dwBlkSize,
                                                 &dwQosCount,
                                                 &dwIfType);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    if ( piicSrc == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get friendly name for interface
    //
    
    dwErr = IpmontrGetFriendlyNameFromIfName(pwszIfGuid,
                                             wszInterfaceName,
                                             &dwBufferSize);
    
    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }
    
    pwszFriendlyIfName = MakeQuotedString( wszInterfaceName );
    
    if ( pwszFriendlyIfName == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pNextFlow = (PIPQOS_IF_FLOW)((PUCHAR)piicSrc + sizeof(IPQOS_IF_CONFIG));

    for (j = 0; j < piicSrc->NumFlows; j++)
    {
        if ((!wszFlowName) ||
            (!_wcsicmp(pNextFlow->FlowName, wszFlowName)))
        {
            //
            // Print or dump the flow now
            //

            pwszFlowName = MakeQuotedString(pNextFlow->FlowName);
    
            if (pwszFlowName == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            // Print or dump flowspecs
            
            pwszSendingFlowspec = 
                MakeQuotedString(pNextFlow->FlowDesc.SendingFlowspecName);

            pwszRecvingFlowspec =
                MakeQuotedString(pNextFlow->FlowDesc.RecvingFlowspecName);

            if (hFile)
            {
                DisplayMessageT(DMP_QOS_DELETE_FLOW,
                                pwszFriendlyIfName,
                                pwszFlowName);
                                

                DisplayMessageT(DMP_QOS_ADD_FLOW,
                                pwszFriendlyIfName,
                                pwszFlowName);

                if (!_wcsicmp(pwszSendingFlowspec, pwszRecvingFlowspec))
                {
                    if (pNextFlow->FlowDesc.SendingFlowspecName[0])
                    {
                        DisplayMessageT(DMP_QOS_ADD_FLOWSPEC_ON_FLOW_BI,
                                        pwszFriendlyIfName,
                                        pwszFlowName,
                                        pwszSendingFlowspec);
                    }
                }
                else
                {
                    if (pNextFlow->FlowDesc.RecvingFlowspecName[0])
                    {
                        DisplayMessageT(DMP_QOS_ADD_FLOWSPEC_ON_FLOW_IN,
                                        pwszFriendlyIfName,
                                        pwszFlowName,
                                        pwszRecvingFlowspec);
                    }

                    if (pNextFlow->FlowDesc.SendingFlowspecName[0])
                    {
                        DisplayMessageT(DMP_QOS_ADD_FLOWSPEC_ON_FLOW_OUT,
                                        pwszFriendlyIfName,
                                        pwszFlowName,
                                        pwszSendingFlowspec);
                    }
                }
            }
            else
            {
                DisplayMessage(g_hModule, MSG_QOS_FLOW_INFO,
                               pwszFlowName,
                               pwszFriendlyIfName,
                               pwszRecvingFlowspec,
                               pwszSendingFlowspec,
                               pNextFlow->FlowDesc.NumTcObjects);
            }

            // Print or dump qos objects

            pwszNextObject = 
                (PWCHAR) ((PUCHAR) pNextFlow + sizeof(IPQOS_IF_FLOW));

            for (k = 0; k < pNextFlow->FlowDesc.NumTcObjects; k++)
            {
                pwszObjectName = MakeQuotedString(pwszNextObject);

                if ( pwszObjectName == NULL )
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                if (hFile)
                {
                    DisplayMessageT(DMP_QOS_ADD_QOSOBJECT_ON_FLOW,
                                    pwszFriendlyIfName,
                                    pwszFlowName,
                                    pwszObjectName);
                }
                else
                {
                    DisplayMessage(g_hModule, MSG_QOS_QOSOBJECT_INFO,
                                   k,
                                   pwszObjectName);
                }

                pwszNextObject += MAX_STRING_LENGTH;

                FreeQuotedString(pwszObjectName);
            }

            if ( pwszFlowName )
            {
                FreeQuotedString( pwszFlowName );
                pwszFlowName = NULL;
            }

            //
            // If we matched flow, then done
            //

            if ((wszFlowName) || (dwErr != NO_ERROR))
            {
                break;
            }
        }

        pNextFlow = (PIPQOS_IF_FLOW)
            ((PUCHAR) pNextFlow + pNextFlow->FlowSize);
    }

    if ( pwszFriendlyIfName )
    {
        FreeQuotedString( pwszFriendlyIfName );
    }

    if (dwErr == NO_ERROR)
    {
        if ((wszFlowName) && (j == piicSrc->NumFlows))
        {
            // We didnt find the flow we are looking for
            DisplayMessage(g_hModule, 
                           MSG_FLOW_NOT_FOUND,
                           wszFlowName);
            return ERROR_SUPPRESS_OUTPUT;
        }
    }

    return dwErr;
}


//
// DsRule, DsMap Helpers
//

DWORD
GetQosAddDelDsRuleOpt(
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    )
{
    DWORD               dwErr = NO_ERROR;
    TAG_TYPE            pttTags[] = {
                             {TOKEN_OPT_NAME,TRUE,FALSE},
                             {TOKEN_OPT_INBOUND_DS_FIELD,TRUE,FALSE},
                             {TOKEN_OPT_CONF_OUTBOUND_DS_FIELD,FALSE,FALSE},
                             {TOKEN_OPT_NONCONF_OUTBOUND_DS_FIELD,FALSE,FALSE},
                             {TOKEN_OPT_CONF_USER_PRIORITY,FALSE,FALSE},
                             {TOKEN_OPT_NONCONF_USER_PRIORITY,FALSE,FALSE}};
    PIPQOS_NAMED_QOSOBJECT pThisQosObject, pNextQosObject;
    PVOID                  pBuffer;
    PTCHAR                 pszDsMap;
    QOS_DIFFSERV          *pDsMap;
    QOS_DIFFSERV_RULE      dsRule, *pDsRule, *pNextDsRule;
    PIPQOS_GLOBAL_CONFIG   pigcSrc = NULL, pigcDst = NULL;
    DWORD                  dwBlkSize, dwNewBlkSize, dwQosCount;
    DWORD              dwNumOpt, dwRes;
    DWORD              dwNumArg, i, j;
    DWORD              dwSkip, dwOffset;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    //
    // We need all params for add and atleast
    // the dsmap name n dsrule num for delete
    //

    if (( bAdd && (dwNumArg != 6)) ||
        (!bAdd && (dwNumArg != 2)))
    {
        return ERROR_INVALID_SYNTAX;
    }

    pDsRule = &dsRule;

    //
    // Initialize the diffserv rule definition
    //

    memset(pDsRule, 0, sizeof(QOS_DIFFSERV_RULE));

    //
    // Process the arguments now
    //

    for ( i = 0; i < dwNumArg; i++)
    {
        // All params except the first are uchar vals

        if ( pdwTagType[i] > 0)
        {
            // What if this is not a valid ULONG ? '0' will not do...
            dwRes = _tcstoul(pptcArguments[i + dwCurrentIndex],NULL,10);
        }

        switch (pdwTagType[i])
        {
            case 0:

                //
                // DSMAP Name: See if we already have the name
                //

                pszDsMap = pptcArguments[i + dwCurrentIndex];

                dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                                          (PBYTE *) &pigcSrc,
                                                          &dwBlkSize,
                                                          &dwQosCount);
                if (dwErr != NO_ERROR)
                {
                    break;
                }

                if ( pigcSrc == NULL )
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

                dwOffset = FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr);

                pThisQosObject = NULL;

                pNextQosObject = 
                    (PIPQOS_NAMED_QOSOBJECT)((PUCHAR) pigcSrc
                                             + sizeof(IPQOS_GLOBAL_CONFIG)
                                             + (pigcSrc->NumFlowspecs *
                                                sizeof(IPQOS_NAMED_FLOWSPEC)));

                for (j = 0; j < pigcSrc->NumQosObjects; j++)
                {
                    if (!_wcsicmp(pNextQosObject->QosObjectName, 
                                  pszDsMap))
                    {
                        break;
                    }

                    pNextQosObject =
                                (PIPQOS_NAMED_QOSOBJECT) 
                                   ((PUCHAR) pNextQosObject + 
                                    dwOffset +
                                    pNextQosObject->QosObjectHdr.ObjectLength);
                }

                if (j < pigcSrc->NumQosObjects)
                {
                    //
                    // You cannot add/del dsrules from a non dsmap
                    //

                    if (pNextQosObject->QosObjectHdr.ObjectType !=
                            QOS_OBJECT_DIFFSERV)
                    {
                        i = dwNumArg;
                        dwErr = ERROR_INVALID_FUNCTION;
                        break;
                    }
                }

                if (bAdd)
                {
                    if (j < pigcSrc->NumQosObjects)
                    {
                        // Remember QOS object you are interested in
                        pThisQosObject = pNextQosObject;
                    }
                }
                else
                {
                    if (j == pigcSrc->NumQosObjects)
                    {
                        //
                        // We do not have a qos object by this name
                        //

                        DisplayMessage(g_hModule, 
                                       MSG_QOSOBJECT_NOT_FOUND,
                                       pszDsMap);
                        i = dwNumArg;
                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }

                    // Remember QOS object you are interested in
                    pThisQosObject = pNextQosObject;
                }

                break;

            case 1:
                // INBOUND_DS
                pDsRule->InboundDSField = (UCHAR) dwRes;
                break;

            case 2:
                // CONF_OUTBOUND_DS
                pDsRule->ConformingOutboundDSField = (UCHAR) dwRes;
                break;

            case 3:
                // NONCONF_OUTBOUND_DS
                pDsRule->NonConformingOutboundDSField = (UCHAR) dwRes;
                break;

            case 4:
                // CONF_USER_PRIOTITY
                pDsRule->ConformingUserPriority = (UCHAR) dwRes;
                break;

            case 5:
                // NONCONF_USER_PRIOTITY
                pDsRule->NonConformingUserPriority = (UCHAR) dwRes;
                break;

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }       
        }
    }

    do
    {
        if (dwErr != NO_ERROR)
        {
            break;
        }

#if 0
        //
        // interface name should be present
        // and the ds rule id (inbound ds)
        //

        if ((!pttTags[0].bPresent) ||
            (!pttTags[1].bPresent))
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
#endif

        //
        // and the test of the info for add
        //

        if (bAdd)
        {
            if ((!pttTags[2].bPresent) ||
                (!pttTags[3].bPresent) ||
                (!pttTags[4].bPresent) ||
                (!pttTags[5].bPresent))
            {
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }

#if 1
        //
        // BUGBUG: Adding and deleting DS rules will cause
        // the corresponding map to be updated, but will
        // this result in getting dependent flows changed?
        //
#endif
    
        if (bAdd)
        {
            if (pThisQosObject)
            {
                //
                // Check if this dsrule is already present
                //

                pDsMap = (QOS_DIFFSERV *) &pThisQosObject->QosObjectHdr;

                pNextDsRule = (QOS_DIFFSERV_RULE *)&pDsMap->DiffservRule[0];

                for (j = 0; j < pDsMap->DSFieldCount; j++)
                {
                    if (pNextDsRule->InboundDSField == 
                          pDsRule->InboundDSField)
                    {
                        break;
                    }

                    pNextDsRule++;
                }

                dwOffset = (PUCHAR)pNextDsRule - (PUCHAR)pigcSrc;

                if (j < pDsMap->DSFieldCount)
                {
                    //
                    // Update existing DS rule with info
                    //

                    *pNextDsRule = *pDsRule;

                    dwSkip  = 0;

                    pBuffer = NULL;
                }
                else
                {
                    //
                    // Initialize new DS rule for new rule info
                    //

                    dwSkip = sizeof(QOS_DIFFSERV_RULE);

                    pNextDsRule = HeapAlloc(GetProcessHeap(), 
                                            0, 
                                            dwSkip);

                    if (pNextDsRule == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }

                    *pNextDsRule = *pDsRule;

                    //
                    // Update num of dfsrv rules in src buff
                    // so that dst copy results in new value
                    //

                    pDsMap->DSFieldCount++;

                    pDsMap->ObjectHdr.ObjectLength +=sizeof(QOS_DIFFSERV_RULE);

                    pBuffer = pNextDsRule;
                }
            }
            else
            {
                //
                // Initialize a new DS map to hold the rule
                //

                dwSkip = sizeof(IPQOS_NAMED_QOSOBJECT) +
                         sizeof(ULONG) + // this for DSFieldCount
                         sizeof(QOS_DIFFSERV_RULE);

                dwOffset = (PUCHAR) pNextQosObject - (PUCHAR) pigcSrc;

                pThisQosObject = HeapAlloc(GetProcessHeap(), 
                                           0, 
                                           dwSkip);

                if (pThisQosObject == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                wcscpy(pThisQosObject->QosObjectName, pszDsMap);

                pDsMap = (QOS_DIFFSERV *) &pThisQosObject->QosObjectHdr;

                pDsMap->ObjectHdr.ObjectType = QOS_OBJECT_DIFFSERV;
                pDsMap->ObjectHdr.ObjectLength = 
                    dwSkip - FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr);

                pDsMap->DSFieldCount = 1;

                pNextDsRule = 
                    (QOS_DIFFSERV_RULE *) &pDsMap->DiffservRule[0];

                *pNextDsRule = *pDsRule;

                //
                // Update num of qos objects in src buff
                // so that dst copy results in new value
                //

                pigcSrc->NumQosObjects++;

                pBuffer = pThisQosObject;
            }

            dwNewBlkSize = dwBlkSize + dwSkip;
                                       
            pigcDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!pigcDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            
            // Copy the all the info that occurs before
            memcpy(pigcDst, pigcSrc, dwOffset);

            // Copy the new information after dwOffset
            memcpy((PUCHAR) pigcDst + dwOffset,
                   pBuffer, 
                   dwSkip);

            // Copy the rest of the info as it is
            memcpy((PUCHAR) pigcDst + dwOffset + dwSkip,
                   (PUCHAR) pigcSrc + dwOffset,
                   dwBlkSize - dwOffset);

            HEAP_FREE_NOT_NULL(pBuffer);
        }
        else
        {
            //
            // Check if this dsrule is already present
            //

            pDsMap = (QOS_DIFFSERV *) &pThisQosObject->QosObjectHdr;

            pNextDsRule = (QOS_DIFFSERV_RULE *)&pDsMap->DiffservRule[0];

            for (j = 0; j < pDsMap->DSFieldCount; j++)
            {
                if (pNextDsRule->InboundDSField == 
                      pDsRule->InboundDSField)
                {
                    break;
                }

                pNextDsRule++;
            }

            if (j == pDsMap->DSFieldCount)
            {
                // Did not find DS rule in the DS map
                DisplayMessage(g_hModule,
                               MSG_DSRULE_NOT_FOUND,
                               pszDsMap,
                               pDsRule->InboundDSField);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            if (pDsMap->DSFieldCount == 1)
            {
                // Last DS rule in the DS map

                dwOffset = (PUCHAR)pThisQosObject - (PUCHAR)pigcSrc;

                dwSkip = sizeof(IPQOS_NAMED_QOSOBJECT) +
                         sizeof(ULONG) + // this for DSFieldCount
                         sizeof(QOS_DIFFSERV_RULE);

                //
                // Update num of qos objects in src buff
                // so that dst copy results in new value
                //

                pigcSrc->NumQosObjects--;
            }
            else
            {
                // More than 1 rule in DS map

                dwOffset = (PUCHAR)pNextDsRule - (PUCHAR)pigcSrc;

                dwSkip = sizeof(QOS_DIFFSERV_RULE);

                //
                // Update num of dfsrv rules in src buff
                // so that dst copy results in new value
                //

                pDsMap->DSFieldCount--;

                pDsMap->ObjectHdr.ObjectLength -= sizeof(QOS_DIFFSERV_RULE);
            }

            dwNewBlkSize = dwBlkSize - dwSkip;
                                       
            pigcDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!pigcDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            
            // Copy the all the info that occurs before
            memcpy(pigcDst, pigcSrc, dwOffset);

            // Copy the rest of the info as it is
            dwOffset += dwSkip;
            memcpy((PUCHAR) pigcDst + dwOffset - dwSkip,
                   (PUCHAR) pigcSrc + dwOffset,
                   dwBlkSize - dwOffset);
        }

        // Update the global config by setting new info

        dwErr = IpmontrSetInfoBlockInGlobalInfo(MS_IP_QOSMGR,
                                                (PBYTE) pigcDst,
                                                dwNewBlkSize,
                                                dwQosCount);
        if (dwErr == NO_ERROR)
        {
            UpdateAllInterfaceConfigs();
        }
    }
    while (FALSE);

    HEAP_FREE_NOT_NULL(pigcSrc);
    HEAP_FREE_NOT_NULL(pigcDst);

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}

DWORD
ShowQosDsMap(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszDsMapName,
    IN      QOS_OBJECT_HDR         *pQosObject
    )
{
    QOS_DIFFSERV_RULE  *pDsRule;
    QOS_DIFFSERV *pDsMap;
    PWCHAR pwszDsMapName;
    DWORD dwErr, k;

    pDsMap = (QOS_DIFFSERV *) pQosObject;

    //
    // Print or dump the dsmap now
    //

    do
    {
        pwszDsMapName = MakeQuotedString(wszDsMapName);
    
        if (pwszDsMapName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (hFile)
        {
            DisplayMessageT(DMP_QOS_DSMAP_HEADER);
        }
        else
        {
            DisplayMessage(g_hModule, MSG_QOS_DSMAP_INFO,
                           pwszDsMapName,
                           pDsMap->DSFieldCount);
        }

        //
        // Print each DS rule in the map
        //

        pDsRule = (QOS_DIFFSERV_RULE *) &pDsMap->DiffservRule[0];
                
        for (k = 0; k < pDsMap->DSFieldCount; k++)
        {
            if (hFile)
            {
                DisplayMessageT(DMP_QOS_DELETE_DSRULE,
                                pwszDsMapName,
                                pDsRule->InboundDSField);

                DisplayMessageT(DMP_QOS_ADD_DSRULE,
                                pwszDsMapName,
                                pDsRule->InboundDSField,
                                pDsRule->ConformingOutboundDSField,
                                pDsRule->NonConformingOutboundDSField,
                                pDsRule->ConformingUserPriority,
                                pDsRule->NonConformingUserPriority);
            }
            else
            {
                DisplayMessage(g_hModule, MSG_QOS_DSRULE_INFO,
                               pwszDsMapName,
                               k,
                               pDsRule->InboundDSField,
                               pDsRule->ConformingOutboundDSField,
                               pDsRule->NonConformingOutboundDSField,
                               pDsRule->ConformingUserPriority,
                               pDsRule->NonConformingUserPriority);
            }

            pDsRule++;
        }

        if (hFile)
        {
            DisplayMessageT(DMP_QOS_DSMAP_FOOTER);
        }

        if ( pwszDsMapName )
        {
            FreeQuotedString( pwszDsMapName );
        }

        return NO_ERROR;
    }
    while (FALSE);

    return dwErr;
}

//
// SD Mode Helpers
//

DWORD
ShowQosSdMode(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszSdModeName,
    IN      QOS_OBJECT_HDR         *pQosObject
    )
{
    QOS_SD_MODE *pSdMode;
    PWCHAR pwszSdModeName;
    DWORD dwErr, k;
    PTCHAR  ptszSdMode = NULL;
    VALUE_TOKEN  vtSdMode1[] =
                  {TC_NONCONF_BORROW,TOKEN_OPT_SDMODE_BORROW,
                   TC_NONCONF_SHAPE,TOKEN_OPT_SDMODE_SHAPE,
                   TC_NONCONF_DISCARD,TOKEN_OPT_SDMODE_DISCARD,
                   TC_NONCONF_BORROW_PLUS,TOKEN_OPT_SDMODE_BORROW_PLUS};

    VALUE_STRING vtSdMode2[] =
                  {TC_NONCONF_BORROW,STRING_SDMODE_BORROW,
                   TC_NONCONF_SHAPE,STRING_SDMODE_SHAPE,
                   TC_NONCONF_DISCARD,STRING_SDMODE_DISCARD,
                   TC_NONCONF_BORROW_PLUS,STRING_SDMODE_BORROW_PLUS};

    pSdMode = (QOS_SD_MODE *)pQosObject;

    //
    // Print or dump the sdmode now
    //

    do
    {
        pwszSdModeName = MakeQuotedString(wszSdModeName);
    
        if (pwszSdModeName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Get service type of flowspec
        //

        GetAltDisplayString(g_hModule, hFile,
                            pSdMode->ShapeDiscardMode,
                            vtSdMode1,
                            vtSdMode2,
                            NUM_VALUES_IN_TABLE(vtSdMode1),
                            &ptszSdMode);
        
        if ( ptszSdMode == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
            
        if (hFile)
        {
            DisplayMessageT(DMP_QOS_DEL_SDMODE,
                            pwszSdModeName);

            DisplayMessageT(DMP_QOS_ADD_SDMODE,
                            pwszSdModeName,
                            ptszSdMode);
        }
        else
        {
            DisplayMessage(g_hModule, MSG_QOS_SDMODE_INFO,
                           pwszSdModeName,
                           ptszSdMode);
        }

        FREE_STRING_NOT_NULL ( ptszSdMode );

        if ( pwszSdModeName )
        {
            FreeQuotedString( pwszSdModeName );
        }

        return NO_ERROR;
    }
    while (FALSE);

    return dwErr;
}

//
// Qos Object Helpers
//

DWORD
GetQosAddDelQosObject(
    IN      PWCHAR                  pwszQosObjectName,
    IN      QOS_OBJECT_HDR         *pQosObject,
    IN      BOOL                    bAdd
    )
{
    PIPQOS_NAMED_QOSOBJECT pNextQosObject;
    PIPQOS_GLOBAL_CONFIG   pigcSrc = NULL, pigcDst = NULL;
    DWORD                  dwBlkSize, dwNewBlkSize, dwQosCount;
    DWORD                  dwErr, dwSize, dwSkip, dwOffset, j;

    dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                              (PBYTE *) &pigcSrc,
                                              &dwBlkSize,
                                              &dwQosCount);

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    if (pigcSrc == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwOffset = FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr);

    //
    // Search for a QOS Object with this name
    //

    pNextQosObject = (PIPQOS_NAMED_QOSOBJECT)((PUCHAR) pigcSrc
                                             + sizeof(IPQOS_GLOBAL_CONFIG)
                                             + (pigcSrc->NumFlowspecs *
                                                sizeof(IPQOS_NAMED_FLOWSPEC)));

    for (j = 0; j < pigcSrc->NumQosObjects; j++)
    {
        if (!_wcsicmp(pNextQosObject->QosObjectName, 
                      pwszQosObjectName))
        {
            break;
        }

        pNextQosObject = (PIPQOS_NAMED_QOSOBJECT) 
                                   ((PUCHAR) pNextQosObject + 
                                    dwOffset +
                                    pNextQosObject->QosObjectHdr.ObjectLength);
    }

    do
    {
        if (bAdd)
        {
            dwSize = FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr) +
                         pQosObject->ObjectLength;
            dwSkip = 0;

            if (j < pigcSrc->NumQosObjects)
            {
                //
                // Do (not) allow overwriting qos objects
                //
#if NO_UPDATE
                //
                // We already have a qos object by this name
                //

                DisplayMessage(g_hModule, 
                               MSG_QOSOBJECT_ALREADY_EXISTS,
                               pwszQosObjectName);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
#endif
                // Get the existing size of the qos object
                dwSkip = FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr) +
                             pNextQosObject->QosObjectHdr.ObjectLength;
            }
            else
            {
                //
                // Update num of qos objects in src buff
                // so that dst copy results in new value
                //

                pigcSrc->NumQosObjects++;
            }

            dwOffset = (PUCHAR) pNextQosObject - (PUCHAR) pigcSrc;

            dwNewBlkSize = dwBlkSize + dwSize - dwSkip;

            pigcDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!pigcDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            // Copy the all the info that occurs before
            memcpy(pigcDst, pigcSrc, dwOffset);

            // Copy the new information after dwOffset

            // Copy the name of the qos object first
            wcscpy((PWCHAR)((PUCHAR) pigcDst + dwOffset),
                   pwszQosObjectName);

            // Copy the rest of the input information
            memcpy((PUCHAR) pigcDst + dwOffset + MAX_WSTR_LENGTH,
                   (PUCHAR) pQosObject,
                   pQosObject->ObjectLength);

            // Copy the rest of the info as it is
            memcpy((PUCHAR) pigcDst + (dwOffset + dwSize),
                   (PUCHAR) pigcSrc + (dwOffset + dwSkip),
                   dwBlkSize - (dwOffset + dwSkip));
        }
        else
        {
#if 1
            //
            // BUGBUG: What if there are dependent flows ?
            //
#endif
            if (j == pigcSrc->NumQosObjects)
            {
                //
                // We do not have a qos object by this name
                //

                DisplayMessage(g_hModule, 
                               MSG_QOSOBJECT_NOT_FOUND,
                               pwszQosObjectName);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            //
            // Update num of qos objects in src buff
            // so that dst copy results in new value
            //

            pigcSrc->NumQosObjects--;

            dwOffset = (PUCHAR)pNextQosObject - (PUCHAR)pigcSrc;

            dwSkip = FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr) +
                         pNextQosObject->QosObjectHdr.ObjectLength;

            dwNewBlkSize = dwBlkSize - dwSkip;

            pigcDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!pigcDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            // Copy the all the info that occurs before
            memcpy(pigcDst, pigcSrc, dwOffset);

            // Copy the rest of the info as it is
            dwOffset += dwSkip;
            memcpy((PUCHAR) pigcDst + dwOffset - dwSkip,
                   (PUCHAR) pigcSrc + dwOffset,
                   dwBlkSize - dwOffset);
        }

        // Update the global config by setting new info

        dwErr = IpmontrSetInfoBlockInGlobalInfo(MS_IP_QOSMGR,
                                                (PBYTE) pigcDst,
                                                dwNewBlkSize,
                                                dwQosCount);
        if (dwErr == NO_ERROR)
        {
            UpdateAllInterfaceConfigs();
        }
    }
    while (FALSE);

    HEAP_FREE_NOT_NULL(pigcSrc);
    HEAP_FREE_NOT_NULL(pigcDst);

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}

DWORD
ShowQosObjects(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszQosObjectName,
    IN      ULONG                   dwQosObjectType
    )
{
    PIPQOS_NAMED_QOSOBJECT pNextQosObject;
    PIPQOS_GLOBAL_CONFIG pigcSrc;
    PSHOW_QOS_OBJECT     pfnShowQosObject;
    DWORD dwBlkSize,dwQosCount;
    DWORD dwOffset;
    DWORD dwErr, j;

    dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                              (PBYTE *) &pigcSrc,
                                              &dwBlkSize,
                                              &dwQosCount);                
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    if ( pigcSrc == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwOffset = FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr);

    pNextQosObject = (PIPQOS_NAMED_QOSOBJECT)((PUCHAR) pigcSrc
                                              + sizeof(IPQOS_GLOBAL_CONFIG)
                                              + (pigcSrc->NumFlowspecs *
                                                sizeof(IPQOS_NAMED_FLOWSPEC)));

    for (j = 0; j < pigcSrc->NumQosObjects; j++)
    {
        if ((dwQosObjectType == QOS_OBJECT_END_OF_LIST) ||
            (dwQosObjectType == pNextQosObject->QosObjectHdr.ObjectType))
        {
            if ((!wszQosObjectName) ||
                (!_wcsicmp(pNextQosObject->QosObjectName, wszQosObjectName)))
            {
                switch (pNextQosObject->QosObjectHdr.ObjectType)
                {
                case QOS_OBJECT_DIFFSERV:
                    pfnShowQosObject = ShowQosDsMap;
                    break;

                case QOS_OBJECT_SD_MODE:
                    pfnShowQosObject = ShowQosSdMode;
                    break;
                
                default:
                    pfnShowQosObject = ShowQosGenObj;
                }

                pfnShowQosObject(hFile,
                                 pNextQosObject->QosObjectName,
                                 &pNextQosObject->QosObjectHdr);

                //
                // If we matched the qos object name, then done
                //

                if (wszQosObjectName)
                {
                    break;
                }
            }
        }

        pNextQosObject = (PIPQOS_NAMED_QOSOBJECT) 
                             ((PUCHAR) pNextQosObject + 
                              dwOffset + 
                              pNextQosObject->QosObjectHdr.ObjectLength);
    }

    if (dwErr == NO_ERROR)
    {
        if ((wszQosObjectName) && (j == pigcSrc->NumQosObjects))
        {
            // We didnt find the qos object we are looking for
            DisplayMessage(g_hModule, 
                           MSG_QOSOBJECT_NOT_FOUND,
                           wszQosObjectName);

            dwErr = ERROR_SUPPRESS_OUTPUT;
        }
    }

    HEAP_FREE(pigcSrc);

    return dwErr;
}

DWORD
ShowQosGenObj(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszGenObjName,
    IN      QOS_OBJECT_HDR         *pQosObject
    )
{
    // We can print a general description from name and size
    return NO_ERROR;
}

DWORD
GetQosAddDelQosObjectOnFlowOpt(
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    )
/*++

Routine Description:

    Gets options for attach and detach QOS objects
    from flows.

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    bAdd            - Adding or deleting flows
    
Return Value:

    NO_ERROR
    
--*/
{
    PIPQOS_GLOBAL_CONFIG  pigcSrc = NULL;
    PIPQOS_IF_CONFIG      piicSrc = NULL, piicDst = NULL;
    DWORD                 dwBlkSize, dwNewBlkSize, dwQosCount;
    DWORD                 dwBlkSize1, dwQosCount1;
    DWORD                 i, j, k, l;
    DWORD                 dwErr = NO_ERROR, dwNumOpt;
    DWORD                 dwRes;
    DWORD                 dwSkip, dwOffset, dwSize, dwBitVector = 0;
    DWORD                 dwIfType;
    WCHAR                 wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PIPQOS_NAMED_QOSOBJECT pNamedQosObject, pNextQosObject;
    PIPQOS_IF_FLOW        pNextFlow, pDestFlow;
    PWCHAR                pwszFlowName, pwszQosObject, pwszNextObject;
    DWORD                 dwNumArg,
                          dwBufferSize = sizeof(wszIfName);
    PUCHAR                pFlow;
    TAG_TYPE              pttTags[] = {{TOKEN_OPT_NAME,TRUE,FALSE},
                                       {TOKEN_OPT_FLOW_NAME,TRUE,FALSE},
                                       {TOKEN_OPT_QOSOBJECT,TRUE,FALSE}};

    DWORD                 pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    for ( i = 0; i < dwNumArg; i++ )
    {
        switch (pdwTagType[i])
        {
        case 0:
                // INTERFACE NAME
                IpmontrGetIfNameFromFriendlyName( pptcArguments[i + dwCurrentIndex],
                                                  wszIfName,&dwBufferSize);
                break;

        case 1: 
                // FLOW NAME
                pwszFlowName = pptcArguments[i + dwCurrentIndex];
                break;

        case 2: 
                // QOSOBJECT NAME
                pwszQosObject = pptcArguments[i + dwCurrentIndex];
                break;

        default:

                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
        }
    }

    do
    {
        if (dwErr != NO_ERROR)
        {
            break;
        }

#if 0
        // interface, flow, qosobject names should be present
    
        if ((!pttTags[0].bPresent) || 
            (!pttTags[1].bPresent) ||
            (!pttTags[2].bPresent))
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
#endif

        //
        // Get the interface info and check if flow already exists
        //

        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(wszIfName,
                                                     MS_IP_QOSMGR,
                                                     (PBYTE *) &piicSrc,
                                                     &dwBlkSize,
                                                     &dwQosCount,
                                                     &dwIfType);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        if ( piicSrc == NULL )
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

       pNextFlow = (PIPQOS_IF_FLOW)((PUCHAR)piicSrc + sizeof(IPQOS_IF_CONFIG));

        for (j = 0; j < piicSrc->NumFlows; j++)
        {
            if (!_wcsicmp(pNextFlow->FlowName, pwszFlowName))
            {
                break;
            }

            pNextFlow = (PIPQOS_IF_FLOW)
                  ((PUCHAR) pNextFlow + pNextFlow->FlowSize);
        }

        if (j == piicSrc->NumFlows)
        {
            //
            // We do not have a flow by this name
            //

            DisplayMessage(g_hModule, 
                           MSG_FLOW_NOT_FOUND,
                           pwszFlowName);
            i = dwNumArg;
            dwErr = ERROR_SUPPRESS_OUTPUT;
            break;
        }

        // Flow was found at 'pNextFlow' position

        //
        // Search for a QOS object by this name
        //

        pwszNextObject = 
            (PWCHAR) ((PUCHAR) pNextFlow + sizeof(IPQOS_IF_FLOW));

        for (k = 0; k < pNextFlow->FlowDesc.NumTcObjects; k++)
        {
            if (!_wcsicmp(pwszNextObject, pwszQosObject))
            {
                break;
            }

            pwszNextObject += MAX_STRING_LENGTH;
        }

        if (!bAdd)
        {
            //
            // Make sure that the flow has the named qosobject
            //

            if (k == pNextFlow->FlowDesc.NumTcObjects)
            {
                DisplayMessage(g_hModule,
                               MSG_QOSOBJECT_NOT_FOUND,
                               pwszQosObject);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            //
            // Update number of qos objects in src buff
            // so that copy to dest results in new value
            //

            pNextFlow->FlowSize -= MAX_WSTR_LENGTH;

            pNextFlow->FlowDesc.NumTcObjects--;

            //
            // Delete the association of the qosobject & flow
            //

            dwNewBlkSize = dwBlkSize - MAX_WSTR_LENGTH;

            piicDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!piicDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            
            dwOffset = (PUCHAR)pwszNextObject - (PUCHAR)piicSrc;

            // Copy the all the objects that occur before
            memcpy(piicDst, piicSrc, dwOffset);

            // Copy the rest of the obj names as they are
            dwSkip = dwOffset + MAX_WSTR_LENGTH;
            memcpy((PUCHAR) piicDst + dwOffset,
                   (PUCHAR) piicSrc + dwSkip,
                   dwBlkSize - dwSkip);
        }
        else
        {
            //
            // Does the flow already have this QOS object ?
            //

            if (k < pNextFlow->FlowDesc.NumTcObjects)
            {
                DisplayMessage(g_hModule, 
                               MSG_QOSOBJECT_ALREADY_EXISTS,
                               pwszQosObject);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            //
            // Make sure that qosobject is actually defined
            //

            dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                                      (PBYTE *) &pigcSrc,
                                                      &dwBlkSize1,
                                                      &dwQosCount1);
            
            if (dwErr != NO_ERROR)
            {
                break;
            }

            if ( pigcSrc == NULL )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            dwOffset = FIELD_OFFSET(IPQOS_NAMED_QOSOBJECT, QosObjectHdr);

            pNextQosObject = 
                (PIPQOS_NAMED_QOSOBJECT)((PUCHAR) pigcSrc
                                         + sizeof(IPQOS_GLOBAL_CONFIG)
                                         + (pigcSrc->NumFlowspecs *
                                            sizeof(IPQOS_NAMED_FLOWSPEC)));

            for (l = 0; l < pigcSrc->NumQosObjects; l++)
            {
                if (!_wcsicmp(pNextQosObject->QosObjectName, 
                              pwszQosObject))
                {
                    break;
                }

                pNextQosObject = (PIPQOS_NAMED_QOSOBJECT) 
                                   ((PUCHAR) pNextQosObject + 
                                    dwOffset +
                                    pNextQosObject->QosObjectHdr.ObjectLength);
            }

            if (l == pigcSrc->NumQosObjects)
            {
                //
                // We do not have a qos object by this name
                //

                DisplayMessage(g_hModule,
                               MSG_QOSOBJECT_NOT_FOUND,
                               pwszQosObject);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            //
            // Update number of qos objects in src buff
            // so that copy to dest results in new value
            //

            pNextFlow->FlowSize += MAX_WSTR_LENGTH;

            pNextFlow->FlowDesc.NumTcObjects++;

            //
            // Create the association of the qosobject & flow
            //

            dwNewBlkSize = dwBlkSize + MAX_WSTR_LENGTH;

            piicDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!piicDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            
            dwOffset = (PUCHAR)pwszNextObject - (PUCHAR)piicSrc;

            // Copy the all the objects that occur before
            memcpy(piicDst, piicSrc, dwOffset);

            // Copy the new association at the end of flow
            wcscpy((PWCHAR)((PUCHAR) piicDst + dwOffset),
                   pwszQosObject);

            // Copy the rest of the obj names as they are
            dwSkip = dwOffset + MAX_WSTR_LENGTH;
            memcpy((PUCHAR) piicDst + dwSkip,
                   (PUCHAR) piicSrc + dwOffset,
                   dwBlkSize - dwOffset);
        }

        // Update the interface config by setting new info

        dwErr = IpmontrSetInfoBlockInInterfaceInfo(wszIfName,
                                                   MS_IP_QOSMGR,
                                                   (PBYTE) piicDst,
                                                   dwNewBlkSize,
                                                   dwQosCount);
    }
    while (FALSE);

    HEAP_FREE_NOT_NULL(piicSrc);
    HEAP_FREE_NOT_NULL(pigcSrc);
    HEAP_FREE_NOT_NULL(piicDst);

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}


//
// Flowspec Helpers
//

DWORD
GetQosAddDelFlowspecOpt(
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    )
{
    DWORD               dwErr = NO_ERROR;
    TAG_TYPE            pttTags[] = {
                              {TOKEN_OPT_NAME,TRUE,FALSE},
                              {TOKEN_OPT_SERVICE_TYPE,FALSE,FALSE},
                              {TOKEN_OPT_TOKEN_RATE,FALSE,FALSE},
                              {TOKEN_OPT_TOKEN_BUCKET_SIZE,FALSE,FALSE},
                              {TOKEN_OPT_PEAK_BANDWIDTH,FALSE,FALSE},
                              {TOKEN_OPT_LATENCY,FALSE,FALSE},
                              {TOKEN_OPT_DELAY_VARIATION,FALSE,FALSE},
                              {TOKEN_OPT_MAX_SDU_SIZE,FALSE,FALSE},
                              {TOKEN_OPT_MIN_POLICED_SIZE,FALSE,FALSE}};
    PIPQOS_NAMED_FLOWSPEC pNamedFlowspec, pNextFlowspec;
    FLOWSPEC           fsFlowspec, *pFlowspec;
    PIPQOS_GLOBAL_CONFIG pigcSrc = NULL, pigcDst = NULL;
    DWORD                   dwBlkSize, dwNewBlkSize, dwQosCount;
    PTCHAR             pszFlowspec;
    DWORD              dwNumOpt, dwRes;
    DWORD              dwNumArg, i, j;
    DWORD              dwSkip, dwOffset;
    DWORD              pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    //
    // We need only the name for delete
    //

    if (!bAdd && (dwNumArg != 1))
    {
        return ERROR_INVALID_SYNTAX;
    }

    pFlowspec = &fsFlowspec;
    if (bAdd)
    {
        //
        // Initialize the flowspec definition
        //

        memset(pFlowspec, QOS_NOT_SPECIFIED, sizeof(FLOWSPEC));
    }

    //
    // Process the arguments now
    //

    for ( i = 0; i < dwNumArg; i++)
    {
        // Only an flowspec name is allowed at delete

        if ((!bAdd) && (pdwTagType[i] != 0))
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        // All params except the first 2 are ulong vals

        if ( pdwTagType[i] > 1)
        {
            // What if this is not a valid ULONG ? '0' will not do...
            dwRes = _tcstoul(pptcArguments[i + dwCurrentIndex],NULL,10);
        }

        switch (pdwTagType[i])
        {
            case 0 :
            {
                //
                // FLOWSPEC_NAME : See if we already have the name
                //

                dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                                          (PBYTE *) &pigcSrc,
                                                          &dwBlkSize,
                                                          &dwQosCount);
                
                if (dwErr != NO_ERROR)
                {
                    break;
                }

                if ( pigcSrc == NULL )
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

                pNextFlowspec = (PIPQOS_NAMED_FLOWSPEC) 
                      ((PUCHAR) pigcSrc + sizeof(IPQOS_GLOBAL_CONFIG));

                for (j = 0; j < pigcSrc->NumFlowspecs; j++)
                {
                    if (!_wcsicmp(pNextFlowspec->FlowspecName,
                                  pptcArguments[i + dwCurrentIndex]))
                    {
                        break;
                    }

                    pNextFlowspec++;
                }

                if (bAdd)
                {
                    //
                    // Do (not) allow overwriting existing flowspecs
                    //
#if NO_UPDATE
                    if (j < pigcSrc->NumFlowspecs)
                    {
                        //
                        // We already have a flowspec by this name
                        //

                        DisplayMessage(g_hModule,
                                       MSG_FLOWSPEC_ALREADY_EXISTS,
                                       pptcArguments[i + dwCurrentIndex]);
                        i = dwNumArg;
                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }
#endif
                    pszFlowspec = pptcArguments[i + dwCurrentIndex];
                }
                else
                {
                    if (j == pigcSrc->NumFlowspecs)
                    {
                        //
                        // We do not have a flowspec by this name
                        //

                        DisplayMessage(g_hModule,
                                       MSG_FLOWSPEC_NOT_FOUND,
                                       pptcArguments[i + dwCurrentIndex]);
                        i = dwNumArg;
                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }
                }

                break;
            }

            case 1:
            {
                //
                // SERVICE_TYPE
                //

                TOKEN_VALUE    rgEnums[] =
                {{TOKEN_OPT_SERVICE_BESTEFFORT, SERVICETYPE_BESTEFFORT},
                 {TOKEN_OPT_SERVICE_CONTROLLEDLOAD,SERVICETYPE_CONTROLLEDLOAD},
                 {TOKEN_OPT_SERVICE_GUARANTEED, SERVICETYPE_GUARANTEED},
                 {TOKEN_OPT_SERVICE_QUALITATIVE, SERVICETYPE_QUALITATIVE}};

                GET_ENUM_TAG_VALUE();

                pFlowspec->ServiceType = dwRes;

                break;
            }
     
            case 2:
            {
                //
                // TOKEN_RATE
                //

                pFlowspec->TokenRate = dwRes;
                break;
            }

            case 3:
            {
                //
                // TOKEN_BUCKET_SIZE
                //

                pFlowspec->TokenBucketSize = dwRes;
                break;
            }

            case 4:
            {
                //
                // PEAK_BANDWIDTH
                //

                pFlowspec->PeakBandwidth = dwRes;
                break;
            }

            case 5:
            {
                //
                // LATENCY
                //

                pFlowspec->Latency = dwRes;
                break;
            }

            case 6:
            {
                //
                // DELAY_VARIATION
                //

                pFlowspec->DelayVariation = dwRes;
                break;
            }

            case 7:
            {
                //
                // MAX_SDU_SIZE
                //

                pFlowspec->MaxSduSize = dwRes;
                break;
            }

            case 8:
            {
                //
                // MIN_POLICED_SIZE
                //

                pFlowspec->MinimumPolicedSize = dwRes;
                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }                
        }
    }

    do
    {
        if (dwErr != NO_ERROR)
        {
            break;
        }

#if 0
        // interface name should be present
    
        if (!pttTags[0].bPresent)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
#endif

        // if add, service type should be present

        if (bAdd && (!pttTags[1].bPresent))
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        if (bAdd)
        {
            //
            // We have a new flowspec definition - update config
            //

            dwNewBlkSize = dwBlkSize;

            if (j == pigcSrc->NumFlowspecs)
            {
                // We do not already have a flowspec by this name
                dwNewBlkSize += sizeof(IPQOS_NAMED_FLOWSPEC);
            }

            pigcDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!pigcDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            dwOffset = (PUCHAR)pNextFlowspec - (PUCHAR) pigcSrc;

            // Copy all existing flowspecs to the new config
            memcpy(pigcDst, pigcSrc, dwOffset);

            // Stick new flowspec at the next flowspec in list
            pNamedFlowspec = 
                (PIPQOS_NAMED_FLOWSPEC)((PUCHAR)pigcDst + dwOffset);
            wcscpy(pNamedFlowspec->FlowspecName, pszFlowspec);
            pNamedFlowspec->FlowspecDesc = fsFlowspec;

            // Copy rest of the interface config information
            dwSkip = dwOffset;

            if (j == pigcSrc->NumFlowspecs)
            {
                pigcDst->NumFlowspecs++;
            }
            else
            {
                // We are overwriting an existing flowspec
                dwSkip += sizeof(IPQOS_NAMED_FLOWSPEC);
            }

            memcpy((PUCHAR)pigcDst + dwOffset + sizeof(IPQOS_NAMED_FLOWSPEC),
                   (PUCHAR)pigcSrc + dwSkip,
                   dwBlkSize - dwSkip);
        }
        else
        {
#if 1
            //
            // BUGBUG: What if there are dependent flows present ?
            //
#endif
            //
            // We have to del old flowspec defn - update config
            //

            dwNewBlkSize = dwBlkSize - sizeof(IPQOS_NAMED_FLOWSPEC);

            pigcDst = HeapAlloc(GetProcessHeap(),0,dwNewBlkSize);
            if (!pigcDst)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            dwOffset = (PUCHAR)pNextFlowspec - (PUCHAR)pigcSrc;

            // Copy the all the flowspecs that occur before
            memcpy(pigcDst, pigcSrc, dwOffset);

            // Copy the rest of the flowspecs as they are
            dwSkip = dwOffset + sizeof(IPQOS_NAMED_FLOWSPEC);
            memcpy((PUCHAR) pigcDst + dwOffset,
                   (PUCHAR) pigcSrc + dwSkip,
                   dwBlkSize - dwSkip);

            pigcDst->NumFlowspecs--;
        }

        // Update the global config by setting new info

        dwErr = IpmontrSetInfoBlockInGlobalInfo(MS_IP_QOSMGR,
                                                (PBYTE) pigcDst,
                                                dwNewBlkSize,
                                                dwQosCount);  
        if (dwErr == NO_ERROR)
        {
            UpdateAllInterfaceConfigs();
        }
    }
    while (FALSE);

    HEAP_FREE_NOT_NULL(pigcSrc);
    HEAP_FREE_NOT_NULL(pigcDst);

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}

DWORD
ShowQosFlowspecs(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszFlowspecName
    )
{
    PIPQOS_GLOBAL_CONFIG pigcSrc;
    DWORD dwBlkSize,dwQosCount;
    DWORD dwErr, j;
    PIPQOS_NAMED_FLOWSPEC pNextFlowspec;
    FLOWSPEC *pFlowspec;
    PWCHAR  pwszFlowspecName = NULL;
    PTCHAR  ptszServiceType = NULL;
    VALUE_TOKEN  vtServiceType1[] =
                  {SERVICETYPE_BESTEFFORT,TOKEN_OPT_SERVICE_BESTEFFORT,
                   SERVICETYPE_CONTROLLEDLOAD,TOKEN_OPT_SERVICE_CONTROLLEDLOAD,
                   SERVICETYPE_GUARANTEED,TOKEN_OPT_SERVICE_GUARANTEED,
                   SERVICETYPE_QUALITATIVE,TOKEN_OPT_SERVICE_QUALITATIVE};

    VALUE_STRING vtServiceType2[] =
                  {SERVICETYPE_BESTEFFORT,STRING_SERVICE_BESTEFFORT,
                   SERVICETYPE_CONTROLLEDLOAD,STRING_SERVICE_CONTROLLEDLOAD,
                   SERVICETYPE_GUARANTEED,STRING_SERVICE_GUARANTEED,
                   SERVICETYPE_QUALITATIVE,STRING_SERVICE_QUALITATIVE};

    dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                              (PBYTE *) &pigcSrc,
                                              &dwBlkSize,
                                              &dwQosCount);
                
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    if ( pigcSrc == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    pNextFlowspec = (PIPQOS_NAMED_FLOWSPEC) ((PUCHAR) pigcSrc + 
                                             sizeof(IPQOS_GLOBAL_CONFIG));

    for (j = 0; j < pigcSrc->NumFlowspecs; j++)
    {
        if ((!wszFlowspecName) ||
            (!_wcsicmp(pNextFlowspec->FlowspecName, wszFlowspecName)))
        {
            pFlowspec = &pNextFlowspec->FlowspecDesc;

            //
            // Print or dump the flowspec now
            //

            pwszFlowspecName = 
                MakeQuotedString(pNextFlowspec->FlowspecName);
    
            if (pwszFlowspecName == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            //
            // Get service type of flowspec
            //

            GetAltDisplayString(g_hModule, hFile,
                                pFlowspec->ServiceType,
                                vtServiceType1,
                                vtServiceType2,
                                NUM_VALUES_IN_TABLE(vtServiceType1),
                                &ptszServiceType);

            if ( ptszServiceType == NULL )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            if (hFile)
            {
                DisplayMessageT(DMP_QOS_DELETE_FLOWSPEC,
                                pwszFlowspecName);

                DisplayMessageT(DMP_QOS_ADD_FLOWSPEC,
                                pwszFlowspecName,
                                ptszServiceType,
                                pFlowspec->TokenRate,
                                pFlowspec->TokenBucketSize,
                                pFlowspec->PeakBandwidth,
                                pFlowspec->Latency,
                                pFlowspec->DelayVariation,
                                pFlowspec->MaxSduSize,
                                pFlowspec->MinimumPolicedSize);
            }
            else
            {
                DisplayMessage(g_hModule, MSG_QOS_FLOWSPEC_INFO,
                               pwszFlowspecName,
                               ptszServiceType,
                               pFlowspec->TokenRate,
                               pFlowspec->TokenBucketSize,
                               pFlowspec->PeakBandwidth,
                               pFlowspec->Latency,
                               pFlowspec->DelayVariation,
                               pFlowspec->MaxSduSize,
                               pFlowspec->MinimumPolicedSize);
            }

            FREE_STRING_NOT_NULL( ptszServiceType ) ;

            if ( pwszFlowspecName )
            {
                FreeQuotedString( pwszFlowspecName );
                pwszFlowspecName = NULL;
            }

            //
            // If we matched flowspec, then done
            //

            if (wszFlowspecName)
            {
                break;
            }
        }

        // Advance to the next flowspec in the list
        pNextFlowspec++;
    }

    if (dwErr == NO_ERROR)
    {
        if ((wszFlowspecName) && (j == pigcSrc->NumFlowspecs))
        {
            // We didnt find the flowspec we are looking for
            DisplayMessage(g_hModule,
                           MSG_FLOWSPEC_NOT_FOUND,
                           wszFlowspecName);

            dwErr = ERROR_SUPPRESS_OUTPUT;
        }
    }

    HEAP_FREE(pigcSrc);

    return dwErr;
}

DWORD
GetQosAddDelFlowspecOnFlowOpt(
    PTCHAR    *pptcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    )
/*++

Routine Description:

    Gets options for attaching and detaching
    flowspecs on flows.

Arguments:

    pptcArguments   - Argument array
    dwCurrentIndex  - pptcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - pptcArguments[dwArgCount - 1] is the last arg 
    bAdd            - Adding or deleting flows
    
Return Value:

    NO_ERROR
    
--*/
{
    PIPQOS_GLOBAL_CONFIG  pigcSrc = NULL;
    PIPQOS_IF_CONFIG      piicSrc = NULL;
    DWORD                 dwBlkSize, dwQosCount;
    DWORD                 dwBlkSize1, dwQosCount1;
    DWORD                 i, j, dwErr = NO_ERROR, dwNumOpt;
    DWORD                 dwRes;
    DWORD                 dwSkip, dwOffset, dwSize, dwBitVector = 0;
    DWORD                 dwIfType, dwDirection;
    WCHAR                 wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PIPQOS_NAMED_FLOWSPEC pNamedFlowspec, pNextFlowspec;
    PIPQOS_IF_FLOW        pNextFlow, pDestFlow;
    PWCHAR                pwszFlowName, pwszFlowspec;
    DWORD                 dwNumArg,
                          dwBufferSize = sizeof(wszIfName);
    PUCHAR                pFlow;
    TAG_TYPE              pttTags[] = {{TOKEN_OPT_NAME,TRUE,FALSE},
                                       {TOKEN_OPT_FLOW_NAME,TRUE,FALSE},
                                       {TOKEN_OPT_FLOWSPEC,TRUE,FALSE},
                                       {TOKEN_OPT_DIRECTION, FALSE, FALSE}};
    DWORD                 pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];

    VERIFY_INSTALLED(MS_IP_QOSMGR, STRING_PROTO_QOS_MANAGER);

    //
    // parse command arguements
    //

    dwErr = PreprocessCommand(
                g_hModule, pptcArguments, dwCurrentIndex, dwArgCount,
                pttTags, sizeof(pttTags)/sizeof(TAG_TYPE),
                1, NUM_TAGS_IN_TABLE(pttTags), pdwTagType
                );

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    dwDirection = DIRECTION_BIDIRECTIONAL;

    for ( i = 0; i < dwNumArg; i++ )
    {
        switch (pdwTagType[i])
        {
        case 0:
                // INTERFACE NAME
                IpmontrGetIfNameFromFriendlyName( pptcArguments[i + dwCurrentIndex],
                                                  wszIfName,&dwBufferSize);
                break;

        case 1: 
                // FLOW NAME
                pwszFlowName = pptcArguments[i + dwCurrentIndex];
                break;

        case 2: 
                // FLOWSPEC NAME
                pwszFlowspec = pptcArguments[i + dwCurrentIndex];
                break;

        case 3:
        {
                // DIRECTION
                TOKEN_VALUE    rgEnums[] =
                 {{TOKEN_OPT_DIRECTION_INBOUND, DIRECTION_INBOUND},
                 {TOKEN_OPT_DIRECTION_OUTBOUND, DIRECTION_OUTBOUND},
                 {TOKEN_OPT_DIRECTION_BIDIRECTIONAL, DIRECTION_BIDIRECTIONAL}};

                GET_ENUM_TAG_VALUE();

                dwDirection = dwRes;

                break;
        }

        default:

                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
        }
    }

    do
    {
        if (dwErr != NO_ERROR)
        {
            break;
        }

#if 0
        // interface, flow, flowspec names should be present
    
        if ((!pttTags[0].bPresent) || 
            (!pttTags[1].bPresent) ||
            (!pttTags[2].bPresent))
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
#endif

        //
        // Get the interface info and check if flow already exists
        //

        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(wszIfName,
                                                     MS_IP_QOSMGR,
                                                     (PBYTE *) &piicSrc,
                                                     &dwBlkSize,
                                                     &dwQosCount,
                                                     &dwIfType);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        if ( piicSrc == NULL )
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

       pNextFlow = (PIPQOS_IF_FLOW)((PUCHAR)piicSrc + sizeof(IPQOS_IF_CONFIG));

        for (j = 0; j < piicSrc->NumFlows; j++)
        {
            if (!_wcsicmp(pNextFlow->FlowName, pwszFlowName))
            {
                break;
            }

            pNextFlow = (PIPQOS_IF_FLOW)
                  ((PUCHAR) pNextFlow + pNextFlow->FlowSize);
        }

        if (j == piicSrc->NumFlows)
        {
            //
            // We do not have a flow by this name
            //

            DisplayMessage(g_hModule,
                           MSG_FLOW_NOT_FOUND,
                           pwszFlowName);
            i = dwNumArg;
            dwErr = ERROR_SUPPRESS_OUTPUT;
            break;
        }

        // Flow was found at 'pNextFlow' position

        if (!bAdd)
        {
            //
            // Make sure that the flow has the named flowspec
            //

            if (dwDirection & DIRECTION_INBOUND)
            {
                if (_wcsicmp(pNextFlow->FlowDesc.RecvingFlowspecName,
                             pwszFlowspec))
                {
                    DisplayMessage(g_hModule,
                                   MSG_FLOWSPEC_NOT_FOUND,
                                   pwszFlowspec);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }
            }

            if (dwDirection & DIRECTION_OUTBOUND)
            {
                if (_wcsicmp(pNextFlow->FlowDesc.SendingFlowspecName,
                             pwszFlowspec))
                {
                    DisplayMessage(g_hModule,
                                   MSG_FLOWSPEC_NOT_FOUND,
                                   pwszFlowspec);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }
            }

            //
            // Delete the association of the flowspec & flow
            //

            if (dwDirection & DIRECTION_INBOUND)
            {
                pNextFlow->FlowDesc.RecvingFlowspecName[0] = L'\0';
            }

            if (dwDirection & DIRECTION_OUTBOUND)
            {
                pNextFlow->FlowDesc.SendingFlowspecName[0] = L'\0';
            }
        }
        else
        {
            //
            // Make sure that the flowspec is actually defined
            //

            dwErr = IpmontrGetInfoBlockFromGlobalInfo(MS_IP_QOSMGR,
                                                      (PBYTE *) &pigcSrc,
                                                      &dwBlkSize1,
                                                      &dwQosCount1);
                
            if (dwErr != NO_ERROR)
            {
                break;
            }

            if ( pigcSrc == NULL )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            pNextFlowspec = (PIPQOS_NAMED_FLOWSPEC) 
                ((PUCHAR) pigcSrc + sizeof(IPQOS_GLOBAL_CONFIG));

            for (j = 0; j < pigcSrc->NumFlowspecs; j++)
            {
                if (!_wcsicmp(pNextFlowspec->FlowspecName,
                              pwszFlowspec))
                {
                    break;
                }

                pNextFlowspec++;
            }

            if (j == pigcSrc->NumFlowspecs)
            {
                //
                // We do not have a flowspec by this name
                //

                DisplayMessage(g_hModule,
                               MSG_FLOWSPEC_NOT_FOUND,
                               pwszFlowspec);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            //
            // Create the association of the flowspec & flow
            //

            if (dwDirection & DIRECTION_INBOUND)
            {
                wcscpy(pNextFlow->FlowDesc.RecvingFlowspecName,
                       pwszFlowspec);
            }

            if (dwDirection & DIRECTION_OUTBOUND)
            {
                wcscpy(pNextFlow->FlowDesc.SendingFlowspecName,
                       pwszFlowspec);
            }
        }

        // Update the interface config by setting new info

        dwErr = IpmontrSetInfoBlockInInterfaceInfo(wszIfName,
                                                   MS_IP_QOSMGR,
                                                   (PBYTE) piicSrc,
                                                   dwBlkSize,
                                                   dwQosCount);
    }
    while (FALSE);

    HEAP_FREE_NOT_NULL(pigcSrc);
    HEAP_FREE_NOT_NULL(piicSrc);

    return (dwErr == NO_ERROR) ? ERROR_OKAY : dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-protocol\makefile.inc ===
qosmmsg.mc:   .\qosmlog.h
    mapmsg NET QOSMLOG_BASE .\qosmlog.h > qosmmsg.mc

qosmmsg.h msg00001.bin:       qosmmsg.mc
    mc -v qosmmsg.mc

qosmgr.rc:      msg00001.bin

clean::
    -del qosmmsg.mc qosmmsg.h msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-netsh\qosp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    qosp.h

Abstract:

    Includes for QOS netsh extension

Revision History:

--*/

#ifndef __QOSP_H
#define __QOSP_H

//
// Constants and Defines
//

#define QOS_LOG_MASK                0x00000001

#define QOS_IF_STATE_MASK           0x00000001

#define DIRECTION_INBOUND           0x00000001
#define DIRECTION_OUTBOUND          0x00000002
#define DIRECTION_BIDIRECTIONAL     (DIRECTION_INBOUND | DIRECTION_OUTBOUND)

#define MAX_WSTR_LENGTH             (MAX_STRING_LENGTH * sizeof(WCHAR))

//
// Extern Global Variables
//

extern ULONG                   g_ulQosNumTopCmds;
extern CMD_ENTRY               g_QosCmds[];

extern ULONG                   g_ulQosNumGroups;
extern CMD_GROUP_ENTRY         g_QosCmdGroups[];

extern ULONG                   g_dwNumQosTableEntries; // Num of sub-helpers

#ifdef ALLOW_CHILD_HELPERS
extern ULONG                   g_dwNumQosContexts;     // Num of sub-contexts
extern PIP_CONTEXT_TABLE_ENTRY g_QosContextTable;
#endif

//
// Function Prototypes
//

// Exported Entry Points

NS_CONTEXT_DUMP_FN   QosDump;

// Command Handlers

FN_HANDLE_CMD  HandleQosInstall;
FN_HANDLE_CMD  HandleQosUninstall;

FN_HANDLE_CMD  HandleQosAddHelper;
FN_HANDLE_CMD  HandleQosDelHelper;
FN_HANDLE_CMD  HandleQosShowHelper;

FN_HANDLE_CMD  HandleQosSetGlobal;
FN_HANDLE_CMD  HandleQosShowGlobal;

FN_HANDLE_CMD  HandleQosAddFlowspec;
FN_HANDLE_CMD  HandleQosDelFlowspec;
FN_HANDLE_CMD  HandleQosShowFlowspec;

FN_HANDLE_CMD  HandleQosDelQosObject;
FN_HANDLE_CMD  HandleQosShowQosObject;

FN_HANDLE_CMD  HandleQosAddSdMode;
FN_HANDLE_CMD  HandleQosShowSdMode;

FN_HANDLE_CMD  HandleQosAddDsRule;
FN_HANDLE_CMD  HandleQosDelDsRule;
FN_HANDLE_CMD  HandleQosShowDsMap;

FN_HANDLE_CMD  HandleQosAddIf;
FN_HANDLE_CMD  HandleQosSetIf;
FN_HANDLE_CMD  HandleQosDelIf;
FN_HANDLE_CMD  HandleQosShowIf;

FN_HANDLE_CMD  HandleQosDump;    
FN_HANDLE_CMD  HandleQosHelp;

FN_HANDLE_CMD  HandleQosAddFlowOnIf;
FN_HANDLE_CMD  HandleQosDelFlowOnIf;
FN_HANDLE_CMD  HandleQosShowFlowOnIf;

FN_HANDLE_CMD  HandleQosAddFlowspecOnIfFlow;
FN_HANDLE_CMD  HandleQosDelFlowspecOnIfFlow;

FN_HANDLE_CMD  HandleQosAddQosObjectOnIfFlow;
FN_HANDLE_CMD  HandleQosDelQosObjectOnIfFlow;

FN_HANDLE_CMD  HandleQosAttachFilterToFlow;
FN_HANDLE_CMD  HandleQosDetachFilterFromFlow;
FN_HANDLE_CMD  HandleQosModifyFilterOnFlow;
FN_HANDLE_CMD  HandleQosShowFilterOnFlow;

FN_HANDLE_CMD  HandleQosMibHelp;
FN_HANDLE_CMD  HandleQosMibShowObject;

// Helper Helper functions

BOOL
IsQosCommand(
    IN PWCHAR pwszCmd
    );

// Info Helper functions

DWORD
UpdateAllInterfaceConfigs(
    VOID
    );

DWORD
MakeQosGlobalInfo(
    OUT      PBYTE                 *ppbStart,
    OUT      PDWORD                 pdwSize
    );

DWORD
MakeQosInterfaceInfo(
    IN      ROUTER_INTERFACE_TYPE   rifType,
    OUT     PBYTE                  *ppbStart,
    OUT     PDWORD                  pdwSize
    );

DWORD
ShowQosGlobalInfo (
    IN      HANDLE                  hFile
    );

DWORD
ShowQosInterfaceInfo(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  pwszIfName
    );

DWORD
ShowQosAllInterfaceInfo(
    IN      HANDLE                  hFile
    );

DWORD
UpdateQosGlobalConfig(
    IN      PIPQOS_GLOBAL_CONFIG    pigcGlobalCfg,
    IN      DWORD                   dwBitVector
    );

DWORD
UpdateQosInterfaceConfig( 
    IN      PWCHAR                  pwszIfName,                         
    IN      PIPQOS_IF_CONFIG        pChangeCfg,
    IN      DWORD                   dwBitVector,
    IN      BOOL                    bAddSet
    );

DWORD
GetQosSetIfOpt(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      PWCHAR                  wszIfName,
    IN      DWORD                   dwSizeOfwszIfName,
    OUT     PIPQOS_IF_CONFIG        pChangeCfg,
    OUT     DWORD                  *pdwBitVector,
    IN      BOOL                    bAddSet
    );

DWORD
GetQosAddDelIfFlowOpt(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      BOOL                    bAdd
    );

DWORD
ShowQosFlows(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  pwszIfGuid,
    IN      PWCHAR                  wszFlowName
    );

DWORD
ShowQosFlowsOnIf(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  pwszIfGuid,
    IN      PWCHAR                  wszFlowName
    );

DWORD
GetQosAddDelFlowspecOpt(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      BOOL                    bAdd
    );

DWORD
ShowQosFlowspecs(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszFlowspecName
    );

DWORD
GetQosAddDelFlowspecOnFlowOpt(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      BOOL                    bAdd
    );

DWORD
GetQosAddDelDsRuleOpt(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      BOOL                    bAdd
    );

DWORD
HandleQosShowGenericQosObject(
    IN      DWORD                   dwQosObjectType,
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      BOOL                   *pbDone
    );

typedef
DWORD
(*PSHOW_QOS_OBJECT)(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszGenObjName,
    IN      QOS_OBJECT_HDR         *pGenObj
    );

DWORD
ShowQosDsMap(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszDsMapName,
    IN      QOS_OBJECT_HDR         *pDsMap
    );

DWORD
ShowQosSdMode(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszSdModeName,
    IN      QOS_OBJECT_HDR         *pSdMode
    );

DWORD
GetQosAddDelQosObject(
    IN      PWCHAR                  pwszQosObjectName,
    IN      QOS_OBJECT_HDR         *pQosObject,
    IN      BOOL                    bAdd
    );

DWORD
GetQosAddDelQosObjectOnFlowOpt(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      BOOL                    bAdd
    );

DWORD
ShowQosObjects(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszQosObjectName,
    IN      ULONG                   dwQosObjectType
    );

DWORD
ShowQosGenObj(
    IN      HANDLE                  hFile,
    IN      PWCHAR                  wszGenObjName,
    IN      QOS_OBJECT_HDR         *pGenObj
    );

// Help Helper Functions

DWORD
ShowQosHelp(
    IN      DWORD                   dwDisplayFlags,
    IN      DWORD                   dwCmdFlags,
    IN      DWORD                   dwArgsRemaining,
    IN      PWCHAR                  pwszGroup
    );

DWORD
WINAPI
DisplayQosHelp(
    VOID
    );

// Dump Helper functions

DWORD
DumpQosInformation (
    IN      HANDLE                  hFile
    );

DWORD
DumpQosHelperInformation (
    IN      HANDLE                  hFile
    );

// MIB Helper defs

typedef
VOID
(*PQOS_PRINT_FN)(
    IN      PIPQOS_MIB_GET_OUTPUT_DATA pgodInfo
    );

typedef struct _QOS_MAGIC_TABLE
{
    DWORD          dwId;
    PQOS_PRINT_FN  pfnPrintFunction;
}QOS_MAGIC_TABLE, *PQOS_MAGIC_TABLE;

// MIB Helper functions

VOID
PrintQosGlobalStats(
    IN      PIPQOS_MIB_GET_OUTPUT_DATA pgodInfo
    );

VOID
PrintQosIfStats(
    IN      PIPQOS_MIB_GET_OUTPUT_DATA pgodInfo
    );

DWORD
GetQosMIBIfIndex(
    IN      PTCHAR                 *pptcArguments,
    IN      DWORD                   dwCurrentIndex,
    OUT     PDWORD                  pdwIndices,
    OUT     PDWORD                  pdwNumParsed 
);

//
// Common Macros
//

#define GET_ENUM_TAG_VALUE()                                            \
        dwErr = MatchEnumTag(g_hModule,                                 \
                             pptcArguments[i + dwCurrentIndex],         \
                             NUM_TOKENS_IN_TABLE(rgEnums),              \
                             rgEnums,                                   \
                             &dwRes);                                   \
                                                                        \
        if (dwErr != NO_ERROR)                                          \
        {                                                               \
            DispTokenErrMsg(g_hModule,                                  \
                            EMSG_BAD_OPTION_VALUE,                      \
                            pttTags[pdwTagType[i]].pwszTag,             \
                            pptcArguments[i + dwCurrentIndex]);         \
                                                                        \
            DisplayMessage(g_hModule,                                   \
                           EMSG_BAD_OPTION_ENUMERATION,                 \
                           pttTags[pdwTagType[i]].pwszTag);             \
                                                                        \
            for ( j = 0; j < NUM_TOKENS_IN_TABLE(rgEnums); j++ )        \
            {                                                           \
                DisplayMessageT( L" %1!s!\n", rgEnums[j].pwszToken );   \
            }                                                           \
                                                                        \
            i = dwNumArg;                                               \
            dwErr = ERROR_SUPPRESS_OUTPUT;                              \
            break;                                                      \
        }                                                               \

#endif // __QOSP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-protocol\pchqosm.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    pchqosm.h

Abstract:

    The file contains precompiled header 
    for the QOS Mgr Protocol.

Revision History:

--*/

#ifndef __PCHQOSM_H_
#define __PCHQOSM_H_

// DO NOT CHANGE ORDER UNLESS YOU KNOW WHAT YOU ARE DOING

#include <nt.h>                 // Include file for NT API applications
#include <ntrtl.h>              // NT runtime USER & KERNEL mode routines
#include <nturtl.h>             // NT runtime USER mode routines

#include <windows.h>            // Include file for Windows applications

#undef   FD_SETSIZE
#define  FD_SETSIZE  256        // Max sockets a WinSock application can use
#include <winsock2.h>           // Interface to WinSock 2 API
#include <ws2tcpip.h>           // WinSock 2 Extension for TCP/IP protocols

#include <routprot.h>           // Interface to Router Manager
#include <rtmv2.h>              // Interface to Routing Table Manager v2
#include <iprtrmib.h>           // MIB variables handled by Router Manager
#include <mgm.h>                // Interface to Multicast Group Manager

#include <mprerror.h>           // Router specific error codes
#include <rtutils.h>            // Utility functions (Log, Trace, ...)

#define  INITGUID
#include <tcguid.h>             // Traffic Control API GUIDS
#include <ndisguid.h>           // Other NDIS adapter  GUIDS
#include <ntddndis.h>           // Needed for "ADDRESS_LIST"
#include <qos.h>                // QOS related definitions
#include <traffic.h>            // Traffic Control API description
#include <tcerror.h>            // Traffic Control API error codes

#include "ipqosrm.h"            // QOS Mgr <-> IP RtrMgr Interface

#include "qosmlog.h"            // Localizable log messages list
#include "qosmdbg.h"            // Logging n' Tracing Facilities

#include "sync.h"               // ReadWriteLock, LockedList Ops

#include "qosmmain.h"           // Global Structure Definitions

#endif // __PCHQOSM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmapi.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    qosmapi.c

Abstract:

    The file contains IP router manager API 
    implementations for the Qos Mgr.

Revision History:

--*/

#include "pchqosm.h"

#pragma hdrstop


DWORD
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS RoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS ServiceChar
    )

/*++

Routine Description:

    Initializes some global data structures in Qos Mgr.

    We initialize some variables here instead of in
    QosmDllStartup as it might not be safe to perform
    some operations in the context of DLL's DLLMain.

    We also export the appropriate callbacks to RM.

    This function is called when RM loads the protocol.

Arguments:

    None

Return Value:

    Status of the operation

--*/

{
    if(RoutingChar->dwProtocolId != MS_IP_QOSMGR)
    {
        return ERROR_NOT_SUPPORTED;
    }

    if  ((RoutingChar->fSupportedFunctionality
          & (RF_ROUTING|RF_DEMAND_UPDATE_ROUTES)) !=
         (RF_ROUTING|RF_DEMAND_UPDATE_ROUTES))
    {
        return ERROR_NOT_SUPPORTED;
    }

    RoutingChar->fSupportedFunctionality =
        (RF_ROUTING | RF_DEMAND_UPDATE_ROUTES);

    //
    // Since we are not a service advertiser (and IPX thing)
    //

    ServiceChar->fSupportedFunctionality = 0;


    RoutingChar->pfnStartProtocol      = StartProtocol;
    RoutingChar->pfnStartComplete      = StartComplete;
    RoutingChar->pfnStopProtocol       = StopProtocol;
    RoutingChar->pfnGetGlobalInfo      = GetGlobalInfo;
    RoutingChar->pfnSetGlobalInfo      = SetGlobalInfo;
    RoutingChar->pfnQueryPower         = NULL;
    RoutingChar->pfnSetPower           = NULL;

    RoutingChar->pfnAddInterface       = AddInterface;
    RoutingChar->pfnDeleteInterface    = DeleteInterface;
    RoutingChar->pfnInterfaceStatus    = InterfaceStatus;
    RoutingChar->pfnGetInterfaceInfo   = GetInterfaceInfo;
    RoutingChar->pfnSetInterfaceInfo   = SetInterfaceInfo;

    RoutingChar->pfnGetEventMessage    = GetEventMessage;

    RoutingChar->pfnUpdateRoutes       = UpdateRoutes;

    RoutingChar->pfnConnectClient      = NULL;
    RoutingChar->pfnDisconnectClient   = NULL;

    RoutingChar->pfnGetNeighbors       = NULL;
    RoutingChar->pfnGetMfeStatus       = NULL;

    RoutingChar->pfnMibCreateEntry     = MibCreateEntry;
    RoutingChar->pfnMibDeleteEntry     = MibDeleteEntry;
    RoutingChar->pfnMibGetEntry        = MibGetEntry;
    RoutingChar->pfnMibSetEntry        = MibSetEntry;
    RoutingChar->pfnMibGetFirstEntry   = MibGetFirstEntry;
    RoutingChar->pfnMibGetNextEntry    = MibGetNextEntry;
    RoutingChar->pfnMibSetTrapInfo     = MibSetTrapInfo;
    RoutingChar->pfnMibGetTrapInfo     = MibGetTrapInfo;

    return NO_ERROR;
}


DWORD
WINAPI
StartProtocol (
    IN      HANDLE                          NotificationEvent,
    IN      PSUPPORT_FUNCTIONS              SupportFunctions,
    IN      LPVOID                          GlobalInfo,
    IN      ULONG                           InfoVer,
    IN      ULONG                           InfoSize,
    IN      ULONG                           InfoCnt
    )
{
    PIPQOS_GLOBAL_CONFIG GlobalConfig;
    DWORD                Status;

    UNREFERENCED_PARAMETER(InfoVer);
    UNREFERENCED_PARAMETER(InfoCnt);

    TraceEnter("StartProtocol");

    GlobalConfig = (IPQOS_GLOBAL_CONFIG *) GlobalInfo;

    do
    {
        //
        // Copy RM support functions to global var
        //

        Globals.SupportFunctions = *SupportFunctions;

        //
        // First update your global configuration
        //

        Status = QosmSetGlobalInfo(GlobalConfig, 
                                   InfoSize);

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Update state to "initialization done"
        //

        Globals.State = IPQOSMGR_STATE_RUNNING;
    }
    while (FALSE);

    TraceLeave("StartProtocol");

    return Status;
}


DWORD
WINAPI
StartComplete (
    VOID
    )
{
    TraceEnter("StartComplete");
    TraceLeave("StartComplete");

    return NO_ERROR;
}


DWORD
WINAPI
StopProtocol (
    VOID
    )
{
    TraceEnter("StopProtocol");
    TraceLeave("StopProtocol");

    return NO_ERROR;
}


DWORD
WINAPI
GetGlobalInfo (
    IN      PVOID                           GlobalInfo,
    IN OUT  PULONG                          BufferSize,
    OUT     PULONG                          InfoVer,
    OUT     PULONG                          InfoSize,
    OUT     PULONG                          InfoCnt
    )
{
    DWORD                  Status;

    UNREFERENCED_PARAMETER(InfoVer);
    UNREFERENCED_PARAMETER(InfoCnt);

#if 1
    *InfoVer = *InfoCnt = 1;
#endif

    Trace2(ENTER, "GetGlobalInfo: Info: %p, Size: %08x",
                   GlobalInfo, 
                   BufferSize);

    Status = QosmGetGlobalInfo(GlobalInfo,
                               BufferSize,
                               InfoSize);

    Trace1(LEAVE, "GetGlobalInfo Returned: %u", Status);

    return Status;
}


DWORD
WINAPI
SetGlobalInfo (
    IN      PVOID                           GlobalInfo,
    IN      ULONG                           InfoVer,
    IN      ULONG                           InfoSize,
    IN      ULONG                           InfoCnt
    )
{
    DWORD   Status;

    Trace2(ENTER, "SetGlobalInfo: Info: %p, Size: %08x",
                   GlobalInfo, 
                   InfoSize);

    Status = QosmSetGlobalInfo(GlobalInfo,
                               InfoSize);

    Trace1(LEAVE, "GetGlobalInfo: Returned %u", Status);

    return Status;
}



DWORD
WINAPI
AddInterface (
    IN      LPWSTR                         InterfaceName,
    IN      ULONG                          InterfaceIndex,
    IN      NET_INTERFACE_TYPE             InterfaceType,
    IN      DWORD                          MediaType,
    IN      WORD                           AccessType,
    IN      WORD                           ConnectionType,
    IN      PVOID                          InterfaceInfo,
    IN      ULONG                          InfoVer,
    IN      ULONG                          InfoSize,
    IN      ULONG                          InfoCnt
    )
{
    PQOSMGR_INTERFACE_ENTRY Interface, NextInterface;
    PIPQOS_IF_CONFIG        InterfaceConfig;
    PLIST_ENTRY             p;
    BOOL                    LockInited;
    DWORD                   Status;

    UNREFERENCED_PARAMETER(InfoVer);
    UNREFERENCED_PARAMETER(InfoCnt);

    TraceEnter("AddInterface");

    //
    // Validate input parameters before creating 'if'
    //

    if ((!InterfaceName) || (!InterfaceInfo))
    {
        return ERROR_INVALID_PARAMETER;
    }

    InterfaceConfig = (PIPQOS_IF_CONFIG) InterfaceInfo;

    Interface = NULL;

    LockInited = FALSE;

    ACQUIRE_GLOBALS_WRITE_LOCK();

    do
    {
        //
        // Search for an interface with this index
        //

        for (p = Globals.IfList.Flink; 
             p != &Globals.IfList; 
             p = p->Flink)
        {
            NextInterface =
                CONTAINING_RECORD(p, QOSMGR_INTERFACE_ENTRY, ListByIndexLE);

            if (NextInterface->InterfaceIndex >= InterfaceIndex)
            {
                break;
            }
        }

        if ((p != &Globals.IfList) &&
               (NextInterface->InterfaceIndex == InterfaceIndex))
        {
            Status = ERROR_ALREADY_EXISTS;
            break;
        }

        //
        // Allocate a new interface structure
        //

        Interface = AllocNZeroMemory(sizeof(QOSMGR_INTERFACE_ENTRY));

        if (Interface == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Fill the interface info from input
        //

        Interface->InterfaceIndex = InterfaceIndex;

        wcscpy(Interface->InterfaceName, 
               InterfaceName);

        //
        // Initialize lock to guard this interface
        //

        try
        {
            CREATE_READ_WRITE_LOCK(&Interface->InterfaceLock);

            LockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetLastError();

                Trace1(ANY,
                       "AddInterface: Failed to create read/write lock %x",
                       Status);

                LOGERR0(CREATE_RWL_FAILED, Status);

                break;
            }

        Interface->Flags = InterfaceType;

        Interface->State = InterfaceConfig->QosState;

        Interface->NumFlows = 0;

        InitializeListHead(&Interface->FlowList);

        //
        // Fill in the TC information for this IF
        //

        QosmOpenTcInterface(Interface);

        //
        // Update state to reflect the intf config 
        //

        Status = QosmSetInterfaceInfo(Interface,
                                      InterfaceConfig,
                                      InfoSize);

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Insert interface on sorted global list
        //

        InsertTailList(p, &Interface->ListByIndexLE);

        Globals.NumIfs++;
    }
    while (FALSE);

    RELEASE_GLOBALS_WRITE_LOCK();

    if (Status != NO_ERROR)
    {
        //
        // Some error occurred - clean up and return
        //

        if (Interface->TciIfHandle)
        {
            TcCloseInterface(Interface->TciIfHandle);
        }

        if (LockInited)
        {
            DELETE_READ_WRITE_LOCK(&Interface->InterfaceLock);
        }
    
        if (Interface)
        {
            FreeMemory(Interface);
        }
    }

    TraceLeave("AddInterface");

    return Status;
}


DWORD
WINAPI
DeleteInterface (
    IN      ULONG                          InterfaceIndex
    )
{
    PQOSMGR_INTERFACE_ENTRY Interface;
    PLIST_ENTRY             p;
    DWORD                   Status;

    TraceEnter("DeleteInterface");

    ACQUIRE_GLOBALS_WRITE_LOCK();

    do
    {
        //
        // Search for an interface with this index
        //

        for (p = Globals.IfList.Flink; 
             p != &Globals.IfList; 
             p = p->Flink)
        {
            Interface =
                CONTAINING_RECORD(p, QOSMGR_INTERFACE_ENTRY, ListByIndexLE);

            if (Interface->InterfaceIndex == InterfaceIndex)
            {
                break;
            }
        }

        if (p == &Globals.IfList)
        {
            Status = ERROR_NOT_FOUND;
            break;
        }

        //
        // Delete the interface from the global list
        //

        RemoveEntryList(&Interface->ListByIndexLE);

        Globals.NumIfs--;

        //
        // Free any handles associated with this if
        //

        if (Interface->TciIfHandle)
        {
            TcCloseInterface(Interface->TciIfHandle);
        }

        //
        // Free all memory allocated to the interface
        //

        DELETE_READ_WRITE_LOCK(&Interface->InterfaceLock);

        if (Interface->InterfaceConfig)
        {
            FreeMemory(Interface->InterfaceConfig);
        }

        FreeMemory(Interface);

        Status = NO_ERROR;
    }
    while (FALSE);

    RELEASE_GLOBALS_WRITE_LOCK();

    TraceLeave("DeleteInterface");

    return Status;
}


DWORD
WINAPI
InterfaceStatus (
    IN      ULONG                          InterfaceIndex,
    IN      BOOL                           InterfaceActive,
    IN      DWORD                          StatusType,
    IN      PVOID                          StatusInfo
    )
{
    TraceEnter("InterfaceStatus");
    TraceLeave("InterfaceStatus");

    return NO_ERROR;
}


DWORD
WINAPI
GetInterfaceInfo (
    IN      ULONG                          InterfaceIndex,
    IN      PVOID                          InterfaceInfo,
    IN OUT  PULONG                         BufferSize,
    OUT     PULONG                         InfoVer,
    OUT     PULONG                         InfoSize,
    OUT     PULONG                         InfoCnt
    )
{
    PQOSMGR_INTERFACE_ENTRY Interface;
    PLIST_ENTRY             p;
    DWORD                   Status;

    UNREFERENCED_PARAMETER(InfoVer);
    UNREFERENCED_PARAMETER(InfoCnt);

#if 1
    *InfoVer = *InfoCnt = 1;
#endif

    Trace3(ENTER, "GetInterfaceInfo: Index: %5u, Info: %p, Size: %08x",
                   InterfaceIndex,
                   InterfaceInfo, 
                   BufferSize);

    ACQUIRE_GLOBALS_READ_LOCK();

    do
    {
        //
        // Search for an interface with this index
        //

        for (p = Globals.IfList.Flink; 
             p != &Globals.IfList; 
             p = p->Flink)
        {
            Interface =
                CONTAINING_RECORD(p, QOSMGR_INTERFACE_ENTRY, ListByIndexLE);

            if (Interface->InterfaceIndex == InterfaceIndex)
            {
                break;
            }
        }

        if (p == &Globals.IfList)
        {
            Status = ERROR_NOT_FOUND;
            break;
        }

        //
        // Get the interface info from the interface
        //
        
        Status = QosmGetInterfaceInfo(Interface,
                                      InterfaceInfo,
                                      BufferSize,
                                      InfoSize);
    }
    while (FALSE);

    RELEASE_GLOBALS_READ_LOCK();

    Trace1(LEAVE, "GetInterfaceInfo: Returned %u", Status);

    return Status;
}


DWORD
WINAPI
SetInterfaceInfo (
    IN      ULONG                          InterfaceIndex,
    IN      PVOID                          InterfaceInfo,
    IN      ULONG                          InfoVer,
    IN      ULONG                          InfoSize,
    IN      ULONG                          InfoCnt
    )
{
    PQOSMGR_INTERFACE_ENTRY Interface;
    PLIST_ENTRY             p;
    DWORD                   Status;

    UNREFERENCED_PARAMETER(InfoVer);
    UNREFERENCED_PARAMETER(InfoCnt);

    Trace3(ENTER, "SetInterfaceInfo: Index: %5u, Info: %p, Size: %08x",
                   InterfaceIndex,
                   InterfaceInfo, 
                   InfoSize);

    ACQUIRE_GLOBALS_READ_LOCK();

    do
    {
        //
        // Search for an interface with this index
        //

        for (p = Globals.IfList.Flink; 
             p != &Globals.IfList; 
             p = p->Flink)
        {
            Interface =
                CONTAINING_RECORD(p, QOSMGR_INTERFACE_ENTRY, ListByIndexLE);

            if (Interface->InterfaceIndex == InterfaceIndex)
            {
                break;
            }
        }

        if (p == &Globals.IfList)
        {
            Status = ERROR_NOT_FOUND;
            break;
        }

        //
        // Set the interface info on the interface
        //
        
        Status = QosmSetInterfaceInfo(Interface,
                                      InterfaceInfo,
                                      InfoSize);
    }
    while (FALSE);

    RELEASE_GLOBALS_READ_LOCK();

    Trace1(LEAVE, "SetInterfaceInfo: Returned %u", Status);

    return Status;
}

DWORD
WINAPI
GetEventMessage (
    OUT     ROUTING_PROTOCOL_EVENTS        *Event,
    OUT     MESSAGE                        *Result
    )
{
    TraceEnter("GetEventMessage");
    TraceLeave("GetEventMessage");

    return ERROR_NO_MORE_ITEMS;
}


DWORD
WINAPI
UpdateRoutes (
    IN      ULONG                          InterfaceIndex
    )
{
    TraceEnter("UpdateRoutes");
    TraceLeave("UpdateRoutes");

    return NO_ERROR;
}


DWORD
WINAPI
MibCreateEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData
    )
{
    TraceEnter("MibCreateEntry");
    TraceLeave("MibCreateEntry");

    return NO_ERROR;
}


DWORD
WINAPI
MibDeleteEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData
    )
{
    TraceEnter("MibDeleteEntry");
    TraceLeave("MibDeleteEntry");

    return NO_ERROR;
}


DWORD
WINAPI
MibGetEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData,
    OUT     PULONG                         OutputDataSize,
    OUT     PVOID                          OutputData
    )
{
    TraceEnter("MibGetEntry");
    TraceLeave("MibGetEntry");

    return ERROR_INVALID_PARAMETER;
}


DWORD
WINAPI
MibSetEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData
    )
{
    TraceEnter("MibSetEntry");
    TraceLeave("MibSetEntry");

    return NO_ERROR;
}


DWORD
WINAPI
MibGetFirstEntry (
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    )
{
    TraceEnter("MibGetFirstEntry");
    TraceLeave("MibGetFirstEntry");

    return ERROR_INVALID_PARAMETER;
}


DWORD
WINAPI
MibGetNextEntry (
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    )
{
    TraceEnter("MibGetNextEntry");
    TraceLeave("MibGetNextEntry");

    return NO_ERROR;
}


DWORD
WINAPI
MibSetTrapInfo (
    IN     HANDLE                          Event,
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    )
{
    TraceEnter("MibSetTrapInfo");
    TraceLeave("MibSetTrapInfo");

    return NO_ERROR;
}


DWORD
WINAPI
MibGetTrapInfo (
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    )
{
    TraceEnter("MibGetTrapInfo");
    TraceLeave("MibGetTrapInfo");

    return ERROR_NO_MORE_ITEMS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosminfo.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    qosminfo.c

Abstract:

    The file contains global and interface
    config functions for QOS Mgr protocol.

Revision History:

--*/

#include "pchqosm.h"

#pragma hdrstop

DWORD
WINAPI
QosmGetGlobalInfo (
    IN      PVOID                          GlobalInfo,
    IN OUT  PULONG                         BufferSize,
    OUT     PULONG                         InfoSize
    )

/*++
  
Routine Description:

    Returns the global config info for this protocol.

Arguments:

    See corr header file.

Return Value:
    
    Status of the operation
  
--*/

{
    PIPQOS_GLOBAL_CONFIG GlobalConfig;
    DWORD                Status;

    //
    // Validate all input params before reading the global info
    //

    if (BufferSize == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    ACQUIRE_GLOBALS_READ_LOCK();

    do
    {
        *InfoSize = Globals.ConfigSize;

        if ((*BufferSize < *InfoSize) || 
            (GlobalInfo == NULL))
        {
            //
            // Either the size was too small or there was no storage
            //

            Trace1(CONFIG, 
                   "GetGlobalInfo: Buffer size too small: %u",
                   *BufferSize);

            *BufferSize = *InfoSize;

            Status = ERROR_INSUFFICIENT_BUFFER;

            break;
        }

        *BufferSize = *InfoSize;

        GlobalConfig = (PIPQOS_GLOBAL_CONFIG) GlobalInfo;

        CopyMemory(GlobalConfig,
                   Globals.GlobalConfig,
                   *InfoSize);

        Status = NO_ERROR;
    }
    while (FALSE);

    RELEASE_GLOBALS_READ_LOCK();

    return Status;
}


DWORD
WINAPI
QosmSetGlobalInfo (
    IN      PVOID                          GlobalInfo,
    IN      ULONG                          InfoSize
    )

/*++
  
Routine Description:

    Sets the global config info for this protocol.

Arguments:

    See corr header file.

Return Value:
    
    Status of the operation
  
--*/

{
    PIPQOS_GLOBAL_CONFIG GlobalConfig;
    DWORD                Status;

    //
    // Update the global config information.
    //

    ACQUIRE_GLOBALS_WRITE_LOCK();

    do
    {
        GlobalConfig = AllocMemory(InfoSize);

        if (GlobalConfig == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Copy the new config information
        //

        CopyMemory(GlobalConfig, GlobalInfo, InfoSize);

        Globals.ConfigSize = InfoSize;

        //
        // Set up rest of the global state
        //

        if (GlobalConfig->LoggingLevel <= IPQOS_LOGGING_INFO)
        {
            Globals.LoggingLevel = GlobalConfig->LoggingLevel;
        }

        //
        // Cleanup old global information
        //

        if (Globals.GlobalConfig)
        {
            FreeMemory(Globals.GlobalConfig);
        }

        Globals.GlobalConfig = GlobalConfig;

        Status = NO_ERROR;
    }
    while (FALSE);

    RELEASE_GLOBALS_WRITE_LOCK();

    return Status;
}

DWORD
WINAPI
QosmGetInterfaceInfo (
    IN      QOSMGR_INTERFACE_ENTRY        *Interface,
    IN      PVOID                          InterfaceInfo,
    IN OUT  PULONG                         BufferSize,
    OUT     PULONG                         InfoSize
    )

/*++
  
Routine Description:

    Gets the inteface config info for this protocol
    for this interface.

Arguments:

    See corr header file.

Return Value:
    
    Status of the operation

--*/

{
    PIPQOS_IF_CONFIG InterfaceConfig;
    DWORD            Status;

    //
    // Validate all input params before reading interface info
    //

    if (BufferSize == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    ACQUIRE_INTERFACE_READ_LOCK(Interface);

    do
    {
        *InfoSize = Interface->ConfigSize;

        if ((*BufferSize < *InfoSize) || 
            (InterfaceInfo == NULL))
        {
            //
            // Either the size was too small or there was no storage
            //

            Trace1(CONFIG, 
                   "GetInterfaceInfo: Buffer size too small: %u",
                   *BufferSize);

            *BufferSize = *InfoSize;

            Status = ERROR_INSUFFICIENT_BUFFER;

            break;
        }

        *BufferSize = *InfoSize;

        InterfaceConfig = (PIPQOS_IF_CONFIG) InterfaceInfo;

        CopyMemory(InterfaceConfig,
                   Interface->InterfaceConfig,
                   *InfoSize);

        Status = NO_ERROR;
    }
    while (FALSE);

    RELEASE_INTERFACE_READ_LOCK(Interface);

    return Status;
}

DWORD
WINAPI
QosmSetInterfaceInfo (
    IN      QOSMGR_INTERFACE_ENTRY        *Interface,
    IN      PVOID                          InterfaceInfo,
    IN      ULONG                          InfoSize
    )

/*++
  
Routine Description:

    Sets the interface config info for this protocol
    on this interface.

Arguments:

    See corr header file.

Return Value:
    
    Status of the operation
  
--*/

{
    PIPQOS_IF_CONFIG     InterfaceConfig;
    PIPQOS_IF_FLOW       FlowConfig;
    PQOSMGR_FLOW_ENTRY   Flow;
    UINT                 i;
    PLIST_ENTRY          p, q;
    PTC_GEN_FLOW         FlowInfo;
    ULONG                FlowSize;
    HANDLE               FlowHandle;
    DWORD                Status;

    //
    // Update the interface config information.
    //

    ACQUIRE_INTERFACE_WRITE_LOCK(Interface);

    do
    {
        //
        // Allocate memory to store new config
        //

        InterfaceConfig = AllocMemory(InfoSize);

        if (InterfaceConfig == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Copy the new config information
        //

        CopyMemory(InterfaceConfig, InterfaceInfo, InfoSize);

        Interface->ConfigSize = InfoSize;

        //
        // Set up rest of interface state
        //

        if (Interface->State != InterfaceConfig->QosState)
        {
            if (InterfaceConfig->QosState == IPQOS_STATE_DISABLED)
            {
                //
                // Disable all flows on this interface
                //

                ;
            }
            else
            {
                //
                // Renable all flows on this interface
                //

                ;
            }

            Interface->State = InterfaceConfig->QosState;
        }

        //
        // Update the flow information on if
        //

        //
        // First mark all flows as needing refresh
        //

        for (p = Interface->FlowList.Flink;
             p != &Interface->FlowList;
             p = p->Flink)
        {
            Flow = CONTAINING_RECORD(p, QOSMGR_FLOW_ENTRY, OnInterfaceLE);

            ASSERT(!(Flow->Flags & FLOW_FLAG_DELETE));

            Flow->Flags |= FLOW_FLAG_DELETE;
        }

        //
        // If we do not have an TC interface handle,
        // we delete all flows as they are obsolete
        //

        if (Interface->TciIfHandle)
        {
            //
            // Set each flow if it has changed from before
            //

            FlowConfig = IPQOS_GET_FIRST_FLOW_ON_IF(InterfaceConfig);

            for (i = 0; i < InterfaceConfig->NumFlows; i++)
            {
                //
                // Search for a flow with the same name
                //

                for (p = Interface->FlowList.Flink;
                     p != &Interface->FlowList;
                     p = p->Flink)
                {
                    Flow = 
                        CONTAINING_RECORD(p, QOSMGR_FLOW_ENTRY, OnInterfaceLE);

                    if (!_wcsicmp(Flow->FlowName, FlowConfig->FlowName))
                    {
                        break;
                    }
                }

                if (p == &Interface->FlowList)
                {
                    //
                    // No flow by this name - add new one
                    //

                    Flow = NULL;
                }

                //
                // Get a flow info from description
                //

                Status = GetFlowFromDescription(&FlowConfig->FlowDesc, 
                                                &FlowInfo, 
                                                &FlowSize);

                if (Status == NO_ERROR)
                {
                    do
                    {
                        if ((Flow) && 
                            (FlowSize == Flow->FlowSize) &&
                            (EqualMemory(FlowInfo, Flow->FlowInfo, FlowSize)))
                        {
                            //
                            // No change in the flow info yet,
                            // this flow still remains valid
                            //

                            Flow->Flags &= ~FLOW_FLAG_DELETE;

                            Status = ERROR_ALREADY_EXISTS;

                            break;
                        }

                        if (Flow)
                        {
                            //
                            // Flow info changed - modify flow
                            //

                            Status = TcModifyFlow(Flow->TciFlowHandle,
                                                  FlowInfo);

                            if (Status != NO_ERROR)
                            {
                                break;
                            }

                            Flow->Flags &= ~FLOW_FLAG_DELETE;

                            //
                            // Update cached flow info
                            //

                            FreeMemory(Flow->FlowInfo);
                            Flow->FlowInfo = FlowInfo;
                            Flow->FlowSize = FlowSize;
                        }
                        else
                        {
                            //
                            // Add the new flow using the TC API
                            //

                            Status = TcAddFlow(Interface->TciIfHandle,
                                               NULL,
                                               0,
                                               FlowInfo,
                                               &FlowHandle);

                            if (Status != NO_ERROR)
                            {
                                break;
                            }

                            //
                            // Addition of a new flow in TC
                            //

                            Flow = AllocMemory(sizeof(QOSMGR_FLOW_ENTRY));

                            if (Flow == NULL)
                            {
                                Status = TcDeleteFlow(FlowHandle);

                                ASSERT(Status);

                                Status = ERROR_NOT_ENOUGH_MEMORY;

                                break;
                            }

                            //
                            // Initialize flow and insert in list
                            //

                            Flow->TciFlowHandle = FlowHandle;

                            Flow->Flags = 0;

                            Flow->FlowInfo = FlowInfo;
                            Flow->FlowSize = FlowSize;

                            wcscpy(Flow->FlowName, FlowConfig->FlowName);

                            InsertTailList(p, &Flow->OnInterfaceLE);
                        }
                    }
                    while (FALSE);
                    
                    if (Status != NO_ERROR)
                    {
                        FreeMemory(FlowInfo);
                    }
                }

                //
                // Move to the next flow in config
                //

                FlowConfig = IPQOS_GET_NEXT_FLOW_ON_IF(FlowConfig);
            }
        }

        //
        // Cleanup all flows that are obsolete
        //

        for (p = Interface->FlowList.Flink;
             p != &Interface->FlowList; 
             p = q)
        {
            Flow = CONTAINING_RECORD(p, QOSMGR_FLOW_ENTRY, OnInterfaceLE);

            q = p->Flink;

            if (Flow->Flags & FLOW_FLAG_DELETE)
            {
                //
                // Delete the flow from the TC API
                //

                Status = TcDeleteFlow(Flow->TciFlowHandle);

                if (Status != NO_ERROR)
                {
                    Flow->Flags &= ~FLOW_FLAG_DELETE;

                    continue;
                }

                //
                // Remove flow from this flow list
                //

                RemoveEntryList(p);

                //
                // Free the flow and its resources
                //

                if (Flow->FlowInfo)
                {
                    FreeMemory(Flow->FlowInfo);
                }

                FreeMemory(Flow);
            }
        }

        //
        // Cleanup old interface information
        //

        if (Interface->InterfaceConfig)
        {
            FreeMemory(Interface->InterfaceConfig);
        }

        Interface->InterfaceConfig = InterfaceConfig;

        Status = NO_ERROR;
    }
    while (FALSE);

    RELEASE_INTERFACE_WRITE_LOCK(Interface);

    return Status;
}


DWORD
GetFlowFromDescription(
    IN      PIPQOS_NAMED_FLOW              FlowDesc,
    OUT     PTC_GEN_FLOW                  *FlowInfo,
    OUT     ULONG                         *FlowSize
    )
{    
    FLOWSPEC       *CurrFlowspec;
    FLOWSPEC        SendFlowspec;
    FLOWSPEC        RecvFlowspec;
    FLOWSPEC       *Flowspec;
    PTC_GEN_FLOW    Flow;
    QOS_OBJECT_HDR *QosObject;
    PWCHAR          FlowspecName;
    PWCHAR          QosObjectName;
    PUCHAR          CopyAtPtr;
    ULONG           ObjectsLength;
    ULONG           i;

#if 1
    //
    // Check for the existence of sending flowspec
    //

    if (FlowDesc->SendingFlowspecName[0] == L'\0')
    {
        return ERROR_INVALID_DATA;
    }
#endif

    //
    // Get the sending and receiving flowspecs
    //

    for (i = 0; i < 2; i++)
    {
        if (i)
        {
            FlowspecName = FlowDesc->RecvingFlowspecName;
            CurrFlowspec = &RecvFlowspec;
        }
        else
        {
            FlowspecName = FlowDesc->SendingFlowspecName;
            CurrFlowspec = &SendFlowspec;
        }

        FillMemory(CurrFlowspec, sizeof(FLOWSPEC), QOS_NOT_SPECIFIED);

        if (FlowspecName[0] != L'\0')
        {
            Flowspec = GetFlowspecFromGlobalConfig(FlowspecName);

            if (Flowspec == NULL)
            {
                return ERROR_INVALID_DATA;
            }

            *CurrFlowspec = *Flowspec;
        }
    }

    //
    // Calculate the size of the TC_GEN_FLOW block
    //

    QosObjectName = IPQOS_GET_FIRST_OBJECT_NAME_ON_NAMED_FLOW(FlowDesc);

    ObjectsLength = 0;

    for (i = 0; i < FlowDesc->NumTcObjects; i++)
    {
        //
        // Get object's description in global info
        //

        QosObject = GetQosObjectFromGlobalConfig(QosObjectName);

        if (QosObject == NULL)
        {
            //
            // Incomplete description
            //

            return ERROR_INVALID_DATA;
        }

        ObjectsLength += QosObject->ObjectLength;

        QosObjectName= IPQOS_GET_NEXT_OBJECT_NAME_ON_NAMED_FLOW(QosObjectName);
    }

    *FlowSize = FIELD_OFFSET(TC_GEN_FLOW, TcObjects) + ObjectsLength;

    *FlowInfo = Flow = AllocMemory(*FlowSize);

    if (Flow == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Fill in the flow information now
    //

    Flow->ReceivingFlowspec = RecvFlowspec;

    Flow->SendingFlowspec = SendFlowspec;

    Flow->TcObjectsLength = ObjectsLength;

    //
    // Repeat the loop above filling info
    //

    QosObjectName = IPQOS_GET_FIRST_OBJECT_NAME_ON_NAMED_FLOW(FlowDesc);

    CopyAtPtr = (PUCHAR) &Flow->TcObjects[0];

    for (i = 0; i < FlowDesc->NumTcObjects; i++)
    {
        //
        // Get object's description in global info
        //

        QosObject = GetQosObjectFromGlobalConfig(QosObjectName);

        // We just checked above for its existence
        ASSERT(QosObject != NULL);

        CopyMemory(CopyAtPtr,
                   QosObject, 
                   QosObject->ObjectLength);

        CopyAtPtr += QosObject->ObjectLength;

        QosObjectName= IPQOS_GET_NEXT_OBJECT_NAME_ON_NAMED_FLOW(QosObjectName);
    }

     return NO_ERROR;
}

FLOWSPEC *
GetFlowspecFromGlobalConfig(
    IN      PWCHAR                         FlowspecName
    )
{
    IPQOS_NAMED_FLOWSPEC *Flowspec;
    UINT                  i;

    Flowspec = IPQOS_GET_FIRST_FLOWSPEC_IN_CONFIG(Globals.GlobalConfig);

    for (i = 0; i < Globals.GlobalConfig->NumFlowspecs; i++)
    {
        if (!_wcsicmp(Flowspec->FlowspecName, FlowspecName))
        {
            break;
        }

        Flowspec = IPQOS_GET_NEXT_FLOWSPEC_IN_CONFIG(Flowspec);
    }

    if (i < Globals.GlobalConfig->NumFlowspecs)
    {
        return &Flowspec->FlowspecDesc;
    }

    return NULL;
}

QOS_OBJECT_HDR *
GetQosObjectFromGlobalConfig(
    IN      PWCHAR                         QosObjectName
    )
{
    IPQOS_NAMED_QOSOBJECT *QosObject;
    UINT                   i;

    QosObject = IPQOS_GET_FIRST_QOSOBJECT_IN_CONFIG(Globals.GlobalConfig);

    for (i = 0; i < Globals.GlobalConfig->NumQosObjects; i++)
    {
        if (!_wcsicmp(QosObject->QosObjectName, QosObjectName))
        {
            break;
        }

        QosObject = IPQOS_GET_NEXT_QOSOBJECT_IN_CONFIG(QosObject);
    }

    if (i < Globals.GlobalConfig->NumFlowspecs)
    {
        return &QosObject->QosObjectHdr;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmmain.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    qosmmain.h

Abstract:

    The file contains the global structure
    definitions for QOS Mgr protocol.

Revision History:

--*/

#ifndef __QOSMMAIN_H
#define __QOSMMAIN_H

//
// Global information for the QOS Mgr
//

#define IF_HASHTABLE_SIZE          16

typedef struct _QOSMGR_GLOBALS
{
    HANDLE            LoggingHandle;    // 
    ULONG             LoggingLevel;     // Handles to debugging functionality
    ULONG             TracingHandle;    //

    DWORD             TracingFlags;     // Flags that control debug tracing

    HANDLE            GlobalHeap;       // Handle to the private memory heap

                                        //
    HANDLE             NotificationEvnt;// Callbacks and events to interact 
    SUPPORT_FUNCTIONS  SupportFunctions;// with the router manager (See API)
                                        //

    READ_WRITE_LOCK   GlobalsLock;      // Lock protecting all the info below

    ULONG             ConfigSize;       // Number of bytes in global config

    PIPQOS_GLOBAL_CONFIG
                      GlobalConfig;     // Pointer to global configuration

    IPQOS_GLOBAL_STATS
                      GlobalStats;      // Global statistics

    ULONG             State;            // State of the QOS Mgr component

    HANDLE            TciHandle;        // Traffic Control Registration Handle

    ULONG             NumIfs;           // Num of Ifs on which QOS is active
    LIST_ENTRY        IfList;           // List of Ifs sorted by index    
}
QOSMGR_GLOBALS, *PQOSMGR_GLOBALS;


//
// Codes describing states of IPQOSMGR.
//

#define IPQOSMGR_STATE_STOPPED   0
#define IPQOSMGR_STATE_STARTING  1
#define IPQOSMGR_STATE_RUNNING   2
#define IPQOSMGR_STATE_STOPPING  3


//
// Per Interface Information for QOS Mgr
//
typedef struct _QOSMGR_INTERFACE_ENTRY
{
    LIST_ENTRY        ListByIndexLE;    // Linkage into index sorted list

    DWORD             InterfaceIndex;   // Interface index for this entry

    WCHAR             InterfaceName[MAX_STRING_LENGTH];
                                        // Router name for the interface

    READ_WRITE_LOCK   InterfaceLock;    // Lock protecting all info below

    DWORD             Flags;            // ACTIVE, MULTIACCESS ...

    DWORD             State;            // QOS Enabled or Disabled

    ULONG             ConfigSize;       // Num of bytes in interface config

    PIPQOS_IF_CONFIG  InterfaceConfig;  // Interface configuration

    IPQOS_IF_STATS    InterfaceStats;   // Interface statistics    

    HANDLE            TciIfHandle;      // Handle to corr. TC interface

    WCHAR             AlternateName[MAX_STRING_LENGTH];
                                        // Traffic Control name for 'if'

    ULONG             NumFlows;         // Number of flows configured on 'if'
    LIST_ENTRY        FlowList;         // List of configured flows on 'if'
} 
QOSMGR_INTERFACE_ENTRY, *PQOSMGR_INTERFACE_ENTRY;

#define IF_FLAG_ACTIVE      ((DWORD)0x00000001)
#define IF_FLAG_MULTIACCESS ((DWORD)0x00000002)

#define INTERFACE_IS_ACTIVE(i)              \
            ((i)->Flags & IF_FLAG_ACTIVE) 

#define INTERFACE_IS_INACTIVE(i)            \
            !INTERFACE_IS_ACTIVE(i)

#define INTERFACE_IS_MULTIACCESS(i)         \
            ((i)->Flags & IF_FLAG_MULTIACCESS) 

#define INTERFACE_IS_POINTTOPOINT(i)        \
            !INTERFACE_IS_MULTIACCESS(i)


//
// Per Flow Information in QOS Mgr
//

typedef struct _QOSMGR_FLOW_ENTRY
{
    LIST_ENTRY        OnInterfaceLE;    // Linkage into index sorted list

    HANDLE            TciFlowHandle;    // Handle to the flow in TC API

    DWORD             Flags;            // Flags for certain flow properties

    ULONG             FlowSize;         // Size of the flow's information
    PTC_GEN_FLOW      FlowInfo;         // Flow information - flowspecs etc.

    WCHAR             FlowName[MAX_STRING_LENGTH];
                                        // Router name for the diffserv flow
}
QOSMGR_FLOW_ENTRY, *PQOSMGR_FLOW_ENTRY;

#define FLOW_FLAG_DELETE ((DWORD)0x00000001)

//
// Global Extern Declarations
//
extern QOSMGR_GLOBALS Globals;


//
// Macros used in allocating and operating on memory
//
#define ZeroMemory             RtlZeroMemory
#define CopyMemory             RtlCopyMemory
#define FillMemory             RtlFillMemory
#define EqualMemory            RtlEqualMemory

#define AllocOnStack(nb)       _alloca((nb))

#define AllocMemory(nb)        HeapAlloc(Globals.GlobalHeap,     \
                                         0,                      \
                                         (nb))

#define ReallocMemory(nb)      HeapReAlloc(Globals.GlobalHeap,   \
                                         0,                      \
                                         (nb))

#define AllocNZeroMemory(nb)   HeapAlloc(Globals.GlobalHeap,     \
                                         HEAP_ZERO_MEMORY,       \
                                         (nb))

#define FreeMemory(ptr)        HeapFree(Globals.GlobalHeap,      \
                                        0,                       \
                                        (ptr))

#define FreeNotNullMemory(ptr)  {                                \
                                  if (!(ptr)) FreeMemory((ptr)); \
                                }
//
// Prototypes relating to global lock management
//

#define ACQUIRE_GLOBALS_READ_LOCK()                              \
    ACQUIRE_READ_LOCK(&Globals.GlobalsLock)

#define RELEASE_GLOBALS_READ_LOCK()                              \
    RELEASE_READ_LOCK(&Globals.GlobalsLock)

#define ACQUIRE_GLOBALS_WRITE_LOCK()                             \
    ACQUIRE_WRITE_LOCK(&Globals.GlobalsLock)

#define RELEASE_GLOBALS_WRITE_LOCK()                             \
    RELEASE_WRITE_LOCK(&Globals.GlobalsLock)

//
// Prototypes relating to interface lock management
//

#define ACQUIRE_INTERFACE_READ_LOCK(Interface)                   \
    ACQUIRE_READ_LOCK(&Interface->InterfaceLock)

#define RELEASE_INTERFACE_READ_LOCK(Interface)                   \
    RELEASE_READ_LOCK(&Interface->InterfaceLock)

#define ACQUIRE_INTERFACE_WRITE_LOCK(Interface)                  \
    ACQUIRE_WRITE_LOCK(&Interface->InterfaceLock)

#define RELEASE_INTERFACE_WRITE_LOCK(Interface)                  \
    RELEASE_WRITE_LOCK(&Interface->InterfaceLock)

//
// Prototypes relating to DLL startup, cleanup
//

BOOL
QosmDllStartup(
    VOID
    );

BOOL
QosmDllCleanup(
    VOID
    );


//
// Prototypes for router manager interface
//

DWORD
APIENTRY
RegisterProtocol(
    IN OUT  PMPR_ROUTING_CHARACTERISTICS    RoutingChar,
    IN OUT  PMPR_SERVICE_CHARACTERISTICS    ServiceChar
    );

DWORD
WINAPI
StartProtocol (
    IN      HANDLE                          NotificationEvent,
    IN      PSUPPORT_FUNCTIONS              SupportFunctions,
    IN      LPVOID                          GlobalInfo,
    IN      ULONG                           StructureVersion,
    IN      ULONG                           StructureSize,
    IN      ULONG                           StructureCount
    );

DWORD
WINAPI
StartComplete (
    VOID
    );

DWORD
WINAPI
StopProtocol (
    VOID
    );

DWORD
WINAPI
GetGlobalInfo (
    IN      PVOID                           GlobalInfo,
    IN OUT  PULONG                          BufferSize,
    OUT     PULONG                          StructureVersion,
    OUT     PULONG                          StructureSize,
    OUT     PULONG                          StructureCount
    );

DWORD
WINAPI
SetGlobalInfo (
    IN      PVOID                           GlobalInfo,
    IN      ULONG                           StructureVersion,
    IN      ULONG                           StructureSize,
    IN      ULONG                           StructureCount
    );

DWORD
WINAPI
AddInterface (
    IN      LPWSTR                         InterfaceName,
    IN      ULONG                          InterfaceIndex,
    IN      NET_INTERFACE_TYPE             InterfaceType,
    IN      DWORD                          MediaType,
    IN      WORD                           AccessType,
    IN      WORD                           ConnectionType,
    IN      PVOID                          InterfaceInfo,
    IN      ULONG                          StructureVersion,
    IN      ULONG                          StructureSize,
    IN      ULONG                          StructureCount
    );

DWORD
WINAPI
DeleteInterface (
    IN      ULONG                          InterfaceIndex
    );

DWORD
WINAPI
InterfaceStatus (
    IN      ULONG                          InterfaceIndex,
    IN      BOOL                           InterfaceActive,
    IN      DWORD                          StatusType,
    IN      PVOID                          StatusInfo
    );

DWORD
WINAPI
GetInterfaceInfo (
    IN      ULONG                          InterfaceIndex,
    IN      PVOID                          InterfaceInfo,
    IN  OUT PULONG                         BufferSize,
    OUT     PULONG                         StructureVersion,
    OUT     PULONG                         StructureSize,
    OUT     PULONG                         StructureCount
    );

DWORD
WINAPI
SetInterfaceInfo (
    IN      ULONG                          InterfaceIndex,
    IN      PVOID                          InterfaceInfo,
    IN      ULONG                          StructureVersion,
    IN      ULONG                          StructureSize,
    IN      ULONG                          StructureCount
    );

DWORD
WINAPI
GetEventMessage (
    OUT     ROUTING_PROTOCOL_EVENTS        *Event,
    OUT     MESSAGE                        *Result
    );

DWORD
WINAPI
UpdateRoutes (
    IN      ULONG                          InterfaceIndex
    );

DWORD
WINAPI
MibCreateEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData
    );

DWORD
WINAPI
MibDeleteEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData
    );

DWORD
WINAPI
MibGetEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData,
    OUT     PULONG                         OutputDataSize,
    OUT     PVOID                          OutputData
    );

DWORD
WINAPI
MibSetEntry (
    IN      ULONG                          InputDataSize,
    IN      PVOID                          InputData
    );

DWORD
WINAPI
MibGetFirstEntry (
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    );

DWORD
WINAPI
MibGetNextEntry (
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    );

DWORD
WINAPI
MibSetTrapInfo (
    IN     HANDLE                          Event,
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    );

DWORD
WINAPI
MibGetTrapInfo (
    IN     ULONG                           InputDataSize,
    IN     PVOID                           InputData,
    OUT    PULONG                          OutputDataSize,
    OUT    PVOID                           OutputData
    );

//
// Helper functions to operate on info blocks
//

DWORD
WINAPI
QosmGetGlobalInfo (
    IN      PVOID                          GlobalInfo,
    IN OUT  PULONG                         BufferSize,
    OUT     PULONG                         InfoSize
    );

DWORD
WINAPI
QosmSetGlobalInfo (
    IN      PVOID                          GlobalInfo,
    IN      ULONG                          InfoSize
    );

DWORD
WINAPI
QosmGetInterfaceInfo (
    IN      QOSMGR_INTERFACE_ENTRY        *Interface,
    IN      PVOID                          InterfaceInfo,
    IN OUT  PULONG                         BufferSize,
    OUT     PULONG                         InfoSize
    );

DWORD
WINAPI
QosmSetInterfaceInfo (
    IN      QOSMGR_INTERFACE_ENTRY        *Interface,
    IN      PVOID                          InterfaceInfo,
    IN      ULONG                          InfoSize
    );

//
// Prototypes relating to TC functionality
//

VOID 
TcNotifyHandler(
    IN      HANDLE                         ClRegCtx,
    IN      HANDLE                         ClIfcCtx,
    IN      ULONG                          Event,
    IN      HANDLE                         SubCode,
    IN      ULONG                          BufSize,
    IN      PVOID                          Buffer
    );

DWORD
QosmOpenTcInterface(
    IN      PQOSMGR_INTERFACE_ENTRY        Interface
    );

DWORD
GetFlowFromDescription(
    IN      PIPQOS_NAMED_FLOW              FlowDesc,
    OUT     PTC_GEN_FLOW                  *FlowInfo,
    OUT     ULONG                         *FlowSize
    );

FLOWSPEC *
GetFlowspecFromGlobalConfig(
    IN      PWCHAR                         FlowspecName
    );

QOS_OBJECT_HDR *
GetQosObjectFromGlobalConfig(
    IN      PWCHAR                         QosObjectName
    );

#endif // __QOSMMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmdbg.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    qosmdbg.h

Abstract:
    Debugging in QOS Mgr Protocol DLL

Revision History:

--*/

#ifndef __QOSMDBG_H__
#define __QOSMDBG_H__

//
// Bypass the system assert
//

#ifdef  ASSERT
#undef  ASSERT
#endif 
#define ASSERT(a)               { if ((a) == FALSE) DbgBreakPoint(); }

//
// Constants used for tracing
//

#define QOSM_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define QOSM_TRACE_ERR             ((DWORD)0x00010000 | TRACE_USE_MASK)
#define QOSM_TRACE_ENTER           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define QOSM_TRACE_LEAVE           ((DWORD)0x00040000 | TRACE_USE_MASK)
#define QOSM_TRACE_LOCK            ((DWORD)0x00080000 | TRACE_USE_MASK)
#define QOSM_TRACE_REFS            ((DWORD)0x00100000 | TRACE_USE_MASK)
#define QOSM_TRACE_HANDLE          ((DWORD)0x00200000 | TRACE_USE_MASK)
#define QOSM_TRACE_MEMORY          ((DWORD)0x00400000 | TRACE_USE_MASK)
#define QOSM_TRACE_START           ((DWORD)0x00800000 | TRACE_USE_MASK)
#define QOSM_TRACE_STOP            ((DWORD)0x01000000 | TRACE_USE_MASK)
#define QOSM_TRACE_CONFIG          ((DWORD)0x02000000 | TRACE_USE_MASK)
#define QOSM_TRACE_FLOW            ((DWORD)0x04000000 | TRACE_USE_MASK)
#define QOSM_TRACE_QUERY           ((DWORD)0x08000000 | TRACE_USE_MASK)
#define QOSM_TRACE_ENUM            ((DWORD)0x10000000 | TRACE_USE_MASK)
#define QOSM_TRACE_NOTIFY          ((DWORD)0x20000000 | TRACE_USE_MASK)
#define QOSM_TRACE_TIMER           ((DWORD)0x40080000 | TRACE_USE_MASK)
#define QOSM_TRACE_CALLBACK        ((DWORD)0x80000000 | TRACE_USE_MASK)

//
// Macros used for tracing 
//

#define TRACEHANDLE         Globals.TracingHandle

#define START_TRACING()     TRACEHANDLE = TraceRegister("QOSM")
            
#define STOP_TRACING()      TraceDeregister(TRACEHANDLE)

#define Trace0(l,a)             \
            TracePrintfEx(TRACEHANDLE, QOSM_TRACE_ ## l, a)
#define Trace1(l,a,b)           \
            TracePrintfEx(TRACEHANDLE, QOSM_TRACE_ ## l, a, b)
#define Trace2(l,a,b,c)         \
            TracePrintfEx(TRACEHANDLE, QOSM_TRACE_ ## l, a, b, c)
#define Trace3(l,a,b,c,d)       \
            TracePrintfEx(TRACEHANDLE, QOSM_TRACE_ ## l, a, b, c, d)
#define Trace4(l,a,b,c,d,e)     \
            TracePrintfEx(TRACEHANDLE, QOSM_TRACE_ ## l, a, b, c, d, e)
#define Trace5(l,a,b,c,d,e,f)   \
            TracePrintfEx(TRACEHANDLE, QOSM_TRACE_ ## l, a, b, c, d, e, f)
#define Trace6(l,a,b,c,d,e,f,g) \
            TracePrintfEx(TRACEHANDLE, QOSM_TRACE_ ## l, a, b, c, d, e, f, g)

#define Tracedump(l,a,b,c)      \
            TraceDumpEx(TRACEHANDLE,l,a,b,c,TRUE)

#if DBG_CAL

#define TraceEnter(X)    Trace0(ENTER, "Entered: "X)
#define TraceLeave(X)    Trace0(LEAVE, "Leaving: "X"\n")

#else

#define TraceEnter(X)
#define TraceLeave(X)

#endif

//
// Constants used in logging
//

#define QOSM_LOGGING_NONE      0
#define QOSM_LOGGING_ERROR     1
#define QOSM_LOGGING_WARN      2
#define QOSM_LOGGING_INFO      3

//
// Event logging macros
//

#define LOGHANDLE       Globals.LoggingHandle
#define LOGLEVEL        Globals.LoggingLevel
#define LOGERR          RouterLogError
#define LOGWARN         RouterLogWarning
#define LOGINFO         RouterLogInformation
#define LOGWARNDATA     RouterLogWarningData

//
// Error logging
//
#define START_LOGGING()     LOGHANDLE = RouterLogRegister("QOSM")

#define STOP_LOGGING()      RouterLogDeregister(LOGHANDLE)

#define LOGERR0(msg,err) \
        if (LOGLEVEL >= QOSM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,QOSMLOG_ ## msg,0,NULL,(err))
#define LOGERR1(msg,a,err) \
        if (LOGLEVEL >= QOSM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,QOSMLOG_ ## msg,1,&(a),(err))
#define LOGERR2(msg,a,b,err) \
        if (LOGLEVEL >= QOSM_LOGGING_ERROR) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGERR(LOGHANDLE,QOSMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGERR3(msg,a,b,c,err) \
        if (LOGLEVEL >= QOSM_LOGGING_ERROR) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGERR(LOGHANDLE,QOSMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGERR4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= QOSM_LOGGING_ERROR) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGERR(LOGHANDLE,QOSMLOG_ ## msg,4,_asz,(err)); \
        }


//
// Warning logging
//

#define LOGWARN0(msg,err) \
        if (LOGLEVEL >= QOSM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,QOSMLOG_ ## msg,0,NULL,(err))
#define LOGWARN1(msg,a,err) \
        if (LOGLEVEL >= QOSM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,QOSMLOG_ ## msg,1,&(a),(err))
#define LOGWARN2(msg,a,b,err) \
        if (LOGLEVEL >= QOSM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARN(LOGHANDLE,QOSMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGWARN3(msg,a,b,c,err) \
        if (LOGLEVEL >= QOSM_LOGGING_WARN) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGWARN(LOGHANDLE,QOSMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGWARN4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= QOSM_LOGGING_WARN) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGWARN(LOGHANDLE,QOSMLOG_ ## msg,4,_asz,(err)); \
        }

#define LOGWARNDATA2(msg,a,b,dw,buf) \
        if (LOGLEVEL >= QOSM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARNDATA(LOGHANDLE,QOSMLOG_ ## msg,2,_asz,(dw),(buf)); \
        }


//
// Information logging
//

#define LOGINFO0(msg,err) \
        if (LOGLEVEL >= QOSM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,QOSMLOG_ ## msg,0,NULL,(err))
#define LOGINFO1(msg,a,err) \
        if (LOGLEVEL >= QOSM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,QOSMLOG_ ## msg,1,&(a),(err))
#define LOGINFO2(msg,a,b,err) \
        if (LOGLEVEL >= QOSM_LOGGING_INFO) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGINFO(LOGHANDLE,QOSMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGINFO3(msg,a,b,c,err) \
        if (LOGLEVEL >= QOSM_LOGGING_INFO) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGINFO(LOGHANDLE,QOSMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGINFO4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= QOSM_LOGGING_INFO) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGINFO(LOGHANDLE,QOSMLOG_ ## msg,4,_asz,(err)); \
        }

//
// Misc Debugging Macros
//

#define IPADDR_FORMAT(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

#define TracePrintAddress(ID, Dest, Mask)                   \
{                                                           \
    Trace2(ID, "Dest: %d.%d.%d.%d Mask: %d.%d.%d.%d",       \
           IPADDR_FORMAT(Dest),                             \
           IPADDR_FORMAT(Mask));                            \
}

#endif // __QOSMDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmdsrv.c ===
/*++

Copyright 1997 - 98, Microsoft Corporation

Module Name:

    qosmdsrv.c

Abstract:

    Contains routines that are invoked by
    the QosMgr DLL to control diffserv.

Revision History:

--*/

#include "pchqosm.h"

#pragma hdrstop

//
// Traffic Control Handlers/Functionality
//

VOID 
TcNotifyHandler(
    IN      HANDLE                         ClRegCtx,
    IN      HANDLE                         ClIfcCtx,
    IN      ULONG                          Event,
    IN      HANDLE                         SubCode,
    IN      ULONG                          BufSize,
    IN      PVOID                          Buffer
    )
{
    PQOSMGR_INTERFACE_ENTRY Interface;
    PLIST_ENTRY             p;

    switch (Event)
    {
    case TC_NOTIFY_IFC_UP:

        //
        // New interface - check if we have this interface
        //

        break;

    case TC_NOTIFY_IFC_CLOSE:

        //
        // An existing interface has been closed by system
        //

        ACQUIRE_GLOBALS_READ_LOCK();

        do
        {
            //
            // Make sure that the interface still exists on list
            //

            for (p = Globals.IfList.Flink; 
                 p != &Globals.IfList; 
                 p = p->Flink)
            {
                Interface =
                   CONTAINING_RECORD(p, QOSMGR_INTERFACE_ENTRY, ListByIndexLE);

                if (Interface == ClIfcCtx)
                {
                    break;
                }
            }

            if (p == &Globals.IfList)
            {
                //
                // Must have been deleted in a parallel thread
                //

                break;
            }

            ACQUIRE_INTERFACE_WRITE_LOCK(Interface);

            Interface->TciIfHandle = NULL;

            //
            // This call would result in invalidating all flows
            // in the list as TciIfHandle is set to NULL above
            //

            QosmSetInterfaceInfo(Interface,
                                 Interface->InterfaceConfig,
                                 Interface->ConfigSize);

            RELEASE_INTERFACE_WRITE_LOCK(Interface);
        }
        while (FALSE);

        RELEASE_GLOBALS_READ_LOCK();

        break;
    }

    return;
}

DWORD
QosmOpenTcInterface(
    IN      PQOSMGR_INTERFACE_ENTRY        Interface
    )
{
    PTC_IFC_DESCRIPTOR CurrInterface;
    PTC_IFC_DESCRIPTOR Buffer;
    DWORD              BufferSize;
    DWORD              Status;

    //
    // First enumerate all interfaces and
    // get a interface with matching name
    //

    BufferSize = 0;

    Buffer = NULL;

    do
    {
        if (BufferSize)
        {
            //
            // Try to increase the buffer size
            //

            if (Buffer)
            {
                FreeMemory(Buffer);
            }

            Buffer = AllocMemory(BufferSize);

            if (!Buffer)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }

        Status = TcEnumerateInterfaces(Globals.TciHandle,
                                       &BufferSize,
                                       Buffer);
    }
    while (Status == ERROR_INSUFFICIENT_BUFFER);

    if (Status == NO_ERROR)
    {
        Status = ERROR_NOT_FOUND;

        //
        // Find the QOS interface with matching GUID
        //

        CurrInterface = Buffer;

        while (BufferSize > 0)
        {
            if (!_wcsicmp(CurrInterface->pInterfaceID,
                          Interface->InterfaceName))
            {
                // Found the interface - copy qos name

                wcscpy(Interface->AlternateName,
                       CurrInterface->pInterfaceName);

                // Open the interface and cache handle

                Status = TcOpenInterfaceW(Interface->AlternateName,
                                          Globals.TciHandle,
                                          Interface,
                                          &Interface->TciIfHandle);
                break;
            }

            BufferSize -= CurrInterface->Length;

            (PUCHAR) CurrInterface += CurrInterface->Length;
        }
    }

    if (Buffer)
    {
        FreeMemory(Buffer);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmmsg.h ===
//
// Net error file for basename QOSMLOG_BASE = 43000
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: QOSMLOG_INIT_CRITSEC_FAILED
//
// MessageText:
//
//  QOSMGR was unable to initialize a critical section.
//  The data is the exception code.
//
#define QOSMLOG_INIT_CRITSEC_FAILED      0x0000A7F9L

//
// MessageId: QOSMLOG_CREATE_SEMAPHORE_FAILED
//
// MessageText:
//
//  QOSMGR was unable to create a semaphore.
//  The data is the error code.
//
#define QOSMLOG_CREATE_SEMAPHORE_FAILED  0x0000A7FAL

//
// MessageId: QOSMLOG_CREATE_EVENT_FAILED
//
// MessageText:
//
//  QOSMGR was unable to create an event.
//  The data is the error code.
//
#define QOSMLOG_CREATE_EVENT_FAILED      0x0000A7FBL

//
// MessageId: QOSMLOG_CREATE_RWL_FAILED
//
// MessageText:
//
//  QOSMGR was unable to create a synchronization object.
//  The data is the error code.
//
#define QOSMLOG_CREATE_RWL_FAILED        0x0000A7FCL

//
// MessageId: QOSMLOG_HEAP_CREATE_FAILED
//
// MessageText:
//
//  QOSMGR was unable to create a heap.
//  The data is the error code.
//
#define QOSMLOG_HEAP_CREATE_FAILED       0x0000A7FDL

//
// MessageId: QOSMLOG_HEAP_ALLOC_FAILED
//
// MessageText:
//
//  QOSMGR was unable to allocate memory from its heap.
//  The data is the error code.
//
#define QOSMLOG_HEAP_ALLOC_FAILED        0x0000A7FEL

//
// MessageId: QOSMLOG_CREATE_THREAD_FAILED
//
// MessageText:
//
//  QOSMGR was unable to create a thread.
//  The data is the error code.
//
#define QOSMLOG_CREATE_THREAD_FAILED     0x0000A7FFL

//
// MessageId: QOSMLOG_WSASTARTUP_FAILED
//
// MessageText:
//
//  QOSMGR was unable to start Windows Sockets.
//  The data is the error code.
//
#define QOSMLOG_WSASTARTUP_FAILED        0x0000A800L

//
// MessageId: QOSMLOG_CREATE_SOCKET_FAILED
//
// MessageText:
//
//  QOSMGR was unable to create a socket.
//  The data is the error code.
//
#define QOSMLOG_CREATE_SOCKET_FAILED     0x0000A801L

//
// MessageId: QOSMLOG_BIND_IF_FAILED
//
// MessageText:
//
//  QOSMGR could not bind to IP address %1.
//  Please make sure TCP/IP is installed and configured correctly.
//  The data is the error code.
//
#define QOSMLOG_BIND_IF_FAILED           0x0000A802L

//
// MessageId: QOSMLOG_RECVFROM_FAILED
//
// MessageText:
//
//  QOSMGR was unable to receive an incoming message
//  on the local interface with IP address %1.
//  The data is the error code.
//
#define QOSMLOG_RECVFROM_FAILED          0x0000A803L

//
// MessageId: QOSMLOG_SENDTO_FAILED
//
// MessageText:
//
//  QOSMGR was unable to send a packet from the interface with IP address %1
//  to the IP address %2.
//  The data is the error code.
//
#define QOSMLOG_SENDTO_FAILED            0x0000A804L

//
// MessageId: QOSMLOG_SET_MCAST_IF_FAILED
//
// MessageText:
//
//  QOSMGR could not request multicasting on the local interface
//  with IP address %1.
//  The data is the error code.
//
#define QOSMLOG_SET_MCAST_IF_FAILED      0x0000A805L

//
// MessageId: QOSMLOG_JOIN_GROUP_FAILED
//
// MessageText:
//
//  QOSMGR could not join the multicast group 224.0.0.9
//  on the local interface with IP address %1.
//  The data is the error code.
//
#define QOSMLOG_JOIN_GROUP_FAILED        0x0000A806L

//
// MessageId: QOSMLOG_QOSMGR_STARTED
//
// MessageText:
//
//  QOSMGR has started successfully.
//
#define QOSMLOG_QOSMGR_STARTED           0x0000A807L

//
// MessageId: QOSMLOG_QOSMGR_ALREADY_STARTED
//
// MessageText:
//
//  QOSMGR received a start request when it was already running.
//
#define QOSMLOG_QOSMGR_ALREADY_STARTED   0x0000A808L

//
// MessageId: QOSMLOG_RTM_REGISTER_FAILED
//
// MessageText:
//
//  IPRIPv2 was unable to register with the Routing Table Manager.
//  The data is the error code.
//
#define QOSMLOG_RTM_REGISTER_FAILED      0x0000A809L

//
// MessageId: QOSMLOG_QOSMGR_STOPPED
//
// MessageText:
//
//  QOSMGR has stopped.
//
#define QOSMLOG_QOSMGR_STOPPED           0x0000A80AL

//
// MessageId: QOSMLOG_NETWORK_MODULE_ERROR
//
// MessageText:
//
//  QOSMGR encountered a problem in the Network Module.
//  The data is the error code.
//
#define QOSMLOG_NETWORK_MODULE_ERROR     0x0000A80BL

//
// MessageId: QOSMLOG_PACKET_TOO_SMALL
//
// MessageText:
//
//  QOSMGR received a packet which was smaller than the minimum size
//  allowed for QOSMGR packets. The packet has been discarded.
//  It was received on the local interface with IP address %1,
//  and it came from the neighboring router with IP address %2.
//
#define QOSMLOG_PACKET_TOO_SMALL         0x0000A80CL

//
// MessageId: QOSMLOG_PACKET_HEADER_CORRUPT
//
// MessageText:
//
//  QOSMGR received a packet with an invalid header. The packet has been
//  discarded. It was received on the local interface with IP address %1,
//  and it came from the neighboring router with IP address %2.
//
#define QOSMLOG_PACKET_HEADER_CORRUPT    0x0000A80DL

//
// MessageId: QOSMLOG_PACKET_VERSION_INVALID
//
// MessageText:
//
//  QOSMGR received a packet with an invalid version in its header.
//  The packet has been discarded. It was received on the local interface
//  with IP address %1, and it came from the neighboring router
//  with IP address %2.
//
#define QOSMLOG_PACKET_VERSION_INVALID   0x0000A80EL

//
// MessageId: QOSMLOG_TIMER_MODULE_ERROR
//
// MessageText:
//
//  QOSMGR encountered a problem in the Timer Module.
//  The data is the error code.
//
#define QOSMLOG_TIMER_MODULE_ERROR       0x0000A80FL

//
// MessageId: QOSMLOG_PROTOCOL_MODULE_ERROR
//
// MessageText:
//
//  QOSMGR encountered a problem in the Protocol Module.
//  The data is the error code.
//
#define QOSMLOG_PROTOCOL_MODULE_ERROR    0x0000A810L

//
// MessageId: QOSMLOG_TC_REGISTER_FAILED
//
// MessageText:
//
//  QOSMGR could not register with the traffic control API.
//  The data is the error code.
//
#define QOSMLOG_TC_REGISTER_FAILED       0x0000A811L

//
// MessageId: QOSMLOG_TC_DEREGISTER_FAILED
//
// MessageText:
//
//  QOSMGR could not deregister with the traffic control API.
//  The data is the error code.
//
#define QOSMLOG_TC_DEREGISTER_FAILED     0x0000A812L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmlog.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    qosmlog.h

Abstract:

    This file is processed by mapmsg to produce a .mc file,
    then the .mc file is compiled by the message compiler,
    and the resulting binary is included in QOSMGR's resource file.

    Don't change the comments following the manifest constants
    without understanding how mapmsg works.

Revision History:

--*/

#define QOSMLOG_BASE                          43000

#define QOSMLOG_INIT_CRITSEC_FAILED           (QOSMLOG_BASE + 1)
/*
 * QOSMGR was unable to initialize a critical section.
 * The data is the exception code.
 */

#define QOSMLOG_CREATE_SEMAPHORE_FAILED       (QOSMLOG_BASE + 2)
/*
 * QOSMGR was unable to create a semaphore.
 * The data is the error code.
 */

#define QOSMLOG_CREATE_EVENT_FAILED           (QOSMLOG_BASE + 3)
/*
 * QOSMGR was unable to create an event.
 * The data is the error code.
 */

#define QOSMLOG_CREATE_RWL_FAILED             (QOSMLOG_BASE + 4)
/*
 * QOSMGR was unable to create a synchronization object.
 * The data is the error code.
 */



#define QOSMLOG_HEAP_CREATE_FAILED            (QOSMLOG_BASE + 5)
/*
 * QOSMGR was unable to create a heap.
 * The data is the error code.
 */

#define QOSMLOG_HEAP_ALLOC_FAILED             (QOSMLOG_BASE + 6)
/*
 * QOSMGR was unable to allocate memory from its heap.
 * The data is the error code.
 */



#define QOSMLOG_CREATE_THREAD_FAILED          (QOSMLOG_BASE + 7)
/*
 * QOSMGR was unable to create a thread.
 * The data is the error code.
 */



#define QOSMLOG_WSASTARTUP_FAILED             (QOSMLOG_BASE + 8)
/*
 * QOSMGR was unable to start Windows Sockets.
 * The data is the error code.
 */

#define QOSMLOG_CREATE_SOCKET_FAILED          (QOSMLOG_BASE + 9)
/*
 * QOSMGR was unable to create a socket.
 * The data is the error code.
 */

#define QOSMLOG_BIND_IF_FAILED                (QOSMLOG_BASE + 10)
/*
 * QOSMGR could not bind to IP address %1.
 * Please make sure TCP/IP is installed and configured correctly.
 * The data is the error code.
 */

#define QOSMLOG_RECVFROM_FAILED               (QOSMLOG_BASE + 11)
/*
 * QOSMGR was unable to receive an incoming message
 * on the local interface with IP address %1.
 * The data is the error code.
 */

#define QOSMLOG_SENDTO_FAILED                 (QOSMLOG_BASE + 12)
/*
 * QOSMGR was unable to send a packet from the interface with IP address %1
 * to the IP address %2.
 * The data is the error code.
 */

#define QOSMLOG_SET_MCAST_IF_FAILED           (QOSMLOG_BASE + 13)
/*
 * QOSMGR could not request multicasting on the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define QOSMLOG_JOIN_GROUP_FAILED             (QOSMLOG_BASE + 14)
/*
 * QOSMGR could not join the multicast group 224.0.0.9
 * on the local interface with IP address %1.
 * The data is the error code.
 */



#define QOSMLOG_QOSMGR_STARTED                (QOSMLOG_BASE + 15)
/*
 * QOSMGR has started successfully.
 */

#define QOSMLOG_QOSMGR_ALREADY_STARTED        (QOSMLOG_BASE + 16)
/*
 * QOSMGR received a start request when it was already running.
 */

#define QOSMLOG_RTM_REGISTER_FAILED           (QOSMLOG_BASE + 17)
/*
 * IPRIPv2 was unable to register with the Routing Table Manager.
 * The data is the error code.
 */

#define QOSMLOG_QOSMGR_STOPPED                (QOSMLOG_BASE + 18)
/*
 * QOSMGR has stopped.
 */



#define QOSMLOG_NETWORK_MODULE_ERROR          (QOSMLOG_BASE + 19)
/*
 * QOSMGR encountered a problem in the Network Module.
 * The data is the error code.
 */



#define QOSMLOG_PACKET_TOO_SMALL              (QOSMLOG_BASE + 20)
/*
 * QOSMGR received a packet which was smaller than the minimum size
 * allowed for QOSMGR packets. The packet has been discarded.
 * It was received on the local interface with IP address %1,
 * and it came from the neighboring router with IP address %2.
 */

#define QOSMLOG_PACKET_HEADER_CORRUPT         (QOSMLOG_BASE + 21)
/*
 * QOSMGR received a packet with an invalid header. The packet has been
 * discarded. It was received on the local interface with IP address %1,
 * and it came from the neighboring router with IP address %2.
 */

#define QOSMLOG_PACKET_VERSION_INVALID        (QOSMLOG_BASE + 22)
/*
 * QOSMGR received a packet with an invalid version in its header.
 * The packet has been discarded. It was received on the local interface
 * with IP address %1, and it came from the neighboring router
 * with IP address %2.
 */ 



#define QOSMLOG_TIMER_MODULE_ERROR            (QOSMLOG_BASE + 23)
/*
 * QOSMGR encountered a problem in the Timer Module.
 * The data is the error code.
 */



#define QOSMLOG_PROTOCOL_MODULE_ERROR         (QOSMLOG_BASE + 24)
/*
 * QOSMGR encountered a problem in the Protocol Module.
 * The data is the error code.
 */



#define QOSMLOG_TC_REGISTER_FAILED            (QOSMLOG_BASE + 25)
/*
 * QOSMGR could not register with the traffic control API.
 * The data is the error code.
 */



#define QOSMLOG_TC_DEREGISTER_FAILED          (QOSMLOG_BASE + 26)
/*
 * QOSMGR could not deregister with the traffic control API.
 * The data is the error code.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmmain.c ===
/*++

Copyright 1997 - 98, Microsoft Corporation

Module Name:

    qosmmain.c

Abstract:

    Contains routines that are invoked when
    the QosMgr DLL is loaded or unloaded.

Revision History:

--*/

#include "pchqosm.h"

#pragma hdrstop

// All Global variables
QOSMGR_GLOBALS  Globals;

BOOL
WINAPI
DllMain(
    IN      HINSTANCE                       Instance,
    IN      DWORD                           Reason,
    IN      PVOID                           Unused
    )

/*++

Routine Description:

    This is the DLL's main entrypoint handler which
    initializes the Qos Mgr component. 
    
Arguments:

    None

Return Value:

    TRUE if successful, FALSE if not
    
--*/

{
    static BOOL QosmInitialized = FALSE;

    UNREFERENCED_PARAMETER(Unused);

    switch(Reason) 
    {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(Instance);

        //
        // Initialize the Qos Mgr Component
        //

        QosmInitialized = QosmDllStartup();

        return QosmInitialized;

    case DLL_PROCESS_DETACH:

        //
        // Cleanup the Qos Mgr Component
        //

        if (QosmInitialized)
        {
            QosmDllCleanup();
        }
    }

    return TRUE;
}


BOOL
QosmDllStartup(
    VOID
    )

/*++

Routine Description:

    Initializes all global data structures in Qos Mgr.
    Called by DLL Main when the process is attached.
    
Arguments:

    None

Return Value:

    TRUE if successful, FALSE if not
    
--*/

{
    TCI_CLIENT_FUNC_LIST TcHandlers;    
    BOOL                 ListLockInited;
    DWORD                Status;
    UINT                 i;

    ListLockInited = FALSE;

    do
    {
        ZeroMemory(&Globals, sizeof(QOSMGR_GLOBALS));

        // Globals.State = IPQOSMRG_STATE_STOPPED;

        //
        // Enable logging and tracing for debugging purposes
        //
  
        START_TRACING();
        START_LOGGING();

#if DBG_TRACE
        Globals.TracingFlags = QOSM_TRACE_ANY;
#endif

        //
        // Create a private heap for Qos Mgr's use
        //

        Globals.GlobalHeap = HeapCreate(0, 0, 0);
  
        if (Globals.GlobalHeap == NULL)
        {
            Status = GetLastError();

            Trace1(ANY, 
                   "QosmDllStartup: Failed to create a global private heap %x",
                   Status);

            LOGERR0(HEAP_CREATE_FAILED, Status);
            
            break;
        }

        //
        // Initialize lock to guard global list of interfaces
        //

        try
        {
            CREATE_READ_WRITE_LOCK(&Globals.GlobalsLock);

            ListLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetLastError();
          
                Trace1(ANY, 
                       "QosmDllStartup : Failed to create read/write lock %x",
                       Status);
      
                LOGERR0(CREATE_RWL_FAILED, Status);

                break;
            }
        
        //
        // Initialize global list and table of active interfaces
        //

        Globals.NumIfs = 0;

        InitializeListHead(&Globals.IfList);

        //
        // Register with the traffic control API to control QOS
        //

        ZeroMemory(&TcHandlers, sizeof(TCI_CLIENT_FUNC_LIST));

        TcHandlers.ClNotifyHandler = TcNotifyHandler;

        Status = TcRegisterClient(CURRENT_TCI_VERSION,
                                  NULL,
                                  &TcHandlers,
                                  &Globals.TciHandle);

        if (Status != NO_ERROR)
        {
            Trace1(ANY, 
                   "QosmDllStartup: Failed to register with the TC API %x",
                   Status);

            LOGERR0(TC_REGISTER_FAILED, Status);
            
            break;
        }

        Globals.State = IPQOSMGR_STATE_STARTING;

        return TRUE;

    }
    while (FALSE);

    //
    // Some error occured - clean up and return the error code
    //

    if (ListLockInited)
    {
        DELETE_READ_WRITE_LOCK(&Globals.GlobalsLock);
    }

    if (Globals.GlobalHeap != NULL)
    {
        HeapDestroy(Globals.GlobalHeap);
    }

    STOP_LOGGING();
    STOP_TRACING();

    return FALSE;
}


BOOL
QosmDllCleanup(
    VOID
    )

/*++

Routine Description:

    Cleans up all global data structures at unload time.
    
Arguments:

    None

Return Value:

    TRUE if successful, FALSE if not

--*/

{
    DWORD   Status;

    // We should have freed all ifs to avoid any leaks
    ASSERT(Globals.NumIfs == 0);

    //
    // Cleanup and deregister with traffic control API
    //

    Status = TcDeregisterClient(Globals.TciHandle);

    if (Status != NO_ERROR)
    {
        Trace1(ANY, 
               "QosmDllCleanup: Failed to deregister with the TC API %x",
               Status);

        LOGERR0(TC_DEREGISTER_FAILED, Status);
    }

    //
    // Free resources allocated like locks and memory
    //

    DELETE_READ_WRITE_LOCK(&Globals.GlobalsLock);

    //
    // Cleanup the heap and memory allocated in it
    //

    HeapDestroy(Globals.GlobalHeap);

    //
    // Stop debugging aids like tracing and logging
    //

    STOP_LOGGING();
    STOP_TRACING();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmtest.cxx ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    qosmtest.cxx

Abstract:

    The file contains code to test the
    QOS Mgr protocol.

Revision History:

--*/

#include "qosmtest.h"

int 
_cdecl
main()
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-protocol\qosmtest.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    qosmtest.h

Abstract:

    The file contains declarations for testing
    QOS Mgr functionality.

Revision History:

--*/

#ifndef __QOSMTEST_H_
#define __QOSMTEST_H_

#include <windows.h>

#include <stdio.h>
#include <wchar.h>

#endif // __QOSMTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\pschdprf\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

      PerfUtil.h

Abstract:

    Header file for performance utility functions

--*/

#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// Definitions for utility functions
#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

// Delcare prototypes for utility functions
void convertIndices(BYTE *, int, DWORD, DWORD);
DWORD GetQueryType(IN LPWSTR);
BOOL IsNumberInUnicodeList(DWORD, LPWSTR);
VOID CorrectInstanceName(PWCHAR);

#endif // _PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\pschdprf\pschddat.c ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    PschdDat.c

Abstract:

    This file declares and initializes object and counter data definitions

Author:

    Eliot Gillum (t-eliotg)   July 5, 1998
    
Revision History

--*/

#include <windows.h>
#include <ntddndis.h>
#include "PschdPrf.h"
#include "PSchdCnt.h"


//
// Pipe object and counter definition declarations
//

PERF_OBJECT_TYPE PsPipeObjType = {
        sizeof(PERF_OBJECT_TYPE),         // TotalByteLength - to be modified later
        sizeof(PERF_OBJECT_TYPE),         // DefinitionLength - to be modified later
        sizeof(PERF_OBJECT_TYPE),         // HeaderLength
        PSCHED_PIPE_OBJ,                  // ObjectNameTitleIndex
        0,                                // ObjectNameTitle
        PSCHED_PIPE_OBJ,                  // ObjectHelpTitleIndex
        0,                                // ObjectHelpTitle
        PERF_DETAIL_NOVICE,               // DetailLevel
        0,                                // NumCounters - to be modified later
        0,                                // DefaultCounter
        0,                                // Number of object instances ( seq #)
        0,                                // CodePage
        {0,0},                            // Perf Time
        {0,0}                             // Perf Freq
    };

PS_PIPE_PIPE_STAT_DEF PsPipePipeStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_OUT_OF_PACKETS,
        0,
        PIPE_OUT_OF_PACKETS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_OUT_OF_PACKETS_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_FLOWS_OPENED,
        0,
        PIPE_FLOWS_OPENED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_FLOWS_OPENED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_FLOWS_CLOSED,
        0,
        PIPE_FLOWS_CLOSED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_FLOWS_CLOSED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_FLOWS_REJECTED,
        0,
        PIPE_FLOWS_REJECTED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_FLOWS_REJECTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_FLOWS_MODIFIED,
        0,
        PIPE_FLOWS_MODIFIED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_FLOWS_MODIFIED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_FLOW_MODS_REJECTED,
        0,
        PIPE_FLOW_MODS_REJECTED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_FLOW_MODS_REJECTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_MAX_SIMULTANEOUS_FLOWS,
        0,
        PIPE_MAX_SIMULTANEOUS_FLOWS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_MAX_SIMULTANEOUS_FLOWS_OFFSET
    }
};

PS_PIPE_CONFORMER_STAT_DEF PsPipeConformerStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_NONCONF_PACKETS_SCHEDULED,
        0,
        PIPE_NONCONF_PACKETS_SCHEDULED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_NONCONF_PACKETS_SCHEDULED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_NONCONF_PACKETS_SCHEDULED_PERSEC,
        0,
        PIPE_NONCONF_PACKETS_SCHEDULED_PERSEC,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PIPE_NONCONF_PACKETS_SCHEDULED_OFFSET
    }
};

PS_PIPE_SHAPER_STAT_DEF PsPipeShaperStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_AVE_PACKETS_IN_SHAPER,
        0,
        PIPE_AVE_PACKETS_IN_SHAPER,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_AVE_PACKETS_IN_SHAPER_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_MAX_PACKETS_IN_SHAPER,
        0,
        PIPE_MAX_PACKETS_IN_SHAPER,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_MAX_PACKETS_IN_SHAPER_OFFSET
    }
};

PS_PIPE_SEQUENCER_STAT_DEF PsPipeSequencerStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_AVE_PACKETS_IN_SEQ,
        0,
        PIPE_AVE_PACKETS_IN_SEQ,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_AVE_PACKETS_IN_SEQ_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_MAX_PACKETS_IN_SEQ,
        0,
        PIPE_MAX_PACKETS_IN_SEQ,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_MAX_PACKETS_IN_SEQ_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_MAX_PACKETS_IN_NETCARD,
        0,
        PIPE_MAX_PACKETS_IN_NETCARD,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_MAX_PACKETS_IN_NETCARD_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_AVE_PACKETS_IN_NETCARD,
        0,
        PIPE_AVE_PACKETS_IN_NETCARD,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_AVE_PACKETS_IN_NETCARD_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_NONCONF_PACKETS_TRANSMITTED,
        0,
        PIPE_NONCONF_PACKETS_TRANSMITTED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIPE_NONCONF_PACKETS_TRANSMITTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        PIPE_NONCONF_PACKETS_TRANSMITTED_PERSEC,
        0,
        PIPE_NONCONF_PACKETS_TRANSMITTED_PERSEC,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PIPE_NONCONF_PACKETS_TRANSMITTED_OFFSET
    }
};


//
// Flow object and counter definition declarations
//

PERF_OBJECT_TYPE PsFlowObjType = {
        sizeof(PERF_OBJECT_TYPE),      // TotalByteLength - to be modified later
        sizeof(PERF_OBJECT_TYPE),      // DefinitionLength - to be modified later
        sizeof(PERF_OBJECT_TYPE),      // HeaderLength
        PSCHED_FLOW_OBJ,               // ObjectNameTitleIndex
        0,                             // ObjectNameTitle
        PSCHED_FLOW_OBJ,               // ObjectHelpTitleIndex
        0,                             // ObjectHelpTitle
        PERF_DETAIL_NOVICE,            // DetailLevel
        0,                             // NumCounters - to be modified later
        5,                             // DefaultCounter -- Ave packets in seq
        0,                             // Number of object instances ( seq #)
        0,                             // CodePage
        {0,0},                         // Perf Time
        {0,0}                          // Perf Freq
    };

PS_FLOW_FLOW_STAT_DEF PsFlowFlowStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_PACKETS_DROPPED,
        0,
        FLOW_PACKETS_DROPPED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_PACKETS_DROPPED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_PACKETS_SCHEDULED,
        0,
        FLOW_PACKETS_SCHEDULED,
        0,
        -3,                     // scale the graph by 10^-3, i.e. graph thousands of packets instead of packets
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_PACKETS_SCHEDULED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_PACKETS_TRANSMITTED,
        0,
        FLOW_PACKETS_TRANSMITTED,
        0,
        -3,                     // scale the graph by 10^-3, i.e. graph thousands of packets instead of packets
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_PACKETS_TRANSMITTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_BYTES_SCHEDULED,
        0,
        FLOW_BYTES_SCHEDULED,
        0,
        -6,                     // scale the graph by 10^-6, i.e. graph MBs instead of bytes
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(LARGE_INTEGER),
        FLOW_BYTES_SCHEDULED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_BYTES_TRANSMITTED,
        0,
        FLOW_BYTES_TRANSMITTED,
        0,
        -6,                     // scale the graph by 10^-6, i.e. graph MBs instead of bytes
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(LARGE_INTEGER),
        FLOW_BYTES_TRANSMITTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_BYTES_TRANSMITTED_PERSEC,
        0,
        FLOW_BYTES_TRANSMITTED_PERSEC,
        0,
        -3,                     // scale the graph by 10^-3, i.e. graph kb/s instead of bytes/sec
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        FLOW_BYTES_TRANSMITTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_BYTES_SCHEDULED_PERSEC,
        0,
        FLOW_BYTES_SCHEDULED_PERSEC,
        0,
        -3,                     // scale the graph by 10^-3, i.e. graph kb/s instead of bytes/sec
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        FLOW_BYTES_SCHEDULED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_PACKETS_TRANSMITTED_PERSEC,
        0,
        FLOW_PACKETS_TRANSMITTED_PERSEC,
        0,
        -3,                     // scale the graph by 10^-3, i.e. graph kilopackets/sec instead of packets/sec
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FLOW_PACKETS_TRANSMITTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_PACKETS_SCHEDULED_PERSEC,
        0,
        FLOW_PACKETS_SCHEDULED_PERSEC,
        0,
        -3,                     // scale the graph by 10^-3, i.e. graph kilopackets/sec instead of packets/sec
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FLOW_PACKETS_SCHEDULED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_PACKETS_DROPPED_PERSEC,
        0,
        FLOW_PACKETS_DROPPED_PERSEC,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FLOW_PACKETS_DROPPED_OFFSET
    }
};

PS_FLOW_CONFORMER_STAT_DEF PsFlowConformerStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_NONCONF_PACKETS_SCHEDULED,
        0,
        FLOW_NONCONF_PACKETS_SCHEDULED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_NONCONF_PACKETS_SCHEDULED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_NONCONF_PACKETS_SCHEDULED_PERSEC,
        0,
        FLOW_NONCONF_PACKETS_SCHEDULED_PERSEC,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FLOW_NONCONF_PACKETS_SCHEDULED_OFFSET
    }
};

PS_FLOW_SHAPER_STAT_DEF PsFlowShaperStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_AVE_PACKETS_IN_SHAPER,
        0,
        FLOW_AVE_PACKETS_IN_SHAPER,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_AVE_PACKETS_IN_SHAPER_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_MAX_PACKETS_IN_SHAPER,
        0,
        FLOW_MAX_PACKETS_IN_SHAPER,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_MAX_PACKETS_IN_SHAPER_OFFSET
    }
};

PS_FLOW_SEQUENCER_STAT_DEF PsFlowSequencerStatDef = {
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_AVE_PACKETS_IN_SEQ,
        0,
        FLOW_AVE_PACKETS_IN_SEQ,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_AVE_PACKETS_IN_SEQ_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_MAX_PACKETS_IN_SEQ,
        0,
        FLOW_MAX_PACKETS_IN_SEQ,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_MAX_PACKETS_IN_SEQ_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_MAX_PACKETS_IN_NETCARD,
        0,
        FLOW_MAX_PACKETS_IN_NETCARD,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_MAX_PACKETS_IN_NETCARD_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_AVE_PACKETS_IN_NETCARD,
        0,
        FLOW_AVE_PACKETS_IN_NETCARD,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_AVE_PACKETS_IN_NETCARD_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_NONCONF_PACKETS_TRANSMITTED,
        0,
        FLOW_NONCONF_PACKETS_TRANSMITTED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FLOW_NONCONF_PACKETS_TRANSMITTED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        FLOW_NONCONF_PACKETS_TRANSMITTED_PERSEC,
        0,
        FLOW_NONCONF_PACKETS_TRANSMITTED_PERSEC,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FLOW_NONCONF_PACKETS_TRANSMITTED_OFFSET
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\pschdprf\pschdcnt.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    PschdCnt.h

Abstract:

    Offset definition file for extensible counter objects and counters

    These "relative" offsets must start at 0 and be multiples of 2 (i.e.
    even numbers). In the Open Procedure, they will be added to the 
    "First Counter" and "First Help" values for the device they belong to, 
    in order to determine the absolute location of the counter and 
    object names and corresponding Explain text in the registry.

    This file is used by the extensible counter DLL code as well as the 
    counter name and Explain text definition file (.INI) file that is used
    by LODCTR to load the names into the registry.

Revision History:

--*/

// PerfMon objects
#define PSCHED_FLOW_OBJ                             0
#define PSCHED_PIPE_OBJ                             2

// Flow counters
#define FLOW_PACKETS_DROPPED                        4
#define FLOW_PACKETS_SCHEDULED                      6
#define FLOW_PACKETS_TRANSMITTED                    8
#define FLOW_AVE_PACKETS_IN_SHAPER                  10
#define FLOW_MAX_PACKETS_IN_SHAPER                  12
#define FLOW_AVE_PACKETS_IN_SEQ                     14
#define FLOW_MAX_PACKETS_IN_SEQ                     16
#define FLOW_BYTES_SCHEDULED                        18
#define FLOW_BYTES_TRANSMITTED                      20
#define FLOW_BYTES_TRANSMITTED_PERSEC               22
#define FLOW_BYTES_SCHEDULED_PERSEC                 24
#define FLOW_PACKETS_TRANSMITTED_PERSEC             26
#define FLOW_PACKETS_SCHEDULED_PERSEC               28
#define FLOW_PACKETS_DROPPED_PERSEC                 30
#define FLOW_NONCONF_PACKETS_SCHEDULED              32
#define FLOW_NONCONF_PACKETS_SCHEDULED_PERSEC       34
#define FLOW_NONCONF_PACKETS_TRANSMITTED            36
#define FLOW_NONCONF_PACKETS_TRANSMITTED_PERSEC     38
#define FLOW_MAX_PACKETS_IN_NETCARD                 40
#define FLOW_AVE_PACKETS_IN_NETCARD                 42

// Pipe counters
#define PIPE_OUT_OF_PACKETS                         44
#define PIPE_FLOWS_OPENED                           46
#define PIPE_FLOWS_CLOSED                           48
#define PIPE_FLOWS_REJECTED                         50
#define PIPE_FLOWS_MODIFIED                         52
#define PIPE_FLOW_MODS_REJECTED                     54
#define PIPE_MAX_SIMULTANEOUS_FLOWS                 56
#define PIPE_NONCONF_PACKETS_SCHEDULED              58
#define PIPE_NONCONF_PACKETS_SCHEDULED_PERSEC       60
#define PIPE_NONCONF_PACKETS_TRANSMITTED            62
#define PIPE_NONCONF_PACKETS_TRANSMITTED_PERSEC     64
#define PIPE_AVE_PACKETS_IN_SHAPER                  66
#define PIPE_MAX_PACKETS_IN_SHAPER                  68
#define PIPE_AVE_PACKETS_IN_SEQ                     70
#define PIPE_MAX_PACKETS_IN_SEQ                     72
#define PIPE_MAX_PACKETS_IN_NETCARD                 74
#define PIPE_AVE_PACKETS_IN_NETCARD                 76
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\pschdprf\perfutil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    PerfUtil.c

Abstract:

    This file implements utility functions for performance monitoring functions

Author:

	Eliot Gillum (t-eliotg) - July 5, 1998

Revision History

--*/

#include <windows.h>
#include <winperf.h>
#include "PerfUtil.h"


WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";
WCHAR NULL_STRING[] = L"\0";    // pointer to null string 


// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


// convertIndices() 
// Takes a pointer to an array of PERF_COUNTER_DEFINITIONs and converts their indices 
// to be absolute by adding the appropriate value (dwFirstCounter/dwFirstHelp)
//
// BYTE *buf				Pointer to an array of PERF_COUNTER_DEFINITIONs
// int numCounters          The number of PERF_COUNTER_DEFINITIONs to convert
// DWORD dwFirstCounter		Absolute index of the first counter in the series
// DWORD dwFirstHelp		Absolute index of the first help index in the series
void convertIndices(BYTE *buf, int numCounters, DWORD dwFirstCounter, DWORD dwFirstHelp)
{
	int i;

	// then the counter indices
	for (i=0; i<numCounters; i++) {
		((PERF_COUNTER_DEFINITION *)buf)->CounterNameTitleIndex += dwFirstCounter;
		((PERF_COUNTER_DEFINITION *)buf)->CounterHelpTitleIndex += dwFirstHelp;
		buf += sizeof(PERF_COUNTER_DEFINITION);
	}
}


DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foreign" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly, 
    // then it must be an item list
    
    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:
       
    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:
    TRUE:   dwNumber was found in the list of unicode number strings
    FALSE:  dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    BOOL    bReturnValue;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not found

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;
    
    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then 
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;
            
            case DELIMITER:
                // a delimiter is either the delimiter character or the 
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

VOID
CorrectInstanceName(PWCHAR IfcName)
{
    WCHAR  SpecialChars[] = L")(#\\/";
    int    k;
    int    r;
    WCHAR *p;

    //
    // perfmon does not allow the following characters in the name. We need to munge the name
    // and replace them with some other character.
    //
    for(r=0; SpecialChars[r]; r++) 
    {
        p = IfcName;
        while((p = wcschr(p, SpecialChars[r])))
        {
            *p = L'-';
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-protocol\sync.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: sync.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// Contains structures and macros used to implement synchronization.
//============================================================================

#ifndef _SYNC_H_
#define _SYNC_H_


//
// type definition for multiple-reader/single-writer lock
// Note: there is a similar facility provided by nturtl.h through the
// structure RTL_RESOURCE and several functions.  However, that
// implementation has the potential for starving a thread trying to acquire
// write accesss, if there are a large number of threads interested in
// acquiring read access.  Such a scenario is avoided in the implementation
// given in this header. However, a mapping is also given to the
// RTL_RESOURCE functionality, so that the protocol can be compiled to use
// either form
//

#ifdef USE_RWL

//
// use IPRIP's definitions
//

typedef struct _READ_WRITE_LOCK {

    CRITICAL_SECTION    RWL_ReadWriteBlock;
    LONG                RWL_ReaderCount;
    HANDLE              RWL_ReaderDoneEvent;

} READ_WRITE_LOCK, *PREAD_WRITE_LOCK;


DWORD CreateReadWriteLock(PREAD_WRITE_LOCK pRWL);
VOID DeleteReadWriteLock(PREAD_WRITE_LOCK pRWL);
VOID AcquireReadLock(PREAD_WRITE_LOCK pRWL);
VOID ReleaseReadLock(PREAD_WRITE_LOCK pRWL);
VOID AcquireWriteLock(PREAD_WRITE_LOCK pRWL);
VOID ReleaseWriteLock(PREAD_WRITE_LOCK pRWL);


//
// macro functions for manipulating a read-write lock
//

#define CREATE_READ_WRITE_LOCK(pRWL)                                        \
    CreateReadWriteLock(pRWL)
#define DELETE_READ_WRITE_LOCK(pRWL)                                        \
    DeleteReadWriteLock(pRWL)

#define READ_WRITE_LOCK_CREATED(pRWL)                                       \
            ((pRWL)->RWL_ReaderDoneEvent != NULL)


#define ACQUIRE_READ_LOCK(pRWL)                                             \
    AcquireReadLock(pRWL)

#define RELEASE_READ_LOCK(pRWL)                                             \
    ReleaseReadLock(pRWL)

#define ACQUIRE_WRITE_LOCK(pRWL)                                            \
    AcquireWriteLock(pRWL)

#define RELEASE_WRITE_LOCK(pRWL)                                            \
    ReleaseWriteLock(pRWL)

#define READ_LOCK_TO_WRITE_LOCK(pRWL)                                       \
    (ReleaseReadLock(pRWL), AcquireWriteLock(pRWL))

#define WRITE_LOCK_TO_READ_LOCK(pRWL)                                       \
    (ReleaseWriteLock(pRWL), AcquireReadLock(pRWL))


#else // i.e. !USE_RWL


//
// use the RTL_RESOURCE mechanism
//

typedef RTL_RESOURCE READ_WRITE_LOCK, *PREAD_WRITE_LOCK;

#define CREATE_READ_WRITE_LOCK(pRWL)                                        \
            RtlInitializeResource((pRWL))
#define DELETE_READ_WRITE_LOCK(pRWL)                                        \
            RtlDeleteResource((pRWL))
#define READ_WRITE_LOCK_CREATED(pRWL)   (TRUE)
#define ACQUIRE_READ_LOCK(pRWL)                                             \
            RtlAcquireResourceShared((pRWL),TRUE)
#define RELEASE_READ_LOCK(pRWL)                                             \
            RtlReleaseResource((pRWL))
#define ACQUIRE_WRITE_LOCK(pRWL)                                            \
            RtlAcquireResourceExclusive((pRWL),TRUE)
#define RELEASE_WRITE_LOCK(pRWL)                                            \
            RtlReleaseResource((pRWL))
#define READ_LOCK_TO_WRITE_LOCK(pRWL)                                       \
            RtlConvertSharedToExclusive((pRWL))
#define WRITE_LOCK_TO_READ_LOCK(pRWL)                                       \
            RtlConvertExclusiveToShared((pRWL))

#endif // USE_RWL



//
// type definition for generic locked list
// access is sychronized with a critical section
//

typedef struct _LOCKED_LIST {
    LIST_ENTRY          LL_Head;
    CRITICAL_SECTION    LL_Lock;
    DWORD               LL_Created;
} LOCKED_LIST, *PLOCKED_LIST;



//
// macro functions for manipulating the locked list
//

#define CREATE_LOCKED_LIST(pLL)                                             \
            InitializeListHead(&(pLL)->LL_Head);                            \
            InitializeCriticalSection(&(pLL)->LL_Lock);                     \
            (pLL)->LL_Created = 0x12345678

#define LOCKED_LIST_CREATED(pLL)                                            \
            ((pLL)->LL_Created == 0x12345678)

#define DELETE_LOCKED_LIST(pLL,type,field) {                                \
            PLIST_ENTRY _ple;                                               \
            (pLL)->LL_Created = 0;                                          \
            DeleteCriticalSection(&(pLL)->LL_Lock);                         \
            while (!IsListEmpty(&(pLL)->LL_Head)) {                         \
                _ple = RemoveHeadList(&(pLL)->LL_Head);                     \
                FREE(CONTAINING_RECORD(_ple,type,field));                   \
            }                                                               \
        }

#define ACQUIRE_LIST_LOCK(pLL)                                              \
            EnterCriticalSection(&(pLL)->LL_Lock)

#define RELEASE_LIST_LOCK(pLL)                                              \
            LeaveCriticalSection(&(pLL)->LL_Lock)

#endif // _SYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-protocol\sync.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    sync.c
//
// History:
//  Abolade Gbadegesin  Jan-12-1996     Created.
//
// Implementation of synchronization routines.
//============================================================================

#include "pchqosm.h"

#pragma hdrstop

#ifdef USE_RWL

//----------------------------------------------------------------------------
// Function:    CreateReadWriteLock
//
// Initializes a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

DWORD
CreateReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    pRWL->RWL_ReaderCount = 0;

    try {
        InitializeCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return GetLastError();
    }

    pRWL->RWL_ReaderDoneEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    if (pRWL->RWL_ReaderDoneEvent != NULL) {
        return GetLastError();
    }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DeleteReadWriteLock
//
// Frees resources used by a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

VOID
DeleteReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    CloseHandle(pRWL->RWL_ReaderDoneEvent);
    pRWL->RWL_ReaderDoneEvent = NULL;
    DeleteCriticalSection(&pRWL->RWL_ReadWriteBlock);
    pRWL->RWL_ReaderCount = 0;
}



//----------------------------------------------------------------------------
// Function:    AcquireReadLock
//
// Secures shared ownership of the lock object for the caller.
//
// readers enter the read-write critical section, increment the count,
// and leave the critical section
//----------------------------------------------------------------------------

VOID
AcquireReadLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock); 
    InterlockedIncrement(&pRWL->RWL_ReaderCount);
    LeaveCriticalSection(&pRWL->RWL_ReadWriteBlock);
}



//----------------------------------------------------------------------------
// Function:    ReleaseReadLock
//
// Relinquishes shared ownership of the lock object.
//
// the last reader sets the event to wake any waiting writers
//----------------------------------------------------------------------------

VOID
ReleaseReadLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) < 0)
        SetEvent(pRWL->RWL_ReaderDoneEvent); 
}



//----------------------------------------------------------------------------
// Function:    AcquireWriteLock
//
// Secures exclusive ownership of the lock object.
//
// the writer blocks other threads by entering the ReadWriteBlock section,
// and then waits for any thread(s) owning the lock to finish
//----------------------------------------------------------------------------

VOID
AcquireWriteLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock);
    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) >= 0)
        WaitForSingleObject(pRWL->RWL_ReaderDoneEvent, INFINITE);
}



//----------------------------------------------------------------------------
// Function:    ReleaseWriteLock
//
// Relinquishes exclusive ownership of the lock object.
//
// the writer releases the lock by setting the count to zero
// and then leaving the ReadWriteBlock critical section
//----------------------------------------------------------------------------

VOID
ReleaseWriteLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    pRWL->RWL_ReaderCount = 0;
    LeaveCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
}

#endif // USE_RWL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\pschdprf\pschdprf.c ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    PschdPrf.c

Abstract:

    This file implements the Extensible Objects for the PSched Flow and 
        Pipe object types.  In particular, it implements the three Open, 
        Collect, and Close functions called by PerfMon/SysMon.

Author:

    Eliot Gillum (t-eliotg)   June 14, 1998
    
Revision History
    Rajesh Sundaram : Reworked the code to work with flows/instances coming up and down.

--*/

// Useful macro


#define WRITEBUF(_addr, _len)           memcpy(pdwBuf,(_addr),(_len));      pdwBuf = (PULONG)((PUCHAR)pdwBuf + (_len));
#define MULTIPLE_OF_EIGHT(_x)  (((_x)+7) & ~7)


#include <windows.h>
#include <winerror.h>
#include <string.h>
#include <wtypes.h>
#include <ntprfctr.h>
#include <malloc.h>
#include <ntddndis.h>
#include <qos.h>
#include <ntddpsch.h>
#include <objbase.h>
#include "PschdPrf.h"
#include "PerfUtil.h"
#include "PschdCnt.h"
#include <rtutils.h>

// Psched Performance Key
#define PSCHED_PERF_KEY TEXT("SYSTEM\\CurrentControlSet\\Services\\PSched\\Performance")

HINSTANCE   ghInst;                 // module instance handle
DWORD       dwOpenCount = 0;        // count of "Open" threads
BOOL        bInitOK = FALSE;        // true = DLL initialized OK
HANDLE      ghTciClient;            // TCI client handle
HANDLE      ghClRegCtx;             // TCI Client Registration Context
PPIPE_INFO  gpPI;                   // Pipe and flow information array
ULONG       gTotalIfcNameSize;      // Number of bytes of all the interface names (incl. NULL term. char)
ULONG       gTotalFlowNameSize;     // Number of bytes of all the flow names (incl. NULL term. char)
ULONG       giIfcBufSize = 1024;    // set the initial buffer size to 1kb
DWORD       gPipeStatLen;           // Length of the buffer used to define all the 
                                    // Pipe statistics that will be reported by the 
                                    // underlying components
DWORD       gFlowStatLen;           // Length of the buffer used to define all the 
                                    // Flow statistics that will be reported by the
                                    // underlying components
CRITICAL_SECTION ghPipeFlowCriticalSection;

#if DBG
//
// For tracing support.
//

#define DBG_INFO  (0x00010000 | TRACE_USE_MASK)
#define DBG_ERROR (0x00020000 | TRACE_USE_MASK)

DWORD   gTraceID = INVALID_TRACEID;

#define Trace0(_mask, _str)     TracePrintfEx(gTraceID, _mask, _str)
#define Trace1(_mask, _str, _a) TracePrintfEx(gTraceID, _mask, _str, _a)

#else

#define Trace0(_mask, _str)
#define Trace1(_mask, _str, _a)

#endif

//  Function Prototypes
//
//      these are used to ensure that the data collection functions
//      accessed by Perflib will have the correct calling format.
PM_OPEN_PROC        OpenPschedPerformanceData;
PM_COLLECT_PROC     CollectPschedPerformanceData;
PM_CLOSE_PROC       ClosePschedPerformanceData;


// Declared in PschdDat.c
extern PERF_OBJECT_TYPE           PsPipeObjType;
extern PS_PIPE_PIPE_STAT_DEF      PsPipePipeStatDef;
extern PS_PIPE_CONFORMER_STAT_DEF PsPipeConformerStatDef;
extern PS_PIPE_SHAPER_STAT_DEF    PsPipeShaperStatDef;
extern PS_PIPE_SEQUENCER_STAT_DEF PsPipeSequencerStatDef;
extern PERF_OBJECT_TYPE           PsFlowObjType;
extern PS_FLOW_FLOW_STAT_DEF      PsFlowFlowStatDef;
extern PS_FLOW_CONFORMER_STAT_DEF PsFlowConformerStatDef;
extern PS_FLOW_SHAPER_STAT_DEF    PsFlowShaperStatDef;
extern PS_FLOW_SEQUENCER_STAT_DEF PsFlowSequencerStatDef;


BOOL
getFlowInfo(IN PPIPE_INFO pPI, IN ULONG flowCount)
{

    HANDLE                   hEnum;
    ULONG                    size;
    PVOID                    pFlowBuf;
    static ULONG             FlowBufSize=1024;
    ULONG                    j;
    ULONG                    BytesWritten;
    ULONG                    status;
    ULONG                    nameSize;

    // initialize the enumeration handle
    hEnum = NULL;
    
    for(j=0; j<pPI->numFlows; j++) 
    {
        size = ((wcslen(pPI->pFlowInfo[j].FriendlyName) + 1) * sizeof(WCHAR));
        gTotalFlowNameSize -= MULTIPLE_OF_EIGHT(size);
    }

    PsFlowObjType.NumInstances -= pPI->numFlows;
    PsFlowObjType.NumInstances += flowCount;
    pPI->numFlows = flowCount;

    if(pPI->pFlowInfo)
        free(pPI->pFlowInfo);

    if(flowCount)
    {
        pPI->pFlowInfo = (PFLOW_INFO) malloc(flowCount * sizeof(FLOW_INFO));

        //
        // We cannot allocate memory for the flow names. There is nothing much we can do here.
        // let's pretend as though there are no flows.
        //

        if(!pPI->pFlowInfo)
        {
           Trace0(DBG_ERROR, L"[getFlowInfo]: malloc failed \n");
           PsFlowObjType.NumInstances -= flowCount;
           pPI->numFlows = 0;
           return FALSE;
        }
        else
        {
            memset(pPI->pFlowInfo, 0, sizeof(FLOW_INFO) * flowCount);
        }

        // allocate the flow enumeration buffer
        pFlowBuf = malloc(FlowBufSize);

        if(!pFlowBuf)
        {
           Trace0(DBG_ERROR, L"[getFlowInfo]: malloc failed \n");
           free(pPI->pFlowInfo);
           pPI->pFlowInfo = NULL;
           PsFlowObjType.NumInstances -= flowCount;
           pPI->numFlows = 0;
           return FALSE;
        }
        
        // initialize the enumeration handle
        hEnum = NULL;
        
        // enumerate each flow and remember its name
        for (j=0; j<pPI->numFlows; j++) 
        {
            PENUMERATION_BUFFER pEnum;
            LPQOS_FRIENDLY_NAME pFriendly;
            ULONG               TcObjectLength, FriendlyNameFound;

            // get the next flow
            BytesWritten = FlowBufSize;
            flowCount = 1;
            status = TcEnumerateFlows(pPI->hIfc, &hEnum, &flowCount, &BytesWritten, pFlowBuf);

            while (ERROR_INSUFFICIENT_BUFFER == status) 
            {
                free(pFlowBuf);
                FlowBufSize *= 2;
                BytesWritten = FlowBufSize;
                pFlowBuf = malloc(BytesWritten);
                if(!pFlowBuf)
                {
                   Trace0(DBG_ERROR, L"[getFlowInfo]: malloc failed \n");
                   free(pPI->pFlowInfo);
                   pPI->pFlowInfo = NULL;
                   PsFlowObjType.NumInstances -= flowCount;
                   pPI->numFlows = 0;
                   return FALSE;
                   
                }
                status = TcEnumerateFlows(pPI->hIfc, &hEnum, &flowCount, &BytesWritten, pFlowBuf);
            }

            if (    (NO_ERROR != status) 
                ||  (BytesWritten == 0) )
            {
                if ( status )
                    Trace1(DBG_ERROR, L"[getFlowInfo]: TcEnumerateFlows failed with 0x%x \n", status);
                else if ( BytesWritten == 0 )
                    Trace0(DBG_ERROR, L"[getFlowInfo]: TcEnumerateFlows returned 0 bytes \n");

                free(pFlowBuf);
                free(pPI->pFlowInfo);
                pPI->pFlowInfo = NULL;
                PsFlowObjType.NumInstances -= flowCount;
                pPI->numFlows = 0;
                return FALSE;
            }
            
            // save the flow's name
            pEnum = (PENUMERATION_BUFFER)pFlowBuf;
            FriendlyNameFound = 0;
            pFriendly = (LPQOS_FRIENDLY_NAME)pEnum->pFlow->TcObjects;
            TcObjectLength = pEnum->pFlow->TcObjectsLength;

            while(0)
            {
                if(pFriendly->ObjectHdr.ObjectType == QOS_OBJECT_FRIENDLY_NAME)
                {
                    // We found a friendly name. Lets use it.
                    memcpy(
                        pPI->pFlowInfo[j].FriendlyName, 
                        pFriendly->FriendlyName, 
                        PS_FRIENDLY_NAME_LENGTH *sizeof(WCHAR) );
                        
                    pPI->pFlowInfo[j].FriendlyName[PS_FRIENDLY_NAME_LENGTH] = L'\0';
                    nameSize = (wcslen(pPI->pFlowInfo[j].FriendlyName) + 1) * sizeof(WCHAR);
                    gTotalFlowNameSize += MULTIPLE_OF_EIGHT(nameSize);
                    FriendlyNameFound = 1;
                    break;
                }
                else {
                    // Move on to the next QoS object.
                    TcObjectLength -= pFriendly->ObjectHdr.ObjectLength;
                    pFriendly = (LPQOS_FRIENDLY_NAME)((PCHAR) pFriendly + pFriendly->ObjectHdr.ObjectLength);
                }
            }
            
            if(!FriendlyNameFound) 
            {
                //
                // If there is no friendly name, the Instance name becomes the friendly name.
                //
                memcpy(pPI->pFlowInfo[j].FriendlyName, 
                       ((PENUMERATION_BUFFER)pFlowBuf)->FlowName, 
                       PS_FRIENDLY_NAME_LENGTH * sizeof(WCHAR) );
                pPI->pFlowInfo[j].FriendlyName[PS_FRIENDLY_NAME_LENGTH] = L'\0';
                nameSize = (wcslen(pPI->pFlowInfo[j].FriendlyName) + 1) * sizeof(WCHAR);
                gTotalFlowNameSize += MULTIPLE_OF_EIGHT(nameSize);
            }

            //
            // We have to always store the instance name since we call TcQueryFlow with this name.
            //

            nameSize = (wcslen(((PENUMERATION_BUFFER)pFlowBuf)->FlowName) + 1) * sizeof(WCHAR);
            memcpy(pPI->pFlowInfo[j].InstanceName, ((PENUMERATION_BUFFER)pFlowBuf)->FlowName, nameSize);
        }
        
        free(pFlowBuf);
    }
    else 
    {
        pPI->pFlowInfo = NULL;
        Trace0(DBG_INFO, L"[getFlowInfo]: No flows to enumerate \n");
    }

    return TRUE;
}

// getPipeFlowInfo() initializes an array of PIPE_INFO structs to contain
// up-to-date information about the pipes available and the flows installed on them
//
// Parameters: ppPI - pointer to a pointer to an array of PIPE_INFO structs
// Return value:  TRUE if all info in *ppPI is valid, FALSE otherwise
BOOL getPipeFlowInfo(OUT        PPIPE_INFO      *ppPI)
{
    ULONG                    status;
    ULONG                    BytesWritten;
    ULONG                    i,j,k;
    PVOID                    pIfcDescBuf = NULL;
    PTC_IFC_DESCRIPTOR       currentIfc;
    PPIPE_INFO               pPI = NULL;
    HANDLE                   hEnum;
    PVOID                    pFlowBuf;
    static ULONG             FlowBufSize=1024;
    ULONG                    flowCount;
    ULONG                    nameSize;
    ULONG                    size;
    PPERF_COUNTER_DEFINITION pCntDef;

    PsPipeObjType.NumInstances=0;
    PsFlowObjType.NumInstances = 0;

    pIfcDescBuf = (PVOID)malloc(giIfcBufSize);

    if (NULL == pIfcDescBuf) 
    {
        Trace0(DBG_ERROR, L"[getPipeFlowInfo]: Malloc failed \n");
        return FALSE;
    }

    BytesWritten = giIfcBufSize;
    status = TcEnumerateInterfaces(ghTciClient, &BytesWritten, pIfcDescBuf);

    while (ERROR_INSUFFICIENT_BUFFER==status) 
    {
        free(pIfcDescBuf);
        giIfcBufSize *= 2;
        pIfcDescBuf = (PTC_IFC_DESCRIPTOR)malloc(giIfcBufSize);

        if (NULL == pIfcDescBuf)
        {
            Trace0(DBG_ERROR, L"[getPipeFlowInfo]: Malloc failed \n");
            return FALSE;
        }

        BytesWritten = giIfcBufSize;

        status = TcEnumerateInterfaces(ghTciClient, &BytesWritten, pIfcDescBuf);
    }

    if (NO_ERROR!=status) 
    {
        // If we're not going to be able to enumerate the interfaces, we have no alternatives

        Trace1(DBG_ERROR, L"[getPipeFlowInfo]: TcEnumerateInterfaces failed with 0x%x\n", status);
        free(pIfcDescBuf);
        return FALSE;
    }
    
    // Figure out the number of interfaces

    for (i=0; i<BytesWritten; i+=((PTC_IFC_DESCRIPTOR)((BYTE *)pIfcDescBuf+i))->Length)
    {
        PsPipeObjType.NumInstances++;
    }
    
    
    // Open each interface and remember the handle to it

    if (0 != PsPipeObjType.NumInstances) {

        // Allocate space for our structs

        *ppPI=(PPIPE_INFO)malloc(PsPipeObjType.NumInstances * sizeof(PIPE_INFO) );

        if (NULL == *ppPI) 
        {
            Trace0(DBG_ERROR, L"[getPipeFlowInfo]: Malloc failed \n");
            free(pIfcDescBuf);
            return FALSE;
        }
        else
        {
            memset(*ppPI, 0, sizeof(PIPE_INFO) * PsPipeObjType.NumInstances);
        }

        pPI = *ppPI;    // less typing, cleaner source code
        
        gTotalIfcNameSize = 0;

        gTotalFlowNameSize = 0;
        
        currentIfc = pIfcDescBuf;

        // Initialize struct information for each interface

        for (i=0; i<(unsigned)PsPipeObjType.NumInstances; i++) 
        {
            // remember the inteface's name

            nameSize = (wcslen(currentIfc->pInterfaceName) + 1) * sizeof(WCHAR);

            pPI[i].IfcName = malloc(nameSize);
            if (NULL == pPI[i].IfcName) 
            {
                Trace0(DBG_ERROR, L"[getPipeFlowInfo]: Malloc failed \n");
                goto Error;
            }
            wcscpy(pPI[i].IfcName, currentIfc->pInterfaceName);
            
            //
            // add this name size to gTotalIfcNameSize.
            //
            gTotalIfcNameSize += MULTIPLE_OF_EIGHT(nameSize);
           
            //
            // open the interface
            //
            status = TcOpenInterface(
                        pPI[i].IfcName, 
                        ghTciClient, 
                        &pPI[i], 
                        &pPI[i].hIfc);
            if (status != NO_ERROR) 
            {
                Trace1(DBG_ERROR, L"[getPipeFlowInfo]: TcOpenInterface failed with 0x%x\n", status);
                goto Error;
            }

            //
            // Enumerate the flows on the interface
            // find out how many flows to expect
            //

            pPI[i].numFlows   = 0;
            pPI[i].pFlowInfo = 0;
            status = TcQueryInterface(pPI[i].hIfc, 
                                      (LPGUID)&GUID_QOS_FLOW_COUNT, 
                                      TRUE, 
                                      &BytesWritten, 
                                      &flowCount);

            if (NO_ERROR != status) 
            {
                Trace1( DBG_ERROR, 
                        L"[getPipeFlowInfo]: TcQueryInterface failed with 0x%x, ignoring this error\n", 
                        status);
            }
            else 
            {
                getFlowInfo(&pPI[i], flowCount);
            }
            
            // move to the next interface
            currentIfc = (PTC_IFC_DESCRIPTOR)((PBYTE)currentIfc + currentIfc->Length);
        }
    }
    
    // determine what components will be contributing stats, if there any stats to get
    if (PsPipeObjType.NumInstances > 0) {
        
        //
        // compute the counter definition lengths. Each set of counters is preceeded by a PERF_OBJECT_TYPE, followed
        // by 'n' PERF_COUNTER_DEFINITIONS. All these are aligned on 8 byte boundaries, so we don't have to do any 
        // fancy aligining.
        //

        PsPipeObjType.DefinitionLength = sizeof(PERF_OBJECT_TYPE) + 
            sizeof(PsPipePipeStatDef) + 
            sizeof(PsPipeConformerStatDef) + 
            sizeof(PsPipeShaperStatDef) + 
            sizeof(PsPipeSequencerStatDef);

        PsFlowObjType.DefinitionLength = sizeof(PERF_OBJECT_TYPE) + 
            sizeof(PsFlowFlowStatDef) + 
            sizeof(PsFlowConformerStatDef) + 
            sizeof(PsFlowShaperStatDef) + 
            sizeof(PsFlowSequencerStatDef);
        
        // compute the sizes of the stats buffers. 
        gPipeStatLen = FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +  // initial offset
            sizeof(PS_ADAPTER_STATS) +                 // every interface has adapter stats
            FIELD_OFFSET(PS_COMPONENT_STATS, Stats) + 
            sizeof(PS_CONFORMER_STATS) + 
            FIELD_OFFSET(PS_COMPONENT_STATS, Stats) + 
            sizeof(PS_SHAPER_STATS) + 
            FIELD_OFFSET(PS_COMPONENT_STATS, Stats) + 
            sizeof(PS_DRRSEQ_STATS);
        
        gFlowStatLen = FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +  // initial offset
            sizeof(PS_FLOW_STATS) +                    // the flow's stats 
            FIELD_OFFSET(PS_COMPONENT_STATS, Stats) + 
            sizeof(PS_CONFORMER_STATS) + 
            FIELD_OFFSET(PS_COMPONENT_STATS, Stats) + 
            sizeof(PS_SHAPER_STATS) + 
            FIELD_OFFSET(PS_COMPONENT_STATS, Stats) + 
            sizeof(PS_DRRSEQ_STATS);

        // Align these to 8 byte boundaries.
        gPipeStatLen = MULTIPLE_OF_EIGHT(gPipeStatLen);
        gFlowStatLen = MULTIPLE_OF_EIGHT(gFlowStatLen);
        
        // update the number of counters to be reported for each object type
        PsPipeObjType.NumCounters = PIPE_PIPE_NUM_STATS + PIPE_CONFORMER_NUM_STATS + 
            PIPE_SHAPER_NUM_STATS + PIPE_SEQUENCER_NUM_STATS;
        
        PsFlowObjType.NumCounters = FLOW_FLOW_NUM_STATS + FLOW_CONFORMER_NUM_STATS + 
            FLOW_SHAPER_NUM_STATS + FLOW_SEQUENCER_NUM_STATS;
    }

    // free up resources
    free(pIfcDescBuf);
    
    // Everything worked so return that we're happy
    return TRUE;

Error:
    for (i=0; i<(unsigned)PsPipeObjType.NumInstances; i++) 
    {
        if ( pPI[i].hIfc )
        {
            // Deregister for flow count notifications.
            TcQueryInterface(
                pPI[i].hIfc, 
                 (LPGUID)&GUID_QOS_FLOW_COUNT, 
                 FALSE, 
                 &BytesWritten, 
                 &flowCount);
         
            TcCloseInterface(pPI[i].hIfc);
        }   
    }
    
    if (pIfcDescBuf)
        free(pIfcDescBuf);
    
    if(pPI)
        free(pPI);
        
    return FALSE;    
}       

// closePipeFlowInfo() is the counterpart to getPipeFlowInfo()
// It closes all open interfaces and flows, as well as freeing memory
//
// Parameters: ppPI - pointer to a pointer to an array of valid PIPE_INFO structs
// Return value:  None
void closePipeFlowInfo(PPIPE_INFO *ppPI)
{
    ULONG i;
    PPIPE_INFO pPI=*ppPI;           // makes for less typing and cleaner code
    ULONG BytesWritten, flowCount;

    BytesWritten = sizeof(flowCount);
    
    // free up resources associated with each interface, then close the interface
    for (i=0; i<(unsigned)PsPipeObjType.NumInstances; i++) 
    {
       if(pPI[i].IfcName)
       {
          free(pPI[i].IfcName);
       }

       if(pPI[i].pFlowInfo)
       {
          free(pPI[i].pFlowInfo);
       }

        // Deregister for flow count notifications.
        TcQueryInterface(pPI[i].hIfc, 
                         (LPGUID)&GUID_QOS_FLOW_COUNT, 
                         FALSE, 
                         &BytesWritten, 
                         &flowCount);

        TcCloseInterface(pPI[i].hIfc);
    }
    
    // now free up the whole buffer
    free(*ppPI);
}


// This func recieves notifcations from traffic.dll and makes the appropriate
// updates to internal structures
void tciNotifyHandler(IN    HANDLE  ClRegCtx,
                      IN    HANDLE  ClIfcCtx,
                      IN    ULONG   Event,
                      IN    HANDLE  SubCode,
                      IN    ULONG   BufSize,
                      IN    PVOID   Buffer)
{
    switch (Event) 
    {
      case TC_NOTIFY_IFC_UP:
      case TC_NOTIFY_IFC_CLOSE:
      case TC_NOTIFY_IFC_CHANGE:
          
          // we'll need sync'ed access
          EnterCriticalSection(&ghPipeFlowCriticalSection);
          
          // now reinit the data struct
          closePipeFlowInfo(&gpPI);
          getPipeFlowInfo(&gpPI);
          
          LeaveCriticalSection(&ghPipeFlowCriticalSection);

          break;

      case TC_NOTIFY_PARAM_CHANGED:
          
          // A flow has been closed by the TC interface
          // for example: after a remote call close, or the whole interface
          // is going down
          //
          // we'll need sync'ed access
          EnterCriticalSection(&ghPipeFlowCriticalSection);

          if(!memcmp((LPGUID) SubCode, &GUID_QOS_FLOW_COUNT, sizeof(GUID)) )
          {
              PULONG FlowCount = (PULONG) Buffer;
              getFlowInfo(ClIfcCtx, *FlowCount);
          }
          LeaveCriticalSection(&ghPipeFlowCriticalSection);
          break;

      default:
          break;
    }
}


DWORD APIENTRY OpenPschedPerformanceData(LPWSTR lpDeviceNames)
/*++
Routine Description:

    This routine will open and map the memory used by the PSched driver to
    pass performance data in. This routine also initializes the data
    structures used to pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PSched)

Return Value:

    None.
--*/

{
    LONG    status;
    HKEY    hPerfKey;
    DWORD   size;
    DWORD   type;
    DWORD   dwFirstCounter;
    DWORD   dwFirstHelp;
    TCI_CLIENT_FUNC_LIST tciCallbFuncList = {tciNotifyHandler, NULL, NULL, NULL};

    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread 
    //  at a time so synchronization (i.e. reentrancy) should not be 
    //  a problem
    if (InterlockedIncrement(&dwOpenCount) == 1)
    {
    
#if DBG
        gTraceID = TraceRegister(L"PschdPrf");
#endif

        // get counter and help index base values
        // update static data structures by adding base to 
        // offset value in structure.

        status = RegOpenKeyEx ( HKEY_LOCAL_MACHINE,
                                PSCHED_PERF_KEY,
                                0L,
                                KEY_READ,
                                &hPerfKey);
        if (status != ERROR_SUCCESS) {
            // this is fatal, if we can't get the base values of the 
            // counter or help names, then the names won't be available
            // to the requesting application, so there's not much
            // point in continuing.
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx( hPerfKey, 
                                    TEXT("First Counter"),
                                    0L,
                                    &type,
                                    (LPBYTE)&dwFirstCounter,
                                    &size);
        if (status != ERROR_SUCCESS) {
            // this is fatal, if we can't get the base values of the 
            // counter or help names, then the names won't be available
            // to the requesting application, so there's not much
            // point in continuing.
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(   hPerfKey, 
                                    TEXT("First Help"),
                                    0L,
                                    &type,
                                    (LPBYTE)&dwFirstHelp,
                                    &size);
        if (status != ERROR_SUCCESS) {
            // this is fatal, if we can't get the base values of the 
            // counter or help names, then the names won't be available
            // to the requesting application, so there's not much
            // point in continuing.
            goto OpenExitPoint;
        }

        RegCloseKey (hPerfKey); // close key to registry


        // Convert Pipe object and counters from offset to absolute index
        PsPipeObjType.ObjectNameTitleIndex += dwFirstCounter;
        PsPipeObjType.ObjectHelpTitleIndex += dwFirstHelp;
        convertIndices((BYTE *)&PsPipePipeStatDef, 
                       sizeof PsPipePipeStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);
        convertIndices((BYTE *)&PsPipeConformerStatDef,
                       sizeof PsPipeConformerStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);
        convertIndices((BYTE *)&PsPipeShaperStatDef,
                       sizeof PsPipeShaperStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);
        convertIndices((BYTE *)&PsPipeSequencerStatDef, 
                       sizeof PsPipeSequencerStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);

        // Convert Flow object and counters from offset to absolute index
        PsFlowObjType.ObjectNameTitleIndex += dwFirstCounter;
        PsFlowObjType.ObjectHelpTitleIndex += dwFirstHelp;
        convertIndices((BYTE *)&PsFlowFlowStatDef,
                       sizeof PsFlowFlowStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);
        convertIndices((BYTE *)&PsFlowConformerStatDef,
                       sizeof PsFlowConformerStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);
        convertIndices((BYTE *)&PsFlowShaperStatDef,
                       sizeof PsFlowShaperStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);
        convertIndices((BYTE *)&PsFlowSequencerStatDef,
                       sizeof PsFlowSequencerStatDef/sizeof(PERF_COUNTER_DEFINITION),
                       dwFirstCounter, 
                       dwFirstHelp);
        
        // initialize the mutex
        __try {

            InitializeCriticalSection(&ghPipeFlowCriticalSection);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
        
            status = GetExceptionCode();
            goto OpenExitPoint;
        }

        // initialize with traffic.dll
        if (TcRegisterClient(CURRENT_TCI_VERSION, ghClRegCtx, &tciCallbFuncList, &ghTciClient)!=NO_ERROR)
        {
            // if we can't connect with traffic.dll we are a non admin thread in OpenPschedPerformanceData. 
            // We cannot fail because of this, because an admin thread might call us at our collect routine.
            // We'll try to register as the Traffic Control client in the Collect Thread.
            //
            ghTciClient = 0;
        }
        else 
        {
        
            // we'll need sync'ed access
            EnterCriticalSection(&ghPipeFlowCriticalSection);

            // get all necessary info about pipes and flows currently installed
            if (getPipeFlowInfo(&gpPI)!=TRUE) {

                // we didn't get all the info we wanted, so we're 
                // going to have to try again, including re-registering

                LeaveCriticalSection(&ghPipeFlowCriticalSection);

                TcDeregisterClient(ghTciClient);
                goto OpenExitPoint;
            }

            LeaveCriticalSection(&ghPipeFlowCriticalSection);
        }

        // if we got to here, then we're all ready
        bInitOK = TRUE;
    }
    
    Trace0(DBG_INFO, L"[OpenPschedPerformanceData]: success \n");

    status = ERROR_SUCCESS; // for successful exit

    return status;
    
OpenExitPoint:
    Trace1(DBG_ERROR, L"[OpenPschedPerformanceData]: Failed with 0x%x \n", status);
    
    return status;
}

DWORD APIENTRY CollectPschedPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++
Routine Description:

    This routine will return the data for the PSched counters. 

    The data is returned in the foll. format. The steps below are carried out for Pipe/Flows.
    
    1. First, we write the PERF_OBJECT_TYPE for the Pipe (and/or) the Flow Counters.

    2. for(i=0; i<NumCounters; i++)
          Write PERF_COUNTER_DEFINITION for counter i;

    3. for(i=0; i<NumInstances; i++)
          Write PERF_INSTANCE_DEFINITION for instance i;
          Write Instance Name
          Write PERF_COUNTER_BLOCK
          Write the Stats;

Arguments:

   IN       LPWSTR   lpValueName
                     pointer to a wide character string passed by registry.

    IN OUT   LPVOID   *lppData
        IN: pointer to the address of the buffer to receive the completed 
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
        OUT: points to the first byte after the data structure added by this
             routine. This routine updated the value at lppdata after appending
             its data.

   IN OUT   LPDWORD  lpcbTotalBytes
        IN: the address of the DWORD that tells the size in bytes of the 
            buffer referenced by the lppData argument
        OUT: the number of bytes added by this routine is written to the 
             DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
        IN: the address of the DWORD to receive the number of objects added 
            by this routine 
        OUT: the number of objects added by this routine is written to the 
            DWORD pointed to by this argument

Return Value:

    ERROR_MORE_DATA if buffer passed is too small to hold data
                    any error conditions encountered could be reported to the event log if
                    event logging support were added.

    ERROR_SUCCESS   if success or any other error. Errors, however could
                    also reported to the event log.
--*/
{
    ULONG                    i,j;
    ULONG                    SpaceNeeded;
    PDWORD                   pdwBuf;
    DWORD                    dwQueryType;
    DWORD                    status;
    DWORD                    bufSize;
    PS_PERF_COUNTER_BLOCK    pcb;
    PERF_INSTANCE_DEFINITION pid={0, 0, 0, PERF_NO_UNIQUE_ID, sizeof(pid), 0};
    ULONG                    size;
    PVOID                    pStatsBuf;

    // save the size of the buffer
    bufSize = *lpcbTotalBytes;
    
    // default to returning nothing
    *lpcbTotalBytes = (DWORD) 0;
    *lpNumObjectTypes = (DWORD) 0;

    // Before doing anything else, see if Open went OK
    if (!bInitOK)
    {
        // unable to continue because open failed.
        Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: open failed \n");    
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // See if this is a foreign (i.e. non-NT) computer data request 
    dwQueryType = GetQueryType (lpValueName);
    if (dwQueryType == QUERY_FOREIGN)
    {
        // this routine does not service requests for data from
        // Non-NT computers
        Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: received QUERY_FOREIGN \n");    
        return ERROR_SUCCESS;
    }

    //  Is PerfMon requesting PSched items?
    if (dwQueryType == QUERY_ITEMS)
    {
        if (   !(IsNumberInUnicodeList(PsPipeObjType.ObjectNameTitleIndex, 
                                           lpValueName))
            && !(IsNumberInUnicodeList(PsFlowObjType.ObjectNameTitleIndex, 
                                           lpValueName)) ) {
            // request received for data object not provided by this routine

            Trace0(DBG_INFO, L"[CollectPschedPerformanceData]: Not for psched \n");
            return ERROR_SUCCESS;
        }
    }

    // from this point on, we need sync'ed access
    EnterCriticalSection(&ghPipeFlowCriticalSection);

    // we might need to rereigster as a Traffic control client. 
    if(ghTciClient == NULL)
    {
        TCI_CLIENT_FUNC_LIST tciCallbFuncList = {tciNotifyHandler, NULL, NULL, NULL};

        status = TcRegisterClient(CURRENT_TCI_VERSION, ghClRegCtx, &tciCallbFuncList, &ghTciClient);

        if(status != NO_ERROR)
        {
            Trace1(DBG_ERROR, L"[CollectPschedPerformanceData]: Could not register as Traffic Client. Error 0x%x \n",
                   status);
            LeaveCriticalSection(&ghPipeFlowCriticalSection);

            return ERROR_SUCCESS;
        }

        // get all necessary info about pipes and flows currently installed
        if (getPipeFlowInfo(&gpPI)!=TRUE) {

            LeaveCriticalSection(&ghPipeFlowCriticalSection);

            Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: getPipeFlowInfo failed \n");

            return ERROR_SUCCESS;

        }
    }

    //
    // We have to write the PERF_OBJECT_TYPE unconditionally even if there are no instances. So, we proceed
    // to compute the space needed even when there are no flows. 
    //

    // Calculate the space needed for the pipe stats. 
    SpaceNeeded = PsPipeObjType.DefinitionLength + gTotalIfcNameSize + (PsPipeObjType.NumInstances *
                                                    (sizeof pid + sizeof pcb + gPipeStatLen) );

    SpaceNeeded += PsFlowObjType.DefinitionLength + gTotalFlowNameSize + (PsFlowObjType.NumInstances *
                                                        (sizeof pid + sizeof pcb + gFlowStatLen) );

    if (bufSize < SpaceNeeded)
    {
        LeaveCriticalSection(&ghPipeFlowCriticalSection);
        Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: Need More data\n");    
        return ERROR_MORE_DATA;
    }
    
    pdwBuf = (PDWORD)*lppData;
    
    // Record the total length of the pipe stats
    PsPipeObjType.TotalByteLength = 
        PsPipeObjType.DefinitionLength + gTotalIfcNameSize + (PsPipeObjType.NumInstances *
                                          (sizeof pid + sizeof pcb + gPipeStatLen) );
    
    // copy object and counter definitions, increment count of object types
    WRITEBUF(&PsPipeObjType,sizeof PsPipeObjType);
    WRITEBUF(&PsPipePipeStatDef, sizeof PsPipePipeStatDef);
    WRITEBUF(&PsPipeConformerStatDef, sizeof PsPipeConformerStatDef);
    WRITEBUF(&PsPipeShaperStatDef, sizeof PsPipeShaperStatDef);
    WRITEBUF(&PsPipeSequencerStatDef, sizeof PsPipeSequencerStatDef);

    (*lpNumObjectTypes)++;
    
    //
    // for each pipe, write out its instance definition, counter block, and actual stats
    //
   
    if(ghTciClient)
    { 
        for (i=0; i<(unsigned)PsPipeObjType.NumInstances; i++) {
    
            PWCHAR InstanceName;
            
            //
            // Write out the PERF_INSTANCE_DEFINITION, which identifies an interface and gives it a name.
            //
            
            pid.NameLength = (wcslen(gpPI[i].IfcName)+1) * sizeof(WCHAR);
            pid.ByteLength = sizeof pid + MULTIPLE_OF_EIGHT(pid.NameLength);
            WRITEBUF(&pid, sizeof pid);
    
            InstanceName = (PWCHAR) pdwBuf;
    
            memcpy(pdwBuf, gpPI[i].IfcName, pid.NameLength);
            pdwBuf = (PULONG)((PUCHAR)pdwBuf + MULTIPLE_OF_EIGHT(pid.NameLength));
            
            CorrectInstanceName(InstanceName);
               
            //
            // get pipe stats and copy them to the buffer
            //
            size = gPipeStatLen;
            pStatsBuf = malloc(size);
            if (NULL == pStatsBuf) 
            {
                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                LeaveCriticalSection(&ghPipeFlowCriticalSection);
                Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: Insufficient memory\n");    
                return ERROR_SUCCESS;
            }
            
            status = TcQueryInterface(gpPI[i].hIfc, 
                                      (LPGUID)&GUID_QOS_STATISTICS_BUFFER, 
                                      FALSE, 
                                      &size, 
                                      pStatsBuf);
            
            if (ERROR_INSUFFICIENT_BUFFER==status) 
            {
                free(pStatsBuf);
                size = gPipeStatLen = MULTIPLE_OF_EIGHT(size);
                pStatsBuf = (PPS_COMPONENT_STATS)malloc(gPipeStatLen);
                if (NULL == pStatsBuf)
                {
                    *lpcbTotalBytes = (DWORD) 0;
                    *lpNumObjectTypes = (DWORD) 0;
                    LeaveCriticalSection(&ghPipeFlowCriticalSection);
                    Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: Insufficient memory\n");    
                    return ERROR_SUCCESS;
                }
                status = TcQueryInterface(gpPI[i].hIfc, 
                                          (LPGUID)&GUID_QOS_STATISTICS_BUFFER, 
                                          FALSE, 
                                          &size, 
                                          pStatsBuf);
            }
            if (NO_ERROR != status) {
                
                Trace1(DBG_ERROR, L"[CollectPschedPerformanceData]: TcQueryInterface failed with 0x%x \n", status);
                memset ( pStatsBuf, 0, gPipeStatLen );
            }
            
            //
            // Now, write the PERF_COUNTER_BLOCK
            //
            pcb.pcb.ByteLength = gPipeStatLen + sizeof(pcb);
            WRITEBUF(&pcb,sizeof pcb);
            
            //
            // Write out all the counters.
            //
                
            WRITEBUF(pStatsBuf,gPipeStatLen);
            
            free(pStatsBuf);
        }
    }
    
    // set the pointer to where the pipe object type said the next object would start
    pdwBuf = (PDWORD)( ((BYTE *)*lppData) + PsPipeObjType.TotalByteLength );
        
    // first copy flow data def (object_type struct).
    // Record the total length of the flow stats
    PsFlowObjType.TotalByteLength = 
            PsFlowObjType.DefinitionLength + gTotalFlowNameSize + (PsFlowObjType.NumInstances *
                                              (sizeof pid + sizeof pcb + gFlowStatLen) );
        
    // copy object and counter definitions, increment count of object types
    WRITEBUF(&PsFlowObjType,sizeof PsFlowObjType);
    WRITEBUF(&PsFlowFlowStatDef, sizeof PsFlowFlowStatDef);
    WRITEBUF(&PsFlowConformerStatDef, sizeof PsFlowConformerStatDef);
    WRITEBUF(&PsFlowShaperStatDef, sizeof PsFlowShaperStatDef);
    WRITEBUF(&PsFlowSequencerStatDef, sizeof PsFlowSequencerStatDef);
    (*lpNumObjectTypes)++;

    // if there are any flows, process them
        
    if (PsFlowObjType.NumInstances && ghTciClient) {

        // initialize parent structure
        pid.ParentObjectTitleIndex = PsPipeObjType.ObjectNameTitleIndex;
        
        // loop over each interface checking for flow installed on them
        for (i=0; i<(unsigned)PsPipeObjType.NumInstances; i++) {
            
            // keep parent instance up to date
            pid.ParentObjectInstance = i;
            
            for (j=0; j<gpPI[i].numFlows; j++) {
                PWCHAR InstanceName;

                // copy flow instance definition and name
                pid.NameLength = (wcslen(gpPI[i].pFlowInfo[j].FriendlyName)+1) * sizeof(WCHAR);
                pid.ByteLength = sizeof(pid) + MULTIPLE_OF_EIGHT(pid.NameLength);
                WRITEBUF(&pid,sizeof pid);
                InstanceName = (PWCHAR) pdwBuf;

                memcpy(pdwBuf, gpPI[i].pFlowInfo[j].FriendlyName, pid.NameLength);
                pdwBuf = (PULONG)((PUCHAR)pdwBuf + MULTIPLE_OF_EIGHT(pid.NameLength));

                CorrectInstanceName(InstanceName);
                
                // get flow stats and copy them to the buffer
                size = gFlowStatLen;
                pStatsBuf = malloc(size);
                if (NULL == pStatsBuf) {
                    *lpcbTotalBytes = (DWORD) 0;
                    *lpNumObjectTypes = (DWORD) 0;
                    LeaveCriticalSection(&ghPipeFlowCriticalSection);
                    Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: Insufficient memory\n");    
                    return ERROR_SUCCESS;
                }
                status = TcQueryFlow(gpPI[i].pFlowInfo[j].InstanceName, (LPGUID)&GUID_QOS_STATISTICS_BUFFER, 
                                     &size, pStatsBuf);
                if (ERROR_INSUFFICIENT_BUFFER==status) {
                    free(pStatsBuf);
                    size = gFlowStatLen = MULTIPLE_OF_EIGHT(size);
                    pStatsBuf = (PPS_COMPONENT_STATS)malloc(gFlowStatLen);
                    if (NULL == pStatsBuf)
                    {
                        *lpcbTotalBytes = (DWORD) 0;
                        *lpNumObjectTypes = (DWORD) 0;
                        LeaveCriticalSection(&ghPipeFlowCriticalSection);
                        Trace0(DBG_ERROR, L"[CollectPschedPerformanceData]: Insufficient memory\n");    
                        return ERROR_SUCCESS;
                    }
                    status = TcQueryFlow(gpPI[i].pFlowInfo[j].InstanceName, (LPGUID)&GUID_QOS_STATISTICS_BUFFER, 
                                         &size, pStatsBuf);
                }
                if (NO_ERROR != status) {
                    
                    free(pStatsBuf);
                    *lpcbTotalBytes = (DWORD) 0;
                    *lpNumObjectTypes = (DWORD) 0;
                    LeaveCriticalSection(&ghPipeFlowCriticalSection);
                    Trace1(DBG_ERROR, 
                             L"[CollectPschedPerformanceData]: TcQueryFlow failed with status 0x%x \n", status);

                    return ERROR_SUCCESS;
                }

                // copy flow instance counter_block 
                pcb.pcb.ByteLength = gFlowStatLen + sizeof(pcb);

                WRITEBUF(&pcb,sizeof pcb);

                WRITEBUF(pStatsBuf, gFlowStatLen);
                
                free(pStatsBuf);
            }
        }
    }
    
    // update the data pointer
    *lpcbTotalBytes = PsPipeObjType.TotalByteLength + PsFlowObjType.TotalByteLength;
    *lppData = ((PBYTE)*lppData) + *lpcbTotalBytes;
    
    // free up the sync lock
    LeaveCriticalSection(&ghPipeFlowCriticalSection);

    Trace0(DBG_INFO, L"[CollectPschedPerformanceData]: Succcess \n");
    return ERROR_SUCCESS;
}


/*
Routine Description:
    This routine closes the open handles to PSched device performance counters

Arguments:
    None.

Return Value:
    ERROR_SUCCESS
*/
DWORD APIENTRY ClosePschedPerformanceData()
{

    if(InterlockedDecrement(&dwOpenCount) == 0)
    {
        // Clean up with traffic.dll and free up resources
        closePipeFlowInfo(&gpPI);

        // then deregister
        if(ghTciClient)
            TcDeregisterClient(ghTciClient);

        // get rid of the mutex
        DeleteCriticalSection(&ghPipeFlowCriticalSection);
        
#if DBG
        TraceDeregister(gTraceID);
#endif
    }

    return ERROR_SUCCESS;
}


//////////////////////////////////////////////////////////////////////
//
// PERF UTILITY STUFF BELOW!
//
//////////////////////////////////////////////////////////////////////
BOOL WINAPI DllEntryPoint(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            ghInst = hDLL;
            break;
        case DLL_PROCESS_DETACH:
            break;
        case DLL_THREAD_ATTACH:
            break;
        case DLL_THREAD_DETACH:
            break;
    } // switch

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\pslog\main.cpp ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    User space log viewer

Author:

    Rajesh Sundaram (1st Aug, 1998)

Revision History:

--*/

#define UNICODE
#define INITGUID
#include "precomp.h"

void ClNotifyHandler( HANDLE ClRegCtx, HANDLE ClIfcCtx, ULONG Event, HANDLE SubCode, ULONG BufSize, PVOID Buffer )
{
}

static PCHAR SendRecvActions[] = {
    "",
    "ENTER",
    "NO_RESOURCES",
    "LOW_RESOURCES",
    "INDICATING",
    "RETURNED",
    "NOT_OURS",
    "OURS",
    "RETURNING",
    "TRANSFERRING",
    "NOT READY"};

#define FILE   1
#define CONFIG 2
#define LEVEL  4
#define MASK   8

VOID
ParseOidRecord(
    CHAR * DataStart,
    ULONG *Size
    )
{
    static PCHAR OIDActions[] =
    {
        "",
        "MpSetInformation",
        "MpQueryInformation",
        "SetRequestComplete",
        "QueryRequestComplete"
    };
    TRACE_RECORD_OID *record = (TRACE_RECORD_OID *)DataStart;

    *Size = sizeof(TRACE_RECORD_OID);

    if(record->Now.QuadPart){

        printf("[%I64u]: OID: %5s:%9s:(%d:%d):%p:%08X:%08X\n",
                 record->Now.QuadPart,
                 OIDActions[record->Action],
                 record->Local == TRUE?"Local":"Non Local",
                 record->PTState,
                 record->MPState,
                 record->Adapter,
                 record->Oid,
                 record->Status);
    }
    else {
        printf("OID: %5s:%9s:(%d:%d):%p:%08X:%08X\n",
                 OIDActions[record->Action],
                 record->Local == TRUE?"Local":"Non Local",
                 record->PTState,
                 record->MPState,
                 record->Adapter,
                 record->Oid,
                 record->Status);
    }
}

VOID
ParseStringRecord(
    CHAR * DataStart,
    ULONG *Size
    )
{
    TRACE_RECORD_STRING *record = (TRACE_RECORD_STRING *) DataStart;

    *Size = sizeof(TRACE_RECORD_STRING);

    if(record->Now.QuadPart){
        printf("%I64u:%s",
               record->Now.QuadPart,
               record->StringStart);
    }
    else{
        printf("%s",
               record->StringStart);
    }

}

VOID
ParseSchedRecord(
    CHAR * DataStart,
    ULONG *Size
    )
{
    TRACE_RECORD_SCHED * record = (TRACE_RECORD_SCHED *)DataStart;
    static PCHAR SchedModules[] = {
        "NOP",
        "TB CONFORMER",
        "SHAPER",
        "DRR SEQ",
        "CBQ"};

    static PCHAR SchedActions[] = {
        "NOP",
        "ENQUEUE",
        "DEQUEUE",
        "CONFORMANCE",
        "DISCARD"};

    LARGE_INTEGER ArrivalTime, ConformanceTime;

    ConformanceTime.QuadPart = record->ConformanceTime;
    ArrivalTime.QuadPart = record->ArrivalTime;

    printf("SCHED:%s:VC %p:%p:%u:%s:%d:%I64u:[%u,%u]:%I64u:[%u,%u]:%u\n",
           SchedModules[record->SchedulerComponent],
           record->VC,
           record->Packet,
           record->PacketLength,
           SchedActions[record->Action],
           record->Priority,
           ArrivalTime.QuadPart,
           ArrivalTime.HighPart,
           ArrivalTime.LowPart,
           ConformanceTime.QuadPart,
           ConformanceTime.HighPart,
           ConformanceTime.LowPart,
           record->PacketsInComponent);

    *Size = sizeof(TRACE_RECORD_SCHED);
}

VOID
ParseRecvRecord(
    CHAR * DataStart,
    PULONG size
    )
{

    static PCHAR RecvEvents[] = {
        "",
        "CL_RECV_PACKET",
        "MP_RETURN_PACKET",
        "CL_RECV_INDICATION",
        "CL_RECV_COMPLETE",
        "MP_TRANSFER_DATA",
        "CL_TRANSFER_COMPLETE"};

    TRACE_RECORD_RECV *record = (TRACE_RECORD_RECV*)DataStart;

    *size = sizeof(TRACE_RECORD_RECV);

    printf("%I64u:Adapter %p:%s:%s:%p:%p \n",
            record->Now.QuadPart,
            record->Adapter,
            RecvEvents[record->Event],
            SendRecvActions[record->Action],
            record->Packet1,
            record->Packet2);
}

VOID
ParseSendRecord(
    CHAR * DataStart,
    PULONG Size
    )
{
    TRACE_RECORD_SEND* record = (TRACE_RECORD_SEND *)DataStart;
    static PCHAR SendEvents[] = {
        "",
        "MP_SEND",
        "MP_CO_SEND",
        "DUP_PACKET",
        "DROP_PACKET",
        "CL_SEND_COMPLETE" };


    *Size = sizeof(TRACE_RECORD_SEND);

    printf("%I64u:Adapter %p:%s:%s:%p:%p:%p\n",
            record->Now.QuadPart,
            record->Adapter,
            SendEvents[record->Event],
            SendRecvActions[record->Action],
            record->Vc,
            record->Packet1,
            record->Packet2);

}

VOID
ParseBuffer(
    CHAR * DataStart,
    ULONG Size
    )
{
    CHAR * recordEnd;
    LONG records;
    BOOLEAN success;
    CHAR hold;
    ULONG bytesread;
    ULONG TotalValidBytesRead = 0;

    records = 0;

    while(TRUE)
    {
        hold = *(DataStart+4);

        switch(hold)
        {

          case RECORD_TSTRING:

              ParseStringRecord(DataStart, &bytesread);
              break;

          case RECORD_OID:
              ParseOidRecord(DataStart, &bytesread);
              break;

          case RECORD_SCHED:

              ParseSchedRecord(DataStart, &bytesread);
              break;

          case RECORD_RECV:
              ParseRecvRecord(DataStart, &bytesread);
              break;

          case RECORD_SEND:
              ParseSendRecord(DataStart, &bytesread);
              break;
          default:

              printf("Unrecognized record type!\n");

              //
              // we cannot proceed - we don't know how much to advance it by.
              //

              return;
        }

        records++;

        TotalValidBytesRead += bytesread;

        if(TotalValidBytesRead >= Size){
            printf("\nDONE:Completed parsing trace buffer. %d records found.\n", records);
            break;
        }

        DataStart += bytesread;
    }
}

BOOLEAN TcDone(
    HANDLE ClientHandle,
    HANDLE InterfaceHandle
    )

{
    ULONG Status;

    Status = TcCloseInterface(InterfaceHandle);

    if(!NT_SUCCESS(Status))
    {
        printf("TcCloseInterface failed : Status = %d \n", Status);
    }

    Status = TcDeregisterClient(ClientHandle);

    if(!NT_SUCCESS(Status))
    {
        printf("TcDeregisterClient failed : Status = %d \n", Status);
    }

    return TRUE;

}

BOOLEAN TcInit(
    PHANDLE ClientHandle,
    PHANDLE InterfaceHandle
    )
{
    TCI_CLIENT_FUNC_LIST ClientHandlerList;
    ULONG                Size = 100 * sizeof(TC_IFC_DESCRIPTOR);
    PTC_IFC_DESCRIPTOR   InterfaceBuffer;
    ULONG x, Status;

    memset( &ClientHandlerList, 0, sizeof(ClientHandlerList) );
    ClientHandlerList.ClNotifyHandler = ClNotifyHandler;

    InterfaceBuffer = (PTC_IFC_DESCRIPTOR) malloc(Size);
    if(!InterfaceBuffer)
        return FALSE;

    //
    // Register the TC client.
    //
    Status = TcRegisterClient(CURRENT_TCI_VERSION,
                              NULL,
                              &ClientHandlerList,
                              ClientHandle);

    if(!NT_SUCCESS(Status))
    {
        printf("Cannot register as TC client \n");
        free(InterfaceBuffer);
        return FALSE;
    }

    //
    // Enumerate interfaces.
    //

    Status = TcEnumerateInterfaces(
        *ClientHandle,
        &Size,
        InterfaceBuffer);

    if(ERROR_INSUFFICIENT_BUFFER == Status)
    {
        free(InterfaceBuffer);

        InterfaceBuffer = (PTC_IFC_DESCRIPTOR) malloc(Size);

		if ( !InterfaceBuffer ) 
		{
            TcDeregisterClient(*ClientHandle);

            printf("Unable to allocate memory to call TcEnumerateInterfaces\n");

            return FALSE;
		}
		
        Status = TcEnumerateInterfaces(
            *ClientHandle,
            &Size,
            InterfaceBuffer);

        if(!NT_SUCCESS(Status))
        {
            TcDeregisterClient(*ClientHandle);

            free(InterfaceBuffer);

            printf("TcEnumerateInterfaces failed with error %d \n", Status);

            return FALSE;
        }
    }
    else
    {
        if(!NT_SUCCESS(Status))
        {
            TcDeregisterClient(*ClientHandle);

            free(InterfaceBuffer);

            printf("TcEnumerateInterfaces failed with error %d \n", Status);

            return FALSE;
        }
    }

    if(Size)
    {
        Status = TcOpenInterface(
            InterfaceBuffer->pInterfaceName,
            *ClientHandle,
            NULL,
            InterfaceHandle);

        if(!NT_SUCCESS(Status))
        {
            //
            printf("TcOpenInterface failed for interface %ws with Status %d \n",
                   InterfaceBuffer->pInterfaceName, Status);

            TcDeregisterClient(*ClientHandle);

            free(InterfaceBuffer);

            return FALSE;
        }

    }
    else
    {
        printf("No Traffic Interfaces \n");
        return FALSE;
    }

    return TRUE;
}


int __cdecl main(int argc, char **argv)
{

    HANDLE  ClientHandle, InterfaceHandle;
    BOOLEAN flags = 0;
    ULONG   mask, level;
    ULONG   DataSize;
    CHAR    *Buffer;

    if (argc < 2) goto usage;

    argv++; argc--;

    while( argc>0 && argv[0][0] == '-' )  {

        switch (argv[0][1])
        {

          case 'F':
          case 'f':
              flags |= FILE;
              break;

          case 'c':
          case 'C':
              flags |= CONFIG;
              break;

          case 'l':
          case 'L':
              if(sscanf(&argv[0][2], "%d", &level) == 1)
              {
                  if((ULONG)level > 10) 
                  {
                      goto usage;
                  }
                  flags |= LEVEL;
              }
              else 
              {
                 goto usage;
              }
              break;

          case 'm':
          case 'M':
              if(argv[0][2]!='0' && argv[0][3]!='x')
              {
                  goto usage;
              }

              if(sscanf(&argv[0][2], "%x", &mask) == 1)
              {
                   flags |= MASK;
              }
              else goto usage;

              break;

          default:
              goto usage;
        }
        argv++; argc--;
    }

    if((flags & CONFIG) && (flags & (FILE|LEVEL|MASK)))
    {
        goto usage;
    }

    if(TcInit(&ClientHandle, &InterfaceHandle))
    {
        ULONG size = sizeof(ULONG);
        ULONG chk;
        if(TcQueryInterface(InterfaceHandle,
                           (LPGUID)&GUID_QOS_LOG_MASK,
                           FALSE,
                           &size,
                           &chk) != STATUS_SUCCESS)
        {
            printf("Does not work on free bits \n");
        }

        if(flags & LEVEL)
        {

            TcSetInterface(InterfaceHandle,
                           (LPGUID)&GUID_QOS_LOG_LEVEL,
                           sizeof(level),
                           &level);
        }

        if(flags & MASK)
        {
            printf("Setting Mask to 0x%x \n", mask);
            TcSetInterface(InterfaceHandle,
                           (LPGUID)&GUID_QOS_LOG_MASK,
                           sizeof(mask),
                           &mask);
        }

        if(flags & CONFIG)
        {
            TcQueryInterface(InterfaceHandle,
                           (LPGUID)&GUID_QOS_LOG_MASK,
                           FALSE,
                           &size,
                           &mask);

            TcQueryInterface(InterfaceHandle,
                             (LPGUID)&GUID_QOS_LOG_LEVEL,
                             FALSE,
                             &size,
                             &level);

            printf("Masks supported\n");
            printf("            DBG_INIT                0x00000001 \n");
            printf("            DBG_MINIPORT            0x00000002 \n");
            printf("            DBG_PROTOCOL            0x00000004 \n");
            printf("            DBG_SEND                0x00000008 \n");
            printf("            DBG_RECEIVE             0x00000010 \n");
            printf("            DBG_IO                  0x00000020 \n");
            printf("            DBG_MEMORY              0x00000040 \n");
            printf("            DBG_CM                  0x00000080 \n");
            printf("            DBG_REFCNTS             0x00000100 \n");
            printf("            DBG_VC                  0x00000200 \n");
            printf("            DBG_GPC_QOS             0x00000400 \n");
            printf("            DBG_WAN                 0x00000800 \n");
            printf("            DBG_STATE               0x00001000 \n");
            printf("            DBG_ROUTINEOIDS         0x00002000 \n");
            printf("            DBG_SCHED_TBC           0x00004000 \n");
            printf("            DBG_SCHED_SHAPER        0x00008000 \n");
            printf("            DBG_SCHED_DRR           0x00010000 \n");
            printf("            DBG_WMI                 0x00020000 \n");

            printf("\nLevels supported\n");
            printf("            DBG_DEATH               1\n");
            printf("            DBG_CRITICAL_ERROR      2\n");
            printf("            DBG_FAILURE             4\n");
            printf("            DBG_INFO                6\n");
            printf("            DBG_TRACE               8\n");
            printf("            DBG_VERBOSE             10\n");
            printf("\n Current Level is %d, Current Mask is 0x%x \n", level, mask);
        }

        if(flags & FILE)
        {
            ULONG Status;

            Status = TcQueryInterface(InterfaceHandle,
                                      (LPGUID)&GUID_QOS_LOG_THRESHOLD,
                                      FALSE,
                                      &size,
                                      &DataSize);

            DataSize *= 2;

            if(NT_SUCCESS(Status))
            {
                if(DataSize != 0)
                {
                    Buffer = (PCHAR) malloc(DataSize);

                    Status = TcQueryInterface(InterfaceHandle,
                                              (LPGUID)&GUID_QOS_LOG_DATA,
                                              FALSE,
                                              &DataSize,
                                              Buffer);
                    if(NT_SUCCESS(Status))
                    {
                        ParseBuffer(Buffer, DataSize);
                    }
                    else
                    {
                        printf("Query for the data buffer failed with status %d \n", Status);
                    }

                    free(Buffer);
                }
                else
                {
                    printf("No Data in buffer. \n");
                }
            }
            else
            {
                printf("Failed to read the sched bytes unread \n");
            }
        }

        TcDone(InterfaceHandle, ClientHandle);
    }

    return 0;

usage:
    printf("Usage %s [-f | -c | -m<0xmask> | -l<level> ] \n", argv[0]);
    printf("          -f          : dump the tt log on screen.                    \n");
    printf("          -c          : Print the current value of the mask and level \n");
    printf("          -m<0xvalue> : Set the mask to this value                    \n");
    printf("          -l<value>   : Set the level to this value (0-10)            \n");

    return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\pschdprf\pschdprf.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

      PschdPrf.h

Abstract:

    Header file for the PSched Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  

--*/

#ifndef _PSCHDPRF_H_
#define _PSCHDPRF_H_

#include <winperf.h>
#include <qos.h>
#include <objbase.h>
#include <tcguid.h>
#include <traffic.h>
#include <ntddpsch.h>
#include "pschdcnt.h"


// Useful Macros


// Necessary data structures

#define PS_FRIENDLY_NAME_LENGTH 128

typedef struct _FLOW_INFO
{
    WCHAR InstanceName[MAX_STRING_LENGTH+1];
    WCHAR FriendlyName[PS_FRIENDLY_NAME_LENGTH+1];
} FLOW_INFO, *PFLOW_INFO;

typedef struct _PIPE_INFO
{
        HANDLE hIfc;                                   // (open) HANDLE to the interface
        LPTSTR IfcName;                                // Interface name
        ULONG numFlows;                                // Flow counter for this pipe
        PFLOW_INFO pFlowInfo;                          // Pointer to array of FLOW_INFOs 
} PIPE_INFO, *PPIPE_INFO;

typedef struct _PS_PERF_COUNTER_BLOCK
{
    PERF_COUNTER_BLOCK pcb;
    DWORD              pad;
} PS_PERF_COUNTER_BLOCK, *PPS_PERF_COUNTER_BLOCK;


//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundaries. Alpha support may 
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

//
//  PSched Flow Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.


// Interface specific counters
// Pipe counters
#define PIPE_OUT_OF_PACKETS_OFFSET              (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_ADAPTER_STATS, OutOfPackets))

#define PIPE_FLOWS_OPENED_OFFSET                (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_ADAPTER_STATS, FlowsOpened))

#define PIPE_FLOWS_CLOSED_OFFSET                (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_ADAPTER_STATS, FlowsClosed))

#define PIPE_FLOWS_REJECTED_OFFSET              (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_ADAPTER_STATS, FlowsRejected))

#define PIPE_FLOWS_MODIFIED_OFFSET              (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_ADAPTER_STATS, FlowsModified))

#define PIPE_FLOW_MODS_REJECTED_OFFSET          (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_ADAPTER_STATS, FlowModsRejected))

#define PIPE_MAX_SIMULTANEOUS_FLOWS_OFFSET      (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_ADAPTER_STATS, MaxSimultaneousFlows))

#define PIPE_NONCONF_PACKETS_SCHEDULED_OFFSET   (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_CONFORMER_STATS, NonconformingPacketsScheduled))

#define PIPE_AVE_PACKETS_IN_SHAPER_OFFSET       (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_CONFORMER_STATS) +                            \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_SHAPER_STATS, AveragePacketsInShaper))

#define PIPE_MAX_PACKETS_IN_SHAPER_OFFSET       (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_CONFORMER_STATS) +                            \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_SHAPER_STATS, MaxPacketsInShaper))

#define PIPE_AVE_PACKETS_IN_SEQ_OFFSET          (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_CONFORMER_STATS) +                            \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_SHAPER_STATS) +                               \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, AveragePacketsInSequencer))

#define PIPE_MAX_PACKETS_IN_SEQ_OFFSET          (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_CONFORMER_STATS) +                            \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_SHAPER_STATS) +                               \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, MaxPacketsInSequencer))

#define PIPE_MAX_PACKETS_IN_NETCARD_OFFSET      (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_CONFORMER_STATS) +                            \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_SHAPER_STATS) +                               \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, MaxPacketsInNetcard))

#define PIPE_AVE_PACKETS_IN_NETCARD_OFFSET      (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_CONFORMER_STATS) +                            \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_SHAPER_STATS) +                               \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, AveragePacketsInNetcard))

#define PIPE_NONCONF_PACKETS_TRANSMITTED_OFFSET (sizeof(PS_PERF_COUNTER_BLOCK) +                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_ADAPTER_STATS) +                              \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_CONFORMER_STATS) +                            \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 sizeof(PS_SHAPER_STATS) +                               \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +               \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, NonconformingPacketsTransmitted))

#define PIPE_PIPE_NUM_STATS         (7)
typedef struct _PS_PIPE_PIPE_STAT_DEF 
{
    PERF_COUNTER_DEFINITION     OutOfPackets;
    PERF_COUNTER_DEFINITION     FlowsOpened;
    PERF_COUNTER_DEFINITION     FlowsClosed;
    PERF_COUNTER_DEFINITION     FlowsRejected;
    PERF_COUNTER_DEFINITION     FlowsModified;
    PERF_COUNTER_DEFINITION     FlowModsRejected;
    PERF_COUNTER_DEFINITION     MaxSimultaneousFlows;
} PS_PIPE_PIPE_STAT_DEF, *PPS_PIPE_PIPE_STAT_DEF;

#define PIPE_CONFORMER_NUM_STATS    (2)
typedef struct _PS_PIPE_CONFORMER_STAT_DEF 
{
    PERF_COUNTER_DEFINITION     NonconfPacketsScheduled;
    PERF_COUNTER_DEFINITION     NonconfPacketsScheduledPerSec;
} PS_PIPE_CONFORMER_STAT_DEF, *PPS_PIPE_CONFORMER_STAT_DEF;

#define PIPE_SHAPER_NUM_STATS       (2)
typedef struct _PS_PIPE_SHAPER_STAT_DEF 
{
    PERF_COUNTER_DEFINITION     AvePacketsInShaper;
    PERF_COUNTER_DEFINITION     MaxPacketsInShaper;
} PS_PIPE_SHAPER_STAT_DEF, *PPS_PIPE_SHAPER_STAT_DEF;

#define PIPE_SEQUENCER_NUM_STATS    (6)
typedef struct _PS_PIPE_SEQUENCER_STAT_DEF
{
    PERF_COUNTER_DEFINITION     AvePacketsInSeq;
    PERF_COUNTER_DEFINITION     MaxPacketsInSeq;
    PERF_COUNTER_DEFINITION     MaxPacketsInNetcard;
    PERF_COUNTER_DEFINITION     AvePacketsInNetcard;
    PERF_COUNTER_DEFINITION     NonconfPacketsTransmitted;
    PERF_COUNTER_DEFINITION     NonconfPacketsTransmittedPerSec;
} PS_PIPE_SEQUENCER_STAT_DEF, *PPS_PIPE_SEQUENCER_STAT_DEF;


// Flow counters

#define FLOW_PACKETS_DROPPED_OFFSET             (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_FLOW_STATS, DroppedPackets))

#define FLOW_PACKETS_SCHEDULED_OFFSET           (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_FLOW_STATS, PacketsScheduled))

#define FLOW_PACKETS_TRANSMITTED_OFFSET         (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_FLOW_STATS, PacketsTransmitted))

#define FLOW_BYTES_SCHEDULED_OFFSET             (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_FLOW_STATS, BytesScheduled))

#define FLOW_BYTES_TRANSMITTED_OFFSET           (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_FLOW_STATS, BytesTransmitted))

#define FLOW_NONCONF_PACKETS_SCHEDULED_OFFSET   (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_FLOW_STATS) +                                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_CONFORMER_STATS, NonconformingPacketsScheduled))

#define FLOW_AVE_PACKETS_IN_SHAPER_OFFSET       (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_FLOW_STATS) +                                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_CONFORMER_STATS) +                                    \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_SHAPER_STATS, AveragePacketsInShaper))

#define FLOW_MAX_PACKETS_IN_SHAPER_OFFSET       (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_FLOW_STATS) +                                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_CONFORMER_STATS) +                                    \
                                                 FIELD_OFFSET(PS_SHAPER_STATS, MaxPacketsInShaper))

#define FLOW_AVE_PACKETS_IN_SEQ_OFFSET          (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_FLOW_STATS) +                                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_CONFORMER_STATS) +                                    \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_SHAPER_STATS) +                                       \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, AveragePacketsInSequencer))

#define FLOW_MAX_PACKETS_IN_SEQ_OFFSET          (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_FLOW_STATS) +                                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_CONFORMER_STATS) +                                    \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_SHAPER_STATS) +                                       \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, MaxPacketsInSequencer))

#define FLOW_MAX_PACKETS_IN_NETCARD_OFFSET     (sizeof(PS_PERF_COUNTER_BLOCK) +                                  \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                sizeof(PS_FLOW_STATS) +                                          \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                sizeof(PS_CONFORMER_STATS) +                                     \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                sizeof(PS_SHAPER_STATS) +                                        \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                FIELD_OFFSET(PS_DRRSEQ_STATS, MaxPacketsInNetcard))

#define FLOW_AVE_PACKETS_IN_NETCARD_OFFSET     (sizeof(PS_PERF_COUNTER_BLOCK) +                                  \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                sizeof(PS_FLOW_STATS) +                                          \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                sizeof(PS_CONFORMER_STATS) +                                     \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                sizeof(PS_SHAPER_STATS) +                                        \
                                                FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                        \
                                                FIELD_OFFSET(PS_DRRSEQ_STATS, AveragePacketsInNetcard))

#define FLOW_NONCONF_PACKETS_TRANSMITTED_OFFSET (sizeof(PS_PERF_COUNTER_BLOCK) +                                 \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_FLOW_STATS) +                                         \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_CONFORMER_STATS) +                                    \
                                                 FIELD_OFFSET(PS_COMPONENT_STATS, Stats) +                       \
                                                 sizeof(PS_SHAPER_STATS) +                                       \
                                                 FIELD_OFFSET(PS_DRRSEQ_STATS, NonconformingPacketsTransmitted))

#define FLOW_FLOW_NUM_STATS (10)
typedef struct _PS_FLOW_FLOW_STAT_DEF 
{
    PERF_COUNTER_DEFINITION PacketsDropped;
    PERF_COUNTER_DEFINITION PacketsScheduled;
    PERF_COUNTER_DEFINITION PacketsTransmitted;
    PERF_COUNTER_DEFINITION BytesScheduled;
    PERF_COUNTER_DEFINITION BytesTransmitted;
    PERF_COUNTER_DEFINITION BytesTransmittedPerSec;
    PERF_COUNTER_DEFINITION BytesScheduledPerSec;
    PERF_COUNTER_DEFINITION PacketsTransmittedPerSec;
    PERF_COUNTER_DEFINITION PacketsScheduledPerSec;
    PERF_COUNTER_DEFINITION PacketsDroppedPerSec;
} PS_FLOW_FLOW_STAT_DEF, *PPS_FLOW_FLOW_STAT_DEF;

#define FLOW_CONFORMER_NUM_STATS (2)
typedef struct _PS_FLOW_CONFORMER_STAT_DEF 
{
    PERF_COUNTER_DEFINITION NonconfPacketsScheduled;
    PERF_COUNTER_DEFINITION NonconfPacketsScheduledPerSec;
} PS_FLOW_CONFORMER_STAT_DEF, *PPS_FLOW_CONFORMER_STAT_DEF;

#define FLOW_SHAPER_NUM_STATS (2)
typedef struct _PS_FLOW_SHAPER_STAT_DEF 
{
    PERF_COUNTER_DEFINITION AvePacketsInShaper;
    PERF_COUNTER_DEFINITION MaxPacketsInShaper;
} PS_FLOW_SHAPER_STAT_DEF, *PPS_FLOW_SHAPER_STAT_DEF;

#define FLOW_SEQUENCER_NUM_STATS (6)
typedef struct _PS_FLOW_SEQUENCER_STAT_DEF 
{
    PERF_COUNTER_DEFINITION AvePacketsInSeq;
    PERF_COUNTER_DEFINITION MaxPacketsInSeq;
    PERF_COUNTER_DEFINITION MaxPacketsInNetcard;
    PERF_COUNTER_DEFINITION AvePacketsInNetcard;
    PERF_COUNTER_DEFINITION NonconfPacketsTransmitted;
    PERF_COUNTER_DEFINITION NonconfPacketsTransmittedPerSec;
} PS_FLOW_SEQUENCER_STAT_DEF, *PPS_FLOW_SEQUENCER_STAT_DEF;

#pragma pack ()


#endif //_PSCHDPRF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\pslog\precomp.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    User space log viewer

Author:

    Rajesh Sundaram (1st Aug, 1998)

Revision History:

--*/

#define NT 1
#define _PNP_POWER  1
#define SECFLTR 1

#include <ntverp.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//#include <windef.h>
//#include <winbase.h>
#include <windows.h>

#include <ntosp.h>
#include <ndis.h>

#include <string.h>
#include <stdio.h>
//#include <stdlib.h>

#include "psched.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\clstate.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    clstate.c

Abstract:

    state machine for gpc client vcs

Author:

    Yoram Bernet    (yoramb)    28-Dec-1997
    Rajesh Sundaram (rajeshsu)  01-Aug-1998

Environment:

    Kernel Mode

Revision History:

    Rajesh Sundaram (rajeshsu) 04-Apr-1998 - reworked completly as another state 
                                            (CL_INTERNAL_CALL_COMPLETE) added.

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */

/* Forward */

/* End Forward */

/*++

Routine Description:

    Initiate a close call on this VC and notify the GPC. Always called with the VC lock held.

Return Value:

    None

--*/
VOID
InternalCloseCall(
    PGPC_CLIENT_VC Vc
    )
{
    PADAPTER Adapter = Vc->Adapter;

    PsDbgOut(DBG_INFO,
             DBG_STATE,
             ("[InternalCloseCall]: Adapter %08X, ClVcState is %s on VC %x\n",
              Vc->Adapter, GpcVcState[Vc->ClVcState], Vc));

    switch(Vc->ClVcState){

      case CL_INTERNAL_CLOSE_PENDING:
          
          //
          // We could get here if we get an unbind at our wan instance with a 
          // NDIS_STATUS_WAN_LINE_DOWN. We could be trying to do an InternalClose
          // from both places. 
          //

          PsAssert(Vc->Flags & INTERNAL_CLOSE_REQUESTED);

          PS_UNLOCK_DPC(&Vc->Lock);

          PS_UNLOCK(&Adapter->Lock);
          
          break;
          
      case CL_CALL_PENDING:
      case CL_MODIFY_PENDING:

          //
          // We've been asked to close before the call 
          // has completed. 
          //
          // Set a flag so that we'll close it when the 
          // call completes.
          //

          PsAssert(!(Vc->Flags & GPC_CLOSE_REQUESTED));

          Vc->Flags |= INTERNAL_CLOSE_REQUESTED;

          PS_UNLOCK_DPC(&Vc->Lock);

          PS_UNLOCK(&Adapter->Lock);

          break;

      case CL_INTERNAL_CALL_COMPLETE:

          //
          // The call has been completed, but we may or may not 
          // have told the GPC. Wait till we tell the GPC. We will
          // complete this when we transistion to CL_CALL_COMPLETE
          //
          
          PsAssert(!IsBestEffortVc(Vc));
          
          Vc->Flags |= INTERNAL_CLOSE_REQUESTED;

          PS_UNLOCK_DPC(&Vc->Lock);

          PS_UNLOCK(&Adapter->Lock);
          
          break;
          
      case CL_CALL_COMPLETE:
          
          //
          // Transition to CL_INTERNAL_CLOSE_PENDING and
          // ask the GPC to close.
          //
          
          Vc->ClVcState = CL_INTERNAL_CLOSE_PENDING;

          Vc->Flags |= INTERNAL_CLOSE_REQUESTED;

          PS_UNLOCK_DPC(&Vc->Lock);

          PS_UNLOCK(&Adapter->Lock);

          CmCloseCall(Vc);

          break;
        
      case CL_GPC_CLOSE_PENDING:

          //
          // The GPC has already asked us to close. Now, 
          // we are also closing down - We need not do 
          // anything here - Need not even inform the GPC.
          // we can just pretend as the InternalClose never
          // happened

          Vc->Flags &= ~INTERNAL_CLOSE_REQUESTED;

          PS_UNLOCK_DPC(&Vc->Lock);

          PS_UNLOCK(&Adapter->Lock);

          break;
        
      default:
          
          PS_UNLOCK_DPC(&Vc->Lock);

          PS_UNLOCK(&Adapter->Lock);
          
          PsDbgOut(DBG_FAILURE,
                   DBG_STATE,
                   ("[InternalCloseCall]: invalid state %s on VC %x\n",
                    GpcVcState[Vc->ClVcState], Vc));

          PsAssert(0);
          break;
    }
}

VOID
CallSucceededStateTransition(
    PGPC_CLIENT_VC Vc
    )
{

    PsDbgOut(DBG_INFO,
             DBG_STATE,
             ("[CallSucceededStateTransition]: Adapter %08X, ClVcState is %s on VC %x\n",
              Vc->Adapter, GpcVcState[Vc->ClVcState], Vc));

    PS_LOCK(&Vc->Lock);

    switch(Vc->ClVcState){

      case CL_GPC_CLOSE_PENDING:

          PS_UNLOCK(&Vc->Lock);
          
          PsDbgOut(DBG_FAILURE,
                   DBG_STATE,
                   ("[CallSucceededStateTransition]: bad state %s on VC %x\n",
                    GpcVcState[Vc->ClVcState], Vc));
          
          PsAssert(0);

          break;

      case CL_INTERNAL_CALL_COMPLETE:
        
          PsAssert(!IsBestEffortVc(Vc));

#if DBG
          if(Vc->Flags & GPC_MODIFY_REQUESTED) {
              PsAssert(! (Vc->Flags & GPC_CLOSE_REQUESTED));
          }

          if(Vc->Flags & GPC_CLOSE_REQUESTED) {
              PsAssert(! (Vc->Flags & GPC_MODIFY_REQUESTED));
          }
#endif
          //
          // Note that if both a modify & a internal remove is requested, 
          // we just satisfy the modify. When the modify goes into internal
          // call complete, we will satify the remove
          //
          if(Vc->Flags & GPC_MODIFY_REQUESTED) {

              NDIS_STATUS Status;

              Vc->ClVcState = CL_MODIFY_PENDING;
              Vc->Flags &= ~GPC_MODIFY_REQUESTED;

              PS_UNLOCK(&Vc->Lock);

              Status = CmModifyCall(Vc);

              if(Status != NDIS_STATUS_PENDING) {
                  
                  CmModifyCallComplete(Status, Vc, Vc->ModifyCallParameters);
              }
              
              break;
              
          }
          
          if(Vc->Flags & GPC_CLOSE_REQUESTED) {
              
              // 
              // The GPC has asked us to close after it
              // was notified of the call completion but
              // before we managed to transition to the
              // CL_CALL_COMPLETE state.
              //
            
              Vc->ClVcState = CL_GPC_CLOSE_PENDING;

              PS_UNLOCK(&Vc->Lock);

              CmCloseCall(Vc);

              break;
          }
          
          if(Vc->Flags & INTERNAL_CLOSE_REQUESTED){
              
              //
              // We had an internal close request while
              // the call was pending. The GPC has already
              // been notified, so - we need to ask it to
              // close.
              //
              
              Vc->ClVcState = CL_INTERNAL_CLOSE_PENDING;

              PS_UNLOCK(&Vc->Lock);

              CmCloseCall(Vc);

              break;
          }
          
          Vc->ClVcState = CL_CALL_COMPLETE;

          PS_UNLOCK(&Vc->Lock);

          break;
          
      case CL_MODIFY_PENDING:
          //
          // Typically, just transition to CL_CALL_COMPLETE
          //
          PsAssert(!(Vc->Flags & GPC_CLOSE_REQUESTED));
          PsAssert(!(Vc->Flags & GPC_MODIFY_REQUESTED));
          PsAssert(!IsBestEffortVc(Vc));
          
          Vc->ClVcState = CL_INTERNAL_CALL_COMPLETE;
          
          PS_UNLOCK(&Vc->Lock);
          
          break;
          
      case CL_CALL_PENDING:
          //
          // Typically, just transition to CL_INTERNAL_CALL_COMPLETE.
          //
          PsAssert(!(Vc->Flags & GPC_CLOSE_REQUESTED));
          PsAssert(!(Vc->Flags & GPC_MODIFY_REQUESTED));
          
          //
          // Call succeeded. Leave it up.
          //
          if(IsBestEffortVc(Vc)) 
          {
              Vc->ClVcState = CL_CALL_COMPLETE;
          }
          else 
          {
            Vc->ClVcState = CL_INTERNAL_CALL_COMPLETE;
          }
          PS_UNLOCK(&Vc->Lock);

          break;
          
      default:
          
          PS_UNLOCK(&Vc->Lock);
          
          PsDbgOut(DBG_FAILURE,
                   DBG_STATE,
                   ("[CallSucceededStateTransition]: invalid state %s on VC %x\n",
                    GpcVcState[Vc->ClVcState], Vc));
          
          PsAssert(0);
    }
}

        
/* end clstate.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\clstate.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    clstate.h

Abstract:

    defines for gpc client state machine code

Author:

    Yoram Bernet (yoramb) 28-Dec-1997

Revision History:

--*/

#ifndef _CLSTATE_
#define _CLSTATE_

/* Prototypes */

VOID
InternalCloseCall(
    PGPC_CLIENT_VC Vc
    );

VOID
CallSucceededStateTransition(
    PGPC_CLIENT_VC Vc
    );

/* End Prototypes */

#endif /* _CLSTATE_ */

/* end clstate.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\adapter.c ===
/*++
Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    adapter.c

Abstract:

    routines for binding/unbinding to/from underlying miniport drivers

Author:
    Charlie Wickham (charlwi)  24-Apr-1996.
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

/* Defines */


/* External */

/* Static */

#define DRIVER_COUNTED_BLOCK             \
{                                        \
    ++DriverRefCount;                    \
    NdisResetEvent(&DriverUnloadEvent);  \
}

#define DRIVER_COUNTED_UNBLOCK                     \
        {                                          \
            PS_LOCK(&DriverUnloadLock);            \
            if( --DriverRefCount == 0)             \
                NdisSetEvent(&DriverUnloadEvent);  \
            PS_UNLOCK(&DriverUnloadLock);          \
        } 

/* Forward */ 

NDIS_STATUS
PsInitializeDeviceInstance(PADAPTER Adapter);

NDIS_STATUS
GetFrameSize(
    PADAPTER Adapter
    );

NDIS_STATUS
InitializeAdapter(
    PADAPTER Adapter, 
    NDIS_HANDLE BindContext, 
    PNDIS_STRING MpDeviceName, 
    PVOID SystemSpecific1);

NDIS_STATUS
UpdateSchedulingPipe(
    PADAPTER Adapter
    );

VOID
DeleteAdapter(PVOID Adapter, BOOLEAN AdapterListLocked);

VOID
ClUnloadProtocol(
    VOID
    );

VOID
MpHalt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS
MpReset(
    OUT PBOOLEAN    AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS
GetSchedulerPipeContext(
    PADAPTER Adapter,
    PPS_PIPE_CONTEXT *AdapterPipeContext,
    PPSI_INFO *AdapterPsComponent,
    PULONG ShutdownMask
    );

NDIS_STATUS
FindProfile(
    IN PNDIS_STRING ProfileName,
    OUT PPS_PROFILE *Profile
    );

NDIS_STATUS
RegisterPsComponent(
    IN PPSI_INFO PsiComponentInfo,
    ULONG Size,
    PPS_DEBUG_INFO DebugInfo
    );

NDIS_STATUS
FindSchedulingComponent(
    IN PNDIS_STRING ComponentName,
    OUT PPSI_INFO *Component
    );

NDIS_STATUS
PsReadMiniportOIDs(
    IN  PADAPTER Adapter
    );

VOID
CloseAllGpcVcs(
    IN PADAPTER Adapter);

/* End Forward */


NTSTATUS
PsIoctl(
        IN      PDEVICE_OBJECT  pdo,
        IN      PIRP            pirp
        )
{
    PIO_STACK_LOCATION     pirpSp;
    ULONG                  ioControlCode;
    PLIST_ENTRY            NextAdapter;
    PADAPTER               Adapter;
    NTSTATUS               Status ;
    PGPC_CLIENT_VC         Vc;
    PLIST_ENTRY            NextVc;
    PPS_WAN_LINK           WanLink;
    
    PVOID                   pIoBuf;
    ULONG                   InputBufferLength;
    ULONG                   OutputBufferLength;

    USHORT				    Port = 0;
    ULONG				    Ip = 0;
    PTIMESTMP_REQ           pTsReq = NULL;


#if DBG
    KIRQL                   OldIrql;
    KIRQL                   NewIrql;
    OldIrql = KeGetCurrentIrql();
#endif

    pirpSp        = IoGetCurrentIrpStackLocation(pirp);
    ioControlCode = pirpSp->Parameters.DeviceIoControl.IoControlCode;

    pirp->IoStatus.Status      = Status = STATUS_SUCCESS;
    pirp->IoStatus.Information = 0;

    /* Both input and output buffers are mapped to "SystemBuffer" in case of direct-IO */
    pIoBuf      = pirp->AssociatedIrp.SystemBuffer;

    InputBufferLength  	= pirpSp->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength 	= pirpSp->Parameters.DeviceIoControl.OutputBufferLength;

    switch(pirpSp->MajorFunction)
    {
        case IRP_MJ_DEVICE_CONTROL:

            switch (ioControlCode) 
            {            
                case IOCTL_PSCHED_ZAW_EVENT:
                {

                    while(InterlockedExchange(&gZAWState, ZAW_STATE_IN_USE) != ZAW_STATE_READY)
                    {
                        //
                        // Some other thread is in this loop. Let's wait 
                        //
                        NdisResetEvent(&gZAWEvent);
                        NdisWaitEvent(&gZAWEvent, 0);
                    }

                    PsReadDriverRegistryData();
                   
                    //
                    // Handle the per adapter settings.
                    //
            
                    PS_LOCK(&AdapterListLock);
            
                    NextAdapter = AdapterList.Flink;

                    while(NextAdapter != &AdapterList) 
                    {
                        Adapter = CONTAINING_RECORD(NextAdapter, ADAPTER, Linkage);
                        
                        PS_LOCK_DPC(&Adapter->Lock);
            
                        if(Adapter->PsMpState != AdapterStateRunning)
                        {
                            PS_UNLOCK_DPC(&Adapter->Lock);

                            NextAdapter = NextAdapter->Flink;

                            continue;
                        }
                        
                        REFADD(&Adapter->RefCount, 'IOTL'); 
            
                        PS_UNLOCK_DPC(&Adapter->Lock);

                        PS_UNLOCK(&AdapterListLock);
            
                        PsReadAdapterRegistryData(Adapter,
                                                  &MachineRegistryKey,
                                                  &Adapter->RegistryPath
                                                  );
                        //
                        // This will apply the effects of the following registry parameters.
                        //
                        // NonBestEffortLimit
                        // TimerResolution (since we update the scheduling pipe)
                        //

                        if(Adapter->MediaType != NdisMediumWan)
                        {
                            UpdateAdapterBandwidthParameters(Adapter);
                            
                            //
                            // Set 802.1p/TOS for b/e Vc
                            //
                            Adapter->BestEffortVc.UserPriorityConforming    = Adapter->UserServiceTypeBestEffort;
                            Adapter->BestEffortVc.UserPriorityNonConforming = Adapter->UserServiceTypeNonConforming;
                            Adapter->BestEffortVc.IPPrecedenceNonConforming = Adapter->IPServiceTypeBestEffortNC;
                        }
                        else
                        {
                            PS_LOCK(&Adapter->Lock);
                            
                            NextVc = Adapter->WanLinkList.Flink;
                            
                            while( NextVc != &Adapter->WanLinkList)
                            {
                                WanLink = CONTAINING_RECORD(NextVc, PS_WAN_LINK, Linkage);
                                
                                PS_LOCK_DPC(&WanLink->Lock);
                                
                                WanLink->BestEffortVc.UserPriorityConforming    = Adapter->UserServiceTypeBestEffort;
                                WanLink->BestEffortVc.UserPriorityNonConforming = Adapter->UserServiceTypeNonConforming;
                                WanLink->BestEffortVc.IPPrecedenceNonConforming = 
                                    Adapter->IPServiceTypeBestEffortNC;
                                
                                if(WanLink->State == WanStateOpen)
                                {
                                    REFADD(&WanLink->RefCount, 'IOTL');
                                    
                                    PS_UNLOCK_DPC(&WanLink->Lock);
                                    
                                    PS_UNLOCK(&Adapter->Lock);
                                    
                                    UpdateWanLinkBandwidthParameters(WanLink);
                                    
                                    PS_LOCK(&Adapter->Lock);
                                    
                                    NextVc = NextVc->Flink;
                                    
                                    REFDEL(&WanLink->RefCount, TRUE, 'IOTL');
                                    
                                }
                                else 
                                {
                                    PS_UNLOCK_DPC(&WanLink->Lock);
                                    
                                    NextVc = NextVc->Flink;
                                    
                                }
                            }
                            
                            PS_UNLOCK(&Adapter->Lock);
                            
                        }

                        //
                        // Apply the new TOS/802.1p mapping to the VCs.
                        //
                        PS_LOCK(&Adapter->Lock);
                        
                        NextVc = Adapter->GpcClientVcList.Flink;
                        
                        while ( NextVc != &Adapter->GpcClientVcList )
                        {
                            
                            Vc = CONTAINING_RECORD(NextVc, GPC_CLIENT_VC, Linkage);
                            
                            NextVc = NextVc->Flink;
                            
                            PS_LOCK_DPC(&Vc->Lock);
                            
                            if(Vc->ClVcState == CL_CALL_COMPLETE          ||
                               Vc->ClVcState == CL_INTERNAL_CALL_COMPLETE )
                            {
                                SetTOSIEEEValues(Vc);
                            }
                            
                            PS_UNLOCK_DPC(&Vc->Lock);
                        }
                        
                        PS_UNLOCK(&Adapter->Lock);

                        PS_LOCK(&AdapterListLock);

                        NextAdapter = NextAdapter->Flink;
                   
                        REFDEL(&Adapter->RefCount, TRUE, 'IOTL'); 
                    
                    }
                
                    PS_UNLOCK(&AdapterListLock);

                    InterlockedExchange(&gZAWState, ZAW_STATE_READY);
                    NdisSetEvent(&gZAWEvent);

                    break;
                }

                case IOCTL_TIMESTMP_REGISTER_IN_PKT:
                {
                    if(InputBufferLength < sizeof(TIMESTMP_REQ))
                    {
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }
                
                    pTsReq = (PTIMESTMP_REQ)pIoBuf;

        			if( !AddRequest(    pirpSp->FileObject, 
                			            pTsReq->SrcIp, 
                			            pTsReq->SrcPort,
                			            pTsReq->DstIp,
                			            pTsReq->DstPort,
                			            pTsReq->Proto,
                			            MARK_IN_PKT,
                			            pTsReq->Direction) )
                    {                			            
        			            Status = STATUS_INSUFFICIENT_RESOURCES;
                    }        			            

                	break;
                }

                case IOCTL_TIMESTMP_DEREGISTER_IN_PKT:
                {
                    if(InputBufferLength < sizeof(TIMESTMP_REQ))
                    {
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }

                    pTsReq = (PTIMESTMP_REQ)pIoBuf;

        			RemoveRequest(  pirpSp->FileObject, 
                                    pTsReq->SrcIp, 
                                    pTsReq->SrcPort,
                                    pTsReq->DstIp,
                                    pTsReq->DstPort,
                                    pTsReq->Proto );
                	break;
                }

                case IOCTL_TIMESTMP_REGISTER_IN_BUF:
                {
                    if(InputBufferLength < sizeof(TIMESTMP_REQ))
                    {
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }

                    pTsReq = (PTIMESTMP_REQ)pIoBuf;

        			if( !AddRequest(    pirpSp->FileObject, 
                			            pTsReq->SrcIp, 
                			            pTsReq->SrcPort,
                			            pTsReq->DstIp,
                			            pTsReq->DstPort,
                			            pTsReq->Proto,
                			            MARK_IN_BUF,
                			            pTsReq->Direction))
                    {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }

                	break;
                }

                case IOCTL_TIMESTMP_DEREGISTER_IN_BUF:
                {
                    if(InputBufferLength < sizeof(TIMESTMP_REQ))
                    {
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }

                    pTsReq = (PTIMESTMP_REQ)pIoBuf;

        			RemoveRequest(  pirpSp->FileObject, 
            			            pTsReq->SrcIp, 
            			            pTsReq->SrcPort,
            			            pTsReq->DstIp,
            			            pTsReq->DstPort,
            			            pTsReq->Proto );
                	break;
                }

                case IOCTL_TIMESTMP_FINISH_BUFFERING:
                {
                    pirp->IoStatus.Information = CopyTimeStmps( pirpSp->FileObject, pIoBuf, OutputBufferLength);
                    break;
                }                    

	        break;
            }

            break;
        
        case IRP_MJ_CREATE:
            break;
                
        case IRP_MJ_CLOSE:
            RemoveRequest(  pirpSp->FileObject, 
                            UL_ANY, 
                            US_ANY,
                            UL_ANY,
                            US_ANY,
                            US_ANY);
            break;

        case IRP_MJ_CLEANUP:
            break;

        case IRP_MJ_READ:
            break;

        case IRP_MJ_SHUTDOWN:
            break;            
                
        default:
            Status = STATUS_NOT_SUPPORTED;
            break;
    }


    if( Status == STATUS_SUCCESS)
    {
        pirp->IoStatus.Status      = Status;
        IoCompleteRequest(pirp, IO_NETWORK_INCREMENT);
    }
    else
    {
        pirp->IoStatus.Status = Status;
        IoCompleteRequest(pirp, IO_NO_INCREMENT);
    }

    PsAssert( OldIrql == KeGetCurrentIrql());

    return Status;
}

NDIS_STATUS
PsIoctlInit()
{
    int                 i;
    NDIS_STATUS         Status;
    PDRIVER_DISPATCH    DispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1];

    for(i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
    {
        DispatchTable[i] = PsIoctl;
    }

    DispatchTable[IRP_MJ_SYSTEM_CONTROL] = WMIDispatch;

    Status = NdisMRegisterDevice(MpWrapperHandle,
                                 &PsDriverName,
                                 &PsSymbolicName,
                                 DispatchTable,
                                 &PsDeviceObject,
                                 &PsDeviceHandle);

    if(Status == NDIS_STATUS_SUCCESS) 
    {
        InitShutdownMask |= SHUTDOWN_DELETE_DEVICE;

        PsDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        IoWMIRegistrationControl(PsDeviceObject, WMIREG_ACTION_REGISTER);
    }
    else 
    {
        PsDeviceHandle = PsDeviceObject = 0;
    }
    return Status;

}

VOID
PsAddDevice()
{
    //
    // The first Adapter will create the DeviceObject which will enable us to receive 
    // irps and become a WMI data provider. The last DeviceObject will unregister from
    // WMI and delete the DeviceObject. 
    //

    MUX_ACQUIRE_MUTEX( &CreateDeviceMutex );

    ++AdapterCount;

    if(AdapterCount == 1) 
    {
        //
        // This is the first adapter, so we create a DeviceObject
        // that allows us to get irps and registers as a WMI data
        // provider.

        PsIoctlInit();
    }

    MUX_RELEASE_MUTEX( &CreateDeviceMutex);
}

NDIS_STATUS
PsInitializeDeviceInstance(PADAPTER Adapter)
{
    NDIS_STATUS Status;

    PsAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    PsDbgOut(DBG_INFO, 
             DBG_PROTOCOL,
             ("[PSInitializeDeviceInstance]: Adapter %08X, InitializeDeviceInstance with %ws \n",
              Adapter, 
              Adapter->UpperBinding.Buffer));
        
    Status = NdisIMInitializeDeviceInstanceEx(LmDriverHandle,
                                              &Adapter->UpperBinding,
                                              Adapter);
    if (Status != NDIS_STATUS_SUCCESS) 
    {
        PsDbgOut(DBG_FAILURE, 
                 DBG_PROTOCOL,
                 ("[PsInitializeDeviceInstance]: Adapter %08X, can't init PS device (%08X)\n",
                  Adapter, 
                  Status));
        
        PsAdapterWriteEventLog(
            EVENT_PS_INIT_DEVICE_FAILED,
            0,
            &Adapter->MpDeviceName,
            sizeof(Status),
            &Status);
        
    }
    
    return Status;
}

VOID
PsDeleteDevice()
{
    //
    // The first Adapter will create the DeviceObject which will enable us to receive 
    // irps and become a WMI data provider. The last DeviceObject will unregister from
    // WMI and delete the DeviceObject. In order to prevent a race condition we prevent 
    // any mpinitialize threads from looking at the AdapterCount. This is achieved by 
    // re-setting the WMIAddEvent. It is not sufficient just to do this based on 
    // interlocked operations on AdapterCount.
    //

    MUX_ACQUIRE_MUTEX( &CreateDeviceMutex );

    --AdapterCount;
    
    if(AdapterCount == 0) 
    {
        //
        // Delete the DeviceObject, since this is the last Adapter.
        //
        
        if(PsDeviceObject) 
        {
            IoWMIRegistrationControl(PsDeviceObject, WMIREG_ACTION_DEREGISTER);
            
            NdisMDeregisterDevice(PsDeviceHandle);
            
            PsDeviceHandle = PsDeviceObject = 0;
        }
    }

    MUX_RELEASE_MUTEX( &CreateDeviceMutex);
}


// No of retries to query the frame size
#define	MAX_GET_FRAME_SIZE_RETRY_COUNT	3
#define	WAIT_TIME_FOR_GET_FRAME_SIZE	3



VOID
ClBindToLowerMp(
    OUT     PNDIS_STATUS                    Status,
    IN      NDIS_HANDLE                     BindContext,
    IN      PNDIS_STRING                    MpDeviceName,
    IN      PVOID                           SystemSpecific1,
    IN      PVOID                           SystemSpecific2
    )

/*++

Routine Description:

    Bind to the underlying MP. Allocate space for an adapter structure,
    initializing its fields. Try to open the adapter indicated in MpDeviceName.

Arguments:

    Status          : Placeholder for the driver to return a Status to NDIS.

    BindContext     : Handle represents NDIS's context for the bind request. 
                      This has to be saved and returned when we call 
                      NdisCompleteBindAdapter

    SystemSpecific1 : Points to a registy path for the driver to obtain adapter 
                      specific configuration.
                      
    MpDeviceName    : DeviceName can refer to a NIC managed by an underlying NIC 
                      driver, or it can be the name of a virtual NIC exported by 
                      an intermediate NDIS driver that is layered between the 
                      called intermediate driver and the NIC driver managing the 
                      adapter to which transmit requests are directed. 

    SystemSpecific2 : Unused, reserved for future use.


Return Values:

    None

--*/

{
    PADAPTER    Adapter;
    NDIS_STATUS OpenAdapterStatus;
    NDIS_STATUS OpenErrorStatus;
    NDIS_STATUS LocalStatus;
    UINT        MediaIndex;
    NDIS_MEDIUM MediumArray[] = {
        NdisMediumFddi,
        NdisMedium802_5,
        NdisMedium802_3,
        NdisMediumWan
        };
    UINT        MediumArraySize = sizeof(MediumArray)/sizeof(NDIS_MEDIUM);
    UINT		GetFrameSizeRetryCount = 0;

    PsDbgOut(DBG_INFO, 
             DBG_PROTOCOL | DBG_INIT, 
             ("[ClBindToLowerMp]: MpDeviceName %ws\n", MpDeviceName->Buffer));


    PS_LOCK(&DriverUnloadLock);

    //
    // (a) The driver can get unloaded before we complete the bind thread. 
    // (b) we can get bound as the driver is getting unloaded. 
    //
    // if (a) happens, we block the driver unload and unblock when we finish the bind.
    // if (b) happens, we fail the bind call.

    if(gDriverState != DriverStateLoaded) {

        *Status = NDIS_STATUS_FAILURE;

        PS_UNLOCK(&DriverUnloadLock);

        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL|DBG_INIT, 
                 ("[ClBindToLowerMp]: Driver is being unloaded \n"));

        return;
    }

    DRIVER_COUNTED_BLOCK;

    PS_UNLOCK(&DriverUnloadLock);

    //
    // Get a new adapter context struct and initialize it with configuration
    // data from the registry.
    //

    PsAllocatePool(Adapter, sizeof(ADAPTER), AdapterTag);

    if(Adapter == NULL) {

        PsAdapterWriteEventLog(
            (ULONG)EVENT_PS_RESOURCE_POOL,
            0,
            MpDeviceName,
            0,
            NULL);

        *Status = NDIS_STATUS_RESOURCES;

        DRIVER_COUNTED_UNBLOCK;

        return;
    }

    // 
    // Initialize the adapter. 
    //

    *Status = InitializeAdapter(Adapter, BindContext, MpDeviceName, SystemSpecific1);

    Adapter->ShutdownMask |= SHUTDOWN_BIND_CALLED;

    if(*Status != NDIS_STATUS_SUCCESS) {

        PsDeleteDevice();

        REFDEL(&Adapter->RefCount, FALSE, 'NDOP');

        DRIVER_COUNTED_UNBLOCK;

        return;
    }


    NdisOpenAdapter(&OpenAdapterStatus,
                    &OpenErrorStatus,
   