 (pNote->rtTime/REF_PER_MIL));
                }
                else
                {
                    TraceI(5, "PLAY %d @%d: %x [%d]{%x}\n", rPartRef.m_dwLogicalPartID, pNote->mtTime,
                        pNote->wMusicValue, pNote->bMidiValue, Variations(rPartRef, nPart));
                }
                if(FAILED(pPerformance->SendPMsg( (DMUS_PMSG*)pNote) ))
                {
                    pPerformance->FreePMsg( (DMUS_PMSG*)pNote);
                }
            }
        }
    }
}


void PatternTrackState::SendTimeSigMessage(MUSIC_TIME mtNow, MUSIC_TIME mtOffset, MUSIC_TIME mtTime, IDirectMusicPerformance* pPerformance)
{
    if (!m_pStyle) return;
    IDirectMusicGraph* pGraph = NULL;
    DMUS_TIMESIG_PMSG* pTimeSig;
    if( FAILED( m_pSegState->QueryInterface( IID_IDirectMusicGraph,
        (void**)&pGraph )))
    {
        pGraph = NULL;
    }
    if( SUCCEEDED( pPerformance->AllocPMsg( sizeof(DMUS_TIMESIG_PMSG),
        (DMUS_PMSG**)&pTimeSig )))
    {
        if( mtTime < mtNow )
        {
            // this only happens in the case where we've puposefully seeked
            // and need to time stamp this event with the start time
            pTimeSig->mtTime = mtNow + mtOffset;
        }
        else
        {
            pTimeSig->mtTime = mtTime + mtOffset;
        }
        pTimeSig->bBeatsPerMeasure = m_pStyle->m_TimeSignature.m_bBeatsPerMeasure;
        pTimeSig->bBeat = m_pStyle->m_TimeSignature.m_bBeat;
        pTimeSig->wGridsPerBeat = m_pStyle->m_TimeSignature.m_wGridsPerBeat;
        pTimeSig->dwFlags |= DMUS_PMSGF_MUSICTIME;
        pTimeSig->dwVirtualTrackID = m_dwVirtualTrackID;
        pTimeSig->dwType = DMUS_PMSGT_TIMESIG;
        pTimeSig->dwGroupID = m_dwGroupID;

        if( pGraph )
        {
            pGraph->StampPMsg( (DMUS_PMSG*)pTimeSig );
            pGraph->Release();
        }
        TraceI(3, "TimeSigtrk: TimeSig event\n");
        if(FAILED(pPerformance->SendPMsg( (DMUS_PMSG*)pTimeSig )))
        {
            pPerformance->FreePMsg( (DMUS_PMSG*)pTimeSig );
        }
    }
}

// send measure and beat notifications
MUSIC_TIME PatternTrackState::NotifyMeasureBeat(
    MUSIC_TIME mtStart, MUSIC_TIME mtEnd, MUSIC_TIME mtOffset, IDirectMusicPerformance* pPerformance, DWORD dwFlags )
{
    if (dwFlags & DMUS_TRACKF_NOTIFY_OFF)
    {
        return S_OK;
    }

    DMUS_NOTIFICATION_PMSG* pEvent = NULL;
    BYTE bCurrentBeat;
    WORD wCurrentMeasure;
    DirectMusicTimeSig& rTimeSig = PatternTimeSig();

    // now actually generate the beat events.
    // Generate events that are on beat boundaries, from mtStart to mtEnd
    long lQuantize = ( DMUS_PPQ * 4 ) / rTimeSig.m_bBeat;
    long lAbsoluteBeat = mtStart / lQuantize;

    bCurrentBeat = (BYTE) (lAbsoluteBeat % rTimeSig.m_bBeatsPerMeasure);
    wCurrentMeasure = (WORD) (lAbsoluteBeat / rTimeSig.m_bBeatsPerMeasure);
    while( mtStart < mtEnd )
    {
        if( SUCCEEDED( pPerformance->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG),
            (DMUS_PMSG**)&pEvent )))
        {
            pEvent->dwField1 = 0;
            pEvent->dwField2 = 0;
            pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
            pEvent->mtTime = mtStart + mtOffset;
            pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
            m_pSegState->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

            pEvent->dwNotificationOption = DMUS_NOTIFICATION_MEASUREBEAT;
            pEvent->dwField1 = bCurrentBeat;
            pEvent->dwField2 = wCurrentMeasure;
            pEvent->guidNotificationType = GUID_NOTIFICATION_MEASUREANDBEAT;
            pEvent->dwGroupID = m_dwGroupID;

            IDirectMusicGraph* pGraph;
            if( SUCCEEDED( m_pSegState->QueryInterface( IID_IDirectMusicGraph,
                (void**)&pGraph )))
            {
                pGraph->StampPMsg((DMUS_PMSG*) pEvent );
                pGraph->Release();
            }
            if(FAILED(pPerformance->SendPMsg((DMUS_PMSG*) pEvent )))
            {
                pPerformance->FreePMsg( (DMUS_PMSG*)pEvent);;
            }
        }
        bCurrentBeat++;
        if( bCurrentBeat >= rTimeSig.m_bBeatsPerMeasure )
        {
            bCurrentBeat = 0;
            wCurrentMeasure++;
        }
        mtStart += lQuantize;
    }
    return mtEnd;
}

MUSIC_TIME PatternTrackState::PartOffset(int nPartIndex)
{
    return m_pmtPartOffset[nPartIndex];
}

/////////////////////////////////////////////////////////////////////////////
// PatternTrackInfo

PatternTrackInfo::PatternTrackInfo() :
    m_fNotifyMeasureBeat(FALSE), m_dwPChannels(0), m_pdwPChannels(NULL),
    m_fActive(TRUE),
//  m_fTrackPlay(TRUE),
    m_fStateSetBySetParam(FALSE),
//  m_fStatePlaySetBySetParam(FALSE),
    m_fChangeStateMappings(FALSE),
    m_lRandomNumberSeed(0),
    m_dwValidate(0),
    m_pVariations(NULL),
    m_pdwRemoveVariations(NULL)
{
}

PatternTrackInfo::PatternTrackInfo(
        const PatternTrackInfo* pInfo, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) :
    m_dwPChannels(0), m_pdwPChannels(NULL), m_lRandomNumberSeed(0), m_dwValidate(0),
    m_pVariations(NULL), m_pdwRemoveVariations(NULL)
{
    if (pInfo)
    {
        m_fChangeStateMappings = pInfo->m_fChangeStateMappings;
        m_fNotifyMeasureBeat = pInfo->m_fNotifyMeasureBeat;
        m_fActive = pInfo->m_fActive;
//      m_fTrackPlay = pInfo->m_fTrackPlay;
        m_fStateSetBySetParam = pInfo->m_fStateSetBySetParam;
//      m_fStatePlaySetBySetParam = pInfo->m_fStatePlaySetBySetParam;
    }
    TListItem<StylePair>* pScan = pInfo->m_pISList.GetHead();
    //1////////////////////////////////////////
    TListItem<StylePair>* pPrevious = NULL;
    //1////////////////////////////////////////
    for(; pScan; pScan = pScan->GetNext())
    {
        StylePair& rScan = pScan->GetItemValue();
        //2////////////////////////////////////////
        if (rScan.m_mtTime < mtStart)
        {
            pPrevious = pScan;
        }
        //2////////////////////////////////////////
        else if (rScan.m_mtTime < mtEnd)
        {
            //3////////////////////////////////////////
            if (rScan.m_mtTime == mtStart)
            {
                pPrevious = NULL;
            }
            //3////////////////////////////////////////
            TListItem<StylePair>* pNew = new TListItem<StylePair>;
            if (pNew)
            {
                StylePair& rNew = pNew->GetItemValue();
                rNew.m_mtTime = rScan.m_mtTime - mtStart;
                rNew.m_pStyle = rScan.m_pStyle;
                if (rNew.m_pStyle) rNew.m_pStyle->AddRef();
                m_pISList.AddTail(pNew);
            }
        }
    }
    //4////////////////////////////////////////
    if (pPrevious)
    {
        TListItem<StylePair>* pNew = new TListItem<StylePair>;
        if (pNew)
        {
            StylePair& rNew = pNew->GetItemValue();
            rNew.m_mtTime = 0;
            rNew.m_pStyle = pPrevious->GetItemValue().m_pStyle;
            if (rNew.m_pStyle) rNew.m_pStyle->AddRef();
            m_pISList.AddHead(pNew);
        }
    }
    //4////////////////////////////////////////
}

PatternTrackInfo::~PatternTrackInfo()
{
    if (m_pdwPChannels) delete [] m_pdwPChannels;
    if (m_pVariations) delete [] m_pVariations;
    if (m_pdwRemoveVariations) delete [] m_pdwRemoveVariations;
}

PatternTrackState* PatternTrackInfo::FindState(IDirectMusicSegmentState* pSegState)
{
    TListItem<StatePair>* pPair = m_StateList.GetHead();
    for (; pPair; pPair = pPair->GetNext())
    {
        if (pPair->GetItemValue().m_pSegState == pSegState)
        {
            return pPair->GetItemValue().m_pStateData;
        }
    }
    return NULL;
}

HRESULT PatternTrackInfo::EndPlay(PatternTrackState* pStateData)
{
    if (!pStateData) return E_FAIL;
    for (TListItem<StatePair>* pScan = m_StateList.GetHead(); pScan; pScan = pScan->GetNext())
    {
        StatePair& rPair = pScan->GetItemValue();
        if (pStateData == rPair.m_pStateData)
        {
            rPair.m_pSegState = NULL;
            rPair.m_pStateData = NULL;
            break;
        }
    }
    delete pStateData;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE PatternTrackInfo::AddNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    if( rGuidNotify == GUID_NOTIFICATION_MEASUREANDBEAT )
    {
        m_fNotifyMeasureBeat = TRUE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE PatternTrackInfo::RemoveNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    if( rGuidNotify == GUID_NOTIFICATION_MEASUREANDBEAT )
    {
        m_fNotifyMeasureBeat = FALSE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT PatternTrackInfo::InitTrackVariations(CDirectMusicPattern* pPattern)
{
    HRESULT hr = S_OK;
    if ( pPattern && (pPattern->m_dwFlags & DMUS_PATTERNF_PERSIST_CONTROL) )
    {
        // delete the variation arrays if they exist;
        if (m_pVariations)
        {
            delete [] m_pVariations;
            m_pVariations = NULL;
        }
        if (m_pdwRemoveVariations)
        {
            delete [] m_pdwRemoveVariations;
            m_pdwRemoveVariations = NULL;
        }
        // init the variation arrays to the number of parts in the pattern
        int nPartCount = pPattern->m_PartRefList.GetCount();
        m_pVariations = new BYTE[nPartCount];
        if (!m_pVariations)
        {
            return E_OUTOFMEMORY;
        }
        m_pdwRemoveVariations = new DWORD[nPartCount];
        if (!m_pdwRemoveVariations)
        {
            return E_OUTOFMEMORY;
        }
        for (int i = 0; i < nPartCount; i++)
        {
            m_pVariations[i] = -1;
            m_pdwRemoveVariations[i] = 0;
        }
    }
    return hr;
}

HRESULT PatternTrackInfo::MergePChannels()
{
    TList<DWORD> PChannelList;
    DMStyleStruct* pStruct = NULL;
    HRESULT hr = S_OK;

    TListItem<StylePair>* pScan = m_pISList.GetHead();
    for( ; pScan; pScan = pScan->GetNext())
    {
        if (pScan->GetItemValue().m_pStyle)
        {
            pScan->GetItemValue().m_pStyle->GetStyleInfo((void**)&pStruct);
            TListItem<DWORD>* pChannel = pStruct->m_PChannelList.GetHead();
            for (; pChannel; pChannel = pChannel->GetNext() )
            {
                AdjoinPChannel(PChannelList, pChannel->GetItemValue() );
            }
        }
    }
    if (PChannelList.IsEmpty())
    {
        AdjoinPChannel(PChannelList, 0);
    }

    TListItem<DWORD>* pPChannel = PChannelList.GetHead();

    m_dwPChannels = pPChannel->GetCount();
    if (m_pdwPChannels) delete [] m_pdwPChannels;
    m_pdwPChannels = new DWORD[m_dwPChannels];
    if (!m_pdwPChannels)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        for (int i = 0; i < (int)m_dwPChannels; i++)
        {
            m_pdwPChannels[i] = pPChannel->GetItemValue();
            pPChannel = pPChannel->GetNext();
        }
        m_fChangeStateMappings = TRUE;
    }
    return hr;
}

inline int CurveIndex(CDirectMusicEventItem* pEvent)
{
    CDMStyleCurve* pCurve = NULL;
    if (pEvent->m_dwEventTag == DMUS_EVENT_CURVE)
    {
        pCurve = (CDMStyleCurve*)pEvent;
        switch (pCurve->m_bEventType)
        {
        case DMUS_CURVET_CCCURVE:
            return pCurve->m_bCCData & 0x7f;
        case DMUS_CURVET_PATCURVE:
            return (pCurve->m_bCCData & 0x7f) + 128;
        case DMUS_CURVET_PBCURVE:
            return 256;
        case DMUS_CURVET_MATCURVE:
            return 257;
        default:
            return -1;
        }
    }
    return -1;
}

CurveSeek::CurveSeek()
{
    for (int nType = 0; nType < CURVE_TYPES; nType++)
    {
        m_apCurves[nType] = NULL;
        m_amtTimeStamps[nType] = 0;
    }
    m_fFoundCurve = false;
}

void CurveSeek::AddCurve(CDirectMusicEventItem* pEvent, MUSIC_TIME mtTimeStamp)
{
    int nIndex = CurveIndex(pEvent);
    if (nIndex >= 0)
    {
        if (!m_apCurves[nIndex] ||
            m_amtTimeStamps[nIndex] < mtTimeStamp)
        {
            m_apCurves[nIndex] = pEvent;
            m_amtTimeStamps[nIndex] = mtTimeStamp;
            m_fFoundCurve = true;
        }
    }
}

void CurveSeek::PlayCurves(
        PatternTrackState* pStateData,
        DirectMusicTimeSig& TimeSig,
        MUSIC_TIME mtPatternOffset,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerformance,
        short nPart,
        DirectMusicPartRef& rPartRef,
        BOOL fClockTime,
        MUSIC_TIME mtPartStart)
{
    if (m_fFoundCurve)
    {
        for (int nType = 0; nType < CURVE_TYPES; nType++)
        {
            CDirectMusicEventItem* pScan = m_apCurves[nType];
            if (pScan)
            {
                int nGrid = pScan->m_nGridStart;
                CDirectMusicEventItem* pWinner = pScan;
                MUSIC_TIME mtBiggest = pWinner->m_nTimeOffset;
                for (; pScan && pScan->m_nGridStart == nGrid; pScan = pScan->GetNext())
                {
                    if (pScan->m_dwEventTag == DMUS_EVENT_CURVE &&
                        pScan->m_nTimeOffset > mtBiggest)
                    {
                        pWinner = pScan;
                        mtBiggest = pWinner->m_nTimeOffset;
                    }
                }
                MUSIC_TIME mtNow = 0;
                bool fChange = false;
                pStateData->BumpTime(pWinner, TimeSig, mtPatternOffset, mtNow);
                pStateData->PlayPatternEvent(
                    mtNow,
                    pWinner,
                    TimeSig,
                    mtPatternOffset,
                    mtOffset,
                    rtOffset,
                    pPerformance,
                    nPart,
                    rPartRef,
                    fClockTime,
                    mtPartStart,
                    fChange);
            }
        }
        m_fFoundCurve = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\sjdefs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       sjdefs.h
//
//--------------------------------------------------------------------------

#ifndef __SJ_DEFINES_H__
#define __SJ_DEFINES_H__

//#define DEFAULT_STYLE_PATH "\\multim~1\\music\\intera~1\\"

// Score defines

#define VNUM        16  // Total number of variations
#define LAST_INSTR  5   // Total number of displayed instr minus 1
#define MAX_OUTS    6   // Max MIDI out devices supported

#define EDITMODES           3
#define MODE_ALLCHORDS      4
#define MODE_FATCHORDS      8

#define BAND_NAME_SIZE      15
#define SECTION_NAME_SIZE   15
#define SONG_NAME_SIZE      20
#define FILTER_SIZE         40
#define TITLE_SIZE          60
#define SMALLEST_OFFSET     96
#define ERRORTEXT_SIZE      100
#define FILENAME_SIZE       256
#define FILENAMES_SIZE      512

#define BUFFER_SIZE     400

#define EVENT_FREED     0x35
#define EVENT_REMOVE    0x5A
#define EVENT_VOICE     1       // Performance event
#define EVENT_REALTIME  2       // qevent() must invoke interrupt
#define EVENT_ONTIME    3       // event should be handled on time

#define FROM_MIDIINPUT  2       // MIDI input
#define DEST_MSG        3       // Post message to app
#define DEST_MIDIOUT    4       // Routed to MIDI mapper
#define DEST_COMPOSER   5       // Routed to composition code
#define DEST_TEMPO      6       // Routed to tempo change code
#define DEST_VOLUME     7       // Routed to volume change code
#define DEST_RTEMPO     8       // Routed to relative tempo change code
#define DEST_RVOLUME    9       // Routed to relative volume change code
#define DEST_REMOVE     10      // Routed to remove code (freeevent)
#define DEST_METRONOME  11      // Routed to metronome code
#define DEST_ENDMOTIF   12      // ends a motif and frees its channels in use
#define DEST_MIDIFILE   13      // Source was a MIDI file, convert to DEST_MIDIOUT

#define NB_OFFSET   0x3     // Offset note up to 7 clicks early

#define PF_FILL     0x0001      // Fill pattern
#define PF_START    0x0002      // May be starting pattern
#define PF_INTRO    0x0002
#define PF_WHOLE    0x0004      // Handles chords on measures
#define PF_HALF     0x0008      // Chords every two beats
#define PF_QUARTER  0x0010      // Chords on beats
#define PF_BREAK    0x0020
#define PF_END      0x0040
#define PF_A        0x0080
#define PF_B        0x0100
#define PF_C        0x0200
#define PF_D        0x0400
#define PF_E        0x0800
#define PF_F        0x1000
#define PF_G        0x2000
#define PF_H        0x10000
#define PF_STOPNOW  0x4000
#define PF_INRIFF   0x8000
#define PF_MOTIF    0x20000     // this pattern is a motif, not a regular pattern
#define PF_BEATS    ( PF_WHOLE | PF_HALF | PF_QUARTER )
#define PF_RIFF     ( PF_INTRO | PF_BREAK | PF_FILL | PF_END )
#define PF_GROOVE   ( PF_A | PF_B | PF_C | PF_D | PF_E | PF_F | PF_G | PF_H )


#define C_FILL      1       // Do a fill
#define C_INTRO     2       // Do an intro
#define C_BREAK     3       // Do a drum break
#define C_END       4       // End the song

//#define NEXTCHORD_SIZE  (sizeof(NextChrd)-sizeof(LPNEXTCHRD)-sizeof(LPCHRDENTRY))
//#define CHORDENTRY_SIZE (sizeof(ChordExt)-sizeof(LPCHORDEXT)+sizeof(unsigned long)+sizeof(short))

#define CE_SELECTED 1               // This is the active chord.
#define CE_START    2
#define CE_END      4
#define CE_MEASURE  8
#define CE_PATH     16
#define CE_TREE     32


// Section Flags
#define SECF_STOPPED_EARLY  0x0001
#define SECF_IS_TRANSITION  0x0002

// chord types for use by each instrument in a pattern
// Chord types for use by each instrument in a pattern
enum
{ 
	CHTYPE_NOTINITIALIZED = 0,
	CHTYPE_DRUM,		// superceded by CHTYPE_FIXED
					// no longer in Note Dialog's combo box selections
					// no longer in Pattern Dialog's combo box selections
	CHTYPE_BASS,		// scale + lower chord
	CHTYPE_UPPER,		// scale + upper chord
	CHTYPE_SCALEONLY, 	// scale, no chord
	CHTYPE_BASSMELODIC,
	CHTYPE_UPPERMELODIC,
	CHTYPE_NONE,		// Ignored on Pattern Dialog's menu selections.
	CHTYPE_FIXED
};

#define VF_SCALE        0x7F    // Seven positions in the scale
#define VF_ACCIDENTAL   0x80    // Handles chords outside of scale
#define VF_MAJOR        0x100   // Handles major chords
#define VF_MINOR        0x200   // Handles minor chords
#define VF_ALL          0x400   // Handles all chord types
#define VF_TO1          0x800   // Handles transitions to 1 chord
#define VF_TO5          0x1000  // Handles transitions to 5 chord
#define VF_SIMPLE       0x2000  // handles simple chords
#define VF_COMPLEX      0x4000  // handles complex chords

// this expects a voiceid from 1-16
#define VOICEID_TO_CHANNEL( id ) ((DWORD) ( ( id + 3 ) & 0xf ))

#pragma pack()

#endif // __SJ_DEFINES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\ptrntrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       ptrntrk.h
//
//--------------------------------------------------------------------------

// PtrnTrk.h : Declaration of the Pattern Track info and state structs

#ifndef __PATTERNTRACK_H_
#define __PATTERNTRACK_H_

#include "dmsect.h"
#include "dmstyle.h"

const MUSIC_TIME MAX_END = 2147483647; // max end time for a track

#define DMUS_PATTERN_AUDITION   1
#define DMUS_PATTERN_MOTIF              2
#define DMUS_PATTERN_STYLE              3

#include <time.h>       // to seed random number generator

const long MULTIPLIER = 48271;
const long MODULUS = 2147483647;

class CRandomNumbers
{
public:
        CRandomNumbers(long nSeed = 0)
        {
                nCurrent = (long)(nSeed ? nSeed : time(NULL));
        }

        void Seed(long nSeed)
        {
                nCurrent = nSeed;
        }

        long Next(long nCeiling = 0)
        {
                LONGLONG llProduct = MULTIPLIER * (LONGLONG) nCurrent;
                nCurrent = (long) (llProduct % MODULUS);
                return nCeiling ? nCurrent % nCeiling : nCurrent;
        }

private:
        long nCurrent;
};

struct PatternTrackState;

struct StylePair
{
        StylePair() : m_mtTime(0), m_pStyle(NULL) {}
        ~StylePair() { if (m_pStyle) m_pStyle->Release(); }

        MUSIC_TIME      m_mtTime;
        IDMStyle*       m_pStyle;
};

struct StatePair
{
        StatePair() : m_pSegState(NULL), m_pStateData(NULL) {}
        StatePair(const StatePair& rPair)
        {
                m_pSegState = rPair.m_pSegState;
                m_pStateData = rPair.m_pStateData;
        }
        StatePair(IDirectMusicSegmentState* pSegState, PatternTrackState* pStateData)
        {
                m_pSegState = pSegState;
                m_pStateData = pStateData;
        }
        StatePair& operator= (const StatePair& rPair)
        {
                if (this != &rPair)
                {
                        m_pSegState = rPair.m_pSegState;
                        m_pStateData = rPair.m_pStateData;
                }
                return *this;
        }
        ~StatePair()
        {
        }
        IDirectMusicSegmentState*       m_pSegState;
        PatternTrackState*                      m_pStateData;
};

struct PatternTrackInfo
{
        PatternTrackInfo();
        PatternTrackInfo(const PatternTrackInfo* pInfo, MUSIC_TIME mtStart, MUSIC_TIME mtEnd); 
        virtual ~PatternTrackInfo();
        virtual HRESULT STDMETHODCALLTYPE Init(
                                /*[in]*/  IDirectMusicSegment*          pSegment
                        ) = 0;

        virtual HRESULT STDMETHODCALLTYPE InitPlay(
                                /*[in]*/  IDirectMusicTrack*            pParentrack,
                                /*[in]*/  IDirectMusicSegmentState*     pSegmentState,
                                /*[in]*/  IDirectMusicPerformance*      pPerformance,
                                /*[out]*/ void**                                        ppStateData,
                                /*[in]*/  DWORD                                         dwTrackID,
                /*[in]*/  DWORD                     dwFlags
                        ) = 0;

        HRESULT STDMETHODCALLTYPE EndPlay(
                                /*[in]*/  PatternTrackState*            pStateData
                        );

        HRESULT STDMETHODCALLTYPE AddNotificationType(
                                /* [in] */  REFGUID     pGuidNotify
                        );

        HRESULT STDMETHODCALLTYPE RemoveNotificationType(
                                /* [in] */  REFGUID pGuidNotify
                        );

        PatternTrackState* FindState(IDirectMusicSegmentState* pSegState);

        HRESULT MergePChannels();

        HRESULT InitTrackVariations(CDirectMusicPattern* pPattern);

        TList<StatePair>                        m_StateList;    // The track's state information
        TList<StylePair>                        m_pISList;      // The track's Style interfaces
        DWORD                                           m_dwPChannels; // # of PChannels the track knows about
        DWORD*                                          m_pdwPChannels; // dynamic array of PChannels
        BOOL                                            m_fNotifyMeasureBeat;
        BOOL                                            m_fActive;
//      BOOL                                            m_fTrackPlay;
    BOOL        m_fStateSetBySetParam;  // If TRUE, active flag was set by GUID. Don't override. 
//    BOOL        m_fStatePlaySetBySetParam;  // If TRUE, trackplay flag was set by GUID. Don't override. 
        BOOL            m_fChangeStateMappings; // If TRUE, state data needs to change m_pMappings
        long            m_lRandomNumberSeed;    // If non-zero, use as a seed for variation selection
        DWORD           m_dwPatternTag;                 // replaces need for dynamic casting
        DWORD           m_dwValidate; // used to validate state data
        BYTE*           m_pVariations;          // Track's array of variations (1 per part)
        DWORD*          m_pdwRemoveVariations;  // Track's array of variations already played (1 per part)

};


#define PLAYPARTSF_CLOCKTIME    0x1
#define PLAYPARTSF_FIRST_CALL   0x2
#define PLAYPARTSF_START                0x4
#define PLAYPARTSF_RELOOP               0x8
#define PLAYPARTSF_FLUSH                0x10

struct PatternTrackState
{
        PatternTrackState();
        virtual ~PatternTrackState();
        // methods
        virtual HRESULT Play(
                                /*[in]*/  MUSIC_TIME                            mtStart, 
                                /*[in]*/  MUSIC_TIME                            mtEnd, 
                                /*[in]*/  MUSIC_TIME                            mtOffset,
                                                  REFERENCE_TIME rtOffset,
                                                  IDirectMusicPerformance* pPerformance,
                                                  DWORD                                         dwFlags,
                                                  BOOL fClockTime

                        ) = 0;

        void GetNextChord(MUSIC_TIME mtNow, MUSIC_TIME mtOffset, IDirectMusicPerformance* pPerformance, BOOL fStart = FALSE, BOOL fSkipVariations = FALSE);

        HRESULT ResetMappings()
        {
                HRESULT hr = S_OK;
                if (m_pMappings) delete [] m_pMappings;
                m_pMappings = new MuteMapping[m_pPatternTrack->m_dwPChannels];
                if (!m_pMappings)
                {
                        hr = E_OUTOFMEMORY;
                }
                else
                {
                        for (DWORD dw = 0; dw < m_pPatternTrack->m_dwPChannels; dw++)
                        {
                                m_pMappings[dw].m_mtTime = 0;
                                m_pMappings[dw].m_dwPChannelMap = m_pPatternTrack->m_pdwPChannels[dw];
                                m_pMappings[dw].m_fMute = FALSE;
                        }
                }
                m_pPatternTrack->m_fChangeStateMappings = FALSE;
                return hr;
        }

        void GetNextMute(DWORD dwPart, MUSIC_TIME mtStart, MUSIC_TIME mtNow, MUSIC_TIME mtOffset, IDirectMusicPerformance* pPerformance, BOOL fClockTime)
        {
                HRESULT hr = S_OK;
                if (m_pPatternTrack->m_fChangeStateMappings)
                {
                        hr = ResetMappings();
                }
                if (SUCCEEDED(hr))
                {
                        for (DWORD dw = 0; dw < m_pPatternTrack->m_dwPChannels; dw++)
                        {
                                if ( (m_pPatternTrack->m_pdwPChannels[dw] == dwPart) &&
                                         (0 <= m_pMappings[dw].m_mtTime && m_pMappings[dw].m_mtTime <= mtNow) )
                                {
                                        DMUS_MUTE_PARAM MD;
                                        MUSIC_TIME mtNext = 0;
                                        MD.dwPChannel = m_pPatternTrack->m_pdwPChannels[dw];
                                        if (fClockTime)
                                        {
                                                MUSIC_TIME mtMusic;
                                                REFERENCE_TIME rtTime = (mtNow + mtOffset) * 10000;
                                                pPerformance->ReferenceToMusicTime(rtTime,&mtMusic);
                                                hr = pPerformance->GetParam(GUID_MuteParam, m_dwGroupID, DMUS_SEG_ANYTRACK, mtMusic,
                                                                                                        &mtNext, (void*) &MD);
                                                if (SUCCEEDED(hr))
                                                {
                                                        REFERENCE_TIME rtNext;
                                                        // Convert to absolute reference time.
                                                        pPerformance->MusicToReferenceTime(mtNext + mtMusic,&rtNext);
                                                        rtNext -= (mtOffset * 10000);   // Subtract out to get the time from segment start.
                                                        m_pMappings[dw].m_mtTime = (MUSIC_TIME)(rtNext / 10000);  // Convert to milliseconds. Could be problematic if there's a tempo change.
                                                        m_pMappings[dw].m_dwPChannelMap = MD.dwPChannelMap;
                                                        m_pMappings[dw].m_fMute = MD.fMute;
                                                }
                                                else
                                                {
                                                        // If we fail, disable mapping
                                                        m_pMappings[dw].m_mtTime = -1;
                                                        m_pMappings[dw].m_dwPChannelMap = m_pPatternTrack->m_pdwPChannels[dw];
                                                        m_pMappings[dw].m_fMute = FALSE;
                                                }
                                        }
                                        else
                                        {
                                                hr = pPerformance->GetParam(GUID_MuteParam, m_dwGroupID, DMUS_SEG_ANYTRACK, mtNow + mtOffset,
                                                                                                        &mtNext, (void*) &MD);
                                                if (SUCCEEDED(hr))
                                                {
                                                        m_pMappings[dw].m_mtTime = (mtNext) ? (mtNext + mtNow) : 0;
                                                        m_pMappings[dw].m_dwPChannelMap = MD.dwPChannelMap;
                                                        m_pMappings[dw].m_fMute = MD.fMute;
                                                }
                                                else
                                                {
                                                        // If we fail, disable mapping
                                                        m_pMappings[dw].m_mtTime = -1;
                                                        m_pMappings[dw].m_dwPChannelMap = m_pPatternTrack->m_pdwPChannels[dw];
                                                        m_pMappings[dw].m_fMute = FALSE;
                                                }
                                        }
                                }
                        }
                }
        }

        
        BOOL MapPChannel(DWORD dwPChannel, DWORD& dwMapPChannel);

        HRESULT PlayParts(MUSIC_TIME mtStart, 
                                          MUSIC_TIME mtFinish,
                                          MUSIC_TIME mtOffset,
                                          REFERENCE_TIME rtOffset,
                                          MUSIC_TIME mtSection,
                                          IDirectMusicPerformance* pPerformance,
                                          DWORD dwPartFlags,
                                          DWORD dwPlayFlags,
                                          bool& rfReloop);

        void PlayPatternEvent(
                MUSIC_TIME mtNow,
                CDirectMusicEventItem* pEventItem, 
                DirectMusicTimeSig& TimeSig,
                MUSIC_TIME mtPartOffset, 
                MUSIC_TIME mtSegmentOffset, 
                REFERENCE_TIME rtOffset, 
                IDirectMusicPerformance* pPerformance,
                short nPart,
                DirectMusicPartRef& rPartRef,
                BOOL fClockTime,
                MUSIC_TIME mtPartStart,
        bool& rfChangedVariation);

        void BumpTime(
                CDirectMusicEventItem* pEvent, 
                DirectMusicTimeSig& TimeSig, 
                MUSIC_TIME mtOffset,
                MUSIC_TIME& mtResult)
        {
                if (pEvent != NULL)
                {
                        mtResult = TimeSig.GridToClocks(pEvent->m_nGridStart) + mtOffset;
                }
        }

        virtual DWORD Variations(DirectMusicPartRef& rPartRef, int nPartIndex);

        virtual BOOL PlayAsIs();

        DirectMusicTimeSig& PatternTimeSig()
        {
                return
                        (m_pPattern && m_pPattern->m_timeSig.m_bBeat != 0) ? 
                                m_pPattern->m_timeSig : 
                (m_pStyle != NULL ? m_pStyle->m_TimeSignature : (::DefaultTimeSig));
        }

        void SendTimeSigMessage(MUSIC_TIME mtNow, MUSIC_TIME mtOffset, MUSIC_TIME mtTime, IDirectMusicPerformance* pPerformance);

        short FindGroup(WORD wID);
        short AddGroup(WORD wID, WORD wCount, short m_nOffset);
        DMStyleStruct* FindStyle(MUSIC_TIME mtTime, MUSIC_TIME& rmtTime);

        MUSIC_TIME NotifyMeasureBeat(
                MUSIC_TIME mtStart, MUSIC_TIME mtEnd, MUSIC_TIME mtOffset, IDirectMusicPerformance* pPerformance, DWORD dwFlags);

        HRESULT InitVariationSeeds(long lBaseSeed);
        HRESULT RemoveVariationSeeds();
        long RandomVariation(MUSIC_TIME mtTime, long lModulus);
        virtual MUSIC_TIME PartOffset(int nPartIndex);
        HRESULT InitPattern(CDirectMusicPattern* pTargetPattern, MUSIC_TIME mtNow, CDirectMusicPattern* pOldPattern = NULL);

        // attributes
        PatternTrackInfo*                       m_pPatternTrack;        // This track state's parent track info
        IDirectMusicTrack*                      m_pTrack;                       // This track state's parent track
        DMStyleStruct*                          m_pStyle;               // The style struct for the current style
        IDirectMusicSegmentState*       m_pSegState;    // The segment state for a performance
        DWORD                                           m_dwVirtualTrackID; // The track's ID
        MUSIC_TIME                                      m_mtCurrentChordTime; // when the current chord began
        MUSIC_TIME                                      m_mtNextChordTime;      // when the next chord begins
        MUSIC_TIME                                      m_mtLaterChordTime;     // when the chord after the next chord begins
        DMUS_CHORD_PARAM                        m_CurrentChord;         // current chord
        DMUS_CHORD_PARAM                        m_NextChord;            // next chord
        CDirectMusicPattern*            m_pPattern;                     // currently playing pattern
        DWORD*                                          m_pdwPChannels;     // array of PChannels for the pattern (1 per part)
        BYTE*                                           m_pVariations;          // array of variations (1 per part)
        DWORD*                                          m_pdwVariationMask;     // array of disabled variations (1 per part)
        DWORD*                                          m_pdwRemoveVariations;  // array of variations already played (1 per part)
        MUSIC_TIME*                                     m_pmtPartOffset;        // array of part offsets (1 per part)
    bool*                       m_pfChangedVariation; // array: have this part's variations changed?
        BOOL                                            m_fNewPattern;          // TRUE if we're starting a new pattern
        BOOL                                            m_mtPatternStart;       // Time the current pattern started
    BOOL                        m_fStateActive;
//    BOOL                        m_fStatePlay;
        InversionGroup                          m_aInversionGroups[INVERSIONGROUPLIMIT];
        short                                           m_nInversionGroupCount;
        MuteMapping*                            m_pMappings;            // dynamic array of PChannel mappings
                                                                                                        // (sized to # of PChannels)
        BYTE                                            m_abVariationGroups[MAX_VARIATION_LOCKS];
        CDirectMusicEventItem**         m_ppEventSeek;          // dynamic array of event list seek pointers
        DWORD                                           m_dwGroupID;            // Track's group ID
        CRandomNumbers*                         m_plVariationSeeds;     // dynamic array of random # generators (1 per beat)
        int                                                     m_nTotalGenerators; // size of m_plVariationSeeds
        DWORD                                           m_dwValidate; // used to validate state data
        HRESULT                                         m_hrPlayCode;  // last HRESULT returned by Play
        IDirectMusicPerformance*        m_pPerformance; // performance used to init the state data
        MUSIC_TIME                                      m_mtPerformanceOffset; // from track::play
        
};

const int CURVE_TYPES = 258; // one for each CC, one for each PAT, one for PB, one for MAT

class CurveSeek
{
public:
        CurveSeek();
        void AddCurve(CDirectMusicEventItem* pEvent, MUSIC_TIME mtTimeStamp);
        void PlayCurves(
                PatternTrackState* pStateData,
                DirectMusicTimeSig& TimeSig,
                MUSIC_TIME mtPatternOffset, 
                MUSIC_TIME mtOffset, 
                REFERENCE_TIME rtOffset,
                IDirectMusicPerformance* pPerformance,
                short nPart,
                DirectMusicPartRef& rPartRef,
                BOOL fClockTime,
                MUSIC_TIME mtPartStart);
private:
        CDirectMusicEventItem* m_apCurves[CURVE_TYPES];
        MUSIC_TIME m_amtTimeStamps[CURVE_TYPES];
        bool m_fFoundCurve;
};

#endif //__PATTERNTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\styletrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       styletrk.h
//
//--------------------------------------------------------------------------

// StyleTrack.h : Declaration of the CStyleTrack

#ifndef __STYLETRACK_H_
#define __STYLETRACK_H_

#include "PtrnTrk.h"
#include "dmusici.h"
#include "dmstylep.h"

struct StyleTrackInfo : public PatternTrackInfo
{
	StyleTrackInfo();
	StyleTrackInfo(const StyleTrackInfo* pInfo, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) 
		: PatternTrackInfo(pInfo, mtStart, mtEnd)
	{
		m_dwPatternTag = DMUS_PATTERN_STYLE;
	}
	~StyleTrackInfo();
	virtual HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

	virtual HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicTrack*		pParentrack,
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

	HRESULT LoadStyleRefList( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent );
	HRESULT LoadStyleRef( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent );
	HRESULT LoadReference(IStream *pStream,
						  IAARIFFStream *pIRiffStream,
						  MMCKINFO& ckParent,
						  IDMStyle** ppStyle);

};


/////////////////////////////////////////////////////////////////////////////
// CStyleTrack
class CStyleTrack : 
	public IDirectMusicTrack8,
	public IStyleTrack,
	public IPersistStream
{
friend struct StyleTrackState;
public:
	CStyleTrack();
	CStyleTrack(const CStyleTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd); 
	~CStyleTrack();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IStyleTrack
public:
// IStyleTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

	HRESULT STDMETHODCALLTYPE GetParam( 
		REFGUID pCommandGuid,
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		void *pData);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID pCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID	pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID			pGuid
			);


// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// IStyleTrack methods

STDMETHOD(GetStyle)(IUnknown** ppStyle);

STDMETHOD(SetTrack)(IUnknown* pStyle);

// internal methods
protected:
// used by both GetParam and GetParamEx
	HRESULT STDMETHODCALLTYPE GetParam( 
		REFGUID pCommandGuid,
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		void *pData,
		void* pStateData);

	HRESULT JoinInternal(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		DWORD dwTrackGroup);

// IStyleTrack data members
protected:
	// attributes
    long m_cRef;
    CRITICAL_SECTION			m_CriticalSection; // for load and playback
    BOOL                        m_fCSInitialized;
	PatternTrackInfo*			m_pTrackInfo;
	BYTE						m_bRequiresSave;
};

struct StyleTrackState : public PatternTrackState
{
	StyleTrackState();
	~StyleTrackState();
	// methods
	HRESULT Play(
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  REFERENCE_TIME rtOffset,
						  IDirectMusicPerformance* pPerformance,
						  DWORD						dwFlags,
						  BOOL fClockTime
			);
	HRESULT GetNextPattern(DWORD dwFlags, MUSIC_TIME mtNow, MUSIC_TIME mtOffset, IDirectMusicPerformance* pPerformance, BOOL fSkipVariations = FALSE);

	MUSIC_TIME PartOffset(int nPartIndex);

	//CDirectMusicPattern* SelectPattern(bool fNewMode, TList<CDirectMusicPattern*>& rPatternList);

	// attributes
	MUSIC_TIME					m_mtSectionOffset;	// Elapsed time in the section
	MUSIC_TIME					m_mtSectionOffsetTemp;	// temporary value for m_mtSectionOffset
	MUSIC_TIME					m_mtNextCommandTime;	// when the next command begins
	MUSIC_TIME					m_mtNextCommandTemp;	// temporary values for m_mtNextCommandTime
	MUSIC_TIME					m_mtNextStyleTime;	// when the next style begins
	DMUS_COMMAND_PARAM_2		m_CommandData;		// data about the current command
//	DMUS_RHYTHM_PARAM*			m_pChordRhythm;		// data about the current chord's rhythm
//	short						m_nLongestPattern;	// length of longest pattern in a style
//	DMUS_COMMAND_PARAM_2*		m_pCommands;		// array of commands (for pattern selection)
//	DWORD*						m_pRhythms;			// array of rhythms (for pattern selection)
	MUSIC_TIME					m_mtOverlap;		// section overlap caused by controlling segment
	TList<CDirectMusicPattern*> m_PlayedPatterns;	// list of patterns already played that match current groove level
};

#endif //__STYLETRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\styletrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       styletrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
// StyleTrack.cpp : Implementation of CStyleTrack
#include "StyleTrk.h"
#include "dmusicc.h"
#include <stdlib.h> // for random number generator
#include <time.h>   // to seed random number generator
#include "debug.h"
#include "debug.h"
#include "..\shared\Validate.h"

/////////////////////////////////////////////////////////////////////////////
// StyleTrackState

StyleTrackState::StyleTrackState() : 
    m_mtSectionOffset(0), m_mtSectionOffsetTemp(0), m_mtOverlap(0),
    m_mtNextCommandTemp(0),
    m_mtNextCommandTime(0),
    m_mtNextStyleTime(0)
{
    ZeroMemory(&m_CommandData , sizeof(m_CommandData));
}

StyleTrackState::~StyleTrackState()
{
    m_PlayedPatterns.CleanUp();
}

HRESULT StyleTrackState::Play(
                          MUSIC_TIME                mtStart, 
                          MUSIC_TIME                mtEnd, 
                          MUSIC_TIME                mtOffset,
                          REFERENCE_TIME rtOffset,
                          IDirectMusicPerformance* pPerformance,
                          DWORD                     dwFlags,
                          BOOL fClockTime
            )
{
    m_mtPerformanceOffset = mtOffset;
    BOOL fStart = (dwFlags & DMUS_TRACKF_START) ? TRUE : FALSE;
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
    BOOL fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? TRUE : FALSE;
    BOOL fFlush = (dwFlags & DMUS_TRACKF_FLUSH) ? TRUE : FALSE;
    BOOL fDirty = (dwFlags & DMUS_TRACKF_DIRTY) ? TRUE : FALSE;
    HRESULT hr = S_OK;
    TraceI(4, "Play [%d:%d @ %d]\n", mtStart, mtEnd, mtOffset);
    if (m_mtNextCommandTime == 0)
    {
        MUSIC_TIME mtBarLength = m_pStyle ? PatternTimeSig().ClocksPerMeasure() : 0;
        DMUS_COMMAND_PARAM_2 TempCommand;
        HRESULT hrCommand = E_FAIL;
        if (fDirty || fFlush)
        {
            char chGroove;
            HRESULT hrGroove = pPerformance->GetGlobalParam((GUID)GUID_PerfMasterGrooveLevel, &chGroove, 1);
            if (!SUCCEEDED(hrGroove)) chGroove = 0;
            BYTE bActualCommand = m_CommandData.bCommand;
            if (m_pStyle)
            {
                hrCommand = m_pStyle->GetCommand(mtStart, mtOffset, pPerformance, NULL, m_dwGroupID, &TempCommand, bActualCommand);
            }
            if (!fDirty && hrCommand == S_OK)
            {
                // Avoid getting a pattern that's the same as the current one.
                if (TempCommand.bGrooveLevel + chGroove == m_CommandData.bGrooveLevel &&
                    bActualCommand == m_CommandData.bCommand)
                {
                    hrCommand = E_FAIL;
                }
            }
        }
        MUSIC_TIME mtFirstCommand = 0;
        if (fStart || fLoop)
        {
            m_mtNextCommandTime = 0;
        }
        else
        {
            mtFirstCommand = mtStart;
            m_mtNextCommandTime = (mtBarLength) ? ((mtStart / mtBarLength) * mtBarLength) : 0;
        }
        if (fStart || fLoop || mtStart == 0 || hrCommand == S_OK || mtStart >= m_mtNextCommandTemp)
        {
            hr = GetNextPattern(dwFlags, mtFirstCommand, mtOffset, pPerformance, fLoop);
            if ( m_pPattern && mtStart > 0 &&  (fSeek || fDirty) )
            {
                while (SUCCEEDED(hr) && mtStart >= m_mtNextCommandTime)
                {
                    hr = GetNextPattern(dwFlags, m_mtNextCommandTime, mtOffset, pPerformance, fLoop);
                }
            }
            fDirty = fDirty || fLoop; // make sure we get new variations if we skipped them above
        }
        else
        {
            m_mtNextCommandTime = m_mtNextCommandTemp;
            m_mtNextCommandTemp = 0;
            m_mtSectionOffset = m_mtSectionOffsetTemp;
            m_mtSectionOffsetTemp = 0;
        }
    }
    if (SUCCEEDED(hr))
    {
        if (fDirty) // We need to make sure we get chords on beat boundaries
        {
            GetNextChord(mtStart, mtOffset, pPerformance, fStart);
        }
        // for each part, play the events between start and end in the corresponding list
        // get new chords and commands when necessary
        MUSIC_TIME mtLast = m_mtNextCommandTime;
        bool fReLoop = false;
        MUSIC_TIME mtNotify = mtStart ? PatternTimeSig().CeilingBeat(mtStart) : 0;
        if( m_fStateActive && m_pPatternTrack->m_fNotifyMeasureBeat && 
            ( mtNotify < mtEnd ) )
        {
            mtNotify = NotifyMeasureBeat( mtNotify, mtEnd, mtOffset, pPerformance, dwFlags );
        }

        DWORD dwPartFlags = PLAYPARTSF_FIRST_CALL;
        if (fStart || fLoop || fSeek) dwPartFlags |= PLAYPARTSF_START;
        if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
        if ( fLoop || (mtStart > 0 &&  (fStart || fSeek || fDirty)) ) dwPartFlags |= PLAYPARTSF_FLUSH;
        MUSIC_TIME mtPartLast = min(mtEnd, mtLast);
        PlayParts(mtStart, mtPartLast, mtOffset, rtOffset, m_mtSectionOffset, pPerformance, dwPartFlags, dwFlags, fReLoop);

        // If we need to reloop any parts, do it
        if (fReLoop)
        {
            dwPartFlags = PLAYPARTSF_RELOOP;
            if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
            PlayParts(mtStart, mtPartLast, mtOffset, rtOffset, m_mtSectionOffset, pPerformance, dwPartFlags, dwFlags, fReLoop);
        }

        // If we need to get a new command, we do it after all the events in all the parts
        // have run. And then we need to run all events from command start to mtEnd.
        if (mtStart <= m_mtNextCommandTime && m_mtNextCommandTime < mtEnd)
        {
            hr = GetNextPattern(dwFlags & ~DMUS_TRACKF_START, m_mtNextCommandTime, mtOffset, pPerformance);
            if (SUCCEEDED(hr))
            {
                dwPartFlags = 0;
                if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
                PlayParts(mtStart, mtEnd, mtOffset, rtOffset, m_mtSectionOffset, pPerformance, dwPartFlags, dwFlags, fReLoop);
            }
        }
        if( SUCCEEDED(hr) &&
            m_fStateActive && m_pPatternTrack->m_fNotifyMeasureBeat && 
            ( mtNotify < mtEnd ) )
        {
            NotifyMeasureBeat( mtNotify, mtEnd, mtOffset, pPerformance, dwFlags );
        }
    }
    m_hrPlayCode = hr;
    return hr;
}


HRESULT StyleTrackState::GetNextPattern(DWORD dwFlags, MUSIC_TIME mtNow, MUSIC_TIME mtOffset, IDirectMusicPerformance* pPerformance, BOOL fSkipVariations)
{
    bool fStart = (dwFlags & DMUS_TRACKF_START) ? TRUE : FALSE;
    bool fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
    bool fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? TRUE : FALSE;
    bool fFlush = (dwFlags & DMUS_TRACKF_FLUSH) ? TRUE : FALSE;
    bool fDirty = (dwFlags & DMUS_TRACKF_DIRTY) ? TRUE : FALSE;
    bool fNewMode = fStart || fDirty;
     // It doesn't seem to make sense to use anything other than the style's time signature
    // when looking for a new pattern.
    //TraceI(1, "New pattern at %d\n", mtNow);
    DMStyleStruct* pOldStyle = m_pStyle;
    if (m_mtNextStyleTime && mtNow >= m_mtNextStyleTime)
    {
        //TraceI(0, "New Style (%d) [%d]\n", m_mtNextStyleTime, mtNow);
        DMStyleStruct* pStyle = FindStyle(mtNow, m_mtNextStyleTime);
        if (!pStyle)
        {
            return E_POINTER; 
        }
        else
        {
            m_pStyle = pStyle;
            fNewMode = true;
        }
        if (m_fStateActive) // if timesig events are enabled...
        {
            SendTimeSigMessage(mtNow, mtOffset, m_mtNextStyleTime, pPerformance);
        }
    }
    MUSIC_TIME mtOldMeasureTime = m_pPattern ? m_pPattern->TimeSignature(pOldStyle).ClocksPerMeasure() : m_pStyle->m_TimeSignature.ClocksPerMeasure();
    CDirectMusicPattern* pOldPattern = m_pPattern;
    CDirectMusicPattern* pTargetPattern = NULL;
    MUSIC_TIME mtMeasureTime = 0, mtNextCommand = 0;
    HRESULT hr = m_pStyle->GetPattern(fNewMode, mtNow, mtOffset, this, pPerformance, NULL, pTargetPattern, mtMeasureTime, mtNextCommand);

    if (SUCCEEDED(hr))
    {
        MUSIC_TIME mtSectionOffset = (!fDirty || m_mtSectionOffset || fLoop) ? m_mtSectionOffset : m_mtSectionOffsetTemp;
        MUSIC_TIME mtOldPatternEnd = (!fStart && !fLoop && pOldPattern) ? mtSectionOffset + (pOldPattern->m_wNumMeasures *  mtOldMeasureTime) : 0;
        MUSIC_TIME mtNewPatternLength = pTargetPattern->m_wNumMeasures * mtMeasureTime;
        MUSIC_TIME mtOverlap = 0;
        if (m_mtOverlap && fDirty) // assumes 1 controlling segment w/command track at a time
        {
            if (m_pStyle->UsingDX8())
            {
                mtOverlap = mtMeasureTime - (m_mtOverlap % mtMeasureTime);
            }
            m_mtOverlap = 0;
            //TraceI(0, "[1]Overlap: %d\n", mtOverlap);
        }
        else if (mtNow < mtOldPatternEnd && 
                 m_pStyle->UsingDX8() )
        {
            mtOverlap = mtOldPatternEnd - mtNow;
            if (fDirty)
            {
                m_mtOverlap = mtOverlap;
                mtOverlap = 0;
            }
            else
            {
                mtOverlap = (mtMeasureTime - (mtOverlap % mtMeasureTime)) % mtMeasureTime;
            }
            //TraceI(0, "[2]Overlap: %d\n", fDirty ? m_mtOverlap : mtOverlap);
        }

        // Whenever I get a new pattern, I should get a new chord
        GetNextChord(mtNow, mtOffset, pPerformance, fStart, fSkipVariations);
        /*
        if (fDirty)
        {
            m_mtSectionOffset = mtNow - mtOverlap;
        }
        else
        {
            m_mtSectionOffset = m_mtNextCommandTime - mtOverlap; // keep the section offset on a measure boundary
        }
        */
        m_mtSectionOffset = m_mtNextCommandTime;
        m_mtNextCommandTime = m_mtSectionOffset + mtNewPatternLength;
        // Note: at this point mtNextCommand == m_mtNextStyleTime - mtNow,
        // if that difference is smaller than the original value for mtNextCommand.
        if (mtNextCommand && m_mtNextCommandTime > mtNow + mtNextCommand)
        {
            m_mtNextCommandTime = mtNow + mtNextCommand;
        }
        TraceI(3, "Next Command Time: %d Measures: %d Measure time: %d\n", 
//      TraceI(0, "Next Command Time: %d Measures: %d Measure time: %d\n", 
            m_mtNextCommandTime, m_pPattern->m_wNumMeasures, mtMeasureTime);
        return S_OK;
    }
    else return E_POINTER;
}

MUSIC_TIME StyleTrackState::PartOffset(int nPartIndex)
{
    return m_pmtPartOffset[nPartIndex] + m_mtSectionOffset;
}

/////////////////////////////////////////////////////////////////////////////
// StyleTrackInfo

StyleTrackInfo::StyleTrackInfo() 
{
    m_dwPatternTag = DMUS_PATTERN_STYLE;
}

StyleTrackInfo::~StyleTrackInfo()
{
}

HRESULT StyleTrackInfo::Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            )
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT StyleTrackInfo::InitPlay(
                /*[in]*/  IDirectMusicTrack*        pParentrack,
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    IDirectMusicSegment* pSegment = NULL;
    StyleTrackState* pStateData = new StyleTrackState;
    if( NULL == pStateData )
    {
        return E_OUTOFMEMORY;
    }
    pStateData->m_dwValidate = m_dwValidate;
    StatePair SP(pSegmentState, pStateData);
    TListItem<StatePair>* pPair = new TListItem<StatePair>(SP);
    if (!pPair)
    {
        delete pStateData;
        return E_OUTOFMEMORY;
    }
    m_StateList.AddHead(pPair);
    pStateData->m_pTrack = pParentrack;
    pStateData->m_pPatternTrack = this;
    pStateData->m_dwVirtualTrackID = dwTrackID;
    pStateData->m_mtNextStyleTime = 0;
    pStateData->m_pStyle = pStateData->FindStyle(0, pStateData->m_mtNextStyleTime);
    if (!pStateData->m_pStyle)
    {
        delete pStateData;
        return E_POINTER;
    }
    pStateData->m_pPattern = NULL;
    pStateData->m_pSegState = pSegmentState; // weak reference, no addref.
    pStateData->m_pPerformance = pPerformance; // weak reference, no addref.
    pStateData->m_mtPerformanceOffset = 0;
    pStateData->m_mtCurrentChordTime = 0;
    pStateData->m_mtNextChordTime = 0;
    pStateData->m_mtPatternStart = 0;
    pStateData->m_mtSectionOffset = 0;
    pStateData->m_mtSectionOffsetTemp = 0;
    pStateData->m_mtOverlap = 0;
    HRESULT hr = pStateData->ResetMappings();
    if (FAILED(hr))
    {
        delete pStateData;
        return hr;
    }
    if (m_fStateSetBySetParam)
    {
        pStateData->m_fStateActive = m_fActive;
    }
    else
    {
        pStateData->m_fStateActive = !(dwFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY));
    }
    if (m_lRandomNumberSeed)
    {
        pStateData->InitVariationSeeds(m_lRandomNumberSeed);
    }
    if( SUCCEEDED( pSegmentState->GetSegment(&pSegment)))
    {
        if (FAILED(pSegment->GetTrackGroup(pStateData->m_pTrack, &pStateData->m_dwGroupID)))
        {
            pStateData->m_dwGroupID = 0xffffffff;
        }
        pSegment->Release();
    }

    *ppStateData = pStateData;
    return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
// CStyleTrack

CStyleTrack::CStyleTrack() : 
    m_bRequiresSave(0), m_cRef(1), m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    srand((unsigned int)time(NULL));
    m_pTrackInfo = new StyleTrackInfo;
//  assert (m_pTrackInfo);
}

CStyleTrack::CStyleTrack(const CStyleTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)  : 
    m_bRequiresSave(0), m_cRef(1), m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    srand((unsigned int)time(NULL));
    m_pTrackInfo = new StyleTrackInfo((StyleTrackInfo*)rTrack.m_pTrackInfo, mtStart, mtEnd);
}

CStyleTrack::~CStyleTrack()
{
    if (m_pTrackInfo)
    {
        delete m_pTrackInfo;
    }
    if (m_fCSInitialized)
    {
        ::DeleteCriticalSection( &m_CriticalSection );
    }
    InterlockedDecrement(&g_cComponent);
}

// CStyleTrack Methods

STDMETHODIMP CStyleTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CStyleTrack::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IStyleTrack)
    {
        *ppv = static_cast<IStyleTrack*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CStyleTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CStyleTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init

HRESULT CStyleTrack::Init( 
    /* [in] */ IDirectMusicSegment __RPC_FAR *pSegment)
{
    V_INAME(CStyleTrack::Init);
    V_INTERFACE(pSegment);

    HRESULT hr = S_OK;
    if (m_pTrackInfo == NULL)
        return DMUS_E_NOT_INIT;

    EnterCriticalSection( &m_CriticalSection );
    hr = m_pTrackInfo->MergePChannels();
    if (SUCCEEDED(hr))
    {
        pSegment->SetPChannelsUsed(m_pTrackInfo->m_dwPChannels, m_pTrackInfo->m_pdwPChannels);
        hr = m_pTrackInfo->Init(pSegment);
    }
    LeaveCriticalSection( &m_CriticalSection );

    return hr;
}

HRESULT CStyleTrack::InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    V_INAME(CStyleTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerformance);

    HRESULT hr = S_OK;
    EnterCriticalSection( &m_CriticalSection );
    if (m_pTrackInfo == NULL)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    hr = m_pTrackInfo->InitPlay(this, pSegmentState, pPerformance, ppStateData, dwTrackID, dwFlags);
    LeaveCriticalSection( &m_CriticalSection );
    return hr;

}

HRESULT CStyleTrack::EndPlay(
                /*[in]*/  void*     pStateData
            )
{
    V_INAME(CStyleTrack::EndPlay);
    V_BUFPTR_WRITE(pStateData, sizeof(StyleTrackState));

    HRESULT hr = DMUS_E_NOT_INIT;
    StyleTrackState* pSD = (StyleTrackState*)pStateData;
    EnterCriticalSection( &m_CriticalSection );
//  if (pSD->m_pPattern) pSD->m_pPattern->Release();
    if (m_pTrackInfo) hr = m_pTrackInfo->EndPlay(pSD);
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CStyleTrack::Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID
            )
{
    V_INAME(CStyleTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(StyleTrackState));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegState);

    HRESULT hr = DMUS_E_NOT_INIT;
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
    BOOL fStart = (dwFlags & DMUS_TRACKF_START) ? TRUE : FALSE;
    BOOL fControl = (dwFlags & DMUS_TRACKF_DIRTY) ? TRUE : FALSE;
    EnterCriticalSection( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return hr;
    }
    StyleTrackState* pSD = (StyleTrackState *)pStateData;
    if (pSD->m_hrPlayCode == E_OUTOFMEMORY)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return pSD->m_hrPlayCode;
    }
    if (pSD->m_dwValidate != m_pTrackInfo->m_dwValidate)
    {
        // new style added to track either via SetParam or Load.  Resync state data.
        pSD->m_pStyle = pSD->FindStyle(mtStart, pSD->m_mtNextStyleTime);
        if (!pSD->m_pStyle)
        {
            hr = E_POINTER;
        }
        pSD->m_dwValidate = m_pTrackInfo->m_dwValidate;
    }
    if ((hr == DMUS_E_NOT_INIT) && pSD && pSD->m_pMappings)
    {
        if (fStart || fSeek || fControl)
        {
            pSD->m_mtSectionOffsetTemp = pSD->m_mtSectionOffset;
            pSD->m_mtSectionOffset = 0;
            pSD->m_mtNextCommandTemp = pSD->m_mtNextCommandTime;
            pSD->m_mtNextCommandTime = 0;
            pSD->m_pStyle = pSD->FindStyle(0, pSD->m_mtNextStyleTime);
            if (!pSD->m_pStyle)
            {
                hr = E_POINTER;
            }
            else
            {
                if (pSD->m_fStateActive) // if timesig events are enabled...
                {
                    pSD->SendTimeSigMessage(mtStart, mtOffset, pSD->m_mtNextStyleTime, pPerf);
                }
                pSD->m_mtCurrentChordTime = 0;
                pSD->m_mtNextChordTime = 0;
                pSD->m_mtLaterChordTime = 0;
//              pSD->m_CurrentChord.bSubChordCount = 0;
                pSD->m_mtPatternStart = 0;
                for (DWORD dw = 0; dw < m_pTrackInfo->m_dwPChannels; dw++)
                {
                    pSD->m_pMappings[dw].m_mtTime = 0;
                    pSD->m_pMappings[dw].m_dwPChannelMap = m_pTrackInfo->m_pdwPChannels[dw];
                    pSD->m_pMappings[dw].m_fMute = FALSE;
                }
            }
        }
        hr = ((StyleTrackState *)pStateData)->Play(mtStart, mtEnd, mtOffset, 0, pPerf, dwFlags, FALSE);
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CStyleTrack::GetPriority( 
                /*[out]*/ DWORD*                    pPriority 
            )
    {
        return E_NOTIMPL;
    }

HRESULT CStyleTrack::GetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void* pData,
    void* pStateData)
{
    V_INAME(CStyleTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE(pData,1);
    V_PTR_WRITE_OPT(pStateData,1);
    V_REFGUID(rCommandGuid);

    HRESULT hr;
    EnterCriticalSection( &m_CriticalSection );
    bool fInCritSection = true;
    if (rCommandGuid == GUID_IDirectMusicStyle)
    {
        if (m_pTrackInfo)
        {
            TListItem<StylePair>* pScan = m_pTrackInfo->m_pISList.GetHead();
            if (pScan)
            {
                IDMStyle* pStyle = pScan->GetItemValue().m_pStyle;
                for(pScan = pScan->GetNext(); pScan; pScan = pScan->GetNext())
                {
                    StylePair& rScan = pScan->GetItemValue();
                    if (mtTime < rScan.m_mtTime && rScan.m_pStyle) break;  // ignore if NULL
                    if (rScan.m_pStyle) pStyle = rScan.m_pStyle; // skip if NULL
                }
                IDirectMusicStyle* pDMStyle;
                if (!pStyle) 
                {
                    hr = E_POINTER;
                }
                else
                {
                    pStyle->QueryInterface(IID_IDirectMusicStyle, (void**)&pDMStyle);
                    // Note: QI with no Release has the effect of an AddRef
                    *(IDirectMusicStyle**)pData = pDMStyle;
                    if (pmtNext)
                    {
                        *pmtNext = (pScan != NULL) ? pScan->GetItemValue().m_mtTime - mtTime : 0;
                    }
                    hr = S_OK;
                }
            }
            else hr = DMUS_E_NOT_FOUND;
        }
        else hr = DMUS_E_NOT_INIT;
    }
    else if (rCommandGuid == GUID_TimeSignature)
    {
        // find the style at the given time, and return its time sig.
        if (m_pTrackInfo)
        {
            TListItem<StylePair>* pScan = m_pTrackInfo->m_pISList.GetHead();
            if (pScan)
            {
                IDMStyle* pStyle = pScan->GetItemValue().m_pStyle;
                MUSIC_TIME mtStyleTime = pScan->GetItemValue().m_mtTime;
                for(pScan = pScan->GetNext(); pScan; pScan = pScan->GetNext())
                {
                    StylePair& rScan = pScan->GetItemValue();
                    if (mtTime < rScan.m_mtTime) break;
                    pStyle = rScan.m_pStyle;
                    mtStyleTime = rScan.m_mtTime;
                }
                if (!pStyle)
                {
                    hr = E_POINTER;
                }
                else
                {
                    // Enter the style's CritSec
                    pStyle->CritSec(true);
                    // If I've got state data, use it to get the time signature of the pattern at mtTime
                    if (pStateData)
                    {
                        MUSIC_TIME mtMeasureTime = 0;
                        MUSIC_TIME mtNext = 0;
                        CDirectMusicPattern* pTargetPattern;
                        StyleTrackState* pStyleTrackState = (StyleTrackState*)pStateData;
                        IDirectMusicPerformance* pPerformance = pStyleTrackState->m_pPerformance;
                        MUSIC_TIME mtOffset = pStyleTrackState->m_mtPerformanceOffset;
                        DMStyleStruct* pStyleStruct = NULL;
                        hr = pStyle->GetStyleInfo((void**)&pStyleStruct);
                        if (SUCCEEDED(hr))
                        {
                            // I don't need the Track CritSec any more, and in fact there's an almost 
                            // guaranteed deadlock if I keep it, so get rid of it
                            LeaveCriticalSection( &m_CriticalSection );
                            fInCritSection = false;
                            hr = pStyleStruct->GetPattern(true, mtTime, mtOffset, NULL,
                                pPerformance, NULL, pTargetPattern, mtMeasureTime, mtNext);
                            if (SUCCEEDED(hr))
                            {
                                DMUS_TIMESIGNATURE* pTimeSig = (DMUS_TIMESIGNATURE*)pData;
                                *pTimeSig = pTargetPattern->TimeSignature(pStyleStruct);
                                pTimeSig->mtTime = mtStyleTime - mtTime;
                                //TraceI(0, "New Time sig from pattern...\n");
                                if (pmtNext)
                                {
                                    *pmtNext = mtNext;
                                }
                            }
                        }
                    }
                    else // Just get the style's time signature
                    {
                        IDirectMusicStyle* pDMStyle;
                        hr = pStyle->QueryInterface(IID_IDirectMusicStyle, (void**)&pDMStyle);
                        if (SUCCEEDED(hr))
                        {
                            hr = pDMStyle->GetTimeSignature((DMUS_TIMESIGNATURE*)pData);
                            if (SUCCEEDED(hr))
                            {
                                ((DMUS_TIMESIGNATURE*)pData)->mtTime = mtStyleTime - mtTime;
                                if (pmtNext)
                                {
                                    *pmtNext = (pScan != NULL) ? pScan->GetItemValue().m_mtTime : 0;
                                }
                            }
                            pDMStyle->Release();
                        }
                    }
                    // Leave the style's CritSec
                    pStyle->CritSec(false);
                }
            }
            else hr = DMUS_E_NOT_FOUND;
        }
        else hr = DMUS_E_NOT_INIT;
    }
    else if (rCommandGuid == GUID_SegmentTimeSig)
    {
        SegmentTimeSig* pTimeSigParam = (SegmentTimeSig*)pData;
        if (!pTimeSigParam->pSegment) hr = E_POINTER;
        // find the style at the given time, and return the time sig currently in effect in the segment.
        else if (m_pTrackInfo)
        {
            TListItem<StylePair>* pScan = m_pTrackInfo->m_pISList.GetHead();
            if (pScan)
            {
                IDMStyle* pStyle = pScan->GetItemValue().m_pStyle;
                MUSIC_TIME mtStyleTime = pScan->GetItemValue().m_mtTime;
                for(pScan = pScan->GetNext(); pScan; pScan = pScan->GetNext())
                {
                    StylePair& rScan = pScan->GetItemValue();
                    if (mtTime < rScan.m_mtTime) break;
                    pStyle = rScan.m_pStyle;
                    mtStyleTime = rScan.m_mtTime;
                }
                if (!pStyle)
                {
                    hr = E_POINTER;
                }
                else
                {
                    DMStyleStruct* pStyleStruct = NULL;
                    hr = pStyle->GetStyleInfo((void**)&pStyleStruct);
                    if (SUCCEEDED(hr))
                    {
                        CDirectMusicPattern* pPattern = NULL;
                        MUSIC_TIME mtMeasureTime = 0, mtNextCommand = 0;
                        hr = pStyleStruct->GetPattern(true, mtTime, 0, NULL, NULL, pTimeSigParam->pSegment,
                            pPattern, mtMeasureTime, mtNextCommand);
                        if (SUCCEEDED(hr))
                        {
                            pTimeSigParam->TimeSig = pPattern->m_timeSig;
                            pTimeSigParam->TimeSig.mtTime = mtStyleTime  - mtTime;
                            if (pmtNext)
                            {
                                *pmtNext = (mtNextCommand) ? mtNextCommand - mtTime : 0;
                            }
                        }
                    }
                }
            }
            else hr = DMUS_E_NOT_FOUND;
        }
        else hr = DMUS_E_NOT_INIT;
    }
    else
    {
        hr = DMUS_E_GET_UNSUPPORTED;
    }
    if (fInCritSection) LeaveCriticalSection( &m_CriticalSection );
    return hr;

} 

HRESULT CStyleTrack::SetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
    V_INAME(CStyleTrack::SetParam);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rCommandGuid);

    HRESULT hr = S_OK;
    EnterCriticalSection( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        hr = DMUS_E_NOT_INIT;
    }
    else if (rCommandGuid == GUID_IDirectMusicStyle)
    {
        if (!pData)
        {
            hr = E_POINTER;
        }
        else
        {
            IDirectMusicStyle* pStyle = (IDirectMusicStyle*)pData;
            IDMStyle* pIS = NULL;
            pStyle->QueryInterface(IID_IDMStyle, (void**)&pIS);
            TListItem<StylePair>* pNew = new TListItem<StylePair>;
            if (!pNew)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                pNew->GetItemValue().m_mtTime = mtTime;
                pNew->GetItemValue().m_pStyle = pIS;
                m_pTrackInfo->m_pISList.AddTail(pNew);
                m_pTrackInfo->m_dwValidate++;

                hr = m_pTrackInfo->MergePChannels();
            }
        }
    }
    else if( rCommandGuid == GUID_EnableTimeSig )
    {
        if( m_pTrackInfo->m_fStateSetBySetParam && m_pTrackInfo->m_fActive )
        {
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_pTrackInfo->m_fStateSetBySetParam = TRUE;
            m_pTrackInfo->m_fActive = TRUE;
            hr = S_OK;
        }
    }
    else if( rCommandGuid == GUID_DisableTimeSig )
    {
        if( m_pTrackInfo->m_fStateSetBySetParam && !m_pTrackInfo->m_fActive )
        {
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_pTrackInfo->m_fStateSetBySetParam = TRUE;
            m_pTrackInfo->m_fActive = FALSE;
            hr = S_OK;
        }
    }
    else if ( rCommandGuid == GUID_SeedVariations )
    {
        if (pData)
        {
            m_pTrackInfo->m_lRandomNumberSeed = *((long*) pData);
            hr = S_OK;
        }
        else hr = E_POINTER;
    }
    else
    {
        hr = DMUS_E_SET_UNSUPPORTED;
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

// IPersist methods
 HRESULT CStyleTrack::GetClassID( LPCLSID pClassID )
{
    V_INAME(CStyleTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicStyleTrack;
    return S_OK;
}

HRESULT CStyleTrack::IsParamSupported(
                /*[in]*/ REFGUID    rGuid
            )
{
    V_INAME(CStyleTrack::IsParamSupported);
    V_REFGUID(rGuid);


    if (!m_pTrackInfo)
    {
        return DMUS_E_NOT_INIT;
    }

    if (rGuid == GUID_IDirectMusicStyle ||
        rGuid == GUID_SeedVariations ||
        rGuid == GUID_SegmentTimeSig )
    {
        return S_OK;
    }
    else if (m_pTrackInfo->m_fStateSetBySetParam)
    {
        if( m_pTrackInfo->m_fActive )
        {
            if( rGuid == GUID_DisableTimeSig ) return S_OK;
            if( rGuid == GUID_TimeSignature ) return S_OK;
            if( rGuid == GUID_EnableTimeSig ) return DMUS_E_TYPE_DISABLED;
        }
        else
        {
            if( rGuid == GUID_EnableTimeSig ) return S_OK;
            if( rGuid == GUID_DisableTimeSig ) return DMUS_E_TYPE_DISABLED;
            if( rGuid == GUID_TimeSignature ) return DMUS_E_TYPE_DISABLED;
        }
    }
    else
    {
        if( ( rGuid == GUID_DisableTimeSig ) ||
            ( rGuid == GUID_TimeSignature ) ||
            ( rGuid == GUID_EnableTimeSig )) return S_OK;
    }
    return DMUS_E_TYPE_UNSUPPORTED;

}

// IPersistStream methods
 HRESULT CStyleTrack::IsDirty()
{
     return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CStyleTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{

    return E_NOTIMPL;
}

HRESULT CStyleTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}

BOOL Less(StylePair& SP1, StylePair& SP2)
{ return SP1.m_mtTime < SP2.m_mtTime; }

HRESULT CStyleTrack::Load(LPSTREAM pStream )
{
    V_INAME(CStyleTrack::Load);
    V_INTERFACE(pStream);

    IAARIFFStream*  pIRiffStream;
    //MMCKINFO      ckMain;
    MMCKINFO        ck;
    HRESULT         hr = E_FAIL;

    EnterCriticalSection( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    StyleTrackInfo* pTrackInfo = (StyleTrackInfo*)m_pTrackInfo;
    if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_STYLE)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return E_FAIL;
    }
    pTrackInfo->m_pISList.CleanUp();

    if( SUCCEEDED( AllocRIFFStream( pStream, &pIRiffStream ) ) )
    {
        if (pIRiffStream->Descend( &ck, NULL, 0 ) == 0)
        {
            if (ck.ckid == FOURCC_LIST && ck.fccType == DMUS_FOURCC_STYLE_TRACK_LIST)
            {
                hr = pTrackInfo->LoadStyleRefList(pIRiffStream, &ck);
            }
            pIRiffStream->Ascend( &ck, 0 );
        }
        pIRiffStream->Release();
    }
    if (SUCCEEDED(hr))
    {
        pTrackInfo->m_pISList.MergeSort(Less);
        m_pTrackInfo->m_dwValidate++;

        hr = m_pTrackInfo->MergePChannels();
    }
    
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT StyleTrackInfo::LoadStyleRefList( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent )
{
    HRESULT hr = S_OK;
    HRESULT hrStyle = E_FAIL;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;

    while ( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0  )
    {
        if ( ck.ckid == FOURCC_LIST && ck.fccType == DMUS_FOURCC_STYLE_REF_LIST )
        {
            hr = LoadStyleRef(pIRiffStream, &ck);
            if (hr == S_OK)
            {
                hrStyle = hr;
            }
            pIRiffStream->Ascend( &ck, 0 );
        }
        pIRiffStream->Ascend( &ck, 0 );
    }

    if (hr != S_OK && hrStyle == S_OK)
    {
        hr = hrStyle;
    }
    return hr;
}

HRESULT StyleTrackInfo::LoadStyleRef( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent )
{
    HRESULT hr = S_OK;
    HRESULT hrStyle = S_OK;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;
    IStream* pIStream = pIRiffStream->GetStream();
    if(!pIStream) return E_FAIL;
    IDMStyle* pStyle = NULL;
    TListItem<StylePair>* pNew = new TListItem<StylePair>;
    if (!pNew) return E_OUTOFMEMORY;
    StylePair& rNew = pNew->GetItemValue();
    while (pIRiffStream->Descend( &ck, pckParent, 0 ) == 0)
    {
        switch (ck.ckid)
        {
        case DMUS_FOURCC_TIME_STAMP_CHUNK:
            {
                DWORD dwTime;
                DWORD cb;
                hr = pIStream->Read( &dwTime, sizeof( dwTime ), &cb );
                if (FAILED(hr) || cb != sizeof( dwTime ) ) 
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                rNew.m_mtTime = dwTime;
            }
            break;
        case FOURCC_LIST:
            if (ck.fccType == DMUS_FOURCC_REF_LIST)
            {
                hr = LoadReference(pIStream, pIRiffStream, ck, &pStyle);
                if (hr != S_OK)
                {
                    hrStyle = hr;
                }
                if (SUCCEEDED(hr))
                {
                    rNew.m_pStyle = pStyle;
                }
            }
            break;
        }
        pIRiffStream->Ascend( &ck, 0 );
    }
    if (SUCCEEDED(hr))
    {
        m_pISList.AddTail(pNew);
    }
    else
    {
        delete pNew;
    }
ON_END:
    pIStream->Release();
    if (hr == S_OK && hrStyle != S_OK)
    {
        hr = hrStyle;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// StyleTrackInfo::LoadReference

HRESULT StyleTrackInfo::LoadReference(IStream *pStream,
                                         IAARIFFStream *pIRiffStream,
                                         MMCKINFO& ckParent,
                                         IDMStyle** ppStyle)
{
    if (!pStream || !pIRiffStream || !ppStyle) return E_INVALIDARG;

    IDirectMusicLoader* pLoader = NULL;
    IDirectMusicGetLoader *pIGetLoader; 
    HRESULT hr = pStream->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (FAILED(hr)) return hr;
    hr = pIGetLoader->GetLoader(&pLoader);
    pIGetLoader->Release(); 
    if (FAILED(hr)) return hr;

    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));

    DWORD cbRead;
    
    MMCKINFO ckNext;
    ckNext.ckid = 0;
    ckNext.fccType = 0;
    DWORD dwSize = 0;
        
    while( pIRiffStream->Descend( &ckNext, &ckParent, 0 ) == 0 )
    {
        switch(ckNext.ckid)
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = pStream->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(DMUS_IO_REFERENCE))
                {
                    desc.guidClass = ioDMRef.guidClassID;
                    desc.dwValidData |= ioDMRef.dwValidData;
                    desc.dwValidData |= DMUS_OBJ_CLASS;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = pStream->Read(&(desc.guidObject), sizeof(GUID), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(GUID))
                {
                    desc.dwValidData |=  DMUS_OBJ_OBJECT;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = pStream->Read(&(desc.ftDate), sizeof(FILETIME), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(FILETIME))
                {
                    desc.dwValidData |=  DMUS_OBJ_DATE;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                dwSize = min(sizeof(desc.wszName), ckNext.cksize);
                hr = pStream->Read(desc.wszName, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.wszName[DMUS_MAX_NAME - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_NAME;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;
            
            case DMUS_FOURCC_FILE_CHUNK:
                dwSize = min(sizeof(desc.wszFileName), ckNext.cksize);
                hr = pStream->Read(desc.wszFileName, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.wszFileName[DMUS_MAX_FILENAME - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_FILENAME;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                dwSize = min(sizeof(desc.wszCategory), ckNext.cksize);
                hr = pStream->Read(desc.wszCategory, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.wszCategory[DMUS_MAX_CATEGORY - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
                DMUS_IO_VERSION ioDMObjVer;
                hr = pStream->Read(&ioDMObjVer, sizeof(DMUS_IO_VERSION), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(DMUS_IO_VERSION))
                {
                    desc.vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
                    desc.vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
                    desc.dwValidData |= DMUS_OBJ_VERSION;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            default:
                break;
        }
    
        if(SUCCEEDED(hr) && pIRiffStream->Ascend(&ckNext, 0) == 0)
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
        }
        else if (SUCCEEDED(hr)) hr = E_FAIL;
    }

    if(SUCCEEDED(hr))
    {
        desc.dwSize = sizeof(DMUS_OBJECTDESC);
        hr = pLoader->GetObject(&desc, IID_IDMStyle, (void**)ppStyle);
        if(SUCCEEDED(hr))
        {
            DMStyleStruct* pStyle;
            (*ppStyle)->GetStyleInfo((void **)&pStyle);
            TListItem<DirectMusicPart*>* pPart;
            for(pPart = pStyle->m_PartList.GetHead(); pPart != NULL; pPart = pPart->GetNext())
            {
                DirectMusicPart* pPattern = pPart->GetItemValue();
                DirectMusicTimeSig& TimeSig = 
                    pPattern->m_timeSig.m_bBeat == 0 ? pStyle->m_TimeSignature : pPattern->m_timeSig;
                pPattern->EventList.MergeSort(TimeSig);
            }
        }
    }

    if (pLoader)
    {
        pLoader->Release();
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CStyleTrack::AddNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CStyleTrack::AddNotificationType);
    V_REFGUID(rGuidNotify);

    HRESULT hr = S_OK;
    EnterCriticalSection( &m_CriticalSection );
    if (m_pTrackInfo)
        hr = m_pTrackInfo->AddNotificationType(rGuidNotify);
    else
        hr = DMUS_E_NOT_INIT;
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT STDMETHODCALLTYPE CStyleTrack::RemoveNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CStyleTrack::RemoveNotificationType);
    V_REFGUID(rGuidNotify);

    HRESULT hr = S_OK;
    EnterCriticalSection( &m_CriticalSection );
    if (m_pTrackInfo)
        hr = m_pTrackInfo->RemoveNotificationType(rGuidNotify);
    else
        hr = DMUS_E_NOT_INIT;
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT STDMETHODCALLTYPE CStyleTrack::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(CStyleTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        return E_INVALIDARG;
    }

    EnterCriticalSection( &m_CriticalSection );
    CStyleTrack *pDM;
    
    try
    {
        pDM = new CStyleTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();
    LeaveCriticalSection( &m_CriticalSection );

    return hr;
}

STDMETHODIMP  CStyleTrack::SetTrack(IUnknown* pStyle)
{
    if (!pStyle) return E_POINTER;
    EnterCriticalSection( &m_CriticalSection );
    if (!m_pTrackInfo) 
    {
        LeaveCriticalSection( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    IDMStyle* pIS = NULL;
    pStyle->QueryInterface(IID_IDMStyle, (void**)&pIS);
    TListItem<StylePair>* pNew = new TListItem<StylePair>;
    if (!pNew)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }
    pNew->GetItemValue().m_mtTime = 0;
    pNew->GetItemValue().m_pStyle = pIS;
    m_pTrackInfo->m_pISList.AddTail(pNew);
    if (pIS) pIS->Release();
    LeaveCriticalSection( &m_CriticalSection );
    return S_OK;
}

// this gets the first style in the track's list.
STDMETHODIMP CStyleTrack::GetStyle(IUnknown * * ppStyle)
{
    HRESULT hr;
    EnterCriticalSection( &m_CriticalSection );
    if (!m_pTrackInfo) 
    {
        LeaveCriticalSection( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    TListItem<StylePair>* pHead = m_pTrackInfo->m_pISList.GetHead();
    if (pHead && pHead->GetItemValue().m_pStyle)
    {
        IUnknown* pIDMS = NULL;
        hr = pHead->GetItemValue().m_pStyle->QueryInterface(IID_IUnknown, (void**)&pIDMS);
        if (SUCCEEDED(hr))
        {
            *ppStyle = pIDMS;
            pIDMS->Release();
            hr = S_OK;
        }
    }
    else
        hr = E_FAIL;
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

// need this for state data, not clock time
STDMETHODIMP CStyleTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    MUSIC_TIME mtNext = 0;
    HRESULT hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam, pStateData);
    if (prtNext)
    {
        *prtNext = mtNext;
    }
    return hr;
}

// only needed because we needed to pass state data into GetParam
STDMETHODIMP CStyleTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

// only needed because we needed to pass state data into GetParam
STDMETHODIMP CStyleTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    hr = Play(pStateData, (MUSIC_TIME)rtStart, (MUSIC_TIME)rtEnd,
          (MUSIC_TIME)rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID);
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CStyleTrack::GetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void *pData)
{
    return GetParam(rCommandGuid, mtTime, pmtNext, pData, NULL);
}

STDMETHODIMP CStyleTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CStyleTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE_OPT(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);

    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        if (SUCCEEDED(hr))
        {
            hr = ((CStyleTrack*)*ppResultTrack)->JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
        }
    }
    else
    {
        hr = JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
    }

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CStyleTrack::JoinInternal(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        DWORD dwTrackGroup)
{
    HRESULT hr = S_OK;
    CStyleTrack* pOtherTrack = (CStyleTrack*)pNewTrack;
    if (!m_pTrackInfo || !pOtherTrack->m_pTrackInfo)
    {
        return DMUS_E_NOT_INIT;
    }
    TListItem<StylePair>* pScan = pOtherTrack->m_pTrackInfo->m_pISList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        StylePair& rScan = pScan->GetItemValue();
        TListItem<StylePair>* pNew = new TListItem<StylePair>;
        if (pNew)
        {
            StylePair& rNew = pNew->GetItemValue();
            rNew.m_mtTime = rScan.m_mtTime + mtJoin;
            rNew.m_pStyle = rScan.m_pStyle;
            if (rNew.m_pStyle) rNew.m_pStyle->AddRef();
            m_pTrackInfo->m_pISList.AddTail(pNew);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\str.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       str.cpp
//
//--------------------------------------------------------------------------

//
// string.cpp

#include "str.h"

WORD String::sm_wBlockSize = 16;

String::String()
{
	m_wAllocated = 0;
    m_pBuf = NULL;
    m_wLength = 0;
}

String::String( const String& str )
{
    m_wLength = str.m_wLength;
	if (m_wLength == 0)
	{
		m_wAllocated = 0;
		m_pBuf = NULL;
	}
	else
	{
		m_wAllocated = figureblocksize( m_wLength );
		m_pBuf = new WCHAR[m_wAllocated];
		if( m_pBuf != NULL )
		{
			wcscpy( m_pBuf, str.m_pBuf );
		}
		else
		{
			m_wLength = 0;
			m_wAllocated = 0;
		}
	}
}

String::String( LPCSTR pszStr )
{
    if( pszStr != NULL && pszStr[0] != '\0' )
    {
        m_wLength = static_cast<WORD>( MultiByteToWideChar( CP_ACP, 0, pszStr, -1, NULL, 0 ) );
		m_wAllocated = figureblocksize( m_wLength );
		m_pBuf = new WCHAR[m_wAllocated];

		if( m_pBuf != NULL )
		{
			MultiByteToWideChar( CP_ACP, 0, pszStr, -1, m_pBuf, m_wAllocated );
		}
		else
		{
			m_wLength = 0;
			m_wAllocated = 0;
		}
    }
    else
    {
        m_wLength = 0;
		m_wAllocated = 0;
		m_pBuf = NULL;
    }

}

String::String( LPCWSTR pszWstr )
{
    if( pszWstr != NULL && pszWstr[0] != L'\0')
    {
        m_wLength = static_cast<WORD>( wcslen(pszWstr) );
		m_wAllocated = figureblocksize( m_wLength );
		m_pBuf = new WCHAR[m_wAllocated];

		if( m_pBuf != NULL )
		{
			wcscpy(m_pBuf, pszWstr);
		}
		else
		{
			m_wLength = 0;
			m_wAllocated = 0;
		}
    }
    else
    {
        m_wLength = 0;
		m_wAllocated = 0;
		m_pBuf = NULL;
    }

}

String::~String()
{
    if (m_pBuf) delete[] m_pBuf;
}

String& String::operator=( const String& str )
{
    WORD wBlockSize;

    if( m_pBuf != str.m_pBuf )
    {
		if (!str.m_pBuf)
		{
            if (m_pBuf)
			{
				m_pBuf[0] = L'\0';
			}
            m_wLength = 0;
		}
		else
		{
			wBlockSize = figureblocksize( str.m_wLength );
			if( wBlockSize <= m_wAllocated )
			{
				m_wLength = str.m_wLength;
				wcscpy( m_pBuf, str.m_pBuf );
			}
			else
			{
				if (m_pBuf) delete [] m_pBuf;
				m_wLength = str.m_wLength;
				m_wAllocated = wBlockSize;
				m_pBuf = new WCHAR[m_wAllocated];
				if( m_pBuf != NULL )
				{
					wcscpy( m_pBuf, str.m_pBuf );
				}
				else
				{
					m_wLength = 0;
					m_wAllocated = 0;
				}
			}
		}
    }
    return *this;
}

String& String::operator=( LPCSTR pszStr )
{
    WORD wLength;
    WORD wBlockSize;

    if( pszStr == NULL )
    {
        m_wLength = 0;
        return *this;
    }

    wLength = static_cast<WORD>( MultiByteToWideChar( CP_ACP, 0, pszStr, -1, NULL, 0 ) );
    wBlockSize = figureblocksize( wLength );
    if( wBlockSize <= m_wAllocated )
    {
        m_wLength = wLength;
        MultiByteToWideChar( CP_ACP, 0, pszStr, -1, m_pBuf, m_wAllocated );
    }
    else
    {
        if (m_pBuf) delete[] m_pBuf;
        m_wLength = wLength;
        m_wAllocated = wBlockSize;
        m_pBuf = new WCHAR[m_wAllocated];
        if( m_pBuf != NULL )
        {
			MultiByteToWideChar( CP_ACP, 0, pszStr, -1, m_pBuf, m_wAllocated );
        }
        else
        {
            m_wLength = 0;
            m_wAllocated = 0;
        }
    }
    return *this;
}

String& String::operator=( LPCWSTR pszWstr )
{
    WORD wLength;
    WORD wBlockSize;

    if( pszWstr == NULL )
    {
        m_wLength = 0;
        return *this;
    }

    wLength = static_cast<WORD>( wcslen( pszWstr ) );
    wBlockSize = figureblocksize( wLength );
    if( wBlockSize <= m_wAllocated )
    {
        m_wLength = wLength;
        wcscpy(m_pBuf, pszWstr);
    }
    else
    {
        if (m_pBuf) delete[] m_pBuf;
        m_wLength = wLength;
        m_wAllocated = wBlockSize;
        m_pBuf = new WCHAR[m_wAllocated];
        if( m_pBuf != NULL )
        {
            wcscpy(m_pBuf, pszWstr);
        }
        else
        {
            m_wLength = 0;
            m_wAllocated = 0;
        }
    }
    return *this;
}

/*
#ifndef _MAC
BOOL String::LoadString( UINT nID, HINSTANCE hInstance )
{
    char szBuf[256];    // this is safe since resource strings
                        // are limited to 255 characters

    if( ::LoadString( hInstance, nID, szBuf, sizeof( szBuf ) ) == 0 )
    {
        return FALSE;
    }
    delete[] m_pBuf;
    m_wLength = static_cast<WORD>( ::lstrlen( szBuf ) );
    m_wAllocated = figureblocksize( m_wLength );
    m_pBuf = new WCHAR[m_wAllocated];
    if( m_pBuf == NULL )
    {
        m_wLength = 0;
        return FALSE;
    }
    ::lstrcpy( m_pBuf, szBuf );
    m_pBuf[m_wLength] = '\0';
    return TRUE;
}
#endif
*/

void String::TrimTrailingSpaces()
{
    while( m_wLength > 0 && m_pBuf[m_wLength - 1] == ' ' )
    {
        m_pBuf[m_wLength - 1] = '\0';
        --m_wLength;
    }
}

void String::Concat( const String& str )
{
    if( ( str.m_wLength + m_wLength + 1 ) < m_wAllocated )
    {
        m_wLength = static_cast<WORD>( m_wLength + str.m_wLength );
        wcscat( m_pBuf, str.m_pBuf );
    }
    else
    {
        WCHAR* p;

        m_wLength = static_cast<WORD>( m_wLength + str.m_wLength );
        m_wAllocated = figureblocksize( m_wLength );
        p = new WCHAR[m_wAllocated];
        if( p != NULL )
        {
            wcscpy( p, m_pBuf );
            wcscat( p, str.m_pBuf );
            if (m_pBuf) delete[] m_pBuf;
            m_pBuf = p;
        }
    }
}

void String::Concat( LPCWSTR lpwzStr )
{
    int len;

    len = wcslen( lpwzStr );
    if( ( len + m_wLength + 1 ) < m_wAllocated )
    {
        m_wLength = static_cast<WORD>( m_wLength + len );
        wcscat( m_pBuf, lpwzStr );
    }
    else
    {
        WCHAR* p;

        m_wLength = static_cast<WORD>( m_wLength + len );
        m_wAllocated = figureblocksize( m_wLength );
        p = new WCHAR[m_wAllocated];
        if( p != NULL )
        {
            wcscpy( p, m_pBuf );
            wcscat( p, lpwzStr );
            if (m_pBuf) delete[] m_pBuf;
            m_pBuf = p;
        }
    }
}

void String::Concat( WCHAR wch )
{
    WCHAR buf[2];

    buf[0] = wch;
    buf[1] = '\0';
    if( ( 1 + m_wLength + 1 ) < m_wAllocated )
    {
        m_wLength += 1;
        wcscat( m_pBuf, buf );
    }
    else
    {
        WCHAR* p;

        m_wLength += 1;
        m_wAllocated = figureblocksize( m_wLength );
        p = new WCHAR[m_wAllocated];
        if( p != NULL )
        {
            wcscpy( p, m_pBuf );
            wcscat( p, buf );
            if (m_pBuf) delete[] m_pBuf;
            m_pBuf = p;
        }
    }
}

HRESULT String::ReadWCS( LPSTREAM pStream, DWORD cSize )
{
	HRESULT		hr = S_OK;
	WCHAR*		wstrText = NULL;
	DWORD		cb;
    WORD        wBlockSize;

    wstrText = new WCHAR[cSize / sizeof( WCHAR )];
	if( NULL == wstrText )
	{
		hr = E_OUTOFMEMORY;
		goto ON_ERR;
	}
    hr = pStream->Read( reinterpret_cast<LPWSTR>( wstrText ), cSize, &cb );
    if( FAILED( hr ) || cb != cSize )
	{
        hr = E_FAIL;
        goto ON_ERR;
	}

	cSize = wcslen(wstrText);
	if (cSize == 0)
	{
        if (m_pBuf)
		{
			m_pBuf[0] = L'\0';
		}
        m_wLength = 0;
		goto ON_ERR;
	}
    wBlockSize = figureblocksize( static_cast<WORD>( cSize ) );
    m_wLength = static_cast<WORD>( cSize );
    if( wBlockSize <= m_wAllocated )
    {
        wcscpy( m_pBuf, wstrText );
    }
    else
    {
        if (m_pBuf) delete[] m_pBuf;
        m_wAllocated = wBlockSize;
        m_pBuf = new WCHAR[m_wAllocated];
        if( m_pBuf != NULL )
        {
            wcscpy( m_pBuf, wstrText );
        }
        else
        {
            hr = E_OUTOFMEMORY;
            m_wLength = 0;
            m_wAllocated = 0;
        }
    }

ON_ERR:
    if( wstrText != NULL )
    {
		delete [] wstrText;
    }
    return hr;
}

/*
HRESULT String::WriteWCS( LPSTREAM pStream )
{
    HRESULT     hr;
    wchar_t*    wstrText;
	DWORD		cb;
    DWORD       cSize;

    cSize = MultiByteToWideChar( CP_ACP, 0, m_pBuf, -1, NULL, 0 );  // get number of wide characters required

	wstrText = new wchar_t[cSize];
    if( wstrText == NULL )
	{
		hr = E_OUTOFMEMORY;
    }
    else
    {
        MultiByteToWideChar( CP_ACP, 0, m_pBuf, -1, wstrText, cSize );
        hr = pStream->Write( reinterpret_cast<LPSTR>( wstrText ), cSize * sizeof( wchar_t ), &cb );
        if( FAILED( hr ) || cb != ( cSize * sizeof( wchar_t ) ) )
        {
            hr = E_FAIL;
        }
        else
        {
            hr = S_OK;
        }
        delete [] wstrText;
    }

    return hr;
}
*/

String operator+( const String& str1, const String& str2 )
{
    String str;

    str = str1;
    str.Concat( str2 );
    return str;
}

String operator+( const String& str1, LPCSTR lpszStr )
{
    String str;

    str = str1;
    str.Concat( lpszStr );
    return str;
}

String operator+( LPCSTR lpszStr, const String& str1 )
{
    String str;

    str = lpszStr;
    str.Concat( str1 );
    return str;
}

String operator+( const String& str1, char ch )
{
    String str;

    str = str1;
    str.Concat( ch );
    return str;
}

String operator+( char ch, const String& str1 )
{
    String str;

    str.Concat( ch );
    str.Concat( str1 );
    return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\adapter.cpp ===
// Copyright (c) 1998 Microsoft Corporation
//
// Kernel mode DirectMusic DLS level 1 Software Synthesizer
//

//
// All the GUIDS for all the miniports end up in this object.
//
#define PUT_GUIDS_HERE

#define STR_MODULENAME "kmsynth: "
#define MAX_MINIPORTS 1

#include "common.h"
#include "private.h"


#if (DBG)
#define SUCCEEDS(s) ASSERT(NT_SUCCESS(s))
#else
#define SUCCEEDS(s) (s)
#endif

NTSTATUS
AddDevice
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
);

NTSTATUS
StartDevice
(
    IN      PVOID           Context1,       // Context for the class driver.
    IN      PVOID           Context2,       // Context for the class driver.
    IN      PRESOURCELIST   ResourceList    // List of hardware resources.
);

#pragma code_seg("PAGE")

/*****************************************************************************
 * DriverEntry()
 *****************************************************************************
 * This function is called by the operating system when the driver is loaded.
 * All adapter drivers can use this code without change.
 */
extern "C"
NTSTATUS
DriverEntry
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
)
{
    PAGED_CODE();

    //
    // Tell the class driver to initialize the driver.
    //
    return InitializeAdapterDriver(Context1,Context2, AddDevice);
}

/*****************************************************************************
 * AddDevice()
 *****************************************************************************
 * This function is called by the operating system when the device is added.
 * All adapter drivers can use this code without change.
 */
NTSTATUS
AddDevice
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
)
{
    PAGED_CODE();

    //
    // Tell the class driver to add the device.
    //
    return AddAdapterDevice(Context1,Context2, StartDevice,MAX_MINIPORTS);
}

/*****************************************************************************
 * StartDevice()
 *****************************************************************************
 * This function is called by the operating system when the device is started.
 * It is responsible for starting the miniports.  This code is specific to
 * the adapter because it calls out miniports for functions that are specific
 * to the adapter.
 */
NTSTATUS
StartDevice
(
    IN      PVOID           Context1,       // Context for the class driver.
    IN      PVOID           Context2,       // Context for the class driver.
    IN      PRESOURCELIST   ResourceList    // List of hardware resources.
)
{
   PAGED_CODE();

   ASSERT(Context1);
   ASSERT(Context2);
   ASSERT(ResourceList);

    // We only care about having a dummy MIDI miniport
    //
    PPORT       port;
    NTSTATUS    nt = NewPort(&port, CLSID_PortSynthesizer);

    if (!NT_SUCCESS(nt))
    {
        return nt;
    }

    PUNKNOWN pPortInterface;
    
    nt = port->QueryInterface(IID_IPortSynthesizer, (LPVOID*)&pPortInterface);
    if (!NT_SUCCESS(nt))
    {
        port->Release();
        return nt;
    }

    PUNKNOWN miniport;
    nt = CreateMiniportDmSynth(&miniport, NULL, NonPagedPool);
    if (!NT_SUCCESS(nt))
    {
        pPortInterface->Release();
        port->Release();
        return nt;
    }

    nt = port->Init(Context1, Context2, miniport, NULL, ResourceList);
    if (!NT_SUCCESS(nt))
    {
        pPortInterface->Release();
        port->Release();
        miniport->Release();
        return nt;
    }

    
    nt = RegisterSubdevice(Context1, Context2, L"MSSWSynth", port);
    if (!NT_SUCCESS(nt))
    {
        pPortInterface->Release();
        port->Release();
        miniport->Release();
        return nt;
    }

    return nt;
}


#pragma code_seg()

/*****************************************************************************
 * _purecall()
 *****************************************************************************
 * The C++ compiler loves me.
 * TODO: Figure out how to put this into portcls.sys
 */
int __cdecl
_purecall( void )
{
    ASSERT( !"Pure virtual function called" );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\cclock.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation

//  clock.h
#ifndef __CCLOCK_H__
#define __CCLOCK_H__

class CDSLink;

class CClock : public IReferenceClock
{
public:
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /* IReferenceClock methods */
    HRESULT STDMETHODCALLTYPE GetTime( 
        /* [out] */ REFERENCE_TIME __RPC_FAR *pTime);
    
    HRESULT STDMETHODCALLTYPE AdviseTime( 
        /* [in] */ REFERENCE_TIME baseTime,
        /* [in] */ REFERENCE_TIME streamTime,
        /* [in] */ HANDLE hEvent,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE AdvisePeriodic( 
        /* [in] */ REFERENCE_TIME startTime,
        /* [in] */ REFERENCE_TIME periodTime,
        /* [in] */ HANDLE hSemaphore,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE Unadvise( 
        /* [in] */ DWORD dwAdviseCookie);
                CClock();
    void        Init(CDSLink *pDSLink);
    void        Stop();         // Call store current time as offset.
    void        Start();        // Call to reinstate running.
private:
    BOOL        m_fStopped;     // Currently changing configuration.
    CDSLink *	m_pDSLink;      // Pointer to parent DSLink structure.
};

#endif //__CCLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\tlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       tlist.h
//
//--------------------------------------------------------------------------

//
// tlist.h --- template version of AList
//
#ifndef __TLIST_H__
#define __TLIST_H__

//#include "stdafx.h"

//template <class T>
//typedef BOOL (* TRelation) (T, T);

// TListItem<> contains four more members than AListItem: one additional constructor,
// a destructor, one member function, and one data member.
template <class T>
class TListItem
{
public:
    TListItem() { m_pNext=NULL; };
    ~TListItem();												// new destructor
	static void Delete(TListItem<T>* pFirst);                           // new deletion helper
    TListItem(const T& item) { m_Tinfo = item; m_pNext=NULL; };	// additional constructor.
    TListItem<T> *GetNext() const {return m_pNext;};
    void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    TListItem<T>* Cat(TListItem<T>* pItem);
    TListItem<T>* AddTail(TListItem<T>* pItem) {return Cat(pItem);};
    TListItem<T>* Remove(TListItem<T>* pItem);
    TListItem<T>* GetPrev(TListItem<T> *pItem) const;
    TListItem<T>* GetItem(LONG index);
    T& GetItemValue() { return m_Tinfo; }  // additional member function
	TListItem<T>* MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list items 
private:
	void Divide(TListItem<T>* &pHalf1, TListItem<T>* &pHalf2);
	TListItem<T>* Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&));
	T m_Tinfo;  // additional data member, but memory is the same since in AListItem 
				// you put the extra data member in the derived class 
    TListItem<T> *m_pNext;
};

// TList<> adds a destructor to AList.
template <class T>
class TList
{
public:
    TList() {m_pHead=NULL;}
	~TList()
	{ 
		//if (m_pHead != NULL) delete m_pHead;
		TListItem<T>::Delete(m_pHead);
	} // new destructor
    TListItem<T> *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    void CleanUp() 
	{ 
		//if (m_pHead) delete m_pHead;
		if (m_pHead) TListItem<T>::Delete(m_pHead);
		m_pHead=NULL;
	}
    LONG GetCount() const {return m_pHead->GetCount();}; 
    TListItem<T> *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert);
    void Cat(TListItem<T> *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(TList<T> *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(TListItem<T> *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(TListItem<T> *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(TListItem<T> *pItem) {m_pHead=m_pHead->Remove(pItem);};
    TListItem<T> *GetPrev(TListItem<T> *pItem) const {return m_pHead->GetPrev(pItem);};
    TListItem<T> *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    TListItem<T> *RemoveHead(void)
        {
            TListItem<T> *li;
            li=m_pHead;
            if(m_pHead)
			{
                m_pHead=m_pHead->GetNext();
				li->SetNext(NULL);
			}
            return li;
        }
	void MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list
	void Reverse(void); // Reverses the entire list
	HRESULT Copy(TList<T>& rList); // Copies one list to another

protected:
    TListItem<T> *m_pHead;
};

#include "tlist.cpp"

#endif // __TLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\timesig.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       timesig.h
//
//--------------------------------------------------------------------------

// TimeSig.h : time signature stuff
#ifndef __TIME_CONVERT__
#define __TIME_CONVERT__
#include "dmusici.h"
#include "dmusicf.h"
#include "score.h"
#include "debug.h"

struct DirectMusicTimeSig
{
	// Time signatures define how many beats per measure, which note receives
	// the beat, and the grid resolution.
	DirectMusicTimeSig() : m_bBeatsPerMeasure(0), m_bBeat(0), m_wGridsPerBeat(0) { }

	DirectMusicTimeSig(BYTE bBPM, BYTE bBeat, WORD wGPB) : 
		m_bBeatsPerMeasure(bBPM), 
		m_bBeat(bBeat),
		m_wGridsPerBeat(wGPB) 
	{ }

	DirectMusicTimeSig(DMUS_TIMESIGNATURE& TSE) : 
		m_bBeatsPerMeasure(TSE.bBeatsPerMeasure), 
		m_bBeat(TSE.bBeat), 
		m_wGridsPerBeat(TSE.wGridsPerBeat) 
	{ }

	operator DMUS_TIMESIGNATURE()
	{
		DMUS_TIMESIGNATURE TSE;
		TSE.bBeatsPerMeasure = m_bBeatsPerMeasure; 
		TSE.bBeat = m_bBeat;
		TSE.wGridsPerBeat = m_wGridsPerBeat; 
		TSE.mtTime = 0;
		return TSE;
	}

	MUSIC_TIME ClocksPerBeat()
	{	
		if (m_bBeat)
		{
			return DMUS_PPQ * 4 / m_bBeat;
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME FloorBeat(MUSIC_TIME mtTime)
	{	MUSIC_TIME mtOneBeat = ClocksPerBeat();
		return (!mtOneBeat || mtTime < mtOneBeat) ? 0 : (mtTime - (mtTime % mtOneBeat));
	}

	MUSIC_TIME CeilingBeat(MUSIC_TIME mtTime)
	{	return OnBeat(mtTime) ? mtTime : (FloorBeat(mtTime) + ClocksPerBeat());
	}

	BOOL OnBeat(MUSIC_TIME mtTime)
	{	MUSIC_TIME mtOneBeat = ClocksPerBeat();
		return (!mtOneBeat) ? FALSE : !(mtTime % mtOneBeat);
	}

	MUSIC_TIME GridsToMeasure(WORD wGrid)
	{	
		if (m_wGridsPerBeat && m_bBeatsPerMeasure)
		{
			return (wGrid / m_wGridsPerBeat) / m_bBeatsPerMeasure;
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME GridsToBeat(WORD wGrid)
	{	
		if (m_wGridsPerBeat && m_bBeatsPerMeasure)
		{
			return (wGrid / m_wGridsPerBeat) % m_bBeatsPerMeasure;
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME GridOffset(WORD wGrid)
	{	
		if (m_wGridsPerBeat)
		{
			return wGrid - ((wGrid / m_wGridsPerBeat) * m_wGridsPerBeat);
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME ClocksPerGrid()
	{
		if (m_wGridsPerBeat)
		{
			return ClocksPerBeat() / m_wGridsPerBeat;
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME ClocksPerMeasure()
	{ 
		return ClocksPerBeat() * m_bBeatsPerMeasure;
	}

	MUSIC_TIME ClocksToMeasure(DWORD dwTotalClocks)
	{ 
		MUSIC_TIME mtCPM = ClocksPerMeasure();
		if (mtCPM)
		{
			return (dwTotalClocks / mtCPM);
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME ClocksToBeat(DWORD dwTotalClocks)
	{
		MUSIC_TIME mtCPB = ClocksPerBeat();
		if (mtCPB)
		{
			return dwTotalClocks / mtCPB;
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME MeasureAndBeatToClocks(WORD wMeasure, BYTE bBeat)
	{ 
		return ClocksPerMeasure() * wMeasure + (ClocksPerBeat() * bBeat);
	}

	MUSIC_TIME GridToClocks(WORD wGrid)
	{
		if (m_wGridsPerBeat)
		{
			return (ClocksPerBeat() * (wGrid / m_wGridsPerBeat)) + (ClocksPerGrid() * (wGrid % m_wGridsPerBeat));
		}
		else
		{
			return ClocksPerGrid() * wGrid;
		}
	}

	BYTE	m_bBeatsPerMeasure;		// beats per measure (top of time sig)
	BYTE	m_bBeat;				// what note receives the beat (bottom of time sig.)
									// we can assume that 0 means 256th note
	WORD	m_wGridsPerBeat;		// grids per beat
};

// Convert old clocks to new clocks
template <class T>
inline T ConvertTime(T oldTime)
{ return (T)((DMUS_PPQ / PPQN) * oldTime); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmstyle\tlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       tlist.cpp
//
//--------------------------------------------------------------------------

//
// tlist.cpp
//

//#include "stdafx.h"
#include "tlist.h"

template <class T>
TListItem<T>::~TListItem()
{
	//if (m_pNext != NULL) { delete m_pNext; }
	// IMPORTANT: user of the list is required to delete content first!
	//ZeroMemory(&m_Tinfo, sizeof(T));
}

template <class T>
void TListItem<T>::Delete(TListItem<T>* pFirst)
{
	TListItem<T>* pScan = pFirst;
	TListItem<T>* pNext = NULL;
	while (pScan)
	{
		pNext = pScan->m_pNext;
		delete pScan;
		pScan = pNext;
	}
}


template <class T>
LONG TListItem<T>::GetCount(void) const
{
    LONG l;
    const TListItem<T> *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

template <class T>
TListItem<T>* TListItem<T>::Cat(TListItem<T> *pItem)
{
    TListItem<T> *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::Remove(TListItem<T> *pItem)
{
    TListItem<T> *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::GetPrev(TListItem<T> *pItem) const
{
    const TListItem<T> *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (TListItem<T>*)prev;
}

template <class T>
TListItem<T> * TListItem<T>::GetItem(LONG index)

{
	TListItem<T> *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

template <class T>
TListItem<T>* TListItem<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pNext != NULL)
	{
		TListItem<T> *pList1, *pList2;
		Divide(pList1, pList2);
		return pList1->MergeSort(fcnCompare)->Merge(pList2->MergeSort(fcnCompare), fcnCompare);
	}
	return this;
}

template <class T>
void TListItem<T>::Divide(TListItem<T>*& pHead1, TListItem<T>*& pHead2)
{
	TListItem<T> *pCurrent = this, *pTail1 = NULL, *pTail2 = NULL;
	do
	{
		pHead1 = pCurrent;
		pCurrent = pCurrent->m_pNext;
		pHead1->m_pNext = pTail1;
		pTail1 = pHead1;
		if (pCurrent != NULL)
		{
			pHead2 = pCurrent;
			pCurrent = pCurrent->m_pNext;
			pHead2->m_pNext = pTail2;
			pTail2 = pHead2;
		}
	} while (pCurrent != NULL);
}

template <class T>
TListItem<T>* TListItem<T>::Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&))
{
	if (!pOtherList) return this;
	TListItem<T>
		*pThisList = this, *pResultHead = NULL, *pResultTail = NULL, *pMergeItem = NULL;
	while (pThisList && pOtherList)
	{
		if ( fcnCompare(pThisList->m_Tinfo, pOtherList->m_Tinfo) )
		{
			pMergeItem = pThisList;
			pThisList = pThisList->GetNext();
		}
		else
		{
			pMergeItem = pOtherList;
			pOtherList = pOtherList->GetNext();
		}
		pMergeItem->SetNext(NULL);
		if (!pResultTail)
		{
			pResultHead = pResultTail = pMergeItem;
		}
		else
		{
			pResultTail->SetNext(pMergeItem);
			pResultTail = pMergeItem;
		}
	}
	if (pThisList) pResultTail->SetNext(pThisList);
	else pResultTail->SetNext(pOtherList);
	return pResultHead;
}

template <class T>
void TList<T>::InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert)

{
	TListItem<T> *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

template <class T>
void TList<T>::AddTail(TListItem<T> *pItem) 

{
	m_pHead = m_pHead->AddTail(pItem);
}

template <class T>
void TList<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pHead != NULL && m_pHead->GetNext() != NULL)
		m_pHead = m_pHead->MergeSort(fcnCompare);
}

template <class T>
void TList<T>::Reverse(void)
{
	if( m_pHead )
	{
		TListItem<T>* pNewHead = m_pHead;
		TListItem<T>* pNext = m_pHead->GetNext();
		pNewHead->SetNext(NULL);
		for( m_pHead = pNext; m_pHead; m_pHead = pNext )
		{
			pNext = m_pHead->GetNext();
			m_pHead->SetNext(pNewHead);
			pNewHead = m_pHead;
		}
		m_pHead = pNewHead;
	}
}

template <class T>
HRESULT TList<T>::Copy(TList<T>& rList)
{
	HRESULT hr = S_OK;
	TListItem<T>* pScan = m_pHead;
	for (; pScan; pScan = pScan->GetNext())
	{
		T& rScan = pScan->GetItemValue();
		TListItem<T>* pNew = new TListItem<T>(rScan);
		if (pNew)
		{
			rList.AddHead(pNew);
		}
		else
		{
			hr = E_OUTOFMEMORY;
			break;
		}
	}
	if (SUCCEEDED(hr))
	{
		rList.Reverse();
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\clist.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//
//      clist.h
//

#ifndef __CLIST_H__
#define __CLIST_H__

class CListItem
{
public:
    CListItem() { m_pNext=NULL; };
    CListItem *GetNext() const {return m_pNext;};
    void SetNext(CListItem *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    BOOL IsMember(CListItem *pItem);
    CListItem* Cat(CListItem* pItem);
    CListItem* AddTail(CListItem* pItem) {pItem->SetNext(NULL); return Cat(pItem);};
    CListItem* Remove(CListItem* pItem);
    CListItem* GetPrev(CListItem *pItem) const;
    CListItem* GetItem(LONG index);

private:
    CListItem *m_pNext;
};

class CList
{
public:
    CList() {m_pHead=NULL;};
    CListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    LONG GetCount() const {return m_pHead->GetCount();}; 
    CListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(CListItem *pItem,CListItem *pInsert);
    void Cat(CListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(CList *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(CListItem *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(CListItem *pItem)
    {
    	if (m_pHead == NULL)
    	{
    		AddHead(pItem);
    	}
    	else
    	{
    		m_pHead=m_pHead->AddTail(pItem);
    	}
    };
    void Remove(CListItem *pItem) {m_pHead=m_pHead->Remove(pItem);};
    CListItem *GetPrev(CListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    CListItem *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    BOOL IsMember(CListItem *pItem) {return (m_pHead->IsMember(pItem));};
    CListItem *RemoveHead(void)
        {
            CListItem *li;
            li=m_pHead;
            if(m_pHead)
                m_pHead=m_pHead->GetNext();
            if (li)
                li->SetNext(NULL);
            return li;
        }

protected:
    CListItem *m_pHead;
};

#endif // __CLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\clist.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//
//      clist.cpp
//
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include "clist.h"
#endif

LONG CListItem::GetCount(void) const
{
    LONG l;
    const CListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

BOOL CListItem::IsMember(CListItem *pItem)

{
    CListItem *li = this;
    for (;li != NULL; li=li->m_pNext)
    {
        if (li == pItem) return (TRUE);
    }
    return (FALSE);
}

CListItem* CListItem::Cat(CListItem *pItem)
{
    CListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

CListItem* CListItem::Remove(CListItem *pItem)
{
    CListItem *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

CListItem* CListItem::GetPrev(CListItem *pItem) const
{
    const CListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (CListItem*)prev;
}

CListItem * CListItem::GetItem(LONG index)

{
	CListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) index--;
	return (scan);
}

void CList::InsertBefore(CListItem *pItem,CListItem *pInsert)

{
	CListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\clib.c ===
/* Copyright (c) 1998 Microsoft Corporation */
#include <windows.h>
#include <stdio.h>

#ifdef _DEBUG
void __cdecl _assert ( void *expr, void *filename, unsigned lineno )
{
    DebugBreak();
}
#endif
#ifdef _DEBUG
#if 0 // These are intrinsics and cause an error in the NT build
int __cdecl memcmp (
        const void * buf1,
        const void * buf2,
        size_t count
        )
{
        if (!count)
                return(0);

        while ( --count && *(char *)buf1 == *(char *)buf2 ) {
                buf1 = (char *)buf1 + 1;
                buf2 = (char *)buf2 + 1;
        }

        return( *((unsigned char *)buf1) - *((unsigned char *)buf2) );
}

void * __cdecl memcpy (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

#if defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC)
        {
        extern void RtlMoveMemory( void *, const void *, size_t count );

        RtlMoveMemory( dst, src, count );
        }
#else  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */
        /*
         * copy from lower addresses to higher addresses
         */
        while (count--) {
                *(char *)dst = *(char *)src;
                dst = (char *)dst + 1;
                src = (char *)src + 1;
        }
#endif  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */

        return(ret);
}

void * __cdecl memset (
        void *dst,
        int val,
        size_t count
        )
{
        void *start = dst;

#if defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC)
        {
        extern void RtlFillMemory( void *, size_t count, char );

        RtlFillMemory( dst, count, (char)val );
        }
#else  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */
        while (count--) {
                *(char *)dst = (char)val;
                dst = (char *)dst + 1;
        }
#endif  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */

        return(start);
}
#endif
#endif
void __cdecl _purecall(
        void
        )
{
}

static long holdrand = 1L;

void __cdecl srand (
        unsigned int seed
        )
{
        holdrand = (long)seed;
}

int __cdecl rand (
        void
        )
{
        return(((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\common.h ===
// Copyright (c) 1998 Microsoft Corporation
#ifndef _COMMON_H_
#define _COMMON_H_


#if (DBG)
#if !defined(DEBUG_LEVEL)
#define DEBUG_LEVEL DEBUGLVL_VERBOSE
#endif
#endif

#include <winerror.h>


#include "portcls.h"
#include "ksdebug.h"
#include <dmusicks.h>       // Ks defines
#include <dmerror.h>        // Error codes
#include <dmdls.h>          // DLS definitions

#include "kernhelp.h"
#include "CSynth.h"
#include "synth.h"
#include "float.h"
#include "muldiv32.h"
#include "SysLink.h"

#endif  //_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\control.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      CControlLogic.cpp
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include <mmsystem.h>
#include <dmusicc.h>
#include <dmusics.h>
#include "synth.h"
#include "misc.h"
#include "csynth.h"
#include "debug.h"
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Manage the global critical section. #pragma's disable the warning about
// not compiling with -GX when using exception handling, which we don't
// care about.
//
//
// The critical section must be global because it protects global
// data in the CMIDIRecorder class. These functions are called from 
// DllMain().
//

CRITICAL_SECTION CControlLogic::s_CriticalSection;
BOOL CControlLogic::s_fCSInitialized = FALSE;

#pragma warning(push)
#pragma warning(disable:4530)

/* static */ BOOL CControlLogic::InitCriticalSection()
{
    s_fCSInitialized = FALSE;
    try
    {
        ::InitializeCriticalSection(&s_CriticalSection);
    } catch(...)
    {
        return FALSE;
    }

    s_fCSInitialized = TRUE;
    return TRUE;
}

#pragma warning(pop)

/* static */ void CControlLogic::KillCriticalSection()
{
    if (s_fCSInitialized)
    {
        ::DeleteCriticalSection(&s_CriticalSection);
        s_fCSInitialized = FALSE;
    }
}

CControlLogic::CControlLogic()

{
    m_pSynth = NULL;
    m_pInstruments = NULL;
    DWORD nIndex;
    GMReset();
    m_fGSActive = FALSE;
    m_fXGActive = FALSE;
    for (nIndex = 0;nIndex < 16;nIndex++)
    {
        m_fSustain[nIndex] = FALSE;
        m_dwProgram[nIndex] = 0;
    }
    m_fEmpty = TRUE;
}

CControlLogic::~CControlLogic()

{
}

void CControlLogic::GMReset()

{
    static int nPartToChannel[16] = { 
        9,0,1,2,3,4,5,6,7,8,10,11,12,13,14,15 
    };
    int nX;
    for (nX = 0; nX < 16; nX++)
    {
        int nY;
        m_nData[nX] = 0;
        m_prFineTune[nX] = 0;
        m_bDrums[nX] = 0;
        for (nY = 0; nY < 12; nY++)
        {
            m_prScaleTune[nX][nY] = 0;
        }
        m_nCurrentRPN[nX] = (short) 0x3FFF;
        m_prCoarseTune[nX] = 0; 
        m_bPartToChannel[nX] = (BYTE)nPartToChannel[nX];
        m_fMono[nX] = FALSE;
        m_dwPriority[nX] = DAUD_STANDARD_VOICE_PRIORITY + 
            ((16 - nX) * DAUD_CHAN15_VOICE_PRIORITY_OFFSET);
        m_bBankH[nX] = 0;
        m_bBankL[nX] = 0;
    }
    m_bDrums[0] = 1;
    m_vrMasterVolume = 0;
    m_fGSActive = FALSE;
    m_fXGActive = FALSE;
}

HRESULT CControlLogic::Init(CInstManager *pInstruments, CSynth *pSynth)

{
    m_pSynth = pSynth;
    m_pInstruments = pInstruments;
    m_vrGainAdjust = 0;
    CVoice::Init();
    return S_OK;
}

void CControlLogic::ClearAll()

{
    int nIndex;
    ::EnterCriticalSection(&s_CriticalSection);
    m_Notes.ClearMIDI(0x7FFFFFFF);
    for (nIndex = 0; nIndex < 16; nIndex++) {
        m_ModWheel[nIndex].ClearMIDI(0x7FFFFFFF);
        m_Volume[nIndex].ClearMIDI(0x7FFFFFFF);
        m_Pan[nIndex].ClearMIDI(0x7FFFFFFF);
        m_Expression[nIndex].ClearMIDI(0x7FFFFFFF);
        m_PitchBend[nIndex].ClearMIDI(0x7FFFFFFF);
        m_Pressure[nIndex].ClearMIDI(0x7FFFFFFF);
        m_ReverbSends[nIndex].ClearMIDI(0x7FFFFFFF);
        m_ChorusSends[nIndex].ClearMIDI(0x7FFFFFFF);
        m_CutOffFreqCC[nIndex].ClearMIDI(0x7FFFFFFF);
    }
    for (nIndex = 0; nIndex < 16; nIndex++) {
        m_ModWheel[nIndex].RecordMIDI(0, 0);
        m_Volume[nIndex].RecordMIDI(0, 100);
        m_Pan[nIndex].RecordMIDI(0, 64);
        m_Expression[nIndex].RecordMIDI(0, 127);
        m_PitchBend[nIndex].RecordMIDI(0, 0x2000);
        m_Pressure[nIndex].RecordMIDI(0, 0);
        m_ReverbSends[nIndex].RecordMIDI(0, 40);
        m_ChorusSends[nIndex].RecordMIDI(0, 0);
        m_CutOffFreqCC[nIndex].RecordMIDI(0, 64);
        m_Notes.RecordEvent(0, nIndex, NOTE_SUSTAIN, 0);
    }
    m_fEmpty = TRUE;
    ::LeaveCriticalSection(&s_CriticalSection);
}

void CControlLogic::ClearMIDI(STIME stEndTime)
{
    DWORD dwIndex;
    ::EnterCriticalSection(&s_CriticalSection);
    if (!m_fEmpty)
    {        
        m_fEmpty = TRUE;
        for (dwIndex = 0;dwIndex < 16; dwIndex++)
        {
            m_fEmpty = m_ModWheel[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_PitchBend[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_Volume[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_Expression[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_Pan[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_Pressure[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_ReverbSends[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_ChorusSends[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_CutOffFreqCC[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
        }
    }
    ::LeaveCriticalSection(&s_CriticalSection);
}

void CControlLogic::SetGainAdjust(VREL vrGainAdjust)
{
    m_vrGainAdjust = vrGainAdjust;
}

void CControlLogic::QueueNotes(STIME stStartTime, STIME stEndTime)
{
    CNote note;

    ::EnterCriticalSection(&s_CriticalSection);
    
    while (m_Notes.GetNote(stEndTime,&note))
    {
        if (note.m_stTime < stStartTime)
        {
            TraceI(2, "Note started %d samples late!\n", (long)(stStartTime - note.m_stTime));

            note.m_stTime = stStartTime;
        }

        if (note.m_bKey > 0x7F) // Special command events.
        {
            long lTemp;
            DWORD dwPart = note.m_bPart;
            DWORD dwCommand = note.m_bKey;
            BYTE bData = note.m_bVelocity;
            switch (dwCommand)
            {
            case NOTE_PROGRAMCHANGE:
                m_dwProgram[dwPart] = bData |
                    (m_bBankH[dwPart] << 16) | 
                    (m_bBankL[dwPart] << 8);
                break;
            case NOTE_CC_BANKSELECTH:
                m_bBankH[dwPart] = bData;
                break;
            case NOTE_CC_BANKSELECTL:
                m_bBankL[dwPart] = bData;
                break;
            case NOTE_CC_POLYMODE:
                m_fMono[dwPart] = FALSE;
                break;
            case NOTE_CC_MONOMODE:
                m_fMono[dwPart] = TRUE;
                break;
            case NOTE_CC_RPN_MSB:
                m_nCurrentRPN[dwPart] = (m_nCurrentRPN[dwPart] & 0x7f) + (bData << 7);
                break;
            case NOTE_CC_RPN_LSB:
                m_nCurrentRPN[dwPart] = (m_nCurrentRPN[dwPart] & 0x3f80) + bData;
                break;
            case NOTE_CC_NRPN:
                m_nCurrentRPN[dwPart] = 0x3FFF;
                break;
            case NOTE_CC_DATAENTRYLSB:
                m_nData[dwPart] &= ~0x7F;
                m_nData[dwPart] |= bData;
                switch (m_nCurrentRPN[dwPart])
                {
                case RPN_PITCHBEND: // Don't do anything, Roland ignores lsb
                    break;
                case RPN_FINETUNE:
                    lTemp = m_nData[dwPart];
                    lTemp -= 8192;
                    lTemp *= 100;
                    lTemp /= 8192;
                    m_prFineTune[dwPart] = lTemp;
                    break;
                case RPN_COARSETUNE: // Ignore lsb
                    break;            
                }
                break;
            case NOTE_CC_DATAENTRYMSB:
                m_nData[dwPart] &= ~(0x7F << 7);
                m_nData[dwPart] |= bData << 7;
                switch (m_nCurrentRPN[dwPart])
                {
                case RPN_PITCHBEND:
                    m_PitchBend[dwPart].m_prRange = bData * 100;
                    break;
                case RPN_FINETUNE:
                    lTemp = m_nData[dwPart];
                    lTemp -= 8192;
                    lTemp *= 100;
                    lTemp /= 8192;
                    m_prFineTune[dwPart] = lTemp;
                    break;
                case RPN_COARSETUNE:
                    m_prCoarseTune[dwPart] = 100 * (bData - 64);
                    break;        
                }
                break;
            case NOTE_SUSTAIN: // special sustain marker
                m_fSustain[dwPart] = (BOOL) bData;
                if (bData == FALSE)
                {
                    CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
                    for (;pVoice != NULL;pVoice = pVoice->GetNext())
                    {
                        if (pVoice->m_fSustainOn &&
                            (pVoice->m_nPart == dwPart) &&
                            (pVoice->m_pControl == this))
                        {
                            pVoice->StopVoice(note.m_stTime);
                        }
                    }
                } 
                break;
            case NOTE_ALLOFF:
                {
                    CVoice *pVoice = m_pSynth->m_VoicesInUse.GetHead();
                    for (;pVoice != NULL; pVoice = pVoice->GetNext())
                    {
                        if (pVoice->m_fNoteOn && !pVoice->m_fSustainOn &&
                            (pVoice->m_nPart == dwPart) &&
                            (pVoice->m_pControl == this))
                        {
                            if (m_fSustain[dwPart])
                            {
                                pVoice->m_fSustainOn = TRUE;
                            }
                            else
                            {
                                pVoice->StopVoice(note.m_stTime);
                            }
                        }
                    }
                }
                break;
            case NOTE_SOUNDSOFF:
                {
                    CVoice *pVoice = m_pSynth->m_VoicesInUse.GetHead();
                    for (;pVoice != NULL; pVoice = pVoice->GetNext())
                    {
                        if ((pVoice->m_nPart == dwPart) &&
                            (pVoice->m_pControl == this))
                        {
                            pVoice->QuickStopVoice(note.m_stTime);
                        }
                    }
                }
                break;
            case NOTE_ASSIGNRECEIVE:
                m_bPartToChannel[dwPart] = (BYTE) bData;
                break;
            case NOTE_MASTERVOLUME:
                m_vrMasterVolume = CMIDIRecorder::VelocityToVolume(bData);
                break;
            }
        }
        else if (note.m_bVelocity == 0)  // Note Off.
        {
            CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
            WORD nPart = note.m_bPart;
            DWORD dwNoteID = 0; // Use to track multiple voices on one note.
            for (;pVoice != NULL;pVoice = pVoice->GetNext())
            {
                if (pVoice->m_fNoteOn && !pVoice->m_fSustainOn &&
                    (pVoice->m_nKey == (WORD) note.m_bKey) &&
                    (pVoice->m_nPart == nPart) &&
                    (pVoice->m_pControl == this)) 
                {
                    if (!dwNoteID || (dwNoteID == pVoice->m_dwNoteID))
                    {
                        dwNoteID = pVoice->m_dwNoteID;
                        if (m_fSustain[nPart])
                        {
                            pVoice->m_fSustainOn = TRUE;
                        }
                        else
                        {
                            pVoice->StopVoice(note.m_stTime);
                        }
                    }
                }
            }
        }
        else   // Note On.
        {
            DWORD dwProgram = m_dwProgram[note.m_bPart];
            if (m_bDrums[note.m_bPart])
            {
                dwProgram |= F_INSTRUMENT_DRUMS;
            }
            if (m_fMono[note.m_bPart])
            {
                CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
                WORD nPart = note.m_bPart;
                for (;pVoice != NULL;pVoice = pVoice->GetNext())
                {
                    if (pVoice->m_fNoteOn && (pVoice->m_nPart == nPart) &&
                        (pVoice->m_pControl == this)) 
                    {
                        pVoice->StopVoice(note.m_stTime);
                    }
                }
            }
            // While we are working with the instrument, including copying
            // the data over from the region, we have to make sure it
            // can not be removed from the instrument list.
            EnterCriticalSection(&m_pInstruments->m_CriticalSection);
            CInstrument * pInstrument = 
                m_pInstruments->GetInstrument(dwProgram,note.m_bKey,note.m_bVelocity);
            if (!pInstrument) 
            {
                if (dwProgram & F_INSTRUMENT_DRUMS)
                {
                    dwProgram = F_INSTRUMENT_DRUMS;
                    pInstrument = 
                        m_pInstruments->GetInstrument(dwProgram,note.m_bKey,note.m_bVelocity);
                }
                else if (m_fXGActive)
                {
                    if ((dwProgram & 0x7F0000) == 0x7F0000) // Drum?
                    {
                        dwProgram &= 0x7F007F;              // Enforce 0 LSB
                        pInstrument = 
                            m_pInstruments->GetInstrument(dwProgram,note.m_bKey,note.m_bVelocity);
                        if (!pInstrument)
                        {
                            dwProgram = 0x7F0000;
                            pInstrument = 
                                m_pInstruments->GetInstrument(dwProgram,note.m_bKey,note.m_bVelocity);
                        }
                    }
                    else
                    {
                        dwProgram &= 0x7F;  // Fall back to GM set.
                        pInstrument = 
                            m_pInstruments->GetInstrument(dwProgram,note.m_bKey,note.m_bVelocity);
                    }
                }
            }
            if (pInstrument != NULL)
            {
                DWORD dwNotesLost = 1;  // Assume note will be lost, will be decremented if played 
                CSourceRegion * pRegion = NULL;
                static DWORD sdwNoteID = 0; // Generate a unique id that will be placed in all voices that play this note.
                sdwNoteID++;                // This will be used to keep the voices associated so we can stop them all at once later.
                while ( pRegion = pInstrument->ScanForRegion(note.m_bKey, note.m_bVelocity, pRegion) ) 
                {
                    WORD nPart = note.m_bPart;
                    CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
                    if (!pRegion->m_bAllowOverlap)
                    {
                        for (;pVoice != NULL; pVoice = pVoice->GetNext())
                        {
                            if ((pVoice->m_nPart == nPart) &&
                                (pVoice->m_nKey == note.m_bKey) &&
                                (pVoice->m_pControl == this) && 
                                (pVoice->m_pRegion  == pRegion))
                            {
                                pVoice->QuickStopVoice(note.m_stTime);
                            }
                        }    
                    }

                    if (pRegion->m_bGroup != 0)
                    {
                        pVoice = m_pSynth->m_VoicesInUse.GetHead();
                        for (;pVoice != NULL;pVoice = pVoice->GetNext())
                        {
                            if ((pVoice->m_dwGroup == pRegion->m_bGroup) &&
                                (pVoice->m_nPart == nPart) &&
                                (pVoice->m_dwProgram == dwProgram) &&
                                (pVoice->m_pControl == this))
                            {
                                pVoice->QuickStopVoice(note.m_stTime);
                            }
                        }
                    }
                
                    pVoice = m_pSynth->m_VoicesFree.RemoveHead();
                    if (pVoice == NULL)
                    {
                        pVoice = m_pSynth->m_VoicesExtra.RemoveHead();
                    }

                    if (pVoice == NULL)
                    {
                        pVoice = m_pSynth->StealVoice(m_dwPriority[nPart]);
                        
                        // The voice IDs are used by the VoiceServiceThread in DMusic
                        // to refill the streaming wave buffers....
                        // Since the voice is stolen this voice could really belong to
                        // a streaming wave in which case preserving the voice ID will 
                        // break the refill code. (NOTE!! This is different from stealing
                        // voices for waves. Waves will ultimately preserve the voice ID as 
                        // they pass it to StartWave where it gets assigned to the voice's 
                        // m_dwVoiceId member).

                        if(pVoice)
                        {
                            // Set the voice ID to something unacceptable
                            pVoice->m_dwVoiceId = 0xffffffff;
                        }
                    }

                    if (pVoice != NULL)
                    {
                        PREL prPitch = m_prFineTune[nPart] + m_prScaleTune[nPart][note.m_bKey % 12];
                        if (!m_bDrums[nPart]) 
                        {
                            if (m_fXGActive)
                            {
                                if ((dwProgram & 0x7F0000) != 0x7F0000)
                                {
                                    prPitch += m_prCoarseTune[nPart];
                                }
                            }
                            else
                            {
                                prPitch += m_prCoarseTune[nPart];
                            }
                        }

                        pVoice->m_nKey = note.m_bKey;
                        pVoice->m_nPart = nPart;
                        pVoice->m_dwProgram = dwProgram;
                        pVoice->m_dwPriority = m_dwPriority[nPart];
                        pVoice->m_pControl = this;
                        pVoice->m_pRegion = pRegion;
                        pVoice->m_dwNoteID = sdwNoteID;

                        if (pVoice->StartVoice(m_pSynth,
                            pRegion, note.m_stTime, 
                            &m_ModWheel[nPart],
                            &m_PitchBend[nPart],
                            &m_Expression[nPart],
                            &m_Volume[nPart],
                            &m_Pan[nPart],
                            &m_Pressure[nPart],
                            &m_ReverbSends[nPart],
                            &m_ChorusSends[nPart],
                            &m_CutOffFreqCC[nPart],
                            &m_BusIds[nPart],
                            (WORD)note.m_bKey,
                            (WORD)note.m_bVelocity,
                            m_vrMasterVolume, 
                            prPitch))
                        {
                            pVoice->m_fInUse = TRUE;
                            m_pSynth->QueueVoice(pVoice);
                            dwNotesLost = 0;    // Note played remove notelost assumpstion 
                        }
                        else
                        {
                            m_pSynth->m_VoicesFree.AddHead(pVoice);
                        }
                    } 
                } 
                m_pSynth->m_BuildStats.dwNotesLost += dwNotesLost;
            } 
            else 
            {
                Trace(1,"Error: No instrument/region was found for patch # %lx, note %ld\n",
                    dwProgram, (long) note.m_bKey);
            }
            LeaveCriticalSection(&m_pInstruments->m_CriticalSection);
        }
    }

    ::LeaveCriticalSection(&s_CriticalSection);
}

void CControlLogic::Flush(STIME stTime)

{
    DWORD dwIndex;
    ::EnterCriticalSection(&s_CriticalSection);
    if (!m_fEmpty)
    {        
        m_fEmpty = TRUE;
        for (dwIndex = 0;dwIndex < 16; dwIndex++)
        {
            m_fEmpty = m_ModWheel[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_PitchBend[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_Volume[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_Expression[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_Pan[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_Pressure[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_ReverbSends[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_ChorusSends[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_CutOffFreqCC[dwIndex].FlushMIDI(stTime) && m_fEmpty;
        }
        m_Notes.FlushMIDI(stTime);
    }
    ::LeaveCriticalSection(&s_CriticalSection);
}

BOOL CControlLogic::RecordMIDI(STIME stTime,BYTE bStatus, BYTE bData1, BYTE bData2)

{
    WORD nPreChannel = bStatus & 0xF; 
    CNote note;
    bStatus = bStatus & 0xF0;
    BOOL bReturn = TRUE;
    WORD nPart;

    ::EnterCriticalSection(&s_CriticalSection);

    for (nPart = 0;nPart < 16; nPart++)
    {
        if (nPreChannel == m_bPartToChannel[nPart])
        {
            switch (bStatus)
            {
            case MIDI_NOTEOFF :
                bData2 = 0;
            case MIDI_NOTEON :
                note.m_bPart = (BYTE) nPart;
                note.m_bKey = bData1;
                note.m_bVelocity = bData2;
                bReturn = m_Notes.RecordNote(stTime,&note);
                break;
            case MIDI_CCHANGE :
                switch (bData1)
                {
                case CC_BANKSELECTH :
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_BANKSELECTH, bData2);
                    break;
                case CC_MODWHEEL :
                    m_fEmpty = FALSE;
                    bReturn = m_ModWheel[nPart].RecordMIDI(stTime,(long) bData2);
                    break;
                case CC_VOLUME :
                    m_fEmpty = FALSE;
                    bReturn = m_Volume[nPart].RecordMIDI(stTime,(long) bData2);
                    break;
                case CC_PAN :
                    m_fEmpty = FALSE;
                    bReturn = m_Pan[nPart].RecordMIDI(stTime,(long) bData2);
                    break;
                case CC_EXPRESSION :
                    m_fEmpty = FALSE;
                    bReturn = m_Expression[nPart].RecordMIDI(stTime,(long)bData2);
                    break;
                case CC_BANKSELECTL :
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_BANKSELECTL, bData2);
                    break;
                case CC_RESETALL:
                    m_fEmpty = FALSE;
                    if (bData2)
                    {
                        bReturn = bReturn && m_Volume[nPart].RecordMIDI(stTime, 100);
                        bReturn = bReturn && m_Pan[nPart].RecordMIDI(stTime, 64);
                    }
                    bReturn = bReturn && m_Expression[nPart].RecordMIDI(stTime, 127);
                    bReturn = bReturn && m_PitchBend[nPart].RecordMIDI(stTime, 0x2000);
                    bReturn = bReturn && m_ModWheel[nPart].RecordMIDI(stTime, 0);   
                    bReturn = bReturn && m_Pressure[nPart].RecordMIDI(stTime, 0);
                    bReturn = bReturn && m_ReverbSends[nPart].RecordMIDI(stTime, 40);
                    bReturn = bReturn && m_ChorusSends[nPart].RecordMIDI(stTime, 0);
                    bReturn = bReturn && m_CutOffFreqCC[nPart].RecordMIDI(stTime, 64);
                    bData2 = 0;
                    // fall through into Sustain Off case....
        
                case CC_SUSTAIN :
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SUSTAIN, bData2);
                    break;
                case CC_ALLSOUNDSOFF:
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SOUNDSOFF, 0);
                    break;
                case CC_ALLNOTESOFF:
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_ALLOFF, 0);
                    break;
                case CC_DATAENTRYMSB:
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_DATAENTRYMSB, bData2);
                    break;
                case CC_DATAENTRYLSB:
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_DATAENTRYLSB, bData2);
                    break;
                case CC_NRPN_LSB :
                case CC_NRPN_MSB :
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_NRPN, bData2);
                    break;
                case CC_RPN_LSB:
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_RPN_LSB, bData2);
                    break; 
                case CC_RPN_MSB:
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_RPN_MSB, bData2);
                    break;
                case CC_MONOMODE :
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_MONOMODE, bData2);
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SOUNDSOFF, 0);
                    break;
                case CC_POLYMODE :
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_POLYMODE, bData2);
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SOUNDSOFF, 0);
                    break;
                case CC_REVERB :
                    m_fEmpty = FALSE;
                    bReturn = m_ReverbSends[nPart].RecordMIDI(stTime,(long)bData2);
                    break;
                case CC_CHORUS :
                    m_fEmpty = FALSE;
                    bReturn = m_ChorusSends[nPart].RecordMIDI(stTime,(long)bData2);
                    break;
                case CC_CUTOFFFREQ:
                    m_fEmpty = FALSE;
                    bReturn = m_CutOffFreqCC[nPart].RecordMIDI(stTime,(long)bData2);
                    break;
                default:
                    break;
                }
                break;

            case MIDI_PCHANGE :
                bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_PROGRAMCHANGE, bData1);
                break;
        
            case MIDI_PBEND :
                m_fEmpty = FALSE;
                {
                    WORD nBend;
                    nBend = bData2 << 7;
                    nBend |= bData1;
                    bReturn = m_PitchBend[nPart].RecordMIDI(stTime,(long)nBend);
                }
                break;

            case MIDI_MTOUCH:
                m_fEmpty = FALSE;
                bReturn = m_Pressure[nPart].RecordMIDI(stTime,(long)bData1);
                break;
            }
        }
    }
    ::LeaveCriticalSection(&s_CriticalSection);

    return bReturn;
}

HRESULT CControlLogic::RecordSysEx(DWORD dwSysExLength,BYTE *pSysExData, STIME stTime)

{
    HRESULT hSuccess = S_OK;
    int nPart;
    int nTune;
    DWORD dwAddress;
    BOOL fClearAll = FALSE;
    BOOL fResetPatches = FALSE;
    if (dwSysExLength < 6) 
    {
        Trace(4,"Warning: Unknown sysex message sent to synth.\n");
        return E_FAIL;
    }

    EnterCriticalSection(&s_CriticalSection);

    switch (pSysExData[1])  // ID number
    {
    case 0x7E : // General purpose ID
        if (pSysExData[3] == 0x09) 
        {
            GMReset();
            fClearAll = TRUE;
            fResetPatches = TRUE;
        }
        break;
    case 0x7F : // Real time ID
        if (pSysExData[3] == 0x04)
        {
            if (pSysExData[4] == 1) // Master Volume
            {
                m_Notes.RecordEvent(stTime, 0, NOTE_MASTERVOLUME, pSysExData[6]);
            }
        }
        break;
    case 0x41 : // Roland
        if (dwSysExLength < 11) 
        {
            Trace(4,"Warning: Unknown sysex message sent to synth.\n");
            LeaveCriticalSection(&s_CriticalSection);
            return E_FAIL;
        }
        if (pSysExData[3] != 0x42) break;
        if (pSysExData[4] != 0x12) break;
        nPart = pSysExData[6] & 0xF;
        dwAddress = (pSysExData[5] << 16) |
            ((pSysExData[6] & 0xF0) << 8) | pSysExData[7];
        switch (dwAddress)
        {
        case 0x40007F :     // GS Reset.
            GMReset();
            m_fXGActive = FALSE;
            fClearAll = TRUE;
            m_fGSActive = TRUE;
            fResetPatches = TRUE;
            break;
        case 0x401002 :     // Set Receive Channel.
            if (m_fGSActive)
            {
                if (pSysExData[8])
                {
                    m_Notes.RecordEvent(stTime, nPart, NOTE_ASSIGNRECEIVE, pSysExData[8] - 1);
                }
            }
            break;
        case 0x401015 :     // Use for Rhythm.
            if (m_fGSActive)
            {
                m_bDrums[nPart] = pSysExData[8];
                fClearAll = TRUE;
            }
            break;
        case 0x401040 :     // Scale Tuning.
            if (m_fGSActive)
            {
                for (nTune = 0;nTune < 12; nTune++)
                {
                    if (pSysExData[9 + nTune] & 0x80) break;
                    m_prScaleTune[nPart][nTune] = 
                        (PREL) pSysExData[8 + nTune] - (PREL) 64;
                }
            }
            break;
        }
        break;
    case 0x43 : // Yamaha
        if ((pSysExData[3] == 0x4C) &&
            (pSysExData[4] == 0) &&
            (pSysExData[5] == 0) &&
            (pSysExData[6] == 0x7E) &&
            (pSysExData[7] == 0))
        {   // XG System On
            m_fXGActive = TRUE;
            m_fGSActive = FALSE;
            GMReset();
            m_fXGActive = TRUE;
            m_bDrums[0] = 0;
            m_bBankH[0] = 127;
            fClearAll = TRUE;
            fResetPatches = TRUE;
        }
        break;
    }
    if (fClearAll)
    {
        Flush(0);
        for (nPart = 0;nPart < 16;nPart++)
        {        
            m_Notes.RecordEvent(stTime, nPart, NOTE_SOUNDSOFF, 0);
            m_Notes.RecordEvent(stTime, nPart, NOTE_SUSTAIN, 0);
            m_Volume[nPart].RecordMIDI(stTime, 100);
            m_Pan[nPart].RecordMIDI(stTime, 64);
            m_Expression[nPart].RecordMIDI(stTime, 127);
            m_PitchBend[nPart].RecordMIDI(stTime, 0x2000);
            m_ModWheel[nPart].RecordMIDI(stTime, 0);
            m_Pressure[nPart].RecordMIDI(stTime, 0);
            m_ReverbSends[nPart].RecordMIDI(stTime, 40);
            m_ChorusSends[nPart].RecordMIDI(stTime, 0);
            m_CutOffFreqCC[nPart].RecordMIDI(stTime, 64);
        }
    }
    if (fResetPatches)
    {
        for (nPart = 0;nPart < 16;nPart++)
        {     
            if ((nPart == 0) && (m_fXGActive))
            {
                m_Notes.RecordEvent(stTime-1, nPart, NOTE_CC_BANKSELECTH, 127);
            }
            else
            {
                m_Notes.RecordEvent(stTime-1, nPart, NOTE_CC_BANKSELECTH, 0);
            }
            m_Notes.RecordEvent(stTime-1, nPart, NOTE_CC_BANKSELECTL, 0);
            m_Notes.RecordEvent(stTime, nPart, NOTE_PROGRAMCHANGE, 0);
        }
    }

    LeaveCriticalSection(&s_CriticalSection);
    return hSuccess;
}

HRESULT CControlLogic::SetChannelPriority(DWORD dwChannel,DWORD dwPriority)

{
    DWORD dwPart;
    for (dwPart = 0;dwPart < 16; dwPart++)
    {
        if (m_bPartToChannel[dwPart] == dwChannel)
        {
            m_dwPriority[dwPart] = dwPriority;
        }
    }
    return S_OK;
}

HRESULT CControlLogic::GetChannelPriority(DWORD dwChannel,LPDWORD pdwPriority)

{
    DWORD dwPart;
    for (dwPart = 0;dwPart < 16; dwPart++)
    {
        if (m_bPartToChannel[dwPart] == dwChannel)
        {
            *pdwPriority = m_dwPriority[dwPart];
            break;
        }
    }
    return S_OK;
}

//////////////////////////////////////////////////////////
// Directx8 Methods 

BOOL CControlLogic::RecordWaveEvent(
    STIME stTime, BYTE bChannel, DWORD dwVoiceId, VREL vrVolume, PREL prPitch, 
    SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd,
    CWaveArt* pWaveArt)

{
    WORD nPreChannel = bChannel;
    CWaveEvent wave;
    BOOL bReturn = TRUE;
    WORD nPart;

    ::EnterCriticalSection(&s_CriticalSection);

    for (nPart = 0;nPart < 16; nPart++)
    {
        if (nPreChannel == m_bPartToChannel[nPart])
        {
            wave.m_bPart        = (BYTE)nPart;
            wave.m_dwVoiceId    = dwVoiceId;
            wave.m_vrVolume     = vrVolume;
            wave.m_prPitch      = prPitch;
            wave.m_pWaveArt     = pWaveArt;
            wave.m_stVoiceStart = stVoiceStart;
            wave.m_stLoopStart  = stLoopStart;
            wave.m_stLoopEnd    = stLoopEnd;
            wave.m_pWaveArt->AddRef();

            bReturn = m_Waves.RecordWave(stTime,&wave);
        }
    }

    ::LeaveCriticalSection(&s_CriticalSection);

    return bReturn;
}

void CControlLogic::QueueWaves(STIME stEndTime)
{
    CWaveEvent wave;
    BOOL fGotAWave = TRUE;

    while (fGotAWave)
    {
        EnterCriticalSection(&m_pInstruments->m_CriticalSection);
        fGotAWave = m_Waves.GetWave(stEndTime,&wave);
        if (!fGotAWave)
        {
            LeaveCriticalSection(&m_pInstruments->m_CriticalSection);
            break;
        }

        WORD nPart = wave.m_bPart;

        CVoice * pVoice = m_pSynth->m_VoicesFree.RemoveHead();

        if (pVoice == NULL)
        {
            pVoice = m_pSynth->m_VoicesExtra.RemoveHead();
        }

        if (pVoice == NULL)
        {
            pVoice = m_pSynth->StealVoice(m_dwPriority[nPart]);
        }

        if (pVoice != NULL)
        {
            PREL prPitch = wave.m_prPitch;
            prPitch += m_prFineTune[nPart]; 
            prPitch += m_prCoarseTune[nPart];

            pVoice->m_nKey = 0xffff;                // set to unused values 
            pVoice->m_dwProgram = 0xffffffff;       // set to unused values 
            pVoice->m_nPart = nPart;
            pVoice->m_dwPriority = m_dwPriority[nPart];
            pVoice->m_pControl = this;
            pVoice->m_pRegion  = NULL;

            if (pVoice->StartWave(m_pSynth,
                wave.m_pWaveArt,
                wave.m_dwVoiceId, 
                wave.m_stTime, 
                &m_PitchBend[nPart],
                &m_Expression[nPart],
                &m_Volume[nPart],
                &m_Pan[nPart],
                &m_ReverbSends[nPart],
                &m_ChorusSends[nPart],
                &m_CutOffFreqCC[nPart],
                &m_BusIds[nPart],
                wave.m_vrVolume,    
                prPitch,
                wave.m_stVoiceStart,
                wave.m_stLoopStart,
                wave.m_stLoopEnd
                ))
            {
                pVoice->m_fInUse = TRUE;
                m_pSynth->QueueVoice(pVoice);
            }
            else
            {
                m_pSynth->m_VoicesFree.AddHead(pVoice);
            }
        } 
        else 
        {
            Trace(1,"Error: No voice avaible for voice id #%lx\n", wave.m_dwVoiceId);
        }
        if (wave.m_pWaveArt) wave.m_pWaveArt->Release(); // no longer need to hold this ref count
        LeaveCriticalSection(&m_pInstruments->m_CriticalSection);
    }
}

void CControlLogic::FlushWaveByStopTime(DWORD dwID, STIME stStopTime)
{
    EnterCriticalSection(&m_pInstruments->m_CriticalSection);
    m_Waves.RemoveWaveByStopTime(dwID, stStopTime);
    LeaveCriticalSection(&m_pInstruments->m_CriticalSection);
}

HRESULT CControlLogic::AssignChannelToBuses(DWORD dwChannel, LPDWORD pdwBusIds, DWORD dwBusCount)
{
    HRESULT hr = S_OK;

    DWORD dwPart;
    for (dwPart = 0;dwPart < 16; dwPart++)
    {
        if (m_bPartToChannel[dwPart] == dwChannel)
        {
            //
            // Assign new bus ids to this channel 
            //
            if ( pdwBusIds && dwBusCount > 0 )
            {
                hr = m_BusIds[dwPart].AssignBuses(pdwBusIds, dwBusCount);
            }
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
CWaveDataList    CWaveIn::m_sFreeList;
DWORD            CWaveIn::m_sUsageCount = 0;


CWaveData::CWaveData() 
{
    m_stTime = 0;
}

CWaveIn::CWaveIn()
{
    m_sUsageCount++;
    m_stCurrentTime = 0;
}

CWaveIn::~CWaveIn()

{
    ClearWave(0x7FFFFFFF);
    m_sUsageCount--;
    // If there are no instances of CMIDIRecorder left, get rid of the free pool.
    if (!m_sUsageCount)
    {
        CWaveData *pWD;
        while (pWD = m_sFreeList.RemoveHead())
        {
            delete pWD;
        }
    }
}

/*void CWaveIn::Init()
{
    int nIndex;
    static BOOL fAlreadyDone = FALSE;
    if (!fAlreadyDone)
    {
        m_sFreeList.RemoveAll();
        for (nIndex = 0; nIndex < MAX_MIDI_EVENTS; nIndex++)
        {
            m_sFreeList.AddHead(&m_sEventBuffer[nIndex]);
        }
        fAlreadyDone = TRUE;
    }
}*/

/*
BOOL CWaveIn::FlushWave(STIME stTime)

{
    CWaveData *pWD;
    CWaveData *pLast = NULL;

    for (pWD = m_EventList.GetHead();pWD != NULL;pWD = pWD->GetNext())
    {
        if (pWD->m_stTime >= stTime)
        {
            if (pLast == NULL)
            {
                m_EventList.RemoveAll();
            }
            else
            {
                pLast->SetNext(NULL);
            }
            m_sFreeList.Cat(pWD);
            break;
        }
        pLast = pWD;
    }
    return m_EventList.IsEmpty();
}
*/

BOOL CWaveIn::ClearWave(STIME stTime)

{
    CWaveData *pWD;

    for (;pWD = m_EventList.GetHead();)
    {
        if (pWD->m_stTime < stTime)
        {
            m_EventList.RemoveHead();
            m_stCurrentTime = pWD->m_stTime;
            m_lCurrentData  = pWD->m_WaveEventData;
            if (pWD->m_WaveEventData.m_pWaveArt)
            {
                pWD->m_WaveEventData.m_pWaveArt->Release();
                pWD->m_WaveEventData.m_pWaveArt = NULL;
            }
            m_sFreeList.AddHead(pWD);
            
        }
        else break;
    }
    return m_EventList.IsEmpty();
}

BOOL CWaveIn::RemoveWave(DWORD dwID)

{
    CWaveData *pWD = m_EventList.GetHead();
    CWaveData *pWDNext = NULL;

    for (; pWD; pWD = pWDNext)
    {
        pWDNext = pWD->GetNext();
        if (pWD->m_WaveEventData.m_dwVoiceId == dwID)
        {
            m_EventList.Remove(pWD);
            if (pWD->m_WaveEventData.m_pWaveArt)
            {
                pWD->m_WaveEventData.m_pWaveArt->Release();
                pWD->m_WaveEventData.m_pWaveArt = NULL;
            }
            m_sFreeList.AddHead(pWD);
        }
    }
    return m_EventList.IsEmpty();
}

BOOL CWaveIn::RemoveWaveByStopTime(DWORD dwID, STIME stStopTime)

{
    CWaveData *pWD = m_EventList.GetHead();
    CWaveData *pWDNext = NULL;

    for (; pWD; pWD = pWDNext)
    {
        pWDNext = pWD->GetNext();
        if (pWD->m_WaveEventData.m_dwVoiceId == dwID && pWD->m_stTime >= stStopTime)
        {
            m_EventList.Remove(pWD);
            if (pWD->m_WaveEventData.m_pWaveArt)
            {
                pWD->m_WaveEventData.m_pWaveArt->Release();
                pWD->m_WaveEventData.m_pWaveArt = NULL;
            }
            m_sFreeList.AddHead(pWD);
        }
    }
    return m_EventList.IsEmpty();
}

BOOL CWaveIn::RecordWave(STIME stTime, CWaveEvent* pWave)

{
    CWaveData *pWD = m_sFreeList.RemoveHead();
    if (!pWD)
    {
        pWD = new CWaveData;
    }    

    CWaveData *pScan = m_EventList.GetHead();
    CWaveData *pNext;

    if (pWD)
    {
        pWD->m_stTime        = stTime;
        pWD->m_WaveEventData = *pWave;
        pWD->m_WaveEventData.m_stTime = stTime;
        if (pScan == NULL)
        {
            m_EventList.AddHead(pWD);
        }
        else
        {
            if (pScan->m_stTime > stTime)
            {
                m_EventList.AddHead(pWD);
            }
            else
            {
                for (;pScan != NULL; pScan = pNext)
                {
                    pNext = pScan->GetNext();
                    if (pNext == NULL)
                    {
                        pScan->SetNext(pWD);
                    }
                    else
                    {
                        if (pNext->m_stTime > stTime)
                        {
                            pWD->SetNext(pNext);
                            pScan->SetNext(pWD);
                            break;
                        }
                    }
                }
            }
        }
        return (TRUE);
    }
    Trace(1,"Error: Wave Event pool empty.\n");

    return (FALSE);
}

BOOL CWaveIn::GetWave(STIME stTime, CWaveEvent *pWave)

{
    CWaveData *pWD = m_EventList.GetHead();

    if (pWD != NULL)
    {
        if (pWD->m_stTime <= stTime)
        {
            *pWave =  pWD->m_WaveEventData;
            m_EventList.RemoveHead();
            m_sFreeList.AddHead(pWD);
            return (TRUE);
        }
    }
    return (FALSE);
}

/////////////////////////////////////////////////////////////////
CBusIds::CBusIds()
{
    m_dwBusIds[0] = DSBUSID_LEFT;
    m_dwBusIds[1] = DSBUSID_RIGHT;
    m_dwBusIds[2] = DSBUSID_REVERB_SEND;
    m_dwBusIds[3] = DSBUSID_CHORUS_SEND;
    m_dwBusCount = NUM_DEFAULT_BUSES;
}

CBusIds::~CBusIds()
{
}

HRESULT CBusIds::Initialize()
{
    HRESULT hr = S_OK;

    m_dwBusIds[0] = DSBUSID_LEFT;
    m_dwBusIds[1] = DSBUSID_RIGHT;
    m_dwBusIds[2] = DSBUSID_REVERB_SEND;
    m_dwBusIds[3] = DSBUSID_CHORUS_SEND;
    m_dwBusCount = NUM_DEFAULT_BUSES;

    return hr;
}

HRESULT CBusIds::AssignBuses(LPDWORD pdwBusIds, DWORD dwBusCount)
{
    HRESULT hr = S_OK;

    if ( pdwBusIds && dwBusCount > 0 )
    {
        if ( dwBusCount > MAX_DAUD_CHAN )
            dwBusCount = MAX_DAUD_CHAN;

        memcpy(m_dwBusIds,pdwBusIds,sizeof(DWORD)*dwBusCount);
        m_dwBusCount = dwBusCount;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\csynth.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//
//      CSynth.h
//

#ifndef __CSYNTH_H__
#define __CSYNTH_H__

#include "synth.h"

#define MAX_CHANNEL_GROUPS	1000
#define MAX_VOICES			1000

// Forward declarations
struct IDirectSoundSynthSink;

class CSynth : public CListItem
{
friend class CControlLogic;
public:	
					CSynth();
					~CSynth();
    CSynth *		GetNext() {return(CSynth *)CListItem::GetNext();};
    HRESULT			SetStereoMode(DWORD dwBufferFlags);
    HRESULT			SetSampleRate(DWORD dwSampleRate);
	HRESULT			Activate(DWORD dwSampleRate, DWORD dwBufferFlags);
	HRESULT			Deactivate();
	HRESULT			Download(LPHANDLE phDownload, void *pdwData, LPBOOL bpFree);
	HRESULT			Unload(HANDLE hDownload,HRESULT ( CALLBACK *lpFreeMemory)(HANDLE,HANDLE),HANDLE hUserData);
	HRESULT			PlayBuffer(IDirectMusicSynthSink *pSynthSink, REFERENCE_TIME rt, LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable);
	HRESULT			SetNumChannelGroups(DWORD dwCableCount);
    void            SetGainAdjust(VREL vrGainAdjust);
    HRESULT			Open(DWORD dwCableCount, DWORD dwVoices, BOOL fReverb);
	HRESULT			Close();
    void			ResetPerformanceStats();
    HRESULT			AllNotesOff();
    HRESULT			SetMaxVoices(short nMaxVoices,short nTempVoices);
    HRESULT			GetMaxVoices(short *pnMaxVoices,short *pnTempVoices);
    HRESULT			GetPerformanceStats(PerfStats *pStats);
	void			Mix(short **ppvBuffer, DWORD *pdwIDs, DWORD *pdwFuncIDs, long *plPitchBends, DWORD dwBufferCount, DWORD dwBufferFlags, DWORD dwLength, LONGLONG llPosition);
    HRESULT         SetChannelPriority(DWORD dwChannelGroup,DWORD dwChannel,DWORD dwPriority);
    HRESULT         GetChannelPriority(DWORD dwChannelGroup,DWORD dwChannel,LPDWORD pdwPriority);
	HRESULT			SetReverb(DMUS_WAVES_REVERB_PARAMS *pParams);
    void            GetReverb(DMUS_WAVES_REVERB_PARAMS *pParams);
    void            SetReverbActive(BOOL fReverb);
    BOOL            IsReverbActive();

	/* DirectX8 methods */
	HRESULT			PlayBuffer(STIME stTime, REFERENCE_TIME rt, LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable);
	HRESULT			PlayBuffer(IDirectSoundSynthSink *pSynthSink, REFERENCE_TIME rt, LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable);
	HRESULT			PlayVoice(IDirectSoundSynthSink *pSynthSink, REFERENCE_TIME rt, DWORD dwVoiceId, DWORD dwChannelGroup, DWORD dwChannel, DWORD dwDLId, VREL vrVolume, PREL prPitch, SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd);
    HRESULT			StopVoice(IDirectSoundSynthSink *pSynthSink, REFERENCE_TIME rt, DWORD dwVoiceId);
    HRESULT			GetVoiceState(DWORD dwVoice[], DWORD cbVoice, DMUS_VOICE_STATE VoiceState[]);
    HRESULT			Refresh(DWORD dwDownloadID, DWORD dwFlags);
	HRESULT			AssignChannelToBuses(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwBusses, DWORD cBusses);
public:
    bool            BusIDToFunctionID(DWORD dwBusID, DWORD *pdwFunctionID, long *plPitchBends, DWORD *pdwIndex);   // Converts the passed bus id into the equivalent function id and position in buffer array. 
private:
    void			StealNotes(STIME stTime);
    void			StartMix(short *pBuffer,DWORD dwlength,BOOL bInterleaved);
    void			FinishMix(short *pBuffer,DWORD dwlength,BOOL bInterleaved);
	short			ChangeVoiceCount(CVoiceList *pList,short nOld,short nCount);

private:
    DWORD *         m_pdwBusIDs;        // Temp pointer to array of bus ids. This is valid only during a mix.
    DWORD *         m_pdwFuncIDs;       // Temp pointer to array of corresponding functional ids. This is also only valid during a mix.
    long *          m_plPitchBends;     // Temp pointer to array of corresponding pitch offsets.
    DWORD           m_dwBufferCount;    // Size of two preceding arrays.
    CVoice *        OldestVoice();
    void            QueueVoice(CVoice *pVoice);
    CVoice *        StealVoice(DWORD dwPriority);
    STIME           m_stLastTime;       // Sample time of last mix.
    CVoiceList      m_VoicesFree;       // List of available voices.
    CVoiceList      m_VoicesExtra;      // Extra voices for temporary overload.
    CVoiceList      m_VoicesInUse;      // List of voices currently in use.
    short           m_nMaxVoices;       // Number of allowed voices.
    short           m_nExtraVoices;      // Number of voices over the limit that can be used in a pinch.
    STIME           m_stLastStats;      // Last perfstats refresh.
    PerfStats       m_BuildStats;       // Performance info accumulator.
    PerfStats       m_CopyStats;        // Performance information for display.

    BOOL            m_fReverbActive;    // Whether reverb is currently on or off.
    long *          m_pStates;          // State storage for reverb.
    void *          m_pCoefs;           // Coeeficient storage for reverb.
    DMUS_WAVES_REVERB_PARAMS	m_ReverbParams; // Reverb settings.

public:	
    VREL            m_vrGainAdjust;     // Final output gain adjust
	// DLS-1 compatibility parameters: set these off to emulate hardware
	// which can't vary volume/pan during playing of a note.
    BOOL            m_fAllowPanWhilePlayingNote;
    BOOL            m_fAllowVolumeChangeWhilePlayingNote;

    STIME           m_stMinSpan;        // Minimum time allowed for mix time span.
    STIME           m_stMaxSpan;        // Maximum time allowed for mix time span.
	DWORD           m_dwSampleRate;		// Sample rate 
    DWORD           m_dwStereo;			// Is the output stereo 
    CInstManager    m_Instruments;      // Instrument manager.
	CControlLogic **m_ppControl;		// Array of open ControlLogics.
	DWORD			m_dwControlCount;	// # of open CLs.
    
    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.
    BOOL             m_fCSInitialized;
	BOOL			m_sfMMXEnabled;		// Is MMX enabled 
};

#endif// __CSYNTH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\csynth.cpp ===
//
// Copyright (c) 1996-2001 Microsoft Corporation
// CSynth.cpp
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else

#include "simple.h"
#include <mmsystem.h>
#include "dsoundp.h"
#include <dmusicc.h>
#include <dmusics.h>
#include "synth.h"
#include "CSynth.h"
#ifdef REVERB_ENABLED
#include "sverb.h"
#endif
#include "debug.h"
#endif

#include "dsoundp.h"    // For IDirectSoundSynthSink

#ifdef _X86_
#define MMX_ENABLED 1
#endif

#ifdef MMX_ENABLED
BOOL MultiMediaInstructionsSupported();
#endif


CSynth::CSynth()

{
    DWORD nIndex;
    CVoice *pVoice;

    m_fCSInitialized = FALSE;
    ::InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
    m_fCSInitialized = TRUE;

    for (nIndex = 0;nIndex < MAX_NUM_VOICES;nIndex++)
    {
        pVoice = new CVoice;
        if (pVoice != NULL)
        {
            m_VoicesFree.AddHead(pVoice);
        }
    }
    for (nIndex = 0;nIndex < NUM_EXTRA_VOICES;nIndex++)
    {
        pVoice = new CVoice;
        if (pVoice != NULL)
        {
            m_VoicesExtra.AddHead(pVoice);
        }
    }
    m_fReverbActive = FALSE;
    m_pCoefs = NULL;
    m_pStates = NULL;
    m_ReverbParams.fInGain = 0.0;
    m_ReverbParams.fReverbMix = -10.0;
    m_ReverbParams.fReverbTime = 1000.0;
    m_ReverbParams.fHighFreqRTRatio = (float) 0.001;
    m_ppControl = NULL;
    m_dwControlCount = 0;
    m_nMaxVoices = MAX_NUM_VOICES;
    m_nExtraVoices = NUM_EXTRA_VOICES;
    m_stLastStats = 0;
    m_fAllowPanWhilePlayingNote = TRUE;
    m_fAllowVolumeChangeWhilePlayingNote = TRUE;
    ResetPerformanceStats();
    m_stLastTime = 0;
    m_dwSampleRate = SAMPLE_RATE_22;
    SetSampleRate(SAMPLE_RATE_22);
    SetStereoMode(BUFFERFLAG_INTERLEAVED);
    SetGainAdjust(600);

    m_sfMMXEnabled = FALSE;
#ifdef MMX_ENABLED
    m_sfMMXEnabled = MultiMediaInstructionsSupported();
#endif // MMX_ENABLED
}

CSynth::~CSynth()

{
    CVoice *pVoice;

    if (m_fCSInitialized)
    {
        // If CS never initialized, nothing else will have been set up
        //
        Close();
        while (pVoice = m_VoicesInUse.RemoveHead())
        {
            delete pVoice;
        }
        while (pVoice = m_VoicesFree.RemoveHead())
        {
            delete pVoice;
        }
        while (pVoice = m_VoicesExtra.RemoveHead())
        {
            delete pVoice;
        }

        DeleteCriticalSection(&m_CriticalSection);
    }
}

short CSynth::ChangeVoiceCount(CVoiceList *pList,short nOld,short nCount)

{
    if (nCount > nOld)
    {
        short nNew = nCount - nOld;
        for (;nNew != 0; nNew--)
        {
            CVoice *pVoice = new CVoice;
            if (pVoice != NULL)
            {
                pList->AddHead(pVoice);
            }
        }
    }
    else
    {
        short nNew = nOld - nCount;
        for (;nNew > 0; nNew--)
        {
            CVoice *pVoice = pList->RemoveHead();
            if (pVoice != NULL)
            {
                delete pVoice;
            }
            else
            {
                nCount += nNew;
                break;
            }
        }
    }
    return nCount;
}

HRESULT CSynth::SetMaxVoices(short nVoices,short nTempVoices)

{
    if (nVoices < 1)
    {
        nVoices = 1;
    }
    if (nTempVoices < 1)
    {
        nTempVoices = 1;
    }
    ::EnterCriticalSection(&m_CriticalSection);

    m_nMaxVoices = ChangeVoiceCount(&m_VoicesFree,m_nMaxVoices,nVoices);
    m_nExtraVoices = ChangeVoiceCount(&m_VoicesExtra,m_nExtraVoices,nTempVoices);

    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSynth::SetNumChannelGroups(DWORD dwCableCount)

{
    HRESULT hr = S_OK;
    CControlLogic **ppControl;
    if ((dwCableCount < 1) || (dwCableCount > MAX_CHANNEL_GROUPS))
    {
        Trace(1,"Error: Request to set synth to %ld channel groups is invalid.\n",dwCableCount);
        return E_INVALIDARG;
    }
    ::EnterCriticalSection(&m_CriticalSection);
    if (m_dwControlCount != dwCableCount)
    {
        try
        {
            ppControl = new CControlLogic *[dwCableCount];
        }
        catch( ... )
        {
            ppControl = NULL;
        }

        if (ppControl)
        {
            DWORD dwX;
            for (dwX = 0; dwX < dwCableCount; dwX++)
            {
                ppControl[dwX] = NULL;
            }
            if (m_dwControlCount < dwCableCount)
            {
                for (dwX = 0; dwX < m_dwControlCount; dwX++)
                {
                    ppControl[dwX] = m_ppControl[dwX];
                }
                for (;dwX < dwCableCount; dwX++)
                {
                    try
                    {
                        ppControl[dwX] = new CControlLogic;
                    }
                    catch( ... )
                    {
                        ppControl[dwX] = NULL;
                    }

                    if (ppControl[dwX])
                    {
                        hr = ppControl[dwX]->Init(&m_Instruments, this);
                        if (FAILED(hr))
                        {
                            delete ppControl[dwX];
                            ppControl[dwX] = NULL;
                            dwCableCount = dwX;
                            break;
                        }

                        ppControl[dwX]->SetGainAdjust(m_vrGainAdjust);
                    }
                    else
                    {
                        dwCableCount = dwX;
                        break;
                    }
                }
            }
            else
            {
                AllNotesOff();
                for (dwX = 0; dwX < dwCableCount; dwX++)
                {
                    ppControl[dwX] = m_ppControl[dwX];
                }
                for (; dwX < m_dwControlCount; dwX++)
                {
                    if (m_ppControl[dwX])
                    {
                        delete m_ppControl[dwX];
                    }
                }
            }
            if (m_ppControl)
            {
                delete[] m_ppControl;
            }
            m_ppControl = ppControl;
            m_dwControlCount = dwCableCount;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

void CSynth::SetGainAdjust(VREL vrGainAdjust)
{
    DWORD idx;

    m_vrGainAdjust = vrGainAdjust;
    ::EnterCriticalSection(&m_CriticalSection);

    for (idx = 0; idx < m_dwControlCount; idx++)
    {
        m_ppControl[idx]->SetGainAdjust(m_vrGainAdjust);
    }

    ::LeaveCriticalSection(&m_CriticalSection);
}

HRESULT CSynth::SetReverb(DMUS_WAVES_REVERB_PARAMS *pParams)

{
    m_ReverbParams = *pParams;
    if (m_pCoefs)
    {
#ifdef REVERB_ENABLED
        ::SetSVerb(m_ReverbParams.fInGain,m_ReverbParams.fReverbMix,
            m_ReverbParams.fReverbTime,m_ReverbParams.fHighFreqRTRatio,m_pCoefs );
#endif
    }
    return S_OK;;
}

void CSynth::SetReverbActive(BOOL fReverb)

{
    ::EnterCriticalSection(&m_CriticalSection);
#ifdef REVERB_ENABLED
    if (m_fReverbActive != fReverb)
    {
        if (m_fReverbActive = fReverb)
        {
            if (!m_pCoefs)
            {
                long lSize = GetCoefsSize();
                m_pCoefs = (void *) malloc(lSize);
                lSize = GetStatesSize();
                m_pStates = (long *) malloc(lSize);
                if (m_pCoefs && m_pStates)
                {
                    memset((void *) m_pStates,0,lSize);
                    InitSVerb( (float) m_dwSampleRate, m_pCoefs);
                    InitSVerbStates( m_pStates );
                    SetReverb(&m_ReverbParams);
                }
            }
            else if (m_pStates)
            {
                InitSVerbStates( m_pStates );
            }
        }
    }
#else
        m_fReverbActive = FALSE;
#endif
    ::LeaveCriticalSection(&m_CriticalSection);
}

void CSynth::GetReverb(DMUS_WAVES_REVERB_PARAMS *pParams)
{
    *pParams = m_ReverbParams;
}

BOOL CSynth::IsReverbActive()

{
    return m_fReverbActive;
}


HRESULT CSynth::Open(DWORD dwCableCount, DWORD dwVoices, BOOL fReverb)

{
    HRESULT hr = S_OK;
    if ((dwCableCount < 1) || (dwCableCount > MAX_CHANNEL_GROUPS))
    {
        Trace(1,"Error: Request to open synth with %ld channel groups is invalid.\n",dwCableCount);
        return E_INVALIDARG;
    }
    if (m_ppControl)
    {
        Trace(1,"Error: Request to open synth failed because synth was already opened.\n");
        return E_FAIL;  // Already opened.
    }
    ::EnterCriticalSection(&m_CriticalSection);
    hr = SetNumChannelGroups(dwCableCount);
    if (SUCCEEDED(hr))
    {
        short nTemp = (short) dwVoices / 4;
        if (nTemp < 4) nTemp = 4;
        SetMaxVoices((short) dwVoices, nTemp);
    }
    SetReverbActive(fReverb);
    m_vrGainAdjust = 0;
    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CSynth::Close()

{
    ::EnterCriticalSection(&m_CriticalSection);
    AllNotesOff();
    DWORD dwX;
    for (dwX = 0; dwX < m_dwControlCount; dwX++)
    {
        if (m_ppControl[dwX])
        {
            delete m_ppControl[dwX];
        }
    }
    m_dwControlCount = 0;
    if (m_ppControl)
    {
        delete[] m_ppControl;
        m_ppControl = NULL;
    }
    m_stLastStats = 0;
    m_stLastTime = 0;
    m_fReverbActive = FALSE;
#ifdef REVERB_ENABLED
    if (m_pCoefs)
    {
        free(m_pCoefs);
        m_pCoefs = NULL;
    }
    if (m_pStates)
    {
        free(m_pStates);
        m_pStates = NULL;
    }
#endif
    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSynth::GetMaxVoices(
    short * pnMaxVoices,    // Returns maximum number of allowed voices for continuous play.
    short * pnTempVoices )  // Returns number of extra voices for voice overflow.
{
    if (pnMaxVoices != NULL)
    {
        *pnMaxVoices = m_nMaxVoices;
    }
    if (pnTempVoices != NULL)
    {
        *pnTempVoices = m_nExtraVoices;
    }
    return S_OK;
}

HRESULT CSynth::SetSampleRate(
    DWORD dwSampleRate)
{
    HRESULT hr = S_OK;

    // Can't set the sample rate to 0
    if (dwSampleRate == 0)
    {
        Trace(1,"Error: Request to set sample rate to 0 failed.\n");
        return E_INVALIDARG;
    }

    ::EnterCriticalSection(&m_CriticalSection);
    AllNotesOff();
    if ( m_dwSampleRate || dwSampleRate )
    {
        m_stLastTime *= dwSampleRate;
        m_stLastTime /= m_dwSampleRate;
    }

//>>>>>>>>>>> why is this commented out????
    // m_stLastTime = MulDiv(m_stLastTime,dwSampleRate,m_dwSampleRate);
    m_stLastStats = 0;
    m_dwSampleRate = dwSampleRate;
    m_stMinSpan = dwSampleRate / 100;   // 10 ms.
    m_stMaxSpan = (dwSampleRate + 19) / 20;    // 50 ms.
    ::LeaveCriticalSection(&m_CriticalSection);
    m_Instruments.SetSampleRate(dwSampleRate);
    return hr;
}

HRESULT CSynth::Activate(DWORD dwSampleRate, DWORD dwBufferFlags)

{
#ifdef REVERB_ENABLED
    if (m_fReverbActive && m_pStates && m_pCoefs)
    {
        InitSVerb( (float) m_dwSampleRate, m_pCoefs);
        InitSVerbStates( m_pStates );
        SetReverb(&m_ReverbParams);
    }
#endif
    m_stLastTime = 0;
    SetSampleRate(dwSampleRate);
    SetStereoMode(dwBufferFlags);
    ResetPerformanceStats();
    return S_OK;
}

HRESULT CSynth::Deactivate()

{
    AllNotesOff();
    return S_OK;
}

HRESULT CSynth::GetPerformanceStats(PerfStats *pStats)

{
    if (pStats == NULL)
    {
        Trace(1,"Error: Null pointer passed for performance stats.\n");
        return E_POINTER;
    }
    *pStats = m_CopyStats;
    return (S_OK);
}

bool CSynth::BusIDToFunctionID(DWORD dwBusID, DWORD *pdwFunctionID, long *plPitchBends, DWORD *pdwIndex)

{
    // This should only be called if the internal bus pointers exist and there is at least one buffer.
    assert(m_pdwBusIDs && m_pdwFuncIDs && m_plPitchBends && m_dwBufferCount);
    // Scan through the list of bus ids, looking for the match for dwBusID.
    for ( DWORD nIndexSinkIds = 0; nIndexSinkIds < m_dwBufferCount; nIndexSinkIds++ )
    {
        // Is this one it?
        if (m_pdwBusIDs[nIndexSinkIds] == dwBusID)
        {
            *pdwFunctionID = m_pdwFuncIDs[nIndexSinkIds];
            if (plPitchBends)
                *plPitchBends = m_plPitchBends[nIndexSinkIds];
            if (pdwIndex)
                *pdwIndex = nIndexSinkIds;
            return true;
        }
    }
    return false;
}

void CSynth::Mix(short **ppvBuffer, DWORD *pdwIDs, DWORD *pdwFuncIDs, long *plPitchBends, DWORD dwBufferCount, DWORD dwBufferFlags,  DWORD dwLength, LONGLONG llPosition)
{
    static BOOL fDidLast = FALSE;

    STIME stEndTime;
    CVoice *pVoice;
    CVoice *pNextVoice;
    long lNumVoices = 0;
    DWORD i;

    ::EnterCriticalSection(&m_CriticalSection);

    // Store pointers to the id arrays so we can access them from BusIDToFunctionID.
    m_pdwBusIDs = pdwIDs;
    m_pdwFuncIDs = pdwFuncIDs;
    m_plPitchBends = plPitchBends;
    m_dwBufferCount = dwBufferCount;

/*  // Useful for debugging the incoming buses...
    static DWORD sdwCountDown = 0;
    if (!sdwCountDown)
    {
        for (DWORD dwIX = 0; dwIX < dwBufferCount; dwIX++)
        {
            Trace(0,"%ld:%ld->%ld\t",dwIX,pdwIDs[dwIX],pdwFuncIDs[dwIX]);
        }
        Trace(0,"\n");
        sdwCountDown = 100;
    }
    sdwCountDown--;*/

    LONG    lTime = - (LONG)::GetTheCurrentTime();

    stEndTime = llPosition + dwLength;
    StealNotes(stEndTime);
    DWORD dwX;

    for ( i = 0; i < dwBufferCount; i++ )
    {
        // For interleaved buffers only the first buss is valid
        if ( dwBufferFlags & BUFFERFLAG_INTERLEAVED && i > 0 )
        {
            break;
        }
        StartMix(ppvBuffer[i],dwLength,(dwBufferFlags&BUFFERFLAG_INTERLEAVED));
    }

    for (dwX = 0; dwX < m_dwControlCount; dwX++)
    {
        m_ppControl[dwX]->QueueNotes(llPosition, stEndTime);
        m_ppControl[dwX]->QueueWaves(stEndTime);
    }
    pVoice = m_VoicesInUse.GetHead();

    for (;pVoice != NULL;pVoice = pNextVoice)
    {
        if (pVoice->m_stWaveStopTime && (pVoice->m_stWaveStopTime < stEndTime))
        {
            pVoice->StopVoice(pVoice->m_stWaveStopTime);
        }
        pNextVoice = pVoice->GetNext();
        pVoice->Mix(ppvBuffer, dwBufferFlags, dwLength, llPosition, stEndTime);

        lNumVoices++;

        if (pVoice->m_fInUse == FALSE)
        {
            m_VoicesInUse.Remove(pVoice);
            m_VoicesFree.AddHead(pVoice);

            if (pVoice->m_stStartTime < m_stLastStats)
            {
                m_BuildStats.dwTotalSamples += (long) (pVoice->m_stStopTime - m_stLastStats);
            }
            else
            {
                m_BuildStats.dwTotalSamples += (long) (pVoice->m_stStopTime - pVoice->m_stStartTime);
            }
        }
    }

    for (dwX = 0; dwX < m_dwControlCount; dwX++)
    {
        m_ppControl[dwX]->ClearMIDI(stEndTime);
    }

#ifdef REVERB_ENABLED
    if (m_fReverbActive && m_pCoefs && m_pStates && !(dwBufferFlags & BUFFERFLAG_MULTIBUFFER) )
    {
        if (dwBufferFlags & BUFFERFLAG_INTERLEAVED)
        {
            SVerbStereoToStereoShort(dwLength,ppvBuffer[0],ppvBuffer[0],m_pCoefs,m_pStates);
        }
        else
        {
            SVerbMonoToMonoShort(dwLength,ppvBuffer[0],ppvBuffer[0],m_pCoefs,m_pStates);
        }
    }
#endif

    for ( i = 0; i < dwBufferCount; i++ )
    {
        // For interleaved buffers only the first buss is valid
        if ( dwBufferFlags & BUFFERFLAG_INTERLEAVED && i > 0 )
        {
            break;
        }
        FinishMix(ppvBuffer[i],dwLength,(dwBufferFlags&BUFFERFLAG_INTERLEAVED));
    }

    if (stEndTime > m_stLastTime)
    {
        m_stLastTime = stEndTime;
    }

    lTime += ::GetTheCurrentTime();

    m_BuildStats.dwTotalTime += lTime;

    if ((m_stLastStats + m_dwSampleRate) <= m_stLastTime)
    {
        DWORD dwElapsed = (DWORD) (m_stLastTime - m_stLastStats);
        pVoice = m_VoicesInUse.GetHead();

        for (;pVoice != NULL;pVoice = pVoice->GetNext())
        {
            if (pVoice->m_stStartTime < m_stLastStats)
            {
                m_BuildStats.dwTotalSamples += dwElapsed;
            }
            else
            {
                m_BuildStats.dwTotalSamples += (long) (m_stLastTime - pVoice->m_stStartTime);
            }
        }

        if (dwElapsed == 0)
            dwElapsed = 1;

        if (m_BuildStats.dwTotalSamples == 0)
            m_BuildStats.dwTotalSamples = 1;

        m_BuildStats.dwVoices =
            (m_BuildStats.dwTotalSamples + (dwElapsed >> 1)) / dwElapsed;
        {
            m_BuildStats.dwCPU = MulDiv(m_BuildStats.dwTotalTime,
                m_dwSampleRate, dwElapsed);
        }

        m_CopyStats = m_BuildStats;
        memset(&m_BuildStats, 0, sizeof(m_BuildStats));
        m_stLastStats = m_stLastTime;
    }

    m_pdwBusIDs = NULL;
    m_pdwFuncIDs = NULL;
    m_plPitchBends = NULL;
    m_dwBufferCount = 0;

    ::LeaveCriticalSection(&m_CriticalSection);
}

CVoice *CSynth::OldestVoice()

{
    CVoice *pVoice;
    CVoice *pBest = NULL;
    pVoice = m_VoicesInUse.GetHead();
    pBest = pVoice;
    if (pBest)
    {
        pVoice = pVoice->GetNext();
        for (;pVoice;pVoice = pVoice->GetNext())
        {
            if (!pVoice->m_fTag)
            {
                if (pBest->m_fTag)
                {
                    pBest = pVoice;
                }
                else
                {
                    if (pVoice->m_dwPriority <= pBest->m_dwPriority)
                    {
                        if (pVoice->m_fNoteOn)
                        {
                            if (pBest->m_fNoteOn)
                            {
                                if (pBest->m_stStartTime > pVoice->m_stStartTime)
                                {
                                    pBest = pVoice;
                                }
                            }
                        }
                        else
                        {
                            if (pBest->m_fNoteOn ||
                                (pBest->m_vrVolume > pVoice->m_vrVolume))
                            {
                                pBest = pVoice;
                            }
                        }
                    }
                }
            }
        }
        if (pBest->m_fTag)
        {
            pBest = NULL;
        }
    }
    return pBest;
}

CVoice *CSynth::StealVoice(DWORD dwPriority)

{
    CVoice *pVoice;
    CVoice *pBest = NULL;
    pVoice = m_VoicesInUse.GetHead();
    for (;pVoice != NULL;pVoice = pVoice->GetNext())
    {
        if (pVoice->m_dwPriority <= dwPriority)
        {
            if (!pBest)
            {
                pBest = pVoice;
            }
            else
            {
                if (pVoice->m_fNoteOn == FALSE)
                {
                    if ((pBest->m_fNoteOn == TRUE) ||
                        (pBest->m_vrVolume > pVoice->m_vrVolume))
                    {
                        pBest = pVoice;
                    }
                }
                else
                {
                    if (pBest->m_stStartTime > pVoice->m_stStartTime)
                    {
                        pBest = pVoice;
                    }
                }
            }
        }
    }
    if (pBest != NULL)
    {
        pBest->ClearVoice();
        pBest->m_fInUse = FALSE;
        m_VoicesInUse.Remove(pBest);

        pBest->SetNext(NULL);
    }
    return pBest;
}

void CSynth::QueueVoice(CVoice *pVoice)

/*  This function queues a voice in the list of currently
    synthesizing voices. It places them in the queue so that
    the higher priority voices are later in the queue. This
    allows the note stealing algorithm to take off the top of
    the queue.
    And, we want older playing notes to be later in the queue
    so the note ons and offs overlap properly. So, the queue is
    sorted in priority order with older notes later within one
    priority level.
*/

{
    CVoice *pScan = m_VoicesInUse.GetHead();
    CVoice *pNext = NULL;
    if (!pScan) // Empty list?
    {
        m_VoicesInUse.AddHead(pVoice);
        return;
    }
    if (pScan->m_dwPriority > pVoice->m_dwPriority)
    {   // Are we lower priority than the head of the list?
        m_VoicesInUse.AddHead(pVoice);
        return;
    }

    pNext = pScan->GetNext();
    for (;pNext;)
    {
        if (pNext->m_dwPriority > pVoice->m_dwPriority)
        {
            // Lower priority than next in the list.
            pScan->SetNext(pVoice);
            pVoice->SetNext(pNext);
            return;
        }
        pScan = pNext;
        pNext = pNext->GetNext();
    }
    // Reached the end of the list.
    pScan->SetNext(pVoice);
    pVoice->SetNext(NULL);
}

void CSynth::StealNotes(STIME stTime)

{
    CVoice *pVoice;
    long lToMove = m_nExtraVoices - m_VoicesExtra.GetCount();
    if (lToMove > 0)
    {
        for (;lToMove > 0;)
        {
            pVoice = m_VoicesFree.RemoveHead();
            if (pVoice != NULL)
            {
                m_VoicesExtra.AddHead(pVoice);
                lToMove--;
            }
            else break;
        }
        if (lToMove > 0)
        {
            pVoice = m_VoicesInUse.GetHead();
            for (;pVoice;pVoice = pVoice->GetNext())
            {
                if (pVoice->m_fTag) // Voice is already slated to be returned.
                {
                    lToMove--;
                }
            }
            for (;lToMove > 0;lToMove--)
            {
                pVoice = OldestVoice();
                if (pVoice != NULL)
                {
                    pVoice->QuickStopVoice(stTime);
                    m_BuildStats.dwNotesLost++;
                }
                else break;
            }
        }
    }
}

#ifndef i386
void CSynth::StartMix(short *pBuffer,DWORD dwLength, BOOL bInterleaved)
{
    DWORD dwIndex = 0;
    DWORD dwLen = dwLength << bInterleaved;

    for (; dwIndex < dwLen; dwIndex++)
    {
        pBuffer[dwIndex] <<= 1;
    }
}
#else
void CSynth::StartMix(short *pBuffer,DWORD dwLength, BOOL bInterleaved)
{
    DWORD dwIndex;
    DWORD dwLen = dwLength << bInterleaved;

    dwIndex = 0;

    if (m_sfMMXEnabled && dwLen >= 16)
    {
        dwIndex = (dwLen & ~0x0000000F);

        _asm {
            mov         eax, dwIndex
            mov         ebx, pBuffer
            lea         ebx, [ebx+eax*2]        // move to the end to start...
            neg         eax

TopOfLoop:
            movq        mm0, [ebx+eax*2]
            movq        mm1, [ebx+eax*2+8]

            psraw       mm0, 1

            movq        mm2, [ebx+eax*2+16]

            psraw       mm1, 1

            movq        mm3, [ebx+eax*2+24]

            psraw       mm2, 1

            movq        [ebx+eax*2], mm0

            psraw       mm3, 1

            movq        [ebx+eax*2+8], mm1
            movq        [ebx+eax*2+16], mm2
            movq        [ebx+eax*2+24], mm3

            add         eax, 16
            jl          TopOfLoop

            emms
        }
    }

    for (; dwIndex < dwLen; dwIndex++)
    {
        pBuffer[dwIndex] <<= 1;
    }
}
#endif

//////////////////////////////////////////////////////////////////
// FinishMix - C Base for Optimized code
#ifndef i386
void CSynth::FinishMix(short *pBuffer,DWORD dwLength, BOOL bInterleaved)

{
    DWORD dwIndex = 0;
    long lMax = (long) m_BuildStats.dwMaxAmplitude;
    long lTemp;
    DWORD dwLen = dwLength << bInterleaved;

    for (; dwIndex < dwLen; dwIndex++)
    {
        lTemp = pBuffer[dwIndex];
        lTemp <<= 1;

        if (lTemp < -32767) lTemp = -32767;
        if (lTemp > 32767) lTemp = 32767;

        pBuffer[dwIndex] = (short) lTemp;
        if (lTemp > lMax)
        {
            lMax = lTemp;
        }
        else if (lTemp < 0 && -lTemp > lMax)
        {
            lMax = -lTemp;
        }
    }
    m_BuildStats.dwMaxAmplitude = lMax;
}
#else
void CSynth::FinishMix(short *pBuffer,DWORD dwLength, BOOL bInterleaved)
{
    DWORD dwIndex;
    long lMax = (long) m_BuildStats.dwMaxAmplitude;
    long lTemp;
    DWORD dwLen = dwLength << bInterleaved;

    short PosMax, NegMax;

    PosMax =   (short) lMax;
    NegMax = - (short) lMax;

    dwIndex = 0;

    if (m_sfMMXEnabled && dwLen >= 4)
    {
        dwIndex = (dwLen & ~0x3);

        _asm {
            mov         eax, dwIndex
            mov         ebx, pBuffer
            lea         ebx, [ebx+eax*2]        // move to the end to start...
            neg         eax
            pxor        mm0, mm0
            movsx       ecx,  WORD PTR PosMax
            movsx       edx,  WORD PTR NegMax
Start:
            movq        mm1, QWORD PTR [ebx+eax*2]
            movq        mm2, mm1
            punpcklwd   mm1, mm0
            punpckhwd   mm2, mm0
            pslld       mm1, 16
            pslld       mm2, 16
            psrad       mm1, 15
            psrad       mm2, 15
            packssdw    mm1, mm2
            movq        QWORD PTR [ebx+eax*2], mm1
            movsx       esi, WORD PTR [ebx+eax*2]
            movsx       edi, WORD PTR [ebx+eax*2+2]

            cmp         esi, ecx
            jg          Max1
Max10:      cmp         edi, edx
            jl          Min1

Min10:      movsx       esi, WORD PTR [ebx+eax*2+4]
            cmp         edi, ecx
            jg          Max2
Max20:      cmp         edi, edx
            jl          Min2

Min20:      movsx       edi, WORD PTR [ebx+eax*2+6]
            cmp         esi, ecx
            jg          Max3
Max30:      cmp         esi, edx
            jl          Min3

Min30:      cmp         edi, ecx
            jg          Max4
Max40:      cmp         edi, edx
            jl          Min4

Min40:      add         eax, 4
            jl          Start
            jmp         Finished
Max1:
            mov         ecx, esi
            jmp         Max10
Max2:
            mov         ecx, edi
            jmp         Max20
Max3:
            mov         ecx, esi
            jmp         Max30
Max4:
            mov         ecx, edi
            jmp         Max40
Min1:
            mov         edx, esi
            jmp         Min10
Min2:
            mov         edx, edi
            jmp         Min20
Min3:
            mov         edx, esi
            jmp         Min30
Min4:
            mov         edx, edi
            jmp         Min40
Finished:
            emms
            mov         WORD PTR PosMax, cx
            mov         WORD PTR NegMax, dx
        }
        if (lMax < PosMax)
            lMax = PosMax;

        if (lMax < -NegMax)
            lMax = -NegMax;
    }

    for (; dwIndex < dwLen; dwIndex++)
    {
        lTemp = pBuffer[dwIndex];
        lTemp <<= 1;

        if (lTemp < -32767) lTemp = -32767;
        if (lTemp > 32767) lTemp = 32767;

        pBuffer[dwIndex] = (short) lTemp;
        if (lTemp > lMax)
        {
            lMax = lTemp;
        }
        else if (lTemp < 0 && -lTemp > lMax)
        {
            lMax = -lTemp;
        }
    }

    m_BuildStats.dwMaxAmplitude = lMax;
}
#endif

HRESULT CSynth::Unload(HANDLE hDownload,
                       HRESULT ( CALLBACK *lpFreeMemory)(HANDLE,HANDLE),
                       HANDLE hUserData)
{
    return m_Instruments.Unload( hDownload, lpFreeMemory, hUserData);
}

HRESULT CSynth::Download(LPHANDLE phDownload, void * pdwData, LPBOOL bpFree)

{
    return m_Instruments.Download( phDownload, (DWORD *) pdwData,  bpFree);
}

HRESULT CSynth::PlayBuffer(IDirectMusicSynthSink *pSynthSink, REFERENCE_TIME rt, LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable)

{
    STIME stTime;

    ::EnterCriticalSection(&m_CriticalSection);

    if ( rt == 0 ) // Special case of time == 0.
    {
        stTime = m_stLastTime;
    }
    else
    {
        pSynthSink->RefTimeToSample(rt, &stTime);
    }

    PlayBuffer(stTime, rt, lpBuffer, cbBuffer, ulCable);

    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSynth::PlayBuffer(IDirectSoundSynthSink *pSynthSink, REFERENCE_TIME rt, LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable)

{
    STIME stTime;

    ::EnterCriticalSection(&m_CriticalSection);

    if ( rt == 0 ) // Special case of time == 0.
    {
        stTime = m_stLastTime;
    }
    else
    {
        pSynthSink->RefToSampleTime(rt, &stTime);
    }

    //Trace(0,"Reftime[%lx%08lx] LastTime[%lx%08lx] SampleTime[%lx%08lx]\n\r",(DWORD)(rt>>32),(DWORD)(rt&0x00000000ffffffff),(DWORD)(m_stLastTime>>32),(DWORD)(m_stLastTime&0x00000000ffffffff),(DWORD)(stTime>>32),(DWORD)(stTime&0x00000000ffffffff));

    PlayBuffer(stTime, rt, lpBuffer, cbBuffer, ulCable);

    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSynth::PlayBuffer(STIME stTime, REFERENCE_TIME rt, LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable)

{
    ::EnterCriticalSection(&m_CriticalSection);

    if (cbBuffer <= sizeof(DWORD))
    {
#ifdef DBG
        if (stTime < m_stLastTime)
        {
            static DWORD dwFailed = 0;
            if ((lpBuffer[0] & 0xF0) == MIDI_NOTEON)
            {
                if (!dwFailed)
                {
                    Trace(2,"Warning: Note On arrived too late to the synth, synth has mixed ahead by %ld samples. This could be caused by latency calculated too low.\n",
                         (long) (m_stLastTime - stTime));
                        dwFailed = 100;
                }
                dwFailed--;
            }
        }
        else if ((stTime - (10000 * 1000)) > m_stLastTime)
        {
            static DWORD dwFailed = 0;
            if ((lpBuffer[0] & 0xF0) == MIDI_NOTEON)
            {
                if (!dwFailed)
                {
                    Trace(2,"Warning: Note On at sample %ld, was stamped too late for synth, which is at mix time %ld, error is %ld samples\n",
                         (long) stTime, (long) m_stLastTime, (long) (m_stLastTime - stTime));
                        dwFailed = 100;
                }
                dwFailed--;
            }
        }
#endif
        if (ulCable <= m_dwControlCount)
        {
            if (ulCable == 0) // Play all groups if 0.
            {
                for (; ulCable < m_dwControlCount; ulCable++)
                {
                    m_ppControl[ulCable]->RecordMIDI(stTime,lpBuffer[0],
                        lpBuffer[1], lpBuffer[2]);
                }
            }
            else
            {
                m_ppControl[ulCable - 1]->RecordMIDI(stTime,lpBuffer[0],
                lpBuffer[1], lpBuffer[2]);

            }
        }
        else
        {
            Trace(1,"Error: MIDI event on channel group %ld is beyond range of %ld opened channel groups\n",
                ulCable, m_dwControlCount);
        }
    }
    else
    {
        if (ulCable <= m_dwControlCount)
        {
            if (ulCable == 0)
            {
                for (; ulCable < m_dwControlCount; ulCable++)
                {
                    m_ppControl[ulCable]->RecordSysEx(cbBuffer,
                        &lpBuffer[0], stTime);
                }
            }
            else
            {
                m_ppControl[ulCable-1]->RecordSysEx(cbBuffer,
                    &lpBuffer[0], stTime);
            }
        }
    }

    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

// Sets the stereo mode for the synth
// this value is currently only being used
// to deterim whether one can pan or not.
HRESULT CSynth::SetStereoMode(
    DWORD dwBufferFlags )
{
    HRESULT hr = S_OK;

    if (dwBufferFlags & BUFFERFLAG_INTERLEAVED )
    {
        m_dwStereo = TRUE;
    }
    else if (dwBufferFlags & BUFFERFLAG_MULTIBUFFER )
    {
        m_dwStereo = TRUE;
    }
    else
        m_dwStereo = FALSE;

    return hr;
}

void CSynth::ResetPerformanceStats()

{
    m_BuildStats.dwNotesLost = 0;
    m_BuildStats.dwTotalTime = 0;
    m_BuildStats.dwVoices = 0;
    m_BuildStats.dwTotalSamples = 0;
    m_BuildStats.dwCPU = 0;
    m_BuildStats.dwMaxAmplitude = 0;
    m_CopyStats = m_BuildStats;
}

HRESULT CSynth::AllNotesOff()

{
    CVoice *pVoice;
    ::EnterCriticalSection(&m_CriticalSection);
    while (pVoice = m_VoicesInUse.RemoveHead())
    {
        pVoice->ClearVoice();
        pVoice->m_fInUse = FALSE;
        m_VoicesFree.AddHead(pVoice);

        if (pVoice->m_stStartTime < m_stLastStats)
        {
            m_BuildStats.dwTotalSamples += (long) (pVoice->m_stStopTime - m_stLastStats);
        }
        else
        {
            m_BuildStats.dwTotalSamples += (long) (pVoice->m_stStopTime - pVoice->m_stStartTime);
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return (S_OK);
}

HRESULT CSynth::SetChannelPriority(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    DWORD dwPriority)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_CriticalSection);

    dwChannelGroup--;
    if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
    {
        Trace(1,"Error: Request to set channel priority on channel group %ld, channel %ld, is out of range.\n",
            dwChannelGroup,dwChannel);
        hr = E_INVALIDARG;
    }
    else
    {
        if (m_ppControl)
        {
            hr = m_ppControl[dwChannelGroup]->SetChannelPriority(dwChannel,dwPriority);
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CSynth::GetChannelPriority(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwPriority)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_CriticalSection);

    dwChannelGroup--;
    if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
    {
        Trace(1,"Error: Request to get channel priority on channel group %ld, channel %ld, is out of range.\n",
            dwChannelGroup,dwChannel);
        hr = E_INVALIDARG;
    }
    else
    {
        if (m_ppControl)
        {
            hr = m_ppControl[dwChannelGroup]->GetChannelPriority(dwChannel,pdwPriority);
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}


//////////////////////////////////////////////////////////
// Directx8 Methods

HRESULT CSynth::PlayVoice(
    IDirectSoundSynthSink *pSynthSink,
    REFERENCE_TIME rt,
    DWORD dwVoiceId,
    DWORD dwChannelGroup,
    DWORD dwChannel,
    DWORD dwDLId,
    VREL vrVolume,
    PREL prPitch,
    SAMPLE_TIME stVoiceStart,
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd
    )
{
    HRESULT hr = S_OK;
    STIME stTime;

    ::EnterCriticalSection(&m_CriticalSection);

    dwChannelGroup--;
    if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
    {
        Trace(1,"Error: Request to set play voice on channel group %ld, channel %ld, is out of range.\n",
            dwChannelGroup,dwChannel);
        hr = E_INVALIDARG;
    }

    if ( rt == 0 ) // Special case of time == 0.
    {
        stTime = m_stLastTime;
    }
    else
    {
        pSynthSink->RefToSampleTime(rt, &stTime);
    }

    CWaveArt *pWaveArt = m_Instruments.GetWaveArt(dwDLId);
    if ( pWaveArt )
        m_ppControl[dwChannelGroup]->RecordWaveEvent(
            stTime,
            (BYTE)(dwChannel & 0xF),
            dwVoiceId,
            vrVolume,
            prPitch,
            stVoiceStart,
            stLoopStart,
            stLoopEnd,
            pWaveArt);

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CSynth::StopVoice(
    IDirectSoundSynthSink *pSynthSink,
    REFERENCE_TIME rt,
    DWORD dwVoiceId )
{
    HRESULT hr = S_OK;
    STIME stTime;

    ::EnterCriticalSection(&m_CriticalSection);

    if ( rt == 0 )  // Special case of time == 0.
    {
        stTime = m_stLastTime;
    }
    else
    {
        pSynthSink->RefToSampleTime(rt, &stTime);
    }

    CVoice * pVoice = m_VoicesInUse.GetHead();
    bool fFoundVoice = false;
    for (;pVoice != NULL;pVoice = pVoice->GetNext())
    {
        if ( pVoice->m_dwVoiceId == dwVoiceId )
        {
            pVoice->m_stWaveStopTime = stTime;
            fFoundVoice = true;
        }
    }
    if (!fFoundVoice)
    {
        TraceI(2, "Warning: Synth couldn't find voice %d to stop.\n", dwVoiceId);
        for (DWORD dwX = 0; dwX < m_dwControlCount; dwX++)
        {
            m_ppControl[dwX]->FlushWaveByStopTime(dwVoiceId, stTime);
        }
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CSynth::GetVoiceState(
    DWORD dwVoice[],
    DWORD cbVoice,
    DMUS_VOICE_STATE VoiceState[] )
{
    HRESULT hr = E_FAIL;

    ::EnterCriticalSection(&m_CriticalSection);

    for ( DWORD i = 0; i < cbVoice; i++ )
    {
        VoiceState[i].bExists = FALSE;
        VoiceState[i].spPosition = 0;

        CVoice * pVoice = m_VoicesInUse.GetHead();
        for (;pVoice != NULL;pVoice = pVoice->GetNext())
        {
            if ( pVoice->m_dwVoiceId == dwVoice[i] )
            {
                VoiceState[i].bExists = TRUE;
                VoiceState[i].spPosition = pVoice->GetCurrentPos();
                break;
            }
        }
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}

HRESULT CSynth::Refresh(
    DWORD dwDownloadID,
    DWORD dwFlags)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_CriticalSection);

    CWave *pWave = m_Instruments.GetWave(dwDownloadID);
    if ( pWave )
    {
        if ( pWave->m_bValid )
        {
            Trace(1,"Error: Attempting to validate already validated streaming buffer\n\r");
            hr = E_FAIL;
        }

        if ( pWave->m_bActive )
        {
            Trace(1,"Error: Attempting to validate active playing streaming buffer\n\r");
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            pWave->m_bValid = TRUE;

            if (pWave->m_bSampleType == SFORMAT_8)
            {
                DWORD dwX;
                char *pData = (char *) pWave->m_pnWave;
                for (dwX = 0; dwX < pWave->m_dwSampleLength; dwX++)
                {
                    pData[dwX] -= (char) 128;
                }
            }

            // Indicate that we did find a vaild download id
            hr = S_OK;
        }
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CSynth::AssignChannelToBuses(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwBuses,
    DWORD cBuses)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_CriticalSection);

//>>>>>>> Probably need a better check here since panning is only valid for left and right?

    dwChannelGroup--;
    if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        hr = m_ppControl[dwChannelGroup]->AssignChannelToBuses(dwChannel, pdwBuses, cBuses);
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG
#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\debug.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//
// Debug.CPP
//
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
#define MODULE "DMSYNTH"
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
#define MODULE "DDKSYNTH"
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT

// Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// The current debug level. 
static int giDebugLevel;

// Do asserts break?
static BOOL gfAssertBreak;

// Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// Send a debug trace out.
//
// Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // The debug level of this message
    LPSTR pstrFormat,       // A printf style format string
    ...)                    // | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }

    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\error.h ===
// Copyright (c) 1998 Microsoft Corporation
//      Error.h

#define RA_E_FIRST				(OLE_E_FIRST + 5000)

#define E_BADWAVE		        (RA_E_FIRST + 1)    // Bad wave chunk
#define E_NOTPCM		        (RA_E_FIRST + 2)    // Not PCM data in wave
#define E_NOTMONO		        (RA_E_FIRST + 3)    // Wave not MONO
#define E_BADARTICULATION       (RA_E_FIRST + 4)    // Bad articulation chunk
#define E_BADREGION		        (RA_E_FIRST + 5)    // Bad region chunk
#define E_BADWAVELINK	        (RA_E_FIRST + 6)    // Bad link from region to wave
#define E_BADINSTRUMENT	        (RA_E_FIRST + 7)    // Bad instrument chunk
#define E_NOARTICULATION        (RA_E_FIRST + 8)    // No articulation found in region
#define E_NOWAVE		        (RA_E_FIRST + 9)    // No wave found for region.
#define E_BADCOLLECTION	        (RA_E_FIRST + 10)   // Bad collection chunk.
#define E_NOLOADER   	        (RA_E_FIRST + 11)   // No IRALoader interface 
#define E_NOLOCK		        (RA_E_FIRST + 12)   // Unable to lock a region.
#define E_TOOBUSY		        (RA_E_FIRST + 13)   // RActive to busy to fully follow command.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\dslink.cpp ===
//
// Copyright (c) 1996-2001 Microsoft Corporation
// DSLink.cpp
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <objbase.h>
#include <ks.h>
#include <ksproxy.h>

#include "debug.h"
#include "dmusicc.h"
#include "dmusics.h"
#include "..\shared\validate.h"
#include "synth.h"
#include "DSLink.h"
#include "float.h"
#include "misc.h"
#include "dmksctrl.h"

#define DSBUFFER_LENGTH_SEC 2

extern long g_cComponent;
CDSLinkList g_DSLinkList;       // Master list of DSLinks.


void CDSLink::SynthProc()
{
    HRESULT hr;
    DWORD dwPlayCursor;         // current play head (driven by streaming wave crystal)
    DWORD dwWriteFromCursor;    // current write head

    ::EnterCriticalSection(&m_CriticalSection);

    if (!m_fActive || !m_pBuffer || !m_pIMasterClock)
    {
        Trace(2, "Warning: SynthSink - Thread in invalid state\n");
        ::LeaveCriticalSection(&m_CriticalSection);
        return;
    }

    hr = m_pBuffer->GetCurrentPosition(&dwPlayCursor, &dwWriteFromCursor);
    if (hr == DS_OK)
    {
        DWORD dwDeltaFilter = m_dwBufferSize >> 1;
        DWORD dwCursorDelta;

        if (dwWriteFromCursor >= dwPlayCursor)
            dwCursorDelta = dwWriteFromCursor - dwPlayCursor;
        else
            dwCursorDelta = (dwWriteFromCursor + m_dwBufferSize) - dwPlayCursor;

        if (dwCursorDelta > m_dwWriteFromMax)
        {
            if (dwCursorDelta < dwDeltaFilter)
            {
                TraceI(2, "Warning: SynthSink - Play to Write cursor distance increased from %lu to %lu\n", m_dwWriteFromMax, dwCursorDelta);
                m_dwWriteFromMax = dwCursorDelta;
            }
            else
            {
                TraceI(2, "Warning: SynthSink - Play to Write cursor delta value rejected:%lu\n", dwCursorDelta);
                SetEvent(g_DSLinkList.m_hEvent);
                ::LeaveCriticalSection(&m_CriticalSection);
                return;
            }
        }
        else
        {
            m_dwWriteFromMax -= ((m_dwWriteFromMax - dwCursorDelta) / 100);
            m_dwWriteFromMax = SampleAlign(m_dwWriteFromMax);
            dwCursorDelta = m_dwWriteFromMax;
        }

        dwWriteFromCursor = (dwPlayCursor + dwCursorDelta) % m_dwBufferSize;

        if (m_llAbsWrite == 0)
        {
            // we just started
            m_dwLastPlay = dwPlayCursor;
            m_dwLastWrite = dwWriteFromCursor;
            m_llAbsWrite = dwCursorDelta;
            m_SampleClock.Start(m_pIMasterClock, m_wfSynth.nSamplesPerSec, 0);
            m_Clock.Start(); // don't want anybody getting latency time until this thread is running
        }

        // check for overrun with master clock
        REFERENCE_TIME rtMaster;
        LONGLONG llMasterSampleTime;
        LONGLONG llMasterBytes;
        LONGLONG llMasterAhead;    // how far master clock is ahead of last known play time
        LONGLONG llAbsWriteFrom;

        m_pIMasterClock->GetTime(&rtMaster);
        RefTimeToSample(rtMaster, &llMasterSampleTime);
        llMasterBytes = SampleToByte(llMasterSampleTime);
        llMasterAhead = (llMasterBytes > m_llAbsPlay) ? llMasterBytes - m_llAbsPlay : 0;

        // check for half-buffer underruns, so backward-moving play cursors can be detected
        if (llMasterAhead > dwDeltaFilter)
        {
            Trace(2, "Warning: SynthSink - Buffer underrun by %lu\n", (long) llMasterAhead - dwDeltaFilter);

            m_llAbsPlay = llMasterBytes;
            m_dwLastWrite = dwWriteFromCursor;
            m_llAbsWrite = llAbsWriteFrom = m_llAbsPlay + dwCursorDelta;
        }
        else
        {
            DWORD dwPlayed;

            if (dwPlayCursor >= m_dwLastPlay)
                dwPlayed = dwPlayCursor - m_dwLastPlay;
            else
                dwPlayed = (dwPlayCursor + m_dwBufferSize) - m_dwLastPlay;

            if (dwPlayed > dwDeltaFilter)
            {
                Trace(2, "Warning: SynthSink - Play Cursor %lu looks invalid, rejecting it.\n", dwPlayed);
                SetEvent(g_DSLinkList.m_hEvent);
                ::LeaveCriticalSection(&m_CriticalSection);
                return;
            }

            m_llAbsPlay += dwPlayed;
            llAbsWriteFrom = m_llAbsPlay + dwCursorDelta;

            // how far ahead of the write head are we?
            if (llAbsWriteFrom > m_llAbsWrite)
            {
                DWORD dwWriteMissed;

                // we are behind-- let's catch up
                dwWriteMissed = DWORD(llAbsWriteFrom - m_llAbsWrite);

                Trace(2, "Warning: SynthSink - Write underrun, missed %lu bytes\n", dwWriteMissed);

                m_dwLastWrite = dwWriteFromCursor;
                m_llAbsWrite += dwWriteMissed;
            }
        }

        m_dwLastPlay = dwPlayCursor;
        m_SampleClock.SyncToMaster(ByteToSample(m_llAbsPlay), m_pIMasterClock);

        // how much to write?
        LONGLONG llAbsWriteTo;
        DWORD dwBytesToFill;

        llAbsWriteTo = llAbsWriteFrom + m_dwWriteTo;

        if (llAbsWriteTo > m_llAbsWrite)
        {
            dwBytesToFill = DWORD(llAbsWriteTo - m_llAbsWrite);
        }
        else
        {
            dwBytesToFill = 0;
        }

        if (dwBytesToFill)
        {
            LPVOID lpStart, lpEnd;      // Buffer pointers, filled by Lock command.
            DWORD dwStart, dwEnd;       // For Lock.

            hr = m_pBuffer->Lock(m_dwLastWrite, dwBytesToFill, &lpStart, &dwStart, &lpEnd, &dwEnd, 0);
            if (hr == DSERR_BUFFERLOST)
            {
                Trace(2, "Warning: SynthSink - Buffer lost\n");
                hr = m_pBuffer->Restore();
                if (hr == DS_OK)
                {
                    Trace(2, "Warning: SynthSink - Buffer restored\n");
                    hr = m_pBuffer->Play(0, 0, DSBPLAY_LOOPING);
                    if (hr == DS_OK)
                    {
                        Trace(2, "Warning: SynthSink - Play restarted\n");
                        hr = m_pBuffer->Lock(m_dwLastWrite, dwBytesToFill, &lpStart, &dwStart, &lpEnd, &dwEnd, 0);
                    }
                }
            }
            if (hr == DS_OK)
            {
                if (dwStart)
                {
                    memset(lpStart, 0, dwStart);
                    if (m_pSynth)
                    {
                        m_pSynth->Render((short*)lpStart, ByteToSample(dwStart), ByteToSample(m_llAbsWrite));
                    }

                    m_dwLastWrite += dwStart;
                    m_llAbsWrite += dwStart;

                    if (m_dwLastWrite == m_dwBufferSize)
                    {
                        m_dwLastWrite = 0;
                    }
                }
                if (dwEnd)
                {
                    memset(lpEnd, 0, dwEnd);
                    if (m_pSynth)
                    {
                        m_pSynth->Render((short*)lpEnd, ByteToSample(dwEnd), ByteToSample(m_llAbsWrite));
                    }
                    m_dwLastWrite = dwEnd;
                    m_llAbsWrite += dwEnd;
                }
                m_pBuffer->Unlock(lpStart, dwStart, lpEnd, dwEnd);

                // write silence into unplayed buffer
                if (m_dwLastWrite >= dwPlayCursor)
                    dwBytesToFill = m_dwBufferSize - m_dwLastWrite + dwPlayCursor;
                else
                    dwBytesToFill = dwPlayCursor - m_dwLastWrite;

                hr = m_pBuffer->Lock(m_dwLastWrite, dwBytesToFill, &lpStart, &dwStart, &lpEnd, &dwEnd, 0);
                if (hr == DSERR_BUFFERLOST)
                {
                    Trace(2, "Warning: SynthSink - Buffer lost\n");
                    hr = m_pBuffer->Restore();
                    if (hr == DS_OK)
                    {
                        Trace(2, "Warning: SynthSink - Buffer restored\n");
                        hr = m_pBuffer->Play(0, 0, DSBPLAY_LOOPING);
                        if (hr == DS_OK)
                        {
                            Trace(2, "Warning: SynthSink - Play restarted\n");
                            hr = m_pBuffer->Lock(m_dwLastWrite, dwBytesToFill, &lpStart, &dwStart, &lpEnd, &dwEnd, 0);
                        }
                    }
                }
                if (hr == DS_OK)
                {
                    if (dwStart)
                    {
                        memset(lpStart, 0, dwStart);
                    }
                    if (dwEnd)
                    {
                        memset(lpEnd, 0, dwEnd);
                    }
                    m_pBuffer->Unlock(lpStart, dwStart, lpEnd, dwEnd);
                }
                else
                {
                    Trace(2, "Warning: SynthSink - Failed to lock DS buffer: %x\n", hr);
                }
            }
            else
            {
                Trace(2, "Warning: SynthSink - Failed to lock DS buffer: %x\n", hr);
            }
        }
    }
    else
    {
        if (hr == DSERR_BUFFERLOST)
        {
            Trace(2, "Warning: SynthSink - Buffer lost on GetCurrentPosition\n");
            hr = m_pBuffer->Restore();
            if (hr == DS_OK)
            {
                Trace(2, "Warning: SynthSink - Buffer restored\n");
                hr = m_pBuffer->Play(0, 0, DSBPLAY_LOOPING);
                if (hr == DS_OK)
                {
                    Trace(2, "Warning: SynthSink - Play restarted\n");
                }
            }
        }
        else
        {
            Trace(0, "Error: SynthSink - Failed to get DS buffer position, error code: %lx\n", hr);
        }
    }

    ::LeaveCriticalSection(&m_CriticalSection);
}


void CDSLinkList::SynthProc()
{
    for (;;)
    {
        if (m_fPleaseDie)
        {
            m_fPleaseDie = FALSE;
            break;
        }

        for (DWORD dwX = 0; dwX < m_dwCount; dwX++)
        {
            ::EnterCriticalSection(&m_CriticalSection);
            CDSLink *pLink = GetItem(dwX);
            ::LeaveCriticalSection(&m_CriticalSection);
            if (pLink)
            {
                if (pLink->m_fActive)
                {
                    pLink->SynthProc();
                }
            }
        }
        if (m_dwResolution < 2) m_dwResolution = 2;
        if (m_dwResolution > 100) m_dwResolution = 100;
        WaitForSingleObject(m_hEvent, m_dwResolution);
    }
}


static DWORD WINAPI SynthThread (LPVOID lpThreadParameter)
{
    CDSLinkList *pLinkList = (CDSLinkList *) lpThreadParameter;
    pLinkList->SynthProc();
    return 0;
}

HRESULT CDSLink::Connect()
{
    if (!m_pSynth)
    {
        Trace(0, "Error: SynthSink - Activation failed, SynthSink not initialized\n");
        return DMUS_E_SYNTHNOTCONFIGURED;
    }

    if (!m_pDSound)
    {
        Trace(0, "Error: SynthSink - Activation failed, IDirectSound not set\n");
        return DMUS_E_DSOUND_NOT_SET;
    }

    if (!IsValidFormat(&m_wfSynth))
    {
        Trace(0, "Error: SynthSink - Activation failed, format not initialized/valid\n");
        return DMUS_E_SYNTHNOTCONFIGURED;
    }

    if (!m_pIMasterClock)
    {
        Trace(0, "Error: SynthSink - Activation failed, master clock not set\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }

    if (m_fActive)
    {
        Trace(0, "Error: SynthSink - Activation failed, already active\n");
        return DMUS_E_SYNTHACTIVE;
    }

    assert(!m_pBuffer);

    HRESULT hr = E_FAIL;

    ::EnterCriticalSection(&m_CriticalSection);
    if (!m_pExtBuffer)
    {
        DSBUFFERDESC dsbdesc;
        memset(&dsbdesc, 0, sizeof(dsbdesc));
        dsbdesc.dwSize = sizeof(dsbdesc);
        dsbdesc.dwFlags = DSBCAPS_PRIMARYBUFFER;

        // create primary buffer
        if (SUCCEEDED(m_pDSound->CreateSoundBuffer(&dsbdesc, &m_pPrimary, NULL)))
        {
            WAVEFORMATEX wfPrimary;
            memset(&wfPrimary, 0, sizeof(wfPrimary));

            if (SUCCEEDED(m_pPrimary->GetFormat(&wfPrimary, sizeof(wfPrimary), NULL)))
            {
                assert(wfPrimary.wFormatTag == WAVE_FORMAT_PCM);

                BOOL fUpgrade = FALSE;
                if (wfPrimary.nChannels < m_wfSynth.nChannels)
                {
                    wfPrimary.nChannels = m_wfSynth.nChannels;
                    fUpgrade = TRUE;
                }
                if (wfPrimary.nSamplesPerSec < m_wfSynth.nSamplesPerSec)
                {
                    wfPrimary.nSamplesPerSec = m_wfSynth.nSamplesPerSec;
                    fUpgrade = TRUE;
                }
                if (wfPrimary.wBitsPerSample < m_wfSynth.wBitsPerSample)
                {
                    wfPrimary.wBitsPerSample = m_wfSynth.wBitsPerSample;
                    fUpgrade = TRUE;
                }

                if (fUpgrade)
                {
                    wfPrimary.nBlockAlign = wfPrimary.nChannels * (wfPrimary.wBitsPerSample / 8);
                    wfPrimary.nAvgBytesPerSec = wfPrimary.nSamplesPerSec * wfPrimary.nBlockAlign;

                    // the existing format is of lesser quality than we desire, so let's upgrade it
                    if (FAILED(hr = m_pPrimary->SetFormat( &wfPrimary )))
                    {
                        if (hr == DSERR_PRIOLEVELNEEDED)
                        {
                            // okay, so maybe the app doen't want us changing primary buffer
                            Trace(2, "Error: SynthSink - SetFormat on primary buffer failed, lacking priority\n");
                            hr = S_OK;
                        }
                        else
                        {
                            Trace(0, "Error: SynthSink - Activation failed, couldn't set primary buffer format\n");

                            m_pPrimary->Release();
                            m_pPrimary = NULL;
                            m_pBuffer = NULL;

                            hr = E_UNEXPECTED;
                        }
                    }
                }
                else
                {
                    hr = S_OK;
                }

                if (SUCCEEDED(hr))
                {
                    hr = E_FAIL;

                    memset(&dsbdesc, 0, sizeof(dsbdesc));
                    dsbdesc.dwSize = sizeof(dsbdesc);
                    // need default controls (pan, volume, frequency).
                    dsbdesc.dwFlags = DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_GLOBALFOCUS;
                    // N-second buffer.
                    dsbdesc.dwBufferBytes = DSBUFFER_LENGTH_SEC * m_wfSynth.nAvgBytesPerSec;
                    dsbdesc.lpwfxFormat = (LPWAVEFORMATEX)&m_wfSynth;

                    if (SUCCEEDED(m_pDSound->CreateSoundBuffer(&dsbdesc, &m_pBuffer, NULL)))
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        m_pBuffer = NULL;

                        if (m_pPrimary)
                        {
                            m_pPrimary->Release(); m_pPrimary = NULL;
                        }

                        Trace(0, "Error: SynthSink - Activation failed, couldn't create secondary buffer\n");
                        hr = E_UNEXPECTED;
                    }
                }
            }
            else
            {
                Trace(0, "Error: SynthSink - Activation failed, couldn't get primary buffer format\n");
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            Trace(0, "Error: SynthSink - Activation failed, couldn't create primary buffer\n");
            hr = E_UNEXPECTED;
        }
    }
    else
    {
        m_pBuffer = m_pExtBuffer;
        m_pBuffer->AddRef();
    }

    if (m_pBuffer)
    {
        DSBCAPS dsbcaps;
        memset(&dsbcaps, 0, sizeof(dsbcaps));
        dsbcaps.dwSize = sizeof(dsbcaps);
        if (SUCCEEDED(m_pBuffer->GetCaps(&dsbcaps)))
        {
            DSCAPS  dsCaps ;
            memset( &dsCaps, 0, sizeof(DSCAPS) );
            dsCaps.dwSize = sizeof(DSCAPS);

            if (SUCCEEDED(m_pDSound->GetCaps(&dsCaps)))
            {
                DWORD dwMinLatency; // ms

                // Check for Dsound on top of Wave...
                if (dsCaps.dwFlags & DSCAPS_EMULDRIVER)
                {
                    dwMinLatency = 240;
                }
                else
                {
                    dwMinLatency = 80;
                }
                DWORD dwGetLatency = dwMinLatency;
                if (GetRegValueDword(TEXT("Software\\Microsoft\\DirectMusic"),
                                           TEXT("DSLMinLatency"),
                                           &dwGetLatency))
                {
                    Trace(4, "SynthSink: Registry set to change latency to %ld\n", dwGetLatency);
                    dwMinLatency = dwGetLatency;
                }
                m_dwWriteTo = SampleAlign((500 + (m_wfSynth.nAvgBytesPerSec * dwMinLatency)) / 1000);
                Trace(4, "SynthSink: Set Latency to %lu\n", dwMinLatency);

                m_dwBufferSize = dsbcaps.dwBufferBytes;

                m_dwLastWrite = 0;
                m_dwLastPlay = 0;
                m_llAbsPlay = 0;

                // fill initial buffer with silence
                LPVOID lpStart, lpEnd;
                DWORD dwStart, dwEnd;
                if (SUCCEEDED(m_pBuffer->Lock(0, m_dwBufferSize, &lpStart, &dwStart, &lpEnd, &dwEnd, 0)))
                {
                    if (dwStart)
                    {
                        memset(lpStart, 0, dwStart);
                    }
                    if (dwEnd)
                    {
                        memset(lpEnd, 0, dwEnd);
                    }
                    m_pBuffer->Unlock(lpStart, dwStart, lpEnd, dwEnd);

                    if (SUCCEEDED(m_pBuffer->Play(0, 0, DSBPLAY_LOOPING)))
                    {
                        g_DSLinkList.ActivateLink(this);
                        hr = S_OK;
                    }
                    else
                    {
                        Trace(0, "Error: SynthSink - Activation failed, couldn't start buffer\n");
                        hr = E_UNEXPECTED;
                    }
                }
                else
                {
                    Trace(0, "Error: SynthSink - Activation failed, couldn't lock buffer\n");
                    hr = E_UNEXPECTED;
                }
            }
            else
            {
                Trace(0, "Error: SynthSink - Activation failed, couldn't get DS caps\n");
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            Trace(0, "Error: SynthSink - Activation failed, couldn't get buffer caps\n");
            hr = E_UNEXPECTED;
        }
    }

    if (FAILED(hr))
    {
        // Clean up
        //

        if (m_pBuffer)
        {
            m_pBuffer->Stop();
            m_pBuffer->Release();
            m_pBuffer = NULL;
        }

        if (m_pPrimary)
        {
            m_pPrimary->Release();
            m_pPrimary = NULL;
        }

        m_Clock.Stop();

        Clear();
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    if (SUCCEEDED(hr))
    {
        // wait until the pump is primed
        for (WORD wRetry = 0; wRetry < 10 && !m_llAbsWrite; wRetry++)
        {
            Sleep(10);
        }

        if (m_llAbsWrite)
        {
            Trace(3, "Warning: SynthSink - Pump is primed\n");
        }
        else
        {
            Trace(0, "Error: SynthSink - Pump is NOT primed\n");
        }
    }

    return hr;
}

HRESULT CDSLink::Disconnect()
{
    // stop the buffer right away!
    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pBuffer)
    {
        // write silence to prevent DSound blip bug if reactivated
        LPVOID lpStart, lpEnd;
        DWORD dwStart, dwEnd;
        if (SUCCEEDED(m_pBuffer->Lock(0, m_dwBufferSize, &lpStart, &dwStart, &lpEnd, &dwEnd, 0))) // REVIEW: don't need full buffer size
        {
            if (dwStart)
            {
                memset(lpStart, 0, dwStart);
            }
            if (dwEnd)
            {
                memset(lpEnd, 0, dwEnd);
            }
            m_pBuffer->Unlock(lpStart, dwStart, lpEnd, dwEnd);
            Sleep(50); // found experimentally
        }

        m_pBuffer->Stop();
    }
    m_Clock.Stop();
    ::LeaveCriticalSection(&m_CriticalSection);

    g_DSLinkList.DeactivateLink(this);

    ::EnterCriticalSection(&m_CriticalSection);

    if (m_pBuffer)
    {
        m_pBuffer->Release(); m_pBuffer = NULL;
    }

    if (m_pPrimary)
    {
        m_pPrimary->Release(); m_pPrimary = NULL;
    }

    Clear();

    ::LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}

void CDSLink::Clear()
{
    m_llAbsPlay = 0;        // Absolute point where play head is.
    m_dwLastPlay = 0;       // Last point where play head was.
    m_llAbsWrite = 0;    // Absolute point we've written up to.
    m_dwBufferSize = 0;     // Size of buffer.
    m_dwLastWrite = 0;   // Last position we wrote to in buffer.
    m_dwWriteTo = 1000;     // Distance between write head and where we are writing.
}

CDSLink::CDSLink()
{
    InterlockedIncrement(&g_cComponent);

    m_fCSInitialized = FALSE;
    ::InitializeCriticalSection(&m_CriticalSection);
    m_fCSInitialized = TRUE;

    memset(&m_wfSynth, 0, sizeof(m_wfSynth));
    m_pIMasterClock = NULL;
    m_cRef = 0;
    m_pSynth = NULL;      // Reference back to parent Synth.
    m_pDSound = NULL;
    m_pPrimary = NULL;
    m_pBuffer = NULL;
    m_pExtBuffer = NULL;
    m_dwWriteFromMax = 0;
    Clear();
    m_Clock.Stop();
    m_fActive = FALSE;
}

CDSLink::~CDSLink()
{
    if (m_fCSInitialized)
    {
        ::EnterCriticalSection(&m_CriticalSection);
        if (m_pIMasterClock)
        {
            m_pIMasterClock->Release(); m_pIMasterClock = NULL;
        }
        ::LeaveCriticalSection(&m_CriticalSection);

        Disconnect();

        if (m_pExtBuffer)
        {
            m_pExtBuffer->Release(); m_pExtBuffer = NULL;
        }

        if (m_pDSound)
        {
            m_pDSound->Release(); m_pDSound = NULL;
        }

        ::DeleteCriticalSection(&m_CriticalSection);
    }

    InterlockedDecrement(&g_cComponent);
}

CDSLinkList::CDSLinkList()
{
    m_fOpened = FALSE;
    m_fPleaseDie = FALSE;
    m_hThread = NULL;           // Handle for synth thread.
    m_dwThread = 0;             // ID for thread.
    m_hEvent = NULL;            // Used to signal thread.
    m_dwCount = 0;
    m_dwResolution = 20;
}

BOOL CDSLinkList::OpenUp()
{
    if (m_fOpened)
    {
        Trace(1, "Warning: SynthSink - Already opened\n");
        return TRUE;
    }

    m_fOpened = TRUE;

    if (!GetRegValueDword(TEXT("Software\\Microsoft\\DirectMusic"),
                          TEXT("DSLResolution"),
                          &m_dwResolution))
    {
        m_dwResolution = 20;
    }

    try
    {
        ::InitializeCriticalSection(&m_CriticalSection);
    }
    catch( ... )
    {
        m_fOpened = FALSE;
        return FALSE;
    }

    return TRUE;
}

void CDSLinkList::CloseDown()
{
    if (m_dwCount)
    {
        CDSLink *pLink;
        if (pLink = GetHead())
        {
            Trace(0, "Error: SynthSink - Process Detach with port still active. May crash on exit.\n");
        }
    }

    if (!m_fOpened)
    {
        Trace(2, "Warning: SynthSink - Process Detach, ports all deactivated\n");
    }
    else
    {
        m_fOpened = FALSE;
        ::DeleteCriticalSection(&m_CriticalSection);
    }
}

void CDSLinkList::ActivateLink(CDSLink *pLink)
{
    ::EnterCriticalSection(&m_CriticalSection);

    if (!pLink->m_fActive)
    {
        if (m_dwCount == 0)
        {
            m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            m_hThread = CreateThread(NULL, 0, SynthThread, this, 0, &m_dwThread);

            if (m_hThread)
            {
                if (!SetThreadPriority(m_hThread, THREAD_PRIORITY_TIME_CRITICAL))
                {
                    Trace(0, "Error: SynthSink - Activate couldn't set thread priority\n");
                }
            }
            else
            {
                Trace(0, "Error: SynthSink - Activate couldn't create thread\n");
            }
        }

        if (!IsMember(pLink))
        {
            m_dwCount++;
            AddTail(pLink);
        }

        pLink->m_fActive = TRUE;
    }

    ::LeaveCriticalSection(&m_CriticalSection);
}

void CDSLinkList::DeactivateLink(CDSLink *pLink)
{
    ::EnterCriticalSection(&m_CriticalSection);

    if (pLink->m_fActive)
    {
        if (m_dwCount)
        {
            Remove(pLink);
            m_dwCount--;
        }

        pLink->m_fActive = FALSE;

        if (m_dwCount == 0)
        {
            if (m_hThread && m_hEvent)
            {
                m_fPleaseDie = TRUE;
                SetEvent(m_hEvent);
                if (WaitForSingleObject(m_hThread, 10000) == WAIT_TIMEOUT)
                {
                    Trace(0, "Error: SynthSink - Deactivate, thread did not exit\n");
                }
            }
            if (m_hEvent)
            {
                CloseHandle(m_hEvent);
                m_hEvent = NULL;
            }
            if(m_hThread)
            {
                CloseHandle(m_hThread);
                m_hThread = NULL;
            }
        }
    }

    ::LeaveCriticalSection(&m_CriticalSection);
}

CDSLink * CDSLink::GetNext()
{
    return (CDSLink *) CListItem::GetNext();
}

void CDSLinkList::AddTail(CDSLink *pNode)
{
    CList::AddTail((CListItem *) pNode);
}

void CDSLinkList::Remove(CDSLink *pNode)
{
    CList::Remove((CListItem *) pNode);
}

CDSLink * CDSLinkList::GetHead()
{
    return (CDSLink *)CList::GetHead();
}

CDSLink * CDSLinkList::RemoveHead()
{
    return (CDSLink *)CList::RemoveHead();
}

CDSLink * CDSLinkList::GetItem(LONG index)
{
    return (CDSLink *)CList::GetItem(index);
}

STDMETHODIMP CDSLink::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicSynthSink::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


    if (iid == IID_IUnknown || iid == IID_IDirectMusicSynthSink) {
        *ppv = static_cast<IDirectMusicSynthSink*>(this);
    }
    else if (iid == IID_IKsControl)
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDSLink::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CDSLink::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }
    return m_cRef;
}

STDMETHODIMP CDSLink::Init(
    IDirectMusicSynth *pSynth) // <i IDirectMusicSynth> to connect to.
{
    m_pSynth = pSynth;
    m_Clock.Init(this);
    return S_OK;
}

STDMETHODIMP CDSLink::SetMasterClock(
    IReferenceClock *pClock)    // Master clock to synchronize to.

{
    V_INAME(IDirectMusicSynthSink::SetMasterClock);
    V_INTERFACE(pClock);

    if (m_pIMasterClock)
    {
        m_pIMasterClock->Release(); m_pIMasterClock = NULL;
    }
    m_pIMasterClock = pClock;
    if (pClock)
    {
        pClock->AddRef();
    }
    return S_OK;
}

STDMETHODIMP CDSLink::GetLatencyClock(
    IReferenceClock **ppClock) // Returned <i IReferenceClock> interface for latency clock.

{
    V_INAME(IDirectMusicSynthSink::GetLatencyClock);
    V_PTR_WRITE(ppClock, IReferenceClock *);
    return m_Clock.QueryInterface(IID_IReferenceClock, (void **)ppClock);
}

STDMETHODIMP CDSLink::Activate(
    BOOL fEnable)   // Whether to activate or deactivate audio.

{
    if (fEnable)
    {
        return Connect();
    }
    return Disconnect();
}

STDMETHODIMP CDSLink::SampleToRefTime(
    LONGLONG llSampleTime,         // Incoming time, in sample position.
    REFERENCE_TIME *prfTime)    // Outgoing time, in REFERENCE_TIME units, relative to master clock.

{
    V_INAME(IDirectMusicSynthSink::SampleToRefTime);
    V_PTR_WRITE(prfTime, REFERENCE_TIME);
    m_SampleClock.SampleToRefTime(llSampleTime, prfTime);
    return S_OK;
}

STDMETHODIMP CDSLink::RefTimeToSample(
    REFERENCE_TIME rfTime,  // Incoming time, in REFERENCE_TIME units.
    LONGLONG *pllSampleTime)   // Outgoing equivalent sample position.

{
    V_INAME(IDirectMusicSynthSink::RefTimeToSample);
    V_PTR_WRITE(pllSampleTime, LONGLONG);
    *pllSampleTime = m_SampleClock.RefTimeToSample(rfTime);
    return S_OK;
}

STDMETHODIMP CDSLink::SetDirectSound(
    LPDIRECTSOUND pDirectSound,             // IDirectSound instance (required).
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer) // DirectSound buffer to render to (optional).
{
    V_INAME(IDirectMusicSynthSink::SetDirectSound);
    V_INTERFACE_OPT(pDirectSound);
    V_INTERFACE_OPT(pDirectSoundBuffer);

    if (m_fActive)
    {
        Trace(0, "Error: SynthSink - SetDirectSound failed, can't call while sink is active\n");
        return DMUS_E_SYNTHACTIVE;
    }

    HRESULT hr = E_FAIL;

    ::EnterCriticalSection(&m_CriticalSection);

    if (m_pExtBuffer)
    {
        m_pExtBuffer->Release(); m_pExtBuffer = NULL;
    }

    if (m_pDSound)
    {
        m_pDSound->Release();
    }

    m_pDSound = pDirectSound;

    if (m_pDSound)
    {
        m_pDSound->AddRef();

        if (m_pSynth)
        {
            DWORD dwWaveFormatExSize = sizeof(m_wfSynth);

            if (SUCCEEDED(m_pSynth->GetFormat(&m_wfSynth, &dwWaveFormatExSize))) // update current synth format
            {
                if (IsValidFormat(&m_wfSynth))
                {
                    m_pExtBuffer = pDirectSoundBuffer;

                    if (m_pExtBuffer)
                    {
                        m_pExtBuffer->AddRef();

                        // check format
                        WAVEFORMATEX wfExt;
                        memset(&wfExt, 0, sizeof(wfExt));

                        if (SUCCEEDED(m_pExtBuffer->GetFormat(&wfExt, sizeof(wfExt), NULL)))
                        {
                            // must exactly match synth format
                            if (wfExt.wFormatTag == m_wfSynth.wFormatTag &&
                                wfExt.nChannels == m_wfSynth.nChannels &&
                                wfExt.nSamplesPerSec == m_wfSynth.nSamplesPerSec &&
                                wfExt.nBlockAlign == m_wfSynth.nBlockAlign &&
                                wfExt.nAvgBytesPerSec == m_wfSynth.nAvgBytesPerSec &&
                                wfExt.wBitsPerSample == m_wfSynth.wBitsPerSample)
                            {
                                DSBCAPS dsbcaps;
                                dsbcaps.dwSize = sizeof(dsbcaps);

                                if (SUCCEEDED(m_pExtBuffer->GetCaps(&dsbcaps)))
                                {
                                    // check for invalid flags
                                    if (dsbcaps.dwFlags & (DSBCAPS_PRIMARYBUFFER | DSBCAPS_STATIC))
                                    {
                                        Trace(0, "Error: SynthSink - SetDirectSound failed, buffer not secondary streaming\n");
                                        hr = DMUS_E_INVALIDBUFFER;
                                    }
                                    // is buffer too small?
                                    else if (dsbcaps.dwBufferBytes < m_wfSynth.nAvgBytesPerSec)
                                    {
                                        Trace(0, "Error: SynthSink - SetDirectSound failed, buffer too small\n");
                                        hr = DMUS_E_INSUFFICIENTBUFFER;
                                    }
                                    else
                                    {
                                        hr = S_OK;
                                    }
                                }
                                else
                                {
                                    Trace(0, "Error: SynthSink - SetDirectSound failed, couldn't get buffer caps\n");
                                    hr = E_UNEXPECTED;
                                }
                            }
                            else
                            {
                                Trace(0, "Error: SynthSink - SetDirectSound failed, format doesn't match synth\n");
                                hr = DMUS_E_WAVEFORMATNOTSUPPORTED;
                            }
                        }
                        else
                        {
                            Trace(0, "Error: SynthSink - SetDirectSound failed, couldn't get buffer format\n");
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    {
                        hr = S_OK;
                    }
                }
                else
                {
                    Trace(0, "Error: SynthSink - SetDirectSound failed, synth format not valid for this sink\n");
                    hr = E_UNEXPECTED;
                }
            }
            else
            {
                Trace(0, "Error: SynthSink - SetDirectSound failed, couldn't get synth format\n");
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            Trace(0, "Error: SynthSink - SetDirectSound failed, sink not initialized\n");
            hr = DMUS_E_SYNTHNOTCONFIGURED;
        }

        if (FAILED(hr))
        {
            if (m_pExtBuffer)
            {
                m_pExtBuffer->Release(); m_pExtBuffer = NULL;
            }

            m_pDSound->Release(); m_pDSound = NULL;
        }
    }
    else
    {
        hr = S_OK;
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CDSLink::GetDesiredBufferSize(
    LPDWORD pdwBufferSizeInSamples)
{
    V_INAME(IDirectMusicSynthSink::GetDesiredBufferSize);
    V_PTR_WRITE(pdwBufferSizeInSamples, DWORD);

    if (!m_pSynth)
    {
        Trace(0, "Error: SynthSink - GetDesiredBufferSize, sink not initialized\n");
        return DMUS_E_SYNTHNOTCONFIGURED;
    }

    HRESULT hr = E_FAIL;
    WAVEFORMATEX wfx;
    DWORD dwWaveFormatExSize = sizeof(wfx);
    memset(&wfx, 0, sizeof(wfx));

    ::EnterCriticalSection(&m_CriticalSection);
    if (SUCCEEDED(m_pSynth->GetFormat(&wfx, &dwWaveFormatExSize)))
    {
        *pdwBufferSizeInSamples = DSBUFFER_LENGTH_SEC * wfx.nAvgBytesPerSec;
        hr = S_OK;
    }
    else
    {
        Trace(0, "Error: SynthSink - GetDesiredBufferSize, couldn't get synth format\n");
        hr = E_UNEXPECTED;
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}


CClock::CClock()

{
    m_pDSLink = NULL;
    m_fStopped = TRUE;
}

void CClock::Init(CDSLink *pDSLink)

{
    m_pDSLink = pDSLink;
}

HRESULT CClock::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
    V_INAME(IReferenceClock::QueryInterface);
    V_REFGUID(riid);
    V_PTRPTR_WRITE(ppvObj);

    if( ::IsEqualIID( riid, IID_IReferenceClock ) ||
        ::IsEqualIID( riid, IID_IUnknown ) )
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CClock::AddRef()
{
    if (m_pDSLink)
    {
        return m_pDSLink->AddRef();
    }
    else return 0;
}

ULONG CClock::Release()
{
    if (m_pDSLink)
    {
        return m_pDSLink->Release();
    }
    else return 0;
}

HRESULT STDMETHODCALLTYPE CClock::AdviseTime( REFERENCE_TIME /*baseTime*/,
                                                REFERENCE_TIME /*streamTime*/,
                                                HANDLE /*hEvent*/,
                                                DWORD __RPC_FAR* /*pdwAdviseCookie*/)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CClock::AdvisePeriodic( REFERENCE_TIME /*startTime*/,
                                                    REFERENCE_TIME /*periodTime*/,
                                                    HANDLE /*hSemaphore*/,
                                                    DWORD __RPC_FAR* /*pdwAdviseCookie*/)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CClock::Unadvise( DWORD /*dwAdviseCookie*/ )
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CClock::GetTime(
    REFERENCE_TIME __RPC_FAR* pTime )   // <t ReferenceTime> structure to hold returned time.
{
    HRESULT hr = E_FAIL;
    if( pTime == NULL )
    {
        return E_INVALIDARG;
    }

    if (m_pDSLink != NULL)
    {
        if (m_pDSLink->m_fActive && !m_fStopped)
        {
            REFERENCE_TIME rtCompare;
            if (m_pDSLink->m_pIMasterClock)
            {
                m_pDSLink->m_pIMasterClock->GetTime(&rtCompare);

                ::EnterCriticalSection(&m_pDSLink->m_CriticalSection); // make sure SynthProc is not about to update
                hr = m_pDSLink->SampleToRefTime(m_pDSLink->ByteToSample(m_pDSLink->m_llAbsWrite), pTime);
                ::LeaveCriticalSection(&m_pDSLink->m_CriticalSection);
                if (FAILED(hr))
                {
                    Trace(1, "Error: SynthSink Latency Clock: SampleToRefTime failed\n");
                    return hr;
                }

                if (*pTime < rtCompare)
                {
                    Trace(3, "Warning: SynthSink Latency Clock off. Latency time is %ldms, Master time is %ldms\n",
                        (long) (*pTime / 10000), (long) (rtCompare / 10000));
                    *pTime = rtCompare;
                }
                else if (*pTime > (rtCompare + (10000 * 1000)))
                {
                    Trace(3, "Warning: SynthSink Latency Clock off. Latency time is %ldms, Master time is %ldms\n",
                        (long) (*pTime / 10000), (long) (rtCompare / 10000));
                    *pTime = rtCompare + (10000 * 1000);
                }

                hr = S_OK;
            }
            else
            {
                Trace(2, "Warning: SynthSink Latency Clock - GetTime called with no master clock\n");
            }
        }
        else
        {
            Trace(2, "Warning: SynthSink Latency Clock - GetTime called with synth sink not active\n");
        }
    }
    return hr;
}

void CClock::Stop()

{
    m_fStopped = TRUE;
}

void CClock::Start()

{
    m_fStopped = FALSE;
}

static DWORD g_dwPropFalse = FALSE;
static DWORD g_dwPropTrue = TRUE;

SINKPROPERTY CDSLink::m_aProperty[] =
{
    {
        &GUID_DMUS_PROP_SynthSink_DSOUND,
        0,
        KSPROPERTY_SUPPORT_GET,
        SINKPROP_F_STATIC,
        &g_dwPropTrue,
        sizeof(g_dwPropTrue),
        NULL
    },
    {
        &GUID_DMUS_PROP_SynthSink_WAVE,
        0,
        KSPROPERTY_SUPPORT_GET,
        SINKPROP_F_STATIC,
        &g_dwPropFalse,
        sizeof(g_dwPropFalse),
        NULL
    },
    {
        &GUID_DMUS_PROP_WriteLatency,
        0,
        KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET,
        SINKPROP_F_FNHANDLER,
        NULL,
        0,
        HandleLatency
    },
    {
        &GUID_DMUS_PROP_WritePeriod,
        0,
        KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET,
        SINKPROP_F_STATIC,
        &g_DSLinkList.m_dwResolution,
        sizeof(g_DSLinkList.m_dwResolution),
        NULL
    },
    {
        &GUID_DMUS_PROP_SinkUsesDSound,
        0,
        KSPROPERTY_SUPPORT_GET,
        SINKPROP_F_STATIC,
        &g_dwPropTrue,
        sizeof(g_dwPropTrue),
        NULL
    }
};

HRESULT CDSLink::HandleLatency(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer)

{
    DWORD dwLatency;
    if (*pcbBuffer != sizeof(dwLatency))
    {
        return E_INVALIDARG;
    }
    if (!m_pSynth || !IsValidFormat(&m_wfSynth))
    {
        return DMUS_E_SYNTHNOTCONFIGURED;
    }
    if (fSet)
    {
        dwLatency = *(DWORD*)pbBuffer;
        if (dwLatency < 5) dwLatency = 5;
        if (dwLatency > 1000) dwLatency = 1000;
        m_dwWriteTo = SampleAlign((500 + (m_wfSynth.nAvgBytesPerSec * dwLatency)) / 1000);
    }
    else
    {
        dwLatency = m_dwWriteTo * 1000;
        if (m_wfSynth.nAvgBytesPerSec)
        {
            dwLatency += m_wfSynth.nAvgBytesPerSec / 2; // Correct rounding error.
            dwLatency /= m_wfSynth.nAvgBytesPerSec;
        }
        else
        {
            dwLatency = 300; // Should never happen, trapped by IsValidFormat().
        }
        *(DWORD*)pbBuffer = dwLatency;
    }

    return S_OK;
}

const int CDSLink::m_nProperty = sizeof(m_aProperty) / sizeof(m_aProperty[0]);

/*
CDSLink::FindPropertyItem

Given a GUID and an item ID, find the associated property item in the synth's
table of SYNPROPERTY's.

Returns a pointer to the entry or NULL if the item was not found.
*/
SINKPROPERTY *CDSLink::FindPropertyItem(REFGUID rguid, ULONG ulId)
{
    SINKPROPERTY *pPropertyItem = &m_aProperty[0];
    SINKPROPERTY *pEndOfItems = pPropertyItem + m_nProperty;

    for (; pPropertyItem != pEndOfItems; pPropertyItem++)
    {
        if (*pPropertyItem->pguidPropertySet == rguid &&
             pPropertyItem->ulId == ulId)
        {
            return pPropertyItem;
        }
    }

    return NULL;
}

#define KS_VALID_FLAGS (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET| KSPROPERTY_TYPE_BASICSUPPORT)

STDMETHODIMP CDSLink::KsProperty(
    PKSPROPERTY pPropertyIn, ULONG ulPropertyLength,
    LPVOID pvPropertyData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    HRESULT hr = E_FAIL;

    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pPropertyIn, ulPropertyLength);
    V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    DWORD dwFlags = pPropertyIn->Flags & KS_VALID_FLAGS;

    SINKPROPERTY *pProperty = FindPropertyItem(pPropertyIn->Set, pPropertyIn->Id);

    if (pProperty == NULL)
    {
        Trace(2, "Warning: KsProperty call requested unknown property.\n");
        return DMUS_E_UNKNOWN_PROPERTY;
    }

    if (pvPropertyData == NULL )
    {
        return E_INVALIDARG;
    }

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_GET))
            {
                Trace(1, "Error: SynthSink does not support Get for the requested property.\n");
                hr = DMUS_E_GET_UNSUPPORTED;
                break;
            }

            if (pProperty->ulFlags & SINKPROP_F_FNHANDLER)
            {
                SINKPROPHANDLER pfn = pProperty->pfnHandler;
                *pulBytesReturned = ulDataLength;
                return (this->*pfn)(pPropertyIn->Id, FALSE, pvPropertyData, pulBytesReturned);
            }

            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pvPropertyData, pProperty->pPropertyData, ulDataLength);
            *pulBytesReturned = ulDataLength;

            hr = S_OK;
            break;

        case KSPROPERTY_TYPE_SET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_SET))
            {
                Trace(1, "Error: SynthSink does not support Set for the requested property.\n");
                hr = DMUS_E_SET_UNSUPPORTED;
                break;
            }

            if (pProperty->ulFlags & SINKPROP_F_FNHANDLER)
            {
                SINKPROPHANDLER pfn = pProperty->pfnHandler;
                hr = (this->*pfn)(pPropertyIn->Id, TRUE, pvPropertyData, &ulDataLength);
            }
            else
            {
                if (ulDataLength > pProperty->cbPropertyData)
                {
                    ulDataLength = pProperty->cbPropertyData;
                }

                CopyMemory(pProperty->pPropertyData, pvPropertyData, ulDataLength);

                hr = S_OK;
            }

            break;

        case KSPROPERTY_TYPE_BASICSUPPORT:
            // XXX Find out what convention is for this!!
            //
            if (ulDataLength < sizeof(DWORD) || pvPropertyData == NULL )
            {
                hr = E_INVALIDARG;
                break;
            }

            *(LPDWORD)pvPropertyData = pProperty->ulSupported;
            *pulBytesReturned = sizeof(DWORD);

            hr = S_OK;
            break;

        default:
            Trace(1, "Error: KSProperty failed, Flags must contain one of %s\n"
                      "\tKSPROPERTY_TYPE_SET, KSPROPERTY_TYPE_GET, or KSPROPERTY_TYPE_BASICSUPPORT\n");
            hr = E_INVALIDARG;
            break;
    }

    return hr;
}

STDMETHODIMP CDSLink::KsMethod(
    PKSMETHOD pMethod, ULONG ulMethodLength,
    LPVOID pvMethodData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynth::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    return DMUS_E_UNKNOWN_PROPERTY;
}

STDMETHODIMP CDSLink::KsEvent(
    PKSEVENT pEvent, ULONG ulEventLength,
    LPVOID pvEventData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    return DMUS_E_UNKNOWN_PROPERTY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\dmsynth.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
// dmsynth.cpp
// @@END_DDKSPLIT
//
// Dll entry points and IDirectMusicSynthFactory implementation
//
#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include "debug.h"

#include "oledll.h"

#include "dmusicc.h"
#include "dmusics.h"
#include "umsynth.h"
#include "misc.h" 
#include <regstr.h>
#include "synth.h"

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
// dslink is only used in the DirectMusic Synth
// validate is located in the sample itself instead of in a shared directory
#include "dslink.h"
#include "..\shared\validate.h"
#include "..\shared\dmusiccp.h"

#if 0 // The following section will only take effect in the DDK sample.
// @@END_DDKSPLIT
#include "validate.h"
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT


// Globals
//


// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
extern CDSLinkList g_DSLinkList;
// @@END_DDKSPLIT


// Version information for our class
//
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
TCHAR g_szMSSynthFriendlyName[]    = TEXT("Microsoft Software Synthesizer");

TCHAR g_szSynthFriendlyName[]    = TEXT("DirectMusicSynth");
TCHAR g_szSynthVerIndProgID[]    = TEXT("Microsoft.DirectMusicSynth");
TCHAR g_szSynthProgID[]          = TEXT("Microsoft.DirectMusicSynth.1");

TCHAR g_szSinkFriendlyName[]    = TEXT("DirectMusicSynthSink");
TCHAR g_szSinkVerIndProgID[]    = TEXT("Microsoft.DirectMusicSynthSink");
TCHAR g_szSinkProgID[]          = TEXT("Microsoft.DirectMusicSynthSink.1");
#if 0 // The following section will only take effect in the DDK sample.
// @@END_DDKSPLIT

TCHAR g_szMSSynthFriendlyName[]    = TEXT("Microsoft DDK Software Synthesizer");

TCHAR g_szSynthFriendlyName[]    = TEXT("DDKSynth");
TCHAR g_szSynthVerIndProgID[]    = TEXT("Microsoft.DDKSynth");
TCHAR g_szSynthProgID[]          = TEXT("Microsoft.DDKSynth.1");

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT

// Dll's hModule
//
HMODULE g_hModule = NULL; 

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;


static char const g_szDoEmulation[] = "DoEmulation";

// CDirectMusicSynthFactory::QueryInterface
//
HRESULT __stdcall
CDirectMusicSynthFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(IDirectMusicSynthFactory::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CDirectMusicSynthFactory::CDirectMusicSynthFactory()

{
	m_cRef = 1;
	InterlockedIncrement(&g_cLock);
}

CDirectMusicSynthFactory::~CDirectMusicSynthFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CDirectMusicSynthFactory::AddRef
//
ULONG __stdcall
CDirectMusicSynthFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CDirectMusicSynthFactory::Release
//
ULONG __stdcall
CDirectMusicSynthFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CDirectMusicSynthFactory::CreateInstance
//
//
HRESULT __stdcall
CDirectMusicSynthFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
//    OSVERSIONINFO osvi;
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CUserModeSynth *pDM;
    
    try
    {
        pDM = new CUserModeSynth;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    // Do initialiazation
    //
    hr = pDM->Init();
    if (!SUCCEEDED(hr)) {
        delete pDM;
        return hr;
    }

    hr = pDM->QueryInterface(iid, ppv);
//    pDM->Release();
    
    return hr;
}

// CDirectMusicSynthFactory::LockServer
//
HRESULT __stdcall
CDirectMusicSynthFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
// CDirectMusicSynthSinkFactory::QueryInterface
//
HRESULT __stdcall
CDirectMusicSynthSinkFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(IDirectMusicSynthSinkFactory::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CDirectMusicSynthSinkFactory::CDirectMusicSynthSinkFactory()

{
	m_cRef = 1;
	InterlockedIncrement(&g_cLock);
}

CDirectMusicSynthSinkFactory::~CDirectMusicSynthSinkFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CDirectMusicSynthSinkFactory::AddRef
//
ULONG __stdcall
CDirectMusicSynthSinkFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CDirectMusicSynthSinkFactory::Release
//
ULONG __stdcall
CDirectMusicSynthSinkFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CDirectMusicSynthSinkFactory::CreateInstance
//
//
HRESULT __stdcall
CDirectMusicSynthSinkFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
//    OSVERSIONINFO osvi;
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CDSLink *pDSLink;

    try
    {
        pDSLink = new CDSLink;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDSLink == NULL) {
        return E_OUTOFMEMORY;
    }

    // Do initialiazation
    //
    hr = pDSLink->Init(NULL);
    if (!SUCCEEDED(hr)) {
        delete pDSLink;
        return hr;
    }

    hr = pDSLink->QueryInterface(iid, ppv);
//    pDM->Release();
    
    return hr;
}

// CDirectMusicSynthSinkFactory::LockServer
//
HRESULT __stdcall
CDirectMusicSynthSinkFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}
// @@END_DDKSPLIT


// Standard calls needed to be an inproc server
//
STDAPI  DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
        IUnknown* pIUnknown = NULL;


// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
        if(clsid == CLSID_DirectMusicSynth)
#if 0 // The following section will only take effect in the DDK sample.
// @@END_DDKSPLIT
        if(clsid == CLSID_DDKSynth)
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT
        {

                pIUnknown = static_cast<IUnknown*> (new CDirectMusicSynthFactory);
                if(!pIUnknown) 
                {
                        return E_OUTOFMEMORY;
                }
        }
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
        else if(clsid == CLSID_DirectMusicSynthSink)
        {

                pIUnknown = static_cast<IUnknown*> (new CDirectMusicSynthSinkFactory);
                if(!pIUnknown) 
                {
                        return E_OUTOFMEMORY;
                }
        }
// @@END_DDKSPLIT
        else
        {
			return CLASS_E_CLASSNOTAVAILABLE;
		}

        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();

    return hr;
}

const TCHAR cszSynthRegRoot[] = TEXT(REGSTR_PATH_SOFTWARESYNTHS) TEXT("\\");
const TCHAR cszDescriptionKey[] = TEXT("Description");
const int CLSID_STRING_SIZE = 39;
HRESULT CLSIDToStr(const CLSID &clsid, TCHAR *szStr, int cbStr);

HRESULT RegisterSynth(REFGUID guid,
                      const TCHAR szDescription[])
{
    HKEY hk;
    TCHAR szCLSID[CLSID_STRING_SIZE];
    TCHAR szRegKey[256];
    
    HRESULT hr = CLSIDToStr(guid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    lstrcpy(szRegKey, cszSynthRegRoot);
    lstrcat(szRegKey, szCLSID);

    if (RegCreateKey(HKEY_LOCAL_MACHINE,
                     szRegKey,
                     &hk))
    {
        return E_FAIL;
    }

    hr = S_OK;

    if (RegSetValueEx(hk,
                  cszDescriptionKey,
                  0L,
                  REG_SZ,
                  (CONST BYTE*)szDescription,
                  lstrlen(szDescription) + 1))
    {
        hr = E_FAIL;
    }

    RegCloseKey(hk);
    return hr;
}

STDAPI DllUnregisterServer()
{
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    UnregisterServer(CLSID_DirectMusicSynth,
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
    UnregisterServer(CLSID_DDKSynth,
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT
                     g_szSynthFriendlyName,
                     g_szSynthVerIndProgID,
                     g_szSynthProgID);

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    UnregisterServer(CLSID_DirectMusicSynthSink,
					 g_szSinkFriendlyName,
					 g_szSinkVerIndProgID,
					 g_szSinkProgID);
// @@END_DDKSPLIT

    return S_OK;
}

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
                   CLSID_DirectMusicSynth,
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
                   CLSID_DDKSynth,
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT
                   g_szSynthFriendlyName,
                   g_szSynthVerIndProgID,
                   g_szSynthProgID);

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    RegisterServer(g_hModule,
                   CLSID_DirectMusicSynthSink,
                   g_szSinkFriendlyName,
                   g_szSinkVerIndProgID,
                   g_szSinkProgID);
// @@END_DDKSPLIT

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    RegisterSynth(CLSID_DirectMusicSynth, g_szMSSynthFriendlyName);
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
    RegisterSynth(CLSID_DDKSynth, g_szMSSynthFriendlyName);
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT

    return S_OK;
}

extern void DebugInit();

// Standard Win32 DllMain
//

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)

{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        Trace(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        Trace(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {
        if (++nReferenceCount == 1)
		{
            DisableThreadLibraryCalls(hModule);
            g_hModule = hModule;
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
            if (!g_DSLinkList.OpenUp())
            {
                return FALSE;
            }
// @@END_DDKSPLIT
#ifdef DBG
			DebugInit();
#endif
#ifdef DBG
//>>>>>>>>> remove these when done 
/*
			_CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_DEBUG );
			int iFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
			_CrtSetDbgFlag( iFlag | _CRTDBG_ALLOC_MEM_DF | _CRTDBG_CHECK_ALWAYS_DF );
*/
#endif 
            if (!CControlLogic::InitCriticalSection())
            {
                TraceI(0, "Failed to initialize global critical section -- failing init\n");
                return FALSE;
            }            
		}
    }
	else if (dwReason == DLL_PROCESS_DETACH) 
	{
		if (--nReferenceCount == 0)
		{
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
			g_DSLinkList.CloseDown();
            
            TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
            // Assert if we still have some objects hanging around
            assert(g_cComponent == 0);
            assert(g_cLock == 0);
// @@END_DDKSPLIT
		}

#ifdef DBG
//>>>>>>>>> remove these when done 
/*
		if ( !_CrtCheckMemory() )
		    ::MessageBox(NULL,"Synth Heap Corupted","ERROR",MB_OK);

        if ( _CrtDumpMemoryLeaks() )
		    ::MessageBox(NULL,"Memory Leaks Detected","ERROR",MB_OK);
*/
#endif 
        CControlLogic::KillCriticalSection();
	}
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\dslink.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//	DSLink.h

#ifndef __DS_LINK__
#define __DS_LINK__

#include <math.h>
#include <mmsystem.h>
#include <dsound.h>
#include "dmusicc.h"
#include "dmusics.h"
#include "cclock.h"
#include "PLClock.h"
#include "clist.h"


class CDSLink;
typedef HRESULT (CDSLink::*SINKPROPHANDLER)(ULONG ulId, BOOL fSet, LPVOID pvPropertyData, PULONG pcbPropertyData);

#define SINKPROP_F_STATIC                0x00000001
#define SINKPROP_F_FNHANDLER             0x00000002

#include <pshpack4.h>
// Struct for holding a property item supported by the sink
//
struct SINKPROPERTY
{
    const GUID *pguidPropertySet;       // What property set?
    ULONG   	ulId;                   // What item?

    ULONG   	ulSupported;            // Get/Set flags for QuerySupported

    ULONG       ulFlags;                // SINKPROP_F_xxx

	LPVOID  	pPropertyData;    
    ULONG   	cbPropertyData;         // and its size

    SINKPROPHANDLER pfnHandler;         // Handler fn if SINKPROP_F_FNHANDLER
};
#include <poppack.h>

class CDSLink : public CListItem, public IDirectMusicSynthSink, public IKsControl
{
friend class CClock;
friend class CDSLinkList;
public:
	CDSLink * GetNext();
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDirectMusicSynthSink
public:
    virtual STDMETHODIMP Init(IDirectMusicSynth *pSynth);
	virtual STDMETHODIMP SetMasterClock(IReferenceClock *pClock);
	virtual STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
	virtual STDMETHODIMP Activate(BOOL fEnable);
	virtual STDMETHODIMP SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
	virtual STDMETHODIMP RefTimeToSample(REFERENCE_TIME rfTime, LONGLONG *pllSampleTime);
    virtual STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    virtual STDMETHODIMP GetDesiredBufferSize(LPDWORD pdwBufferSizeInSamples);

// IKsPropertySet
    virtual STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    virtual STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    virtual STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
						CDSLink();
						~CDSLink();
	void				Clear();
private:
	IDirectMusicSynth *	m_pSynth;		// Reference to synth that uses this.
    CClock				m_Clock;        // Latency clock.
	IReferenceClock *	m_pIMasterClock;	// Master clock from app.
	CSampleClock		m_SampleClock;	// Use to synchronize timing with master clock.
	long				m_cRef;
	WAVEFORMATEX		m_wfSynth;		// Waveform requested by synth.

	LPDIRECTSOUND 		m_pDSound;			
	LPDIRECTSOUNDBUFFER	m_pPrimary;			// Primary buffer.
	LPDIRECTSOUNDBUFFER	m_pBuffer;			// Mix buffer.
	LPDIRECTSOUNDBUFFER	m_pExtBuffer;		// Optional buffer from SetDirectSound.
    CRITICAL_SECTION	m_CriticalSection;	// Critical section to manage access.
    BOOL                m_fCSInitialized;   //  Was CS initialized?
	LONGLONG			m_llAbsPlay;		// Absolute point where play head is.
	DWORD				m_dwLastPlay;		// Point in buffer where play head is.
	LONGLONG			m_llAbsWrite;	    // Absolute point we've written up to.
	DWORD				m_dwLastWrite;	    // Last position we wrote to in buffer.
	DWORD				m_dwBufferSize;		// Size of buffer.
	DWORD				m_dwWriteTo;		// Distance between write head and where we are writing.
	DWORD               m_dwWriteFromMax;   // Max distance observed between play and write head.
	BOOL				m_fActive;			// Currently active.

	HRESULT				Connect();
	HRESULT				Disconnect();
	void				SynthProc();

	static SINKPROPERTY m_aProperty[];
	static const int m_nProperty;
	static SINKPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);

    HRESULT HandleLatency(
        ULONG               ulId, 
        BOOL                fSet, 
        LPVOID              pbBuffer, 
        PULONG              pcbBuffer);

    // helpers
    LONGLONG SampleToByte(LONGLONG llSamples) {return llSamples << m_wfSynth.nChannels;}   // REVIEW: dwSamples * m_wfSynth.nBlockAlign
    DWORD SampleToByte(DWORD dwSamples) {return dwSamples << m_wfSynth.nChannels;}   // REVIEW: dwSamples * m_wfSynth.nBlockAlign
    LONGLONG ByteToSample(LONGLONG llBytes)   {return llBytes >> m_wfSynth.nChannels;}     // REVIEW: dwBytes / m_wfSynth.nBlockAlign
    DWORD ByteToSample(DWORD dwBytes)   {return dwBytes >> m_wfSynth.nChannels;}     // REVIEW: dwBytes / m_wfSynth.nBlockAlign
    LONGLONG SampleAlign(LONGLONG llBytes)    {return SampleToByte(ByteToSample(llBytes));}
    DWORD SampleAlign(DWORD dwBytes)    {return SampleToByte(ByteToSample(dwBytes));}
    
    BOOL IsValidFormat(LPCWAVEFORMATEX pwf)
    {
        return (pwf &&
            pwf->wFormatTag == WAVE_FORMAT_PCM &&
            (pwf->nChannels == 1 || pwf->nChannels == 2) &&
            (pwf->nSamplesPerSec == 44100 || pwf->nSamplesPerSec == 22050 || pwf->nSamplesPerSec == 11025) &&
            pwf->wBitsPerSample == 16 &&
            pwf->nBlockAlign == (pwf->nChannels * (pwf->wBitsPerSample / 8)) &&
            pwf->nAvgBytesPerSec == (pwf->nSamplesPerSec * pwf->nBlockAlign));
    }
};


class CDSLinkList : public CList
{
public:
						CDSLinkList();
	BOOL				OpenUp();
    void				CloseDown();
	CDSLink *			GetHead();
	CDSLink *			RemoveHead();
	void				Remove(CDSLink *pLink);
	void				AddTail(CDSLink *pLink);
	CDSLink *			GetItem(LONG index);
	BOOL				InitThread();
	void				ActivateLink(CDSLink *pLink);
	void				DeactivateLink(CDSLink *pLink);			
	void				SynthProc();
    
    BOOL                m_fOpened;
    CRITICAL_SECTION	m_CriticalSection;	// Critical section to manage access.
    HANDLE				m_hThread;          // Handle for synth thread.
	BOOL				m_fPleaseDie;		// Triggers exit.
    DWORD				m_dwThread;         // ID for thread.
    HANDLE				m_hEvent;           // Used to signal thread.
	DWORD				m_dwCount;          // Number of sinks
    DWORD               m_dwResolution;     // Synth thread timeout (ms)
};

// Class factory
//
// Common to emulation/WDM.
// 
class CDirectMusicSynthSinkFactory : public IClassFactory
{
public:
	// IUnknown
    //
	virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CDirectMusicSynthSinkFactory();

	// Destructor
	~CDirectMusicSynthSinkFactory();

private:
	long m_cRef;
};


#endif // __DS_LINK__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\float.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include "float.h"
#endif

#ifdef _ALPHA_
#include <math.h>
#endif		// _ALPHA_


#ifndef _ALPHA_

#ifndef DBG
extern "C" int _fltused = 1;
#endif
// asm_fsave(rgbState)
//
// Store the floating point state into <rgbState> and reinitialize the FPU.
//
void __cdecl asm_fsave(char *rgbState)
{
	_asm
	{
		mov		eax, dword ptr rgbState
		fsave	[eax]
	}
}


// asm_frestore(rgbState)
//
// Restore a previously saved floating point state <rgbState>.
//
void __cdecl asm_frestore(const char *rgbState)
{
	_asm
	{
		fwait
		mov		eax, dword ptr rgbState
		frstor	[eax]
	}
}


// FLOATSAFE
//
// Saves floating point state on construction and restores on destruction.
//
struct FLOATSAFE
{
	char m_rgbState[105];
	FLOATSAFE::FLOATSAFE(void)
	{
		asm_fsave(m_rgbState);
	}
	FLOATSAFE::~FLOATSAFE(void)
	{
		asm_frestore(m_rgbState);
	}
};


// asm_fdiv()
//
float __cdecl asm_fdiv(float flNum, float flDenom)
{
	float flResult = (float) 0.0;

	if (flDenom != (float) 0.0)
	{
		_asm
		{									 
			fld       flNum
			fdiv      flDenom
			fstp      flResult
			fnclex				; clear the status word of exceptions
		}
	}

	return(flResult);
}


// asm__fsin()
//
float __cdecl asm_fsin(float flRad)
{
	float flSine;

	_asm
	{
		fld       flRad
		fsin
		fstp      flSine
		fnclex				; clear the status word of exceptions
	}

	return(flSine);
}


// asm__fcos()
//
float __cdecl asm_fcos(float flRad)
{
	float flCosine;

	_asm
	{
		fld       flRad
		fcos
		fstp      flCosine
		fnclex				; clear the status word of exceptions
	}

	return(flCosine);
}


// asm_flog2()
//
float __cdecl asm_flog2(float flX)
{
	float flLog;

	_asm
	{
		fld1
		fld		flX
		fyl2X
		fstp	flLog;
		fnclex				; clear the status word of exceptions
	}
	
	return flLog;
}


// asm_ftol()
//
long __cdecl asm_ftol(float flX)
{
	long lResult;
	WORD wCW;
	WORD wNewCW;

	_asm
	{
		fld       flX			// Push the float onto the stack
		wait
		fnstcw    wCW			// Store the control word
		wait
		mov       ax,wCW		// Setup our rounding
		or        ah,0x0c
		mov       wNewCW,ax
		fldcw     wNewCW		// Set Control word to our new value
		fistp     lResult		// Round off top of stack into result
		fldcw     wCW			// Restore control word
		fnclex					// clear the status word of exceptions
	}

	return(lResult);
}


// asm_fpow()
//
float __cdecl asm_fpow(float flX, float flY)
{
	float flHalf = (float) 0.5;
	float flOne = (float) 1.0;
	float flResult = (float) 0.0;

	if (flX == (float) 0.0 && flY > (float) 0.0)
	{
		flResult = (float) 0.0;
	}
	else if (flX == (float) 0.0 && flY <= (float) 0.0)
	{
		flResult = (float) 1.0;
	}
	else if (flY == (float) 0.0)
	{
		flResult = (float) 1.0;
	}
	else
	{
		BOOL fNeg = FALSE;
			// Ok, if X is negative the sign is positive if the Y is even
			// and negative if Y is odd.  Fractions can't be done.
		if (flX < (float) 0.0)
		{
			long lY = asm_ftol(flY);

			if ((float) lY == flY)	// Only fix it if we have a integer poer
			{
				flX = -flX;

				if (lY % 2)
				{
					fNeg = TRUE;
				}
			}
		}

		flX = flY * asm_flog2(flX);

		if (max(-flX,flX) < flOne)
			// Is the power is in the range which F2XM1 can handle?
		{
			_asm
			{
				fld		flX				// Put flX in ST[0]			
				f2xm1					// ST := 2^ST - 1
				fadd	flOne			// ST := 2^mantissa
				fstp	flResult		// Store result
				fnclex					// clear the status word of exceptions
			}	
		}
		else					// Nope, we've got to scale first
		{
			_asm
			{
				fld		flX				// Put flX in ST[0]
				fld		ST				// Duplicate ST
				frndint					// Integral value in ST
				fsub	ST(1),ST		// Fractional value in ST(1)
				fxch					// Factional value in ST
				f2xm1					// ST := 2^ST - 1
				fadd	flOne			// ST := 2^frac
				fscale					// ST := 2^frac * 2^integral
				fstp	flResult		// Store result
				fnclex					// clear the status word of exceptions
			}
		}

		if (fNeg)
		{
			flResult = -flResult;
		}
	}

	return flResult;
}

#endif		// _ALPHA_


// fp_ftol()
//
STDAPI_(long) fp_ftol(float flX)
{
#ifdef _ALPHA_
	return (long)flX;
#else
	FLOATSAFE fs;
	return(asm_ftol(flX));
#endif
}


// fp_ltof()
//
STDAPI_(float) fp_ltof(long lx)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return(float(lx));
}


// fp_fadd()
//
STDAPI_(float) fp_fadd(float flX, float flY)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return(flX + flY);
}


// fp_fsub()
//
STDAPI_(float) fp_fsub(float flX, float flY)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return(flX - flY);
}


// fp_fmul()
//
STDAPI_(float) fp_fmul(float flX, float flY)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return(flX * flY);
}


// fp_fdiv()
//
STDAPI_(float) fp_fdiv(float flNum, float flDenom)
{
#ifdef _ALPHA_
	return flNum/flDenom;
#else
	FLOATSAFE fs;
	return(asm_fdiv(flNum,flDenom));
#endif
}


// fp_fabs()
//
STDAPI_(float) fp_fabs(float flX)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return max(-flX,flX);
}


// fp_fsin()
//
STDAPI_(float) fp_fsin(float flRad)
{
#ifdef _ALPHA_
	return sin(flRad);
#else
	FLOATSAFE fs;
	return(asm_fsin(flRad));
#endif
}


// fp_fcos()
//
STDAPI_(float) fp_fcos(float flRad)
{
#ifdef _ALPHA_
	return cos(flRad);
#else
	FLOATSAFE fs;
	return(asm_fcos(flRad));
#endif
}


// fp_fpow()
//
STDAPI_(float) fp_fpow(float flX, float flY)
{
#ifdef _ALPHA_
	return pow(flX, flY);
#else
	FLOATSAFE fs;
	return(asm_fpow(flX,flY));
#endif
}


// fp_flog2()
//
STDAPI_(float) fp_flog2(float flX)
{
#ifdef _ALPHA_
	return log(flX);
#else
	FLOATSAFE fs;
	return(asm_flog2(flX));
#endif
}


// fp_flog10()
//
STDAPI_(float) fp_flog10(float flX)
{
#ifdef _ALPHA_
	return log10(flX);
#else
	FLOATSAFE fs;
	#define LOG2OF10 float(3.321928094887)
	return(asm_fdiv(asm_flog2(flX),LOG2OF10));
#endif
}


// fp_fchs()
//
STDAPI_(float) fp_fchs(float flX)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return(-flX);
}


// fp_fcmp()
//
STDAPI_(int) fp_fcmp(float flA, float flB)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif

	if (flA > flB)
		return(1);
	
	if (flA < flB)
		return(-1);

	return(0);
}


// fp_fmin()
//
STDAPI_(float) fp_fmin(float flA, float flB)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return(min(flA,flB));
}


// fp_fmax()
//
STDAPI_(float) fp_fmax(float flA, float flB)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return(max(flA,flB));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\float.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation

// float.h
//
// Defines fp_ floating point functions which don't rely on the C runtime.
//
// If you don't want to pull in C runtime floating point support, you
// need to include the following in a .cpp file:
//
//     extern "C" int _fltused = 1;
//

// floating point operations
STDAPI_(long)   fp_ftol     (float flX);
STDAPI_(float)  fp_ltof     (long lX);
STDAPI_(float)  fp_fadd     (float fA, float fB);
STDAPI_(float)  fp_fsub     (float fA, float fB);
STDAPI_(float)  fp_fmul     (float fA, float fB);
STDAPI_(float)  fp_fdiv     (float fNum, float fDenom);
STDAPI_(float)  fp_fabs     (float flX);
STDAPI_(float)  fp_fsin     (float flX);
STDAPI_(float)  fp_fcos     (float flX);
STDAPI_(float)  fp_fpow     (float flX, float flY);
STDAPI_(float)  fp_flog2    (float flX);
STDAPI_(float)  fp_flog10   (float flX);
STDAPI_(float)  fp_fchs     (float flX);
STDAPI_(int)    fp_fcmp     (float flA, float flB);
STDAPI_(float)  fp_fmin     (float flA, float flB);
STDAPI_(float)  fp_fmax     (float flA, float flB);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\guids.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation

#include <objbase.h>
#include "initguid.h"
#include <mmsystem.h>
#include <dsoundp.h>
#include "dmusicc.h"
#include "dmusics.h"
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
#include "dmusici.h"
#include "dsoundp.h"
#include "..\shared\dmusiccp.h" // For class ids.
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
#include <ks.h>
#include "umsynth.h"
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
#endif
// @@END_DDKSPLIT
#include "dmksctrl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\kernhelp.cpp ===
// Copyright (c) 1998 Microsoft Corporation
//
// KernHelp.cpp
//
// Wrappers for kernel functions to make synth core cross compilable
//

extern "C" {
#include <ntddk.h>
};

#include "KernHelp.h"

VOID InitializeCriticalSection(
    LPCRITICAL_SECTION CritSect)
{
    KeInitializeMutex((PKMUTEX)CritSect, 1);
}

VOID EnterCriticalSection(
    LPCRITICAL_SECTION CritSect)
{
    KeWaitForSingleObject((PKMUTEX)CritSect,
                          Executive,
                          KernelMode,
                          FALSE,
                          0);

}

VOID LeaveCriticalSection(
    LPCRITICAL_SECTION CritSect)
{
    KeReleaseMutex((PKMUTEX)CritSect, FALSE);
}

VOID DeleteCriticalSection(
    LPCRITICAL_SECTION CritSect)
{
    // NOP in kernel
    //
}

// GetRegValueDword
//
// Must be called at passive level
//
int GetRegValueDword(
    LPTSTR RegPath,
    LPTSTR ValueName,
    PULONG Value)
{
    int                             ReturnValue = 0;
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    HANDLE                          KeyHandle;
    KEY_VALUE_PARTIAL_INFORMATION   *Information;
    ULONG                           InformationSize;
    UNICODE_STRING                  UnicodeRegPath;
    UNICODE_STRING                  UnicodeValueName;

    RtlInitUnicodeString(&UnicodeRegPath, RegPath);
    RtlInitUnicodeString(&UnicodeValueName, ValueName);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeRegPath,
                               0,           // Flags
                               NULL,        // Root directory
                               NULL);       // Security descriptor

    Status = ZwOpenKey(&KeyHandle,
                       KEY_QUERY_VALUE,
                       &ObjectAttributes);
    if (Status != STATUS_SUCCESS)
    {
        return 0;
    }

    InformationSize = sizeof(Information) + sizeof(ULONG);
    Information = (KEY_VALUE_PARTIAL_INFORMATION*)ExAllocatePool(PagedPool, InformationSize);
    if (Information == NULL)
    {
        return 0;
    }

    Status = ZwQueryValueKey(KeyHandle,
                             &UnicodeValueName,
                             KeyValuePartialInformation,
                             Information,
                             sizeof(Information),
                             &InformationSize);
    if (Status == STATUS_SUCCESS)
    {
        if (Information->Type == REG_DWORD && Information->DataLength == sizeof(ULONG))
        {
            RtlCopyMemory(Value, Information->Data, sizeof(ULONG));
            ReturnValue = 1;
        }
    }                                
                                    
    ExFreePool(Information);
    ZwClose(KeyHandle);

    return ReturnValue;                                
}

ULONG GetTheCurrentTime()
{
    LARGE_INTEGER Time;

    KeQuerySystemTime(&Time);

    return (ULONG)(Time.QuadPart / (10 * 1000));
}

void DebugInit(void)
{
}

void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\midi.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      MIDI.cpp
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#include "math.h"
#include "debug.h"
#endif
 
CMIDIDataList    CMIDIRecorder::m_sFreeList;
DWORD            CMIDIRecorder::m_sUsageCount = 0;

CMIDIData::CMIDIData() 
{
    m_stTime = 0;
    m_lData = 0;            
}


CMIDIRecorder::CMIDIRecorder()
{
    m_sUsageCount++;
    m_lCurrentData = 0;
    m_stCurrentTime = 0;
}

CMIDIRecorder::~CMIDIRecorder()

{
    ClearMIDI(0x7FFFFFFF);
     m_sUsageCount--;
    // If there are no instances of CMIDIRecorder left, get rid of the free pool.
    if (!m_sUsageCount)
    {
        CMIDIData *pMD;
        while (pMD = m_sFreeList.RemoveHead())
        {
            delete pMD;
        }
    }
}

VREL CMIDIRecorder::m_vrMIDIToVREL[128] = 
{
    -9600, -8415, -7211, -6506, -6006, -5619, -5302, -5034, 
    -4802, -4598, -4415, -4249, -4098, -3959, -3830, -3710, 
    -3598, -3493, -3394, -3300, -3211, -3126, -3045, -2968, 
    -2894, -2823, -2755, -2689, -2626, -2565, -2506, -2449, 
    -2394, -2341, -2289, -2238, -2190, -2142, -2096, -2050, 
    -2006, -1964, -1922, -1881, -1841, -1802, -1764, -1726, 
    -1690, -1654, -1619, -1584, -1551, -1518, -1485, -1453, 
    -1422, -1391, -1361, -1331, -1302, -1273, -1245, -1217, 
    -1190, -1163, -1137, -1110, -1085, -1059, -1034, -1010, 
    -985, -961, -938, -914, -891, -869, -846, -824, 
    -802, -781, -759, -738, -718, -697, -677, -657, 
    -637, -617, -598, -579, -560, -541, -522, -504, 
    -486, -468, -450, -432, -415, -397, -380, -363, 
    -347, -330, -313, -297, -281, -265, -249, -233, 
    -218, -202, -187, -172, -157, -142, -127, -113, 
    -98, -84, -69, -55, -41, -27, -13, 0
};

VREL CMIDIRecorder::m_vrMIDIPercentToVREL[128] = 
{
    -9600, -4207, -3605, -3253, -3003, -2809, -2651, -2517, 
    -2401, -2299, -2207, -2124, -2049, -1979, -1915, -1855, 
    -1799, -1746, -1697, -1650, -1605, -1563, -1522, -1484, 
    -1447, -1411, -1377, -1344, -1313, -1282, -1253, -1224, 
    -1197, -1170, -1144, -1119, -1095, -1071, -1048, -1025, 
    -1003, -982, -961, -940, -920, -901, -882, -863, 
    -845, -827, -809, -792, -775, -759, -742, -726, 
    -711, -695, -680, -665, -651, -636, -622, -608, 
    -595, -581, -568, -555, -542, -529, -517, -505, 
    -492, -480, -469, -457, -445, -434, -423, -412, 
    -401, -390, -379, -369, -359, -348, -338, -328, 
    -318, -308, -299, -289, -280, -270, -261, -252, 
    -243, -234, -225, -216, -207, -198, -190, -181, 
    -173, -165, -156, -148, -140, -132, -124, -116, 
    -109, -101, -93, -86, -78, -71, -63, -56, 
    -49, -42, -34, -27, -20, -13, -6, 0 
};

/*void CMIDIRecorder::Init()
{
    int nIndex;
    static BOOL fAlreadyDone = FALSE;
    if (!fAlreadyDone)
    {
        m_sFreeList.RemoveAll();
        for (nIndex = 0; nIndex < MAX_MIDI_EVENTS; nIndex++)
        {
            m_sFreeList.AddHead(&m_sEventBuffer[nIndex]);
        }
        fAlreadyDone = TRUE;*/
/*		for (nIndex = 1; nIndex < 128; nIndex++)
		{
			double   flTemp;
			flTemp = nIndex;
			flTemp /= 127.0;
			flTemp = pow(flTemp,4.0);
			flTemp = log10(flTemp);
			flTemp *= 1000.0;
            Trace(0,"%ld, ",(long)flTemp);
            if ((nIndex % 8) == 7)
                Trace(0,"\n");
			m_vrMIDIToVREL[nIndex] = (VREL) flTemp;
		}
        Trace(0,"\n");
		m_vrMIDIToVREL[0] = -9600;
        for (nIndex = 1; nIndex < 128; nIndex++)
        {
            double flTemp;
            flTemp = nIndex;
            flTemp /= 127;
            flTemp *= flTemp;
            flTemp = log10(flTemp);
            flTemp *= 1000.0;
            m_vrMIDIPercentToVREL[nIndex] = (VREL) flTemp;
            Trace(0,"%ld, ",(long)flTemp);
            if ((nIndex % 8) == 7)
                Trace(0,"\n");
        }
        m_vrMIDIPercentToVREL[0] = -9600;*/
    /*}
}*/

BOOL CMIDIRecorder::FlushMIDI(STIME stTime)
{
    CMIDIData *pMD;
    CMIDIData *pLast = NULL;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            if (pLast == NULL)
            {
                m_EventList.RemoveAll();
            }
            else
            {
                pLast->SetNext(NULL);
            }
            m_sFreeList.Cat(pMD);
            break;
        }
        pLast = pMD;
    }
    return m_EventList.IsEmpty();
}

BOOL CMIDIRecorder::ClearMIDI(STIME stTime)

{
    CMIDIData *pMD;
    for (;pMD = m_EventList.GetHead();)
    {
        if (pMD->m_stTime < stTime)
        {
            m_EventList.RemoveHead();
            m_stCurrentTime = pMD->m_stTime;
            m_lCurrentData = pMD->m_lData;
            m_sFreeList.AddHead(pMD);
            
        }
        else break;
    }
    return m_EventList.IsEmpty();
}

VREL CMIDIRecorder::VelocityToVolume(WORD nVelocity)

{
    return (m_vrMIDIToVREL[nVelocity]);
}

BOOL CMIDIRecorder::RecordMIDINote(STIME stTime, long lData)

{
    CMIDIData *pMD = m_sFreeList.RemoveHead();
    if (!pMD)
    {
        pMD = new CMIDIData;
    }

	CMIDIData *pScan = m_EventList.GetHead();
	CMIDIData *pNext;
    if (pMD)
    {
        pMD->m_stTime = stTime;
        pMD->m_lData = lData;
		if (pScan == NULL)
		{
			m_EventList.AddHead(pMD);
		}
		else
		{
			if (pScan->m_stTime > stTime)
			{
				m_EventList.AddHead(pMD);
			}
			else
			{
				for (;pScan != NULL; pScan = pNext)
				{
					pNext = pScan->GetNext();
					if (pNext == NULL)
					{
						pScan->SetNext(pMD);
					}
					else
					{
						if (pNext->m_stTime > stTime)
						{
							pMD->SetNext(pNext);
							pScan->SetNext(pMD);
							break;
						}
					}
				}
			}
		}
        return (TRUE);
    }
    return (FALSE);
}

BOOL CMIDIRecorder::RecordMIDI(STIME stTime, long lData)

{
    CMIDIData *pMD = m_sFreeList.RemoveHead();
    if (!pMD)
    {
        pMD = new CMIDIData;
    }

	CMIDIData *pScan = m_EventList.GetHead();
	CMIDIData *pNext;
    if (pMD)
    {
        pMD->m_stTime = stTime;
        pMD->m_lData = lData;
		if (pScan == NULL)
		{
			m_EventList.AddHead(pMD);
		}
		else
		{
			if (pScan->m_stTime > stTime)
			{
				m_EventList.AddHead(pMD);
			}
			else
			{
				for (;pScan != NULL; pScan = pNext)
				{
                    if ((pScan->m_stTime == stTime) && 
                        (pScan->m_lData == lData))
                    {
                        m_sFreeList.AddHead(pMD);
                        break;
                    }
					pNext = pScan->GetNext();
					if (pNext == NULL)
					{
						pScan->SetNext(pMD);
					}
					else
					{
						if (pNext->m_stTime > stTime)
						{
							pMD->SetNext(pNext);
							pScan->SetNext(pMD);
							break;
						}
					}
				}
			}
		}
        return (TRUE);
    }
/*#ifdef DBG
    static gWarnCount = 0;
    if (!gWarnCount)
    {
        Trace(1,"Warning: MIDI Free event pool empty. This can be caused by time stamping problems, too much MIDI data, or too many PChannels.\n");
        gWarnCount = 100;
    }
    gWarnCount--;
#endif*/
    return (FALSE);
}

long CMIDIRecorder::GetData(STIME stTime)

{
    CMIDIData *pMD = m_EventList.GetHead();
    long lData = m_lCurrentData;
    for (;pMD;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime > stTime)
        {
            break;
        }
        lData = pMD->m_lData;
    }
    return (lData);
}

BOOL CNoteIn::RecordNote(STIME stTime, CNote * pNote)

{
	long lData = pNote->m_bPart << 16;
	lData |= pNote->m_bKey << 8;
	lData |= pNote->m_bVelocity;
	return (RecordMIDINote(stTime,lData));
}

BOOL CNoteIn::RecordEvent(STIME stTime, DWORD dwPart, DWORD dwCommand, BYTE bData)

{
	long lData = dwPart;
	lData <<= 8;
	lData |= dwCommand;
	lData <<= 8;
	lData |= bData;
	return (RecordMIDINote(stTime,lData));	
}

BOOL CNoteIn::GetNote(STIME stTime, CNote * pNote)

{
    CMIDIData *pMD = m_EventList.GetHead();
	if (pMD != NULL)
	{
		if (pMD->m_stTime <= stTime)
		{
			pNote->m_stTime = pMD->m_stTime;
			pNote->m_bPart = (BYTE) (pMD->m_lData >> 16);
			pNote->m_bKey = (BYTE) (pMD->m_lData >> 8) & 0xFF;
			pNote->m_bVelocity = (BYTE) pMD->m_lData & 0xFF;
            m_EventList.RemoveHead();
            m_sFreeList.AddHead(pMD);
			return (TRUE);
		}
	}
	return (FALSE);
}

void CNoteIn::FlushMIDI(STIME stTime)

{
    CMIDIData *pMD;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            pMD->m_stTime = stTime;     // Play now.
            pMD->m_lData &= 0xFFFFFF00; // Clear velocity to make note off.
        }
    }
}


void CNoteIn::FlushPart(STIME stTime, BYTE bChannel)

{
    CMIDIData *pMD;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
			if (bChannel == (BYTE) (pMD->m_lData >> 16))
			{
				pMD->m_stTime = stTime;     // Play now.
				pMD->m_lData &= 0xFFFFFF00; // Clear velocity to make note off.
			}
		}
    }
}

DWORD CModWheelIn::GetModulation(STIME stTime)

{
    DWORD nResult = CMIDIRecorder::GetData(stTime);
    return (nResult);
}

CPitchBendIn::CPitchBendIn()

{
    m_lCurrentData = 0x2000;	// initially at midpoint, no bend
    m_prRange = 200;           // whole tone range by default.
}

// note (davidmay 8/14/96): we don't keep a time-stamped range.
// if people are changing the pitch bend range often, this won't work right,
// but that didn't seem likely enough to warrant a new list.
PREL CPitchBendIn::GetPitch(STIME stTime)

{
    PREL prResult = (PREL) CMIDIRecorder::GetData(stTime);
    prResult -= 0x2000;         // Subtract MIDI Midpoint.
    prResult *= m_prRange;	// adjust by current range
    prResult >>= 13;
    return (prResult);
}

CVolumeIn::CVolumeIn()

{
    m_lCurrentData = 100;
}

VREL CVolumeIn::GetVolume(STIME stTime)

{
    long lResult = CMIDIRecorder::GetData(stTime);
    return (m_vrMIDIToVREL[lResult]);
}

CExpressionIn::CExpressionIn()

{
    m_lCurrentData = 127;
}

VREL CExpressionIn::GetVolume(STIME stTime)

{
    long lResult = CMIDIRecorder::GetData(stTime);
    return (m_vrMIDIToVREL[lResult]);
}

CPanIn::CPanIn()

{
    m_lCurrentData = 64;
}

long CPanIn::GetPan(STIME stTime)

{
    long lResult = (long) CMIDIRecorder::GetData(stTime);
    return (lResult);
}

//////////////////////////////////////////////////////////
// Directx8 Methods 

DWORD CPressureIn::GetPressure(STIME stTime)

{
    DWORD nResult = CMIDIRecorder::GetData(stTime);
    return (nResult);
}

CReverbIn::CReverbIn()

{
    m_lCurrentData = 40;
}

DWORD CReverbIn::GetVolume(STIME stTime)

{
    return (m_vrMIDIPercentToVREL[CMIDIRecorder::GetData(stTime)]);
}

DWORD CChorusIn::GetVolume(STIME stTime)

{
    return (m_vrMIDIPercentToVREL[CMIDIRecorder::GetData(stTime)]);
}

CCutOffFreqIn::CCutOffFreqIn()
{
	m_lCurrentData = 64;
}

DWORD CCutOffFreqIn::GetFrequency(STIME stTime)
{
    DWORD nResult = CMIDIRecorder::GetData(stTime);
    return (nResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\instr.cpp ===
//
// Copyright (c) 1996-2001 Microsoft Corporation
// Instrument.cpp
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include <mmsystem.h>
#include <dmerror.h>
#include "synth.h"
#include "math.h"
#include "debug.h"
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
#include "..\shared\validate.h"
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
#include "validate.h"
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT
#endif

void MemDump(char * prompt);

//#include <windowsx.h>

CSourceLFO::CSourceLFO()

{
    m_pfFrequency = 3804; // f = (256*4096*16*5hz)/(samplerate)
    m_stDelay = 0;
    m_prMWPitchScale = 0;
    m_vrMWVolumeScale = 0;
    m_vrVolumeScale = 0;
    m_prPitchScale = 0;
    m_prCPPitchScale = 0;
    m_vrCPVolumeScale = 0;
    m_prCutoffScale = 0;
    m_prMWCutoffScale = 0;
    m_prCPCutoffScale = 0;
}

void CSourceLFO::Init(DWORD dwSampleRate)

{
    m_pfFrequency = (256 * 4096 * 16 * 5) / dwSampleRate;
    m_stDelay = 0;
    m_prMWPitchScale = 0;
    m_vrMWVolumeScale = 0;
    m_vrVolumeScale = 0;
    m_prPitchScale = 0;
    m_prCPPitchScale = 0;
    m_vrCPVolumeScale = 0;
    m_prCutoffScale = 0;
    m_prMWCutoffScale = 0;
    m_prCPCutoffScale = 0;
}

void CSourceLFO::SetSampleRate(long lChange)

{
    if (lChange > 0)
    {
        m_stDelay <<= lChange;
        m_pfFrequency <<= lChange;
    }
    else
    {
        m_stDelay >>= -lChange;
        m_pfFrequency >>= -lChange;
    }
}

void CSourceLFO::Verify()

{
    FORCEBOUNDS(m_pfFrequency,64,7600);
    FORCEBOUNDS(m_stDelay,0,441000);
    FORCEBOUNDS(m_vrVolumeScale,-1200,1200);
    FORCEBOUNDS(m_vrMWVolumeScale,-1200,1200);
    FORCEBOUNDS(m_prPitchScale,-1200,1200);
    FORCEBOUNDS(m_prMWPitchScale,-1200,1200);
    FORCEBOUNDS(m_prCPPitchScale,-1200,1200);
    FORCEBOUNDS(m_vrCPVolumeScale,-1200,1200);
    FORCEBOUNDS(m_prCutoffScale, -12800, 12800);
    FORCEBOUNDS(m_prMWCutoffScale, -12800, 12800);
    FORCEBOUNDS(m_prCPCutoffScale, -12800, 12800);
}

CSourceEG::CSourceEG()

{
    Init();
}

void CSourceEG::Init()

{
    m_stAttack = 0;
    m_stDecay = 0;
    m_pcSustain = 1000;
    m_stRelease = 0;
    m_trVelAttackScale = 0;
    m_trKeyDecayScale = 0;
    m_sScale = 0;
    m_stDelay = 0;
    m_stHold = 0;
    m_prCutoffScale = 0;
}

void CSourceEG::SetSampleRate(long lChange)

{
    if (lChange > 0)
    {
        m_stAttack <<= lChange;
        m_stDecay <<= lChange;
        m_stRelease <<= lChange;
    }
    else
    {
        m_stAttack >>= -lChange;
        m_stDecay >>= -lChange;
        m_stRelease >>= -lChange;
    }
}

void CSourceEG::Verify()

{
    FORCEBOUNDS(m_stAttack,0,1764000);
    FORCEBOUNDS(m_stDecay,0,1764000);
    FORCEBOUNDS(m_pcSustain,0,1000);
    FORCEBOUNDS(m_stRelease,0,1764000);
    FORCEBOUNDS(m_sScale,-1200,1200);
    FORCEBOUNDS(m_trKeyDecayScale,-12000,12000);
    FORCEBOUNDS(m_trVelAttackScale,-12000,12000);
    FORCEBOUNDS(m_trKeyHoldScale,-12000,12000);
    FORCEBOUNDS(m_prCutoffScale,-12800,12800);
}

CSourceFilter::CSourceFilter()
{
    Init(22050);
}

void CSourceFilter::Init(DWORD dwSampleRate)
{
    // First, calculate the playback samplerate in pitch rels.
    // The reference frequency is a440, which is midi note 69.
    // So, calculate the ratio of the sample rate to 440 and
    // convert into prels (1200 per octave), then add the
    // offset of 6900.
    double fSampleRate = (double)dwSampleRate;

    fSampleRate /= 440.0;
    fSampleRate = log(fSampleRate) / log(2.0);
    fSampleRate *= 1200.0;
    fSampleRate += 6900.0;
    m_prSampleRate = (PRELS)fSampleRate;

    m_prCutoff = (PRELS)0x7FFF;
    m_vrQ = (VRELS)0;
    m_prVelScale = (PRELS)0;
    m_prCutoffSRAdjust = 0;
    m_iQIndex = 0;
}

void CSourceFilter::SetSampleRate(LONG lChange)
{
    // lChange ==  1 -> doubles -> add 1200 cents
    // lChange ==  2 -> quad    -> add 2400 cents
    // lChange == -1 -> halves  -> sub 1200 cents
    // lChange == -2 -> 1/4ths  -> sub 2400 cents
    //
    if (lChange > 0)
    {
        m_prSampleRate += (1200 << (lChange - 1));
    }
    else
    {
        m_prSampleRate -= (1200 << ((-lChange) - 1));
    }

    m_prCutoffSRAdjust = FILTER_FREQ_RANGE - m_prSampleRate + m_prCutoff;
}

void CSourceFilter::Verify()
{
    if ( m_prCutoff == 0x7FFF )
    {
        m_vrQ = 0;
        m_prVelScale = 0;
    }
    else
    {
        FORCEBOUNDS(m_prCutoff, 5535, 11921);
        FORCEBOUNDS(m_vrQ, 0, 225);
        FORCEBOUNDS(m_prVelScale, -12800, 12800);
    }
}

CSourceArticulation::CSourceArticulation()

{
//    m_sVelToVolScale = -9600;
    m_wUsageCount = 0;
    m_sDefaultPan = 0;
    m_dwSampleRate = 22050;
    m_PitchEG.m_sScale = 0; // pitch envelope defaults to off
}

void CSourceArticulation::Init(DWORD dwSampleRate)

{
    m_dwSampleRate = dwSampleRate;
    m_LFO.Init(dwSampleRate);       // Set to default values.
    m_PitchEG.Init();
    m_VolumeEG.Init();
    m_LFO2.Init(dwSampleRate);
    m_Filter.Init(dwSampleRate);
}

void CSourceArticulation::SetSampleRate(DWORD dwSampleRate)

{
    if (dwSampleRate != m_dwSampleRate)
    {
        long lChange;
        if (dwSampleRate > (m_dwSampleRate * 2))
        {
            lChange = 2;        // going from 11 to 44.
        }
        else if (dwSampleRate > m_dwSampleRate)
        {
            lChange = 1;        // must be doubling
        }
        else if ((dwSampleRate * 2) < m_dwSampleRate)
        {
            lChange = -2;       // going from 44 to 11
        }
        else
        {
            lChange = -1;       // that leaves halving.
        }
        m_dwSampleRate = dwSampleRate;
        m_LFO.SetSampleRate(lChange);
        m_PitchEG.SetSampleRate(lChange);
        m_VolumeEG.SetSampleRate(lChange);
        m_LFO2.SetSampleRate(lChange);
        m_Filter.SetSampleRate(lChange);
    }
}

void CSourceArticulation::Verify()

{
    m_LFO.Verify();
    m_PitchEG.Verify();
    m_VolumeEG.Verify();
    m_LFO2.Verify();
    m_Filter.Verify();
}

void CSourceArticulation::AddRef()

{
    m_wUsageCount++;
}

void CSourceArticulation::Release()

{
    m_wUsageCount--;
    if (m_wUsageCount == 0)
    {
        delete this;
    }
}

CSourceSample::CSourceSample()

{
    m_pWave = NULL;
    m_dwLoopStart = 0;
    m_dwLoopEnd = 1;
    m_dwLoopType = WLOOP_TYPE_FORWARD;
    m_dwSampleLength = 0;
    m_prFineTune = 0;
    m_dwSampleRate = 22050;
    m_bMIDIRootKey = 60;
    m_bOneShot = TRUE;
    m_bSampleType = 0;
}

CSourceSample::~CSourceSample()

{
    if (m_pWave != NULL)
    {
        m_pWave->Release();
    }
}

void CSourceSample::Verify()

{
    if (m_pWave != NULL)
    {
        FORCEBOUNDS(m_dwSampleLength,0,m_pWave->m_dwSampleLength);
        FORCEBOUNDS(m_dwLoopEnd,1,m_dwSampleLength);
        FORCEBOUNDS(m_dwLoopStart,0,m_dwLoopEnd);
        if ((m_dwLoopEnd - m_dwLoopStart) < 6)
        {
            m_bOneShot = TRUE;
        }
    }
    FORCEBOUNDS(m_dwSampleRate,3000,200000);
    FORCEBOUNDS(m_bMIDIRootKey,0,127);
    FORCEBOUNDS(m_prFineTune,-1200,1200);
}

BOOL CSourceSample::CopyFromWave()

{
    if (m_pWave == NULL)
    {
        return FALSE;
    }
    m_dwSampleLength = m_pWave->m_dwSampleLength;
    m_dwSampleRate = m_pWave->m_dwSampleRate;
    m_bSampleType = m_pWave->m_bSampleType;
    if (m_bOneShot)
    {
        m_dwSampleLength--;
        if (m_pWave->m_bSampleType & SFORMAT_16)
        {
            m_pWave->m_pnWave[m_dwSampleLength] = 0;
        }
        else
        {
            char *pBuffer = (char *) m_pWave->m_pnWave;
            pBuffer[m_dwSampleLength] = 0;
        }
    }
    else
    {
        if (m_dwLoopStart >= m_dwSampleLength)
        {
            m_dwLoopStart = 0;
        }
        if (m_pWave->m_bSampleType & SFORMAT_16)
        {
            m_pWave->m_pnWave[m_dwSampleLength-1] =
                m_pWave->m_pnWave[m_dwLoopStart];
        }
        else
        {
            char *pBuffer = (char *) m_pWave->m_pnWave;
            pBuffer[m_dwSampleLength-1] =
                pBuffer[m_dwLoopStart];
        }
    }
    Verify();
    return (TRUE);
}


CWave::CWave()
{
    m_hUserData = NULL;
    m_lpFreeHandle = NULL;
    m_pnWave = NULL;
    m_dwSampleRate = 22050;
    m_bSampleType = SFORMAT_16;
    m_dwSampleLength = 0;
    m_wUsageCount = 0;
    m_dwID = 0;
    m_wPlayCount = 0;
    m_bStream = FALSE;
    m_bActive = FALSE;
    m_bLastSampleInit = FALSE;
    m_bValid = FALSE;
}

CWave::~CWave()

{
    if (m_pnWave && m_lpFreeHandle)
    {
        m_lpFreeHandle((HANDLE) this,m_hUserData);
    }
}

void CWave::Verify()

{
    FORCEBOUNDS(m_dwSampleRate,3000,200000);
}

void CWave::PlayOn()

{
    m_wPlayCount++;
    AddRef();
}

void CWave::PlayOff()

{
    m_wPlayCount--;
    Release();
}

BOOL CWave::IsPlaying()

{
    return (m_wPlayCount);
}

void CWave::AddRef()

{
    m_wUsageCount++;
}

void CWave::Release()

{
    m_wUsageCount--;
    if (m_wUsageCount == 0)
    {
        delete this;
    }
}

CWaveArt::CWaveArt()
{
    m_wUsageCount = 1;
    m_dwID = 0;
    m_bSampleType = 0;
    m_bStream = FALSE;
    memset(&m_WaveArtDl,0,sizeof(DMUS_WAVEARTDL));
    memset(&m_WaveformatEx,0,sizeof(WAVEFORMATEX));
}

CWaveArt::~CWaveArt()
{
//>>>>>>>>>> clear list
    while(!m_pWaves.IsEmpty())
    {
        CWaveBuffer* pWaveBuffer = m_pWaves.RemoveHead();
        if(pWaveBuffer)
        {
            pWaveBuffer->m_pWave->Release();
            pWaveBuffer->m_pWave = NULL;
            delete pWaveBuffer;
        }
    }
}

void CWaveArt::AddRef()
{
    m_wUsageCount++;
}

void CWaveArt::Release()
{
    m_wUsageCount--;
    if (m_wUsageCount == 0)
    {
        delete this;
    }
}

void CWaveArt::Verify()
{
}

CSourceRegion::CSourceRegion()
{
    m_pArticulation = NULL;
    m_vrAttenuation = 0;
    m_prTuning = 0;
    m_bKeyHigh = 127;
    m_bKeyLow = 0;
    m_bGroup = 0;
    m_bAllowOverlap = FALSE;
    m_bVelocityHigh = 127;
    m_bVelocityLow  = 0;
    m_dwChannel = 0;
    m_sWaveLinkOptions = 0;
}

CSourceRegion::~CSourceRegion()
{
    if (m_pArticulation)
    {
        m_pArticulation->Release();
    }
}

void CSourceRegion::SetSampleRate(DWORD dwSampleRate)

{
    if (m_pArticulation != NULL)
    {
        m_pArticulation->SetSampleRate(dwSampleRate);
    }
}

void CSourceRegion::Verify()

{
    FORCEBOUNDS(m_bKeyHigh,0,127);
    FORCEBOUNDS(m_bKeyLow,0,127);
    FORCEBOUNDS(m_prTuning,-12000,12000);
    FORCEBOUNDS(m_vrAttenuation,-9600,0);
    m_Sample.Verify();
    if (m_pArticulation != NULL)
    {
        m_pArticulation->Verify();
    }
}

CInstrument::CInstrument()
{
    m_dwProgram = 0;
}

CInstrument::~CInstrument()
{
    while (!m_RegionList.IsEmpty())
    {
        CSourceRegion *pRegion = m_RegionList.RemoveHead();
        delete pRegion;
    }
}

void CInstrument::Verify()

{
    CSourceRegion *pRegion = m_RegionList.GetHead();
    CSourceArticulation *pArticulation = NULL;
    for (;pRegion != NULL;pRegion = pRegion->GetNext())
    {
        if (pRegion->m_pArticulation != NULL)
        {
            pArticulation = pRegion->m_pArticulation;
        }
        pRegion->Verify();
    }
    pRegion = m_RegionList.GetHead();
    for (;pRegion != NULL;pRegion = pRegion->GetNext())
    {
        if (pRegion->m_pArticulation == NULL  && pArticulation)
        {
            pRegion->m_pArticulation = pArticulation;
            pArticulation->AddRef();
        }
    }
}

void CInstrument::SetSampleRate(DWORD dwSampleRate)

{
    CSourceRegion *pRegion = m_RegionList.GetHead();
    for (;pRegion;pRegion = pRegion->GetNext())
    {
        pRegion->SetSampleRate(dwSampleRate);
    }
}

CSourceRegion * CInstrument::ScanForRegion(DWORD dwNoteValue, DWORD dwVelocity, CSourceRegion *pRegion)

{
    if ( pRegion == NULL )
        pRegion = m_RegionList.GetHead(); // Starting search
    else
        pRegion = pRegion->GetNext();     // Continuing search through the rest of the regions

    for (;pRegion;pRegion = pRegion->GetNext())
    {
        if (dwNoteValue >= pRegion->m_bKeyLow  &&
            dwNoteValue <= pRegion->m_bKeyHigh &&
            dwVelocity  >= pRegion->m_bVelocityLow &&
            dwVelocity  <= pRegion->m_bVelocityHigh )
        {
            break ;
        }
    }
    return pRegion;
}

void CInstManager::SetSampleRate(DWORD dwSampleRate)

{
    DWORD dwIndex;
    m_dwSampleRate = dwSampleRate;
    EnterCriticalSection(&m_CriticalSection);
    for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
    {
        CInstrument *pInstrument = m_InstrumentList[dwIndex].GetHead();
        for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
        {
            pInstrument->SetSampleRate(dwSampleRate);
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
}

CInstManager::CInstManager()

{
    m_dwSampleRate = 22050;
    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
    m_fCSInitialized = TRUE;
    m_dwSynthMemUse = 0;
}

CInstManager::~CInstManager()

{
    if (m_fCSInitialized)
    {
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
        {
            while (!m_InstrumentList[dwIndex].IsEmpty())
            {
                CInstrument *pInstrument = m_InstrumentList[dwIndex].RemoveHead();
                delete pInstrument;
            }
        }
        for (dwIndex = 0; dwIndex < WAVE_HASH_SIZE; dwIndex++)
        {
            while (!m_WavePool[dwIndex].IsEmpty())
            {
                CWave *pWave = m_WavePool[dwIndex].RemoveHead();
                pWave->Release();
            }
        }
        while (!m_FreeWavePool.IsEmpty())
        {
            CWave *pWave = m_FreeWavePool.RemoveHead();
            pWave->Release();
        }

        for(int nCount = 0; nCount < WAVEART_HASH_SIZE; nCount++)
        {
            while(!m_WaveArtList[nCount].IsEmpty())
            {
                CWaveArt* pWaveArt = m_WaveArtList[nCount].RemoveHead();
                if(pWaveArt)
                {
                    pWaveArt->Release();
                }
            }
        }

        DeleteCriticalSection(&m_CriticalSection);
    }
}

void CInstManager::Verify()

{
    DWORD dwIndex;
    EnterCriticalSection(&m_CriticalSection);
    for (dwIndex = 0;dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
    {
        CInstrument *pInstrument = m_InstrumentList[dwIndex].GetHead();
        for (;pInstrument != NULL;pInstrument = pInstrument->GetNext())
        {
            pInstrument->Verify();
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
}

CInstrument * CInstManager::GetInstrument(DWORD dwProgram, DWORD dwKey, DWORD dwVelocity)

{
    EnterCriticalSection(&m_CriticalSection);
    CInstrument *pInstrument = m_InstrumentList[dwProgram % INSTRUMENT_HASH_SIZE].GetHead();
    for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
    {
        if (pInstrument->m_dwProgram == dwProgram)
        {
            if (pInstrument->ScanForRegion(dwKey, dwVelocity, NULL) != NULL)
            {
                break;
            }
            else
            {
                Trace(2,"Warning: No region was found in instrument # %lx that matched note %ld\n",
                    dwProgram,dwKey);
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return (pInstrument);
}


DWORD TimeCents2Samples(long tcTime, DWORD dwSampleRate)
{
    if (tcTime ==  0x80000000) return (0);
    double flTemp = tcTime;
    flTemp /= (65536 * 1200);
    flTemp = pow(2.0,flTemp);
    flTemp *= dwSampleRate;
    return (DWORD) flTemp;
}

DWORD PitchCents2PitchFract(long pcRate,DWORD dwSampleRate)

{
    double fTemp = pcRate;
    fTemp /= 65536;
    fTemp -= 6900;
    fTemp /= 1200;
    fTemp = pow(2.0,fTemp);
    fTemp *= 7381975040.0; // (440*256*16*4096);
    fTemp /= dwSampleRate;
    return (DWORD) (fTemp);
}

HRESULT CSourceArticulation::Download(DMUS_DOWNLOADINFO * pInfo,
                                void * pvOffsetTable[],
                                DWORD dwIndex,
                                DWORD dwSampleRate,
                                BOOL fNewFormat)
{
    if (fNewFormat)
    {
        DMUS_ARTICULATION2 * pdmArtic =
            (DMUS_ARTICULATION2 *) pvOffsetTable[dwIndex];
        while (pdmArtic)
        {
            if (pdmArtic->ulArtIdx)
            {
                if (pdmArtic->ulArtIdx >= pInfo->dwNumOffsetTableEntries)
                {
                    Trace(1,"Error: Download failed because articulation chunk has an error.\n");
                    return DMUS_E_BADARTICULATION;
                }
                DWORD dwPosition;
                void *pData = pvOffsetTable[pdmArtic->ulArtIdx];
                CONNECTIONLIST * pConnectionList =
                    (CONNECTIONLIST *) pData;
                CONNECTION *pConnection;
                dwPosition = sizeof(CONNECTIONLIST);
                for (dwIndex = 0; dwIndex < pConnectionList->cConnections; dwIndex++)
                {
                    pConnection = (CONNECTION *) ((BYTE *)pData + dwPosition);
                    dwPosition += sizeof(CONNECTION);
                    switch (pConnection->usSource)
                    {
                    case CONN_SRC_NONE :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_LFO_FREQUENCY :
                            m_LFO.m_pfFrequency = PitchCents2PitchFract(
                                pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_LFO_STARTDELAY :
                            m_LFO.m_stDelay = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG1_ATTACKTIME :
                            m_VolumeEG.m_stAttack = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG1_DECAYTIME :
                            m_VolumeEG.m_stDecay = TimeCents2Samples(
                            (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG1_SUSTAINLEVEL :
                            m_VolumeEG.m_pcSustain =
                                (SPERCENT) ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG1_RELEASETIME :
                            m_VolumeEG.m_stRelease = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_ATTACKTIME :
                            m_PitchEG.m_stAttack = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_DECAYTIME :
                            m_PitchEG.m_stDecay = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_SUSTAINLEVEL :
                            m_PitchEG.m_pcSustain =
                                (SPERCENT) ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_RELEASETIME :
                            m_PitchEG.m_stRelease = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_PAN :
                            m_sDefaultPan = (short)
                                ((long) ((long) pConnection->lScale >> 12) / 125);
                            break;

                        /* DLS2 */
                        case CONN_DST_EG1_DELAYTIME:
                            m_VolumeEG.m_stDelay = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG1_HOLDTIME:
                            m_VolumeEG.m_stHold  = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_DELAYTIME:
                            m_PitchEG.m_stDelay  = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_HOLDTIME:
                            m_PitchEG.m_stHold   = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_VIB_FREQUENCY :
                            m_LFO2.m_pfFrequency = PitchCents2PitchFract(
                                pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_VIB_STARTDELAY :
                            m_LFO2.m_stDelay = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_FILTER_CUTOFF:
                            // First, get the filter cutoff frequency, which is relative to a440.
                            m_Filter.m_prCutoff = (PRELS)
                                (pConnection->lScale >> 16);
                            // Then, calculate the resulting prel, taking into consideration
                            // the sample rate and the base of the filter coefficient lookup
                            // table, relative to the sample rate (FILTER_FREQ_RANGE).
                            // This number can then be used directly look up the coefficients in the
                            // filter table.
                            m_Filter.m_prCutoffSRAdjust = (PRELS)
                                FILTER_FREQ_RANGE - m_Filter.m_prSampleRate + m_Filter.m_prCutoff;
                            break;
                        case CONN_DST_FILTER_Q:
                            m_Filter.m_vrQ = (VRELS)
                                (pConnection->lScale >> 16); //>>>>>>>> not really VRELS, but 1/10th's
                            m_Filter.m_iQIndex = (DWORD)
                                ((m_Filter.m_vrQ / 15.0f) + 0.5f);
                            break;
                        }
                        break;
                    case CONN_SRC_LFO :
                        switch (pConnection->usControl)
                        {
                        case CONN_SRC_NONE :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_ATTENUATION :
                                m_LFO.m_vrVolumeScale = (VRELS)
                                    ((long) ((pConnection->lScale * 10) >> 16));
                                break;
                            case CONN_DST_PITCH :
                                m_LFO.m_prPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;

                            /* DLS2 */
                            case CONN_DST_FILTER_CUTOFF:
                                m_LFO.m_prCutoffScale = (PRELS)
                                    (pConnection->lScale >> 16);
                                break;
                            }
                            break;
                        case CONN_SRC_CC1 :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_ATTENUATION :
                                m_LFO.m_vrMWVolumeScale = (VRELS)
                                    ((long) ((pConnection->lScale * 10) >> 16));
                                break;
                            case CONN_DST_PITCH :
                                m_LFO.m_prMWPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;

                            /* DLS2 */
                            case CONN_DST_FILTER_CUTOFF:
                                m_LFO.m_prMWCutoffScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;
                            }
                            break;

                        /* DLS2 */
                        case CONN_SRC_CHANNELPRESSURE :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_ATTENUATION :
                                m_LFO.m_vrCPVolumeScale = (VRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;
                            case CONN_DST_PITCH :
                                m_LFO.m_prCPPitchScale  = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;

                            /* DLS2 */
                            case CONN_DST_FILTER_CUTOFF:
                                m_LFO.m_prCPCutoffScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;
                            }
                            break;
                        }
                        break;
                    case CONN_SRC_KEYONVELOCITY :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_EG1_ATTACKTIME :
                            m_VolumeEG.m_trVelAttackScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_ATTACKTIME :
                            m_PitchEG.m_trVelAttackScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;

                        /* DLS2 */
                        case CONN_DST_FILTER_CUTOFF:
                            m_Filter.m_prVelScale = (PRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        }
                        break;
                    case CONN_SRC_KEYNUMBER :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_EG1_DECAYTIME :
                            m_VolumeEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_DECAYTIME :
                            m_PitchEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;

                        /* DLS2 */
                        case CONN_DST_EG1_HOLDTIME :
                            m_PitchEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_HOLDTIME :
                            m_PitchEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                        case CONN_DST_FILTER_CUTOFF :
                            m_Filter.m_prKeyScale = (PRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        }
                        break;
                    case CONN_SRC_EG2 :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_PITCH :
                            m_PitchEG.m_sScale = (short)
                                ((long) (pConnection->lScale >> 16));
                            break;

                        /* DLS2 */
                        case CONN_DST_FILTER_CUTOFF:
                            m_PitchEG.m_prCutoffScale = (PRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        }
                        break;

                    /* DLS2 */
                    case CONN_SRC_VIBRATO :
                        switch (pConnection->usControl)
                        {
                        case CONN_SRC_NONE :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_PITCH :
                                m_LFO2.m_prPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;
                            }
                            break;
                        case CONN_SRC_CC1 :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_PITCH :
                                m_LFO2.m_prMWPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;
                            }
                            break;
                        case CONN_SRC_CHANNELPRESSURE :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_PITCH :
                                m_LFO2.m_prCPPitchScale  = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;
                            }
                            break;
                        }
                        break;
                    }
                }
            }
            if (pdmArtic->ulNextArtIdx)
            {
                if (pdmArtic->ulNextArtIdx >= pInfo->dwNumOffsetTableEntries)
                {
                    Trace(1,"Error: Download failed because articulation chunk has an error.\n");
                    return DMUS_E_BADARTICULATION;
                }
                pdmArtic = (DMUS_ARTICULATION2 *) pvOffsetTable[pdmArtic->ulNextArtIdx];
            }
            else
            {
                pdmArtic = NULL;
            }
        }
    }
    else
    {
        DMUS_ARTICULATION * pdmArtic =
            (DMUS_ARTICULATION *) pvOffsetTable[dwIndex];

        if (pdmArtic->ulArt1Idx)
        {
            if (pdmArtic->ulArt1Idx >= pInfo->dwNumOffsetTableEntries)
            {
                Trace(1,"Error: Download failed because articulation chunk has an error.\n");
                return DMUS_E_BADARTICULATION;
            }
            DMUS_ARTICPARAMS * pdmArticParams =
                (DMUS_ARTICPARAMS *) pvOffsetTable[pdmArtic->ulArt1Idx];

            m_LFO.m_pfFrequency = PitchCents2PitchFract(
                pdmArticParams->LFO.pcFrequency,dwSampleRate);
            m_LFO.m_stDelay = TimeCents2Samples(
                (TCENT) pdmArticParams->LFO.tcDelay,dwSampleRate);
            m_LFO.m_vrVolumeScale = (VRELS)
                ((long) ((pdmArticParams->LFO.gcVolumeScale * 10) >> 16));
            m_LFO.m_prPitchScale = (PRELS)
                ((long) (pdmArticParams->LFO.pcPitchScale >> 16));
            m_LFO.m_vrMWVolumeScale = (VRELS)
                ((long) ((pdmArticParams->LFO.gcMWToVolume * 10) >> 16));
            m_LFO.m_prMWPitchScale = (PRELS)
                ((long) (pdmArticParams->LFO.pcMWToPitch >> 16));

            m_VolumeEG.m_stAttack = TimeCents2Samples(
                (TCENT) pdmArticParams->VolEG.tcAttack,dwSampleRate);
            m_VolumeEG.m_stDecay = TimeCents2Samples(
                (TCENT) pdmArticParams->VolEG.tcDecay,dwSampleRate);
            m_VolumeEG.m_pcSustain =
                (SPERCENT) ((long) (pdmArticParams->VolEG.ptSustain >> 16));
            m_VolumeEG.m_stRelease = TimeCents2Samples(
                (TCENT) pdmArticParams->VolEG.tcRelease,dwSampleRate);
            m_VolumeEG.m_trVelAttackScale = (TRELS)
                ((long) (pdmArticParams->VolEG.tcVel2Attack >> 16));
            m_VolumeEG.m_trKeyDecayScale = (TRELS)
                ((long) (pdmArticParams->VolEG.tcKey2Decay >> 16));

            m_PitchEG.m_trKeyDecayScale = (TRELS)
                ((long) (pdmArticParams->PitchEG.tcKey2Decay >> 16));
            m_PitchEG.m_sScale = (short)
                ((long) (pdmArticParams->PitchEG.pcRange >> 16));
            m_PitchEG.m_trVelAttackScale = (TRELS)
                ((long) (pdmArticParams->PitchEG.tcVel2Attack >> 16));
            m_PitchEG.m_stAttack = TimeCents2Samples(
                (TCENT) pdmArticParams->PitchEG.tcAttack,dwSampleRate);
            m_PitchEG.m_stDecay = TimeCents2Samples(
                (TCENT) pdmArticParams->PitchEG.tcDecay,dwSampleRate);
            m_PitchEG.m_pcSustain =
                (SPERCENT) ((long) (pdmArticParams->PitchEG.ptSustain >> 16));
            m_PitchEG.m_stRelease = TimeCents2Samples(
                (TCENT) pdmArticParams->PitchEG.tcRelease,dwSampleRate);

            m_sDefaultPan = (short)
                ((long) ((long) pdmArticParams->Misc.ptDefaultPan >> 12) / 125);
        }
    }
    Verify();   // Make sure all parameters are legal.

    return S_OK;
}

HRESULT CSourceRegion::Download(DMUS_DOWNLOADINFO * pInfo,
                                void * pvOffsetTable[],
                                DWORD *pdwRegionIX,
                                DWORD dwSampleRate,
                                BOOL fNewFormat)
{
    DMUS_REGION * pdmRegion = (DMUS_REGION *) pvOffsetTable[*pdwRegionIX];
    *pdwRegionIX = pdmRegion->ulNextRegionIdx;  // Clear to avoid loops.
    pdmRegion->ulNextRegionIdx = 0;
    // Read the Region chunk...
    m_bKeyHigh = (BYTE) pdmRegion->RangeKey.usHigh;
    m_bKeyLow  = (BYTE) pdmRegion->RangeKey.usLow;
    m_bVelocityHigh = (BYTE) pdmRegion->RangeVelocity.usHigh;
    m_bVelocityLow  = (BYTE) pdmRegion->RangeVelocity.usLow;

    //
    // Fix DLS Designer bug
    // Designer was putting velocity ranges that fail
    // on DLS2 synths
    //
    if ( m_bVelocityHigh == 0 && m_bVelocityLow == 0 )
        m_bVelocityHigh = 127;

    if (pdmRegion->fusOptions & F_RGN_OPTION_SELFNONEXCLUSIVE)
    {
        m_bAllowOverlap = TRUE;
    }
    else
    {
        m_bAllowOverlap = FALSE;
    }
    m_bGroup = (BYTE) pdmRegion->usKeyGroup;
    // Now, the WSMP and WLOOP chunks...
    m_vrAttenuation = (short) ((long) ((pdmRegion->WSMP.lAttenuation) * 10) >> 16);
    m_Sample.m_prFineTune = pdmRegion->WSMP.sFineTune;
    m_Sample.m_bMIDIRootKey = (BYTE) pdmRegion->WSMP.usUnityNote;
    if (pdmRegion->WSMP.cSampleLoops == 0)
    {
        m_Sample.m_bOneShot = TRUE;
    }
    else
    {
        m_Sample.m_dwLoopStart = pdmRegion->WLOOP[0].ulStart;
        m_Sample.m_dwLoopEnd = m_Sample.m_dwLoopStart + pdmRegion->WLOOP[0].ulLength;
        m_Sample.m_bOneShot = FALSE;
        m_Sample.m_dwLoopType = pdmRegion->WLOOP[0].ulType;
    }
    m_Sample.m_dwSampleRate = dwSampleRate;

    m_sWaveLinkOptions = pdmRegion->WaveLink.fusOptions;
    m_dwChannel = pdmRegion->WaveLink.ulChannel;

    if ( (m_dwChannel != WAVELINK_CHANNEL_LEFT) && !IsMultiChannel() )
    {
        Trace(1, "Download failed: Attempt to use a non-mono channel without setting the multichannel flag.\n");
        return DMUS_E_NOTMONO;
    }

    m_Sample.m_dwID = (DWORD) pdmRegion->WaveLink.ulTableIndex;

    // Does it have its own articulation?
    //
    if (pdmRegion->ulRegionArtIdx )
    {
        if (pdmRegion->ulRegionArtIdx >= pInfo->dwNumOffsetTableEntries)
        {
            Trace(1,"Error: Download failed because articulation chunk has an error.\n");
            return DMUS_E_BADARTICULATION;
        }

        CSourceArticulation *pArticulation = new CSourceArticulation;
        if (pArticulation)
        {
            pArticulation->Init(dwSampleRate);
            HRESULT hr = pArticulation->Download(pInfo, pvOffsetTable,
                    pdmRegion->ulRegionArtIdx, dwSampleRate, fNewFormat);

            if (FAILED(hr))
            {
                delete pArticulation;
                return hr;
            }
            m_pArticulation = pArticulation;
            m_pArticulation->AddRef();
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}



HRESULT CInstManager::DownloadInstrument(LPHANDLE phDownload,
                                         DMUS_DOWNLOADINFO *pInfo,
                                         void *pvOffsetTable[],
                                         void *pvData,
                                         BOOL fNewFormat)

{
    DMUS_INSTRUMENT *pdmInstrument = (DMUS_INSTRUMENT *) pvData;
    CInstrument *pInstrument = new CInstrument;
    if (pInstrument)
    {
        Trace(3,"Downloading instrument %lx\n",pdmInstrument->ulPatch);
        pInstrument->m_dwProgram = pdmInstrument->ulPatch;

        DWORD dwRegionIX = pdmInstrument->ulFirstRegionIdx;
        pdmInstrument->ulFirstRegionIdx = 0; // Clear to avoid loops.
        while (dwRegionIX)
        {
            if (dwRegionIX >= pInfo->dwNumOffsetTableEntries)
            {
                Trace(1,"Error: Download failed because instrument has error in region list.\n");
                delete pInstrument;
                return DMUS_E_BADINSTRUMENT;
            }
            CSourceRegion *pRegion = new CSourceRegion;
            if (!pRegion)
            {
                delete pInstrument;
                return E_OUTOFMEMORY;
            }
            pInstrument->m_RegionList.AddHead(pRegion);
            HRESULT hr = pRegion->Download(pInfo, pvOffsetTable, &dwRegionIX, m_dwSampleRate, fNewFormat);
            if (FAILED(hr))
            {
                delete pInstrument;
                return hr;
            }
            EnterCriticalSection(&m_CriticalSection);
            CWave *pWave = m_WavePool[pRegion->m_Sample.m_dwID % WAVE_HASH_SIZE].GetHead();
            for (;pWave;pWave = pWave->GetNext())
            {
                if (pRegion->m_Sample.m_dwID == pWave->m_dwID)
                {
                    pRegion->m_Sample.m_pWave = pWave;
                    pWave->AddRef();
                    pRegion->m_Sample.CopyFromWave();
                    break;
                }
            }
            LeaveCriticalSection(&m_CriticalSection);
        }
        if (pdmInstrument->ulGlobalArtIdx)
        {
            if (pdmInstrument->ulGlobalArtIdx >= pInfo->dwNumOffsetTableEntries)
            {
                Trace(1,"Error: Download failed because of out of range articulation chunk.\n");
                delete pInstrument;
                return DMUS_E_BADARTICULATION;
            }

            CSourceArticulation *pArticulation = new CSourceArticulation;
            if (pArticulation)
            {
                pArticulation->Init(m_dwSampleRate);
                HRESULT hr = pArticulation->Download(pInfo, pvOffsetTable,
                        pdmInstrument->ulGlobalArtIdx, m_dwSampleRate, fNewFormat);
                if (FAILED(hr))
                {
                    delete pInstrument;
                    delete pArticulation;
                    return hr;
                }
                for (CSourceRegion *pr = pInstrument->m_RegionList.GetHead();
                     pr != NULL;
                     pr = pr->GetNext())
                {
                    if (pr->m_pArticulation == NULL)
                    {
                        pr->m_pArticulation = pArticulation;
                        pArticulation->AddRef();
                    }
                }
                if (!pArticulation->m_wUsageCount)
                {
                    delete pArticulation;
                }
            }
            else
            {
                delete pInstrument;
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            for (CSourceRegion *pr = pInstrument->m_RegionList.GetHead();
                 pr != NULL;
                 pr = pr->GetNext())
            {
                if (pr->m_pArticulation == NULL)
                {
                    Trace(1,"Error: Download failed because region has no articulation.\n");
                    delete pInstrument;
                    return DMUS_E_NOARTICULATION;
                }
            }
        }
        EnterCriticalSection(&m_CriticalSection);
        if (pdmInstrument->ulFlags & DMUS_INSTRUMENT_GM_INSTRUMENT)
        {
            pInstrument->SetNext(NULL);
            m_InstrumentList[pInstrument->m_dwProgram % INSTRUMENT_HASH_SIZE].AddTail(pInstrument);
        }
        else
        {
            m_InstrumentList[pInstrument->m_dwProgram % INSTRUMENT_HASH_SIZE].AddHead(pInstrument);
        }
        LeaveCriticalSection(&m_CriticalSection);
        *phDownload = (HANDLE) pInstrument;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CInstManager::DownloadWave(LPHANDLE phDownload,
                                   DMUS_DOWNLOADINFO *pInfo,
                                   void *pvOffsetTable[],
                                   void *pvData)
{
    DMUS_WAVE *pdmWave = (DMUS_WAVE *) pvData;
    if (pdmWave->WaveformatEx.wFormatTag != WAVE_FORMAT_PCM)
    {
        Trace(1,"Error: Download failed because wave data is not PCM format.\n");
        return DMUS_E_NOTPCM;
    }

    if (pdmWave->WaveformatEx.nChannels != 1)
    {
        Trace(1,"Error: Download failed because wave data is not mono.\n");
        return DMUS_E_NOTMONO;
    }

    if (pdmWave->ulWaveDataIdx >= pInfo->dwNumOffsetTableEntries)
    {
        Trace(1,"Error: Download failed because wave data is at invalid location.\n");
        return DMUS_E_BADWAVE;
    }

    CWave *pWave = new CWave;
    if (pWave)
    {
        DMUS_WAVEDATA *pdmWaveData= (DMUS_WAVEDATA *)
            pvOffsetTable[pdmWave->ulWaveDataIdx];
        pWave->m_dwID = pInfo->dwDLId;
        pWave->m_hUserData = NULL;
        pWave->m_lpFreeHandle = NULL;
        pWave->m_dwSampleLength = pdmWaveData->cbSize;
        pWave->m_pnWave = (short *) &pdmWaveData->byData[0];
        pWave->m_dwSampleRate = pdmWave->WaveformatEx.nSamplesPerSec;

        if (pdmWave->WaveformatEx.wBitsPerSample == 8)
        {
            pWave->m_bSampleType = SFORMAT_8;
            DWORD dwX;
            char *pData = (char *) &pdmWaveData->byData[0];
            for (dwX = 0; dwX < pWave->m_dwSampleLength; dwX++)
            {
                pData[dwX] -= (char) 128;
            }
        }
        else if (pdmWave->WaveformatEx.wBitsPerSample == 16)
        {
            pWave->m_dwSampleLength >>= 1;
            pWave->m_bSampleType = SFORMAT_16;
        }
        else
        {
            Trace(1,"Error: Downloading wave %ld, bad wave format.\n",pInfo->dwDLId);
            delete pWave;
            return DMUS_E_BADWAVE;
        }
        pWave->m_dwSampleLength++;  // We always add one sample to the end for interpolation.
        EnterCriticalSection(&m_CriticalSection);
        m_WavePool[pWave->m_dwID % WAVE_HASH_SIZE].AddHead(pWave);
        LeaveCriticalSection(&m_CriticalSection);
        *phDownload = (HANDLE) pWave;
        pWave->AddRef();

        // Track memory usage
        m_dwSynthMemUse += (pWave->m_bSampleType == SFORMAT_16)?pWave->m_dwSampleLength << 1: pWave->m_dwSampleLength;
        Trace(3,"Downloading wave %ld memory usage %ld\n",pInfo->dwDLId,m_dwSynthMemUse);

        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CInstManager::Download(LPHANDLE phDownload,
                               void * pvData,
                               LPBOOL pbFree)


{
    V_INAME(IDirectMusicSynth::Download);
    V_BUFPTR_READ(pvData,sizeof(DMUS_DOWNLOADINFO));

    HRESULT hr = DMUS_E_UNKNOWNDOWNLOAD;
    void ** ppvOffsetTable;     // Array of pointers to chunks in data.
    DMUS_DOWNLOADINFO * pInfo = (DMUS_DOWNLOADINFO *) pvData;
    DMUS_OFFSETTABLE* pOffsetTable = (DMUS_OFFSETTABLE *)(((BYTE*)pvData) + sizeof(DMUS_DOWNLOADINFO));
    char *pcData = (char *) pvData;

    V_BUFPTR_READ(pvData,pInfo->cbSize);

    // Code fails if pInfo->dwNumOffsetTableEntries == 0
    // Sanity check here for debug
    assert(pInfo->dwNumOffsetTableEntries);

    ppvOffsetTable = new void *[pInfo->dwNumOffsetTableEntries];
    if (ppvOffsetTable) // Create the pointer array and validate.
    {
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < pInfo->dwNumOffsetTableEntries; dwIndex++)
        {
            if (pOffsetTable->ulOffsetTable[dwIndex] >= pInfo->cbSize)
            {
                delete[] ppvOffsetTable;
                Trace(1,"Error: Download failed because of corrupt download tables.\n");
                return DMUS_E_BADOFFSETTABLE;   // Bad!
            }
            ppvOffsetTable[dwIndex] = (void *) &pcData[pOffsetTable->ulOffsetTable[dwIndex]];
        }
        if (pInfo->dwDLType == DMUS_DOWNLOADINFO_INSTRUMENT) // Instrument.
        {
            *pbFree = TRUE;
            hr = DownloadInstrument(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0],FALSE);
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_INSTRUMENT2) // New instrument format.
        {
            *pbFree = TRUE;
            hr = DownloadInstrument(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0],TRUE);
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_WAVE) // Wave.
        {
            *pbFree = FALSE;
            hr = DownloadWave(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]);
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_WAVEARTICULATION) // Wave onshot & streaming
        {
            *pbFree = TRUE;
            hr = DownloadWaveArticulation(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]);
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_STREAMINGWAVE) // Streaming
        {
            *pbFree = FALSE;
            hr = DownloadWaveRaw(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]);
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_ONESHOTWAVE) // Wave onshot
        {
            *pbFree = FALSE;
            hr = DownloadWaveRaw(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]);
        }

        delete[] ppvOffsetTable;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CInstManager::Unload(HANDLE hDownload,
                             HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                             HANDLE hUserData)

{
    DWORD dwIndex;
    EnterCriticalSection(&m_CriticalSection);
    for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
    {
        CInstrument *pInstrument = m_InstrumentList[dwIndex].GetHead();
        for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
        {
            if (pInstrument == (CInstrument *) hDownload)
            {
                Trace(3,"Unloading instrument %lx\n",pInstrument->m_dwProgram);
                m_InstrumentList[dwIndex].Remove(pInstrument);
                delete pInstrument;
                LeaveCriticalSection(&m_CriticalSection);
                return S_OK;
            }
        }
    }
    for (dwIndex = 0; dwIndex < WAVE_HASH_SIZE; dwIndex++)
    {
        CWave *pWave = m_WavePool[dwIndex].GetHead();
        for (;pWave != NULL;pWave = pWave->GetNext())
        {
            if (pWave == (CWave *) hDownload)
            {
                // Track memory usage
                m_dwSynthMemUse -= (pWave->m_bSampleType == SFORMAT_16)?pWave->m_dwSampleLength << 1: pWave->m_dwSampleLength;

                Trace(3,"Unloading wave %ld memory usage %ld\n",pWave->m_dwID,m_dwSynthMemUse);
                m_WavePool[dwIndex].Remove(pWave);

                pWave->m_hUserData = hUserData;
                pWave->m_lpFreeHandle = lpFreeHandle;
                pWave->Release();
                LeaveCriticalSection(&m_CriticalSection);
                return S_OK;
            }
        }
    }
    for (dwIndex = 0; dwIndex < WAVE_HASH_SIZE; dwIndex++)
    {
        CWaveArt* pWaveArt = m_WaveArtList[dwIndex].GetHead();
        for (;pWaveArt != NULL;pWaveArt = pWaveArt->GetNext())
        {
            if (pWaveArt == (CWaveArt *) hDownload)
            {
                Trace(3,"Unloading wave articulation %ld\n",pWaveArt->m_dwID,m_dwSynthMemUse);
                m_WaveArtList[dwIndex].Remove(pWaveArt);

                pWaveArt->Release();
                LeaveCriticalSection(&m_CriticalSection);
                return S_OK;
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    Trace(1,"Error: Unload failed - downloaded object not found.\n");
    return E_FAIL;
}

//////////////////////////////////////////////////////////
// Directx8 Methods

CWave * CInstManager::GetWave(DWORD dwDLId)
{
    EnterCriticalSection(&m_CriticalSection);
    CWave *pWave = m_WavePool[dwDLId % WAVE_HASH_SIZE].GetHead();
    for (;pWave;pWave = pWave->GetNext())
    {
        if (dwDLId == pWave->m_dwID)
        {
            break;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);

    return pWave;
}

CWaveArt *  CInstManager::GetWaveArt(DWORD dwDLId)
{
    EnterCriticalSection(&m_CriticalSection);
    CWaveArt *pWaveArt = m_WaveArtList[dwDLId % WAVEART_HASH_SIZE].GetHead();
    for (;pWaveArt;pWaveArt = pWaveArt->GetNext())
    {
        if (dwDLId == pWaveArt->m_dwID)
        {
            break;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);

    return pWaveArt;
}

HRESULT CInstManager::DownloadWaveArticulation(LPHANDLE phDownload,
                                   DMUS_DOWNLOADINFO *pInfo,
                                   void *pvOffsetTable[],
                                   void *pvData)
{
    DMUS_WAVEARTDL* pWaveArtDl  = (DMUS_WAVEARTDL*)pvData;
    WAVEFORMATEX *pWaveformatEx = (WAVEFORMATEX *) pvOffsetTable[1];
    DWORD *dwDlId = (DWORD*)pvOffsetTable[2];
    DWORD i;

    CWaveArt* pWaveArt = new CWaveArt();
    if ( pWaveArt )
    {
        pWaveArt->m_dwID = pInfo->dwDLId;
        pWaveArt->m_WaveArtDl = *pWaveArtDl;;
        pWaveArt->m_WaveformatEx = *pWaveformatEx;
        if (pWaveformatEx->wBitsPerSample == 8)
        {
            pWaveArt->m_bSampleType = SFORMAT_8;
        }
        else if (pWaveformatEx->wBitsPerSample == 16)
        {
            pWaveArt->m_bSampleType = SFORMAT_16;
        }
        else
        {
            Trace(1,"Error: Download failed because wave data is %ld bits instead of 8 or 16.\n",(long) pWaveformatEx->wBitsPerSample);
            delete pWaveArt;
            return DMUS_E_BADWAVE;
        }

        for ( i = 0; i < pWaveArtDl->ulBuffers; i++ )
        {
            // Get wave buffer and fill header with waveformat data
            CWave *pWave = GetWave(dwDlId[i]);
            assert(pWave);

            if (!pWave)
            {
                delete pWaveArt;
                return E_POINTER;
            }

            pWave->m_dwSampleRate = pWaveformatEx->nSamplesPerSec;

            if (pWaveformatEx->wBitsPerSample == 8)
            {
                DWORD dwX;
                char *pData = (char *) pWave->m_pnWave;
                for (dwX = 0; dwX < pWave->m_dwSampleLength; dwX++)
                {
                    pData[dwX] -= (char) 128;
                }
                pWave->m_bSampleType = SFORMAT_8;
            }
            else if (pWaveformatEx->wBitsPerSample == 16)
            {
                pWave->m_dwSampleLength >>= 1;
                pWave->m_bSampleType = SFORMAT_16;
            }
            else
            {
                Trace(1,"Error: Download failed because wave data is %ld bits instead of 8 or 16.\n",(long) pWaveformatEx->wBitsPerSample);
                delete pWaveArt;
                return DMUS_E_BADWAVE;
            }
            pWave->m_dwSampleLength++;  // We always add one sample to the end for interpolation.

            // Default is to duplicate last sample. This will be overrwritten for
            // streaming waves.
            //
            if (pWave->m_dwSampleLength > 1)
            {
                if (pWave->m_bSampleType == SFORMAT_8)
                {
                    char* pb = (char*)pWave->m_pnWave;
                    pb[pWave->m_dwSampleLength - 1] = pb[pWave->m_dwSampleLength - 2];
                }
                else
                {
                    short *pn = pWave->m_pnWave;
                    pn[pWave->m_dwSampleLength - 1] = pn[pWave->m_dwSampleLength - 2];
                }
            }

            // Create a WaveBuffer listitem and save the wave in and add it to the circular buffer list
            CWaveBuffer* pWavBuf = new CWaveBuffer();
            if ( pWavBuf == NULL )
            {
                delete pWaveArt;
                return E_OUTOFMEMORY;
            }
            pWavBuf->m_pWave = pWave;

            // This Articulation will be handling streaming data
            if ( pWave->m_bStream )
                pWaveArt->m_bStream = TRUE;

            pWaveArt->m_pWaves.AddTail(pWavBuf);
        }

        EnterCriticalSection(&m_CriticalSection);
        if (pWaveArt)
        {
            CWaveBuffer* pCurrentBuffer = pWaveArt->m_pWaves.GetHead();
            for (; pCurrentBuffer; pCurrentBuffer = pCurrentBuffer->GetNext() )
            {
                if (pCurrentBuffer->m_pWave)
                {
                    pCurrentBuffer->m_pWave->AddRef();
                }
            }
        }
        m_WaveArtList[pWaveArt->m_dwID % WAVEART_HASH_SIZE].AddHead(pWaveArt);
        LeaveCriticalSection(&m_CriticalSection);

        *phDownload = (HANDLE) pWaveArt;

        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CInstManager::DownloadWaveRaw(LPHANDLE phDownload,
                                   DMUS_DOWNLOADINFO *pInfo,
                                   void *pvOffsetTable[],
                                   void *pvData)
{
    CWave *pWave = new CWave;
    if (pWave)
    {
        DMUS_WAVEDATA *pdmWaveData= (DMUS_WAVEDATA *)pvData;
        Trace(3,"Downloading raw wave data%ld\n",pInfo->dwDLId);

        pWave->m_dwID = pInfo->dwDLId;
        pWave->m_hUserData = NULL;
        pWave->m_lpFreeHandle = NULL;
        pWave->m_dwSampleLength = pdmWaveData->cbSize;
        pWave->m_pnWave = (short *) &pdmWaveData->byData[0];

        if ( pInfo->dwDLType == DMUS_DOWNLOADINFO_STREAMINGWAVE )
        {
            pWave->m_bStream = TRUE;
            pWave->m_bValid = TRUE;
        }

        EnterCriticalSection(&m_CriticalSection);
        m_WavePool[pWave->m_dwID % WAVE_HASH_SIZE].AddHead(pWave);
        LeaveCriticalSection(&m_CriticalSection);

        *phDownload = (HANDLE) pWave;
        pWave->AddRef();

        m_dwSynthMemUse += pWave->m_dwSampleLength;

        return S_OK;
    }
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\kernhelp.h ===
// Copyright (c) 1998 Microsoft Corporation
//
//
//
#ifndef _KernHelp_
#define _KernHelp_

// Use kernel mutex to implement critical section
//
typedef KMUTEX CRITICAL_SECTION;
typedef CRITICAL_SECTION *LPCRITICAL_SECTION;

VOID InitializeCriticalSection(
    LPCRITICAL_SECTION);

VOID EnterCriticalSection(
    LPCRITICAL_SECTION);

VOID LeaveCriticalSection(
    LPCRITICAL_SECTION);

VOID DeleteCriticalSection(
    LPCRITICAL_SECTION);

// We have very little registry work to do, so just encapsulate the
// entire process
//
int GetRegValueDword(
    LPTSTR RegPath,
    LPTSTR ValueName,
    PULONG Value);

ULONG GetTheCurrentTime();


#ifndef _NEW_DELETE_OPERATORS_
#define _NEW_DELETE_OPERATORS_

inline void* __cdecl operator new
(
    unsigned int    iSize
)
{
    PVOID result = ExAllocatePoolWithTag(NonPagedPool, iSize, 'suMD');
    if (result)
    {
        RtlZeroMemory(result, iSize);
    }

    return result;
}

/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    unsigned int    iSize,
    POOL_TYPE       poolType
)
{
    PVOID result = ExAllocatePoolWithTag(poolType, iSize, 'suMD');
    if (result)
    {
        RtlZeroMemory(result, iSize);
    }

    return result;
}

/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    unsigned int    iSize,
    POOL_TYPE       poolType,
    ULONG           tag
)
{
    PVOID result = ExAllocatePoolWithTag(poolType, iSize, tag);

    if (result)
    {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

/*****************************************************************************
 * ::delete()
 *****************************************************************************
 * Delete function.
 */
inline void __cdecl operator delete
(
    PVOID pVoid
)
{
    ExFreePool(pVoid);
}


#endif //!_NEW_DELETE_OPERATORS_

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Debug trace facility
//
#ifdef DBG
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
#define Trace DebugTrace
#else
#define Trace
#endif

// Paramter validation unused
//
#define V_INAME(x)
#define V_BUFPTR_READ(p,cb)


#endif // _KernHelp_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\misc.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
// Misc.h
//
// functions used in multiple DLL's

#ifndef __MISC_H__
#define __MISC_H__

//LPVOID MemGlobalAllocPtr(UINT uFlags,DWORD dwBytes);
//BOOL MemGlobalFreePtr(LPVOID p);

// memory functions
//HRESULT MemStart();
//void MemEnd();

/*#ifdef _DEBUGMEM
#ifndef new
void* operator new( size_t cb, LPCTSTR pszFileName, WORD wLine );
#define new new( __FILE__, (WORD)__LINE__ )
#endif
#endif*/

#ifdef DBG
#define RELEASE( obj ) ( (obj)->Release(), *((char**)&(obj)) = (char*)0x0bad0bad )
#else
#define RELEASE( obj ) (obj)->Release()
#endif

BOOL GetRegValueDword(
    LPCTSTR szRegPath,
    LPCTSTR szValueName,
    LPDWORD pdwValue);

ULONG GetTheCurrentTime();

#endif // __MISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\fparms.h ===
// Filter coefficients in 2.30 fixed point
//

// b1 min -1.998977207 max -0.166675302 range  0.083380291
//
// NOTE: b1 is stored as a positive value, and these coefcients are 
//       the negation of b1, which when originally calculated is a 
//       negative number.  Compensation for this is made in the 
//       filter calculation by changing a subtraction to and add.
//
COEFF CVoiceFilter::m_aB1[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC] =
{
    { 0x7ebb466f, 0x7ebb466f, 0x7ebb466f, 0x7ebb466f, 0x7ea7f78f, 0x7e9382d1, 0x7e7dd6bd, 0x7e66e0d2, 0x7e4e8d7b, 0x7e34c7ef, 0x7e197a33, 0x7dfc8cf8, 0x7ddde792, 0x7dbd6fdd, 0x7d9b0a28, 0x7d76991c, 0x7d4ffdad, 0x7d2716f0, 0x7cfbc20e, 0x7ccdda1e, 0x7c9d380b, 0x7c69b277, 0x7c331d86, 0x7bf94ada, 0x7bbc094e, 0x7b7b24e1, 0x7b366687, 0x7aed93fd, 0x7aa06f93, 0x7a4eb80d, 0x79f82860, 0x799c7781, 0x793b5834, 0x78d478ce, 0x786782f6, 0x77f41b69, 0x7779e1be, 0x76f8701a, 0x766f5af7, 0x75de30d9, 0x75447a04, 0x74a1b83e, 0x73f5667e, 0x733ef8b2, 0x727ddb68, 0x71b17398, 0x70d91e64, 0x6ff430d6, 0x6f01f7a6, 0x6e01b71c, 0x6cf2aadd, 0x6bd405d3, 0x6aa4f217, 0x696490f9, 0x6811fafc, 0x66ac4000, 0x65326754, 0x63a36ffd, 0x61fe50cb, 0x6041f8ab, 0x5e6d4eb5, 0x5c7f3229, 0x5a767a36, 0x5851f538, 0x5610676b, 0x53b08886, 0x5131001c, 0x4e905faf, 0x4bcd1a02, 0x48e5763a, 0x45d77cf6, 0x42a0dcf4, 0x3f3ec32e, 0x3bada059, 0x37e8d1eb, 0x33ea1e16, 0x2fa8e4d8, 0x2b18cea1, 0x262787a8, 0x20b88fa1, 0x1a9cba80, 0x137e89ae, 0x0aaacee2, 0x0aaacee2, 0x0aaacee2, 0x0aaacee2, 0x0aaacee2, 0x0aaacee2, 0x0aaacee2 },
    { 0x7f3a8183, 0x7f3a8183, 0x7f2ead4b, 0x7f222259, 0x7f14d583, 0x7f06bae2, 0x7ef7c5d3, 0x7ee7e8ea, 0x7ed715da, 0x7ec53d71, 0x7eb24f85, 0x7e9e3ae1, 0x7e88ed39, 0x7e72530b, 0x7e5a579e, 0x7e40e4d6, 0x7e25e328, 0x7e093982, 0x7deacd2c, 0x7dca81a3, 0x7da8388e, 0x7d83d181, 0x7d5d29ef, 0x7d341cf8, 0x7d088340, 0x7cda32c0, 0x7ca8fe95, 0x7c74b6d6, 0x7c3d284a, 0x7c021c39, 0x7bc35824, 0x7b809d86, 0x7b39a97d, 0x7aee348f, 0x7a9df23f, 0x7a4890c5, 0x79edb8a4, 0x798d0c45, 0x7926278e, 0x78b89f77, 0x78440187, 0x77c7d362, 0x7743924f, 0x76b6b2a7, 0x76209f5b, 0x7580b96c, 0x74d65768, 0x7420c4e2, 0x735f420b, 0x7291032c, 0x71b53057, 0x70cae514, 0x6fd13038, 0x6ec713cd, 0x6dab8536, 0x6c7d6d73, 0x6b3ba9b9, 0x69e50c2b, 0x68785d07, 0x66f45c16, 0x6557c263, 0x63a14479, 0x61cf94cf, 0x5fe16688, 0x5dd57057, 0x5baa6f6a, 0x595f29ec, 0x56f270e8, 0x546320cc, 0x51b01fee, 0x4ed859b9, 0x4bdab532, 0x48b6048b, 0x4568ea9d, 0x41f1b1a9, 0x3e4e0bdb, 0x3a7ab142, 0x3672c53e, 0x322ed973, 0x2da33782, 0x28bcab08, 0x2359c59e, 0x1d3a3b6e, 0x15c8f78f, 0x0ad59d8d, 0x0ad59d8d, 0x0ad59d8d, 0x0ad59d8d, 0x0ad59d8d },
    { 0x7f6169cb, 0x7f6169cb, 0x7f57defe, 0x7f4dbf73, 0x7f4301e7, 0x7f379c78, 0x7f2b84a6, 0x7f1eaf3a, 0x7f111048, 0x7f029b14, 0x7ef3420b, 0x7ee2f6b4, 0x7ed1a99a, 0x7ebf4a40, 0x7eabc708, 0x7e970d26, 0x7e81087b, 0x7e69a38d, 0x7e50c75f, 0x7e365b5d, 0x7e1a4537, 0x7dfc68c2, 0x7ddca7d3, 0x7dbae216, 0x7d96f4e2, 0x7d70bb13, 0x7d480cca, 0x7d1cbf41, 0x7ceea488, 0x7cbd8b51, 0x7c893e9b, 0x7c518573, 0x7c1622a4, 0x7bd6d458, 0x7b9353c0, 0x7b4b54ae, 0x7afe8530, 0x7aac8d10, 0x7a550d69, 0x79f7a015, 0x7993d737, 0x79293c91, 0x78b75107, 0x783d8beb, 0x77bb5a68, 0x77301ed6, 0x769b3017, 0x75fbd8eb, 0x75515756, 0x749adc08, 0x73d789d5, 0x7306753c, 0x7226a41d, 0x71370d81, 0x703699a8, 0x6f242241, 0x6dfe72fd, 0x6cc44a73, 0x6b745b74, 0x6a0d4ed7, 0x688dc5cd, 0x66f45cc7, 0x653faef9, 0x636e5a7e, 0x617f04ff, 0x5f7060dd, 0x5d41329c, 0x5af0564c, 0x587cc486, 0x55e59655, 0x532a075b, 0x50497505, 0x4d43595c, 0x4a173fa1, 0x46c4b010, 0x434b0ef8, 0x3fa969d4, 0x3bde2949, 0x37e698f1, 0x33be287e, 0x2f5d2dc3, 0x2ab6aaf1, 0x25b3e5f6, 0x202a5a83, 0x19bf4b09, 0x11701842, 0x11701842, 0x11701842, 0x11701842 },
    { 0x7f7da104, 0x7f7da104, 0x7f75bfb5, 0x7f6d6274, 0x7f648169, 0x7f5b1431, 0x7f5111dd, 0x7f4670e0, 0x7f3b2709, 0x7f2f2971, 0x7f226c75, 0x7f14e3a0, 0x7f0681a3, 0x7ef7383b, 0x7ee6f825, 0x7ed5b10b, 0x7ec35165, 0x7eafc66c, 0x7e9afbfb, 0x7e84dc73, 0x7e6d509c, 0x7e543f86, 0x7e398e64, 0x7e1d2062, 0x7dfed67c, 0x7dde8f51, 0x7dbc26f0, 0x7d97769b, 0x7d705491, 0x7d4693c9, 0x7d1a03b1, 0x7cea6fd5, 0x7cb79f94, 0x7c8155c7, 0x7c475050, 0x7c0947c7, 0x7bc6eeee, 0x7b7ff248, 0x7b33f78a, 0x7ae29d14, 0x7a8b7954, 0x7a2e1a2a, 0x79ca0439, 0x795eb23c, 0x78eb944a, 0x78700f15, 0x77eb7b2c, 0x775d2433, 0x76c4482b, 0x762016ab, 0x756fb043, 0x74b225dc, 0x73e6783b, 0x730b97bd, 0x7220642c, 0x7123acf0, 0x7014317d, 0x6ef0a248, 0x6db7a20d, 0x6c67c7cb, 0x6affa156, 0x697db69c, 0x67e08dc2, 0x6626b01a, 0x644eafdb, 0x62572ece, 0x603ee57b, 0x5e04aafe, 0x5ba77ce1, 0x592686c3, 0x568128db, 0x53b6fcd2, 0x50c7d78f, 0x4db3c6ce, 0x4a7b0894, 0x471dfa79, 0x439cfdbf, 0x3ff84c11, 0x3c2fb6b7, 0x384245be, 0x342da44a, 0x2fed3590, 0x2b7884e6, 0x26c05ba8, 0x21a898a4, 0x1bf8a7e1, 0x15274a9e, 0x15274a9e, 0x15274a9e },
    { 0x7f93a2b0, 0x7f93a2b0, 0x7f8d0dc6, 0x7f86105c, 0x7f7ea3b7, 0x7f76c0a3, 0x7f6e5f6d, 0x7f6577d8, 0x7f5c0115, 0x7f51f1b0, 0x7f473f91, 0x7f3bdfde, 0x7f2fc6fa, 0x7f22e86c, 0x7f1536d3, 0x7f06a3cf, 0x7ef71feb, 0x7ee69a8e, 0x7ed501db, 0x7ec24294, 0x7eae4802, 0x7e98fbd4, 0x7e8245f5, 0x7e6a0c6d, 0x7e503333, 0x7e349bff, 0x7e172613, 0x7df7ae0a, 0x7dd60d9a, 0x7db21b4e, 0x7d8baa41, 0x7d6289c9, 0x7d36852d, 0x7d07633c, 0x7cd4e5eb, 0x7c9ec9e7, 0x7c64c61b, 0x7c268b32, 0x7be3c306, 0x7b9c100f, 0x7b4f0cbd, 0x7afc4ad1, 0x7aa3529d, 0x7a43a250, 0x79dcad21, 0x796dda81, 0x78f68542, 0x7875fabd, 0x77eb79f0, 0x775632b1, 0x76b544d9, 0x7607bf96, 0x754ca0c0, 0x7482d46f, 0x73a934b9, 0x72be89b5, 0x71c189d9, 0x70b0dac8, 0x6f8b129d, 0x6e4eb9e0, 0x6cfa4e2d, 0x6b8c45af, 0x6a03138e, 0x685d2d5a, 0x6699117f, 0x64b54ed3, 0x62b08d14, 0x60899651, 0x5e3f60c6, 0x5bd1190b, 0x593e2bbe, 0x56864e2b, 0x53a984c3, 0x50a82680, 0x4d82db94, 0x4a3a9616, 0x46d0828f, 0x4345ee35, 0x3f9c1fed, 0x3bd41fa2, 0x37ee6513, 0x33ea61f2, 0x2fc5cfda, 0x2b7b9215, 0x2701bf1f, 0x2245c3dc, 0x1d23897b, 0x174c1540, 0x174c1540 },
    { 0x7faa8d3c, 0x7fa55772, 0x7f9fce51, 0x7f99ec65, 0x7f93abdb, 0x7f8d0674, 0x7f85f581, 0x7f7e71d5, 0x7f7673bf, 0x7f6df2ff, 0x7f64e6b8, 0x7f5b4566, 0x7f5104cc, 0x7f4619ea, 0x7f3a78e7, 0x7f2e1502, 0x7f20e07c, 0x7f12cc82, 0x7f03c91b, 0x7ef3c4fe, 0x7ee2ad8a, 0x7ed06e97, 0x7ebcf254, 0x7ea8212a, 0x7e91e189, 0x7e7a17c1, 0x7e60a5c5, 0x7e456b02, 0x7e284416, 0x7e090a91, 0x7de794b2, 0x7dc3b50c, 0x7d9d3a3b, 0x7d73ee7a, 0x7d47973f, 0x7d17f4cc, 0x7ce4c1b2, 0x7cadb243, 0x7c727412, 0x7c32ad42, 0x7bedfbf0, 0x7ba3f56f, 0x7b542590, 0x7afe0dcf, 0x7aa12484, 0x7a3cd3f0, 0x79d07969, 0x795b6453, 0x78dcd541, 0x7853fcf4, 0x77bffb84, 0x771fdf7d, 0x7672a526, 0x75b735ec, 0x74ec67fd, 0x7410fe2d, 0x7323a82d, 0x72230340, 0x710d9b70, 0x6fe1ed6b, 0x6e9e6932, 0x6d41759b, 0x6bc974f2, 0x6a34ca99, 0x6881e1fa, 0x66af36a9, 0x64bb5dbb, 0x62a51048, 0x606b36c1, 0x5e0cf4df, 0x5b89b59a, 0x58e13672, 0x56139154, 0x532143db, 0x500b32ed, 0x4cd2a936, 0x49794f3a, 0x46011b47, 0x426c37aa, 0x3ebcdd2c, 0x3af51eff, 0x3716a3e0, 0x332244c6, 0x2f17828a, 0x2af3b49f, 0x26b0b02c, 0x22424d7d, 0x1d912d1f, 0x1d912d1f },
    { 0x7fb839e1, 0x7fb3d32f, 0x7faf2553, 0x7faa2b92, 0x7fa4e0d5, 0x7f9f3fa8, 0x7f994231, 0x7f92e226, 0x7f8c18c4, 0x7f84dec5, 0x7f7d2c55, 0x7f74f907, 0x7f6c3bc7, 0x7f62eac8, 0x7f58fb7a, 0x7f4e6274, 0x7f431362, 0x7f3700ef, 0x7f2a1cb0, 0x7f1c5708, 0x7f0d9f0b, 0x7efde261, 0x7eed0d25, 0x7edb09bb, 0x7ec7c0ab, 0x7eb31872, 0x7e9cf54d, 0x7e853907, 0x7e6bc2b9, 0x7e506e89, 0x7e33155f, 0x7e138c98, 0x7df1a5a8, 0x7dcd2dc2, 0x7da5ed67, 0x7d7ba7f5, 0x7d4e1b29, 0x7d1cfe97, 0x7ce80313, 0x7caed210, 0x7c710cf1, 0x7c2e4c4f, 0x7be61f2d, 0x7b980a23, 0x7b43867c, 0x7ae80144, 0x7a84da4d, 0x7a196334, 0x79a4de57, 0x79267dd1, 0x789d6277, 0x78089aef, 0x776722ce, 0x76b7e1e5, 0x75f9abbf, 0x752b3f60, 0x744b4761, 0x73585a7e, 0x7250fcab, 0x7133a0e7, 0x6ffeabc6, 0x6eb07703, 0x6d47561a, 0x6bc19c21, 0x6a1da2ec, 0x6859d390, 0x6674b054, 0x646cdff2, 0x624139f9, 0x5ff0d403, 0x5d7b0f50, 0x5adfa61e, 0x581eb7d9, 0x5538d35c, 0x522efddc, 0x4f02b579, 0x4bb5ee15, 0x484b073e, 0x44c4b9d3, 0x4125fc8a, 0x3d71ddef, 0x39ab5281, 0x35d4f4a1, 0x31f0b1e2, 0x2dff5ccf, 0x2a001103, 0x25ef4246, 0x21c51d73, 0x1d725a1a },
    { 0x7fc3854a, 0x7fbfc9c8, 0x7fbbd133, 0x7fb79765, 0x7fb317e7, 0x7fae4def, 0x7fa93451, 0x7fa3c580, 0x7f9dfb7f, 0x7f97cfdb, 0x7f913b9c, 0x7f8a373d, 0x7f82baa1, 0x7f7abcfe, 0x7f7234d6, 0x7f6917e0, 0x7f5f5af8, 0x7f54f208, 0x7f49cff6, 0x7f3de686, 0x7f312643, 0x7f237e5a, 0x7f14dc81, 0x7f052ccd, 0x7ef45987, 0x7ee24b06, 0x7ecee775, 0x7eba12a8, 0x7ea3adcf, 0x7e8b9747, 0x7e71aa3e, 0x7e55be73, 0x7e37a7d3, 0x7e173619, 0x7df4346a, 0x7dce68d6, 0x7da593e2, 0x7d796ff6, 0x7d49b0c7, 0x7d1602b4, 0x7cde0a0e, 0x7ca1625a, 0x7c5f9d83, 0x7c1842f7, 0x7bcacebd, 0x7b76b07e, 0x7b1b4a7b, 0x7ab7f07f, 0x7a4be6cb, 0x79d660fb, 0x795680f7, 0x78cb55e3, 0x7833db38, 0x778ef7e3, 0x76db7daf, 0x761828e6, 0x7543a043, 0x745c7567, 0x736125d1, 0x72501c86, 0x7127b496, 0x6fe63c91, 0x6e89fb28, 0x6d1134ff, 0x6b7a340d, 0x69c35048, 0x67eafa01, 0x65efc5a4, 0x63d078d9, 0x618c18b3, 0x5f21f87c, 0x5c91c885, 0x59dba433, 0x57001e59, 0x54004a9f, 0x50ddc30c, 0x4d9aa823, 0x4a399ab2, 0x46bdae2e, 0x432a52e1, 0x3f83375e, 0x3bcc20ef, 0x3808ba85, 0x343c5962, 0x3069b54f, 0x2c928f48, 0x28b73b99, 0x24d5f78a, 0x20e9d5ff },
    { 0x7fcce827, 0x7fc9bb01, 0x7fc65930, 0x7fc2bf08, 0x7fbee89a, 0x7fbad1a7, 0x7fb67598, 0x7fb1cf7d, 0x7facda00, 0x7fa78f5b, 0x7fa1e950, 0x7f9be11e, 0x7f956f75, 0x7f8e8c66, 0x7f872f58, 0x7f7f4ef4, 0x7f76e114, 0x7f6ddab2, 0x7f642fce, 0x7f59d356, 0x7f4eb70e, 0x7f42cb6f, 0x7f35ff8b, 0x7f2840e0, 0x7f197b38, 0x7f09987b, 0x7ef8807b, 0x7ee618be, 0x7ed24446, 0x7ebce34c, 0x7ea5d2f6, 0x7e8ced09, 0x7e720791, 0x7e54f47b, 0x7e35812f, 0x7e137615, 0x7dee961a, 0x7dc69e1e, 0x7d9b445c, 0x7d6c37bf, 0x7d391f32, 0x7d0198d1, 0x7cc5391e, 0x7c838a17, 0x7c3c0a41, 0x7bee2bac, 0x7b9952dc, 0x7b3cd5b2, 0x7ad7fa4a, 0x7a69f5cf, 0x79f1eb58, 0x796eead1, 0x78dfefe8, 0x7843e126, 0x77998f3a, 0x76dfb477, 0x7614f4ac, 0x7537dd80, 0x7446e739, 0x7340765c, 0x7222de0a, 0x70ec635f, 0x6f9b4209, 0x6e2db21d, 0x6ca1ef73, 0x6af6428f, 0x69290b1f, 0x6738cc30, 0x652439c6, 0x62ea47c0, 0x608a398b, 0x5e03b219, 0x5b56c349, 0x5883fbda, 0x558c72cf, 0x5271cf04, 0x4f3649d9, 0x4bdcabb6, 0x4868417d, 0x44dcca5a, 0x413e5d7f, 0x3d914802, 0x39d9e335, 0x361c63f7, 0x325ca340, 0x2e9ddf39, 0x2ae27242, 0x272b7951, 0x23785afd },
    { 0x7fd4bcff, 0x7fd206b2, 0x7fcf22be, 0x7fcc0de3, 0x7fc8c49f, 0x7fc54329, 0x7fc18569, 0x7fbd86f1, 0x7fb942f5, 0x7fb4b443, 0x7fafd53a, 0x7faa9fbb, 0x7fa50d24, 0x7f9f163e, 0x7f98b330, 0x7f91db6e, 0x7f8a85ab, 0x7f82a7c3, 0x7f7a36a4, 0x7f71263a, 0x7f676950, 0x7f5cf179, 0x7f51aee8, 0x7f459054, 0x7f3882cb, 0x7f2a7187, 0x7f1b45c0, 0x7f0ae674, 0x7ef9382b, 0x7ee61cb8, 0x7ed172ed, 0x7ebb164d, 0x7ea2deb1, 0x7e889fec, 0x7e6c2957, 0x7e4d4560, 0x7e2bb908, 0x7e074354, 0x7ddf9cae, 0x7db4763e, 0x7d857932, 0x7d5245f2, 0x7d1a7349, 0x7cdd8d7a, 0x7c9b1549, 0x7c527ef1, 0x7c033109, 0x7bac835e, 0x7b4dbdd2, 0x7ae61711, 0x7a74b372, 0x79f8a3bd, 0x7970e411, 0x78dc5ae9, 0x7839d842, 0x77881509, 0x76c5b2dd, 0x75f13c3f, 0x7509254d, 0x740bcd34, 0x72f78079, 0x71ca7c44, 0x7082f2db, 0x6f1f1176, 0x6d9d0790, 0x6bfb0fed, 0x6a377b3a, 0x6850bc7d, 0x6645770b, 0x64148df9, 0x61bd3478, 0x5f3efe9a, 0x5c99f1e0, 0x59ce9460, 0x56ddf9a4, 0x53c9cbef, 0x509450bf, 0x4d406758, 0x49d1807a, 0x464b8e94, 0x42b2ee35, 0x3f0c4716, 0x3b5c6658, 0x37a81308, 0x33f3de13, 0x3043eec5, 0x2c9bcbe4, 0x28fe206f, 0x256c77e6 },
    { 0x7fdb4a34, 0x7fd8f760, 0x7fd67cc5, 0x7fd3d77e, 0x7fd10466, 0x7fce0016, 0x7fcac6df, 0x7fc754c3, 0x7fc3a569, 0x7fbfb41c, 0x7fbb7bbd, 0x7fb6f6b7, 0x7fb21efb, 0x7facedea, 0x7fa75c4f, 0x7fa1624b, 0x7f9af745, 0x7f9411d8, 0x7f8ca7bd, 0x7f84adb3, 0x7f7c1767, 0x7f72d756, 0x7f68deae, 0x7f5e1d2a, 0x7f5280ea, 0x7f45f64b, 0x7f3867b3, 0x7f29bd5e, 0x7f19dd22, 0x7f08aa2e, 0x7ef604c0, 0x7ee1c9da, 0x7ecbd2e2, 0x7eb3f544, 0x7e9a020a, 0x7e7dc55b, 0x7e5f0606, 0x7e3d84e5, 0x7e18fc4a, 0x7df11f4e, 0x7dc59917, 0x7d960c0d, 0x7d6210fb, 0x7d29362a, 0x7ceafe57, 0x7ca6dfac, 0x7c5c429f, 0x7c0a80c0, 0x7bb0e38d, 0x7b4ea327, 0x7ae2e512, 0x7a6cbb02, 0x79eb21a7, 0x795cff99, 0x78c12472, 0x7816482c, 0x775b0ab7, 0x768df41f, 0x75ad7523, 0x74b7e894, 0x73ab957d, 0x7286b251, 0x7147695b, 0x6febde78, 0x6e72366f, 0x6cd89fee, 0x6b1d5e49, 0x693ed60a, 0x673b9b3c, 0x6512812b, 0x62c2ab45, 0x604b9e91, 0x5dad5307, 0x5ae843b3, 0x57fd7cbe, 0x54eea5ff, 0x51be08f5, 0x4e6e90dd, 0x4b03c417, 0x4781b613, 0x43ecf1a2, 0x404a5bed, 0x3c9f10f8, 0x38f03acf, 0x3542e51c, 0x319bceae, 0x2dff3a6b, 0x2a70c076, 0x26f31efe },
    { 0x7fe0c7d8, 0x7fdec869, 0x7fdca623, 0x7fda5e6b, 0x7fd7ee6a, 0x7fd5530d, 0x7fd288fc, 0x7fcf8c96, 0x7fcc59e6, 0x7fc8ec9e, 0x7fc5400d, 0x7fc14f13, 0x7fbd141a, 0x7fb88908, 0x7fb3a72e, 0x7fae6740, 0x7fa8c13d, 0x7fa2ac62, 0x7f9c1f11, 0x7f950ebf, 0x7f8d6fd5, 0x7f853598, 0x7f7c5208, 0x7f72b5bd, 0x7f684fc1, 0x7f5d0d66, 0x7f50da12, 0x7f439f10, 0x7f354351, 0x7f25ab2d, 0x7f14b819, 0x7f02485b, 0x7eee36ab, 0x7ed859d7, 0x7ec08458, 0x7ea683d2, 0x7e8a209c, 0x7e6b1d29, 0x7e49356c, 0x7e241e2c, 0x7dfb8443, 0x7dcf0bd6, 0x7d9e4f73, 0x7d68df1f, 0x7d2e3f59, 0x7cede801, 0x7ca74330, 0x7c59ac12, 0x7c046d98, 0x7ba6c134, 0x7b3fcd8f, 0x7acea543, 0x7a524595, 0x79c99560, 0x79336415, 0x788e68f8, 0x77d942bc, 0x7712777a, 0x7638753d, 0x75499341, 0x74441400, 0x73262852, 0x71edf3bd, 0x70999227, 0x6f271f12, 0x6d94bea9, 0x6be0a885, 0x6a093455, 0x680ce85d, 0x65ea896f, 0x63a12c42, 0x6130475f, 0x5e97c51c, 0x5bd8148e, 0x58f23872, 0x55e7d2d8, 0x52bb2c2d, 0x4f6f34a3, 0x4c077ecf, 0x488832f8, 0x44f5faab, 0x4155e518, 0x3dad44df, 0x3a0188d5, 0x3658114f, 0x32b60416, 0x2f2020c5, 0x2b9a9736, 0x2828e0cf },
    { 0x7fe56357, 0x7fe3a9e9, 0x7fe1d1c9, 0x7fdfd89a, 0x7fddbbc9, 0x7fdb7887, 0x7fd90bc8, 0x7fd67237, 0x7fd3a834, 0x7fd0a9c7, 0x7fcd729c, 0x7fc9fdf7, 0x7fc646a7, 0x7fc24700, 0x7fbdf8c9, 0x7fb9552d, 0x7fb454ae, 0x7faeef11, 0x7fa91b48, 0x7fa2cf5e, 0x7f9c005e, 0x7f94a235, 0x7f8ca795, 0x7f8401d2, 0x7f7aa0bb, 0x7f707271, 0x7f656335, 0x7f595d36, 0x7f4c4856, 0x7f3e09e9, 0x7f2e846e, 0x7f1d973b, 0x7f0b1e2e, 0x7ef6f13f, 0x7ee0e41f, 0x7ec8c5ba, 0x7eae5fb9, 0x7e9175e9, 0x7e71c5a5, 0x7e4f0526, 0x7e28e2bf, 0x7dff0415, 0x7dd1053a, 0x7d9e77bb, 0x7d66e199, 0x7d29bc35, 0x7ce67321, 0x7c9c62e9, 0x7c4ad7d1, 0x7bf10c7d, 0x7b8e28a1, 0x7b213fac, 0x7aa94f85, 0x7a253f50, 0x7993de76, 0x78f3e3c7, 0x7843ecfc, 0x77827eaa, 0x76ae04a8, 0x75c4d340, 0x74c52928, 0x73ad3282, 0x727b0d1b, 0x712cce0a, 0x6fc088ea, 0x6e3458ca, 0x6c866b0f, 0x6ab50c19, 0x68beb5ec, 0x66a2205d, 0x645e52ad, 0x61f2b5ea, 0x5f5f2757, 0x5ca40a08, 0x59c25688, 0x56bba74b, 0x539240bc, 0x50491385, 0x4ce3b851, 0x4966640b, 0x45d5d47d, 0x423735a4, 0x3e900064, 0x3ae5d428, 0x373e4d29, 0x339ed976, 0x300c8eda, 0x2c8c038a, 0x29212b03 },
    { 0x7fe941eb, 0x7fe7c34b, 0x7fe62976, 0x7fe47242, 0x7fe29b53, 0x7fe0a218, 0x7fde83c1, 0x7fdc3d3c, 0x7fd9cb2d, 0x7fd729e8, 0x7fd45566, 0x7fd1493e, 0x7fce0096, 0x7fca761f, 0x7fc6a3ff, 0x7fc283cc, 0x7fbe0e72, 0x7fb93c2a, 0x7fb4045f, 0x7fae5d9d, 0x7fa83d75, 0x7fa19865, 0x7f9a61b3, 0x7f928b52, 0x7f8a05b9, 0x7f80bfb7, 0x7f76a646, 0x7f6ba45a, 0x7f5fa29e, 0x7f52873e, 0x7f443597, 0x7f348dec, 0x7f236d0f, 0x7f10abf9, 0x7efc1f67, 0x7ee59758, 0x7eccde96, 0x7eb1ba1b, 0x7e93e873, 0x7e732113, 0x7e4f1394, 0x7e2766e4, 0x7dfbb865, 0x7dcb9af5, 0x7d9695e6, 0x7d5c23e7, 0x7d1bb1d0, 0x7cd49d69, 0x7c86341d, 0x7c2fb1a2, 0x7bd03e9b, 0x7b66ef41, 0x7af2c20d, 0x7a729e7d, 0x79e55403, 0x7949991f, 0x789e0ad1, 0x77e12c75, 0x7711681c, 0x762d0fa7, 0x75325ea2, 0x741f7d44, 0x72f28483, 0x71a983b1, 0x704287a5, 0x6ebba3a0, 0x6d12fc2b, 0x6b46d3ce, 0x695599ca, 0x673dfa72, 0x64fef0f3, 0x6297da11, 0x600886ea, 0x5d514f1c, 0x5a7320f1, 0x576f8e8b, 0x5448d6ab, 0x5101e7ca, 0x4d9e5ca7, 0x4a227160, 0x4692f0d9, 0x42f51abf, 0x3f4e82f1, 0x3ba4eba0, 0x37fe1c20, 0x345fb672, 0x30cf0dcf, 0x2d510037, 0x29e9d4d1 },
    { 0x7fec8253, 0x7feb3520, 0x7fe9cfa6, 0x7fe84fe8, 0x7fe6b3b9, 0x7fe4f8b7, 0x7fe31c49, 0x7fe11b94, 0x7fdef378, 0x7fdca085, 0x7fda1ef6, 0x7fd76aa8, 0x7fd47f0c, 0x7fd1571f, 0x7fcded5b, 0x7fca3baa, 0x7fc63b57, 0x7fc1e4fa, 0x7fbd3065, 0x7fb81491, 0x7fb28782, 0x7fac7e2b, 0x7fa5ec54, 0x7f9ec476, 0x7f96f793, 0x7f8e7511, 0x7f852a86, 0x7f7b0389, 0x7f6fe973, 0x7f63c325, 0x7f5674bb, 0x7f47df40, 0x7f37e054, 0x7f2651cb, 0x7f130945, 0x7efdd7af, 0x7ee688c7, 0x7ecce283, 0x7eb0a47a, 0x7e91872f, 0x7e6f3b4d, 0x7e4968e1, 0x7e1fae6b, 0x7df19fed, 0x7dbec5da, 0x7d869c03, 0x7d48905b, 0x7d0401bd, 0x7cb83e97, 0x7c64838f, 0x7c07fa20, 0x7ba1b737, 0x7b30b9d7, 0x7ab3e9d8, 0x7a2a16c0, 0x7991f6dc, 0x78ea26a1, 0x7831286c, 0x776564e2, 0x76852bdf, 0x758eb65b, 0x7480293a, 0x73579964, 0x7213114a, 0x70b097f7, 0x6f2e3a03, 0x6d8a1454, 0x6bc260f5, 0x69d585c0, 0x67c224eb, 0x65872efa, 0x6323f5a5, 0x60983f09, 0x5de4581b, 0x5b09255a, 0x58083084, 0x54e3b1f0, 0x519e9462, 0x4e3c722f, 0x4ac18b10, 0x4732b221, 0x4395347c, 0x3feeb90e, 0x3c451b2a, 0x389e4194, 0x34fff44d, 0x316fb356, 0x2df2908d, 0x2a8d0e8b },
    { 0x7fef3e18, 0x7fee1a75, 0x7fece101, 0x7feb8fe5, 0x7fea251c, 0x7fe89e6f, 0x7fe6f96e, 0x7fe5336f, 0x7fe34982, 0x7fe1386d, 0x7fdefca2, 0x7fdc9239, 0x7fd9f4e0, 0x7fd71fd5, 0x7fd40dd9, 0x7fd0b91f, 0x7fcd1b3f, 0x7fc92d23, 0x7fc4e6f4, 0x7fc04005, 0x7fbb2ebb, 0x7fb5a870, 0x7fafa156, 0x7fa90c57, 0x7fa1daee, 0x7f99fcfd, 0x7f91609f, 0x7f87f1f5, 0x7f7d9aed, 0x7f724300, 0x7f65ceea, 0x7f582061, 0x7f4915b4, 0x7f388972, 0x7f2651fa, 0x7f124102, 0x7efc2319, 0x7ee3bf10, 0x7ec8d55c, 0x7eab1f63, 0x7e8a4ec5, 0x7e660c7a, 0x7e3df7fd, 0x7e11a645, 0x7de0a0c4, 0x7daa6441, 0x7d6e5fa4, 0x7d2bf2b5, 0x7ce26cc4, 0x7c910b49, 0x7c36f87f, 0x7bd349f2, 0x7b64ff25, 0x7aeb0043, 0x7a641cef, 0x79cf0b56, 0x792a677d, 0x7874b300, 0x77ac5551, 0x76cf9caa, 0x75dcbfd5, 0x74d1e0f2, 0x73ad117e, 0x726c57c6, 0x710db5f1, 0x6f8f32e2, 0x6deee4f8, 0x6c2afee8, 0x6a41de6d, 0x68321cf0, 0x65faa194, 0x639ab459, 0x61121178, 0x5e60fc3d, 0x5b88500f, 0x58898e9b, 0x5566e9ae, 0x5223478d, 0x4ec240ac, 0x4b481609, 0x47b99fb0, 0x441c33c2, 0x407586b6, 0x3ccb861c, 0x39242feb, 0x35856852, 0x31f4d089, 0x2e77a0b4, 0x2b1286d9 }
};

// b2 min  0.043480612 max  0.999116025 range 22.978426231
//
COEFF CVoiceFilter::m_aB2[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC] =
{   
    { 0x3ebe7626, 0x3ebe7626, 0x3ebe7626, 0x3ebe7626, 0x3eab8aa1, 0x3e97854f, 0x3e82562c, 0x3e6bec5b, 0x3e54361a, 0x3e3b20ae, 0x3e209866, 0x3e048882, 0x3de6db39, 0x3dc7799c, 0x3da64b93, 0x3d8337cb, 0x3d5e23ba, 0x3d36f379, 0x3d0d89d3, 0x3ce1c827, 0x3cb38e63, 0x3c82baff, 0x3c4f2ae0, 0x3c18b96d, 0x3bdf4064, 0x3ba297ee, 0x3b62968b, 0x3b1f1112, 0x3ad7daa6, 0x3a8cc4c5, 0x3a3d9f3e, 0x39ea3834, 0x39925c32, 0x3935d62d, 0x38d46f98, 0x386df075, 0x38021f72, 0x3790c206, 0x37199c9d, 0x369c72be, 0x36190740, 0x358f1c8b, 0x34fe74dc, 0x3466d294, 0x33c7f88f, 0x3321aa8b, 0x3273ad96, 0x31bdc889, 0x30ffc486, 0x30396d94, 0x2f6a9338, 0x2e930912, 0x2db2a793, 0x2cc94cb2, 0x2bd6dc9f, 0x2adb428b, 0x29d6714e, 0x28c8642a, 0x27b11f57, 0x2690b095, 0x25672f95, 0x2434be20, 0x22f98820, 0x21b5c336, 0x2069ae02, 0x1f158ed7, 0x1db9b1dc, 0x1c566646, 0x1aebfaa1, 0x197ab7ca, 0x1802da28, 0x168488c4, 0x14ffc94a, 0x13746fb3, 0x11e2079e, 0x1047b3cb, 0x0ea3fd72, 0x0cf487dc, 0x0b359075, 0x096107e6, 0x076cc67a, 0x054678ea, 0x02c862e7, 0x02c862e7, 0x02c862e7, 0x02c862e7, 0x02c862e7, 0x02c862e7, 0x02c862e7 },
    { 0x3f3d0b77, 0x3f3d0b77, 0x3f318694, 0x3f2554a1, 0x3f186ba1, 0x3f0ac0fd, 0x3efc498d, 0x3eecf98b, 0x3edcc486, 0x3ecb9d5d, 0x3eb9763c, 0x3ea64087, 0x3e91ecdd, 0x3e7c6b03, 0x3e65a9e6, 0x3e4d9786, 0x3e3420ec, 0x3e193229, 0x3dfcb643, 0x3dde9727, 0x3dbebdab, 0x3d9d116e, 0x3d7978e0, 0x3d53d92f, 0x3d2c1638, 0x3d021282, 0x3cd5af2c, 0x3ca6cbee, 0x3c754707, 0x3c40fd34, 0x3c09c9ad, 0x3bcf861e, 0x3b920a9b, 0x3b512da8, 0x3b0cc42e, 0x3ac4a183, 0x3a78976a, 0x3a28761c, 0x39d40c50, 0x397b2755, 0x391d9313, 0x38bb1a34, 0x38538643, 0x37e69fc4, 0x37742e70, 0x36fbf961, 0x367dc754, 0x35f95eec, 0x356e870c, 0x34dd0725, 0x3444a7aa, 0x33a53278, 0x32fe735e, 0x32503899, 0x319a5376, 0x30dc98e2, 0x3016e21a, 0x2f490d4a, 0x2e72fe3e, 0x2d949f0a, 0x2cade09b, 0x2bbebb4e, 0x2ac72f4d, 0x29c744d0, 0x28bf0c1a, 0x27ae9d24, 0x269616cf, 0x25759d89, 0x244d5931, 0x231d71f8, 0x21e60bff, 0x20a74136, 0x1f6118ec, 0x1e137c22, 0x1cbe252e, 0x1b608854, 0x19f9b13c, 0x18880dc4, 0x17091796, 0x1578bd9c, 0x13d045d2, 0x1203e8e8, 0x0ffcc2a0, 0x0d8481cc, 0x09c35cee, 0x09c35cee, 0x09c35cee, 0x09c35cee, 0x09c35cee },
    { 0x3f63f484, 0x3f63f484, 0x3f5ab931, 0x3f50f2d2, 0x3f46994f, 0x3f3ba41d, 0x3f300a33, 0x3f23c207, 0x3f16c188, 0x3f08fe0f, 0x3efa6c64, 0x3eeb00aa, 0x3edaae5d, 0x3ec9684c, 0x3eb72088, 0x3ea3c864, 0x3e8f5066, 0x3e79a840, 0x3e62bec1, 0x3e4a81d4, 0x3e30de6e, 0x3e15c085, 0x3df91305, 0x3ddabfca, 0x3dbaaf8a, 0x3d98c9d9, 0x3d74f50f, 0x3d4f1648, 0x3d271153, 0x3cfcc8ab, 0x3cd01d6e, 0x3ca0ef4e, 0x3c6f1c95, 0x3c3a820f, 0x3c02fb0f, 0x3bc86166, 0x3b8a8d62, 0x3b4955cd, 0x3b048ff0, 0x3abc0f97, 0x3a6fa71e, 0x3a1f2773, 0x39ca6037, 0x39711fc3, 0x39133352, 0x38b06719, 0x38488678, 0x37db5c24, 0x3768b267, 0x36f0535f, 0x3672094f, 0x35ed9ef4, 0x3562dfe9, 0x34d19916, 0x34399932, 0x339ab13f, 0x32f4b528, 0x32477c54, 0x3192e254, 0x30d6c789, 0x301311d4, 0x2f47ad3e, 0x2e748c93, 0x2d99a9f6, 0x2cb70741, 0x2bccae44, 0x2adab0c2, 0x29e12809, 0x28e0341b, 0x27d7fa34, 0x26c8a27f, 0x25b254c2, 0x24953398, 0x237155db, 0x2246bd71, 0x21154a82, 0x1fdca95d, 0x1e9c3828, 0x1d52df41, 0x1bfed284, 0x1a9d27af, 0x192915dd, 0x179a7055, 0x15e21bce, 0x13dfce54, 0x1135a2b0, 0x1135a2b0, 0x1135a2b0, 0x1135a2b0 },
    { 0x3f802c4d, 0x3f802c4d, 0x3f789a93, 0x3f70969d, 0x3f6819c2, 0x3f5f1cf4, 0x3f5598bf, 0x3f4b8541, 0x3f40da28, 0x3f358ea6, 0x3f299972, 0x3f1cf0ba, 0x3f0f8a20, 0x3f015ab3, 0x3ef256e5, 0x3ee27286, 0x3ed1a0b8, 0x3ebfd3e9, 0x3eacfdcc, 0x3e990f4b, 0x3e83f883, 0x3e6da8b5, 0x3e560e41, 0x3e3d1698, 0x3e22ae33, 0x3e06c08a, 0x3de9380a, 0x3dc9fe06, 0x3da8faaf, 0x3d86150c, 0x3d6132ef, 0x3d3a38e4, 0x3d110a32, 0x3ce588cf, 0x3cb7954f, 0x3c870eef, 0x3c53d37c, 0x3c1dbf5b, 0x3be4ad84, 0x3ba8777d, 0x3b68f562, 0x3b25fde8, 0x3adf6661, 0x3a9502cf, 0x3a46a5f2, 0x39f4215a, 0x399d4589, 0x3941e20f, 0x38e1c5ba, 0x387cbebf, 0x38129afc, 0x37a32838, 0x372e346e, 0x36b38e32, 0x3633050b, 0x35ac69ed, 0x351f8fb3, 0x348c4bb0, 0x33f27640, 0x3351eb71, 0x32aa8bac, 0x31fc3c66, 0x3146e8d1, 0x308a8290, 0x2fc70254, 0x2efc686e, 0x2e2abd32, 0x2d521134, 0x2c727d2f, 0x2b8c2198, 0x2a9f25a1, 0x29abb5a3, 0x28b2009b, 0x27b23494, 0x26ac7990, 0x25a0ea7b, 0x248f8b5e, 0x23783bb4, 0x225aa2ea, 0x213613b5, 0x20096000, 0x1ed29165, 0x1d8e6c27, 0x1c378009, 0x1ac42369, 0x19214197, 0x1720899b, 0x1720899b, 0x1720899b },
    { 0x3f962e69, 0x3f962e69, 0x3f8fe929, 0x3f894523, 0x3f823ccd, 0x3f7aca45, 0x3f72e758, 0x3f6a8d74, 0x3f61b5aa, 0x3f5858a3, 0x3f4e6e9f, 0x3f43ef6c, 0x3f38d261, 0x3f2d0e5b, 0x3f2099b0, 0x3f136a2c, 0x3f05750b, 0x3ef6aeee, 0x3ee70bd8, 0x3ed67f1f, 0x3ec4fb6d, 0x3eb272ad, 0x3e9ed609, 0x3e8a15e1, 0x3e7421be, 0x3e5ce84b, 0x3e44574a, 0x3e2a5b89, 0x3e0ee0dd, 0x3df1d212, 0x3dd318e5, 0x3db29df6, 0x3d9048c4, 0x3d6bffa0, 0x3d45a7a4, 0x3d1d24ab, 0x3cf2594b, 0x3cc526cf, 0x3c956d2c, 0x3c630b06, 0x3c2ddda8, 0x3bf5c105, 0x3bba8fbb, 0x3b7c231b, 0x3b3a5330, 0x3af4f6cc, 0x3aabe399, 0x3a5eee36, 0x3a0dea49, 0x39b8aab0, 0x395f01a2, 0x3900c0ea, 0x389dba1f, 0x3835bef0, 0x37c8a176, 0x37563490, 0x36de4c53, 0x3660be81, 0x35dd630d, 0x355414b1, 0x34c4b18e, 0x342f1bd5, 0x33933a7d, 0x32f0f9fd, 0x32484d01, 0x31992d22, 0x30e39b88, 0x3027a17a, 0x2f6550b7, 0x2e9cc3a9, 0x2dce1d34, 0x2cf9882f, 0x2c1f363e, 0x2b3f5e0a, 0x2a5a3881, 0x296ffcfa, 0x2880dbc7, 0x278cf6bf, 0x269456f9, 0x2596de6d, 0x2494335c, 0x238ba1b0, 0x227beaef, 0x2162f5da, 0x203d3c3d, 0x1f04a33d, 0x1dadc7f2, 0x1c2020c3, 0x1c2020c3 },
    { 0x3facd242, 0x3fa7e386, 0x3fa2aa1f, 0x3f9d21ac, 0x3f974588, 0x3f9110ca, 0x3f8a7e42, 0x3f83886f, 0x3f7c2983, 0x3f745b58, 0x3f6c1771, 0x3f6356ee, 0x3f5a128e, 0x3f5042a4, 0x3f45df15, 0x3f3adf50, 0x3f2f3a4a, 0x3f22e670, 0x3f15d9b1, 0x3f080960, 0x3ef96a43, 0x3ee9f07c, 0x3ed98f86, 0x3ec83a2e, 0x3eb5e28d, 0x3ea279f8, 0x3e8df0fe, 0x3e78375a, 0x3e613bf0, 0x3e48ecba, 0x3e2f36ca, 0x3e140637, 0x3df7461c, 0x3dd8e086, 0x3db8be71, 0x3d96c7be, 0x3d72e32d, 0x3d4cf64d, 0x3d24e583, 0x3cfa93f6, 0x3ccde398, 0x3c9eb518, 0x3c6ce7e8, 0x3c385a3d, 0x3c00e913, 0x3bc67032, 0x3b88ca3c, 0x3b47d0bd, 0x3b035c3c, 0x3abb4455, 0x3a6f5fe0, 0x3a1f850d, 0x39cb899c, 0x39734316, 0x3916870d, 0x38b52b68, 0x384f06c1, 0x37e3f0c9, 0x3773c2be, 0x36fe57ea, 0x36838e36, 0x360346c0, 0x357d6692, 0x34f1d749, 0x346087d9, 0x33c96d4a, 0x332c8377, 0x3289cdc6, 0x31e157bf, 0x31333597, 0x307f847b, 0x2fc66aa2, 0x2f0816ff, 0x2e44c088, 0x2d7ca4dd, 0x2cb00638, 0x2bdf2870, 0x2b0a4cc5, 0x2a31ac27, 0x29556f6c, 0x2875a4b3, 0x2792308b, 0x26aab8a3, 0x25be8391, 0x24cc4528, 0x23d1c4fa, 0x22cb33bf, 0x21b1bb02, 0x21b1bb02 },
    { 0x3fba7f26, 0x3fb65f8c, 0x3fb20179, 0x3fad6141, 0x3fa87afe, 0x3fa34a92, 0x3f9dcba1, 0x3f97f990, 0x3f91cf7f, 0x3f8b4844, 0x3f845e6b, 0x3f7d0c2f, 0x3f754b75, 0x3f6d15cc, 0x3f646460, 0x3f5b2ffd, 0x3f517106, 0x3f471f6c, 0x3f3c32b1, 0x3f30a1d8, 0x3f246366, 0x3f176d58, 0x3f09b51b, 0x3efb2f88, 0x3eebd0dd, 0x3edb8cae, 0x3eca55e8, 0x3eb81ec0, 0x3ea4d8b0, 0x3e90746c, 0x3e7ae1d8, 0x3e641006, 0x3e4bed22, 0x3e326677, 0x3e176859, 0x3dfade27, 0x3ddcb23b, 0x3dbccde7, 0x3d9b196e, 0x3d777bfc, 0x3d51db9c, 0x3d2a1d3e, 0x3d0024ab, 0x3cd3d488, 0x3ca50e54, 0x3c73b270, 0x3c3fa020, 0x3c08b597, 0x3bced007, 0x3b91cbb0, 0x3b5183f7, 0x3b0dd389, 0x3ac6947a, 0x3a7ba075, 0x3a2cd0f1, 0x39d9ff70, 0x398305c7, 0x3927be79, 0x38c80514, 0x3863b6a5, 0x37fab231, 0x378cd949, 0x371a109b, 0x36a240a3, 0x36255657, 0x35a343e8, 0x351c0181, 0x348f8e0e, 0x33fdeff5, 0x336735c2, 0x32cb76bd, 0x322ad352, 0x3185753e, 0x30db8f76, 0x302d5da7, 0x2f7b2336, 0x2ec529a2, 0x2e0bbe25, 0x2d4f2e67, 0x2c8fc3fd, 0x2bcdbe72, 0x2b094b48, 0x2a427b2f, 0x29793311, 0x28ad1653, 0x27dd6585, 0x2708c753, 0x262ce530, 0x2545a324 },
    { 0x3fc5cac1, 0x3fc25662, 0x3fbeada1, 0x3fbacd6a, 0x3fb6b277, 0x3fb25952, 0x3fadbe51, 0x3fa8dd97, 0x3fa3b307, 0x3f9e3a4d, 0x3f986ed3, 0x3f924bbc, 0x3f8bcbe7, 0x3f84e9e6, 0x3f7d9ffc, 0x3f75e816, 0x3f6dbbc8, 0x3f65144b, 0x3f5bea72, 0x3f5236aa, 0x3f47f0f2, 0x3f3d10d5, 0x3f318d65, 0x3f255d34, 0x3f18764e, 0x3f0ace34, 0x3efc59cf, 0x3eed0d71, 0x3edcdcc6, 0x3ecbbad4, 0x3eb999ec, 0x3ea66ba7, 0x3e9220da, 0x3e7ca993, 0x3e65f50d, 0x3e4df1a9, 0x3e348ce5, 0x3e19b359, 0x3dfd50a9, 0x3ddf4f85, 0x3dbf999c, 0x3d9e179f, 0x3d7ab134, 0x3d554cfa, 0x3d2dd084, 0x3d04205c, 0x3cd82005, 0x3ca9b1ff, 0x3c78b7d3, 0x3c45121d, 0x3c0ea0a3, 0x3bd54261, 0x3b98d5b2, 0x3b593867, 0x3b1647f8, 0x3acfe1bb, 0x3a85e315, 0x3a3829cc, 0x39e69455, 0x39910235, 0x3937546a, 0x38d96deb, 0x3877342e, 0x38108fbc, 0x37a56cdd, 0x3735bc40, 0x36c173bc, 0x36488f0d, 0x35cb109a, 0x3549022d, 0x34c275a8, 0x3437859b, 0x33a855b9, 0x33151318, 0x327df42b, 0x31e33869, 0x31452781, 0x30a41006, 0x3000457e, 0x2f5a1dac, 0x2eb1ecf2, 0x2e08019b, 0x2d5c9dbb, 0x2cafef34, 0x2c020509, 0x2b52c097, 0x2aa1bfe7, 0x29ee3b94, 0x2936cc73 },
    { 0x3fcf2dc9, 0x3fcc47ce, 0x3fc935da, 0x3fc5f555, 0x3fc2837e, 0x3fbedd6f, 0x3fbb0011, 0x3fb6e823, 0x3fb29232, 0x3fadfa98, 0x3fa91d77, 0x3fa3f6ba, 0x3f9e820f, 0x3f98bae2, 0x3f929c5d, 0x3f8c2163, 0x3f85448a, 0x3f7e001a, 0x3f764e06, 0x3f6e27ea, 0x3f658703, 0x3f5c642d, 0x3f52b7de, 0x3f487a1c, 0x3f3da27d, 0x3f32281f, 0x3f2601a0, 0x3f192519, 0x3f0b8819, 0x3efd1f9d, 0x3eede009, 0x3eddbd20, 0x3ecca9ff, 0x3eba9914, 0x3ea77c18, 0x3e934406, 0x3e7de114, 0x3e6742af, 0x3e4f576f, 0x3e360d13, 0x3e1b507d, 0x3dff0da7, 0x3de12fa4, 0x3dc1a099, 0x3da049bb, 0x3d7d134f, 0x3d57e4a8, 0x3d30a430, 0x3d073767, 0x3cdb82ef, 0x3cad6a99, 0x3c7cd174, 0x3c4999e5, 0x3c13a5bd, 0x3bdad664, 0x3b9f0cfa, 0x3b602a89, 0x3b1e1048, 0x3ad89fd3, 0x3a8fbb87, 0x3a4346db, 0x39f326c5, 0x399f4237, 0x394782a2, 0x38ebd487, 0x388c281d, 0x382871f6, 0x37c0abb9, 0x3754d4dc, 0x36e4f365, 0x3671149a, 0x35f94db7, 0x357dbc7b, 0x34fe879d, 0x347bdf12, 0x33f5fc06, 0x336d2099, 0x32e19728, 0x3253b126, 0x31c3c571, 0x31322dfd, 0x309f44d8, 0x300b6050, 0x2f76ce22, 0x2ee1cd72, 0x2e4c8708, 0x2db7031f, 0x2d211b1f, 0x2c8a645a },
    { 0x3fd702c5, 0x3fd493a9, 0x3fd1ff9b, 0x3fcf446b, 0x3fcc5fcb, 0x3fc94f46, 0x3fc61047, 0x3fc2a00e, 0x3fbefbb5, 0x3fbb2029, 0x3fb70a2a, 0x3fb2b646, 0x3fae20da, 0x3fa9460b, 0x3fa421c5, 0x3f9eafb9, 0x3f98eb57, 0x3f92cfcb, 0x3f8c57fb, 0x3f857e83, 0x3f7e3dad, 0x3f768f72, 0x3f6e6d74, 0x3f65d0f4, 0x3f5cb2d7, 0x3f530b98, 0x3f48d348, 0x3f3e0184, 0x3f328d76, 0x3f266dc7, 0x3f1998a0, 0x3f0c039e, 0x3efda3d2, 0x3eee6db4, 0x3ede551f, 0x3ecd4d4d, 0x3ebb48cc, 0x3ea8397b, 0x3e941080, 0x3e7ebe46, 0x3e683272, 0x3e505be3, 0x3e3728aa, 0x3e1c8606, 0x3e00605f, 0x3de2a34a, 0x3dc33983, 0x3da20cee, 0x3d7f06a1, 0x3d5a0ee0, 0x3d330d2d, 0x3d09e855, 0x3cde867a, 0x3cb0cd2f, 0x3c80a18f, 0x3c4de860, 0x3c18863a, 0x3be05fb9, 0x3ba559b2, 0x3b67597f, 0x3b264542, 0x3ae2044a, 0x3a9a7f71, 0x3a4fa195, 0x3a015818, 0x39af936e, 0x395a47b5, 0x39016d60, 0x38a501e3, 0x38450863, 0x37e18a72, 0x377a98b3, 0x37104b83, 0x36a2c37d, 0x363229e5, 0x35beb0da, 0x35489359, 0x34d014e8, 0x345580ee, 0x33d929a2, 0x335b667f, 0x32dc923e, 0x325d0837, 0x31dd2132, 0x315d2f7f, 0x30dd7a44, 0x305e37c9, 0x2fdf864b, 0x2f61627d },
    { 0x3fdd9018, 0x3fdb847a, 0x3fd959cc, 0x3fd70e39, 0x3fd49fcd, 0x3fd20c7a, 0x3fcf5211, 0x3fcc6e44, 0x3fc95ea0, 0x3fc6208f, 0x3fc2b154, 0x3fbf0e09, 0x3fbb339d, 0x3fb71ed1, 0x3fb2cc34, 0x3fae3825, 0x3fa95eca, 0x3fa43c13, 0x3f9ecbb1, 0x3f990917, 0x3f92ef75, 0x3f8c79b3, 0x3f85a270, 0x3f7e63fc, 0x3f76b852, 0x3f6e991b, 0x3f65ff9d, 0x3f5ce4c5, 0x3f534114, 0x3f490ca4, 0x3f3e3f1e, 0x3f32cfb6, 0x3f26b525, 0x3f19e5a3, 0x3f0c56e1, 0x3efdfe03, 0x3eeecf9c, 0x3edebfa7, 0x3ecdc17f, 0x3ebbc7da, 0x3ea8c4c9, 0x3e94a9aa, 0x3e7f6729, 0x3e68ed3a, 0x3e512b16, 0x3e380f3a, 0x3e1d8761, 0x3e018088, 0x3de3e6f1, 0x3dc4a623, 0x3da3a8f0, 0x3d80d983, 0x3d5c216a, 0x3d3569a6, 0x3d0c9abd, 0x3ce19cdd, 0x3cb457f8, 0x3c84b3e9, 0x3c5298a7, 0x3c1dee7e, 0x3be69e4f, 0x3bac91dc, 0x3b6fb420, 0x3b2ff1b4, 0x3aed393e, 0x3aa77bee, 0x3a5eae06, 0x3a12c76e, 0x39c3c453, 0x3971a5cb, 0x391c727d, 0x38c43747, 0x386907df, 0x380aff61, 0x37aa40c4, 0x3746f735, 0x36e15632, 0x3679997d, 0x361004bc, 0x35a4e2c7, 0x353884a1, 0x34cb3ffe, 0x345d6d6b, 0x33ef65fc, 0x3381808d, 0x33140e8f, 0x32a75852, 0x323b98b7, 0x31d0f817 },
    { 0x3fe30dd5, 0x3fe155a1, 0x3fdf834e, 0x3fdd9550, 0x3fdb8a03, 0x3fd95fac, 0x3fd71474, 0x3fd4a66b, 0x3fd21381, 0x3fcf5987, 0x3fcc7631, 0x3fc9670d, 0x3fc62984, 0x3fc2badb, 0x3fbf182c, 0x3fbb3e68, 0x3fb72a50, 0x3fb2d875, 0x3fae4537, 0x3fa96cbf, 0x3fa44afc, 0x3f9edba4, 0x3f991a2a, 0x3f9301c2, 0x3f8c8d57, 0x3f85b78d, 0x3f7e7ab5, 0x3f76d0d3, 0x3f6eb392, 0x3f661c42, 0x3f5d03d5, 0x3f5362d8, 0x3f49316e, 0x3f3e674d, 0x3f32fbb7, 0x3f26e578, 0x3f1a1adb, 0x3f0c91aa, 0x3efe3f25, 0x3eef1802, 0x3edf1060, 0x3ece1bca, 0x3ebc2d2e, 0x3ea936db, 0x3e952a7c, 0x3e7ff915, 0x3e699304, 0x3e51e7fe, 0x3e38e70f, 0x3e1e7ea0, 0x3e029c76, 0x3de52dbe, 0x3dc61f13, 0x3da55c8e, 0x3d82d1d5, 0x3d5e6a2f, 0x3d3810a4, 0x3d0fb017, 0x3ce53371, 0x3cb885d1, 0x3c8992be, 0x3c58466e, 0x3c248e0c, 0x3bee580e, 0x3bb59497, 0x3b7a35e0, 0x3b3c30b4, 0x3afb7ceb, 0x3ab81600, 0x3a71fb9a, 0x3a29322e, 0x39ddc393, 0x398fbf9c, 0x393f3ca1, 0x38ec57fc, 0x38973667, 0x38400438, 0x37e6f56b, 0x378c4579, 0x373036e4, 0x36d3127c, 0x3675264f, 0x3616c441, 0x35b84050, 0x3559ee80, 0x34fc207c, 0x349f22e1, 0x34433a51, 0x33e8a02a },
    { 0x3fe7a969, 0x3fe6373a, 0x3fe4af12, 0x3fe30fa2, 0x3fe1578c, 0x3fdf8558, 0x3fdd977b, 0x3fdb8c52, 0x3fd96222, 0x3fd71714, 0x3fd4a937, 0x3fd2167d, 0x3fcf5cb8, 0x3fcc799b, 0x3fc96ab4, 0x3fc62d6e, 0x3fc2bf0f, 0x3fbf1cb1, 0x3fbb4345, 0x3fb72f8e, 0x3fb2de1f, 0x3fae4b59, 0x3fa97365, 0x3fa45236, 0x3f9ee383, 0x3f9922c4, 0x3f930b2d, 0x3f8c97af, 0x3f85c2f1, 0x3f7e874b, 0x3f76dec5, 0x3f6ec313, 0x3f662d8d, 0x3f5d172e, 0x3f53788f, 0x3f4949e3, 0x3f3e82f0, 0x3f331b0b, 0x3f270916, 0x3f1a4379, 0x3f0cc01e, 0x3efe746c, 0x3eef5545, 0x3edf56fe, 0x3ece6d62, 0x3ebc8ba8, 0x3ea9a478, 0x3e95a9e4, 0x3e808d6c, 0x3e6a3ffc, 0x3e52b1f4, 0x3e39d327, 0x3e1f92e8, 0x3e03e010, 0x3de6a90d, 0x3dc7dbf5, 0x3da76699, 0x3d8536a2, 0x3d6139ae, 0x3d3b5d7b, 0x3d139014, 0x3ce9c005, 0x3cbddc9d, 0x3c8fd635, 0x3c5f9e82, 0x3c2d28f3, 0x3bf86b17, 0x3bc15d0e, 0x3b87fa08, 0x3b4c40c1, 0x3b0e340c, 0x3acddb64, 0x3a8b436b, 0x3a467e75, 0x39ffa4fc, 0x39b6d601, 0x396c374f, 0x391ff59f, 0x38d24484, 0x38835e23, 0x383382b1, 0x37e2f7a0, 0x37920691, 0x3740fbf4, 0x36f02565, 0x369fcfd2, 0x36504564, 0x3601cb44, 0x35b49f43 },
    { 0x3feb880e, 0x3fea50b1, 0x3fe906d7, 0x3fe7a967, 0x3fe63739, 0x3fe4af13, 0x3fe30fa6, 0x3fe15792, 0x3fdf8561, 0x3fdd9788, 0x3fdb8c65, 0x3fd9623a, 0x3fd71734, 0x3fd4a960, 0x3fd216b1, 0x3fcf5cf9, 0x3fcc79eb, 0x3fc96b17, 0x3fc62de9, 0x3fc2bfa5, 0x3fbf1d67, 0x3fbb4422, 0x3fb7309a, 0x3fb2df62, 0x3fae4cde, 0x3fa9753a, 0x3fa4546a, 0x3f9ee628, 0x3f9925ef, 0x3f930ef8, 0x3f8c9c39, 0x3f85c85e, 0x3f7e8dc7, 0x3f76e683, 0x3f6ecc4f, 0x3f663890, 0x3f5d244f, 0x3f538834, 0x3f495c85, 0x3f3e991e, 0x3f333571, 0x3f27287f, 0x3f1a68d6, 0x3f0cec8b, 0x3efea93c, 0x3eef9408, 0x3edfa18f, 0x3ecec5f1, 0x3ebcf4cf, 0x3eaa2149, 0x3e963e00, 0x3e813d1c, 0x3e6b1052, 0x3e53a8e9, 0x3e3af7c6, 0x3e20ed7d, 0x3e057a5d, 0x3de88e8b, 0x3dca1a1b, 0x3daa0d31, 0x3d885823, 0x3d64ebb1, 0x3d3fb92e, 0x3d18b2c6, 0x3cefcbc1, 0x3cc4f8d0, 0x3c98306c, 0x3c696b31, 0x3c38a44d, 0x3c05d9f1, 0x3bd10dc8, 0x3b9a4575, 0x3b618b0a, 0x3b26ed86, 0x3aea813c, 0x3aac6035, 0x3a6caa78, 0x3a2b862b, 0x39e91fa0, 0x39a5a91e, 0x39615a84, 0x391c70ac, 0x38d72c91, 0x3891d239, 0x384ca765, 0x3807f20a, 0x37c3f6a9, 0x3780f686, 0x373f2dce },
    { 0x3feec885, 0x3fedc297, 0x3fecad1c, 0x3feb8726, 0x3fea4fbc, 0x3fe905d5, 0x3fe7a858, 0x3fe6361c, 0x3fe4ade7, 0x3fe30e6b, 0x3fe15648, 0x3fdf8408, 0x3fdd9620, 0x3fdb8aed, 0x3fd960b3, 0x3fd7159e, 0x3fd4a7bc, 0x3fd21500, 0x3fcf5b3d, 0x3fcc7825, 0x3fc9694a, 0x3fc62c18, 0x3fc2bdd4, 0x3fbf1b9d, 0x3fbb4265, 0x3fb72ef2, 0x3fb2ddda, 0x3fae4b81, 0x3fa97418, 0x3fa45395, 0x3f9ee5b7, 0x3f9925fd, 0x3f930fa6, 0x3f8c9dae, 0x3f85cac9, 0x3f7e9160, 0x3f76eb90, 0x3f6ed320, 0x3f664186, 0x3f5d2fde, 0x3f5396e6, 0x3f496f00, 0x3f3eb026, 0x3f3351f0, 0x3f274b8b, 0x3f1a93ba, 0x3f0d20d0, 0x3efee8b4, 0x3eefe0db, 0x3edffe4e, 0x3ecf35a4, 0x3ebd7b0e, 0x3eaac251, 0x3e96fed7, 0x3e8223ad, 0x3e6c239a, 0x3e54f122, 0x3e3c7e9f, 0x3e22be56, 0x3e07a292, 0x3deb1dc2, 0x3dcd22a2, 0x3dada467, 0x3d8c96f1, 0x3d69ef0b, 0x3d45a2a8, 0x3d1fa935, 0x3cf7fbea, 0x3cce9625, 0x3ca375cf, 0x3c769bc5, 0x3c480c41, 0x3c17cf4c, 0x3be5f125, 0x3bb282a5, 0x3b7d9997, 0x3b4750fd, 0x3b0fc93c, 0x3ad72824, 0x3a9d98db, 0x3a634b8e, 0x3a2874fd, 0x39ed4dca, 0x39b2119a, 0x3976fdfe, 0x393c5136, 0x390248cf, 0x38c9202e, 0x38910f0a },
    { 0x3ff18456, 0x3ff0a7fb, 0x3fefbe88, 0x3feec739, 0x3fedc139, 0x3fecabaa, 0x3feb85a0, 0x3fea4e20, 0x3fe90423, 0x3fe7a68e, 0x3fe6343a, 0x3fe4abec, 0x3fe30c56, 0x3fe15419, 0x3fdf81be, 0x3fdd93ba, 0x3fdb886a, 0x3fd95e15, 0x3fd712e3, 0x3fd4a4e6, 0x3fd21210, 0x3fcf5834, 0x3fcc7506, 0x3fc96618, 0x3fc628d7, 0x3fc2ba8a, 0x3fbf1850, 0x3fbb3f1f, 0x3fb72bbd, 0x3fb2dac4, 0x3fae489b, 0x3fa97177, 0x3fa45152, 0x3f9ee3f0, 0x3f9924d8, 0x3f930f51, 0x3f8c9e5e, 0x3f85ccc0, 0x3f7e94ed, 0x3f76f111, 0x3f6edb07, 0x3f664c5a, 0x3f5d3e41, 0x3f53a99a, 0x3f4986ea, 0x3f3ece59, 0x3f3377b4, 0x3f277a64, 0x3f1acd75, 0x3f0d6793, 0x3eff3f08, 0x3ef049c5, 0x3ee07d5d, 0x3ecfcf11, 0x3ebe33d4, 0x3eaba054, 0x3e980907, 0x3e836237, 0x3e6da01b, 0x3e56b6e6, 0x3e3e9ae4, 0x3e25409f, 0x3e0a9cff, 0x3deea575, 0x3dd15033, 0x3db29463, 0x3d926a62, 0x3d70cc12, 0x3d4db520, 0x3d29235d, 0x3d03171b, 0x3cdb9383, 0x3cb29eff, 0x3c884390, 0x3c5c8f2b, 0x3c2f9404, 0x3c0168d4, 0x3bd228fe, 0x3ba1f4a4, 0x3b70f096, 0x3b3f461c, 0x3b0d2296, 0x3adab6f0, 0x3aa836eb, 0x3a75d836, 0x3a43d167, 0x3a1258d3, 0x39e1a356, 0x39b1e30e }
};

// k  min  0.000038014 max  0.901921617 range 23725.941121027
COEFF CVoiceFilter::m_aK[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC] =
{
    { 0x00032fb7, 0x00032fb7, 0x00032fb7, 0x00032fb7, 0x00039311, 0x0004027d, 0x00047f6f, 0x00050b89, 0x0005a89f, 0x000658bf, 0x00071e32, 0x0007fb8a, 0x0008f3a7, 0x000a09bf, 0x000b416a, 0x000c9eae, 0x000e260c, 0x000fdc89, 0x0011c7c5, 0x0013ee09, 0x00165657, 0x00190887, 0x001c0d5a, 0x001f6e92, 0x00233715, 0x0027730c, 0x002c3003, 0x00317d14, 0x00376b12, 0x003e0cb8, 0x004576de, 0x004dc0b3, 0x005703fd, 0x00615d5f, 0x006ceca2, 0x0079d50b, 0x00883db3, 0x009851ec, 0x00aa41a6, 0x00be41e5, 0x00d48d3b, 0x00ed644d, 0x01090e5d, 0x0127d9e1, 0x014a1d27, 0x017036f2, 0x019a8f31, 0x01c997b3, 0x01fdccdf, 0x0237b678, 0x0277e85a, 0x02bf033e, 0x030db57b, 0x0364bbb8, 0x03c4e1a3, 0x042f028a, 0x04a409f9, 0x0524f42d, 0x05b2ce8b, 0x064eb7ea, 0x06f9e0df, 0x07b58bf7, 0x08830de9, 0x0963cdfd, 0x0a594697, 0x0b650650, 0x0c88b1bf, 0x0dc60696, 0x0f1ee09f, 0x1095418f, 0x122b5d31, 0x13e3abd0, 0x15c1061b, 0x17c6cf5a, 0x19f935b3, 0x1c5d95b5, 0x1efb189a, 0x21dbb93a, 0x250e08cc, 0x28a87844, 0x2cd00bf9, 0x31c7ef3c, 0x381d9404, 0x381d9404, 0x381d9404, 0x381d9404, 0x381d9404, 0x381d9404, 0x381d9404 },
    { 0x0002542f, 0x0002542f, 0x00029cf4, 0x0002ee96, 0x00034a2a, 0x0003b0e4, 0x0004241e, 0x0004a55e, 0x00053655, 0x0005d8ec, 0x00068f45, 0x00075bc3, 0x00084113, 0x00094236, 0x000a6286, 0x000ba5c6, 0x000d102b, 0x000ea66b, 0x00106dcb, 0x00126c30, 0x0014a832, 0x00172933, 0x0019f772, 0x001d1c25, 0x0020a19b, 0x00249354, 0x0028fe2c, 0x002df07b, 0x00337a42, 0x0039ad5f, 0x00409dba, 0x00486185, 0x00511179, 0x005ac91c, 0x0065a70e, 0x0071cd5c, 0x007f61de, 0x008e8e97, 0x009f8226, 0x00b27037, 0x00c79204, 0x00df26dd, 0x00f974b5, 0x0116c8c2, 0x0137781e, 0x015be072, 0x018468a3, 0x01b18194, 0x01e3a6d3, 0x021b5f5b, 0x02593e48, 0x029de384, 0x02e9fc65, 0x033e443d, 0x039b84c3, 0x0402965f, 0x04746041, 0x04f1d845, 0x057c0283, 0x0613f09c, 0x06bac0a3, 0x07719b9f, 0x0839b3aa, 0x091441a3, 0x0a028282, 0x0b05b462, 0x0c1f1374, 0x0d4fd70b, 0x0e992f29, 0x0ffc430c, 0x117a318a, 0x13141429, 0x14cb0677, 0x16a033a0, 0x1894ed45, 0x1aaad042, 0x1ce3feeb, 0x1f437e0e, 0x21cdcdc6, 0x2489f176, 0x27835b3b, 0x2acde79e, 0x2e8f9163, 0x331f4566, 0x39b91572, 0x39b91572, 0x39b91572, 0x39b91572, 0x39b91572 },
    { 0x00022384, 0x00022384, 0x00026663, 0x0002b169, 0x00030596, 0x00036405, 0x0003cdf5, 0x000444cd, 0x0004ca1f, 0x00055faa, 0x00060769, 0x0006c38f, 0x00079695, 0x00088340, 0x00098cab, 0x000ab650, 0x000c0412, 0x000d7a4e, 0x000f1de6, 0x0010f44f, 0x001303a6, 0x001552c5, 0x0017e950, 0x001acfda, 0x001e0ff3, 0x0021b450, 0x0025c8e8, 0x002a5b15, 0x002f79c6, 0x003535a4, 0x003ba148, 0x0042d170, 0x004add3f, 0x0053de7b, 0x005df1db, 0x00693757, 0x0075d27f, 0x0083eada, 0x0093ac54, 0x00a547a9, 0x00b8f2e7, 0x00cee9ee, 0x00e76efe, 0x0102cb52, 0x01214fbc, 0x0143554f, 0x01693e0f, 0x019375a6, 0x01c27219, 0x01f6b483, 0x0230c9c4, 0x02714b30, 0x02b8df28, 0x0308399f, 0x03601c7d, 0x03c157dd, 0x042cca0f, 0x04a35f5a, 0x0526116e, 0x05b5e669, 0x0653ef7f, 0x0701470a, 0x07bf0e27, 0x088e69a9, 0x09707e87, 0x0a666dba, 0x0b714fa4, 0x0c922f32, 0x0dca04f5, 0x0f19b291, 0x1081ff0d, 0x120394aa, 0x139f013f, 0x1554ba3e, 0x17252608, 0x1910acce, 0x1b17d437, 0x1d3b6ad1, 0x1f7ccbeb, 0x21de4b5a, 0x2463e832, 0x27148a26, 0x29fc6fb2, 0x2d32a8ee, 0x30e86427, 0x35a83b0c, 0x35a83b0c, 0x35a83b0c, 0x35a83b0c },
    { 0x0001f6a7, 0x0001f6a7, 0x00023413, 0x000278fe, 0x0002c651, 0x00031d13, 0x00037e6a, 0x0003eb9e, 0x00046623, 0x0004ef95, 0x000589c5, 0x000636bd, 0x0006f8c2, 0x0007d264, 0x0008c67e, 0x0009d845, 0x000b0b52, 0x000c63aa, 0x000de5d0, 0x000f96d0, 0x00117c50, 0x00139ca4, 0x0015fee2, 0x0018aaf5, 0x001ba9bd, 0x001f0522, 0x0022c83c, 0x0026ff72, 0x002bb89c, 0x00310337, 0x0036f08a, 0x003d93e2, 0x004502c8, 0x004d553f, 0x0056a60e, 0x00611309, 0x006cbd67, 0x0079ca1f, 0x00886248, 0x0098b38e, 0x00aaf09e, 0x00bf51b0, 0x00d61509, 0x00ef7f8f, 0x010bdd68, 0x012b829b, 0x014ecbba, 0x01761e96, 0x01a1eaf1, 0x01d2ab36, 0x0208e526, 0x02452a86, 0x028819b8, 0x02d25e3b, 0x0324b116, 0x037fd911, 0x03e4aab8, 0x04540813, 0x04cee01b, 0x05562daf, 0x05eaf621, 0x068e4732, 0x07413475, 0x0804d401, 0x08da3a80, 0x09c2767d, 0x0abe8b23, 0x0bcf6a5f, 0x0cf5eec1, 0x0e32d541, 0x0f86b771, 0x10f20687, 0x12750809, 0x140fd4e9, 0x15c25c28, 0x178c6a51, 0x196db772, 0x1b65fdf1, 0x1d751d7e, 0x1f9b4fb7, 0x21d97821, 0x2431a24d, 0x26a7d611, 0x29439ec2, 0x2c133d10, 0x2f33a1a2, 0x32eafa0f, 0x32eafa0f, 0x32eafa0f },
    { 0x0001cd62, 0x0001cd62, 0x000205c8, 0x00024511, 0x00028c13, 0x0002dbc1, 0x00033528, 0x00039978, 0x00040a03, 0x00048849, 0x000515f3, 0x0005b4e2, 0x0006672e, 0x00072f32, 0x00080f90, 0x00090b3d, 0x000a258a, 0x000b622b, 0x000cc548, 0x000e538b, 0x0010122a, 0x001206fd, 0x0014388e, 0x0016ae2f, 0x00197011, 0x001c8761, 0x001ffe60, 0x0023e087, 0x00283aab, 0x002d1b23, 0x003291f3, 0x0038b103, 0x003f8c4d, 0x00473a20, 0x004fd35d, 0x005973c1, 0x00643a36, 0x00704928, 0x007dc6e5, 0x008cde06, 0x009dbde0, 0x00b09afa, 0x00c5af96, 0x00dd3c39, 0x00f78845, 0x0114e292, 0x0135a219, 0x015a269d, 0x0182d95d, 0x01b02dc3, 0x01e2a215, 0x021ac01a, 0x02591dba, 0x029e5d7e, 0x02eb2efa, 0x03404f0c, 0x039e87e9, 0x0406b0dc, 0x0479adc0, 0x04f86e02, 0x0583eb30, 0x061d2703, 0x06c528b0, 0x077cf9a2, 0x0845a162, 0x092020be, 0x0a0d6c42, 0x0b0e65ea, 0x0c23d66c, 0x0d4e6624, 0x0e8e961e, 0x0fe4b990, 0x1150f07a, 0x12d323fa, 0x146b054c, 0x1618103b, 0x17d99237, 0x19aeb752, 0x1b969e8f, 0x1d9077d2, 0x1f9baece, 0x21b828c2, 0x23e6a087, 0x26293843, 0x288475ad, 0x2b012cb7, 0x2db0da5d, 0x30ba095c, 0x30ba095c },
    { 0x0001794e, 0x0001a772, 0x0001db38, 0x00021552, 0x00025684, 0x00029fad, 0x0002f1c5, 0x00034de2, 0x0003b53e, 0x00042936, 0x0004ab54, 0x00053d51, 0x0005e11b, 0x000698dd, 0x00076703, 0x00084e46, 0x000951b2, 0x000a74b4, 0x000bbb1f, 0x000d293d, 0x000ec3de, 0x00109064, 0x001294d8, 0x0014d7fa, 0x0017615c, 0x001a3972, 0x001d69b9, 0x0020fcc8, 0x0024fe7c, 0x00297c17, 0x002e846b, 0x0034280b, 0x003a7977, 0x00418d59, 0x00497ac3, 0x00525b70, 0x005c4c10, 0x00676c9c, 0x0073e0b0, 0x0081cfe9, 0x00916654, 0x00a2d4e2, 0x00b651e1, 0x00cc1986, 0x00e46e7a, 0x00ff9a74, 0x011deed5, 0x013fc551, 0x01658096, 0x018f8cff, 0x01be6137, 0x01f27ee4, 0x022c7340, 0x026cd79c, 0x02b451d1, 0x03039482, 0x035b5f2e, 0x03bc7e07, 0x0427c96c, 0x049e250c, 0x05207e81, 0x05afcb75, 0x064d070b, 0x06f92eaa, 0x07b53dfd, 0x08822a20, 0x0960dc0f, 0x0a522a46, 0x0b56d1cf, 0x0c6f6ed3, 0x0d9c750d, 0x0ede287a, 0x103496c4, 0x119f9209, 0x131eadaa, 0x14b13ded, 0x16565b33, 0x180ce9ad, 0x19d3a65e, 0x1ba93a71, 0x1d8c561e, 0x1f7bd50e, 0x2176efb7, 0x237d8042, 0x259068ea, 0x27b239d6, 0x29e85e5e, 0x2c3d9358, 0x2c3d9358 },
    { 0x00015a3d, 0x00018496, 0x0001b41c, 0x0001e972, 0x0002254b, 0x00026875, 0x0002b3d2, 0x00030865, 0x0003674b, 0x0003d1c7, 0x00044942, 0x0004cf53, 0x000565bf, 0x00060e84, 0x0006cbde, 0x0007a04d, 0x00088ea1, 0x000999fe, 0x000ac5ea, 0x000c165a, 0x000d8fbb, 0x000f3703, 0x001111c1, 0x0013262e, 0x00157b44, 0x001818d1, 0x001b0792, 0x001e5150, 0x002200fc, 0x002622d5, 0x002ac48d, 0x002ff572, 0x0035c6a1, 0x003c4b37, 0x0043988c, 0x004bc673, 0x0054ef7e, 0x005f3151, 0x006aacf0, 0x0077871e, 0x0085e8c1, 0x0095ff52, 0x00a7fd50, 0x00bc1ac0, 0x00d295b6, 0x00ebb2e4, 0x0107be33, 0x01270b61, 0x0149f6a9, 0x0170e564, 0x019c46b1, 0x01cc941a, 0x02025227, 0x023e10e8, 0x02806c60, 0x02ca0cd5, 0x031ba6e8, 0x0375fb74, 0x03d9d725, 0x044811a5, 0x04c18c61, 0x054730be, 0x05d9edb8, 0x067ab4c8, 0x072a7611, 0x07ea1bbc, 0x08ba8480, 0x099c7d61, 0x0a90bac5, 0x0b97d0f4, 0x0cb22c5e, 0x0de009dd, 0x0f216f99, 0x107626d4, 0x11ddb782, 0x1357662a, 0x14e234cf, 0x167ce78f, 0x18260d90, 0x19dc0eb7, 0x1b9d3ebb, 0x1d67f61c, 0x1f3ab1d8, 0x21143bce, 0x22f3df6a, 0x24d9b2b0, 0x26c704ea, 0x28bf1ac3, 0x2ac89c1a },
    { 0x00013db4, 0x00016492, 0x00019030, 0x0001c124, 0x0001f813, 0x000235b8, 0x00027ae6, 0x0002c889, 0x00031fa7, 0x00038169, 0x0003ef1b, 0x00046a32, 0x0004f450, 0x00058f49, 0x00063d2b, 0x00070043, 0x0007db25, 0x0008d0b8, 0x0009e438, 0x000b1949, 0x000c73fe, 0x000df8e8, 0x000fad25, 0x00119671, 0x0013bb39, 0x001622ac, 0x0018d4d9, 0x001bdac6, 0x001f3e88, 0x00230b6c, 0x00274e14, 0x002c14a1, 0x00316edf, 0x00376e77, 0x003e2720, 0x0045aee0, 0x004e1e4d, 0x005790cf, 0x006224f9, 0x006dfcd6, 0x007b3e4d, 0x008a1388, 0x009aab5f, 0x00ad39d5, 0x00c1f894, 0x00d9277b, 0x00f30d27, 0x010ff794, 0x01303caf, 0x01543b01, 0x017c5a46, 0x01a90c0e, 0x01dacc51, 0x021221f5, 0x024f9f3b, 0x0293e210, 0x02df9433, 0x03336b20, 0x039027b0, 0x03f6956a, 0x0467895d, 0x04e3e07d, 0x056c7d6c, 0x06024594, 0x06a61d88, 0x0758e497, 0x081b6f98, 0x08ee82de, 0x09d2cb77, 0x0ac8d7d9, 0x0bd11026, 0x0cebae6d, 0x0e18b736, 0x0f57f2ea, 0x10a8e8ac, 0x120adb23, 0x137cc7f2, 0x14fd6a6e, 0x168b41f7, 0x18249c70, 0x19c7a4f0, 0x1b7276d3, 0x1d23352d, 0x1ed826db, 0x208fd7e6, 0x2249423f, 0x2404024f, 0x25c0a169, 0x27810c5b },
    { 0x00012382, 0x0001472c, 0x00016f34, 0x00019c20, 0x0001ce8a, 0x0002071f, 0x0002469d, 0x00028ddf, 0x0002ddd5, 0x00033791, 0x00039c43, 0x00040d43, 0x00048c0e, 0x00051a56, 0x0005b9fb, 0x00066d1d, 0x0007361a, 0x0008179c, 0x0009149d, 0x000a3077, 0x000b6ee9, 0x000cd426, 0x000e64e4, 0x00102669, 0x00121e9f, 0x00145425, 0x0016ce67, 0x001995b1, 0x001cb351, 0x002031ae, 0x00241c6f, 0x0028809b, 0x002d6cc2, 0x0032f130, 0x00392019, 0x00400dd0, 0x0047d10a, 0x0050831b, 0x005a4044, 0x00652801, 0x00715d64, 0x007f0773, 0x008e5191, 0x009f6bee, 0x00b28c03, 0x00c7ed0e, 0x00dfd0a0, 0x00fa7f27, 0x01184887, 0x013984b0, 0x015e9439, 0x0187e0f6, 0x01b5de87, 0x01e90adc, 0x0221eea5, 0x02611da3, 0x02a736d2, 0x02f4e463, 0x034adb6d, 0x03a9db52, 0x0412acb5, 0x04862003, 0x05050b5f, 0x059047fa, 0x0628aead, 0x06cf13d2, 0x07844255, 0x0848f5f7, 0x091dd4d5, 0x0a036855, 0x0afa15a1, 0x0c021601, 0x0d1b6f69, 0x0e45edb5, 0x0f811d18, 0x10cc464a, 0x12266d14, 0x138e51ac, 0x15027574, 0x1681233c, 0x18087b41, 0x199682cd, 0x1b293725, 0x1cbea389, 0x1e54f9f6, 0x1feaaecd, 0x217e9845, 0x23101435, 0x249f3a0a },
    { 0x00010b74, 0x00012c2f, 0x000150ea, 0x00017a24, 0x0001a868, 0x0001dc54, 0x00021699, 0x000257fe, 0x0002a162, 0x0002f3be, 0x0003502a, 0x0003b7e2, 0x00042c45, 0x0004aee0, 0x0005416e, 0x0005e5e0, 0x00069e66, 0x00076d71, 0x000855bf, 0x00095a63, 0x000a7ecf, 0x000bc6e0, 0x000d36eb, 0x000ed3cb, 0x0010a2ee, 0x0012aa6e, 0x0014f11e, 0x00177ea3, 0x001a5b8c, 0x001d916e, 0x00212b04, 0x0025344f, 0x0029babc, 0x002ecd4d, 0x00347ccc, 0x003adbfa, 0x0041ffc7, 0x0049ff94, 0x0052f577, 0x005cfe84, 0x00683b21, 0x0074cf60, 0x0082e360, 0x0092a3b7, 0x00a441e3, 0x00b7f4c0, 0x00cdf911, 0x00e691fc, 0x0102099f, 0x0120b19f, 0x0142e3b5, 0x01690245, 0x019378e3, 0x01c2bcd7, 0x01f74d86, 0x0231b4c8, 0x02728719, 0x02ba6395, 0x0309f3c0, 0x0361eaf8, 0x03c3058e, 0x042e076a, 0x04a3ba2e, 0x0524eaba, 0x05b2660c, 0x064cf55b, 0x06f5597c, 0x07ac4577, 0x08725869, 0x094816c2, 0x0a2de310, 0x0b23f696, 0x0c2a5a01, 0x0d40deaa, 0x0e6718db, 0x0f9c5baa, 0x10dfb6e2, 0x122ff786, 0x138bab5a, 0x14f127a5, 0x165e934c, 0x17d1f428, 0x19493f27, 0x1ac26ad4, 0x1c3b83a2, 0x1db2c176, 0x1f269e3c, 0x2095eddb, 0x21fff8fe },
    { 0x0000f561, 0x00011369, 0x0001351d, 0x00015af1, 0x00018565, 0x0001b50a, 0x0001ea83, 0x00022686, 0x000269e0, 0x0002b575, 0x00030a47, 0x00036978, 0x0003d44a, 0x00044c2a, 0x0004d2ae, 0x000569a1, 0x00061303, 0x0006d113, 0x0007a656, 0x000895a0, 0x0009a21a, 0x000acf53, 0x000c2145, 0x000d9c66, 0x000f45b8, 0x001122d4, 0x00133a01, 0x00159248, 0x0018338a, 0x001b2698, 0x001e7552, 0x00222ac5, 0x0026534d, 0x002afcbf, 0x00303691, 0x0036120a, 0x003ca279, 0x0043fd6b, 0x004c3aef, 0x005575d8, 0x005fcc0d, 0x006b5edb, 0x00785351, 0x0086d29e, 0x00970a82, 0x00a92dba, 0x00bd747a, 0x00d41cec, 0x00ed6bb3, 0x0109ac78, 0x0129326d, 0x014c58db, 0x017383a4, 0x019f1fc1, 0x01cfa3a9, 0x02058fa5, 0x02416e05, 0x0283d325, 0x02cd5d3f, 0x031eb3f2, 0x03788770, 0x03db8f4b, 0x044888b9, 0x04c03453, 0x05435330, 0x05d2a349, 0x066edb2f, 0x0718a4fc, 0x07d0988c, 0x08973525, 0x096cda96, 0x0a51c229, 0x0b45f791, 0x0c495259, 0x0d5b702a, 0x0e7bb07e, 0x0fa93225, 0x10e2d337, 0x122733b3, 0x1374bb25, 0x14c9a15c, 0x1623fa08, 0x1781c2ea, 0x18e0f412, 0x1a3f9171, 0x1b9bbd16, 0x1cf3c978, 0x1e464b68, 0x1f922bcd },
    { 0x0000e11e, 0x0000fcac, 0x00011b98, 0x00013e4e, 0x00016542, 0x000190fa, 0x0001c20b, 0x0001f91c, 0x000236e9, 0x00027c45, 0x0002ca1c, 0x00032177, 0x0003837f, 0x0003f183, 0x00046cf8, 0x0004f783, 0x000592fa, 0x0006416e, 0x0007052f, 0x0007e0d6, 0x0008d74b, 0x0009ebd3, 0x000b2215, 0x000c7e2b, 0x000e04ae, 0x000fbac5, 0x0011a636, 0x0013cd77, 0x001637c8, 0x0018ed45, 0x001bf703, 0x001f5f2e, 0x00233125, 0x002779a4, 0x002c46e6, 0x0031a8d4, 0x0037b136, 0x003e73e9, 0x00460715, 0x004e8376, 0x0058049e, 0x0062a942, 0x006e9393, 0x007be994, 0x008ad580, 0x009b8635, 0x00ae2fa0, 0x00c30b37, 0x00da5874, 0x00f45d57, 0x011166e5, 0x0131c9a9, 0x0155e238, 0x017e159e, 0x01aad1cc, 0x01dc8de6, 0x0213ca77, 0x02511184, 0x0294f65e, 0x02e01541, 0x03331297, 0x038e99df, 0x03f35c20, 0x04620dd2, 0x04db643a, 0x05601213, 0x05f0c392, 0x068e19b1, 0x0738a4cd, 0x07f0deae, 0x08b72410, 0x098badee, 0x0a6e8ac7, 0x0b5f984a, 0x0c5e7dba, 0x0d6aa797, 0x0e8344f7, 0x0fa74701, 0x10d562ef, 0x120c16cf, 0x1349b11d, 0x148c5b0d, 0x15d22535, 0x17191617, 0x185f39d1, 0x19a2b23c, 0x1ae1c6c5, 0x1c1af35e, 0x1d4cf631 },
    { 0x0000ce86, 0x0000e7ce, 0x0001042d, 0x00012405, 0x000147c3, 0x00016fe0, 0x00019ce5, 0x0001cf6c, 0x00020821, 0x000247c6, 0x00028f33, 0x0002df5c, 0x00033951, 0x00039e46, 0x00040f92, 0x00048eb7, 0x00051d65, 0x0005bd81, 0x0006712b, 0x00073ac6, 0x00081cfd, 0x00091ad1, 0x000a379d, 0x000b7727, 0x000cdda7, 0x000e6fd9, 0x0010330c, 0x00122d31, 0x001464f0, 0x0016e1bf, 0x0019abf9, 0x001cccf7, 0x00204f2f, 0x00243e58, 0x0028a78a, 0x002d996a, 0x00332455, 0x00395a94, 0x0040508f, 0x00481d0e, 0x0050d976, 0x005aa213, 0x0065966a, 0x0071d987, 0x007f925d, 0x008eec29, 0x00a016d7, 0x00b34775, 0x00c8b8a4, 0x00e0ab12, 0x00fb65f0, 0x01193773, 0x013a7543, 0x015f7cf0, 0x0188b453, 0x01b689db, 0x01e974ca, 0x0221f53d, 0x02609415, 0x02a5e299, 0x02f279d5, 0x0346f998, 0x03a4070e, 0x040a4ad7, 0x047a6e97, 0x04f519e7, 0x057aeea3, 0x060c8490, 0x06aa6459, 0x075501f9, 0x080cb6b6, 0x08d1bac3, 0x09a41ef0, 0x0a83c696, 0x0b706236, 0x0c696b2c, 0x0d6e20f1, 0x0e7d8855, 0x0f966cfa, 0x10b76567, 0x11ded9b8, 0x130b0ccd, 0x143a27b8, 0x156a46de, 0x16998831, 0x17c619c7, 0x18ee480b, 0x1a108ae8, 0x1b2b9167 },
    { 0x0000bd76, 0x0000d4a7, 0x0000eeaf, 0x00010be7, 0x00012cb1, 0x0001517f, 0x00017acd, 0x0001a929, 0x0001dd31, 0x00021796, 0x00025920, 0x0002a2ad, 0x0002f539, 0x000351dd, 0x0003b9d4, 0x00042e80, 0x0004b16e, 0x0005445d, 0x0005e93f, 0x0006a244, 0x000771e2, 0x00085ad9, 0x0009603f, 0x000a858a, 0x000bce9c, 0x000d3fcd, 0x000eddfe, 0x0010aea5, 0x0012b7e0, 0x0015008a, 0x00179050, 0x001a6fcc, 0x001da89b, 0x00214582, 0x0025528d, 0x0029dd33, 0x002ef483, 0x0034a94f, 0x003b0e5f, 0x004238aa, 0x004a3f93, 0x00533d28, 0x005d4e6f, 0x006893b3, 0x007530d9, 0x00834dbc, 0x0093168b, 0x00a4bc35, 0x00b874d3, 0x00ce7c16, 0x00e713bc, 0x01028400, 0x01211c0c, 0x01433261, 0x01692533, 0x01935aba, 0x01c24165, 0x01f64fee, 0x02300543, 0x026fe838, 0x02b686f5, 0x03047611, 0x035a4f47, 0x03b8afbe, 0x042035c7, 0x04917e13, 0x050d2048, 0x0593aaf7, 0x06259eff, 0x06c36a55, 0x076d6267, 0x0823be2c, 0x08e6902d, 0x09b5c0c6, 0x0a910909, 0x0b77ee8d, 0x0c69c0ae, 0x0d659798, 0x0e6a5565, 0x0f76a99c, 0x1089171d, 0x119ffc66, 0x12b99de6, 0x13d431f4, 0x14ededce, 0x160512e7, 0x1717fbde, 0x1825286a, 0x192b47b2 },
    { 0x0000adce, 0x0000c315, 0x0000daf7, 0x0000f5c5, 0x000113da, 0x0001359e, 0x00015b84, 0x0001860c, 0x0001b5c9, 0x0001eb5d, 0x0002277e, 0x00026afb, 0x0002b6b8, 0x00030bb9, 0x00036b1e, 0x0003d62d, 0x00044e52, 0x0004d526, 0x00056c74, 0x0006163e, 0x0006d4c5, 0x0007aa91, 0x00089a77, 0x0009a7a4, 0x000ad5aa, 0x000c2886, 0x000da4b2, 0x000f4f33, 0x00112da9, 0x0013465e, 0x0015a062, 0x0018439b, 0x001b38df, 0x001e8a15, 0x00224250, 0x00266df0, 0x002b1ace, 0x00305862, 0x003637f3, 0x003ccccb, 0x00442c6d, 0x004c6ed4, 0x0055aeb8, 0x006009d3, 0x006ba132, 0x0078998c, 0x00871b95, 0x00975467, 0x00a975de, 0x00bdb706, 0x00d45482, 0x00ed90f8, 0x0109b57d, 0x012911ee, 0x014bfd57, 0x0172d631, 0x019e029b, 0x01cdf070, 0x02031533, 0x023dedd0, 0x027efe12, 0x02c6cfd9, 0x0315f1f0, 0x036cf676, 0x03cc70cf, 0x0434f315, 0x04a70af1, 0x05233de3, 0x05aa04fa, 0x063bc806, 0x06d8d852, 0x07816b2a, 0x0835943d, 0x08f54038, 0x09c02fec, 0x0a95f44f, 0x0b75ebc5, 0x0c5f4109, 0x0d50ec0c, 0x0e49b4f5, 0x0f48396b, 0x104af40a, 0x115045c1, 0x125680c5, 0x135bf472, 0x145ef986, 0x155dfe0a, 0x16579042, 0x174a6820 },
    { 0x00009f71, 0x0000b2f6, 0x0000c8de, 0x0000e176, 0x0000fd0f, 0x00011c09, 0x00013ece, 0x000165d3, 0x0001919f, 0x0001c2c7, 0x0001f9f2, 0x000237dd, 0x00027d5b, 0x0002cb59, 0x000322e0, 0x0003851a, 0x0003f358, 0x00046f0f, 0x0004f9e5, 0x000595b2, 0x00064487, 0x000708b8, 0x0007e4de, 0x0008dbe4, 0x0009f110, 0x000b280c, 0x000c84f6, 0x000e0c69, 0x000fc38e, 0x0011b02f, 0x0013d8c7, 0x00164497, 0x0018fbbf, 0x001c0757, 0x001f718c, 0x002345bf, 0x002790aa, 0x002c6085, 0x0031c533, 0x0037d070, 0x003e9604, 0x00462bff, 0x004eaaf5, 0x00582e40, 0x0062d44c, 0x006ebee2, 0x007c137e, 0x008afba7, 0x009ba54a, 0x00ae4320, 0x00c30d09, 0x00da4079, 0x00f420d1, 0x0110f7c2, 0x0131159d, 0x0154d19b, 0x017c8a0e, 0x01a8a479, 0x01d98d81, 0x020fb8b5, 0x024ba016, 0x028dc35b, 0x02d6a6e6, 0x0326d24f, 0x037ece84, 0x03df236b, 0x04485503, 0x04badff1, 0x05373590, 0x05bdb779, 0x064eb2ab, 0x06ea5a69, 0x0790c302, 0x0841dcc7, 0x08fd6f74, 0x09c31669, 0x0a923e06, 0x0b6a2289, 0x0c49d0ad, 0x0d302852, 0x0e1be132, 0x0f0b919f, 0x0ffdb710, 0x10f0c01e, 0x11e3176c, 0x12d32eeb, 0x13bf8ad2, 0x14a6cbb7, 0x1587b740 }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\mixf.cpp ===
//      Mixf.cpp
//      Copyright (c) Microsoft Corporation	1996-1999
//      Filtered Mix Engine

#include "simple.h"
#include <mmsystem.h>
#include "synth.h"

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#pragma message ("Programer note: property hack")
//#define DEBUG_DUMP_FILE

#pragma warning(disable : 4101 4102 4146)  

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#ifdef DEBUG_DUMP_FILE
DWORD dmp_bufsize = 4000000;
DWORD dmp_samplesrecorded;
DWORD dmp_buffercount;
short dmp_soundbuffer[4000000];
#endif
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

DWORD CDigitalAudio::Mix16Filtered(
	short **ppBuffers,
	DWORD *pdwChannels,
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
	VFRACT vfDeltaLVolume, 
	VFRACT vfDeltaRVolume,
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFFDELTA cfdK,
    COEFFDELTA cfdB1,
    COEFFDELTA cfdB2)
{
    DWORD dwI;
	DWORD dwIndex;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  
    VFRACT vfRVFract = vfRVolume << 8; 
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
    
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
    		    pfSamplePos -= pfLoopLength;
			}
	        else
	    	    break;
	    }

        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract  += pfDeltaPitch;
            pfPitch    = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume  = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume  = vfRVFract >> 8;
            cfK       += cfdK;
            cfB1      += cfdB1;
            cfB2      += cfdB2;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

		// Interpolate 
        lA = (long)pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

		//
        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// >>>> We store the negative of b1 in the table, so we flip the sign again by
		// >>>> adding here
		// >>>> Lookinto simply using a float here, it may just be faster, save a div 
		//
        lM = MulDiv(lM, cfK, (1 << 30))
           + MulDiv(m_lPrevSample, cfB1, (1 << 30))
           - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

		//
		//
		//
        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lM;

		//
		//
		//
		lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;

		dwIndex = 0;
		while ( dwIndex < dwBufferCount )
		{
			short *pBuffer = &ppBuffers[dwIndex][dwI];

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_LEFT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lA;

				_asm{jno no_oflowl}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowl}
				*pBuffer = (short) 0x8000;
			}
no_oflowl:	
			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_RIGHT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lM;

				_asm{jno no_oflowr}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowr}
				*pBuffer = (short) 0x8000;
			}
no_oflowr:
			dwIndex++;
		}

#ifdef DEBUG_DUMP_FILE
dmp_soundbuffer[dmp_samplesrecorded] = pBuffer[dwI];
if (dmp_samplesrecorded < dmp_bufsize)
	dmp_samplesrecorded++ ;
#endif

		dwI++;
    }

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch   = pfPitch;
    m_pfLastSample  = pfSamplePos;
	m_cfLastK  = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;

    return (dwI);
}


DWORD CDigitalAudio::Mix16FilteredInterleaved(
	short **ppBuffers,
	DWORD *pdwChannels,
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
	VFRACT vfDeltaLVolume, 
	VFRACT vfDeltaRVolume,
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFFDELTA cfdK,
    COEFFDELTA cfdB1,
    COEFFDELTA cfdB2)
{
    DWORD dwI;
	DWORD dwIndex;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  
    VFRACT vfRVFract = vfRVolume << 8; 
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
	dwLength <<= 1;
    
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
    		    pfSamplePos -= pfLoopLength;
			}
	        else
	    	    break;
	    }

        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract  += pfDeltaPitch;
            pfPitch    = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume  = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume  = vfRVFract >> 8;
            cfK       += cfdK;
            cfB1      += cfdB1;
            cfB2      += cfdB2;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

		// Interpolate 
        lA = (long)pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

		//
        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// >>>> We store the negative of b1 in the table, so we flip the sign again by
		// >>>> adding here
		// >>>> Lookinto simply using a float here, it may just be faster, save a div 
		//
        lM = MulDiv(lM, cfK, (1 << 30))
           + MulDiv(m_lPrevSample, cfB1, (1 << 30))
           - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

		//
		//
		//
        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lM;

		//
		//
		//
		lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;

		dwIndex = 0;
		while ( dwIndex < dwBufferCount )
		{
			short *pBuffer = &ppBuffers[dwIndex][dwI];

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_LEFT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lA;

				_asm{jno no_oflowl}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowl}
				*pBuffer = (short) 0x8000;
			}
no_oflowl:	
			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_RIGHT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				pBuffer++;
				*pBuffer += (short) lM;

				_asm{jno no_oflowr}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowr}
				*pBuffer = (short) 0x8000;
			}
no_oflowr:
			dwIndex++;
		}

#ifdef DEBUG_DUMP_FILE
dmp_soundbuffer[dmp_samplesrecorded] = pBuffer[dwI];
if (dmp_samplesrecorded < dmp_bufsize)
	dmp_samplesrecorded++ ;
#endif

		dwI += 2;
    }

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch   = pfPitch;
    m_pfLastSample  = pfSamplePos;
	m_cfLastK  = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;

    return (dwI >> 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\mixmulti.cpp ===
//      Mix.cpp
//      Copyright (c) Microsoft Corporation	1996, 1998
//      Mix engines for MSSynth

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#define STR_MODULENAME "DMusicMix:"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#endif

///////////////////////////////////////////////////////
// Modifications 
// member m_nChannels => parameter dwBufferCount
//
// Changed number of arguments into Filtered mixers
//
// Remove range checking after filter 

#pragma warning(disable : 4101 4102 4146)  

#ifdef _ALPHA_

extern "C" {
	int __ADAWI(short, short *);
};
#pragma intrinsic(__ADAWI)

#define ALPHA_OVERFLOW 2 
#define ALPHA_NEGATIVE 8

#else // !_ALPHA_
//  TODO -- overflow detection for ia64 (+ axp64?)
#endif // !_ALPHA_
#ifdef DMSYNTH_MINIPORT
#pragma code_seg("PAGE")
#endif // DMSYNTH_MINIPORT

#define USE_MMX
#define USE_MMX_FILTERED

#ifdef i386 // {
DWORD CDigitalAudio::MixMulti8(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
    VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    long lA;//, lB;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }   
	
#if 1 // {
	DWORD l_nChannels = dwBufferCount;
#if 1 // {
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
#ifdef USE_MMX // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off    
	cmp	Use_MMX, 0
	je	AssignMmxLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX

	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi

	}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00 \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
    _asm _emit 0x89 _asm _emit 0x42 _asm _emit 0x00

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43860:
_asm {
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
//	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm5, mm6
	psraw		mm5, 8
	movd		esi, mm4
//	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm4, mm6
	psraw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1
	psrad		mm6, 12								// lMIntrep2, lMInterp
//	pand		mm6, QWORD PTR ffffMask
//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.

	movq		mm4, mm5
	mov	esi, DWORD PTR [ecx+4]

	punpckldq	mm4, mm4
	pmaddwd		mm4, mm6
	psrad		mm4, 5
	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2

	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
	mov	esi, DWORD PTR [ecx+8]

	pmaddwd		mm5, mm6
	psrad		mm5, 5
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // There is noise here, probably due to the signed nature of the multiply.
	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }

$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, BYTE PTR [eax+edx]
	movsx	eax, BYTE PTR [eax+edx+1]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches

	add	eax, esi		// lMInterp
	jmp	edi

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 5;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 5
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms
NoMmxCleanupLabel:
#endif
}
#else // }{
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;

#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1]; \
			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
            for (dwJ = 0; dwJ < l_nChannels; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
#endif
        }

#if 1 // {
		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;
		DWORD b = dwLength - dwI;

		if (b < a) a = b;
		if (dwIncDelta < a) a = dwIncDelta;

		dwIncDelta -= a - 1;
		a          += dwI;

		for (; dwI < a; dwI++)
		{
			dwPosition = pfSamplePos >> 12;
			dwFract = pfSamplePos & 0xFFF;
			pfSamplePos += pfPitch;

			lA = (long) pcWave[dwPosition];
			lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1 // {
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else // }{
			for (dwJ = 0; dwJ < l_nChannels; dwJ++)
			{
				lM = lMInterp * vfVolume[dwJ]; 
				lM >>= 5;         // Signal bumps up to 12 bits.

				// Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
				ppBuffer[dwJ][dwI] += (short) lM;
				_asm{jno no_oflow}
				ppBuffer[dwJ][dwI] = 0x7fff;
				_asm{js  no_oflow}
				ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
			}
#endif // }
		}
#else // }{
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
        for (dwJ = 0; dwJ < l_nChannels; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 5;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
        }
#endif
		dwI++;
#endif // }
    }
#endif // }
#else // }{
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
        }
		dwI++;
    }
#endif // }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}
                        
DWORD CDigitalAudio::MixMulti8Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 
	DWORD dMM6[2];

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

#if 1 // {
	DWORD l_nChannels = dwBufferCount;
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
	long l_lPrevPrevSample = m_lPrevPrevSample, l_lPrevSample = m_lPrevSample;

#ifdef USE_MMX_FILTERED // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off    
	cmp	Use_MMX, 0
	je	AssignMmxLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX

	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi

	}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00  \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
    _asm _emit 0x89 _asm _emit 0x42 _asm _emit 0x00

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1

_asm {
	//	cfK += cfdK;
	//	cfB1 += cfdB1;
	//	cfB2 += cfdB2;

	mov	eax, DWORD PTR cfdK
	mov	edx, DWORD PTR cfdB1
	
	mov	esi, DWORD PTR cfdB2
	add	DWORD PTR cfK, eax

	add DWORD PTR cfB1, edx
	add	DWORD PTR cfB2, esi

$L43860:
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX_FILTERED // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
//	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm5, mm6
	psraw		mm5, 8
	movd		esi, mm4
//	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm4, mm6
	psraw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1
	psrad		mm6, 12								// lMIntrep2, lMInterp

#if 1
	//	eax, ebx, ecx, edx, esi are used.	edi is free...
	push	eax
	push	ecx
	push	edx

	movq	QWORD PTR dMM6, mm6

	mov		eax, DWORD PTR dMM6
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx


	mov	DWORD PTR dMM6, eax
	mov	DWORD PTR l_lPrevSample, eax

	//	2nd sample

	mov		eax, DWORD PTR dMM6+4
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx

	mov	DWORD PTR dMM6+4, eax
	mov	DWORD PTR l_lPrevSample, eax

	movq	mm6, QWORD PTR dMM6

	pop		edx
	pop		ecx
	pop		eax
#endif
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1

//	pand		mm6, QWORD PTR ffffMask
	
//	packssdw	mm6, mm0				// 		Saturate to 16 bits, instead.
//	punpcklwd	mm6, mm0

//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.

	movq		mm4, mm5
	mov	esi, DWORD PTR [ecx+4]

	punpckldq	mm4, mm4
	pmaddwd		mm4, mm6
	psrad		mm4, 5
	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2

	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
	mov	esi, DWORD PTR [ecx+8]

	pmaddwd		mm5, mm6
	psrad		mm5, 5
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // There is noise here, probably due to the signed nature of the multiply.
	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }

$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, BYTE PTR [eax+edx]
	movsx	eax, BYTE PTR [eax+edx+1]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches

	add	eax, esi		// lMInterp

//	lMInterp =
//		MulDiv(lMInterp, cfK, (1 << 30))
//		- MulDiv(m_lPrevPrevSample, cfB2, (1 << 30))
//		+ MulDiv(m_lPrevSample, cfB1, (1 << 30))

	push	ecx
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		esi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		esi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx			// esi:eax
	adc		esi, edx

	pop		ecx
//	shrd	eax, esi, 30
		
//>>>>> MOD:PETCHEY 
//	shld	eax, esi, 2
//>>>>> should be 
	shld	esi, eax, 2
	mov		eax, esi

//>>>>>>>>>>>> removed dp
#if 0 
//	if (lMInterp < -32767) lMInterp = -32767;
//	else if (lMInterp > 32767) lMInterp = 32767;

	cmp		eax, -32767
	jl		Less_than
	cmp		eax, 32767
	jg		Greater_than
#endif

//	m_lPrevPrevSample = m_lPrevSample;
//	m_lPrevSample = lMInterp;

	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

Less_than:
	mov	eax, -32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

Greater_than:
	mov	eax, 32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 5;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 5
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX_FILTERED
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms
NoMmxCleanupLabel:
#endif
}
	m_lPrevPrevSample = l_lPrevPrevSample;
	m_lPrevSample     = l_lPrevSample;
#else // }{
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
            cfB2 += cfdB2;
        }
	    
	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;

        // Filter
        //
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            - MulDiv(m_lPrevSample, cfB1, (1 << 30))
            + MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
        }
		dwI++;
    }
#endif // }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}

#if 0
DWORD CDigitalAudio::MixMulti16(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;


        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
#endif
no_oflow:	;
        }
		dwI++;
    }
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }
    return (dwI);
}
#else
DWORD CDigitalAudio::MixMulti16(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 


    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

#if 1 // {
	DWORD l_nChannels = dwBufferCount;
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
#ifdef USE_MMX // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off
	cmp	Use_MMX, 0
	je	AssignMMXLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX
	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi

	}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00 \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx], eax };

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43860:
_asm {
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm5, mm6
//	psarw		mm5, 8
	movd		esi, mm4
	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm4, mm6
//	psarw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1
	psrad		mm6, 12								// lMIntrep2, lMInterp
//	pand		mm6, QWORD PTR ffffMask
//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.

	movq		mm4, mm5
	mov	esi, DWORD PTR [ecx+4]

	punpckldq	mm4, mm4
	pmaddwd		mm4, mm6
	psrad		mm4, 13
	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2

	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
	mov	esi, DWORD PTR [ecx+8]

	pmaddwd		mm5, mm6
	psrad		mm5, 13
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // There is noise here, probably due to the signed nature of the multiply.
	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }


$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, WORD PTR [eax+edx*2]
	movsx	eax, WORD PTR [eax+edx*2+2]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches

	add	eax, esi		// lMInterp
	jmp	edi

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 13;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 13
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms
NoMmxCleanupLabel:
#endif
}
#else // }{
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;

#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1]; \
			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
            for (dwJ = 0; dwJ < l_nChannels; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
#endif
        }

#if 1 // {
		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;
		DWORD b = dwLength - dwI;

		if (b < a) a = b;
		if (dwIncDelta < a) a = dwIncDelta;

		dwIncDelta -= a - 1;
		a          += dwI;

		for (; dwI < a; dwI++)
		{
			dwPosition = pfSamplePos >> 12;
			dwFract = pfSamplePos & 0xFFF;
			pfSamplePos += pfPitch;

			lA = (long) pcWave[dwPosition];
			lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1 // {
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else // }{
			for (dwJ = 0; dwJ < l_nChannels; dwJ++)
			{
				lM = lMInterp * vfVolume[dwJ]; 
				lM >>= 13;         // Signal bumps up to 12 bits.

				// Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
				ppBuffer[dwJ][dwI] += (short) lM;
				_asm{jno no_oflow}
				ppBuffer[dwJ][dwI] = 0x7fff;
				_asm{js  no_oflow}
				ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
			}
#endif // }
		}
#else // }{
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
        for (dwJ = 0; dwJ < l_nChannels; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
        }
#endif
		dwI++;
#endif // }
    }
#endif // }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    return (dwI);
}
#endif

DWORD CDigitalAudio::MixMulti16Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
	DWORD dMM6[2];					// Handle filter...
	DWORD dMM4[2];					// Handle filter...
	DWORD dMM5[2];					// Handle filter...
    
    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

#if 1 // {
	DWORD l_nChannels = dwBufferCount;
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
	long l_lPrevPrevSample = m_lPrevPrevSample, l_lPrevSample = m_lPrevSample;

#ifdef USE_MMX_FILTERED // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off
	cmp	Use_MMX, 0
	je	AssignMMXLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX
	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi
}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer - 4
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00 \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
    _asm _emit 0x89 _asm _emit 0x42 _asm _emit 0x00

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1

_asm {
	//	cfK += cfdK;
	//	cfB1 += cfdB1;
	//	cfB2 += cfdB2;

	mov	eax, DWORD PTR cfdK
	mov	edx, DWORD PTR cfdB1
	
	mov	esi, DWORD PTR cfdB2
	add	DWORD PTR cfK, eax

	add DWORD PTR cfB1, edx
	add	DWORD PTR cfB2, esi

$L43860:
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX_FILTERED // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm5, mm6
//	psarw		mm5, 8
	movd		esi, mm4
	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm4, mm6
//	psarw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1 // {
	psrad		mm6, 12								// lMIntrep2, lMInterp

#if 1 // {
	//	eax, ebx, ecx, edx, esi are used.	edi is free...
	push	eax
	push	ecx
	push	edx

	movq	QWORD PTR dMM6, mm6

	mov		eax, DWORD PTR dMM6
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx

	mov	DWORD PTR dMM6, eax
	mov	DWORD PTR l_lPrevSample, eax

	//	2nd sample

	mov		eax, DWORD PTR dMM6+4
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx

	mov	DWORD PTR dMM6+4, eax
	mov	DWORD PTR l_lPrevSample, eax

	movq	mm6, QWORD PTR dMM6

	pop		edx
	pop		ecx
	pop		eax
#endif // }

#define DO_32BIT_MULTIPLY
#ifndef DO_32BIT_MULTIPLY
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1
//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.
#endif

//	pand		mm6, QWORD PTR ffffMask

#ifndef DO_32BIT_MULTIPLY
	movq		mm4, mm5
#endif
	mov	esi, DWORD PTR [ecx+4]

#ifndef DO_32BIT_MULTIPLY
	punpckldq	mm4, mm4
#endif

#ifdef DO_32BIT_MULTIPLY
	mov			edi, DWORD PTR vfVolume
	imul		edi, DWORD PTR dMM6
	sar			edi, 13
	mov			DWORD PTR dMM4, edi

	mov			edi, DWORD PTR vfVolume
	imul		edi, DWORD PTR dMM6+4
	sar			edi, 13
	mov			DWORD PTR dMM4+4, edi

	movq		mm4, QWORD PTR dMM4
#else
	pmaddwd		mm4, mm6
	psrad		mm4, 13
#endif

	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2


#ifndef DO_32BIT_MULTIPLY
	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
#endif
	mov	esi, DWORD PTR [ecx+8]

#ifdef DO_32BIT_MULTIPLY
	mov			edi, DWORD PTR vfVolume+4
	imul		edi, DWORD PTR dMM6
	sar			edi, 13
	mov			DWORD PTR dMM5, edi

	mov			edi, DWORD PTR vfVolume+4
	imul		edi, DWORD PTR dMM6+4
	sar			edi, 13
	mov			DWORD PTR dMM5+4, edi

	movq		mm5, QWORD PTR dMM5
#else
	pmaddwd		mm5, mm6
	psrad		mm5, 13
#endif
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // }{ There is noise here, probably due to the signed nature of the multiply.

	// NOTE the filter is NOT implemented here....

	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif // }

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }

$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, WORD PTR [eax+edx*2]
	movsx	eax, WORD PTR [eax+edx*2+2]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches
	add	eax, esi		// lMInterp

#if 1 
//	lMInterp =
//		MulDiv(lMInterp, cfK, (1 << 30))
//		- MulDiv(m_lPrevPrevSample, cfB2, (1 << 30))
//		+ MulDiv(m_lPrevSample, cfB1, (1 << 30))

	push	ecx
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		esi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		esi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
//	adc		esi, edx
	adc		edx, esi

	pop		ecx
//	shrd	eax, edx, 30
//	mov		esi,0x40000000
//	idiv	esi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx
#endif
	
//>>>>>>>>>>>> removed dp
#if 0 
//	if (lMInterp < -32767) lMInterp = -32767;
//	else if (lMInterp > 32767) lMInterp = 32767;

	cmp		eax, -32767
	jl		Less_than
	cmp		eax, 32767
	jg		Greater_than
#endif

//	m_lPrevPrevSample = m_lPrevSample;
//	m_lPrevSample = lMInterp;

	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

//>>>>>>>>>>>> removed dp
#if 0 
Less_than:
	mov	eax, -32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

Greater_than:
	mov	eax, 32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi
#endif

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 13;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 13
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 


    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX_FILTERED
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms

NoMmxCleanupLabel:
#endif
}

	m_lPrevPrevSample = l_lPrevPrevSample;
	m_lPrevSample     = l_lPrevSample;
#else // }{
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
           cfB2 += cfdB2;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// We store the negative of b1 in the table, so we flip the sign again by
		// adding here
		//
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            + MulDiv(m_lPrevSample, cfB1, (1 << 30))
            - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

//>>>>>>>>>>>> removed dp
#if 0 
		if (lMInterp < -32767) lMInterp = -32767;
		else if (lMInterp > 32767) lMInterp = 32767;
#endif
        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
        }
		dwI++;
    }
#endif // }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

	m_cfLastK = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    return (dwI);
}

#else // }{     all assembly code
DWORD CDigitalAudio::MixMulti8(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
    VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    long lA;//, lB;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }   
	
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;
	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
#endif
        }
		dwI++;
    }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}
                        
DWORD CDigitalAudio::MixMulti8Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 
	DWORD dMM6[2];

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
            cfB2 += cfdB2;
        }
	    
	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;

        // Filter
        //
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            - MulDiv(m_lPrevSample, cfB1, (1 << 30))
            + MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
#endif
        }
		dwI++;
    }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}

DWORD CDigitalAudio::MixMulti16(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI = 0;
    DWORD dwJ = 0;
    DWORD dwPosition = 0;
    long lA = 0;//, lB;
    long lM = 0;
    long lMInterp = 0;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
#endif
        }
		dwI++;
    }
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }
    return (dwI);
}

DWORD CDigitalAudio::MixMulti16Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
	DWORD dMM6[2];					// Handle filter...
    
    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
           cfB2 += cfdB2;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// We store the negative of b1 in the table, so we flip the sign again by
		// adding here
		//
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            + MulDiv(m_lPrevSample, cfB1, (1 << 30))
            - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

//>>>>>>>>>>>> removed dp
#if 0 
		if (lMInterp < -32767) lMInterp = -32767;
		else if (lMInterp > 32767) lMInterp = 32767;
#endif
        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
#endif
        }
		dwI++;
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

	m_cfLastK = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    return (dwI);
}

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\mixc.cpp ===
//      Mixc.cpp
//      Copyright (c) Microsoft Corporation	1996-1999
//      C version of the Mix Engine

#include "simple.h"
#include <mmsystem.h>
#include "synth.h"

#pragma warning(disable : 4101 4102 4146)  

DWORD CDigitalAudio::Mix16(
	short **ppBuffers,
	DWORD *pdwChannels,
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
	VFRACT vfDeltaLVolume, 
	VFRACT vfDeltaRVolume,
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI;
	DWORD dwIndex;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  
    VFRACT vfRVFract = vfRVolume << 8; 
    
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
    		    pfSamplePos -= pfLoopLength;
			}
	        else
	    	    break;
	    }

        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract  += pfDeltaPitch;
            pfPitch    = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume  = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume  = vfRVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

		// Interpolate 
        lA = (long)pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

		lA = lM;
		lA *= vfLVolume;
		lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;

		dwIndex = 0;
		while ( dwIndex < dwBufferCount )
		{
			short *pBuffer = &ppBuffers[dwIndex][dwI];

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_LEFT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lA;

				_asm{jno no_oflowl}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowl}
				*pBuffer = (short) 0x8000;
			}
no_oflowl:	

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_RIGHT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lM;

				_asm{jno no_oflowr}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowr}
				*pBuffer = (short) 0x8000;
			}
no_oflowr:
			dwIndex++;
		}

		dwI++;
	}

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch   = pfPitch;
    m_pfLastSample  = pfSamplePos;

    return (dwI);
}

DWORD CDigitalAudio::Mix16InterLeaved(
	short **ppBuffers,
	DWORD *pdwChannels,
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
	VFRACT vfDeltaLVolume, 
	VFRACT vfDeltaRVolume,
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI;
	DWORD dwIndex;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  
    VFRACT vfRVFract = vfRVolume << 8; 
	dwLength <<= 1;
    
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
    		    pfSamplePos -= pfLoopLength;
			}
	        else
	    	    break;
	    }

        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract  += pfDeltaPitch;
            pfPitch    = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume  = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume  = vfRVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

		// Interpolate 
        lA = (long)pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

		lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;

		dwIndex = 0;
		while ( dwIndex < dwBufferCount )
		{
			short *pBuffer = &ppBuffers[dwIndex][dwI];

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_LEFT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lA;

				_asm{jno no_oflowl}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowl}
				*pBuffer = (short) 0x8000;
			}
no_oflowl:	

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_RIGHT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				pBuffer++;
				*pBuffer += (short) lM;

				_asm{jno no_oflowr}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowr}
				*pBuffer = (short) 0x8000;
			}
no_oflowr:
			dwIndex++;
		}

		dwI += 2;
	}

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch   = pfPitch;
    m_pfLastSample  = pfSamplePos;

    return (dwI >> 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\miniport.cpp ===
// Copyright (c) 1998 Microsoft Corporation
//
// DirectMusic Software Synthesizer
//
#include "common.h"
#include "private.h"
#include "dmusicks.h"


#define STR_MODULENAME "DmSynth: "

#pragma code_seg("PAGE")


// Property handlers
//
NTSTATUS PropertyHandler_SynthCaps(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_SynthPortParameters(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_SynthMasterClock(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_SynthPortChannelGroups(IN PPCPROPERTY_REQUEST);

NTSTATUS PropertyHandler_DlsDownload(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_DlsUnload(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_DlsCompact(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_DlsAppend(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_DlsVolume(IN PPCPROPERTY_REQUEST);


NTSTATUS PropertyHandler_GetLatency(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_GetLatencyClock(IN PPCPROPERTY_REQUEST);

// CreateMiniportDirectMusic
//
//
NTSTATUS CreateMiniportDmSynth
(
    OUT PUNKNOWN *  Unknown,
    IN  PUNKNOWN    UnknownOuter OPTIONAL,
    IN  POOL_TYPE   PoolType
)
{
    PAGED_CODE();
    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_TERSE, ("Creating DirectMusic synth miniport"));
    STD_CREATE_BODY(CMiniportDmSynth, Unknown, UnknownOuter, PoolType);
}

STDMETHODIMP CMiniportDmSynth::NonDelegatingQueryInterface
(
    IN  REFIID      Interface,
    OUT PVOID*      Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportSynthesizer))
    {
        *Object = PVOID(PMINIPORTSYNTHESIZER(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

CMiniportDmSynth::~CMiniportDmSynth()
{
}

STDMETHODIMP CMiniportDmSynth::Init
(
    IN  PUNKNOWN            Unknown OPTIONAL,
    IN  PRESOURCELIST       ResourceList,
    IN  PPORTSYNTHESIZER    Port_,
    OUT PSERVICEGROUP*      ServiceGroup
)
{
    _DbgPrintF(DEBUGLVL_TERSE, ("[CMiniportDmSynth::Init]"));
    ASSERT(ResourceList);
    ASSERT(Port_);
    ASSERT(ServiceGroup);

    
    Port = Port_;
    Port->AddRef();   

    Stream = NULL;
    
    *ServiceGroup = NULL;
    
    return STATUS_SUCCESS; 
}

STDMETHODIMP CMiniportDmSynth::NewStream
(
    OUT     PMINIPORTSYNTHESIZERSTREAM *   Stream_,
    IN      PUNKNOWN                OuterUnknown    OPTIONAL,
    IN      POOL_TYPE               PoolType,
    IN      ULONG                   Pin,
    IN      BOOLEAN                 Capture,
    IN      PKSDATAFORMAT           DataFormat,
    OUT     PSERVICEGROUP *         ServiceGroup
)
{
    _DbgPrintF(DEBUGLVL_TERSE, ("[CMiniportDmSynth::NewStream]"));
    NTSTATUS nt = STATUS_SUCCESS;

    if (Stream)
    {
        // XXX Multiinstance!!!
        //
        nt = STATUS_INVALID_DEVICE_REQUEST;
    }
    else
    {
        CDmSynthStream *Stream = new(PoolType) CDmSynthStream(OuterUnknown);

        if (Stream)
        {
            nt = Stream->Init(this);
            if (NT_SUCCESS(nt))
            {
                Stream->AddRef();
                *Stream_ = PMINIPORTSYNTHESIZERSTREAM(Stream);
            }
            else
            {
                Stream->Release();
                Stream = NULL;
            }
        }
        else
        {
            nt = STATUS_INSUFFICIENT_RESOURCES;
        }

    }

    return nt;
}

STDMETHODIMP_(void) CMiniportDmSynth::Service()
{
}

// ==============================================================================
// PinDataRangesStream
// Structures indicating range of valid format values for streaming pins.
// ==============================================================================
static
KSDATARANGE_MUSIC PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_MUSIC),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
        },
        STATICGUIDOF(KSMUSIC_TECHNOLOGY_WAVETABLE),
        0,                                      // Channels
        0,                                      // Notes
        0x0000ffff                              // ChannelMask
    }
};

// ==============================================================================
// PinDataRangePointersStream
// List of pointers to structures indicating range of valid format values
// for streaming pins.
// ==============================================================================
static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

#if 0
// ==============================================================================
// PinDataRangesBridge
// Structures indicating range of valid format values for bridge pins.
// ==============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI_BUS),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

// ==============================================================================
// PinDataRangePointersBridge
// List of pointers to structures indicating range of valid format values
// for bridge pins.
// ==============================================================================
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};
#endif

// ==============================================================================
// PinDataRangesAudio
// Structures indicating range of valid format values for audio pins.
// ==============================================================================
static
KSDATARANGE_AUDIO PinDataRangesAudio[] =
{
    {
        { sizeof(KSDATARANGE_AUDIO),
          0,
          0,
          0,
          STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
          STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
          STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX),
        },
        2,
        16,
        16,
        22050,
        22050
    }
};

// ==============================================================================
// PinDataRangePointersAudio
// List of pointers to structures indicating range of valid format values
// for audio pins.
// ==============================================================================
static
PKSDATARANGE PinDataRangePointersAudio[] =
{
    (PKSDATARANGE)&PinDataRangesAudio
};

static
PCPROPERTY_ITEM
SynthProperties[] =
{
    ///////////////////////////////////////////////////////////////////
    //
    // Configuration items
    //

    // Global: Synth caps
    // 
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CAPS,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_SynthCaps
    },
    
    // Per Stream: Synth port parameters
    // 
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_PORTPARAMETERS,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_SynthPortParameters
    },

    // Global: Master clock
    // 
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_MASTERCLOCK,
        KSPROPERTY_TYPE_SET,
        PropertyHandler_SynthMasterClock
    },

    // Per Stream: Channel groups
    // 
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CHANNELGROUPS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET,
        PropertyHandler_SynthPortChannelGroups
    },

    ///////////////////////////////////////////////////////////////////
    //
    // DLS items
    //

    // Per stream: Download DLS sample
    //
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_DOWNLOAD,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_DlsDownload
    },

    // Per stream: Unload DLS sample
    //
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_UNLOAD,
        KSPROPERTY_TYPE_SET,
        PropertyHandler_DlsUnload
    },

    // Global: Compact DLS memory
    //
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_COMPACT,
        KSPROPERTY_TYPE_SET,
        PropertyHandler_DlsCompact
    },

    // Per stream: append
    //                
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_APPEND,
        KSPROPERTY_TYPE_SET,
        PropertyHandler_DlsAppend
    },

    // Per stream: volume
    //                
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_VOLUME,
        KSPROPERTY_TYPE_SET,
        PropertyHandler_DlsVolume
    },

    ///////////////////////////////////////////////////////////////////
    //
    // Clock items
    //

    // Per stream: Get desired latency
    //
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_LATENCY,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_GetLatency
    },

    // Per stream: Get current latency time
    //
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_LatencyClock,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_GetLatencyClock
    }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSynth, SynthProperties);

// ==============================================================================
// MiniportPins
// List of pins.
// ==============================================================================
static
PCPIN_DESCRIPTOR 
MiniportPins[] =
{
    {
        1,1,1,  // InstanceCount
        NULL, 
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStream),   // DataRangesCount
            PinDataRangePointersStream,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_SINK,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                          // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },
#if 0 
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                          // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
#else
    {
        1,1,1,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersAudio),    // DataRangesCount
            PinDataRangePointersAudio,                  // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_SOURCE,                 // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
#endif
};

// ==============================================================================
// MiniportNodes
// List of nodes.
// ==============================================================================
#define CONST_PCNODE_DESCRIPTOR(n)			{ 0, NULL, &n, NULL }
#define CONST_PCNODE_DESCRIPTOR_AUTO(n,a)	{ 0, &a, &n, NULL }
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
    CONST_PCNODE_DESCRIPTOR_AUTO(KSNODETYPE_SYNTHESIZER, AutomationSynth)
};

// ==============================================================================
// MiniportConnections
// List of connections.
// ==============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    // From node            From pin        To node                 To pin
    //
    { PCFILTER_NODE,        0,              0,                      1 },    // Stream in to synth.
    { 0,                    0,              PCFILTER_NODE,          1 }     // Synth to bridge out.
};

/*****************************************************************************
 * MiniportFilterDescriptor
 *****************************************************************************
 * Complete miniport description.
 */
static
PCFILTER_DESCRIPTOR 
MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories
};

STDMETHODIMP CMiniportDmSynth::GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE();
    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_VERBOSE, ("GetDescription"));

    *OutFilterDescriptor = &MiniportFilterDescriptor;
    return STATUS_SUCCESS;
}

STDMETHODIMP CMiniportDmSynth::DataRangeIntersection
(
    IN      ULONG           PinId,
    IN      PKSDATARANGE    DataRange,
    IN      PKSDATARANGE    MatchingDataRange,
    IN      ULONG           OutputBufferLength,
    OUT     PVOID           ResultantFormat    OPTIONAL,
    OUT     PULONG          ResultantFormatLength
)
{
    // XXX ???
    //
    return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////
//
// CDmSynthStream
//

CDmSynthStream::~CDmSynthStream()
{
    _DbgPrintF(DEBUGLVL_TERSE, ("[CDmSynthStream destruct]"));

    if (Miniport)
    {
        Miniport->Stream = NULL;
        Miniport->Release();
    }

    if (Synth)
    {
        delete Synth;
    }

    if (Sink)
    {
        Sink->Release();
    }
}

NTSTATUS CDmSynthStream::Init
(
    CMiniportDmSynth        *Miniport_
)
{
    _DbgPrintF(DEBUGLVL_TERSE, ("[CDmSynthStream::Init]"));
    _DbgPrintF(DEBUGLVL_TERSE, ("Stream IUnkown is %08X", DWORD(PVOID(PUNKNOWN(this)))));

    Miniport = Miniport_;
    Miniport->AddRef();

    Synth = new CSynth;
    if (Synth == NULL)
    {
        Miniport->Release();
        return STATUS_NO_MEMORY;
    }

    Sink = new CSysLink;
    if (Sink == NULL)
    {
        delete Synth;
        Synth = NULL;
        Miniport->Release();
        return STATUS_NO_MEMORY;
    }

    return STATUS_SUCCESS;
}

STDMETHODIMP CDmSynthStream::NonDelegatingQueryInterface
(
    IN  REFIID      Interface,
    OUT PVOID*      Object
)
{
    PAGED_CODE();
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportSynthesizerStream))
    {
        *Object = PVOID(PMINIPORTSYNTHESIZERSTREAM(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

STDMETHODIMP CDmSynthStream::SetState
(
    IN      KSSTATE     NewState
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("[CDmSynthStream::SetState]"));

    NTSTATUS nt = STATUS_SUCCESS;

    // XXX Propogate to activate state
    //
    switch (NewState)
    {
        case KSSTATE_RUN:
            nt = Synth->Activate(PortParams.SampleRate,
                                 PortParams.Stereo ? 2 : 1);
            break;

        case KSSTATE_ACQUIRE:
        case KSSTATE_STOP:
        case KSSTATE_PAUSE:
            nt = Synth->Deactivate();
            break;
    }

    return nt;
}

STDMETHODIMP CDmSynthStream::ConnectOutput
(
    PMXFFILTER ConnectionPoint
)
{
    return STATUS_NOT_IMPLEMENTED;
}

STDMETHODIMP CDmSynthStream::DisconnectOutput
(
    PMXFFILTER ConnectionPoint
)
{
    return STATUS_NOT_IMPLEMENTED;
}

STDMETHODIMP CDmSynthStream::PutMessage
(
    IN  PDMUS_KERNEL_EVENT  Event
)
{
    PBYTE Data = (Event->ByteCount <= sizeof(PBYTE) ? &Event->ActualData.Data[0] : Event->ActualData.DataPtr);

    // This is just MIDI bytes
    //
    return Synth->PlayBuffer(Sink,
                             Event->PresTime100Ns,
                             Data,
                             Event->ByteCount,
                             (ULONG)Event->ChannelGroup);
}

// CDmSynthStream::HandlePortParams
//
// Fix up the port params to include defaults. Cache the params as well
// as passing the updated version back.
//
STDMETHODIMP CDmSynthStream::HandlePortParams
(
    IN      PPCPROPERTY_REQUEST pRequest
)
{
    BOOL ValidParamChanged = FALSE;

    SYNTH_PORTPARAMS *Params = (SYNTH_PORTPARAMS*)pRequest->Value;
    if (pRequest->ValueSize < sizeof(SYNTH_PORTPARAMS))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_VOICES))
    {
        Params->Voices = 32;
    }
    else if (Params->Voices > 32)
    {
        Params->Voices = 32;
        ValidParamChanged = TRUE;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_CHANNELGROUPS))
    {
        Params->ChannelGroups = 32;
    }
    else if (Params->ChannelGroups > 32)
    {
        Params->ChannelGroups = 32;
        ValidParamChanged = TRUE;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_SAMPLERATE))
    {
        Params->SampleRate = 22050;
    }
    else if (Params->SampleRate != 11025 && Params->SampleRate != 22050 && Params->SampleRate != 44100)
    {
        Params->SampleRate = 22050;
        ValidParamChanged = TRUE;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_REVERB))
    {
        Params->Reverb = FALSE;
    }
    else if (Params->Reverb)
    {
        Params->Reverb = FALSE;
        ValidParamChanged = TRUE;
    }

    RtlCopyMemory(&PortParams, Params, sizeof(PortParams));    
    
    return ValidParamChanged ? STATUS_NOT_ALL_ASSIGNED : STATUS_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////
//
// Property dispatchers
//
// XXX All of these need to be connected
//

NTSTATUS PropertyHandler_SynthCaps
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    SYNTHCAPS caps;

    caps.Flags              = SYNTH_PC_DLS | SYNTH_PC_SOFTWARESYNTH;
    caps.MemorySize         = SYNTH_PC_SYSTEMMEMORY;         
    caps.MaxChannelGroups   = 32;
    caps.MaxVoices          = 32;

    pRequest->ValueSize = min(pRequest->ValueSize, sizeof(caps));
    RtlCopyMemory(pRequest->Value, &caps, pRequest->ValueSize);

    return STATUS_SUCCESS;
}

// PropertyHandler_SynthPortParameters
//
NTSTATUS PropertyHandler_SynthPortParameters
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    ASSERT(pRequest);
    ASSERT(pRequest->MinorTarget);
    
    return (PDMSYNTHSTREAM(pRequest->MinorTarget))->HandlePortParams(pRequest);
}

// PropertyHandler_SynthMasterClock
//
NTSTATUS PropertyHandler_SynthMasterClock
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    return STATUS_SUCCESS;
}

// PropertyHandler_SynthPortChannelGroups
//
NTSTATUS PropertyHandler_SynthPortChannelGroups
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    ASSERT(pRequest);
    ASSERT(pRequest->MinorTarget);

    if (pRequest->ValueSize < sizeof(ULONG))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    ULONG ChannelGroups = *(PULONG)(pRequest->Value);

    return (PDMSYNTHSTREAM(pRequest->MinorTarget))->Synth->SetNumChannelGroups(ChannelGroups);
}

// PropertyHandler_DlsDownload
//
NTSTATUS PropertyHandler_DlsDownload
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    // XXX Lock down this memory
    //
    // XXX Validate entire buffer size???
    //
    HANDLE DownloadHandle;
    BOOL Free;

    NTSTATUS Status = (PDMSYNTHSTREAM(pRequest->MinorTarget))->Synth->Download(
        &DownloadHandle,
        pRequest->Value,
        &Free);

    if (SUCCEEDED(Status))
    {
        ASSERT(pRequest->ValueSize >= sizeof(DownloadHandle));
        RtlCopyMemory(pRequest->Value, &DownloadHandle, sizeof(DownloadHandle));
        pRequest->ValueSize = sizeof(DownloadHandle);
    }

    return Status;
}

// PropertyHandler_DlsUnload
//
HRESULT CALLBACK UnloadComplete(HANDLE,HANDLE);

NTSTATUS PropertyHandler_DlsUnload
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    ASSERT(pRequest);
    ASSERT(pRequest->MinorTarget);

    if (pRequest->ValueSize < sizeof(HANDLE))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    // XXX Need some concurrency control here
    //
    NTSTATUS Status = (PDMSYNTHSTREAM(pRequest->MinorTarget))->Synth->Unload(
        *(HANDLE*)pRequest->Value,
        UnloadComplete,
        (HANDLE)pRequest);
    
    return STATUS_SUCCESS;
}

HRESULT CALLBACK UnloadComplete(HANDLE WhichDownload, HANDLE CallbackInstance)
{
    PPCPROPERTY_REQUEST pRequest = (PPCPROPERTY_REQUEST)CallbackInstance;
        
    PcCompletePendingPropertyRequest(pRequest, STATUS_SUCCESS);

    return STATUS_SUCCESS;
}

// PropertyHandler_DlsCompact
//
// We don't care
//
NTSTATUS PropertyHandler_DlsCompact
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    return STATUS_SUCCESS;
}

NTSTATUS PropertyHandler_DlsAppend
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    ASSERT(pRequest);

    if (pRequest->ValueSize < sizeof(ULONG))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    *(PULONG)(pRequest->Value) = 4;
    pRequest->ValueSize = sizeof(ULONG);

    return STATUS_SUCCESS;
}

NTSTATUS PropertyHandler_DlsVolume
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    // XXX *Both* versions of the synth need this
    //
    return STATUS_SUCCESS;
}

NTSTATUS PropertyHandler_GetLatency
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    if (pRequest->ValueSize < sizeof(ULONGLONG))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    *((PULONGLONG)pRequest->Value) = 0;
    pRequest->ValueSize = sizeof(ULONGLONG);

    return STATUS_SUCCESS;
}

NTSTATUS PropertyHandler_GetLatencyClock
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    // XXX This depends on the synth sink
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\mix.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      Mix.cpp
//      Mix engines for MSSynth

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#define STR_MODULENAME "DMusicMix:"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#endif

#pragma warning(disable : 4101 4102 4146)  

#ifdef _ALPHA_

extern "C" {
	int __ADAWI(short, short *);
};
#pragma intrinsic(__ADAWI)

#define ALPHA_OVERFLOW 2 
#define ALPHA_NEGATIVE 8

#else // !_ALPHA_
//  TODO -- overflow detection for ia64 (+ axp64?)
#endif // !_ALPHA_
#ifdef DMSYNTH_MINIPORT
#pragma code_seg("PAGE")
#endif // DMSYNTH_MINIPORT

DWORD CDigitalAudio::Mix8(short * pBuffer, 
						  DWORD dwLength, 
						  DWORD dwDeltaPeriod,
						  VFRACT vfDeltaLVolume, 
						  VFRACT vfDeltaRVolume,
					      VFRACT vfLastVolume[],
						  PFRACT pfDeltaPitch, 
						  PFRACT pfSampleLength, 
						  PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lM, lLM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8;  
	dwLength <<= 1;

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lLM = pcWave[dwPosition];
        lM = ((pcWave[dwPosition + 1] - lLM) * dwFract) >> 12;
        lM += lLM;
        lLM = lM;

        lLM *= vfLVolume;
        lLM >>= 5;         // Signal bumps up to 15 bits.
        lM *= vfRVolume;
        lM >>= 5;

#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lLM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#else // !_ALPHA_
    // TODO -- overflow detection on ia64 (+ axp64?)
#endif // !_ALPHA_

#else // _X86_  (dead code)
      //  Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lLM;

        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	

		pBuffer[dwI+1] += (short) lM;

        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:
#endif // _X86_  (dead code)

		dwI += 2;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;

// esi = b == dwIncDelta

; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = (dwLength - dwI) / 2;	// Remaining span.

	mov	edx, edi
	neg	edx
	shr	edx, 1		// edx = a

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543	

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI >> 1);
; 1094 : }

	lea	edx, [edx*2+2]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

; 1018 : 				lLM = lM;
; 1019 : 				lLM *= vfLVolume;
; 1020 : 				lLM >>= 5;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lLM;
; 1028 : 						lM *= vfRVolume;
; 1029 : 						lM >>= 5;
; 1030 : 				pBuffer[dwI+1] += (short) lM;
; 1036 : 
; 1037 : 				dwI += 2;
	sub	edx, eax

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_lx
no_oflowlx:

	imul	esi, edx

; 1038 : 			} while (--dwIncDelta);

	sar	esi, 5					; 00000005H
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	jo	overflow_rx

no_oflowrx:

	add	edi, 2
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:

; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 984  : 			{
; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaLVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfLVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfLVFract += vfDeltaLVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;
; 998  :             vfRVFract += vfDeltaRVolume;

	sar	ecx, 8
	mov	DWORD PTR vfLVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR vfDeltaRVolume

	mov	DWORD PTR vfLVolume, edx
	mov	edx, DWORD PTR vfRVFract

	add	edx, esi
	mov	DWORD PTR pfPitch, ecx

	mov	DWORD PTR vfRVFract, edx
	mov	esi, DWORD PTR dwDeltaPeriod

; 999  :             vfRVolume = vfRVFract >> 8;

	sar	edx, 8
	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	mov	DWORD PTR vfRVolume, edx
	jmp	$L30541

// Handle truncation.

overflow_l:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowl
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflowl

overflow_r:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowr
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowr

overflow_lx:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowlx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowlx

overflow_rx:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowrx
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowrx

$L30543:
; 1041 : 		}
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	add	ebx, ecx
	and	esi, 4095				; 00000fffH

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1049 :         lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

    sub	edx, eax
	
    imul	edx, esi

; 1052 :         lLM = lM;
; 1053 :         lLM *= vfLVolume;
; 1054 :         lLM >>= 5;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lLM;

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_l
no_oflowl:

; 1078 :         lM *= vfRVolume;
; 1079 : 		lM >>= 5;

	imul	esi, edx

; 1080 : 		pBuffer[dwI+1] += (short) lM;
; 1085 : no_oflowr:
; 1087 : 		dwI += 2;

	sar	esi, 5					; 00000005H
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	mov	edx, DWORD PTR pfPFract

	jo	overflow_r

no_oflowr:
; 978  : 
; 979  :     for (dwI = 0; dwI < dwLength; )

	add	edi, 2
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    vfLastVolume[0] = vfLVolume;
    vfLastVolume[1] = vfRVolume;

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI >> 1);
}

#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono8(short * pBuffer, 
							  DWORD dwLength,
							  DWORD dwDeltaPeriod,
							  VFRACT vfDeltaVolume,
							  VFRACT vfLastVolume[],
							  PFRACT pfDeltaPitch, 
							  PFRACT pfSampleLength, 
							  PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around. 

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }

	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lM = pcWave[dwPosition];
	    lM += ((pcWave[dwPosition + 1] - lM) * dwFract) >> 12;
		lM *= vfVolume;
		lM >>= 5;

#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#else // !_ALPHA_
    //  TODO -- overflow code on ia64 (+ axp64?)
#endif // !_ALPHA_

#else // _X86_  (dead code)
      // Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:
#endif  // _X86_  (dead code)
		dwI++;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:

; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta

; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;

; 1009 : 	a = dwLength - dwI;	// Remaining span.

	mov	edx, edi
	neg	edx

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI);
; 1094 : }

	lea	edx, [edx+1]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
		
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

	sub	edx, eax

; 1018 : 				lLM = lM;
; 1019 : 				lLM *= vfLVolume;
; 1020 : 				lLM >>= 5;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lLM;
; 1027 : no_oflowx:	
; 1037 : 				++dwI;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	mov	ecx, DWORD PTR pfPitch
	add	edx, eax

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	jo	overflow_x

no_oflowx:

	inc	edi
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 984  : 			{
; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfVFract += vfDeltaVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;

	sar	ecx, 8
	mov	DWORD PTR vfVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR dwDeltaPeriod


	mov	DWORD PTR vfVolume, edx
	mov	DWORD PTR pfPitch, ecx


	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	jmp	$L30541

// Handle truncation.

overflow_:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflow
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflow

overflow_x:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	add	ebx, ecx
	and	esi, 4095				; 00000fffH

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1049 :         lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lLM = lM;
; 1053 :         lLM *= vfLVolume;
; 1054 :         lLM >>= 5;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lLM;

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	jo	overflow_
no_oflow:
	inc	edi
	mov	edx, DWORD PTR pfPFract

; 979  :     for (dwI = 0; dwI < dwLength; )

	mov	ecx, DWORD PTR pfPitch
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    vfLastVolume[0] = vfVolume;
    vfLastVolume[1] = vfVolume; // !!! is this right?
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI);
}
#endif

DWORD CDigitalAudio::Mix8Filter(short * pBuffer, 
                            DWORD dwLength, 
                            DWORD dwDeltaPeriod,
                            VFRACT vfDeltaLVolume, 
                            VFRACT vfDeltaRVolume,
                            VFRACT vfLastVolume[],
                            PFRACT pfDeltaPitch, 
                            PFRACT pfSampleLength, 
                            PFRACT pfLoopLength,
                            COEFF cfdK,
                            COEFF cfdB1,
                            COEFF cfdB2)
{
    DWORD dwI;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8; 
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
	dwLength <<= 1;

    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
				pfSamplePos -= pfLoopLength;
			}
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
            cfK += cfdK;
            cfB1 += cfdB1;
            cfB2 += cfdB2;
        }
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lM = ((pcWave[dwPosition+1] - lA) * dwFract);
        lM >>= 12;
        lM += lA;
        lM <<= 8; // Source was 8 bits, so convert to 16.

        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// We store the negative of b1 in the table, so we flip the sign again by
		// adding here
		//
        lM =
              MulDiv(lM, cfK, (1 << 30))
            + MulDiv(m_lPrevSample, cfB1, (1 << 30))
            - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lM;

        lA = lM;

        lA *= vfLVolume;
        lA >>= 15;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 15;
        //  TODO -- overflow detection on ia64 (+ axp64?)
#ifdef _X86_
        //  Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lA;

        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	

		pBuffer[dwI+1] += (short) lM;

        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:
#endif // _X86_
		dwI += 2;
    }

    vfLastVolume[0] = vfLVolume;
    vfLastVolume[1] = vfRVolume;
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    m_cfLastK = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;
    return (dwI >> 1);
}

DWORD CDigitalAudio::Mix16Filter(short * pBuffer, 
                            DWORD dwLength, 
                            DWORD dwDeltaPeriod,
                            VFRACT vfDeltaLVolume, 
                            VFRACT vfDeltaRVolume,
                            VFRACT vfLastVolume[],
                            PFRACT pfDeltaPitch, 
                            PFRACT pfSampleLength, 
                            PFRACT pfLoopLength,
                            COEFF cfdK,
                            COEFF cfdB1,
                            COEFF cfdB2)
{
    DWORD dwI;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8; 
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
	dwLength <<= 1;

    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
				pfSamplePos -= pfLoopLength;
			}
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
            cfK += cfdK;
            cfB1 += cfdB1;
            cfB2 += cfdB2;
        }
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lM = ((pcWave[dwPosition+1] - lA) * dwFract);
        lM >>= 12;
        lM += lA;

        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// We store the negative of b1 in the table, so we flip the sign again by
		// adding here
		//
        lM =
              MulDiv(lM, cfK, (1 << 30))
            + MulDiv(m_lPrevSample, cfB1, (1 << 30))
            - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lM;

        lA = lM;

        lA *= vfLVolume;
        lA >>= 15;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 15;
        //  TODO -- overflow detection on ia64 (+ axp64?)
#ifdef _X86_
        //  Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lA;

        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	

		pBuffer[dwI+1] += (short) lM;

        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:
#endif
		dwI += 2;
    }

    vfLastVolume[0] = vfLVolume;
    vfLastVolume[1] = vfRVolume;
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    m_cfLastK = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;
    return (dwI >> 1);
}



DWORD CDigitalAudio::Mix16(short * pBuffer, 
						   DWORD dwLength, 
						   DWORD dwDeltaPeriod,
						   VFRACT vfDeltaLVolume, 
						   VFRACT vfDeltaRVolume,
						   VFRACT vfLastVolume[],
						   PFRACT pfDeltaPitch, 
						   PFRACT pfSampleLength, 
						   PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8; 
	dwLength <<= 1;

	static int _a = 0, _b = 0, _c = 0;

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
				pfSamplePos -= pfLoopLength;
			}
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lM = ((pcWave[dwPosition+1] - lA) * dwFract);
        lM >>= 12;
        lM += lA;
        lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;
#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lA, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#else // !_ALPHA_
    //  TODO -- overflow detection on ia64 (+ axp64?)
#endif // !_ALPHA_
#else // _X86_  (dead code)
      //  Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lA;

        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	

		pBuffer[dwI+1] += (short) lM;

        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:

#endif // _X86_  (dead code)
		dwI += 2;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta
; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = (dwLength - dwI) / 2;	// Remaining span.

	mov	edx, edi
	neg	edx
	shr	edx, 1		// edx = a

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI >> 1);
; 1094 : }

	lea	edx, [edx*2+2]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
		
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1014 : 				lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]
	sub	edx, eax

; 1018 : 				lA = lM;
; 1019 : 				lA *= vfLVolume;
; 1020 : 				lA >>= 13;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lA;
; 1027 : no_oflowlx:	
; 1028 : 						lM *= vfRVolume;
; 1029 : 						lM >>= 13;
; 1030 : 				pBuffer[dwI+1] += (short) lM;
; 1035 : no_oflowrx:
; 1037 : 				dwI += 2;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax
	mov	eax, DWORD PTR pBufX

	imul	esi, edx

	sar	esi, 13					; 0000000dH

	add	WORD PTR [eax+edi*2], si

	mov	esi, DWORD PTR vfRVolume
	jo	overflow_lx
no_oflowlx:

	imul	esi, edx

; 1038 : 			} while (--dwIncDelta);

	sar	esi, 13					; 0000000dH
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	jo	overflow_rx

no_oflowrx:

	add	edi, 2
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaLVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfLVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfLVFract += vfDeltaLVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;
; 998  :             vfRVFract += vfDeltaRVolume;

	sar	ecx, 8
	mov	DWORD PTR vfLVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR vfDeltaRVolume

	mov	DWORD PTR vfLVolume, edx
	mov	edx, DWORD PTR vfRVFract

	add	edx, esi
	mov	DWORD PTR pfPitch, ecx

	mov	DWORD PTR vfRVFract, edx
	mov	esi, DWORD PTR dwDeltaPeriod

; 999  :             vfRVolume = vfRVFract >> 8;

	sar	edx, 8
	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	mov	DWORD PTR vfRVolume, edx
	jmp	$L30541

// Handle truncation.
overflow_l:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowl
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflowl

overflow_r:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowr
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowr

overflow_lx:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowlx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowlx

overflow_rx:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowrx
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowrx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	and	esi, 4095				; 00000fffH
	add	ebx, ecx

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1049 :         lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lA = lM;
; 1053 :         lA *= vfLVolume;
; 1054 :         lA >>= 13;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lA;

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_l
no_oflowl:

; 1077 : no_oflowl:	
; 1078 :         lM *= vfRVolume;
; 1079 : 		lM >>= 13;

	imul	esi, edx

; 1080 : 		pBuffer[dwI+1] += (short) lM;
; 1085 : no_oflowr:
; 1086 : #endif  /* _ALPHA */
; 1087 : 		dwI += 2;

	sar	esi, 13					; 0000000dH
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	mov	edx, DWORD PTR pfPFract

	jo	overflow_r
no_oflowr:

	add	edi, 2

; 978  : 
; 979  :     for (dwI = 0; dwI < dwLength; )

	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    vfLastVolume[0] = vfLVolume;
    vfLastVolume[1] = vfRVolume;
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI >> 1);
}


#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono16(short * pBuffer, 
							   DWORD dwLength,
							   DWORD dwDeltaPeriod,
							   VFRACT vfDeltaVolume,
							   VFRACT vfLastVolume[],
							   PFRACT pfDeltaPitch, 
							   PFRACT pfSampleLength, 
							   PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.

#ifndef _X86_
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        lM *= vfVolume; 
        lM >>= 13;         // Signal bumps up to 12 bits.

#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#else // !_ALPHA_
    // TODO -- overflow detection for ia64 (+ axp64?)
#endif // !_ALPHA_
#else // _X86_  (dead code)
        // Keep this around so we can use it to generate new assembly code (see below...)
        pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:	
#endif // _X86  (dead code)
		dwI++;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta
; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = dwLength - dwI;	// Remaining span.

	mov	edx, edi
	neg	edx

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:
	push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI);
; 1094 : }

	lea	edx, [edx+1]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

; 1018 : 				lA = lM;
; 1019 : 				lA *= vfLVolume;
; 1020 : 				lA >>= 13;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lA;
; 1027 : no_oflowx:	
; 1037 : 				++dwI;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax
	mov	ecx, DWORD PTR pfPitch

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	jo	overflow_x
no_oflowx:

; 1038 : 			} while (--dwIncDelta);

	inc	edi
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfVFract += vfDeltaVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfVolume = vfVFract >> 8;

	sar	ecx, 8
	mov	DWORD PTR vfVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR dwDeltaPeriod

	mov	DWORD PTR vfVolume, edx
	mov	DWORD PTR pfPitch, ecx


	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	jmp	$L30541

// Handle truncation.
overflow_:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflow
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflow

overflow_x:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	and	esi, 4095				; 00000fffH
	add	ebx, ecx

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1049 :         lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lA = lM;
; 1053 :         lA *= vfVolume;
; 1054 :         lA >>= 13;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lA;

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	jo	overflow_
no_oflow:
; 1077 : no_oflowl:	
; 1087 : 		++dwI;

	inc	edi
	mov	edx, DWORD PTR pfPFract

; 979  :     for (dwI = 0; dwI < dwLength; )

	mov	ecx, DWORD PTR pfPitch
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}
	dwI += dwLength;

#endif // _X86_
    vfLastVolume[0] = vfVolume;
    vfLastVolume[1] = vfVolume; // !!! is this right?
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\opnew.cpp ===
// Copyright (c) 1999 Microsoft Corporation
// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\mmdebug.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
/*
 * johnkn's debug logging and assert macros
 *
 */
 
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#if !defined _INC_MMDEBUG_
#define _INC_MMDEBUG_

#if defined _DEBUG && !defined DEBUG
 #define DEBUG
#endif

//
// prototypes for debug functions.
//
    #define SQUAWKNUMZ(num) #num
    #define SQUAWKNUM(num) SQUAWKNUMZ(num)
    #define SQUAWK __FILE__ "(" SQUAWKNUM(__LINE__) ") ----"
    #define DEBUGLINE __FILE__ "(" SQUAWKNUM(__LINE__) ") "
        
    #if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL

        #define STATICFN

        int  FAR _cdecl AuxDebugEx(int, LPTSTR, ...);
        void FAR _cdecl AuxRip(LPTSTR, ...);
        VOID WINAPI AuxDebugDump (int, LPVOID, int);
        LPCTSTR WINAPI AuxMMErrText(DWORD  mmr);
        int  WINAPI DebugSetOutputLevel (int,int);
        UINT WINAPI AuxFault (DWORD dwFaultMask);

       #if defined DEBUG_RETAIL && !defined DEBUG && !defined _DEBUG
        #define INLINE_BREAK
       #else
        #if !defined _WIN32 || defined _X86_
         #define INLINE_BREAK _asm {int 3}
        #else
         #define INLINE_BREAK DebugBreak()
        #endif
       #endif

        #define FAULT_HERE AuxFault

       #undef  assert
       #define assert(exp) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " #exp "\r\n"); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert2
       #define assert2(exp,sz) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n"); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert3
       #define assert3(exp,sz,arg) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (arg)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert4
       #define assert4(exp,sz,arg1,arg2) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (arg1),(arg2)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert5
       #define assert5(exp,sz,arg1,arg2,arg3) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (arg1),(arg2),(arg3)); \
               INLINE_BREAK;\
               }\
           }

    #else // defined(DEBUG) || defined(_DEBUG)
                      
       #define AuxDebugEx  1 ? (void)0 :
       #define AuxDebugDump(a,b,c)
       #define AuxMMErrText(m)     NULL
       #define AuxRip  1 ? (void)0 :

       #define assert(a)          ((void)0)
       #define assert2(a,b)       ((void)0)
       #define assert3(a,b,c)     ((void)0)
       #define assert4(a,b,c,d)   ((void)0)
       #define assert5(a,b,c,d,e) ((void)0)

       #define FAULT_HERE    1 ? (void)0 :
       #define INLINE_BREAK
       #define DebugSetOutputLevel(i,j)
       #define STATICFN static

   #endif // defined(DEBUG) || defined _DEBUG || defined DEBUG_RETAIL

   #ifndef DPF_CATEGORY
    #define DPF_CATEGORY 0x0100
   #endif

   // translate DPF's only in internal debug builds
   //
   #if defined DEBUG || defined _DEBUG
       #define DUMP(n,a,b) AuxDebugDump (DPF_CATEGORY | (n), a, b)
       #define RIP AuxDebugEx (0, DEBUGLINE), AuxRip
       #define AuxMMR(api,mmr) (mmr) ? AuxDebugEx(1, DEBUGLINE #api " error %d '%s'\r\n", mmr, AuxMMErrText(mmr)) : (int)0
       #define DPF(n,sz) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n")
       #define DPF1(n,sz,a) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a))
       #define DPF2(n,sz,a,b) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b))
       #define DPF3(n,sz,a,b,c) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c))
       #define DPF4(n,sz,a,b,c,d) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d))
       #define DPF5(n,sz,a,b,c,d,e) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d),(e))
       #define DPF6(n,sz,a,b,c,d,e,f) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d),(d),(f))
       #define DPF7(n,sz,a,b,c,d,e,f,g) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d),(d),(f),(g))
   #else
       #define DUMP(n,a,b)
       #define RIP AuxRip
       #define AuxMMR(api,mmr)
       #define DPF(n,sz)
       #define DPF1(n,sz,a)
       #define DPF2(n,sz,a,b)
       #define DPF3(n,sz,a,b,c)
       #define DPF4(n,sz,a,b,c,d)
       #define DPF5(n,sz,a,b,c,d,e)
       #define DPF6(n,sz,a,b,c,d,e,f)
       #define DPF7(n,sz,a,b,c,d,e,f,g)
   #endif
   
#endif //_INC_MMDEBUG_

// =============================================================================

//
// include this in only one module in a DLL or APP
//   
#if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL
    #if (defined _INC_MMDEBUG_CODE_) && (_INC_MMDEBUG_CODE_ != FALSE)
    #undef _INC_MMDEBUG_CODE_
    #define _INC_MMDEBUG_CODE_ FALSE
       
    #include <stdarg.h>   

    #if !defined _WIN32 && !defined wvsprintfA
     #define wvsprintfA wvsprintf
    #endif

static struct _mmerrors {
   DWORD    mmr;
   LPCTSTR  psz;
   } aMMErr[] = {
      MMSYSERR_NOERROR      ,"Success",
   #ifdef DEBUG
      MMSYSERR_ERROR        ,"unspecified error",
      MMSYSERR_BADDEVICEID  ,"device ID out of range",
      MMSYSERR_NOTENABLED   ,"driver failed enable",
      MMSYSERR_ALLOCATED    ,"device already allocated",
      MMSYSERR_INVALHANDLE  ,"device handle is invalid",
      MMSYSERR_NODRIVER     ,"no device driver present",
      MMSYSERR_NOMEM        ,"memory allocation error",
      MMSYSERR_NOTSUPPORTED ,"function isn't supported",
      MMSYSERR_BADERRNUM    ,"error value out of range",
      MMSYSERR_INVALFLAG    ,"invalid flag passed",
      MMSYSERR_INVALPARAM   ,"invalid parameter passed",
     #if (WINVER >= 0x0400)
      MMSYSERR_HANDLEBUSY   ,"handle in use by another thread",
      MMSYSERR_INVALIDALIAS ,"specified alias not found",
      MMSYSERR_BADDB        ,"bad registry database",
      MMSYSERR_KEYNOTFOUND  ,"registry key not found",
      MMSYSERR_READERROR    ,"registry read error",
      MMSYSERR_WRITEERROR   ,"registry write error",
      MMSYSERR_DELETEERROR  ,"registry delete error",
      MMSYSERR_VALNOTFOUND  ,"registry value not found",
      MMSYSERR_NODRIVERCB   ,"Never got a 32 bit callback from driver",
     #endif // WINVER >= 0x400

      WAVERR_BADFORMAT      ,"wave:unsupported wave format",
      WAVERR_STILLPLAYING   ,"wave:still something playing",
      WAVERR_UNPREPARED     ,"wave:header not prepared",
      WAVERR_SYNC           ,"wave:device is synchronous",

      MIDIERR_UNPREPARED    ,"midi:header not prepared",
      MIDIERR_STILLPLAYING  ,"midi:still something playing",
      //MIDIERR_NOMAP         ,"midi:no configured instruments",
      MIDIERR_NOTREADY      ,"midi:hardware is still busy",
      MIDIERR_NODEVICE      ,"midi:port no longer connected",
      MIDIERR_INVALIDSETUP  ,"midi:invalid MIF",
      #ifdef CHICAGO
      MIDIERR_BADOPENMODE   ,"midi:operation unsupported w/ open mode",
      #endif

      TIMERR_NOCANDO        ,"timer: request not completed",
      JOYERR_PARMS          ,"joy:bad parameters",
      JOYERR_NOCANDO        ,"joy:request not completed",
      JOYERR_UNPLUGGED      ,"joystick is unplugged",

      MCIERR_INVALID_DEVICE_ID        ,"MCIERR_INVALID_DEVICE_ID",
      MCIERR_UNRECOGNIZED_KEYWORD     ,"MCIERR_UNRECOGNIZED_KEYWORD",
      MCIERR_UNRECOGNIZED_COMMAND     ,"MCIERR_UNRECOGNIZED_COMMAND",
      MCIERR_HARDWARE                 ,"MCIERR_HARDWARE",
      MCIERR_INVALID_DEVICE_NAME      ,"MCIERR_INVALID_DEVICE_NAME",
      MCIERR_OUT_OF_MEMORY            ,"MCIERR_OUT_OF_MEMORY",
      MCIERR_DEVICE_OPEN              ,"MCIERR_DEVICE_OPEN",
      MCIERR_CANNOT_LOAD_DRIVER       ,"MCIERR_CANNOT_LOAD_DRIVER",
      MCIERR_MISSING_COMMAND_STRING   ,"MCIERR_MISSING_COMMAND_STRING",
      MCIERR_PARAM_OVERFLOW           ,"MCIERR_PARAM_OVERFLOW",
      MCIERR_MISSING_STRING_ARGUMENT  ,"MCIERR_MISSING_STRING_ARGUMENT",
      MCIERR_BAD_INTEGER              ,"MCIERR_BAD_INTEGER",
      MCIERR_PARSER_INTERNAL          ,"MCIERR_PARSER_INTERNAL",
      MCIERR_DRIVER_INTERNAL          ,"MCIERR_DRIVER_INTERNAL",
      MCIERR_MISSING_PARAMETER        ,"MCIERR_MISSING_PARAMETER",
      MCIERR_UNSUPPORTED_FUNCTION     ,"MCIERR_UNSUPPORTED_FUNCTION",
      MCIERR_FILE_NOT_FOUND           ,"MCIERR_FILE_NOT_FOUND",
      MCIERR_DEVICE_NOT_READY         ,"MCIERR_DEVICE_NOT_READY",
      MCIERR_INTERNAL                 ,"MCIERR_INTERNAL",
      MCIERR_DRIVER                   ,"MCIERR_DRIVER",
      MCIERR_CANNOT_USE_ALL           ,"MCIERR_CANNOT_USE_ALL",
      MCIERR_MULTIPLE                 ,"MCIERR_MULTIPLE",
      MCIERR_EXTENSION_NOT_FOUND      ,"MCIERR_EXTENSION_NOT_FOUND",
      MCIERR_OUTOFRANGE               ,"MCIERR_OUTOFRANGE",
      MCIERR_FLAGS_NOT_COMPATIBLE     ,"MCIERR_FLAGS_NOT_COMPATIBLE",
      MCIERR_FILE_NOT_SAVED           ,"MCIERR_FILE_NOT_SAVED",
      MCIERR_DEVICE_TYPE_REQUIRED     ,"MCIERR_DEVICE_TYPE_REQUIRED",
      MCIERR_DEVICE_LOCKED            ,"MCIERR_DEVICE_LOCKED",
      MCIERR_DUPLICATE_ALIAS          ,"MCIERR_DUPLICATE_ALIAS",
      MCIERR_BAD_CONSTANT             ,"MCIERR_BAD_CONSTANT",
      MCIERR_MUST_USE_SHAREABLE       ,"MCIERR_MUST_USE_SHAREABLE",
      MCIERR_MISSING_DEVICE_NAME      ,"MCIERR_MISSING_DEVICE_NAME",
      MCIERR_BAD_TIME_FORMAT          ,"MCIERR_BAD_TIME_FORMAT",
      MCIERR_NO_CLOSING_QUOTE         ,"MCIERR_NO_CLOSING_QUOTE",
      MCIERR_DUPLICATE_FLAGS          ,"MCIERR_DUPLICATE_FLAGS",
      MCIERR_INVALID_FILE             ,"MCIERR_INVALID_FILE",
      MCIERR_NULL_PARAMETER_BLOCK     ,"MCIERR_NULL_PARAMETER_BLOCK",
      MCIERR_UNNAMED_RESOURCE         ,"MCIERR_UNNAMED_RESOURCE",
      MCIERR_NEW_REQUIRES_ALIAS       ,"MCIERR_NEW_REQUIRES_ALIAS",
      MCIERR_NOTIFY_ON_AUTO_OPEN      ,"MCIERR_NOTIFY_ON_AUTO_OPEN",
      MCIERR_NO_ELEMENT_ALLOWED       ,"MCIERR_NO_ELEMENT_ALLOWED",
      MCIERR_NONAPPLICABLE_FUNCTION   ,"MCIERR_NONAPPLICABLE_FUNCTION",
      MCIERR_ILLEGAL_FOR_AUTO_OPEN    ,"MCIERR_ILLEGAL_FOR_AUTO_OPEN",
      MCIERR_FILENAME_REQUIRED        ,"MCIERR_FILENAME_REQUIRED",
      MCIERR_EXTRA_CHARACTERS         ,"MCIERR_EXTRA_CHARACTERS",
      MCIERR_DEVICE_NOT_INSTALLED     ,"MCIERR_DEVICE_NOT_INSTALLED",
      MCIERR_GET_CD                   ,"MCIERR_GET_CD",
      MCIERR_SET_CD                   ,"MCIERR_SET_CD",
      MCIERR_SET_DRIVE                ,"MCIERR_SET_DRIVE",
      MCIERR_DEVICE_LENGTH            ,"MCIERR_DEVICE_LENGTH",
      MCIERR_DEVICE_ORD_LENGTH        ,"MCIERR_DEVICE_ORD_LENGTH",
      MCIERR_NO_INTEGER               ,"MCIERR_NO_INTEGER",
      MCIERR_WAVE_OUTPUTSINUSE        ,"MCIERR_WAVE_OUTPUTSINUSE",
      MCIERR_WAVE_SETOUTPUTINUSE      ,"MCIERR_WAVE_SETOUTPUTINUSE",
      MCIERR_WAVE_INPUTSINUSE         ,"MCIERR_WAVE_INPUTSINUSE",
      MCIERR_WAVE_SETINPUTINUSE       ,"MCIERR_WAVE_SETINPUTINUSE",
      MCIERR_WAVE_OUTPUTUNSPECIFIED   ,"MCIERR_WAVE_OUTPUTUNSPECIFIED",
      MCIERR_WAVE_INPUTUNSPECIFIED    ,"MCIERR_WAVE_INPUTUNSPECIFIED",
      MCIERR_WAVE_OUTPUTSUNSUITABLE   ,"MCIERR_WAVE_OUTPUTSUNSUITABLE",
      MCIERR_WAVE_SETOUTPUTUNSUITABLE ,"MCIERR_WAVE_SETOUTPUTUNSUITABLE",
      MCIERR_WAVE_INPUTSUNSUITABLE    ,"MCIERR_WAVE_INPUTSUNSUITABLE",
      MCIERR_WAVE_SETINPUTUNSUITABLE  ,"MCIERR_WAVE_SETINPUTUNSUITABLE",
      MCIERR_SEQ_DIV_INCOMPATIBLE     ,"MCIERR_SEQ_DIV_INCOMPATIBLE",
      MCIERR_SEQ_PORT_INUSE           ,"MCIERR_SEQ_PORT_INUSE",
      MCIERR_SEQ_PORT_NONEXISTENT     ,"MCIERR_SEQ_PORT_NONEXISTENT",
      MCIERR_SEQ_PORT_MAPNODEVICE     ,"MCIERR_SEQ_PORT_MAPNODEVICE",
      MCIERR_SEQ_PORT_MISCERROR       ,"MCIERR_SEQ_PORT_MISCERROR",
      MCIERR_SEQ_TIMER                ,"MCIERR_SEQ_TIMER",
      MCIERR_SEQ_PORTUNSPECIFIED      ,"MCIERR_SEQ_PORTUNSPECIFIED",
      MCIERR_SEQ_NOMIDIPRESENT        ,"MCIERR_SEQ_NOMIDIPRESENT",
      MCIERR_NO_WINDOW                ,"MCIERR_NO_WINDOW",
      MCIERR_CREATEWINDOW             ,"MCIERR_CREATEWINDOW",
      MCIERR_FILE_READ                ,"MCIERR_FILE_READ",
      MCIERR_FILE_WRITE               ,"MCIERR_FILE_WRITE",
     #ifdef CHICAGO
      MCIERR_NO_IDENTITY              ,"MCIERR_NO_IDENTITY",

      MIXERR_INVALLINE            ,"Invalid Mixer Line",
      MIXERR_INVALCONTROL         ,"Invalid Mixer Control",
      MIXERR_INVALVALUE           ,"Invalid Mixer Value",
     #endif // CHICAGO
   #endif // DEBUG
      0xFFFFFFFE                  , "unknown error %d"
      };

    struct _mmdebug {
        int    Level;
        int    Mask;
        int    StopOnRip;
        DWORD  TakeFault;
        struct _mmerrors *paErrs;
        BOOL   Initialized;
        HANDLE hOut;
        } mmdebug = {0, 0xFF, 0, 0xFF, aMMErr};

    /*+ AuxFault
     *
     *-=================================================================*/

     UINT WINAPI AuxFault (
         DWORD dwFaultMask)
     {
         LPUINT pData = NULL;

         if (dwFaultMask & mmdebug.TakeFault)
            return *pData;
         return 0;
     }


    /*+ AuxOut - write a string to designated debug out
     *
     *-=================================================================*/

   void WINAPI AuxOut (
      LPTSTR psz)
      {
     #ifdef WIN32
      if (mmdebug.hOut)
         {
         UINT  cb = lstrlen(psz);
         DWORD dw;
         if (INVALID_HANDLE_VALUE != mmdebug.hOut)
            WriteFile (mmdebug.hOut, psz, cb, &dw, NULL);
         }
      else
     #endif
         {
        #ifdef DbgLog
         DbgOutString (psz); // from \quartz\sdk\classes\base\debug.cpp
        #else
         OutputDebugString (psz);
        #endif
         }
      }

    /*+ AuxDebug - create a formatted string and output to debug terminal
     *
     *-=================================================================*/
    
    int FAR _cdecl AuxDebugEx (
       int    iLevel,
       LPTSTR lpFormat,
       ...)
       {
      #ifdef WIN32
       char     szBuf[1024];
      #else
       static char szBuf[1024];
      #endif
       int      cb;
       va_list  va;
       LPSTR    psz;

       // mask the iLevel passed with mmdebug.Mask. if this ends up
       // clearing the high bits then iLevel has a shot being smaller
       // than mmdebug.Level.  if not, then the second test will always
       // fail.  Thus mmdebug.Mask has bits set to DISABLE that category.
       // 
       // note that we always pass messages that have an iLevel < 0.
       // this level corresponds to Asserts & Rips so we always want to see them.
       //
       if (iLevel < 0 || mmdebug.Level >= (iLevel & mmdebug.Mask))
          {
          va_start (va, lpFormat);
          cb = wvsprintfA (szBuf, lpFormat, va);
          va_end (va);

          // eat leading ..\..\ which we get from __FILE__ since
          // george's wierd generic makefile stuff.
          //
          psz = szBuf;
          while (psz[0] == '.' && psz[1] == '.' && psz[2] == '\\')
             psz += 3;

          // if we begin with a drive letter, strip off all but filename
          //  
          if (psz[0] && psz[1] == ':')
             {
             UINT ii = 2;
             for (ii = 2; psz[ii] != 0; ++ii)
                 if (psz[ii] == '\\')
                    psz += ii+1, ii = 0;
             }

          // write to standard out if we have a handle. otherwise write to 
          // the debugger
          //
         #ifdef MODULE_DEBUG_PREFIX
          if (psz != szBuf)
             AuxOut (MODULE_DEBUG_PREFIX);
         #endif
          AuxOut (psz);
          }

       return cb;
       }

    /*+ AuxRip
     *
     *-=================================================================*/

    void FAR _cdecl AuxRip (
       LPTSTR lpFormat,
       ...)
       {
      #ifdef WIN32
       char     szBuf[1024];
      #else
       static char szBuf[1024];
      #endif
       va_list  va;
       LPSTR    psz;
                
       va_start (va, lpFormat);
       wvsprintfA (szBuf, lpFormat, va);
       va_end (va);

       // eat leading ..\..\ which we get from __FILE__ since
       // george's wierd generic makefile stuff.
       //
       psz = szBuf;
       while (psz[0] == '.' && psz[1] == '.' && psz[2] == '\\')
          psz += 3;

       AuxOut ("RIP: ");
       AuxOut (psz);
       AuxOut ("\r\n");

       if (mmdebug.StopOnRip)
          {
         #if !defined _WIN32 || defined _X86_
          _asm {int 3};
         #else
          DebugBreak();
         #endif
          }
       }

    /*+ AuxDebugDump -
     *
     *-=================================================================*/
    
    VOID WINAPI AuxDebugDump (
       int    iLevel,
       LPVOID lpvData,
       int    nCount)
       {
       LPBYTE   lpData = (LPBYTE)lpvData;
       char     szBuf[128];
       LPSTR    psz;
       int      cb;
       int      ix;
       BYTE     abRow[8];
                
       if ((mmdebug.Level < (iLevel & mmdebug.Mask)) || nCount <= 0)
          return;

       do {
          cb = wsprintf (szBuf, "\t%08X: ", lpData);
          psz = szBuf + cb;

          for (ix = 0; ix < 8; ++ix)
             {
             LPBYTE lpb = lpData;

             abRow[ix] = '.';
             if (IsBadReadPtr (lpData + ix, 1))
                lstrcpy (psz, ".. ");
             else
                {
                wsprintf (psz, "%02X ", lpData[ix]);
                if (lpData[ix] >= 32 && lpData[ix] < 127)
                    abRow[ix] = lpData[ix];
                }
             psz += 3;
             }
          for (ix = 0; ix < 8; ++ix)
             *psz++ = abRow[ix];

          lstrcpy (psz, "\r\n");

          #ifdef MODULE_DEBUG_PREFIX
           AuxOut (MODULE_DEBUG_PREFIX);
          #endif

          AuxOut (szBuf);

          } while (lpData += 8, (nCount -= 8) > 0);

       return;
       }
       
    /*+ AuxMMErrText
     *
     *-=================================================================*/
    
   LPCTSTR WINAPI AuxMMErrText (
      DWORD  mmr)
   {
      UINT uRemain = sizeof(aMMErr)/sizeof(aMMErr[0]);
      UINT uUpper  = uRemain-1;
      UINT uLower  = 0;
      static char szTemp[50];

      if (mmr <= aMMErr[uUpper].mmr)
      {
         // binary search for mmr match, if match
         // return string pointer
         //
         while (--uRemain)
         {
            UINT ii = (uLower + uUpper) >> 1;

            if (aMMErr[ii].mmr < mmr)
            {
               if (uLower == ii)
                  break;
               uLower = ii;
            }
            else if (aMMErr[ii].mmr > mmr)
            {
               if (uUpper == ii)
                  break;
               uUpper = ii;
            }
            else
            {
               return aMMErr[ii].psz;
               break;
            }
         }

         // we can only get to here if no match was found for
         // the error id.
         //
         if ( ! uRemain)
         {
            int ix;

            INLINE_BREAK;

            for (ix = 0; ix < sizeof(aMMErr)/sizeof(aMMErr[0])-1; ++ix)
            {
                assert (aMMErr[ix].mmr < aMMErr[ix+1].mmr);
            }
            wsprintf (szTemp, "error %d 0x%X", mmr, mmr);
            return szTemp;
         }
      }

      wsprintf (szTemp, aMMErr[uUpper].psz, mmr);
      return szTemp;
   }

    /*+ DebugSetOutputLevel
     *
     *-=================================================================*/
    
    BOOL  WINAPI DebugSetOutputLevel (
        int nLevel,
        int nMask)
        {
        int nOldLevel = mmdebug.Level;

        if (!mmdebug.Initialized)
           {
          #ifdef WIN32
           TCHAR szFile[MAX_PATH];
           mmdebug.TakeFault = GetProfileInt("Debug", "FaultMask", 1);

           GetProfileString("Debug", "MMDebugTo", "", szFile, sizeof(szFile));
#if 0
           if (!lstrcmpi(szFile, "Console"))
              {
              mmdebug.hOut = GetStdHandle (STD_OUTPUT_HANDLE);
              if (!mmdebug.hOut || mmdebug.hOut == INVALID_HANDLE_VALUE)
                 {
                 AllocConsole ();
                 mmdebug.hOut = GetStdHandle (STD_OUTPUT_HANDLE);
                 if (mmdebug.hOut == INVALID_HANDLE_VALUE)
                    mmdebug.hOut = NULL;
                 }
              SetConsoleTitle (MODULE_DEBUG_PREFIX " Debug Output");
              }
           else
#endif
           if (szFile[0] &&
                    lstrcmpi(szFile, "Debug") &&
                    lstrcmpi(szFile, "Debugger") &&
                    lstrcmpi(szFile, "Deb"))
              {
              mmdebug.hOut = CreateFile(szFile, GENERIC_WRITE,
                                        FILE_SHARE_READ,
                                        NULL, OPEN_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);
              if (INVALID_HANDLE_VALUE != mmdebug.hOut)
                 SetFilePointer (mmdebug.hOut, 0, NULL, FILE_END);
              }
          #endif
           mmdebug.Initialized = TRUE;
           }

        mmdebug.Level = (nLevel & 0xFF);
        mmdebug.Mask  = (nMask | 0xFF);
        return nOldLevel;
        }


    #endif // _INC_MMDEBUG_CODE_
#endif // DEBUG || _DEBUG    

#ifdef __cplusplus
}
#endif // _cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\simple.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include "misc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\plclock.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
/*	CPhaseLockClock

  */

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include "dmusicc.h"
#include "dmusics.h"
#include "plclock.h"
#include "misc.h"
#define MILS_TO_REF	10000

CPhaseLockClock::CPhaseLockClock()

{
	m_rfOffset = 0;
}

void CPhaseLockClock::Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime)

/*	When the clock starts, it needs to mark down the 
	difference between the time it is given and its concept of time. 
*/

{
	m_rfOffset = rfMasterTime - rfSlaveTime;
}	

void CPhaseLockClock::GetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)

/*	Convert the passed time to use the same base as the master clock.
*/

{
	rfSlaveTime += m_rfOffset;
	*prfTime = rfSlaveTime;
}

void CPhaseLockClock::SetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)

{
	rfSlaveTime -= m_rfOffset;
	*prfTime = rfSlaveTime;
}

void CPhaseLockClock::SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime)

/*	SyncToTime provides the needed magic to keep the clock
	in sync. Since the clock uses its own clock (rfSlaveTime)
	to increment, it can drift. This call provides a reference
	time which the clock compares with its internal 
	concept of time. The difference between the two is
	considered the drift. Since the sync time may increment in
	a lurching way, the correction has to be subtle. 
	So, the difference between the two is divided by
	100 and added to the offset.
*/

{
	rfSlaveTime += m_rfOffset;
	rfSlaveTime -= rfMasterTime;	// Find difference between calculated and expected time.
	rfSlaveTime /= 100;				// Reduce in magnitude.
	m_rfOffset -= rfSlaveTime;		// Subtract that from the original offset.
}

CSampleClock::CSampleClock()

{
	m_dwStart = 0;
	m_dwSampleRate = 22050;
}

void CSampleClock::Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples)

{
	REFERENCE_TIME rfStart;
	m_dwStart = dwSamples;
	m_dwSampleRate = dwSampleRate;
	if (pIClock)
	{
		pIClock->GetTime(&rfStart);
		m_PLClock.Start(rfStart,0);
	}
}

void CSampleClock::SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime)

{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	m_PLClock.GetSlaveTime(llSampleTime, prfTime);
}

LONGLONG CSampleClock::RefTimeToSample(REFERENCE_TIME rfTime)

{
	m_PLClock.SetSlaveTime(rfTime, &rfTime);
	rfTime /= 1000;
	rfTime *= m_dwSampleRate;
	rfTime /= MILS_TO_REF;
	return rfTime + m_dwStart;
}


void CSampleClock::SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock)

{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	if (pIClock)
	{
		REFERENCE_TIME rfMasterTime;
		pIClock->GetTime(&rfMasterTime);
		m_PLClock.SyncToMaster(llSampleTime, rfMasterTime);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\plclock.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
/*	PLClock.h

  */

#ifndef __PLCLOCK_H__
#define __PLCLOCK_H__

class CPhaseLockClock
{
public:
						CPhaseLockClock();
	void				Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime);
	void				GetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime);
private:
	REFERENCE_TIME		m_rfOffset;
};

class CSampleClock
{
public:
						CSampleClock();
	void				Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples);
	void				SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock);
	LONGLONG			RefTimeToSample(REFERENCE_TIME rfTime);

private:
	CPhaseLockClock		m_PLClock;
	DWORD				m_dwStart;		// Initial sample offset.
	DWORD				m_dwSampleRate;
};



#endif	// __PLCLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\private.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//
//
//
#ifndef _PRIVATE
#define _PRIVATE_

NTSTATUS CreateMiniportDmSynth
(
    OUT PUNKNOWN *  Unknown,
    IN  PUNKNOWN    UnknownOuter OPTIONAL,
    IN  POOL_TYPE   PoolType
);


#include <stdunk.h>

class CDmSynthStream;

class CMiniportDmSynth : public IMiniportSynthesizer, public CUnknown
{
friend class CDmSynthStream;

public:
    // IUnknown
    //
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportDmSynth);

    ~CMiniportDmSynth();

    // IMiniport
    //
    STDMETHOD(GetDescription)
    (   THIS_
        OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
    );

    STDMETHOD(DataRangeIntersection)
    (   THIS_
        IN      ULONG           PinId,
        IN      PKSDATARANGE    DataRange,
        IN      PKSDATARANGE    MatchingDataRange,
        IN      ULONG           OutputBufferLength,
        OUT     PVOID           ResultantFormat    OPTIONAL,
        OUT     PULONG          ResultantFormatLength
    );

    // IMiniportDmSynth
    //
    STDMETHOD(Init)
    (   THIS_
        IN      PUNKNOWN        UnknownNotUsed  OPTIONAL,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTSYNTHESIZER Port,
        OUT     PSERVICEGROUP * ServiceGroup
    );  
      
    STDMETHOD(NewStream)
    (   THIS_
        OUT     PMINIPORTSYNTHESIZERSTREAM *   Stream,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   Pin,
        IN      BOOLEAN                 Capture,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP *         ServiceGroup
    );

    STDMETHOD_(void, Service)
    (   void
    );

private:
    PPORTSYNTHESIZER        Port;
    CDmSynthStream *        Stream;    
};


class CDmSynthStream : public IMiniportSynthesizerStream, public CUnknown
{
public:
    // IUnknown
    //
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CDmSynthStream);
    ~CDmSynthStream();
    NTSTATUS Init(CMiniportDmSynth *Miniport);

    // IMxfFilter
    //
    STDMETHOD(ConnectOutput)
    (
        PMXFFILTER ConnectionPoint
    );
    
    STDMETHOD(DisconnectOutput)
    (
        PMXFFILTER ConnectionPoint
    );

    STDMETHOD(PutMessage)
    (   THIS_
        IN  PDMUS_KERNEL_EVENT  Event
    ); 

    // IMiniportSynthStream
    //
    STDMETHOD(SetState)
    (   THIS_
        IN      KSSTATE     State
    );

    // Class
    //
    STDMETHOD(HandlePortParams)
    (   THIS_
        IN      PPCPROPERTY_REQUEST pRequest
    );

public:
    CSynth *                Synth;

private:
    CMiniportDmSynth *      Miniport;
    CSysLink *              Sink;
    SYNTH_PORTPARAMS        PortParams;
};

typedef CDmSynthStream *PDMSYNTHSTREAM;

#endif // _PRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\mmx.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      Mmx.cpp
//      MMX Mix engines for Microsoft synth

/*
Variable useage.

		Variable									register 
		pfSamplePos									eax
		pfPitch										ebx
		dwI											ecx
		dwIncDelta									edx (edx is sometimes a temporary register)
		dwPosition1									esi
		dwPostiion2									edi

		vfRvolume and vfLvolume						mm0		
		vfRVolume, vfLVolume						mm2		

		mm4 - mm7 are temporary mmx registers.
*/

// Notes about calculation.

		// Loop is unrolled once.
		// *1  shifting volumne to 15 bit values to get rid of shifts and simplify code.
		// This make the packed mulitply work better later since I keep the sound interpolated
		// wave value at 16 bit signed value.  For a PMULHW, this results in 15 bit results
		// which is the same as the original code.


		// *2 linear interpolation can be done very quickly with MMX by re-arranging the
		// way that the interpolation is done. Here is code in C that shows the difference.
		// Original C code		
        //lM1 = ((pcWave[dwPosition1 + 1] - pcWave[dwPosition1]) * dwFract1) >> 12;
		//lM2 = ((pcWave[dwPosition2 + 1] - pcWave[dwPosition2]) * dwFract2) >> 12;
        //lM1 += pcWave[dwPosition1];
		//lM2 += pcWave[dwPosition2];

		// Equivalent C Code that can be done with a pmadd
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;


#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#include "debug.h"
#endif

typedef unsigned __int64 QWORD;

#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono8X(short * pBuffer, 
							   DWORD dwLength,
							   DWORD dwDeltaPeriod,
							   VFRACT vfDeltaVolume,
							   VFRACT vfLastVolume[],
							   PFRACT pfDeltaPitch, 
							   PFRACT pfSampleLength, 
							   PFRACT pfLoopLength)
{
    DWORD dwI;    
    DWORD dwIncDelta = dwDeltaPeriod;
    
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.


	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfVolume
	movd	mm7, vfVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaVolume
	movd	mm6, vfDeltaVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfVFract += vfDeltaVolume;
											// vfVFract += vfDeltaVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		inc		ecx					//dwI++;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		//shl		esi, 1			// do not shift left since pcWave is array of chars
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movzx	esi, word ptr[esi]	//lLM1 = pcWave[dwPosition1];
		movd	mm3, esi

		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		//shl		edi, 1			//do not shift left since pcWave is array of chars
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;
		
		movzx	edi, word ptr[edi]	//lLM2 = pcWave[dwPoisition2];
		movd	mm6, edi

		pxor	mm7, mm7		// zero out mm7 to make 8 bit into 16 bit
					
								// low 4 bytes in mm3
		punpcklwd	mm3, mm6	// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1]											
		
		add		esi, pBuffer	//
	punpcklbw	mm7, mm3		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		

		movq	mm3, mm2		// put left and right volume levels in mm3
		add		eax, ebx		//pfSamplePos += pfPitch;

		packssdw	mm3, mm2		// words in mm7
								// vfVolume, vfVolume, vfVolume, vfVolume
									
		movd	mm5, dword ptr[esi-2]	// Load values from buffer
		inc		ecx				// dwI++;
						
		psrad	mm7, 12			// shift back down to 16 bits.

	packssdw	mm7, mm4		// only need one word in mono case.
								// low word are lm2 and lm1
										        
		// above multiplies and shifts are all done with this one pmul. Low two word are only
		// interest in mono case
		pmulhw		mm3, mm7	// lLM1 *= vfVolume;								
								// lLM2 *= vfVolume;
								
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movd	dword ptr[esi-2], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		//shl		esi, 1				// do not shift left since pcWave is array of chars
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		movzx	esi, word ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		pxor	mm7, mm7
								// low four bytes
		movd	mm4, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 

								// 8 bytes after unpakc
		punpcklbw	mm7, mm4	// 0, 0, 0, 0, pcWave[dwPos1+1], 0, pcWave[dwPos1], 0
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits
				
		movq		mm5, mm2	// move volume into mm5
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer

		movd	edx, mm5

		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:		
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfVolume;
    //vfLastVolume[1] = vfVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
#if 0 
	movd	[edx]this.m_vfLastVolume[0], mm2	
	movd	[edx]this.m_vfLastVolume[1], mm2
#endif
	movd	vfLastVolume[0], mm2	
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI);
}
#endif

DWORD CDigitalAudio::Mix8X(short * pBuffer, 
						   DWORD dwLength, 
						   DWORD dwDeltaPeriod,
						   VFRACT vfDeltaLVolume, 
						   VFRACT vfDeltaRVolume,
						   VFRACT vfLastVolume[],
						   PFRACT pfDeltaPitch, 
						   PFRACT pfSampleLength, 
						   PFRACT pfLoopLength)

{
    DWORD dwI;
    //DWORD dwPosition1, dwPosition2;
    //long lM1, lLM1;
	//long lM2, lLM2;
    DWORD dwIncDelta = dwDeltaPeriod;
    //VFRACT dwFract1, dwFract2;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];

	VFRACT vfLVolume2 = vfLastVolume[0];
    VFRACT vfRVolume2 = vfLastVolume[1];

    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
	dwLength <<= 1;

	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfLVolume
	movd	mm7, vfRVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaLVolume
	movd	mm6, vfDeltaRVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfLVFract += vfDeltaLVolume;
											// vfRVFract += vfDeltaRVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		add		ecx, 2				//dwI += 2;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		//shl		esi, 1			// do not shift left since pcWave is array of chars
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movzx	esi, word ptr[esi]	//lLM1 = pcWave[dwPosition1];

		movd	mm3, esi

		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		//shl		edi, 1			// do not shift left since pcWave is array of chars
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		
					
		movzx	edi, word ptr[edi]	//lLM2 = pcWave[dwPosition2];
		movd	mm6, edi
	
		pxor	mm7, mm7		// zero out mm7 to make 8 bit into 16 bit

								// low 4 bytes bytes in mm3
	punpcklwd	mm3, mm6		// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
		
		add		esi, pBuffer	//
	punpcklbw	mm7, mm3		// bytes in mm7
								// pcWave[dwPos2+1], 0, pcWave[dwPos2], 0, pcWave[dwPos1+1], pcWave[dwPos1], 0 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		

		movq	mm3, mm2		// put left and right volume levels in mm3

		add		eax, ebx		//pfSamplePos += pfPitch;
	packssdw	mm3, mm2		// words in mm3
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		movq	mm5, qword ptr[esi-4]	// Load values from buffer
		add		ecx, 2			// dwI += 2;
						
		psrad	mm7, 12			// shift back down to 16 bits.

		pand	mm7, wordmask	// combine results to get ready to multiply by left and right
		movq	mm6, mm7		// volume levels.
		pslld	mm6, 16			//
		por		mm7, mm6		// words in mm7
								// lM2, lM2, lM1, lM1
										        
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm3, mm7	// lLM1 *= vfLVolume;
								// lM1 *= vfRVolume;
								// lLM2 *= vfLVolume;
								// lM2 *= vfRVolume;
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movq	qword ptr[esi-4], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		//shl		esi, 1				// do not shift left since pcWave is array of chars
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		movzx	esi, word ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

		pxor	mm7, mm7
								// byte in MMX registers
		movd	mm4, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 

		punpcklbw	mm7, mm4	// 0, 0, 0, 0, pcWave[dwPos1+1], 0, pcWave[dwPos1], 0
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits

		pand		mm7, wordmask	// combine results to get ready to multiply by left and right 
		movq		mm6, mm7		// volume levels.
		pslld		mm6, 16			//
		por			mm7, mm6		// words in mm7
									// lM2, lM2, lM1, lM1

		pxor		mm6, mm6

		movq		mm5, mm2	// move volume1 into mm5
								
								// use pack to get 4 volume values together for multiplication.
		packssdw	mm5, mm6    // words in mm7
								// 0, 0, vfRVolume1, vfLVolume1
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer		

/*
		add		word ptr[edi-4], si
        jno		no_oflowl1
		// pBuffer[dwI] = 0x7fff;
		mov		word ptr[edi-4], 0x7fff
        js  no_oflowl1
        //pBuffer[dwI] = (short) 0x8000;
		mov		word ptr[edi-4], 0x8000
no_oflowl1:
		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:
*/
		movd	mm7, dword ptr[edi-4]		
		paddsw	mm7, mm5
		movd	dword ptr[edi-4], mm7
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfLVolume;
    //vfLastVolume[1] = vfRVolume;
	// need to shift volume back down to 12 bits before storing
#if 0
	psrld	mm2, 3
	movd	[edx]this.m_vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	[edx]this.m_vfLastVolume[1], mm2
#endif
	psrld	mm2, 3
	movd	vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI >> 1);
}

#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono16X(short * pBuffer, 
								DWORD dwLength,
								DWORD dwDeltaPeriod,
								VFRACT vfDeltaVolume,
							    VFRACT vfLastVolume[],
								PFRACT pfDeltaPitch, 
								PFRACT pfSampleLength, 
								PFRACT pfLoopLength)

{
    DWORD dwI;    
    
    
    DWORD dwIncDelta = dwDeltaPeriod;
    
    short * pcWave = (short*) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.


	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfVolume
	movd	mm7, vfVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaVolume
	movd	mm6, vfDeltaVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfVFract += vfDeltaVolume;
											// vfVFract += vfDeltaVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		inc		ecx					//dwI++;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		shl		esi, 1			// shift left since pcWave is array of shorts
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movd	mm7, dword ptr[esi]	//lLM1 = pcWave[dwPosition1];
		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		shl		edi, 1			// shift left since pcWave is array of shorts
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		movq	mm3, mm2		// put left and right volume levels in mm3
		
					
		movd	mm6, dword ptr[edi]	//lLM2 = pcWave[dwPosition2];
	packssdw	mm3, mm2		// words in mm7
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		add		esi, pBuffer	//
	punpckldq	mm7, mm6		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		
		add		eax, ebx		//pfSamplePos += pfPitch;
		
		movd	mm5, dword ptr[esi-2]	// Load values from buffer
		inc		ecx				// dwI++;
						
		psrad	mm7, 12			// shift back down to 16 bits.

	packssdw	mm7, mm4		// only need one word in mono case.
								// low word are lm2 and lm1
										        
		// above multiplies and shifts are all done with this one pmul. Low two word are only
		// interest in mono case
		pmulhw		mm3, mm7	// lLM1 *= vfVolume;								
								// lLM2 *= vfVolume;
								
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movd	dword ptr[esi-2], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		shl		esi, 1				// shift left since pcWave is array of shorts
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		mov		esi, dword ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		movd	mm7, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits
				
		movq		mm5, mm2	// move volume into mm5
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer

		movd	edx, mm5

		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:		
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfVolume;
    //vfLastVolume[1] = vfVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
#if 0
	movd	[edx]this.m_vfLastVolume[0], mm2	
	movd	[edx]this.m_vfLastVolume[1], mm2
#endif
	movd	vfLastVolume[0], mm2	
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI);
}
#endif

DWORD CDigitalAudio::Mix16X(short * pBuffer, 
							DWORD dwLength, 
							DWORD dwDeltaPeriod,
							VFRACT vfDeltaLVolume, 
							VFRACT vfDeltaRVolume,
						    VFRACT vfLastVolume[],
							PFRACT pfDeltaPitch, 
							PFRACT pfSampleLength, 
							PFRACT pfLoopLength)
{
    DWORD dwI;
    //DWORD dwPosition1, dwPosition2;
    //long lM1, lLM1;
	//long lM2, lLM2;
    DWORD dwIncDelta = dwDeltaPeriod;
    //VFRACT dwFract1, dwFract2;
    short * pcWave = (short *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];

	VFRACT vfLVolume2 = vfLastVolume[0];
    VFRACT vfRVolume2 = vfLastVolume[1];

    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
	dwLength <<= 1;

	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfLVolume
	movd	mm7, vfRVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaLVolume
	movd	mm6, vfDeltaRVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfLVFract += vfDeltaLVolume;
											// vfRVFract += vfDeltaRVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		add		ecx, 2				//dwI += 2;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		shl		esi, 1			// shift left since pcWave is array of shorts
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movd	mm7, dword ptr[esi]	//lLM1 = pcWave[dwPosition1];
		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		shl		edi, 1			// shift left since pcWave is array of shorts
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		movq	mm3, mm2		// put left and right volume levels in mm3
		
					
		movd	mm6, dword ptr[edi]	//lLM2 = pcWave[dwPosition2];
	packssdw	mm3, mm2		// words in mm7
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		add		esi, pBuffer	//
	punpckldq	mm7, mm6		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		
		add		eax, ebx		//pfSamplePos += pfPitch;
		
		movq	mm5, qword ptr[esi-4]	// Load values from buffer
		add		ecx, 2			// dwI += 2;
						
		psrad	mm7, 12			// shift back down to 16 bits.

		pand	mm7, wordmask	// combine results to get ready to multiply by left and right
		movq	mm6, mm7		// volume levels.
		pslld	mm6, 16			//
		por		mm7, mm6		// words in mm7
								// lM2, lM2, lM1, lM1
										        
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm3, mm7	// lLM1 *= vfLVolume;
								// lM1 *= vfRVolume;
								// lLM2 *= vfLVolume;
								// lM2 *= vfRVolume;
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movq	qword ptr[esi-4], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		shl		esi, 1				// shift left since pcWave is array of shorts
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		mov		esi, dword ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		movd	mm7, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits

		pand		mm7, wordmask	// combine results to get ready to multiply by left and right 
		movq		mm6, mm7		// volume levels.
		pslld		mm6, 16			//
		por			mm7, mm6		// words in mm7
									// lM2, lM2, lM1, lM1

		pxor		mm6, mm6

		movq		mm5, mm2	// move volume1 into mm5
								
								// use pack to get 4 volume values together for multiplication.
		packssdw	mm5, mm6    // words in mm7
								// 0, 0, vfRVolume1, vfLVolume1
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer		

/*
		add		word ptr[edi-4], si
        jno		no_oflowl1
		// pBuffer[dwI] = 0x7fff;
		mov		word ptr[edi-4], 0x7fff
        js  no_oflowl1
        //pBuffer[dwI] = (short) 0x8000;
		mov		word ptr[edi-4], 0x8000
no_oflowl1:
		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:
*/
		movd	mm7, dword ptr[edi-4]		
		paddsw	mm7, mm5
		movd	dword ptr[edi-4], mm7
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfLVolume;
    //vfLastVolume[1] = vfRVolume;
	// need to shift volume back down to 12 bits before storing
#if 0
	psrld	mm2, 3
	movd	[edx]this.vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	[edx]this.vfLastVolume[1], mm2
#endif 
	psrld	mm2, 3
	movd	vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI >> 1);
}

static BOOL MMXDisabled()
{
    ULONG ulValue = FALSE;

    if (!GetRegValueDword(
            TEXT("Software\\Microsoft\\DirectMusic"),
            TEXT("MMXDisabled"),
            &ulValue))
    {
        return FALSE;
    }

    return (BOOL)ulValue;
}

#define CPU_ID _asm _emit 0x0f _asm _emit 0xa2  

BOOL MultiMediaInstructionsSupported()
{
    static  BOOL bMultiMediaInstructionsSupported = FALSE;
    static  BOOL bFlagNotSetYet = TRUE;
    
    // No need to keep interogating the CPU after it has been checked the first time
    if (bFlagNotSetYet)
    {
        bFlagNotSetYet = FALSE;         // Don't repeat the check for each call
		if (!MMXDisabled())
		{
			_asm 
			{
				pushfd                      // Store original EFLAGS on stack
				pop     eax                 // Get original EFLAGS in EAX
				mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
				xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
				push    eax                 // Save new EFLAGS value on stack
				popfd                       // Replace current EFLAGS value
				pushfd                      // Store new EFLAGS on stack
				pop     eax                 // Get new EFLAGS in EAX
				xor     eax, ecx            // Can we toggle ID bit?
				jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
				mov     eax, 1              // Set EAX to tell the CPUID instruction what to return
				push	ebx
				CPU_ID                      // Get family/model/stepping/features
				pop		ebx
				test    edx, 0x00800000L    // Check if mmx technology available
				jz      Done                // Jump if no
			}
			// Tests have passed, this machine supports the Intel MultiMedia Instruction Set!
			bMultiMediaInstructionsSupported = TRUE;
Done:
			NULL;
		}
    }

#if DBG
	if ( bMultiMediaInstructionsSupported )
	{
		Trace(1,"MMX - Detected, Enabling MMX mixing\n\r");
	}
	else
	{
		Trace(1,"MMX - Not Detected\n\r");
	}
#endif

    return (bMultiMediaInstructionsSupported);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\stdafx.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard methods for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		    = TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\sources.inc ===
!IF 0

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

NOTE:	The file ddksources in this directory structure is used to build the
        DDK sythesizer sample.  If you make changes to this file, make sure
        to keep ddksources in sync as well.  See ddkreadme.txt for more info.

!ENDIF

!include ..\..\dmusic.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmsynth

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF


TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\dmsynth.def
DLLENTRY=_DllMainCRTStartup
USE_MAPSYM=1
USE_MSVCRT=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!else
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Oxt

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 -DREVERB_ENABLED -D_DMUSIC_USER_MODE_

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib		\
	   $(SDK_LIB_PATH)\user32.lib		\
	   $(SDK_LIB_PATH)\winmm.lib		\
	   $(SDK_LIB_PATH)\advapi32.lib		\
	   $(SDK_LIB_PATH)\uuid.lib         \
           $(SDK_LIB_PATH)\ole32.lib        \
           $(SDK_LIB_PATH)\dsound.lib

SOURCES=\
..\clist.cpp			\
..\control.cpp			\
..\csynth.cpp			\
..\instr.cpp			\
..\midi.cpp				\
..\mix.cpp				\
..\voice.cpp			\
..\dmsynth.rc			\
..\debug.cpp			\
..\dmsynth.cpp			\
..\dslink.cpp			\
..\guids.cpp			\
..\oledll.cpp			\
..\plclock.cpp			\
..\sverb.c				\
..\umsynth.cpp          \
..\opnew.cpp            \
..\mixmulti.cpp

i386_SOURCES=       \
mmx.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\stdafx.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__58C2B4C5_46E7_11D1_89AC_00A0C9054129__INCLUDED_)
#define AFX_STDAFX_H__58C2B4C5_46E7_11D1_89AC_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__58C2B4C5_46E7_11D1_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\sverb.h ===
/***********************************************************
Copyrights : ksWaves Ltd. 1998.

Provided to Microsoft under contract between ksWaves and Microsoft.

************************************************************/

/****************************************************************************
Const defines :
*****************************************************************************/
#define FPU_DENORM_OFFS (float)1.0E-30

#define BASE_REV_DELAY  0x4000
#define BASE_DSPS_DELAY 0x800

#define DSPS_MASK   0x7ff
#define REV_MASK    0x3fff

/****************************************************************************
Coefs Struct :
*****************************************************************************/
typedef struct
{

	long mySize;
	long myVersion;
	float SampleRate;

	float directGain; 
	long  l_directGain; 
	float revGain; 
	long l_revGain; 

	long lDelay1;
	long lDelay2;
	long lDelay3;
	long lDelay4;

	long lDDly1; 
	long lDDly2; 

	float dDsps;
	long l_dDsps;

	float dDG1;
	long l_dDG1;

	float dDG2; 
	long l_dDG2; 

	float dFB11;
	long l_dFB11;
	float dFB12;
	long l_dFB12;
	float dFB21;
	long l_dFB21;
	float dFB22;
	long l_dFB22;
	float dFB31;
	long l_dFB31;
	float dFB32;
	long l_dFB32;
	float dFB41;
	long l_dFB41;
	float dFB42;
	long l_dFB42;

	float dDamp;
	long l_dDamp;


} sCoefsStruct;

/****************************************************************************
Initialization and control functions :
*****************************************************************************/

#ifdef __cplusplus
extern "C"
{
#endif

#define MAX_16 (float)((unsigned long)0x00008000)

void InitSVerbStates( long *pStates );
long DToF32( float dbl  );
void ConvertCoefsToFix( void *pC );
void InitSVerb( float SampleRate, void  *pCoefs);
void SetSVerb( float InGain, float dRevMix,  float dRevTime, 
			    float dHighFreqRTRatio, void  *pCoefs );



long GetCoefsSize(void);
long GetStatesSize(void);
long GetSVerbVersion(void);

float VerifySampleRate(void  *pCoefs);
long VerifyVersion(void  *pCoefs);
long VerifySize(void  *pCoefs);


#define CLIP_SHORT_TO_SHORT(x)\
			if (x>32767)\
				x = 32767;\
			else if (x<-32768)\
				x = -32768;

/****************************************************************************
//Process Functions :
*****************************************************************************/

__inline void dsps( float *pDly, long ref, long delay, float dDG1, float dDsps, float *inL, float *inR );
__inline void dspsL( long *pDly, long ref, long delay, long dDG1, long dDsps, long *inL, long *inR );

void SVerbMonoToMonoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbMonoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbStereoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbMonoToMonoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);

void SVerbMonoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);

void SVerbStereoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\umsynth.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
// UMSynth.h : Declaration of CUserModeSynth

#ifndef __UMSYNTH_H_
#define __UMSYNTH_H_

#include <ks.h>
#include <ksproxy.h>
#include <mmsystem.h>
#include "dsound.h"   
#include "dmusicc.h"
#include "dmusics.h"
#include "CSynth.h"
#include "synth.h"
#include "dsoundp.h"    // For IDirectSoundSource

class CUserModeSynth;

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
// {F5038F82-C052-11D2-872F-00600893B1BD}
DEFINE_GUID(CLSID_DDKSynth, 
0xf5038f82, 0xc052, 0x11d2, 0x87, 0x2f, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT

typedef HRESULT (CUserModeSynth::*GENPROPHANDLER)(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);

#define GENPROP_F_STATIC                0x00000000
#define GENPROP_F_FNHANDLER             0x00000001


#include <pshpack4.h>
struct GENERICPROPERTY
{
    const GUID *pguidPropertySet;       // What property set?
    ULONG       ulId;                   // What item?

    ULONG       ulSupported;            // Get/Set flags for QuerySupported

    ULONG       ulFlags;                // GENPROP_F_xxx

    LPVOID      pPropertyData;          // Data to be returned
    ULONG       cbPropertyData;         // and its size    

    GENPROPHANDLER pfnHandler;          // Handler fn iff GENPROP_F_FNHANDLER
};
#include <poppack.h>

/////////////////////////////////////////////////////////////////////////////
// CDMSynth

class CUserModeSynth : public IDirectMusicSynth8, public IDirectSoundSource, public IKsControl
{
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
friend class CDSLink;
friend class CClock;
// @@END_DDKSPLIT

public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDirectMusicSynth
public:
	virtual STDMETHODIMP Open(LPDMUS_PORTPARAMS pPortParams);
	virtual STDMETHODIMP Close(); 
	virtual STDMETHODIMP SetNumChannelGroups(DWORD dwGroups);
	virtual STDMETHODIMP Download(LPHANDLE phDownload, LPVOID pvData, LPBOOL pbFree);
	virtual STDMETHODIMP Unload(HANDLE hDownload,
								HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
								HANDLE hUserData);
	virtual STDMETHODIMP PlayBuffer(REFERENCE_TIME rt, LPBYTE pbBuffer, DWORD cbBuffer);
	virtual STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
	virtual STDMETHODIMP GetPortCaps(LPDMUS_PORTCAPS pCaps);
	virtual STDMETHODIMP SetMasterClock(IReferenceClock *pClock);
	virtual STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
	virtual STDMETHODIMP Activate(BOOL fEnable);
	virtual STDMETHODIMP SetSynthSink(IDirectMusicSynthSink *pSynthSink);
	virtual STDMETHODIMP Render(short *pBuffer, DWORD dwLength, LONGLONG llPosition);
    virtual STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    virtual STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
    virtual STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize);
    virtual STDMETHODIMP GetAppend(DWORD* pdwAppend);

// IDirectMusicSynth8
public:
	virtual STDMETHODIMP PlayVoice(REFERENCE_TIME rt, DWORD dwVoiceId, DWORD dwChannelGroup, DWORD dwChannel, DWORD dwDLId, PREL prPitch, VREL vrVolume, SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd );
    virtual STDMETHODIMP StopVoice(REFERENCE_TIME rt, DWORD dwVoiceId );
    virtual STDMETHODIMP GetVoiceState(DWORD dwVoice[], DWORD cbVoice, DMUS_VOICE_STATE VoiceState[] );
    virtual STDMETHODIMP Refresh(DWORD dwDownloadID, DWORD dwFlags );
    virtual STDMETHODIMP AssignChannelToBuses(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwBuses, DWORD cBuses );

// IDirectSoundSource
public:
    virtual STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
    virtual STDMETHODIMP SetSink(IDirectSoundConnect* pSinkConnect);
    virtual STDMETHODIMP Seek(ULONGLONG sp);
    virtual STDMETHODIMP Read(LPVOID *ppvBuffer, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchBends, DWORD cpvBuffer, PULONGLONG pcb);
	virtual STDMETHODIMP GetSize(PULONGLONG pcb);

// IDirectSoundSource : members 
private:
	ULONGLONG m_ullPosition;

// IKsControl
public:
 	virtual STDMETHODIMP KsProperty(
		PKSPROPERTY pPropertyIn, 
		ULONG ulPropertyLength,
		LPVOID pvPropertyData, 
		ULONG ulDataLength,
		PULONG pulBytesReturned);

    virtual STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    virtual STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
	CUserModeSynth();
	~CUserModeSynth();
	HRESULT		Init();

private:
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
	HRESULT		UseDefaultSynthSink();
// @@END_DDKSPLIT
	long		m_cRef;
	IDirectMusicSynthSink *m_pSynthSink;
	IDirectSoundSynthSink *m_pSynthSink8;
	CSynth *	m_pSynth;		// Just one synth engine.
	BOOL		m_fActive;		// Currently active.
	DWORD		m_dwSampleRate;	// Synths sample rate 
	DWORD		m_dwChannels;	// number of ouput channels 
	DWORD 		m_dwBufferFlags;// flags the type of output buffer dssink or interleaved or plain mono
    LONG        m_lVolume;      // in 1/100 dB
    LONG        m_lBoost;       // in 1/100 dB
    LONG        m_lGainAdjust;  // in 1/100 dB
    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.
    BOOL        m_fCSInitialized;

    HRESULT HandleSetVolume(
        ULONG               ulId, 
        BOOL                fSet, 
        LPVOID              pbBuffer, 
        PULONG              pcbBuffer);

    HRESULT HandleSetBoost(
        ULONG               ulId, 
        BOOL                fSet, 
        LPVOID              pbBuffer, 
        PULONG              pcbBuffer);
        
	HRESULT HandleReverb(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
	HRESULT HandleEffects(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    HRESULT HandleGetSampleRate(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    static GENERICPROPERTY m_aProperty[];
    static const int m_nProperty;
    //static GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);
    GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);

};

// Class factory
//
// Common to emulation/WDM.
// 
class CDirectMusicSynthFactory : public IClassFactory
{
public:
	// IUnknown
    //
	virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CDirectMusicSynthFactory();

	// Destructor
	~CDirectMusicSynthFactory();

private:
	long m_cRef;
};



#endif //__UMSYNTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\umsynth.cpp ===
//
// Copyright (c) 1996-2001 Microsoft Corporation
// UMSynth.cpp : Implementation of CUserModeSynth
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//

#pragma warning(disable:4530)

#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include <ks.h>

#include "debug.h"
#include "UMSynth.h"
#include "dmusicc.h"
#include "dmusics.h"
#include "math.h"
#include "misc.h"
#include "dmksctrl.h"
#include "dsoundp.h"    // For IDirectSoundSource
#include "..\shared\dmusiccp.h" // For class ids.

#include <dmusprop.h>

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
#include "..\shared\validate.h"
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
#include "validate.h"
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT

extern long g_cComponent;

/////////////////////////////////////////////////////////////////////
// User mode registry helper
//
BOOL GetRegValueDword(
    LPCTSTR szRegPath,
    LPCTSTR szValueName,
    LPDWORD pdwValue)
{
    HKEY  hKeyOpen;
    DWORD dwType;
    DWORD dwCbData;
    LONG  lResult;
    BOOL  fReturn = FALSE;

    assert(pdwValue);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           szRegPath,
                           0, KEY_QUERY_VALUE,
                           &hKeyOpen );

    if (lResult == ERROR_SUCCESS)
    {
        dwCbData = sizeof(DWORD);

        lResult = RegQueryValueEx(hKeyOpen,
                                  szValueName,
                                  NULL,
                                  &dwType,
                                  (LPBYTE)pdwValue,
                                  &dwCbData);

        if (lResult == ERROR_SUCCESS &&
            dwType == REG_DWORD)
        {
            fReturn = TRUE;
        }

        RegCloseKey( hKeyOpen );
    }

    return fReturn;
}

DWORD GetTheCurrentTime()
{
    static BOOL s_fFirstTime = TRUE;
    static LARGE_INTEGER s_liPerfFrequency;
    static BOOL s_fUsePerfCounter = FALSE;
    if (s_fFirstTime)
    {
        s_fFirstTime = FALSE;
        s_fUsePerfCounter = QueryPerformanceFrequency(&s_liPerfFrequency);
        s_liPerfFrequency.QuadPart /= 1000;
    }
    if (s_fUsePerfCounter)
    {
        LARGE_INTEGER liPerfCounter;
        QueryPerformanceCounter(&liPerfCounter);
        liPerfCounter.QuadPart /= s_liPerfFrequency.QuadPart;
        return (DWORD) liPerfCounter.QuadPart;
    }
    else
    {
        return timeGetTime();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CUserModeSynth

HRESULT CUserModeSynth::Init()
{
    return S_OK;
}

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
HRESULT CUserModeSynth::UseDefaultSynthSink()
{
    HRESULT hr = S_OK;
    if (!m_pSynthSink)
    {
        IDirectMusicSynthSink *pSink = NULL;
        hr = CoCreateInstance(CLSID_DirectMusicSynthSink,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDirectMusicSynthSink,
                              (void **) &pSink);
        if (pSink)
        {
            SetSynthSink(pSink);
            pSink->Release();
        }
    }
    return hr;
}
// @@END_DDKSPLIT

CUserModeSynth::CUserModeSynth()
{
    InterlockedIncrement(&g_cComponent);

    m_fCSInitialized = FALSE;
    ::InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
    m_fCSInitialized = TRUE;

    m_cRef = 0;
    m_dwSampleRate = 22050;
    m_dwChannels = 2;
    m_lVolume = 0;
    m_lBoost = 6 * 100;
    m_lGainAdjust = 6 * 100;            // Default 6 dB boost
    m_fActive = FALSE;
    m_pSynth = NULL;
    m_pSynthSink = NULL;
    m_pSynthSink8 = NULL;
    m_ullPosition = 0;
    m_dwBufferFlags = BUFFERFLAG_INTERLEAVED;
}

CUserModeSynth::~CUserModeSynth()
{
    Activate(FALSE);

    if (m_fCSInitialized)
    {
        ::EnterCriticalSection(&m_CriticalSection);
        if (m_pSynth)
        {
            delete m_pSynth;
            m_pSynth = NULL;
        }

        if (m_pSynthSink)
        {
            m_pSynthSink->Release();
        }

        if (m_pSynthSink8)
        {
            m_pSynthSink8->Release();
        }

        ::LeaveCriticalSection(&m_CriticalSection);
        ::DeleteCriticalSection(&m_CriticalSection);
    }

      InterlockedDecrement(&g_cComponent);
}


// CUserModeSynth::QueryInterface
//
STDMETHODIMP
CUserModeSynth::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicSynth::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicSynth) {
        *ppv = static_cast<IDirectMusicSynth*>(this);
    }
    else if (iid == IID_IKsControl)
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else if (iid == IID_IDirectMusicSynth8 )
    {
        *ppv = static_cast<IDirectMusicSynth8*>(this);
    }
    else if (iid == IID_IDirectSoundSource)
    {
        *ppv = static_cast<IDirectSoundSource*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

// CUserModeSynth::AddRef
//
STDMETHODIMP_(ULONG)
CUserModeSynth::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CUserModeSynth::Release
//
STDMETHODIMP_(ULONG)
CUserModeSynth::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CUserModeSynth::SetSynthSink(
    IDirectMusicSynthSink *pSynthSink)    // <i IDirectMusicSynthSink> to connect to synth, or
                                        // NULL to disconnect.
{
    HRESULT hr = S_OK;
    V_INAME(IDirectMusicSynth::SetSynthSink);
    V_INTERFACE_OPT(pSynthSink);

    ::EnterCriticalSection(&m_CriticalSection);

//>>>>>>>>. RELEASE THE DSINK IF PRESENT !!!!

    if (m_pSynthSink)
    {
        hr = m_pSynthSink->Init(NULL);
        m_pSynthSink->Release();
    }

    m_pSynthSink = pSynthSink;

//>>>>>>>>> the current state of the format of the the synth is
//>>>>>>>>> ambiguos if a sink has been previously applied.
    m_dwBufferFlags &= ~BUFFERFLAG_MULTIBUFFER;    // .... just in case

    if (m_pSynthSink)
    {
        m_pSynthSink->AddRef();
        hr = m_pSynthSink->Init(static_cast<IDirectMusicSynth*>(this));
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::Open(
    LPDMUS_PORTPARAMS pPortParams)        // <t DMUS_PORTPARAMS> structure for opening the port. If NULL, default settings are used.
{
    V_INAME(IDirectMusicSynth::Open);
    //if (pPortParams == NULL)
    //{
    //    Trace(1, "Error: Open called with NULL PortParams.\n");
    //    return E_FAIL;
    //}

    DWORD cbPortParams = 0;
    DWORD dwVer;

    if (pPortParams)
    {
        V_STRUCTPTR_READ_VER(pPortParams, dwVer);
        V_STRUCTPTR_READ_VER_CASE(DMUS_PORTPARAMS, 7);
        V_STRUCTPTR_READ_VER_CASE(DMUS_PORTPARAMS, 8);
        V_STRUCTPTR_READ_VER_END(DMUS_PORTPARAMS, pPortParams);

        switch (dwVer)
        {
            case 7:
                cbPortParams = sizeof(DMUS_PORTPARAMS7);
                break;

            case 8:
                cbPortParams = sizeof(DMUS_PORTPARAMS8);
                break;
        }
    }

    bool bPartialOpen = false;

    DMUS_PORTPARAMS myParams;
    myParams.dwSize = sizeof (myParams);
    myParams.dwVoices = 32;
    myParams.dwChannelGroups = 2;
    myParams.dwAudioChannels = 2;
    myParams.dwSampleRate = 22050;
#ifdef REVERB_ENABLED
    myParams.dwEffectFlags = DMUS_EFFECT_REVERB;
#else
    myParams.dwEffectFlags = DMUS_EFFECT_NONE;
#endif
    myParams.fShare = FALSE;
    myParams.dwValidParams =
        DMUS_PORTPARAMS_VOICES |
        DMUS_PORTPARAMS_CHANNELGROUPS |
        DMUS_PORTPARAMS_AUDIOCHANNELS |
        DMUS_PORTPARAMS_SAMPLERATE |
        DMUS_PORTPARAMS_EFFECTS |
        DMUS_PORTPARAMS_SHARE;

    if (pPortParams)
    {
        if (pPortParams->dwSize >= sizeof(DMUS_PORTPARAMS8))
        {
            myParams.dwValidParams |= DMUS_PORTPARAMS_FEATURES;
            myParams.dwFeatures = 0;
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_VOICES)
        {
            if (pPortParams->dwVoices)
            {
                if (pPortParams->dwVoices <= MAX_VOICES)
                {
                    myParams.dwVoices = pPortParams->dwVoices;
                }
                else
                {
                    bPartialOpen = true;
                    myParams.dwVoices = MAX_VOICES;
                }
            }
            else
            {
                bPartialOpen = true;
                myParams.dwVoices = 1; // MIN_VOICES
            }
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
        {
            if (pPortParams->dwChannelGroups)
            {
                if (pPortParams->dwChannelGroups <= MAX_CHANNEL_GROUPS)
                {
                    myParams.dwChannelGroups = pPortParams->dwChannelGroups;
                }
                else
                {
                    bPartialOpen = true;
                    myParams.dwChannelGroups = MAX_CHANNEL_GROUPS;
                }
            }
            else
            {
                bPartialOpen = true;
                myParams.dwChannelGroups = 1; // MIN_CHANNEL_GROUPS
            }
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_AUDIOCHANNELS)
        {
            if (pPortParams->dwAudioChannels)
            {
                if (pPortParams->dwAudioChannels <= 2)
                {
                    myParams.dwAudioChannels = pPortParams->dwAudioChannels;
                }
                else
                {
                    bPartialOpen = true;
                    myParams.dwAudioChannels = 2; // MAX_AUDIO_CHANNELS
                }
            }
            else
            {
                bPartialOpen = true;
                myParams.dwAudioChannels = 1; // MIN_AUDIO_CHANNELS
            }
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SAMPLERATE)
        {
            if (dwVer == 7)
            {
                // DX-7 compat: clamp sample rate to one of the
                // understood rates.
                //
                if (pPortParams->dwSampleRate > 30000)
                {
                    if(pPortParams->dwSampleRate != 44100)
                    {
                        bPartialOpen = true;
                    }

                    myParams.dwSampleRate = 44100;
                }
                else if (pPortParams->dwSampleRate > 15000)
                {
                    if(pPortParams->dwSampleRate != 22050)
                    {
                        bPartialOpen = true;
                    }

                    myParams.dwSampleRate = 22050;
                }
                else
                {
                    if(pPortParams->dwSampleRate != 11025)
                    {
                        bPartialOpen = true;
                    }

                    myParams.dwSampleRate = 11025;
                }
            }
            else
            {
                if (pPortParams->dwSampleRate > 96000)
                {
                    bPartialOpen = true;
                    myParams.dwSampleRate = 96000;
                }
                else if (pPortParams->dwSampleRate < 11025)
                {
                    bPartialOpen = true;
                    myParams.dwSampleRate = 11025;
                }
                else myParams.dwSampleRate = pPortParams->dwSampleRate;
            }
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_EFFECTS)
        {
            if (pPortParams->dwEffectFlags & ~DMUS_EFFECT_REVERB)
            {
                bPartialOpen = true;
                pPortParams->dwEffectFlags &= DMUS_EFFECT_REVERB;
            }

#ifdef REVERB_ENABLED
            myParams.dwEffectFlags = pPortParams->dwEffectFlags;
#else
            myParams.dwEffectFlags = DMUS_EFFECT_NONE;
            if (pPortParams->dwEffectFlags & DMUS_EFFECT_REVERB)
            {
                bPartialOpen = true;
            }
#endif
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SHARE)
        {
            if (pPortParams->fShare)
            {
                bPartialOpen = true;
            }
        }

        if ((pPortParams->dwValidParams & DMUS_PORTPARAMS_FEATURES) &&
            (pPortParams->dwSize >= sizeof(DMUS_PORTPARAMS8)))
        {
            myParams.dwFeatures = pPortParams->dwFeatures;
        }
    }

    if (pPortParams)
    {
        DWORD dwSize = min(cbPortParams, myParams.dwSize);

        memcpy(pPortParams, &myParams, dwSize);
        pPortParams->dwSize = dwSize;
    }

    m_dwSampleRate = myParams.dwSampleRate;
    m_dwChannels = myParams.dwAudioChannels;
    m_dwBufferFlags = (m_dwChannels==1)?BUFFERFLAG_MONO:BUFFERFLAG_INTERLEAVED;

    ::EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = DMUS_E_ALREADYOPEN;
    if (!m_pSynth)
    {
        try
        {
            m_pSynth = new CSynth;
        }
        catch( ... )
        {
            m_pSynth = NULL;
        }

        if (!m_pSynth)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = m_pSynth->Open(myParams.dwChannelGroups,
                myParams.dwVoices,
                (myParams.dwEffectFlags & DMUS_EFFECT_REVERB) ? TRUE : FALSE);
            if (SUCCEEDED(hr))
            {
                m_pSynth->SetGainAdjust(m_lGainAdjust);
                m_pSynth->Activate(m_dwSampleRate, m_dwBufferFlags);
            }
            else
            {
                delete m_pSynth;
                m_pSynth = NULL;
            }
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    if(SUCCEEDED(hr))
    {
        if(bPartialOpen)
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

STDMETHODIMP CUserModeSynth::SetNumChannelGroups(
    DWORD dwGroups)        // Number of ChannelGroups requested.
{
    ::EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
    if (m_pSynth)
    {
        hr = m_pSynth->SetNumChannelGroups(dwGroups);
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CUserModeSynth::Close()
{
    ::EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = DMUS_E_ALREADYCLOSED;
    if (m_pSynth)
    {
        hr = m_pSynth->Close();
        delete m_pSynth;
        m_pSynth = NULL;
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}
STDMETHODIMP CUserModeSynth::Download(
    LPHANDLE phDownload,    // Pointer to download handle, to be created by <om IDirectMusicSynth::Download> and used later to unload the data.
    LPVOID pvData,          // Pointer to continuous memory segment with download data.
    LPBOOL pbFree)          // <p pbFree> indicates whether the synthesizer wishes to keep the memory in <p pvData> allocated.
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
    V_INAME(IDirectMusicSynth::Download);
    V_PTR_WRITE(phDownload, HANDLE);
    V_PTR_WRITE(pbFree, BOOL);

    // pvData is validated inside synth while parsing.
    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->Download(phDownload, pvData, pbFree);
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::Unload(
    HANDLE hDownload,   // Handle to data, previously downloaded with a call to <om IDirectMusicSynth::Download>.
    HRESULT ( CALLBACK *lpFreeHandle)(HANDLE, HANDLE), // If the original call to
                        // <om IDirectMusicSynth::Download> returned FALSE in <p pbFree>,
                        // the synthesizer hung onto the memory in the download chunk. If so,
                        // the caller must be notified once the memory has been freed,
                        // but that could occur later than <om IDirectMusicSynth::Download>
                        // since a wave might be currently in use. <p lpFreeHandle> is a
                        // pointer to a callback
                        // function which will be called when the memory is no longer in use.
    HANDLE hUserData)   // Pointer to user data, passed as a parameter to the
                        // <p lpFreeHandle> function, typically used so the callback routine can retrieve
                        // its state.
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->Unload(hDownload, lpFreeHandle, hUserData);
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CUserModeSynth::PlayBuffer(
    REFERENCE_TIME rt,  // Start time of the buffer. This should be in
                        // REFERENCE_TIME units, relative to the master
                        // clock, previously set with a call to <om IDirectMusicSynth::SetMasterClock>.
                        // And, this should be after the time returned by the clock in
                        // <om IDirectMusicSynth::GetLatencyClock>.
    LPBYTE pbBuffer,    // Memory chunk with all the MIDI events, generated by <i IDirectMusicBuffer>.
    DWORD cbBuffer)     // Size of buffer.
{
    class MIDIEVENT : public DMUS_EVENTHEADER {
    public:
         BYTE  abEvent[4];           /* Actual event data, rounded up to be an even number */
                                     /* of QWORD's (8 bytes) */
    };

    typedef class MIDIEVENT FAR  *LPMIDIEVENT;
    #define QWORD_ALIGN(x) (((x) + 7) & ~7)

    HRESULT hr = DMUS_E_NOT_INIT;

    V_INAME(IDirectMusicSynth::PlayBuffer);
    V_BUFPTR_READ(pbBuffer, cbBuffer);

    ::EnterCriticalSection(&m_CriticalSection);

    if (!m_pSynthSink && !m_pSynthSink8)
    {
        ::LeaveCriticalSection(&m_CriticalSection);
        return DMUS_E_NOSYNTHSINK;
    }

    if (!m_fActive)
    {
        ::LeaveCriticalSection(&m_CriticalSection);
        Trace(3, "Warning: Synth is inactive, can not process MIDI events.\n");
        return DMUS_E_SYNTHINACTIVE;
    }

    LPMIDIEVENT lpEventHdr;
    DWORD cbEvent;

    while (cbBuffer)
    {
        if (cbBuffer < sizeof(DMUS_EVENTHEADER))
        {
            Trace(1, "Error: PlayBuffer called with error in buffer size.\n");
            ::LeaveCriticalSection(&m_CriticalSection);
            return E_INVALIDARG;
        }

        lpEventHdr = (LPMIDIEVENT)pbBuffer;
        cbEvent = DMUS_EVENT_SIZE(lpEventHdr->cbEvent);
        if (cbEvent > cbBuffer)
        {
            Trace(1, "Error: PlayBuffer called with error in event size.\n");
            ::LeaveCriticalSection(&m_CriticalSection);
            return E_INVALIDARG;
        }

        pbBuffer += cbEvent;
        cbBuffer -= cbEvent;
        if ( m_pSynthSink )
        {
            hr = m_pSynth->PlayBuffer(m_pSynthSink,
                                      rt + lpEventHdr->rtDelta,
                                      &lpEventHdr->abEvent[0],
                                      lpEventHdr->cbEvent,
                                      lpEventHdr->dwChannelGroup);
        }

        if ( m_pSynthSink8 )
        {
            hr = m_pSynth->PlayBuffer(m_pSynthSink8,
                                      rt + lpEventHdr->rtDelta,
                                      &lpEventHdr->abEvent[0],
                                      lpEventHdr->cbEvent,
                                      lpEventHdr->dwChannelGroup);
        }

        if (FAILED(hr))
        {
            ::LeaveCriticalSection(&m_CriticalSection);
            return hr;
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}


STDMETHODIMP CUserModeSynth::GetPortCaps(
    LPDMUS_PORTCAPS pCaps)    // <t DMUS_PORTCAPS> structure to be filled in by synth.
{
    V_INAME(IDirectMusicSynth::GetPortCaps);
    V_STRUCTPTR_WRITE(pCaps, DMUS_PORTCAPS);

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    wcscpy(pCaps->wszDescription, L"Microsoft Synthesizer");
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
    wcscpy(pCaps->wszDescription, L"Microsoft DDK Synthesizer");
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT

    pCaps->dwClass = DMUS_PC_OUTPUTCLASS;
    pCaps->dwType = DMUS_PORT_USER_MODE_SYNTH;
    pCaps->dwFlags = DMUS_PC_DLS | DMUS_PC_DLS2 | DMUS_PC_SOFTWARESYNTH |
        DMUS_PC_DIRECTSOUND | DMUS_PC_AUDIOPATH | DMUS_PC_WAVE;

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    pCaps->guidPort = CLSID_DirectMusicSynth;
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
    pCaps->guidPort = CLSID_DDKSynth;
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT

    pCaps->dwMemorySize = DMUS_PC_SYSTEMMEMORY;
    pCaps->dwMaxChannelGroups = MAX_CHANNEL_GROUPS;
    pCaps->dwMaxVoices = MAX_VOICES;
    pCaps->dwMaxAudioChannels = 2;

    pCaps->dwEffectFlags = 0;
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    pCaps->dwEffectFlags = DMUS_EFFECT_REVERB;
// @@END_DDKSPLIT

    return S_OK;
}

STDMETHODIMP CUserModeSynth::SetMasterClock(
    IReferenceClock *pClock)    // Pointer to master <i IReferenceClock>,
                                // used by all devices in current instance of DirectMusic.

{
    V_INAME(IDirectMusicSynth::SetMasterClock);
    V_INTERFACE(pClock);

    return S_OK;
}

STDMETHODIMP CUserModeSynth::GetLatencyClock(
    IReferenceClock **ppClock)    // <i IReferenceClock> interface designed to return the current mix time.

{
    IDirectSoundSynthSink* pDSSink = NULL;

    V_INAME(IDirectMusicSynth::GetLatencyClock);
    V_PTR_WRITE(ppClock, IReferenceClock *);

    HRESULT hr = DMUS_E_NOSYNTHSINK;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynthSink)
    {
         hr = m_pSynthSink->GetLatencyClock(ppClock);
         ::LeaveCriticalSection(&m_CriticalSection);
    }
     else if (m_pSynthSink8)
    {
         pDSSink = m_pSynthSink8;
         ::LeaveCriticalSection(&m_CriticalSection);

         // FIXME:: The call to GetLatencyClock requres the DSound DLL Mutex and
         // so we have to be outside of the Synth CriticalSection to make the call
         // In theory, pDSSink could have been released by another thread at this point
         //
         // That happens if we get a simultaneous call to the destructor or to SetSink.
         try
         {
            hr = pDSSink->GetLatencyClock(ppClock);
         }
         catch(...)
         {
            // If we're here the pointer to pDSSink has gone bad.
            hr = E_UNEXPECTED;
         }

    }
    else // still need to leave the critical section...
    {
         ::LeaveCriticalSection(&m_CriticalSection);
    }

    return hr;
}

STDMETHODIMP CUserModeSynth::Activate(
    BOOL fEnable)            // Whether to activate or deactivate audio.
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

//    ::EnterCriticalSection(&m_CriticalSection);
    if (fEnable)
    {
        if (m_pSynthSink || m_pSynthSink8)
        {
            if (!m_fActive)
            {
                if (m_dwSampleRate && m_dwChannels)
                {
                    if (m_pSynth)
                    {
                        m_pSynth->Activate(m_dwSampleRate, m_dwBufferFlags);

                        if (m_pSynthSink)
                        {
                            if (SUCCEEDED(m_pSynthSink->Activate(fEnable)))
                            {
                                m_fActive = TRUE;
                                hr = S_OK;
                            }
                        }

                        if ( m_pSynthSink8 )
                        {
                            hr = m_pSynthSink8->Activate(fEnable);
                            if (SUCCEEDED(hr) || hr == DMUS_E_SYNTHACTIVE)
                            {
                                m_fActive = TRUE;
                                hr = S_OK;
                            }
                        }
                    }
                }
            }
            else
            {
                Trace(1, "Error: Synth::Activate- synth already active\n");
                hr = DMUS_E_SYNTHACTIVE;
//>>>>>>>>>>>>>>>>>>>>> what's this about test it before removing????
hr = S_FALSE;
            }
        }
        else
        {
            Trace(1, "Error: Synth::Activate- sink not connected\n");
            hr = DMUS_E_NOSYNTHSINK;
        }
    }
    else
    {
        if (m_fActive)
        {
            m_fActive = FALSE;
            if (m_pSynth)
            {
                m_pSynth->Deactivate();
            }

            if (m_pSynthSink)
            {
                if (SUCCEEDED(m_pSynthSink->Activate(fEnable)))
                {
                    hr = S_OK;
                }
            }

            if (m_pSynthSink8)
            {
                hr = m_pSynthSink8->Activate(fEnable);
            }
        }
        else
        {
            Trace(2, "Warning: Synth::Activate- synth already inactive\n");
            hr = S_FALSE;
        }
    }
//    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CUserModeSynth::Render(
    short *pBuffer,        // Pointer to buffer to write into.
    DWORD dwLength,        // Length of buffer, in samples. This is not the
                        // memory size of the buffer. The memory size may vary,
                        // dependant on the buffer format, which the synth
                        // sets when in response to an <om IDirectMusicSynth::Activate>
                        // command.
    LONGLONG llPosition)    // Position in the audio stream, also in samples.
                        // This should always increment by <p dwLength> after
                        // each call.
{
    V_INAME(IDirectMusicSynth::Render);
    V_BUFPTR_WRITE(pBuffer, dwLength << (m_dwBufferFlags&BUFFERFLAG_INTERLEAVED)?1:0 );

    if (!m_pSynthSink)
    {
        Trace(1, "Error: Synth is not configured, can not render.\n");
        return DMUS_E_SYNTHNOTCONFIGURED;
    }
    if (!m_fActive)
    {
        Trace(1, "Error: Synth is not inactive, can not render.\n");
        return DMUS_E_SYNTHINACTIVE;
    }

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        DWORD dwID[2];
        DWORD dwFuncID[2];
        long lPitchBend[2];

        // Setup busid for a Backward compatible DX7 interleaved buffer
        dwID[0]     = DSBUSID_LEFT;
        dwID[1]     = DSBUSID_RIGHT;
        dwFuncID[0] = DSBUSID_LEFT;
        dwFuncID[1] = DSBUSID_RIGHT;
        lPitchBend[0] = lPitchBend[1] = 0;

        DWORD dwChannels = 1;
        if (m_pSynth->m_dwStereo)
        {
            dwChannels = 2;
        }
        m_pSynth->Mix(&pBuffer, dwID, dwFuncID, lPitchBend, dwChannels, m_dwBufferFlags, dwLength, llPosition);
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

STDMETHODIMP CUserModeSynth::SetChannelPriority(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    DWORD dwPriority)
{
    if (m_pSynth)
    {
        return m_pSynth->SetChannelPriority(dwChannelGroup, dwChannel, dwPriority);
    }
    Trace(1, "Error: Synth not initialized.\n");
    return E_FAIL;
}

STDMETHODIMP CUserModeSynth::GetChannelPriority(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwPriority)
{
    if (m_pSynth)
    {
        return m_pSynth->GetChannelPriority(dwChannelGroup, dwChannel, pdwPriority);
    }
    Trace(1, "Error: Synth not initialized.\n");
    return E_FAIL;
}

// IDirectSoundSource version of GetFormat()

STDMETHODIMP CUserModeSynth::GetFormat(
    LPWAVEFORMATEX pWaveFormatEx,
    DWORD dwSizeAllocated,
    LPDWORD pdwSizeWritten)
{
    V_INAME(IDirectMusicSynth::GetFormat);

    if (!m_pSynth)
    {
        Trace(1, "Error: Synth is not configured, can not get format.\n");
        return DMUS_E_SYNTHNOTCONFIGURED;
    }

    if (!pWaveFormatEx && !pdwSizeWritten)
    {
        Trace(1, "Error: GetFormat failed, must request either the format or the required size");
        return E_INVALIDARG;
    }

    if (pdwSizeWritten)
    {
        V_PTR_WRITE(pdwSizeWritten, DWORD);
        *pdwSizeWritten = sizeof(WAVEFORMATEX);
    }

    if (pWaveFormatEx)
    {
        V_BUFPTR_WRITE_OPT(pWaveFormatEx, dwSizeAllocated);
        WAVEFORMATEX wfx;
        memset(&wfx, 0, sizeof(wfx));
        wfx.wFormatTag = WAVE_FORMAT_PCM;
        wfx.nChannels = (WORD)m_dwChannels;
        wfx.nSamplesPerSec = (WORD)m_dwSampleRate;
        wfx.wBitsPerSample = 16;
        wfx.nBlockAlign = wfx.nChannels * (wfx.wBitsPerSample / 8);
        wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
        wfx.cbSize = 0; // no extra data

        memcpy(pWaveFormatEx, &wfx, min(sizeof wfx, dwSizeAllocated));
    }

    return S_OK;
}

// IDirectMusicSynth8 version of GetFormat()

STDMETHODIMP CUserModeSynth::GetFormat(
    LPWAVEFORMATEX pWaveFormatEx,
    LPDWORD pdwWaveFormatExSize)
{
    V_INAME(IDirectMusicSynth::GetFormat);
    V_PTR_WRITE(pdwWaveFormatExSize, DWORD);
    V_BUFPTR_WRITE_OPT(pWaveFormatEx, *pdwWaveFormatExSize);
    return GetFormat(pWaveFormatEx, *pdwWaveFormatExSize, pdwWaveFormatExSize);
}

STDMETHODIMP CUserModeSynth::GetAppend(
    DWORD* pdwAppend)
{
    V_INAME(IDirectMusicSynth::GetAppend);
    V_PTR_WRITE(pdwAppend, DWORD);

    *pdwAppend = 2; // The synth needs 1 extra sample for loop interpolation.
                    // We're adding one more to be paranoid.
    return S_OK;
}

STDMETHODIMP CUserModeSynth::GetRunningStats(
    LPDMUS_SYNTHSTATS pStats)    // <t DMUS_SYNTHSTATS> structure to fill in.

{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
    V_INAME(IDirectMusicSynth::GetRunningStats);
    V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS);
    if ( pStats->dwSize == sizeof(DMUS_SYNTHSTATS8) )
    {
        V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS8);
    }

    if (!m_pSynthSink && !m_pSynthSink8)
    {
        Trace(1, "Error: Synth::GetRunningStats failed because synth is inactove.\n");
        return hr;
    }

    if (m_fActive)
    {
        ::EnterCriticalSection(&m_CriticalSection);
        if (m_pSynth)
        {
            PerfStats Stats;
            m_pSynth->GetPerformanceStats(&Stats);
            long lCPU = Stats.dwCPU;
            if (Stats.dwVoices)
            {
                lCPU /= Stats.dwVoices;
            }
            else
            {
                lCPU = 0;
            }
            pStats->dwVoices = Stats.dwVoices;
            pStats->dwCPUPerVoice = lCPU * 10;
            pStats->dwTotalCPU = Stats.dwCPU * 10;
            pStats->dwLostNotes = Stats.dwNotesLost;
            long ldB = 6;
            double fLevel = Stats.dwMaxAmplitude;
            if (Stats.dwMaxAmplitude < 1)
            {
                fLevel = -96.0;
            }
            else
            {
                fLevel /= 32768.0;
                fLevel = log10(fLevel);
                fLevel *= 20.0;
            }
            pStats->lPeakVolume = (long) fLevel;
            pStats->dwValidStats = DMUS_SYNTHSTATS_VOICES | DMUS_SYNTHSTATS_TOTAL_CPU |
                DMUS_SYNTHSTATS_CPU_PER_VOICE | DMUS_SYNTHSTATS_LOST_NOTES | DMUS_SYNTHSTATS_PEAK_VOLUME;

            if ( pStats->dwSize == sizeof(DMUS_SYNTHSTATS8) )
            {
                ((DMUS_SYNTHSTATS8*)pStats)->dwSynthMemUse = m_pSynth->m_Instruments.m_dwSynthMemUse;
            }


            hr = S_OK;
        }
        ::LeaveCriticalSection(&m_CriticalSection);
    }
    else
    {
        DWORD dwSize = pStats->dwSize;
        memset(pStats, 0, dwSize);
        pStats->dwSize = dwSize;

        hr = S_OK;
    }
    return hr;
}

static DWORD dwPropFalse = FALSE;
static DWORD dwPropTrue  = TRUE;
static DWORD dwSystemMemory = DMUS_PC_SYSTEMMEMORY;

GENERICPROPERTY CUserModeSynth::m_aProperty[] =
{
    {
        &GUID_DMUS_PROP_GM_Hardware,        // Set
        0,                                  // Item
        KSPROPERTY_SUPPORT_GET,             // KS support flags
        GENPROP_F_STATIC,                   // GENPROP flags
        &dwPropFalse, sizeof(dwPropFalse),  // static data and size
        NULL                                // Handler
    },
    {   &GUID_DMUS_PROP_GS_Hardware,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropFalse, sizeof(dwPropFalse),
        NULL
    },
    {   &GUID_DMUS_PROP_XG_Hardware,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropFalse, sizeof(dwPropFalse),
        NULL
    },
    {   &GUID_DMUS_PROP_XG_Capable,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropTrue, sizeof(dwPropTrue),
        NULL
    },
    {   &GUID_DMUS_PROP_GS_Capable,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropTrue, sizeof(dwPropTrue),
        NULL
    },
    {   &GUID_DMUS_PROP_INSTRUMENT2,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropTrue, sizeof(dwPropTrue),
        NULL
    },
    {
        &GUID_DMUS_PROP_DLS1,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropTrue,  sizeof(dwPropTrue),
        NULL
    },
    {
        &GUID_DMUS_PROP_DLS2,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropTrue,  sizeof(dwPropTrue),
        NULL
    },
    {
        &GUID_DMUS_PROP_SampleMemorySize,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwSystemMemory,  sizeof(dwSystemMemory),
        NULL
    },
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOLUME,
        KSPROPERTY_SUPPORT_SET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleSetVolume
    },
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOLUMEBOOST,
        KSPROPERTY_SUPPORT_SET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleSetBoost
    },
    {
        &GUID_DMUS_PROP_WavesReverb,
        0,
        KSPROPERTY_SUPPORT_SET | KSPROPERTY_SUPPORT_GET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleReverb
    },
    {
        &GUID_DMUS_PROP_Effects,
        0,
        KSPROPERTY_SUPPORT_SET | KSPROPERTY_SUPPORT_GET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleEffects
    },
    {
        &GUID_DMUS_PROP_SamplePlaybackRate,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleGetSampleRate
    }
};

const int CUserModeSynth::m_nProperty = sizeof(m_aProperty) / sizeof(m_aProperty[0]);

HRESULT CUserModeSynth::HandleGetSampleRate(
        ULONG               ulId,
        BOOL                fSet,
        LPVOID              pbBuffer,
        PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(LONG))
    {
        return E_INVALIDARG;
    }
    if (!fSet)
    {
        *(long*)pbBuffer = m_dwSampleRate;
    }
    return S_OK;
}

HRESULT CUserModeSynth::HandleSetVolume(
        ULONG               ulId,
        BOOL                fSet,
        LPVOID              pbBuffer,
        PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(LONG))
    {
        return E_INVALIDARG;
    }

    m_lVolume =  *(LONG*)pbBuffer;
    m_lGainAdjust = m_lVolume + m_lBoost;

    if (m_pSynth)
    {
        m_pSynth->SetGainAdjust(m_lGainAdjust);
    }
    return S_OK;
}

HRESULT CUserModeSynth::HandleSetBoost(
        ULONG               ulId,
        BOOL                fSet,
        LPVOID              pbBuffer,
        PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(LONG))
    {
        return E_INVALIDARG;
    }

    m_lBoost =  *(LONG*)pbBuffer;
    m_lGainAdjust = m_lVolume + m_lBoost;

    if (m_pSynth)
    {
        m_pSynth->SetGainAdjust(m_lGainAdjust);
    }
    return S_OK;
}

HRESULT CUserModeSynth::HandleReverb(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer)
{
    DMUS_WAVES_REVERB_PARAMS *pParams;
    if (*pcbBuffer != sizeof(DMUS_WAVES_REVERB_PARAMS))
    {
        return E_INVALIDARG;
    }

    pParams = (DMUS_WAVES_REVERB_PARAMS *) pbBuffer;
    if (m_pSynth)
    {
        if (fSet)
        {
            m_pSynth->SetReverb(pParams);
        }
        else
        {
            m_pSynth->GetReverb(pParams);
        }
    }

    return S_OK;
}

HRESULT CUserModeSynth::HandleEffects(
    ULONG               ulId,
    BOOL                fSet,
    LPVOID              pbBuffer,
    PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(LONG))
    {
        return E_INVALIDARG;
    }
    if (fSet)
    {
        long lEffects = *(long*)pbBuffer;

        if (m_pSynth)
        {
            m_pSynth->SetReverbActive(lEffects & DMUS_EFFECT_REVERB);
        }
    }
    else
    {
        if (m_pSynth && m_pSynth->IsReverbActive())
        {
            *(long*)pbBuffer = DMUS_EFFECT_REVERB;
        }
        else
        {
            *(long*)pbBuffer = 0;
        }
    }
    return S_OK;
}

//
// CDirectMusicEmulatePort::FindPropertyItem
//
// Given a GUID and an item ID, find the associated property item in the synth's
// table of SYNPROPERTY's.
//
// Returns a pointer to the entry or NULL if the item was not found.
//
GENERICPROPERTY *CUserModeSynth::FindPropertyItem(REFGUID rguid, ULONG ulId)
{
    GENERICPROPERTY *pPropertyItem = &m_aProperty[0];
    GENERICPROPERTY *pEndOfItems = pPropertyItem + m_nProperty;

    // Special Case -- We don't support Waves Reverb on a SinthSink8
    if ((rguid == GUID_DMUS_PROP_WavesReverb) && (this->m_pSynthSink8 != NULL))
        return NULL;

    for (; pPropertyItem != pEndOfItems; pPropertyItem++)
    {
        if (*pPropertyItem->pguidPropertySet == rguid &&
             pPropertyItem->ulId == ulId)
        {
            return pPropertyItem;
        }
    }



    return NULL;
}

#define KS_VALID_FLAGS (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET| KSPROPERTY_TYPE_BASICSUPPORT)

STDMETHODIMP CUserModeSynth::KsProperty(
    PKSPROPERTY pPropertyIn, ULONG ulPropertyLength,
    LPVOID pvPropertyData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pPropertyIn, ulPropertyLength);

    DWORD dwFlags = pPropertyIn->Flags & KS_VALID_FLAGS;

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
            break;

        case KSPROPERTY_TYPE_SET:
            V_BUFPTR_READ(pvPropertyData, ulDataLength);
            break;

        case KSPROPERTY_TYPE_BASICSUPPORT:
            V_BUFPTR_WRITE(pvPropertyData, ulDataLength);
            break;
    }


    V_PTR_WRITE(pulBytesReturned, ULONG);

    GENERICPROPERTY *pProperty = FindPropertyItem(pPropertyIn->Set, pPropertyIn->Id);

    if (pProperty == NULL)
    {
        Trace(2, "Warning: KsProperty call requested unknown property.\n");
        return DMUS_E_UNKNOWN_PROPERTY;
    }

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_GET))
            {
                Trace(1, "Error: SynthSink does not support Get for the requested property.\n");
                return DMUS_E_GET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                *pulBytesReturned = ulDataLength;
                return (this->*pfn)(pPropertyIn->Id, FALSE, pvPropertyData, pulBytesReturned);
            }

            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            if (pvPropertyData != NULL)
            {
                CopyMemory(pvPropertyData, pProperty->pPropertyData, ulDataLength);
            }
            *pulBytesReturned = ulDataLength;

            return S_OK;

        case KSPROPERTY_TYPE_SET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_SET))
            {
                Trace(1, "Error: SynthSink does not support Set for the requested property.\n");
                return DMUS_E_SET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                return (this->*pfn)(pPropertyIn->Id, TRUE, pvPropertyData, &ulDataLength);
            }

            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pProperty->pPropertyData, pvPropertyData, ulDataLength);

            return S_OK;


        case KSPROPERTY_TYPE_BASICSUPPORT:
            if (pProperty == NULL)
            {
                Trace(1, "Error: Synth does not provide support for requested property type.\n");
                return DMUS_E_UNKNOWN_PROPERTY;
            }

            // XXX Find out what convention is for this!!
            //
            if (ulDataLength < sizeof(DWORD))
            {
                Trace(1, "Error: Data size for property is too small.\n");
                return E_INVALIDARG;
            }

            *(LPDWORD)pvPropertyData = pProperty->ulSupported;
            *pulBytesReturned = sizeof(DWORD);

            return S_OK;
    }

    Trace(1, "Error: KSProperty Flags must contain one of: %s\n"
              "\tKSPROPERTY_TYPE_SET, KSPROPERTY_TYPE_GET, or KSPROPERTY_TYPE_BASICSUPPORT\n");
    return E_INVALIDARG;
}

STDMETHODIMP CUserModeSynth::KsMethod(
    PKSMETHOD pMethod, ULONG ulMethodLength,
    LPVOID pvMethodData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynth::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    return DMUS_E_UNKNOWN_PROPERTY;
}
STDMETHODIMP CUserModeSynth::KsEvent(
    PKSEVENT pEvent, ULONG ulEventLength,
    LPVOID pvEventData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    return DMUS_E_UNKNOWN_PROPERTY;
}

/////////////////////////////////////////////////////////////////////
// Implementation of IDirectMusicSynth8

STDMETHODIMP CUserModeSynth::PlayVoice(REFERENCE_TIME rt, DWORD dwVoiceId, DWORD dwChannelGroup, DWORD dwChannel, DWORD dwDLId, PREL prPitch, VREL vrVolume, SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd )
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->PlayVoice(m_pSynthSink8,
                                 rt,
                                 dwVoiceId,
                                 dwChannelGroup,
                                 dwChannel,
                                 dwDLId,
                                 vrVolume,
                                 prPitch,
                                 stVoiceStart,
                                 stLoopStart,
                                 stLoopEnd);
    }
    else
    {
        Trace(1, "Error: Failed wave playback, synth is not properly configured.\n");
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::StopVoice(REFERENCE_TIME rt, DWORD dwVoiceId )
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->StopVoice(m_pSynthSink8,
                                 rt,
                                 dwVoiceId);
    }
    else
    {
        Trace(1, "Error: Failed stop of wave playback, synth is not properly configured.\n");
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::GetVoiceState(DWORD dwVoice[], DWORD cbVoice, DMUS_VOICE_STATE VoiceState[] )
{
    V_INAME(IDirectMusicSynth::GetVoiceState);
    V_PTR_READ(dwVoice, sizeof(DWORD)*cbVoice);

    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {

        hr = m_pSynth->GetVoiceState(dwVoice,
                                     cbVoice,
                                     VoiceState);

    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::Refresh(DWORD dwDownloadID, DWORD dwFlags )
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->Refresh(dwDownloadID,
                               dwFlags);
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::AssignChannelToBuses(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwBuses, DWORD cBuses )
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
    hr = m_pSynth->AssignChannelToBuses(dwChannelGroup,
                                         dwChannel,
                                         pdwBuses,
                                         cBuses);
    }
    else
    {
        Trace(1, "Error: Failed synth channel assignment, synth is not properly configured.\n");
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

/////////////////////////////////////////////////////////////////////
// Implementation of IDirectSoundSource

STDMETHODIMP CUserModeSynth::SetSink(IDirectSoundConnect* pSinkConnect)
{
    V_INAME(IDirectSoundSink::SetSink);
    V_INTERFACE_OPT(pSinkConnect);

    HRESULT hr = S_OK;

    LPVOID ptr = NULL;
    V_BUFPTR_WRITE_OPT(ptr, 0);

    ::EnterCriticalSection(&m_CriticalSection);

//>>>>>>>> RELEASE THE DSLINK IF PRESENT !!!!

// FIXME: The calls into the SynthSink8 may require the DSound DLL Mutex.  If the Sink
// is making a a call to READ then we end up in a deadlock.  We need to be sure that the
// Synth isn't playing when we do this.

    if (m_pSynthSink8)
    {
        // FIXME: whoever called us->SetSink() should previously have called
        // pOldSink->RemoveSource(us) - it shouldn't be our responsibility to
        // do this call (??):
        // m_pSynthSink8->RemoveSource(this);
        m_pSynthSink8->Release();
        m_pSynthSink8 = NULL;
    }

    if (pSinkConnect)
    {
        // Obtain the IDirectSoundSynthSink interface on the sink
        hr = pSinkConnect->QueryInterface(IID_IDirectSoundSynthSink, (void**)&m_pSynthSink8);

        if (SUCCEEDED(hr))
        {
            //
            // Get the sink's format and validate it
            //
            WAVEFORMATEX wfx;
            DWORD dwSize = sizeof wfx;
            hr = m_pSynthSink8->GetFormat(&wfx, dwSize, NULL);
            if (SUCCEEDED(hr) && wfx.wBitsPerSample != 16 )
            {
                Trace(1, "Error; Synth can not write to any format other than 16 bit PCM.\n");
                hr = DMUS_E_WAVEFORMATNOTSUPPORTED;
            }

            if (SUCCEEDED(hr))
            {
                // Flag the buffer format to be non-interleaved
                m_dwChannels = 1;    // This synth with a sink is concidered a mono source.
                m_dwBufferFlags = BUFFERFLAG_MULTIBUFFER;

                if (m_pSynth)
                {
                    m_pSynth->SetStereoMode(m_dwBufferFlags);

                    // reset sample rate if it has changed
                    if (wfx.nSamplesPerSec != (WORD)m_dwSampleRate)
                    {
                        m_pSynth->SetSampleRate(wfx.nSamplesPerSec);
                    }

                    // disable DX7 Reverb
                    m_pSynth->SetReverbActive(FALSE);
                }
            }
        }
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::Seek(ULONGLONG sp)
{
    m_ullPosition = sp/2;    // Convert from bytes to samples

    return S_OK;
}

STDMETHODIMP CUserModeSynth::Read(LPVOID *ppvBuffer, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchBends, DWORD dwBufferCount, PULONGLONG pullLength )
{
    V_INAME(IDirectMusicSynth::Read);
    V_PTR_READ(ppvBuffer, sizeof(LPVOID)*dwBufferCount);
    V_PTR_READ(pdwIDs, sizeof(LPDWORD)*dwBufferCount);

    for ( DWORD i = 0; i < dwBufferCount; i++ )
    {
        V_BUFPTR_WRITE(ppvBuffer[i], (DWORD)*pullLength);
        if ( ppvBuffer[i] == NULL )
        {
            Trace(1, "Error: Read called with NULL buffer.\n");
            return E_INVALIDARG;
        }
    }

    if ( *pullLength > 0x00000000FFFFFFFF )    // can't read more than a DWORD's worth of data
    {
        Trace(1, "Error: Read called with invalid buffer length.\n");
        return E_INVALIDARG;
    }

    if ( dwBufferCount == 0 )                // don't read no buffers
    {
        Trace(4, "Warning: Read called with 0 buffers.\n");
        return E_INVALIDARG;
    }
    if (!m_pSynthSink8)
    {
        Trace(1, "Error: Synth is not configured, can not play.\n");
        return DMUS_E_SYNTHNOTCONFIGURED;
    }
    if (!m_fActive)
    {
        Trace(3, "Warning: Synth is not active, can not play.\n");
        return DMUS_E_SYNTHINACTIVE;
    }

    ::EnterCriticalSection(&m_CriticalSection);

    if (m_pSynth)
    {
        // Mix
        DWORD dwLength = (DWORD)(*pullLength)/2;    // Convert from bytes to number of samples. Synth assumes 16 bit
        m_pSynth->Mix((short**)ppvBuffer, pdwIDs, pdwFuncIDs, plPitchBends, dwBufferCount, m_dwBufferFlags, dwLength, m_ullPosition);

        // Increment current sample position in the audio stream
        m_ullPosition += dwLength;
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}

STDMETHODIMP CUserModeSynth::GetSize(PULONGLONG pcb)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\syslink.cpp ===
// Copyright (c) 1998 Microsoft Corporation
//
// syslink.cpp
//
#include "common.h"
#include <mmsystem.h>


CSysLink::CSysLink()
{
    m_cRef = 1;
}

CSysLink::~CSysLink()
{
}

STDMETHODIMP CSysLink::QueryInterface(const IID &iid, void **ppv)
{
    if (IsEqualGUIDAligned(iid, IID_IUnknown))
    {
        *ppv = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(iid, IID_IDirectMusicSynthSink))
    {
        *ppv = PVOID(PDIRECTMUSICSYNTHSINK(this));
    }
    else
    {
        return E_NOINTERFACE;
    }

    return S_OK;
}

STDMETHODIMP_(ULONG) CSysLink::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSysLink::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSysLink::Init(CSynth *pSynth) 
{
    return S_OK;
}

STDMETHODIMP CSysLink::SetFormat(LPCWAVEFORMATEX pWaveFormat)
{
    return S_OK;
}

STDMETHODIMP CSysLink::SetMasterClock(IReferenceClock *pClock)
{
    return S_OK;
}

STDMETHODIMP CSysLink::GetLatencyClock(IReferenceClock **ppClock)
{
    return S_OK;
}

STDMETHODIMP CSysLink::Activate(HWND hWnd, BOOL fEnable)
{
    return S_OK;
}

STDMETHODIMP CSysLink::SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime)
{
    return S_OK;
}

STDMETHODIMP CSysLink::RefTimeToSample(REFERENCE_TIME rfTime, LONGLONG *pllSampleTime)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\sverb.c ===
/***********************************************************
Copyrights : ksWaves Ltd. 1998.

Provided to Microsoft under contract between ksWaves and Microsoft.

************************************************************/

/***********************************************************
General description :

The functions in this file provides for any apoplication to process audio data
with the SVerb algorithm.

In order to do so the application should :

1. Allocate two chunks of memory for 'Coefs' and 'States' with sizes as returned 
   by the functions 'GetCoefsSize' and 'GetStatesSize' accordingly.
   
2. Initialize these memory chunks using the functions : 'InitSVerb' and 'InitSVerbStates' 
   accordingly.

3. Change the settings of the SVerb sound using the function 'SetSVerb'.

4. Call one of the process functions according to the input/output data format:

   SVerbMonoToMonoShort 
   SVerbMonoToStereoShort
   SVerbStereoToStereoShort 
   SVerbMonoToMonoFloat
   SVerbMonoToStereoFloat
   SVerbStereoToStereoFloat

   The input/output are always the same data type (i.e. both input and output are short integer
   or both are 32bits floats).

   Stereo data format is always'interlaced' left,right samples.

   The 'coefs' and 'states' memory should be passed to the process functions.
   
5. Many coefs structures can be initialized each for different SVerb settings. Passing a different
   coefs structure will cause a real time change of sound quality.

   As long as sound continuity should be maintained the states structure should not be changes or
   re-initialized. Only when a completly new audio sequence is desired should the states be re-initialized.

6. Note that the coefs are valid per sampling rate.

7. Althaugh provisions for coefs compatibility for future versions are provided, it should be avoided to save coefs
   structures to files as-is and re-use them later. Rather the application should save the 'real-world'
   settings of the reverb - namely the parameters passed to 'SetSVerb'. These 'real-world' settings 
   will always be valid for future versions, as well as if other sampling rates are used. The coefs 
   structur(es) should be re-initialized in run time using the real-world settings and call to 
   'SetSverb'.


************************************************************/

#include <windows.h>
#include <String.h>
#include <math.h>
#include "SVerb.h"

#pragma optimize( "ty", on )

/****************************************************************************

Function Name	: GetCoefsSize

Input Arguments : None

Return Value    : The size of memory in bytes, to be allocated in order to hold coefficients.

Description		:  

This function must be called before any calls to other functions that uses the coefs structure.
The calling app must than allocate the returned size of memory and initialize it using 'InitSVerb()'
and 'SetSVerb()'.

The caller should not be botherred by the internals of the coefs structure, rather only konw it's size 
and than allocate enough memory to hold it.

The structure allocated can be used in a very flexible way in order to allow for real-time, pre-computed
changes in Reverb Sound. 

*****************************************************************************/

long GetCoefsSize(void) 
{
	return sizeof(sCoefsStruct); 
};

/****************************************************************************

Function Name	: GetStatesSize

Input Arguments : None

Return Value    : The size of memory in bytes, to be allocated in order to hold states.

Description		:  

This function must be called before any calls to other functions that uses the states structure.
The calling app must than allocate the returned size of memory and initialize it using 'InitSVerbStates()'.

The states allocated are valid in run-time only, and sould be re-initialized only when a complete
new input is to be processed by the SVerb. 

When changing the settings of revevreb in real time while audio is playing, the states should not 
be re-initialized, rather the same passed states must be passed to the process functions in order 
to maintain sound continuity.

*****************************************************************************/

long GetStatesSize(void) 
{
	return sizeof(long)*(BASE_REV_DELAY+2*BASE_DSPS_DELAY+2); 
};

/****************************************************************************

Function Name	: GetSVerbVersion

Input Arguments : None

Return Value    : Version of SVerb implementation - for future compatibility.

Description		:  

Since the caller do not know about the internals of the coefs structure, this function,
together with 'VerifyVersion' function provides a way to verify if a coefs structure
match the version of the reverb used.

This should be needed only if one is using a coefs structure that was saved to file, and 
being used later.

NOTE : In normal operation, this way of usage should be avoided... and only real-world reverb
settings should be saved to files, and re-initialize the coefs in run time.

*****************************************************************************/

long GetSVerbVersion(void) 
{
	return 0x1; 
};

/****************************************************************************

Function Name	: VerifySampleRate

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The sample rate for which this coefs are valid.

Description		:  

When an application uses different sampling rates, and re-uses same coefs structures, 
it should verify that the coefs match the audio sampling rate.

*****************************************************************************/

float VerifySampleRate(void *pC) {
	return ((sCoefsStruct *)pC)->SampleRate; 
};

/****************************************************************************

Function Name	: VerifyVersion

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The version of this coefs structure.

Description		:  

When initialized, each coefs structure is 'stamped' with it's version.
The location of this variable in the structure is fixed, and thus all future versions of
SVerb will know to read it.

Note : as explained above, in normal uses coefs should not be saved to files, rather the 
'real-world' settings should be saved and coefs re-initialized in run-time.
*****************************************************************************/

long VerifyVersion(void *pC) {
	return ((sCoefsStruct *)pC)->myVersion; 
};

/****************************************************************************

Function Name	: VerifySize

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The size of this coefs structure.

Description		:  

When initialized, each coefs structure is 'stamped' with it's size.
The location of this variable in the structure is fixed, and thus all future versions of
SVerb will know to read it.

Note : as explained above, in normal uses coefs should not be saved to files, rather the 
'real-world' settings should be saved and coefs re-initialized in run-time.
*****************************************************************************/

long VerifySize(void *pC) {
	return ((sCoefsStruct *)pC)->mySize; 
};


/****************************************************************************

Function Name	: InitSVerbStates

Input Arguments : 

 float *pStates	: The pointer to the states memory.

Return Value    : none.

Description		:  

After allocating memory for the states, according to thge size returned by 'GetStatesSize'
The application MUST initialize the states using this function. 
Note : in future versions this may be more complex than simply memset to 0...
*****************************************************************************/

void InitSVerbStates( long *pStates )
{
    memset( pStates, 0, GetStatesSize() ) ;
}

/****************************************************************************

Function Name	: DToF16

Input Arguments : 

 float SampleRate	: The sampling rate.
 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

Converts a float number between -1.0 .. 1.0 to a 16bits integer 
fixed point representation.
This allows for fix point arithmetics, where two 16bits integers are multiplied to 
a 32bits integer, and we than take the upper 16 bits of the result.

*****************************************************************************/

long DToF16( float dbl  )
{
	dbl *= MAX_16;
	dbl = max(-MAX_16,min(MAX_16-(float)1.0,dbl+(float)0.5));
	return (long)(dbl);
}

/****************************************************************************

Function Name	: ConvertCoefsToFix

Input Arguments : 

 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  converts coefficients to longs, as fixed point numbers

*****************************************************************************/


void ConvertCoefsToFix( void *pC )
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);

//		float directGain; 

	pCoefs->l_directGain =  DToF16(pCoefs->directGain);

//		float revGain; 
	pCoefs->l_revGain =  DToF16(pCoefs->revGain);
//		float dDsps;
	pCoefs->l_dDsps =  DToF16(pCoefs->dDsps);
//		float dDG1;
	pCoefs->l_dDG1 =  DToF16(pCoefs->dDG1);
//		float dDG2; 
	pCoefs->l_dDG2 =  DToF16(pCoefs->dDG2);
//	float dFB11;
	pCoefs->l_dFB11 =  DToF16(pCoefs->dFB11);
//		float dFB12;
	pCoefs->l_dFB12 =  DToF16(pCoefs->dFB12);
//		float dFB21;
	pCoefs->l_dFB21 =  DToF16(pCoefs->dFB21);
//		float dFB22;
	pCoefs->l_dFB22 =  DToF16(pCoefs->dFB22);
//		float dFB31;
	pCoefs->l_dFB31 =  DToF16(pCoefs->dFB31);
//		float dFB32;
	pCoefs->l_dFB32 =  DToF16(pCoefs->dFB32);
//		float dFB41;
	pCoefs->l_dFB41 =  DToF16(pCoefs->dFB41);
//		float dFB42;
	pCoefs->l_dFB42 =  DToF16(pCoefs->dFB42);
//		float dDamp;
	pCoefs->l_dDamp =  DToF16(pCoefs->dDamp);



}

/****************************************************************************

Function Name	: InitSVerb

Input Arguments : 

 float SampleRate	: The sampling rate.
 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

After allocating memory for the coefs, according to thge size returned by 'GetCoefsSize'
The application MUST initialize the coefs using this function. 
The initialization takes the sampling rate as an argument, ans thus is valid per this
sampling rate only.

It is possible to find out what is the sampling rate a coefs structure is valid for by calling 
the function 'VerifySampleRate'.

This function initialises the SVerb to so reasonable default setting by calling 'SetSVerb' with
the following real-world settings :

InGain				= -3.0dB   (to avoid output overflows)
dRevMix				= -6.0dB   (a reasonable reverb mix)
dRevTime			= 1000.0ms (one second global reverb time)
dHighFreqRTRatio	= 0.001    (the ratio of the high frequencies to the global reverb time) 

*****************************************************************************/

void InitSVerb( float SampleRate, void *pC)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
 	//Magic numbers ...
    long lRefD;
	
	float dRatio =  (float)1.189207115003;
	
	float dD2MRatio = (float)0.2309333333;

	pCoefs->mySize = sizeof(sCoefsStruct);
	pCoefs->myVersion = 0x1;

	pCoefs->dDsps =  (float)0.6180339887499;

	pCoefs->SampleRate = SampleRate;

    lRefD = (long)( 0.5 + 0.045 * pCoefs->SampleRate ) ;

	pCoefs->lDelay1 = lRefD;
	pCoefs->lDelay3 = (long)(0.5 + dRatio * (float)pCoefs->lDelay1);
	pCoefs->lDelay2 = (long)(0.5 + dRatio * (float)pCoefs->lDelay3);
	pCoefs->lDelay4 = (long)(0.5 + dRatio * (float)pCoefs->lDelay2);
  
    pCoefs->lDDly1 = (long)(0.5 + 0.5 * dD2MRatio * (float)(pCoefs->lDelay1+pCoefs->lDelay2));
	pCoefs->lDDly2 = (long)(0.5 + 0.5 * dD2MRatio * (float)(pCoefs->lDelay3+pCoefs->lDelay4));

    pCoefs->lDelay1 -= pCoefs->lDDly1 ;    
    pCoefs->lDelay2 -= pCoefs->lDDly1 ;    
    pCoefs->lDelay3 -= pCoefs->lDDly2 ;    
    pCoefs->lDelay4 -= pCoefs->lDDly2 ;        

    pCoefs->lDelay1 <<= 2;    
    pCoefs->lDelay2 <<= 2;    
    pCoefs->lDelay3 <<= 2;    
    pCoefs->lDelay4 <<= 2;        

	pCoefs->lDDly1 <<= 1;
	pCoefs->lDDly2 <<= 1;

	SetSVerb( (float)0.0, (float)-10.0, (float)1000.0, (float)0.001, pC );

}

/****************************************************************************

Function Name	: SetSVerb

Input Arguments : 

InGain				: input gain in dB (to avoid output overflows)

dRevMix				: Reverb mix in dB. 0dB means 100% wet reverb (no direct signal)
                      Negative values gives less wet signal.
					  The coeficients are calculated so that the overall output level stays 
					  (approximately) constant regardless of the ammount of reverb mix.
dRevTime			: The global reverb time (decay time) in milliseconds.

dHighFreqRTRatio	: The ratio of the high frequencies to the global reverb time. 
					  Unless very 'splashy-bright' reverbs are wanted, this should be set to 
					  a value < 1.0.
					  For example if dRevTime==1000ms and dHighFreqRTRatio=0.1 than the 
					  decay time for high frequencies will be 100ms.

void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

This function accepts the 'real world' settings or SVerb and computes the corresponding 
coefs structure.

The coefs pointer passed to it MUST have been initialized first by InitSVerb.

In normal uses one coefs structure is allocated, initialized, and than as the user changes 
SVerb settings this function should be called repeatedly with the same coefs pointer and the 
new 'real world' settings. 

And the coefs structure passed to the process function in the next buffer to process.

Also few coefs structures can be pre allocated, and initialized, and than different 'presets' 
can be pre-computed into each of them, and switched in real time. 

The coefs structures should not be saved to files by the application for future uses, rather 
the 'real world' settings them selvs. This way future compatibility is guaranteed.

*****************************************************************************/

void SetSVerb( float InGain, float dRevMix, 
			   float dRevTime, float dHighFreqRTRatio, void *pC )
{


	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);

    float dD,dTmp,dInGain,dRevGain;

	float dHfR;
    float dAPS;

    if (dHighFreqRTRatio > (float) 0.999)
    {
        dHighFreqRTRatio = (float) 0.999;
    }
    if (dHighFreqRTRatio <= (float) 0.0)
    {
        dHighFreqRTRatio = (float) 0.001;
    }
    dHfR = ( (float)1.0/dHighFreqRTRatio - (float)1.0);

    if (dRevTime < (float) 0.001) 
    {
        dRevTime = (float) 0.001;
    }

    if (InGain > (float) 0.0)
    {
        InGain = (float) 0.0;
    }

    if (dRevMix > (float) 0.0)
    {
        dRevMix = (float) 0.0;
    }

    if (pCoefs->SampleRate < (float) 1.0) 
    {
        pCoefs->SampleRate = (float) 22050.0;
    }

    dAPS = (float)(-3000.0) / (pCoefs->SampleRate * dRevTime);


    pCoefs->dDamp = 0.0;

 	pCoefs->dDG1 = (float)pow((float)10.0,(float)(pCoefs->lDDly1>>1)*dAPS);
 	pCoefs->dDG2 = (float)pow((float)10.0,(float)(pCoefs->lDDly2>>1)*dAPS);

	//////////////////////////////

		pCoefs->dFB11 = (float)pow((float)10.0,(float)(pCoefs->lDelay1>>2)*dAPS);
        
		dD = pCoefs->dFB11 * pCoefs->dDG1;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly1>>1)+(pCoefs->lDelay1>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB12 = pCoefs->dFB11 * dTmp;
		pCoefs->dFB11 *= ((float)1.0-dTmp);

	///////////////////////////////

		pCoefs->dFB21 = (float)pow((float)10.0,(float)(pCoefs->lDelay2>>2)*dAPS);
        
		dD = pCoefs->dFB21 * pCoefs->dDG1;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly1>>1)+(pCoefs->lDelay2>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB22 = pCoefs->dFB21 * dTmp;
		pCoefs->dFB21 *= ((float)1.0-dTmp);

	////////////////////////////////

		pCoefs->dFB31 = (float)pow((float)10.0,(float)(pCoefs->lDelay3>>2)*dAPS);
        
		dD = pCoefs->dFB31 * pCoefs->dDG2;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
		    pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly2>>1)+(pCoefs->lDelay3>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB32 = pCoefs->dFB31 * dTmp;
		pCoefs->dFB31 *= ((float)1.0-dTmp);


	//////////////////////////////

		pCoefs->dFB41 = (float)pow((float)10.0,(float)(pCoefs->lDelay4>>2)*dAPS);

        dD = pCoefs->dFB41 * pCoefs->dDG2;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly2>>1)+(pCoefs->lDelay4>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB42 = pCoefs->dFB41 * dTmp;
		pCoefs->dFB41 *= ((float)1.0-dTmp);


    pCoefs->dDamp = (float)sqrt(pCoefs->dDamp);

 	dInGain = (float)pow((float)10.0, (float)0.05*InGain ) ;
	dRevMix = (float)pow((float)10.0,(float)0.1*dRevMix);

	dRevGain = (float)4.0 / pCoefs->dDamp * dInGain;

	//in the DSP we used -  	 
	

	pCoefs->directGain = dInGain * (float)sqrt((float)1.0-dRevMix);
	pCoefs->revGain = dRevGain * (float)sqrt(dRevMix);

	ConvertCoefsToFix( pC );

}

///////////////////////////////////////////////////////////////////////////////////////
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/
/* Process functions */
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/

/**********************************************************************************

Bellow are 6 different process functions.
The difference between the functions is only in the input/output data formats.

3 functions support short samples input/output.
3 other functions support float samples input/output.

Per each of the data types there are 3 functions :

  Mono-Mono
  Mono-Stereo
  Stereo-Stereo

The names of the functions are clear to which format they apply.

Stereo data is always interlaced left,right samples.

All process functions have basically the same format namely :

  SVerbXXXXXX(long NumInFrames, short *pInShort, short *pOutShort, 
			  void *pC, float *pStates)

Input arguments :

long NumInFrames	: Number of input frames
short *pInXXX		: Pointer to input buffer.
					  Each function expects the data format suggested by it's name in terms of
					  data type (short or float) and mono/stereo.
short *pOutXXX		: Pointer to output buffer.
					  Each function expects the data format suggested by it's name in terms of
					  data type (short or float) and mono/stereo.

void *pC			: The coefs structure allocated and initialized as explained above.
float *pStates		: The states structure allocated and initialized as explained above.

*******************************************************************************************/

void SVerbMonoToMonoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						  void *pC, long *pStates)
{

	sCoefsStruct *pCoefs =  ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (long)(*pInShort++)>>1;

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			Out1 += Out2;
			CLIP_SHORT_TO_SHORT(Out1)

			*pOutShort++ = (short)(Out1);
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

#ifdef USE_ALL_VERBS
void SVerbMonoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						    void *pC, long *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (long)(*pInShort++);
			In1 += (In1>>1) - (In1>>2);
			In2 = In1;

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			CLIP_SHORT_TO_SHORT(Out1)
			CLIP_SHORT_TO_SHORT(Out2)

			*pOutShort++ = (short)(Out1);
			*pOutShort++ = (short)(Out2);
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}
#endif

void SVerbStereoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						      void *pC, long *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (long)(*pInShort++);
			In2 = (long)(*pInShort++);

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			CLIP_SHORT_TO_SHORT(Out1)
			CLIP_SHORT_TO_SHORT(Out2)

			*pOutShort++ = (short)(Out1);
			*pOutShort++ = (short)(Out2);
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

#ifdef USE_ALL_VERBS

void SVerbMonoToMonoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						  void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (float)0.5 * (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1+Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

void SVerbMonoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						    void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (float)0.7071 * (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1;
			*pOutFloat++ = Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

void SVerbStereoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						      void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (*pInFloat++) + FPU_DENORM_OFFS;
			In2 = (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1;
			*pOutFloat++ = Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

__inline void dsps( float *pDly, long ref, long delay, float dDG1, float dDsps, float *inL, float *inR )
{
	float outL, outR;
	float *pDlyOut; 

    pDlyOut = pDly + ((ref+delay) & DSPS_MASK);
    pDly += (ref & DSPS_MASK);

    outL = dDG1 * (*pDlyOut++) + *inR * dDsps;
	outR = dDG1 * (*pDlyOut) - *inL * dDsps ;

    // here we feed back the output.
	*pDly++ = *inL + dDsps * outR ;
	*pDly = *inR - dDsps * outL ;

	*inL = outL;
	*inR = outR;

}
#endif

__inline void dspsL( long *pDly, long ref, long delay, long dDG1, long dDsps, long *inL, long *inR )
{
	long outL, outR;
	long *pDlyOut; 

    pDlyOut = pDly + ((ref+delay) & DSPS_MASK);
    pDly += (ref & DSPS_MASK);

    outL = (dDG1 * (*pDlyOut++) + *inR * dDsps)>>15;

	outR = (dDG1 * (*pDlyOut) - *inL * dDsps)>>15;

    // here we feed back the output.
	*pDly++ = *inL + ((dDsps * outR)>>15) ;

	*pDly = *inR - ((dDsps * outL)>>15) ;

	*inL = outL;
	*inR = outR;

}
#pragma optimize( "ty", off )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\syslink.h ===
// Copyright (c) 1998 Microsoft Corporation
//
//
// 
#ifndef _SYSLINK_
#define _SYSLINK_

#include <mmsystem.h>

#undef  INTERFACE
#define INTERFACE  IReferenceClock
DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /*  IReferenceClock */
    /*  */
    
    /*  get the time now */
    STDMETHOD(GetTime)                  (THIS_ REFERENCE_TIME *pTime) PURE;

    /*  ask for an async notification that a time has elapsed */
    STDMETHOD(AdviseTime)               (THIS_ REFERENCE_TIME baseTime,         /*  base time */
                                               REFERENCE_TIME streamTime,       /*  stream offset time */
                                               HANDLE hEvent,                   /*  advise via this event */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  ask for an async periodic notification that a time has elapsed */
    STDMETHOD(AdvisePeriodic)           (THIS_ REFERENCE_TIME startTime,        /*  starting at this time */
                                               REFERENCE_TIME periodTime,       /*  time between notifications */
                                               HANDLE hSemaphore,               /*  advise via a semaphore */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  cancel a request for notification */
    STDMETHOD(Unadvise)                 (THIS_ DWORD dwAdviseCookie) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynthSink
DECLARE_INTERFACE_(IDirectMusicSynthSink, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynthSink */
    STDMETHOD(Init)                 (THIS_ CSynth *pSynth) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pWaveFormat) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ HWND hWnd, 
                                           BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,
                                           REFERENCE_TIME *prfTime) PURE;
    STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime, 
                                           LONGLONG *pllSampleTime) PURE;
};

typedef IDirectMusicSynthSink *PDIRECTMUSICSYNTHSINK;

class CSysLink : public IDirectMusicSynthSink
{
public:
    // IUnknown
    //
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *);
    STDMETHOD_(ULONG, AddRef)       (THIS);
    STDMETHOD_(ULONG, Release)      (THIS);

    // IDirectMusicSynthSink
    //
    STDMETHOD(Init)                 (THIS_ CSynth *pSynth);
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pWaveFormat);
	STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock);
	STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock);
	STDMETHOD(Activate)             (THIS_ HWND hWnd, BOOL fEnable);
	STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
	STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime, LONGLONG *pllSampleTime);

    // Class
    //
	CSysLink();
	~CSysLink();

private:
    LONG m_cRef;
};

#define STATIC_IID_IDirectMusicSynthSink \
    0xaec17ce3, 0xa514, 0x11d1, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6
DEFINE_GUIDSTRUCT("aec17ce3-a514-11d1-afa6-00aa0024d8b6", IID_IDirectMusicSynthSink);
#define IID_IDirectMusicSynthSink DEFINE_GUIDNAMED(IID_IDirectMusicSynthSink)

#endif // _SYSLINK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\synth.h ===
//      Synth.h
//      Copyright (c) 1996-1999 Microsoft Corporation
//

/*  For internal representation, volume is stored in Volume Cents, 
    where each increment represents 1/100 of a dB.
    Pitch is stored in Pitch Cents, where each increment
    represents 1/100 of a semitone.
*/ 

#ifndef __SYNTH_H__
#define __SYNTH_H__

#pragma warning(disable:4296)

#include "clist.h"
#include "dmdls.h"
#include "dls2.h"
#include "dsound.h"   
#include "dmusicc.h"

#ifdef DBG
extern DWORD sdwDebugLevel;
#endif

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE

// controller numbers
#define CC_BANKSELECTH  0x00
#define CC_BANKSELECTL  0x20

#define CC_MODWHEEL     0x01
#define CC_VOLUME       0x07
#define CC_PAN          0x0A
#define CC_EXPRESSION   0x0B
#define CC_SUSTAIN      0x40
#define CC_CUTOFFFREQ   0x4A
#define CC_REVERB       0x5B
#define CC_CHORUS       0x5D
#define CC_ALLSOUNDSOFF 0x78
#define CC_RESETALL     0x79
#define CC_ALLNOTESOFF  0x7B
#define CC_MONOMODE     0x7E
#define CC_POLYMODE     0x7F

// rpn controllers
#define CC_DATAENTRYMSB 0x06
#define CC_DATAENTRYLSB 0x26
#define CC_NRPN_LSB     0x62
#define CC_NRPN_MSB     0x63
#define CC_RPN_LSB      0x64
#define CC_RPN_MSB      0x65

// registered parameter numbers
#define RPN_PITCHBEND   0x00
#define RPN_FINETUNE    0x01
#define RPN_COARSETUNE  0x02

/*  Sample format and Sample playback flags are organized
    together because together they determine which 
    mix loop to use.
*/

#define SFORMAT_16              1       // Sixteen bit sample.
#define SFORMAT_8               2       // Eight bit sample.
#define SPLAY_MMX               0x10    // Use MMX processor (16 bit only).
#define SPLAY_INTERLEAVED       0x40    // Interleave Buffer 
#define SPLAY_FILTERED          0x80    // Non-trivial filter coeff's


/*  Output buffer format flags, defines whether the buffers being
    played are multi-buffer, interleave or just plain mono
*/
#define BUFFERFLAG_MONO         0x00000000
#define BUFFERFLAG_INTERLEAVED  0x00000001
#define BUFFERFLAG_MULTIBUFFER  0x00000002


typedef long    PREL;   // Pitch cents, for relative pitch.
typedef short   PRELS;  // Pitch cents, in storage form.
typedef long    VREL;   // Volume cents, for relative volume.
typedef short   VRELS;  // Volume cents, in storage form.
typedef long    TREL;   // Time cents, for relative time
typedef short   TRELS;  // Time Cents, in storage form.
typedef LONGLONG    STIME;  // Time value, in samples.
typedef long    MTIME;  // Time value, in milliseconds.
typedef long    PFRACT; // Pitch increment, where upper 20 bits are
                        // the index and the lower 12 are the fractional
                        // component.
typedef long    VFRACT; // Volume, where lower 12 bits are the fraction.

typedef long    TCENT;
typedef short   SPERCENT;

#define COEFF_UNITY 0x40000000  // 1.0 multiplier as a 2.30 number
typedef unsigned long COEFF;    // 2.30 fixed point filter coefficient
typedef long COEFFDELTA;        // 2.30 fixed point filter coefficient delta value

#define FILTER_PARMS_DIM_Q  16      // the number of different resonances in the filter parameter table (rows)
#define FILTER_PARMS_DIM_FC 89      // the number of different cutoff frequencies in the filter parameter table (cols)
#define FILTER_FREQ_RANGE   10688   // the difference in pitch cents between the sample rate of the filter design and the 

#define MAX_VOLUME      0       // No attenuation and no amplification 
#define MIN_VOLUME     -9600    // Below 96 db down is considered off.
#define PERCEIVED_MIN_VOLUME   -8000   // But, we cheat.
#define SAMPLE_RATE_22  22050   // 22 kHz is the standard rate.
#define SAMPLE_RATE_44  44100   // 44 kHz is the high quality rate.
#define SAMPLE_RATE_11  11025   // 11 kHz should not be allowed!
#define STEREO_ON       1
#define STEREO_OFF      0

#define MAX_DAUD_CHAN 32

#define FORCEBOUNDS(data,min,max) {if (data < min) data = min; else if (data > max) data = max;}

class CControlLogic;

/*
>>>>>>>>> comment 
*/

class CBusIds
{
public:
    CBusIds();
    ~CBusIds();

    HRESULT     Initialize();
    HRESULT     AssignBuses(LPDWORD pdwBusIds, DWORD dwBusCount);

public:
    DWORD       m_dwBusCount;               // Number of Bus Id's
    DWORD       m_dwBusIds[MAX_DAUD_CHAN];  // Array of bus IDs 
};

/*  CSourceLFO is the file format definition of the LFO in an
    instrument. This is used to represent an LFO as part of
    a specific articulation set within an instrument that
    has been loaded from disk. Once the instrument is chosen
    to play a note, this is also copied into the CVoice
    object.
*/

class CSourceLFO
{
public:
                CSourceLFO();
    void        Init(DWORD dwSampleRate);
    void        SetSampleRate(long lDirection);
    void        Verify();           // Verifies that the data is valid.
    PFRACT      m_pfFrequency;      // Frequency, in increments through the sine table.
    STIME       m_stDelay;          // How long to delay in sample units.
    VRELS       m_vrMWVolumeScale;  // Scaling of volume LFO by Mod Wheel.
    PRELS       m_prMWPitchScale;   // Scaling of pitch LFO by Mod Wheel.
    VRELS       m_vrVolumeScale;    // Scaling of straight volume signal from LFO.
    PRELS       m_prPitchScale;     // Scaling of straight pitch signal from LFO.

    /* DirectX8 members */
    PRELS       m_prCPPitchScale;   // Scaling of pitch signal from channel pressure. 
    VRELS       m_vrCPVolumeScale;  // Scaling of volume signal from channel pressure.
//>>>>>>>> comments 
    PRELS       m_prCutoffScale;    // Scaling of Cutoff feq >>>>>> 
    PRELS       m_prMWCutoffScale;  // Scaling of Cutoff feq mod wheel
    PRELS       m_prCPCutoffScale;  // Scaling of Cutoff feq channel pressure
};

/*  CSourceEG is the file format definition of an Envelope
    generator in an instrument.
*/

class CSourceEG
{
public:
                CSourceEG();
    void        SetSampleRate(long lDirection);
    void        Init();
    void        Verify();           // Verifies valid data.
    STIME       m_stAttack;         // Attack rate.
    STIME       m_stDecay;          // Decay rate.
    STIME       m_stRelease;        // Release rate.
    TRELS       m_trVelAttackScale; // Scaling of attack by note velocity.
    TRELS       m_trKeyDecayScale;  // Scaling of decay by note value.
    SPERCENT    m_pcSustain;        // Sustain level.
    short       m_sScale;           // Scaling of entire signal.

    /* DLS2 */
    STIME       m_stDelay;          // Delay rate.
    STIME       m_stHold;           // Hold rate.
    TRELS       m_trKeyHoldScale;   // Scaling of Hold by note value.
//>>>>>>>> comments 
    PRELS       m_prCutoffScale;    // Scaling of Cutoff feq >>>>>>
};

//>>>>>>>> comments 

class CSourceFilter
{
public:
                CSourceFilter();
    void        SetSampleRate(long lDirection);          
    void        Init(DWORD dwSampleRate);
    void        Verify();

    PRELS       m_prSampleRate;     // Sample rate in cents
    PRELS       m_prCutoff;         // Cutoff Frequency in absolute pitch
    PRELS       m_prCutoffSRAdjust; // Cutoff Frequency adjusted to the sampel rate
    VRELS       m_vrQ;              // Resonance
    DWORD       m_iQIndex;          // Q index          
    PRELS       m_prVelScale;       // Scale by key velocity
    PRELS       m_prKeyScale;       // Scaling by note value.
};

/*  CSourceArticulation is the file format definition of
    a complete articulation set: the LFO and two
    envelope generators.
    Since several regions within one Instrument can 
    share one articulation, a counter is used to keep
    track of the usage.
*/

class CSourceArticulation

{
public:
                CSourceArticulation();
    HRESULT     Download(DMUS_DOWNLOADINFO * pInfo, 
                    void * pvOffsetTable[], DWORD dwIndex, 
                    DWORD dwSampleRate, BOOL fNewFormat);
#ifdef DDUMP
    void        Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    void        Init(DWORD dwSampleRate);
    void        Verify();           // Verifies valid data.
    void        AddRef();
    void        Release();
    void        SetSampleRate(DWORD dwSampleRate);
    CSourceEG   m_PitchEG;          // Pitch envelope.
    CSourceEG   m_VolumeEG;         // Volume envelope.
    CSourceLFO  m_LFO;              // Low frequency oscillator.
    DWORD       m_dwSampleRate;
    WORD        m_wUsageCount;      // Keeps track of how many times in use.
    short       m_sDefaultPan;      // default pan (for drums)

    /* DLS2 */
    CSourceLFO  m_LFO2;             // Vibrato
    CSourceFilter m_Filter;         // Low pass filter
};

/*  Since multiple regions may reference
    the same Wave, a reference count is maintained to
    keep track of how many regions are using the sample.
*/

class CWave : public CListItem
{
public:
                    CWave();
                    ~CWave();
#ifdef DDUMP
    void            Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    void            Verify();           // Verifies that the data is valid.
    void            Release();          // Remove reference.
    void            AddRef();           // Add reference.
    void            PlayOn();           // Increment play count.
    void            PlayOff();          // Decrement play count.
    BOOL            IsPlaying();        // Is currently playing?
    CWave *         GetNext() {return(CWave *)CListItem::GetNext();};
    DWORD           m_dwSampleLength;   // Length of sample.
    DWORD           m_dwSampleRate;
    HRESULT ( CALLBACK *m_lpFreeHandle)(HANDLE,HANDLE);
    HANDLE          m_hUserData;        // Used to notify app when wave released.
    short *         m_pnWave;
    DWORD           m_dwID;             // ID for matching wave with regions.
    WORD            m_wUsageCount;      // Keeps track of how many times in use.
    WORD            m_wPlayCount;       // Wave is currently being played.
    BYTE            m_bSampleType;

    /* DirectX 8 members */
    BYTE            m_bStream;          // This wave is used as a streaming buffer
    BYTE            m_bActive;          // This buffer is currently be used to play out of
    BYTE            m_bValid;           // Indicates data in the buffer is valid 
    BYTE            m_bLastSampleInit;  // Indicates the the buffers last sample has been initialize
};


class CWavePool : public CList
{
public:
    CWave *      GetHead() {return (CWave *)CList::GetHead();};
    CWave *      GetItem(DWORD dwID) {return (CWave *)CList::GetItem((LONG)dwID);};
    CWave *      RemoveHead() {return (CWave *)CList::RemoveHead();};
};


/*  The CSourceSample class describes one sample in an
    instrument. The sample is referenced by a CSourceRegion
    structure. 
*/
class Collection;

class CSourceSample
{
public:
                CSourceSample();
                ~CSourceSample();
    BOOL        CopyFromWave();
    void        Verify();           // Verifies that the data is valid.
    CWave *     m_pWave;            // Wave in pool.
    DWORD       m_dwLoopStart;      // Index of start of loop.
    DWORD       m_dwLoopEnd;        // Index of end of loop.
    DWORD       m_dwSampleLength;   // Length of sample.
    DWORD       m_dwSampleRate;     // Sample rate of recording.
    PRELS       m_prFineTune;       // Fine tune to correct pitch.
    DWORD       m_dwID;             // Wave pool id.
    BYTE        m_bSampleType;      // 16 or 8.
    BYTE        m_bOneShot;         // Is this a one shot sample?
    BYTE        m_bMIDIRootKey;     // MIDI note number for sample.
    DWORD       m_dwLoopType;       // WLOOP_TYPE_xxx
};

/*  The CSourceRegion class defines a region within an instrument.
    The sample is managed with a pointer instead of an embedded
    sample. This allows multiple regions to use the same
    sample.
    Each region also has an associated articulation. For drums, there
    is a one to one matching. For melodic instruments, all regions
    share the same articulation. So, to manage this, each region
    points to the articulation.
*/

class CSourceRegion : public CListItem
{
public:
                CSourceRegion();
                ~CSourceRegion();
#ifdef DDUMP
    void        Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    CSourceRegion *GetNext() {return(CSourceRegion *)CListItem::GetNext();};
    void        Verify();           // Verifies that the data is valid.
    void        SetSampleRate(DWORD dwSampleRate);
    HRESULT     Download(DMUS_DOWNLOADINFO * pInfo, void * pvOffsetTable[], 
                    DWORD *pdwRegionIX, DWORD dwSampleRate, BOOL fNewFormat);
    CSourceSample m_Sample;       // Sample structure.
    CSourceArticulation * m_pArticulation; // Pointer to associated articulation.
    VRELS       m_vrAttenuation;    // Volume change to apply to sample.
    PRELS       m_prTuning;         // Pitch shift to apply to sample.
    BYTE        m_bAllowOverlap;    // Allow overlapping of note.
    BYTE        m_bKeyHigh;         // Upper note value for region.
    BYTE        m_bKeyLow;          // Lower note value.
    BYTE        m_bGroup;           // Logical group (for drums.)

    /* DLS2 */
    BYTE        m_bVelocityHigh;    // Upper velocity value for region.
    BYTE        m_bVelocityLow;     // Lower velocity value.
    SHORT       m_sWaveLinkOptions; // Wave link chunk option flags
    DWORD       m_dwChannel;        // Region channels, from WAVELINK chunk

    // Channel in m_dwChannel provides voice destination and overrides anything
    // from the articulation.
    //
    inline BOOL IsMultiChannel() const
    { return (BOOL)(m_sWaveLinkOptions & F_WAVELINK_MULTICHANNEL); }
};


class CSourceRegionList : public CList
{
public:
    CSourceRegion *GetHead() {return (CSourceRegion *)CList::GetHead();};
    CSourceRegion *RemoveHead() {return (CSourceRegion *)CList::RemoveHead();};
};


/*  The CInstrument class is really the file format definition
    of an instrument.
    The CInstrument can be either a Drum or a Melodic instrument.
    If a drum, it has up to 128 pairings of articulations and
    regions. If melodic, all regions share the same articulation.
    ScanForRegion is called by ControlLogic to get the region
    that corresponds to a note.
*/

class CInstManager;

class CInstrument : public CListItem
{
public:
                    CInstrument();
                    ~CInstrument();
#ifdef DDUMP
    void            Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    void            Init(DWORD dwSampleRate);
    void            Verify();           // Verifies that the data is valid.
    CInstrument *   GetInstrument(DWORD dwProgram,DWORD dwAccept);
    CInstrument *   GetNext() {return(CInstrument *)CListItem::GetNext();};
    void            SetSampleRate(DWORD dwSampleRate);
    CSourceRegion * ScanForRegion(DWORD dwNoteValue, DWORD dwVelocity, CSourceRegion *pRegion = NULL);
    CSourceRegionList m_RegionList;     // Linked list of regions.
    DWORD           m_dwProgram;        // Which program change it represents.
    HRESULT         LoadRegions( BYTE *p, BYTE *pEnd, DWORD dwSampleRate);
    HRESULT         Load( BYTE *p, BYTE *pEnd, DWORD dwSampleRate);
};

class CInstrumentList : public CList
{
public:
    CInstrument *    GetHead() {return (CInstrument *)CList::GetHead();};
    CInstrument *    RemoveHead() {return (CInstrument *)CList::RemoveHead();};
};

class CWaveBufferList;
class CWaveBuffer : public CListItem 
{
friend CWaveBufferList;
public:
                CWaveBuffer() 
                {
                }
    CWaveBuffer * GetNext() { return (CWaveBuffer *)CListItem::GetNext();};
    CWaveBuffer * GetNextLoop() 
                {
                    // Threat the list as a circular list
                    CWaveBuffer *pbuf;
                    pbuf = (CWaveBuffer *)CListItem::GetNext();
                    if ( pbuf == NULL )
                        pbuf = (CWaveBuffer *)*m_ppHead;

                    return pbuf;
                };

    CWave *     m_pWave;            // pointer to wave object
protected:
    CListItem** m_ppHead;
};

class CWaveBufferList : public CList
{
public:
    CWaveBuffer *GetHead() {return (CWaveBuffer *)CList::GetHead();};
    CWaveBuffer *RemoveHead() {return (CWaveBuffer *)CList::RemoveHead();};

    // Overide these methods so that m_pHead can be added to CWaveBuffer ListItem
    // to allow GetNextLoop() to function as a simple circular buffer list 
    void InsertBefore(CListItem *pItem,CWaveBuffer *pInsert) {pInsert->m_ppHead = &m_pHead; CList::Cat(pItem);};
    void Cat(CWaveBuffer *pItem)     {pItem->m_ppHead = &m_pHead; CList::Cat(pItem);};
    void AddHead(CWaveBuffer *pItem) {pItem->m_ppHead = &m_pHead; CList::AddHead(pItem);};
    void AddTail(CWaveBuffer *pItem) {pItem->m_ppHead = &m_pHead; CList::AddTail(pItem);};
};

class CWaveArt : public CListItem
{
public:
                    CWaveArt();
                    ~CWaveArt();
    void            Release();          // Remove reference.
    void            AddRef();           // Add reference.
    void            Verify();           // Verifies that the data is valid.
    CWaveArt *      GetNext() {return(CWaveArt *)CListItem::GetNext();};
    DWORD           m_dwID;             // ID for matching wave with regions.
    DMUS_WAVEARTDL  m_WaveArtDl;
    WAVEFORMATEX    m_WaveformatEx;
    CWaveBufferList m_pWaves;           // Array of Wave buffers associated with dowload id's
//  DWORD           m_dwSampleLength;
    BYTE            m_bSampleType;
    BOOL            m_bStream;          // Is this a streaming articulation 
    WORD            m_wUsageCount;      // Keeps track of how many times in use.
};

class CWaveArtList : public CList
{
public:
    CWaveArt *      GetHead() {return (CWaveArt *)CList::GetHead();};
    CWaveArt *      RemoveHead() {return (CWaveArt *)CList::RemoveHead();};
};

#define WAVE_HASH_SIZE          31      // Keep waves in a hash table of linked lists to speed access.
#define INSTRUMENT_HASH_SIZE    31      // Same with instruments.
#define WAVEART_HASH_SIZE       31

class CInstManager {
public:
                    CInstManager();
                    ~CInstManager();
#ifdef DDUMP
    void            Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    CInstrument *   GetInstrument(DWORD dwPatch,DWORD dwKey,DWORD dwVelocity);
    void            Verify();           // Verifies that the data is valid.
    void            SetSampleRate(DWORD dwSampleRate);
    HRESULT         Download(LPHANDLE phDownload, 
                            void * pvData,
                            LPBOOL pbFree);
    HRESULT         Unload(HANDLE hDownload,
                            HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                            HANDLE hUserData);
    /* DirectX8 Methods */
    CWave *         GetWave(DWORD dwDLId);
    CWaveArt *      GetWaveArt(DWORD dwDLId);

private:
    HRESULT         DownloadInstrument(LPHANDLE phDownload, 
                                         DMUS_DOWNLOADINFO *pInfo, 
                                         void *pvOffsetTable[], 
                                         void *pvData,
                                         BOOL fNewFormat);
    HRESULT         DownloadWave(LPHANDLE phDownload,
                                DMUS_DOWNLOADINFO *pInfo, 
                                void *pvOffsetTable[], 
                                void *pvData);
    /* DirectX8 Private Methods */
    HRESULT         DownloadWaveArticulation(LPHANDLE phDownload, 
                                   DMUS_DOWNLOADINFO *pInfo, 
                                   void *pvOffsetTable[], 
                                   void *pvData);
    HRESULT         DownloadWaveRaw(LPHANDLE phDownload, 
                                   DMUS_DOWNLOADINFO *pInfo, 
                                   void *pvOffsetTable[], 
                                   void *pvData);
    CInstrumentList m_InstrumentList[INSTRUMENT_HASH_SIZE];
    CWavePool       m_WavePool[WAVE_HASH_SIZE];
    CWavePool       m_FreeWavePool;     // Track waves still in use, but unloaded.
    DWORD           m_dwSampleRate;     // Sample rate requested by app.

    /* DirectX8 Private Memmebers */
    CWaveArtList    m_WaveArtList[WAVEART_HASH_SIZE];
public:
    DWORD           m_dwSynthMemUse;        /* Memory used by synth wave data */ 

    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.
    BOOL             m_fCSInitialized;
};

/*  CMIDIRecorder is used to keep track of a time
    slice of MIDI continuous controller events.
    This is subclassed by the PitchBend, Volume, 
    Expression, and ModWheel Recorder classes, so
    each of them may reliably manage MIDI events
    coming in.
    CMIDIRecorder uses a linked list of CMIDIData
    structures to keep track of the changes within
    the time slice.
    Allocation and freeing of the CMIDIData events 
    is kept fast and efficient because they are
    always pulled from the static pool m_pFreeList,
    which is really a list of events pulled directly
    from the static array m_sEventBuffer. This is
    safe because we can make the assumption that
    the maximum MIDI rate is 1000 events per second.
    Since we are managing time slices of roughly
    1/16 of a second, a buffer of 100 events would
    be overkill.
    Although CMIDIRecorder is subclassed to several 
    different event types, they all share the one
    staticly declared free list. 
*/

class CMIDIData : public CListItem 
{
public:
                CMIDIData();
    CMIDIData *  GetNext() {return (CMIDIData *)CListItem::GetNext();};
    STIME       m_stTime;   // Time this event was recorded.
    long        m_lData;    // Data stored in event.            
};

class CMIDIDataList : public CList
{
public:
    CMIDIData *GetHead() {return (CMIDIData *)CList::GetHead();};
    CMIDIData *RemoveHead() {return (CMIDIData *)CList::RemoveHead();};
};


class CMIDIRecorder
{
public:
                CMIDIRecorder();
                ~CMIDIRecorder();        // Be sure to clear local list.
    BOOL        FlushMIDI(STIME stTime); // Clear after time stamp.
    BOOL        ClearMIDI(STIME stTime); // Clear up to time stamp.
    BOOL        RecordMIDI(STIME stTime, long lData); // MIDI input goes here.
    BOOL        RecordMIDINote(STIME stTime, long lData); // MIDI input goes here.
    long        GetData(STIME stTime);  // Gets data at time.

    static VREL VelocityToVolume(WORD nVelocity);
protected:
    static VREL m_vrMIDIToVREL[128]; // Array for converting MIDI to volume.
    static VREL m_vrMIDIPercentToVREL[128]; // Array for converting MIDI reverb and chorus percentages to volume.
private:
    static DWORD m_sUsageCount;         // Keeps track of how many instances so free list can be released.
public:
    static CMIDIDataList m_sFreeList;    // Global free list of events.
protected:
    CMIDIDataList m_EventList;           // This recorder's list.
    STIME       m_stCurrentTime;        // Time for current value.
    long        m_lCurrentData;         // Current value.
};

class CNote {
public:
    STIME       m_stTime;
    BYTE        m_bPart;
    BYTE        m_bKey;
    BYTE        m_bVelocity;
};


// Fake note values held in CNoteIn's queue
// to indicate changes in the sustain pedal
// and "all notes off".
// This is a grab bag for synchronous events
// that should be queued in time, not simply done as
// soon as received.
// By putting them in the note queue, we ensure
// they are evaluated in the exact same order as
// the notes themselves.

const BYTE NOTE_PROGRAMCHANGE   = 0xF1;
const BYTE NOTE_CC_BANKSELECTH  = 0xF2;
const BYTE NOTE_CC_BANKSELECTL  = 0xF3;
const BYTE NOTE_CC_POLYMODE     = 0xF4;
const BYTE NOTE_CC_MONOMODE     = 0xF5;
const BYTE NOTE_CC_RPN_MSB      = 0xF6;
const BYTE NOTE_CC_RPN_LSB      = 0xF7;
const BYTE NOTE_CC_NRPN         = 0xF8;
const BYTE NOTE_CC_DATAENTRYLSB = 0xF9;
const BYTE NOTE_CC_DATAENTRYMSB = 0xFA;
const BYTE NOTE_ASSIGNRECEIVE   = 0xFB;
const BYTE NOTE_MASTERVOLUME    = 0xFC;
const BYTE NOTE_SOUNDSOFF       = 0xFD;
const BYTE NOTE_SUSTAIN         = 0xFE;
const BYTE NOTE_ALLOFF          = 0xFF;

class CNoteIn : public CMIDIRecorder
{
public:
    void        FlushMIDI(STIME stTime);
    void        FlushPart(STIME stTime, BYTE bChannel);
    BOOL        RecordNote(STIME stTime, CNote * pNote);
    BOOL        RecordEvent(STIME stTime, DWORD dwPart, DWORD dwCommand, BYTE bData);
    BOOL        GetNote(STIME stTime, CNote * pNote); // Gets the next note.
}; 

/*  CModWheelIn handles one channel of Mod Wheel
    input. As such, it is not embedded in the CVoice
    class, rather it is in the Channel class.
    CModWheelIn's task is simple: keep track of MIDI
    Mod Wheel events, each tagged with millisecond
    time and value, and return the value for a specific
    time request.
    CModWheelIn inherits almost all of its functionality
    from the CMIDIRecorder Class.
    CModWheelIn receives MIDI mod wheel events through
    the RecordMIDI() command, which stores the 
    time and value of the event. 
    CModWheelIn is called by CVoiceLFO to get the 
    current values for the mod wheel to set the amount
    of LFO modulation for pitch and volume.
*/

class CModWheelIn : public CMIDIRecorder
{
public:
    DWORD       GetModulation(STIME stTime);    // Gets the current Mod Wheel value.
};       

/*  CPitchBendIn handles one channel of Pitch Bend
    input. Like the Mod Wheel module, it inherits
    its abilities from the CMIDIRecorder class.
    It has one additional routine, GetPitch(),
    which returns the current pitch bend value.
*/

class CPitchBendIn : public CMIDIRecorder
{
public:
                CPitchBendIn();
    PREL        GetPitch(STIME stTime); // Gets the current pitch in pitch cents.

    // current pitch bend range.  Note that this is not timestamped!
    PREL        m_prRange;              
};              

/*  CVolumeIn handles one channel of Volume
    input. It inherits its abilities from 
    the CMIDIRecorder class.
    It has one additional routine, GetVolume(),
    which returns the volume in decibels at the
    specified time.
*/

class CVolumeIn : public CMIDIRecorder
{
public:
                CVolumeIn();
    VREL        GetVolume(STIME stTime);    // Gets the current volume in db cents.
};

/*  CExpressionIn handles one channel of Expression
    input. It inherits its abilities from 
    the CMIDIRecorder class.
    It has one additional routine, GetVolume(),
    which returns the volume in decibels at the
    specified time.
*/

class CExpressionIn : public CMIDIRecorder
{
public:
                CExpressionIn();
    VREL        GetVolume(STIME stTime);    // Gets the current volume in db cents.
};

/*  CPanIn handles one channel of Volume
    input. It inherits its abilities from 
    the CMIDIRecorder class.
    It has one additional routine, GetPan(),
    which returns the pan position (MIDI value)
    at the specified time.
*/

class CPanIn : public CMIDIRecorder
{
public:
                CPanIn();
    long        GetPan(STIME stTime);       // Gets the current pan.
};

/*  CProgramIn handles one channel of Program change
    input. It inherits its abilities from 
    the CMIDIRecorder class.
    Unlike the other controllers, it actually 
    records a series of bank select and program
    change events, so it's job is a little
    more complex. Three routines handle the 
    recording of the three different commands (bank 1,
    bank 2, program change).
*/

/*class CProgramIn : public CMIDIRecorder
{
public:
                CProgramIn();
    DWORD       GetProgram(STIME stTime);       // Gets the current program change.
    BOOL        RecordBankH(BYTE bBank1);
    BOOL        RecordBankL(BYTE bBank2);
    BOOL        RecordProgram(STIME stTime, BYTE bProgram);
private:
    BYTE        m_bBankH;
    BYTE        m_bBankL;
};*/

/*  CPressureIn handles one channel of Channel Pressure
    input. As such, it is not embedded in the CVoice
    class, rather it is in the Channel class.
    CPressureIn's task is simple: keep track of MIDI
    Channel Pressure events, each tagged with millisecond
    time and value, and return the value for a specific
    time request.
    CPressureIn inherits almost all of its functionality
    from the CMIDIRecorder Class.
    CPressureIn receives MIDI Channel Pressure events through
    the RecordMIDI() command, which stores the 
    time and value of the event. 
    CPressureIn is called by CVoiceLFO to get the 
    current values for the channel pressure to set the amount
    of LFO modulation for pitch.
*/

class CPressureIn : public CMIDIRecorder
{
public:
    DWORD       GetPressure(STIME stTime);    // Gets the current channel pressure value.
};       

//>>>> comment
class CReverbIn : public CMIDIRecorder
{
public:
                CReverbIn();
    DWORD       GetVolume(STIME stTime);       // Gets the current reverb attenuation.
};

//>>>> comment
class CChorusIn : public CMIDIRecorder
{
public:
    DWORD       GetVolume(STIME stTime);       // Gets the current chorus attenuation.
};

//>>>> comment
class CCutOffFreqIn : public CMIDIRecorder
{
public:
                CCutOffFreqIn();
    DWORD       GetFrequency(STIME stTime);       // Gets the current pan.
};

class CWaveEvent {
public:
                CWaveEvent() : 
                m_stTime(0),
                m_bPart(0),
                m_dwVoiceId(0),
                m_vrVolume(0),
                m_prPitch(0),
                m_pWaveArt(NULL)
                {}
public:
    STIME       m_stTime;
    BYTE        m_bPart;
    DWORD       m_dwVoiceId;
    VREL        m_vrVolume;
    PREL        m_prPitch;
    SAMPLE_TIME m_stVoiceStart;
    SAMPLE_TIME m_stLoopStart;
    SAMPLE_TIME m_stLoopEnd;
    CWaveArt*   m_pWaveArt;
};

class CWaveData : public CListItem 
{
public:
                CWaveData();
    CWaveData * GetNext() {return (CWaveData *)CListItem::GetNext();};
    STIME       m_stTime;           // Time this event was recorded.
    CWaveEvent  m_WaveEventData;    // Data stored in event.            
};

class CWaveDataList : public CList
{
public:
    CWaveData *GetHead() {return (CWaveData *)CList::GetHead();};
    CWaveData *RemoveHead() {return (CWaveData *)CList::RemoveHead();};
};

class CWaveIn 
{
public:
                CWaveIn();
                ~CWaveIn();              // Be sure to clear local list.
//    BOOL        FlushWave(STIME stTime); // Clear after time stamp.
    BOOL        ClearWave(STIME stTime); // Clear up to time stamp.
    BOOL        RemoveWave(DWORD dwID);  // Remove wave with dwID.
    BOOL        RemoveWaveByStopTime(DWORD dwID, STIME stStopTime);
    BOOL        RecordWave(STIME stTime, CWaveEvent *pWaveData); 
    BOOL        GetWave(STIME stTime, CWaveEvent *pWave); 

private:
    static DWORD     m_sUsageCount;                   // Keeps track of how many instances so free list can be released.
public:
    static CWaveDataList m_sFreeList;   // Global free list of events.

protected:
    CWaveDataList m_EventList;          // This recorder's list.
    STIME         m_stCurrentTime;      // Time for current value.
    CWaveEvent    m_lCurrentData;       // Current value.
}; 

/*  The CVoiceLFO class is used to track the behavior
    of an LFO within a voice. The LFO is hard wired to 
    output both volume and pitch values, through separate
    calls to GetVolume and GetPitch.
    It also manages mixing Mod Wheel control of pitch and
    volume LFO output. It tracks the scaling of Mod Wheel
    for each of these in m_nMWVolumeScale and m_nMWPitchScale.
    It calls the Mod Wheel module to get the current values 
    if the respective scalings are greater than 0.
    All of the preset values for the LFO are carried in
    the m_CSource field, which is a replica of the file
    CSourceLFO structure. This is initialized with the
    StartVoice call.
*/

class CVoiceLFO 
{
public:
                CVoiceLFO();
    static void Init();             // Set up sine table.
    STIME       StartVoice(CSourceLFO *pSource, 
                    STIME stStartTime,CModWheelIn * pModWheelIn, CPressureIn * pPressureIn);
    VREL        GetVolume(STIME stTime, STIME *pstTime);    // Returns volume cents.
    PREL        GetPitch(STIME stTime, STIME *pstTime);     // Returns pitch cents.

    /* DirectX8 Methods */
    void        Enable(BOOL bEnable) {m_bEnable = bEnable;};
    PREL        GetCutoff(STIME stTime);                    // Return filter cutoff

private:
    long        GetLevel(STIME stTime, STIME *pstTime);
    CSourceLFO  m_Source;           // All of the preset information.
    STIME       m_stStartTime;      // Time the voice started playing.
    CModWheelIn *m_pModWheelIn;     // Pointer to Mod Wheel for this channel.
    STIME       m_stRepeatTime;     // Repeat time for LFO.
    static short m_snSineTable[256];    // Sine lookup table.

    /* DirectX8 Memmebers */
    CPressureIn *m_pPressureIn;     // Pointer to Channel Pressure for this channel.
    BOOL        m_bEnable;
};

/*  The CVoiceEG class is used to track the behavior of
    an Envelope Generator within a voice. There are two 
    EG's, one for pitch and one for volume. However, they
    behave identically.
    All of the preset values for the EG are carried in
    the m_Source field, which is a replica of the file
    CSourceEG structure. This is initialized with the
    StartVoice call.
*/

class CVoiceEG
{
public:
    static void Init();             // Set up linear attack table.
                CVoiceEG();
    STIME       StartVoice(CSourceEG *pSource, STIME stStartTime, 
                    WORD nKey, WORD nVelocity, STIME stMinAttack);
    void        StopVoice(STIME stTime);
    void        QuickStopVoice(STIME stTime, DWORD dwSampleRate);
    VREL        GetVolume(STIME stTime, STIME *pstTime);    // Returns volume cents.
    PREL        GetPitch(STIME stTime, STIME *pstTime);     // Returns pitch cents.
    BOOL        InAttack(STIME stTime);     // is voice still in attack?
    BOOL        InRelease(STIME stTime);    // is voice in release?

    /* DirectX8 Methods */
    void        Enable(BOOL bEnable) {m_bEnable = bEnable;};
    PREL        GetCutoff(STIME stTime);                    // Return filter cutoff

private:
    long        GetLevel(STIME stTime, STIME *pstTime, BOOL fVolume);
    CSourceEG   m_Source;           // Preset values for envelope, copied from file.
    STIME       m_stStartTime;      // Time note turned on
    STIME       m_stStopTime;       // Time note turned off
    static short m_snAttackTable[201];

    /* DirectX8 Memmebers */
    BOOL        m_bEnable;
};

//>>>>>>>>>>> comment 
class CVoiceFilter
{
public:
    void        StartVoice(CSourceFilter *pSource, CVoiceLFO *pLFO, CVoiceEG *pEG, WORD nKey, WORD nVelocity);
    void        GetCoeff(STIME stTime, PREL prFreqIn, COEFF &cfK, COEFF &cfB1, COEFF &cfB2);
    BOOL        IsFiltered();
    
public:
    CSourceFilter   m_Source;   
    CVoiceLFO       *m_pLFO;
    CVoiceEG        *m_pEG;
    CPitchBendIn    *m_pPitchBend;

    PREL            m_prVelScale;
    PREL            m_prKeyScale;
    
    static COEFF    m_aK[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC];
    static COEFF    m_aB1[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC];
    static COEFF    m_aB2[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC];
};

/*  The CDigitalAudio class is used to track the playback
    of a sample within a voice.
    It manages the loop points, the pointer to the sample.
    and the base pitch and base volume, which it initially sets 
    when called via StartVoice(). 
    Pitch is stored in a fixed point format, where the leftmost
    20 bits define the sample increment and the right 12 bits
    define the factional increment within the sample. This 
    format is also used to track the position in the sample.
    Mix is a critical routine. It is called by the CVoice to blend
    the instrument into the data buffer. It is handed relative change
    values for pitch and volume (semitone cents and decibel
    cents.) These it converts into three linear values:
    Left volume, Right volume, and Pitch.
    It then compares these new values with the values that existed 
    for the previous slice and divides by the number of samples to 
    determine an incremental change at the sample rate. 
    Then, in the critical mix loop, these are added to the 
    volume and pitch indices to give a smooth linear slope to the
    change in volume and pitch.
*/

#define MAX_SAMPLE    4095
#define MIN_SAMPLE  (-4096)

#define MAXDB            0
#define MINDB           -100
#define TEST_WRITE_SIZE  3000
#define TEST_SOURCE_SIZE 44100

class CSynth;

class CDigitalAudio 
{
public:
                CDigitalAudio();
                ~CDigitalAudio();

    void        ClearVoice();
    STIME       StartVoice(CSynth *pSynth,
                    CSourceSample *pSample,
                    PREL prBasePitch, long lKey);
    STIME       StartWave(CSynth *pSynth,
                    CWaveArt *pWaveArt, 
                    PREL prBasePitch,
                    SAMPLE_TIME stVoiceStart,
                    SAMPLE_TIME stLoopStart,
                    SAMPLE_TIME stLoopEnd);
    BOOL        Mix(short **ppBuffers, 
                    DWORD dwInterleaved, 
                    DWORD dwBufferCount, 
                    DWORD dwLength,
                    VREL vrMaxVolumeDelta,  
                    VFRACT vrNewVolume[],                       
                    VFRACT vrLastVolume[],                      
                    PREL dwPitch,
                    DWORD dwIsFiltered, COEFF cfK, COEFF cfB1, COEFF cfB2);

    inline void BreakLoop()
    { m_bOneShot = TRUE; }

    static void Init();                         // Set up lookup tables.
    static PFRACT PRELToPFRACT(PREL prPitch);   // Pitch cents to pitch.
    static VFRACT VRELToVFRACT(VREL vrVolume);  // dB to absolute.

    SAMPLE_POSITION GetCurrentPos() {return m_ullSamplesSoFar;};

    //
    // Optimized Interleaved mixers 
    //
private:
    DWORD       Mix8(short * pBuffer, 
                    DWORD dwLength,
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, 
                    VFRACT vfDeltaRVolume,
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD       Mix16(short * pBuffer, 
                    DWORD dwLength,
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, 
                    VFRACT vfDeltaRVolume,
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD       MixMono8(short * pBuffer, 
                    DWORD dwLength,
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume, 
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD       MixMono16(short * pBuffer, 
                    DWORD dwLength,
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume, 
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    //
    // Optimized MMX Interleaved mixers 
    //
private:
    DWORD _cdecl Mix8X(short * pBuffer, 
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, 
                    VFRACT vfDeltaRVolume,
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD _cdecl Mix16X(short * pBuffer, 
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, 
                    VFRACT vfDeltaRVolume,
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD       MixMono16X(short * pBuffer, 
                    DWORD dwLength,
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume, 
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength,
                    PFRACT pfLoopLength);
    DWORD       MixMono8X(short * pBuffer,
                    DWORD dwLength,
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume, 
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    //
    // Optimize Multi Buffer versions of the mixer 
    //
private:
    DWORD       MixMulti8(short *ppBuffer[], 
                    DWORD dwBufferCount,
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod, 
                    VFRACT vfDeltaVolume[], 
                    VFRACT vfLastVolume[], 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD       MixMulti8Filter(short *ppBuffer[], 
                    DWORD dwBufferCount,
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod, 
                    VFRACT vfDeltaVolume[], 
                    VFRACT vfLastVolume[], 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength,
                    COEFF cfdK,
                    COEFF cfdB1,
                    COEFF cfdB2);
    DWORD       MixMulti16(short *ppBuffer[], 
                    DWORD dwBufferCount,
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod, 
                    VFRACT vfDeltaVolume[], 
                    VFRACT vfLastVolume[], 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD       MixMulti16Filter(short *ppBuffer[], 
                    DWORD dwBufferCount,
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod, 
                    VFRACT vfDeltaVolume[], 
                    VFRACT vfLastVolume[], 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength,
                    COEFF cfdK,
                    COEFF cfdB1,
                    COEFF cfdB2);
    DWORD Mix8Filter(short * pBuffer, 
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, 
                    VFRACT vfDeltaRVolume,
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength,
                    COEFF cfdK,
                    COEFF cfdB1,
                    COEFF cfdB2);
    DWORD Mix16Filter(short * pBuffer, 
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, 
                    VFRACT vfDeltaRVolume,
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength,
                    COEFF cfdK,
                    COEFF cfdB1,
                    COEFF cfdB2);
private:
    void        BeforeBigSampleMix();
    void        AfterBigSampleMix();

private:
    CSourceSample   m_Source;           // Preset values for sample.
    CSynth *        m_pSynth;           // For access to sample rate, etc.

    static PFRACT   m_spfCents[201];    // Pitch increment lookup.
    static PFRACT   m_spfSemiTones[97]; // Four octaves up and down.
    static VFRACT   m_svfDbToVolume[(MAXDB - MINDB) * 10 + 1]; // dB conversion table.
    static BOOL     m_sfMMXEnabled;

private:
    short *     m_pnWave;           // Private pointer to wave.

    PFRACT      m_pfBasePitch;      // Overall pitch.
    PFRACT      m_pfLastPitch;      // The last pitch value.
    PREL        m_prLastPitch;      // Same for pitch, in PREL.
    PFRACT      m_pfLastSample;     // The last sample position.
    PFRACT      m_pfLoopStart;      // Start of loop.
    PFRACT      m_pfLoopEnd;        // End of loop.
    PFRACT      m_pfSampleLength;   // Length of sample buffer.
    BOOL        m_fElGrande;        // Indicates larger than 1m wave.
    ULONGLONG   m_ullLastSample;    // Used to track > 1m wave.
    ULONGLONG   m_ullLoopStart;     // Used to track > 1m wave.
    ULONGLONG   m_ullLoopEnd;       // Used to track > 1m wave.
    ULONGLONG   m_ullSampleLength;  // Used to track > 1m wave.
    DWORD       m_dwAddressUpper;   // Temp storage for upper bits of address.
    BOOL        m_bOneShot;         // Is the source region we're mixing a one-shot?

    /* DLS2 filter members */
    COEFF       m_cfLastK;          // Held filter coefficients
    COEFF       m_cfLastB1;
    COEFF       m_cfLastB2;
    long        m_lPrevSample;      // Last two samples, post-filter
    long        m_lPrevPrevSample;

    /* DirectX8 members */
    CWaveBuffer*    m_pCurrentBuffer;
    CWaveArt*       m_pWaveArt;
    ULONGLONG       m_ullSamplesSoFar;
};


/*  The CVoice class pulls together everything needed to perform
    one voice. It has the envelopes, lfo, and sample embedded
    within it. 

    StartVoice() initializes a voice structure for playback. The
    CSourceRegion structure carries the region and sample as well
    as a pointer to the articulation, which is used to set up
    the various articulation modules. It also carries pointers to 
    all the MIDI modulation inputs and the values for the note key
    and channel which are used by the parent ControlLogic object
    to match incoming note off events with the right voice. 
*/

class CVoice : public CListItem
{
public:
                CVoice();
    CVoice *     GetNext() {return (CVoice *)CListItem::GetNext();};

    BOOL        StartVoice(CSynth *pControl,
                    CSourceRegion *pRegion, STIME stStartTime,
                    CModWheelIn * pModWheelIn, 
                    CPitchBendIn * pPitchBendIn,
                    CExpressionIn * pExpressionIn,
                    CVolumeIn * pVolumeIn,
                    CPanIn * pPanIn,
                    CPressureIn * pPressureIn,
                    CReverbIn * pReverbSend,
                    CChorusIn * pChorusSend,
                    CCutOffFreqIn * PCCutOffFreqIn,
                    CBusIds * pBusIds,
                    WORD nKey,WORD nVelocity,
                    VREL vrVolume,      // Added for GS
                    PREL prPitch);      // Added for GS

    BOOL        StartWave(CSynth *pSynth,
                       CWaveArt *pWaveArt,
                       DWORD dwVoiceId,
                       STIME stStartTime,
                       CPitchBendIn * pPitchBendIn,
                       CExpressionIn * pExpressionIn,   
                       CVolumeIn * pVolumeIn,
                       CPanIn * pPanIn,
                       CReverbIn * pReverbSend,
                       CChorusIn * pChorusSend,
                       CCutOffFreqIn * pCCutOffFreqIn,
                       CBusIds * pBusIds,
                       VREL vrVolume,
                       PREL prPitch,
                       SAMPLE_TIME stVoiceStart,
                       SAMPLE_TIME stLoopStart,
                       SAMPLE_TIME stLoopEnd       
                       );
    static void Init();             // Initialize LFO, Digital Audio.
    void  StopVoice(STIME stTime);// Called on note off event.
    void  QuickStopVoice(STIME stTime);// Called to get quick release.
    void  SpeedRelease();     // Force an already off envelope to release quickly.
    void  ClearVoice();       // Release use of sample.
    void  GetNewPitch(STIME stTime, PREL& prPitch);// Return current pitch value
    void  GetNewVolume(STIME stTime, VREL& vrVolume, VREL& vrVolumeL, VREL& vrVolumeR, VREL& vrVolumeReverb, VREL& vrVolumeChorus);
    void  GetNewCoeff(STIME stTime, PREL& prCutOff, COEFF& cfK, COEFF& cfB1, COEFF& cfB2);
    DWORD Mix(short **ppvBuffer, DWORD dwBufferFlags, DWORD dwLength, STIME stStart,STIME stEnd);
    SAMPLE_POSITION GetCurrentPos();

private:
    static VREL m_svrPanToVREL[128];// Converts Pan to db.
    CVoiceLFO   m_LFO;             // LFO.
    CVoiceEG    m_PitchEG;         // Pitch Envelope.
    CVoiceEG    m_VolumeEG;        // Volume Envelope.
    CDigitalAudio m_DigitalAudio;  // The Digital Audio Engine structure.
    CPitchBendIn *  m_pPitchBendIn; // Pitch bend source.
    CExpressionIn * m_pExpressionIn;// Expression source.
    CVolumeIn * m_pVolumeIn;        // Volume source, if allowed to vary
    CPanIn *    m_pPanIn;           // Pan source, if allowed to vary
    CReverbIn * m_pReverbSend;      //>>>> comment 
    CChorusIn * m_pChorusSend;      //>>>> comment 
    CCutOffFreqIn * m_CCutOffFreqIn;//>>>> comment
    CSynth *    m_pSynth;           // To access sample rate, etc.
    STIME       m_stMixTime;        // Next time we need a mix.
    STIME       m_stLastMix;        // Last sample position mixed.
    long        m_lDefaultPan;      // Default pan
    PREL        m_prLastCutOff;     // Last cut off value.

public:
    DWORD       m_dwNoteID;         // Unique id to keep all voices that represent layers of one note connected.
    STIME       m_stStartTime;      // Time the sound starts.
    STIME       m_stStopTime;       // Time the sound stops.
    STIME       m_stWaveStopTime;   // Stop time set by direct call to stop the wave voice.
    BOOL        m_fInUse;           // This is currently in use.
    BOOL        m_fNoteOn;          // Note is considered on.
    BOOL        m_fTag;             // Used to track note stealing.
    VREL        m_vrVolume;         // Volume, used for voice stealing...
    BOOL        m_fSustainOn;       // Sus pedal kept note on after off event.
    WORD        m_nPart;            // Part that is playing this (channel).
    WORD        m_nKey;             // Note played.
    BOOL        m_fAllowOverlap;    // Allow overlapped note.
    DWORD       m_dwGroup;          // Group this voice is playing now
    DWORD       m_dwProgram;        // Bank and Patch choice.
    DWORD       m_dwPriority;       // Priority.
    CControlLogic * m_pControl;     // Which control group is playing voice.
    DWORD       m_dwVoiceId;        // Used to identify a playing wave
    CSourceRegion *m_pRegion;       // Used to determin which region a voice is playing out of 
    CVoiceFilter m_Filter;          // Low pass filter
    CVoiceLFO   m_LFO2;             // Vibrato
    CBusIds     m_BusIds;           // Bus Id's to playe on this voice
    DWORD       m_dwLoopType;       // Loop type
    BOOL        m_fIgnorePan;       // If we're part of a multichannel wave/sample
    VREL        m_vrLastVolume[MAX_DAUD_CHAN];
    VREL        m_vrBaseVolume[MAX_DAUD_CHAN];    
    VFRACT      m_vfLastVolume[MAX_DAUD_CHAN];  
};


class CVoiceList : public CList
{
public:
    CVoice *     GetHead() {return (CVoice *)CList::GetHead();};
    CVoice *     RemoveHead() {return (CVoice *)CList::RemoveHead();};
    CVoice *     GetItem(LONG lIndex) {return (CVoice *) CList::GetItem(lIndex);};
};

/*  Finally, ControlLogic is the big Kahuna that manages 
    the whole system. It parses incoming MIDI events
    by channel and event type. And, it manages the mixing
    of voices into the buffer.

  MIDI Input:

    The most important events are the note on and
    off events. When a note on event comes in, 
    ControlLogic searches for an available voice.
    ControlLogic matches the channel and finds the
    instrument on that channel. It then call the instrument's
    ScanForRegion() command which finds the region 
    that matches the note. At this point, it can copy
    the region and associated articulation into the
    voice, using the StartVoice command.
    When it receives the sustain pedal command,
    it artificially sets all notes on the channel on
    until a sustain off arrives. To keep track of notes
    that have been shut off while the sustain was on
    it uses an array of 128 shorts, with each bit position 
    representing a channel. When the sustain releases,
    it scans through the array and creates a note off for
    each bit that was set.
    It also receives program change events to set the
    instrument choice for the channel. When such
    a command comes in, it consults the softsynth.ini file 
    and loads an instrument with the file name described
    in the ini file.
    Additional continuous controller events are managed
    by the CModWheelIn, CPitchBendIn, etc., MIDI input recording
    modules.

  Mixing:

    Control Logic is also called to mix the instruments into
    a buffer at regular intervals. The buffer is provided by the
    calling sound driver (initially, AudioMan.) 
    Each voice is called to mix its sample into the buffer.
*/

typedef struct PerfStats
{
    DWORD dwTotalTime;
    DWORD dwTotalSamples;
    DWORD dwNotesLost;
    DWORD dwVoices;
    DWORD dwCPU;
    DWORD dwMaxAmplitude;
} PerfStats;

#define MIX_BUFFER_LEN          500 // Set the sample buffer size to 500 mils
#define MAX_NUM_VOICES          32  
#define NUM_EXTRA_VOICES        8   // Extra voices for when we overload.
#define NUM_DEFAULT_BUSES       4


class CControlLogic
{
public:
                    CControlLogic();
                    ~CControlLogic();
    HRESULT         Init(CInstManager *pInstruments, CSynth *pSynth);
    void            ClearAll();
    void            Flush(STIME stTime); // Clears all events after time.
    BOOL            RecordMIDI(STIME stTime,BYTE bStatus, BYTE bData1, BYTE bData2);
    HRESULT         RecordSysEx(DWORD dwSysExLength,BYTE *pSysExData, STIME stTime);
    CSynth *        m_pSynth;
    void            QueueNotes(STIME stStartTime, STIME stEndTime);
    void            ClearMIDI(STIME stEndTime);
    void            SetGainAdjust(VREL vrGainAdjust);
    HRESULT         SetChannelPriority(DWORD dwChannel,DWORD dwPriority);
    HRESULT         GetChannelPriority(DWORD dwChannel,LPDWORD pdwPriority);

    /* DirectX8 methods */
    void            QueueWaves(STIME stEndTime);
    void            FlushWaveByStopTime(DWORD dwID, STIME stStopTime);
    BOOL            RecordWaveEvent(STIME stTime, BYTE bChannel, DWORD dwVoiceId, VREL prVolume, PREL prPitch, SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd, CWaveArt* pWaveArt);
    HRESULT         AssignChannelToBuses(DWORD dwChannel, LPDWORD pdwBusIds, DWORD dwBusCount);
    
private:
    void            GMReset();
    CInstManager *  m_pInstruments;
    CNoteIn         m_Notes;            // All Note ons and offs.
    CModWheelIn     m_ModWheel[16];     // Sixteen channels of Mod Wheel.
    CPitchBendIn    m_PitchBend[16];    // Sixteen channels of Pitch Bend.
    CVolumeIn       m_Volume[16];       // Sixteen channels of Volume.
    CExpressionIn   m_Expression[16];   // Sixteen channels of Expression.
    CPanIn          m_Pan[16];          // Sixteen channels of Pan.
    CReverbIn       m_ReverbSends[16];  //>>>> comment  
    CChorusIn       m_ChorusSends[16];  //>>>> comment
    CCutOffFreqIn   m_CutOffFreqCC[16]; //>>>> comment
    BOOL            m_fSustain[16];     // Sustain on / off.
    short           m_nCurrentRPN[16];  // RPN number.
    BYTE            m_bBankH[16];       // Bank selects for instrument.
    BYTE            m_bBankL[16];     
    DWORD           m_dwProgram[16];    // Instrument choice.
    BOOL            m_fEmpty;           // Indicates empty lists, no need to flush.
    VREL            m_vrGainAdjust;     // Final stage gain adjust
    DWORD           m_dwPriority[16];   // Priorities for each channel.
    
    BOOL            m_fXGActive;        // Is XG Active?
    BOOL            m_fGSActive;        // Is GS enabled?
    WORD            m_nData[16];        // Used to track RPN reading.
    VREL            m_vrMasterVolume;   // Master Volume.
    PREL            m_prFineTune[16];   // Fine tune for each channel.
    PREL            m_prScaleTune[16][12]; // Alternate scale for each channel.
    PREL            m_prCoarseTune[16]; // Coarse tune.
    BYTE            m_bPartToChannel[16]; // Channel to Part converter.
    BYTE            m_bDrums[16];       // Melodic or which drum?
    BOOL            m_fMono[16];        // Mono mode?

public:
    // This is static to protect the CMIDIRecorder free list, which is also static.
    // 
    static CRITICAL_SECTION s_CriticalSection; // Critical section to manage access.
    static BOOL             s_fCSInitialized;

    static BOOL InitCriticalSection();
    static void KillCriticalSection();

    /* DirectX8 members */
private:
    CWaveIn         m_Waves;            // All waves scheduled to be played
    CPressureIn     m_Pressure[16];     // Sixteen channels of Channel Pressure.
    CBusIds         m_BusIds[16];       // Bus Id's for each channel 
};

#endif // __SYNTH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\basetool.cpp ===
// BaseTool.cpp : Implementation of CBaseTool
//
// Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "basetool.h"

CBaseTool::CBaseTool()
{
    m_cRef = 1; // set to 1 so one call to Release() will free this
    InitializeCriticalSection(&m_CrSec);
}

CBaseTool::~CBaseTool()
{
    DeleteCriticalSection(&m_CrSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\basetool.h ===
#ifndef _BASE_TOOL_
#define _BASE_TOOL_

#include "dmusici.h"
#include "medparam.h"

extern long g_cComponent;

class CBaseTool : public IDirectMusicTool8
{
public:
    CBaseTool()
    {
        m_cRef = 1; // set to 1 so one call to Release() will free this
        m_pParams = NULL;
        InitializeCriticalSection(&m_CrSec);
        // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
        // ever pops in stress, we can add an exception handler and retry loop.
        InterlockedIncrement(&g_cComponent);
    }
    ~CBaseTool()
    {
        if (m_pParams)
        {
            m_pParams->Release();
        }
        DeleteCriticalSection(&m_CrSec);
        InterlockedDecrement(&g_cComponent);
    }
    void CreateParams()
    {
    }
    void CloneParams()
    {
    }
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) PURE;
    STDMETHODIMP_(ULONG) AddRef() PURE;
    STDMETHODIMP_(ULONG) Release() PURE;

/*// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID) PURE;

// IPersistStream functions
    STDMETHODIMP IsDirty() PURE;
    STDMETHODIMP Load(IStream* pStream) PURE;
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty) PURE;
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize) PURE;*/

// IDirectMusicTool
    STDMETHODIMP Init(IDirectMusicGraph* pGraph) {return E_NOTIMPL;}
    STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) {return E_NOTIMPL;}
    STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) {return E_NOTIMPL;}
    STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) {return E_NOTIMPL;}
    STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) PURE;
    STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) {return E_NOTIMPL;}

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) PURE;

protected:
    long m_cRef;                // reference counter
    CRITICAL_SECTION m_CrSec;   // to make SetEchoNum() and SetDelay() thread-safe
    IMediaParams * m_pParams;   // Helper object that manages IMediaParams.
};

class CToolFactory : public IClassFactory
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    STDMETHODIMP LockServer(BOOL bLock);

    // Constructor
    //
    CToolFactory(DWORD dwToolType);

    // Destructor
    ~CToolFactory();

private:
    long m_cRef;
    DWORD m_dwToolType;
};

// We use one class factory to create all tool classes. We need an identifier for each
// type so the class factory knows what it is creating.

#define TOOL_ECHO       1
#define TOOL_TRANSPOSE  2
#define TOOL_SWING      3
#define TOOL_QUANTIZE   4
#define TOOL_VELOCITY   5
#define TOOL_DURATION   6
#define TOOL_TIMESHIFT  7

#endif // _BASE_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\dll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// loader dll.cpp
//
// Dll entry points and CToolFactory, CContainerFactory implementation
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#include <objbase.h>
#include "debug.h"

#include "oledll.h"
#include "debug.h" 
#include "dmusicc.h" 
#include "dmusici.h" 
#include "BaseTool.h"
#include "Echo.h"
#include "Transpose.h"
#include "Duration.h"
#include "Quantize.h"
#include "TimeShift.h"
#include "Swing.h"
#include "Velocity.h"

#ifndef UNDER_CE
#include <regstr.h>
#endif

// Globals
//

// Version information for our class
//
TCHAR g_szEchoFriendlyName[]            = TEXT("Microsoft Echo Tool");
TCHAR g_szEchoShortName[]               = TEXT("Echo");
TCHAR g_szEchoDescription[]             = TEXT("Echoes notes");
TCHAR g_szEchoVerIndProgID[]            = TEXT("Microsoft.DirectMusicEchoTool");
TCHAR g_szEchoProgID[]                  = TEXT("Microsoft.DirectMusicEchoTool.1");

TCHAR g_szTransposeFriendlyName[]       = TEXT("Microsoft Transpose Tool");
TCHAR g_szTransposeShortName[]          = TEXT("Transpose");
TCHAR g_szTransposeDescription[]        = TEXT("Transposes notes");
TCHAR g_szTransposeVerIndProgID[]       = TEXT("Microsoft.DirectMusicTransposeTool");
TCHAR g_szTransposeProgID[]             = TEXT("Microsoft.DirectMusicTransposeTool.1");

TCHAR g_szDurationFriendlyName[]        = TEXT("Microsoft Duration Modifier Tool");
TCHAR g_szDurationShortName[]           = TEXT("Duration");
TCHAR g_szDurationDescription[]         = TEXT("Scales note durations");
TCHAR g_szDurationVerIndProgID[]        = TEXT("Microsoft.DirectMusicDurationTool");
TCHAR g_szDurationProgID[]              = TEXT("Microsoft.DirectMusicDurationTool.1");

TCHAR g_szQuantizeFriendlyName[]        = TEXT("Microsoft Quantize Tool");
TCHAR g_szQuantizeShortName[]           = TEXT("Quantize");
TCHAR g_szQuantizeDescription[]         = TEXT("Quantizes note starts and durations");
TCHAR g_szQuantizeVerIndProgID[]        = TEXT("Microsoft.DirectMusicQuantizeTool");
TCHAR g_szQuantizeProgID[]              = TEXT("Microsoft.DirectMusicQuantizeTool.1");

TCHAR g_szTimeShiftFriendlyName[]       = TEXT("Microsoft Time Shift Tool");
TCHAR g_szTimeShiftShortName[]          = TEXT("Time Shift");
TCHAR g_szTimeShiftDescription[]        = TEXT("Shifts and randomizes note starts");
TCHAR g_szTimeShiftVerIndProgID[]       = TEXT("Microsoft.DirectMusicTimeShiftTool");
TCHAR g_szTimeShiftProgID[]             = TEXT("Microsoft.DirectMusicTimeShiftTool.1");

TCHAR g_szSwingFriendlyName[]           = TEXT("Microsoft Swing Tool");
TCHAR g_szSwingShortName[]              = TEXT("Swing");
TCHAR g_szSwingDescription[]            = TEXT("Changes the timing to a adopt a triplet rhythm");
TCHAR g_szSwingVerIndProgID[]           = TEXT("Microsoft.DirectMusicSwingTool");
TCHAR g_szSwingProgID[]                 = TEXT("Microsoft.DirectMusicSwingTool.1");

TCHAR g_szVelocityFriendlyName[]        = TEXT("Microsoft Velocity Transform Tool");
TCHAR g_szVelocityShortName[]           = TEXT("Velocity Transform");
TCHAR g_szVelocityDescription[]         = TEXT("Modifies note velocities");
TCHAR g_szVelocityVerIndProgID[]        = TEXT("Microsoft.DirectMusicVelocityTool");
TCHAR g_szVelocityProgID[]              = TEXT("Microsoft.DirectMusicVelocityTool.1");

// Dll's hModule
//
HMODULE g_hModule = NULL; 

#ifndef UNDER_CE
// Track whether running on Unicode machine.

BOOL g_fIsUnicode = FALSE;
#endif

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;

// CToolFactory::QueryInterface
//
HRESULT __stdcall
CToolFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CToolFactory::CToolFactory(DWORD dwToolType)

{
	m_cRef = 1;
    m_dwToolType = dwToolType;
	InterlockedIncrement(&g_cLock);
}

CToolFactory::~CToolFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CToolFactory::AddRef
//
ULONG __stdcall
CToolFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CToolFactory::Release
//
ULONG __stdcall
CToolFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CToolFactory::CreateInstance
//
//
HRESULT __stdcall
CToolFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CBaseTool *pTool;
    switch (m_dwToolType)
    {
    case TOOL_ECHO:
        pTool = new CEchoTool;
        break;
    case TOOL_TRANSPOSE:
        pTool = new CTransposeTool;
        break;
    case TOOL_SWING:
        pTool = new CSwingTool;
        break;
    case TOOL_DURATION:
        pTool = new CDurationTool;
        break;
    case TOOL_QUANTIZE:
        pTool = new CQuantizeTool;
        break;
    case TOOL_TIMESHIFT:
        pTool = new CTimeShiftTool;
        break;
    case TOOL_VELOCITY:
        pTool = new CVelocityTool;
        break;
    }

    if (pTool == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pTool->QueryInterface(iid, ppv);
    pTool->Release();
    
    return hr;
}

// CToolFactory::LockServer
//
HRESULT __stdcall
CToolFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

// Standard calls needed to be an inproc server
//
STDAPI  DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    IUnknown* pIUnknown = NULL;
    DWORD dwTypeID = 0;

    if(clsid == CLSID_DirectMusicEchoTool)
    {
        dwTypeID = TOOL_ECHO;
    }
    else if(clsid == CLSID_DirectMusicTransposeTool) 
    {
        dwTypeID = TOOL_TRANSPOSE;
    }
    else if(clsid == CLSID_DirectMusicDurationTool) 
    {
        dwTypeID = TOOL_DURATION;
    }
    else if(clsid == CLSID_DirectMusicQuantizeTool) 
    {
        dwTypeID = TOOL_QUANTIZE;
    }
    else if(clsid == CLSID_DirectMusicTimeShiftTool) 
    {
        dwTypeID = TOOL_TIMESHIFT;
    }
    else if(clsid == CLSID_DirectMusicSwingTool) 
    {
        dwTypeID = TOOL_SWING;
    }
    else if(clsid == CLSID_DirectMusicVelocityTool) 
    {
        dwTypeID = TOOL_VELOCITY;
    }
    else
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}
    pIUnknown = static_cast<IUnknown*> (new CToolFactory(dwTypeID));
    if(pIUnknown) 
    {
        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();
        return hr;
    }
	return E_OUTOFMEMORY;
}

const TCHAR cszToolRegRoot[] = TEXT(DMUS_REGSTR_PATH_TOOLS) TEXT("\\");
const TCHAR cszDescriptionKey[] = TEXT("Description");
const TCHAR cszNameKey[] = TEXT("Name");
const TCHAR cszShortNameKey[] = TEXT("ShortName");
const int CLSID_STRING_SIZE = 39;
HRESULT CLSIDToStr(const CLSID &clsid, TCHAR *szStr, int cbStr);

HRESULT RegisterTool(REFGUID guid,
                      const TCHAR szDescription[],
                      const TCHAR szShortName[],
                      const TCHAR szName[])
{
    HKEY hk;
    TCHAR szCLSID[CLSID_STRING_SIZE];
    TCHAR szRegKey[256];
    
    HRESULT hr = CLSIDToStr(guid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    lstrcpy(szRegKey, cszToolRegRoot);
    lstrcat(szRegKey, szCLSID);

    if (RegCreateKey(HKEY_LOCAL_MACHINE,
                     szRegKey,
                     &hk))
    {
        return E_FAIL;
    }

    hr = S_OK;

    if (RegSetValueEx(hk,
                  cszDescriptionKey,
                  0L,
                  REG_SZ,
                  (CONST BYTE*)szDescription,
                  lstrlen(szDescription) + 1))
    {
        hr = E_FAIL;
    }

    if (RegSetValueEx(hk,
                  cszNameKey,
                  0L,
                  REG_SZ,
                  (CONST BYTE*)szName,
                  lstrlen(szName) + 1))
    {
        hr = E_FAIL;
    }

    if (RegSetValueEx(hk,
                  cszShortNameKey,
                  0L,
                  REG_SZ,
                  (CONST BYTE*)szShortName,
                  lstrlen(szName) + 1))
    {
        hr = E_FAIL;
    }

    RegCloseKey(hk);
    return hr;
}

HRESULT UnregisterTool(REFGUID guid)
{
    HKEY hk;
    TCHAR szCLSID[CLSID_STRING_SIZE];
    TCHAR szRegKey[256];
    
    HRESULT hr = CLSIDToStr(guid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    lstrcpy(szRegKey, cszToolRegRoot);
    lstrcat(szRegKey, szCLSID);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,szRegKey,0,KEY_ALL_ACCESS | KEY_WRITE, &hk))
    {
        return E_FAIL;
    }

    hr = S_OK;

    if (RegDeleteValue(hk,cszDescriptionKey))
    {
        hr = E_FAIL;
    }

    if (RegDeleteValue(hk,cszNameKey))
    {
        hr = E_FAIL;
    }

    if (RegDeleteValue(hk,cszShortNameKey))
    {
        hr = E_FAIL;
    }

    RegCloseKey(hk);

    if (RegDeleteKey(HKEY_LOCAL_MACHINE,szRegKey))
    {
        hr = E_FAIL;
    }

    return hr;
}


STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusicEchoTool,
                     g_szEchoFriendlyName,
                     g_szEchoVerIndProgID,
                     g_szEchoProgID);
    UnregisterTool(CLSID_DirectMusicEchoTool);
    UnregisterServer(CLSID_DirectMusicTransposeTool,
                     g_szTransposeFriendlyName,
                     g_szTransposeVerIndProgID,
                     g_szTransposeProgID);
    UnregisterTool(CLSID_DirectMusicTransposeTool);
    UnregisterServer(CLSID_DirectMusicDurationTool,
                     g_szDurationFriendlyName,
                     g_szDurationVerIndProgID,
                     g_szDurationProgID);
    UnregisterTool(CLSID_DirectMusicDurationTool);
    UnregisterServer(CLSID_DirectMusicQuantizeTool,
                     g_szQuantizeFriendlyName,
                     g_szQuantizeVerIndProgID,
                     g_szQuantizeProgID);
    UnregisterTool(CLSID_DirectMusicQuantizeTool);
    UnregisterServer(CLSID_DirectMusicSwingTool,
                     g_szSwingFriendlyName,
                     g_szSwingVerIndProgID,
                     g_szSwingProgID);
    UnregisterTool(CLSID_DirectMusicSwingTool);
    UnregisterServer(CLSID_DirectMusicTimeShiftTool,
                     g_szTimeShiftFriendlyName,
                     g_szTimeShiftVerIndProgID,
                     g_szTimeShiftProgID);
    UnregisterTool(CLSID_DirectMusicTimeShiftTool);
    UnregisterServer(CLSID_DirectMusicVelocityTool,
                     g_szVelocityFriendlyName,
                     g_szVelocityVerIndProgID,
                     g_szVelocityProgID);
    UnregisterTool(CLSID_DirectMusicVelocityTool);
    return S_OK;
}

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectMusicEchoTool,
                   g_szEchoFriendlyName,
                   g_szEchoVerIndProgID,
                   g_szEchoProgID);
    RegisterTool(CLSID_DirectMusicEchoTool, g_szEchoDescription, g_szEchoShortName, g_szEchoFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicTransposeTool,
                   g_szTransposeFriendlyName,
                   g_szTransposeVerIndProgID,
                   g_szTransposeProgID);
    RegisterTool(CLSID_DirectMusicTransposeTool, g_szTransposeDescription, g_szTransposeShortName, g_szTransposeFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicDurationTool,
                   g_szDurationFriendlyName,
                   g_szDurationVerIndProgID,
                   g_szDurationProgID);
    RegisterTool(CLSID_DirectMusicDurationTool, g_szDurationDescription, g_szDurationShortName, g_szDurationFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicQuantizeTool,
                   g_szQuantizeFriendlyName,
                   g_szQuantizeVerIndProgID,
                   g_szQuantizeProgID);
    RegisterTool(CLSID_DirectMusicQuantizeTool, g_szQuantizeDescription, g_szQuantizeShortName, g_szQuantizeFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicSwingTool,
                   g_szSwingFriendlyName,
                   g_szSwingVerIndProgID,
                   g_szSwingProgID);
    RegisterTool(CLSID_DirectMusicSwingTool, g_szSwingDescription, g_szSwingShortName, g_szSwingFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicTimeShiftTool,
                   g_szTimeShiftFriendlyName,
                   g_szTimeShiftVerIndProgID,
                   g_szTimeShiftProgID);
    RegisterTool(CLSID_DirectMusicTimeShiftTool, g_szTimeShiftDescription, g_szTimeShiftShortName, g_szTimeShiftFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicVelocityTool,
                   g_szVelocityFriendlyName,
                   g_szVelocityVerIndProgID,
                   g_szVelocityProgID);
    RegisterTool(CLSID_DirectMusicVelocityTool, g_szVelocityDescription, g_szVelocityShortName, g_szVelocityFriendlyName);
    return S_OK; 
}

extern void DebugInit();

// Standard Win32 DllMain
//

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        DebugTrace(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        DebugTrace(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {
        if (++nReferenceCount == 1)
        { 
            g_hModule = (HMODULE)hModule;
#ifndef UNDER_CE
            OSVERSIONINFO osvi;

            DisableThreadLibraryCalls(hModule);
            osvi.dwOSVersionInfoSize = sizeof(osvi);
            GetVersionEx(&osvi);
            g_fIsUnicode = 
				(osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS);
#endif
#ifdef DBG
			DebugInit();
#endif
		}
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMTOOL"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmsynth\voice.cpp ===
//
// Voice.cpp
// Copyright (c) 1996-2001 Microsoft Corporation
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#include <math.h>
#include "muldiv32.h"
#else
#include "debug.h"
#include "simple.h"
#include <mmsystem.h>
#include <dmusicc.h>
#include <dmusics.h>
#include "synth.h"
#include <math.h>
#include <stdio.h>
#include "csynth.h"
#endif

#include "fparms.h" // Generated filter parameter arrays

#ifdef _X86_
#define MMX_ENABLED 1
#endif

#ifdef DBG
extern DWORD sdwDebugLevel;
#endif

CVoiceLFO::CVoiceLFO()
{
    m_pModWheelIn = NULL;
    m_pPressureIn = NULL;
    m_bEnable = TRUE;
}

short CVoiceLFO::m_snSineTable[256];

void CVoiceLFO::Init()
{
    double flTemp;
    long lIndex;

    for (lIndex = 0;lIndex < 256;lIndex++)
    {
        flTemp = lIndex;
        flTemp *= 6.283185307;
        flTemp /= 256.0;
        flTemp = sin(flTemp);
        flTemp *= 100.0;
        m_snSineTable[lIndex] = (short) flTemp;
    }
}


STIME CVoiceLFO::StartVoice(CSourceLFO *pSource,
                    STIME stStartTime, CModWheelIn * pModWheelIn, CPressureIn * pPressureIn)
{
    m_bEnable = TRUE;

    m_pModWheelIn = pModWheelIn;
    m_pPressureIn = pPressureIn;
    m_Source = *pSource;
    m_stStartTime = stStartTime;
    if ((m_Source.m_prMWPitchScale == 0) && (m_Source.m_vrMWVolumeScale == 0) &&
        (m_Source.m_prPitchScale == 0) && (m_Source.m_vrVolumeScale == 0))
    {
        m_stRepeatTime = 44100;
    }
    else
    {
        m_stRepeatTime = 2097152 / m_Source.m_pfFrequency; // (1/8 * 256 * 4096 * 16)
    }
    return (m_stRepeatTime);
}

long CVoiceLFO::GetLevel(STIME stTime, STIME *pstNextTime)
{
    if ( !m_bEnable )
        return 0;

    stTime -= (m_stStartTime + m_Source.m_stDelay);
    if (stTime < 0)
    {
        *pstNextTime = -stTime;
        return (0);
    }
    *pstNextTime = m_stRepeatTime;
    stTime *= m_Source.m_pfFrequency;
    stTime = stTime >> (12 + 4); // We've added 4 extra bits of resolution...
    return (m_snSineTable[stTime & 0xFF]);
}

VREL CVoiceLFO::GetVolume(STIME stTime, STIME *pstNextTime)
{
    VREL vrVolume;
    VREL vrCPVolume;
    VREL vrMWVolume;

    if ( !m_bEnable )
        return 0;

    vrCPVolume = m_pPressureIn->GetPressure(stTime);
    vrCPVolume *= m_Source.m_vrCPVolumeScale;
    vrCPVolume /= 127;

    vrMWVolume = m_pModWheelIn->GetModulation(stTime);
    vrMWVolume *= m_Source.m_vrMWVolumeScale;
    vrMWVolume /= 127;

    vrVolume  = vrMWVolume;
    vrVolume += vrCPVolume;
    vrVolume += m_Source.m_vrVolumeScale;
    vrVolume *= GetLevel(stTime, pstNextTime);
    vrVolume /= 100;
    return (vrVolume);
}

PREL CVoiceLFO::GetPitch(STIME stTime, STIME *pstNextTime)
{
    PREL prPitch;
    PREL prCPPitch;
    PREL prMWPitch;

    if ( !m_bEnable )
        return 0;

    prCPPitch = m_pPressureIn->GetPressure(stTime);
    prCPPitch *= m_Source.m_prCPPitchScale;
    prCPPitch /= 127;

    prMWPitch = m_pModWheelIn->GetModulation(stTime);
    prMWPitch *= m_Source.m_prMWPitchScale;
    prMWPitch /= 127;

    prPitch  = prMWPitch;
    prPitch += prCPPitch;
    prPitch += m_Source.m_prPitchScale;
    prPitch *= GetLevel(stTime, pstNextTime);
    prPitch /= 100;

    return (prPitch);
}

PREL CVoiceLFO::GetCutoff(STIME stTime)
{
    PREL prPitch;
    PREL prCPPitch;
    PREL prMWPitch;
    STIME stNextTime;

    if ( !m_bEnable )
        return 0;

    prCPPitch = m_pPressureIn->GetPressure(stTime);
    prCPPitch *= m_Source.m_prCPCutoffScale;
    prCPPitch /= 127;

    prMWPitch = m_pModWheelIn->GetModulation(stTime);
    prMWPitch *= m_Source.m_prMWCutoffScale;
    prMWPitch /= 127;

    prPitch  = prMWPitch;
    prPitch += prCPPitch;
    prPitch += m_Source.m_prCutoffScale;
    prPitch *= GetLevel(stTime, &stNextTime);
    prPitch /= 100;

    return (prPitch);
}

CVoiceEG::CVoiceEG()
{
    m_stStopTime = 0;
    m_bEnable = TRUE;
}

short CVoiceEG::m_snAttackTable[201];

void CVoiceEG::Init()
{
    double flTemp;
    long lV;

    m_snAttackTable[0] = 0;
    for (lV = 1;lV <= 200; lV++)
    {
        flTemp = lV;
        flTemp /= 200.0;
        flTemp *= flTemp;
        flTemp = log10(flTemp);
        flTemp *= 10000.0;
        flTemp /= 96.0;
        flTemp += 1000.0;
        m_snAttackTable[lV] = (short) flTemp;
    }
}

void CVoiceEG::StopVoice(STIME stTime)
{
    if ( m_bEnable )
    {
        m_Source.m_stRelease *= GetLevel(stTime, &m_stStopTime, TRUE);    // Adjust for current sustain level.
        m_Source.m_stRelease /= 1000;
    }
    m_stStopTime = stTime;
}

void CVoiceEG::QuickStopVoice(STIME stTime, DWORD dwSampleRate)

{
    if ( m_bEnable )
    {
        m_Source.m_stRelease *= GetLevel(stTime, &m_stStopTime, TRUE);    // Adjust for current sustain level.
        m_Source.m_stRelease /= 1000;
        dwSampleRate /= 70;
        if (m_Source.m_stRelease > (long) dwSampleRate)
        {
            m_Source.m_stRelease = dwSampleRate;
        }
    }
    m_stStopTime = stTime;
}

STIME CVoiceEG::StartVoice(CSourceEG *pSource, STIME stStartTime,
                    WORD nKey, WORD nVelocity, STIME stMinAttack)
{
    m_bEnable = TRUE;

    m_stStartTime = stStartTime;
    m_stStopTime = 0x7fffffffffffffff;      // set to indefinite future
    m_Source = *pSource;
    if (m_Source.m_stAttack < stMinAttack)
    {
        m_Source.m_stAttack = stMinAttack;
    }
    if (m_Source.m_stRelease < stMinAttack)
    {
        m_Source.m_stRelease = stMinAttack;
    }

    // apply velocity to attack length scaling here
    m_Source.m_stAttack *= CDigitalAudio::PRELToPFRACT(nVelocity * m_Source.m_trVelAttackScale / 127);
    m_Source.m_stAttack /= 4096;

    m_Source.m_stHold  *= CDigitalAudio::PRELToPFRACT(nKey * m_Source.m_trKeyDecayScale / 127);
    m_Source.m_stHold  /= 4096;

    m_Source.m_stDecay *= CDigitalAudio::PRELToPFRACT(nKey * m_Source.m_trKeyDecayScale / 127);
    m_Source.m_stDecay /= 4096;

    m_Source.m_stDecay *= (1000 - m_Source.m_pcSustain);
    m_Source.m_stDecay /= 1000;

    if ( m_Source.m_stDelay )
        return ((STIME)m_Source.m_stDelay);
    else
        return ((STIME)m_Source.m_stAttack);
}

//note: appears to not be in use
BOOL CVoiceEG::InAttack(STIME st)
{
    if ( !m_bEnable )
        return FALSE;

    // has note been released?
    if (st >= m_stStopTime)
        return FALSE;

    // past length of attack?
    if (st >= m_stStartTime + m_Source.m_stDelay + m_Source.m_stAttack)
        return FALSE;

    return TRUE;
}

BOOL CVoiceEG::InRelease(STIME st)
{
    if ( !m_bEnable )
        return FALSE;

    // has note been released?
    if (st > m_stStopTime)
        return TRUE;

    return FALSE;
}

long CVoiceEG::GetLevel(STIME stEnd, STIME *pstNext, BOOL fVolume)
{
    long lLevel = 0;

    if (stEnd <= m_stStopTime)
    {
        stEnd -= m_stStartTime;
        if (stEnd < m_Source.m_stDelay )
        {
            lLevel = 0;
            *pstNext = m_Source.m_stDelay - stEnd;
        }
        else
        {
            stEnd -= m_Source.m_stDelay;
            if (stEnd < m_Source.m_stAttack )
            {
                // still in attack
                lLevel = 1000 * (long) stEnd;
                if (m_Source.m_stAttack)
                {
                    lLevel /= (long) m_Source.m_stAttack;
                }
                else // This should never happen, but it does...
                {
                    lLevel = 0;
                }
                *pstNext = m_Source.m_stAttack - stEnd;
                if (lLevel < 0) lLevel = 0;
                if (lLevel > 1000) lLevel = 1000;
                if (fVolume)
                {
                    lLevel = m_snAttackTable[lLevel / 5];
                }
            }
            else
            {
                stEnd -= m_Source.m_stAttack;
                if ( stEnd < m_Source.m_stHold )
                {
                    lLevel = 1000;
                    *pstNext = m_Source.m_stHold - stEnd;
                    if (fVolume)
                    {
                        lLevel = m_snAttackTable[lLevel / 5];
                    }
                }
                else
                {
                    stEnd -= m_Source.m_stHold;
                    if (stEnd < m_Source.m_stDecay)
                    {
                        // still in decay
                        lLevel = (1000 - m_Source.m_pcSustain) * (long) stEnd;
                        lLevel /= (long) m_Source.m_stDecay;
                        lLevel = 1000 - lLevel;
                        // To improve the decay curve, set the next point to be 1/4, 1/2, or end of slope.
                        // To avoid close duplicates, fudge an extra 100 samples.
                        if (stEnd < ((m_Source.m_stDecay >> 2) - 100))
                        {
                            *pstNext = (m_Source.m_stDecay >> 2) - stEnd;
                        }
                        else if (stEnd < ((m_Source.m_stDecay >> 1) - 100))
                        {
                            *pstNext = (m_Source.m_stDecay >> 1) - stEnd;
                        }
                        else
                        {
                            *pstNext = m_Source.m_stDecay - stEnd;  // Next is end of decay.
                        }
                    }
                    else
                    {
                        // in sustain
                        lLevel = m_Source.m_pcSustain;
                        *pstNext = 44100;
                    }
                }
            }
        }
    }
    else
    {
        STIME stBogus;
        // in release
        stEnd -= m_stStopTime;

        if (stEnd < m_Source.m_stRelease)
        {
            lLevel = GetLevel(m_stStopTime, &stBogus, fVolume) * (long) (m_Source.m_stRelease - stEnd);
            lLevel /= (long) m_Source.m_stRelease;
            if (stEnd < ((m_Source.m_stRelease >> 2) - 100))
            {
                *pstNext = (m_Source.m_stRelease >> 2) - stEnd;
            }
            else if (stEnd < ((m_Source.m_stRelease >> 1) - 100))
            {
                *pstNext = (m_Source.m_stRelease >> 1) - stEnd;
            }
            else
            {
                *pstNext = m_Source.m_stRelease - stEnd;  // Next is end of decay.
            }
        }
        else
        {
            lLevel = 0;   // !!! off
            *pstNext = 0x7FFFFFFFFFFFFFFF;
        }
    }

    return lLevel;
}

VREL CVoiceEG::GetVolume(STIME stTime, STIME *pstNextTime)
{
    if ( !m_bEnable )
        return 0;

    VREL vrLevel = GetLevel(stTime, pstNextTime, TRUE) * 96;
    vrLevel /= 10;
    vrLevel = vrLevel - 9600;
    return vrLevel;
}

PREL CVoiceEG::GetPitch(STIME stTime, STIME *pstNextTime)
{
    if ( !m_bEnable )
        return 0;

    PREL prLevel;
    if (m_Source.m_sScale != 0)
    {
        prLevel = GetLevel(stTime, pstNextTime, FALSE);
        prLevel *= m_Source.m_sScale;
        prLevel /= 1000;
    }
    else
    {
        *pstNextTime = 44100;
        prLevel = 0;
    }
    return prLevel;
}

PREL CVoiceEG::GetCutoff(STIME stTime)
{
    if ( !m_bEnable )
        return 0;

    PREL prLevel;
    STIME pstNextTime;  // not used
    if (m_Source.m_prCutoffScale != 0)
    {
        prLevel = GetLevel(stTime, &pstNextTime, FALSE);
        prLevel *= m_Source.m_prCutoffScale;
        prLevel /= 1000;
    }
    else
    {
        prLevel = 0;
    }
    return prLevel;
}

void CVoiceFilter::StartVoice(CSourceFilter *pSource, CVoiceLFO *pLFO, CVoiceEG *pEG, WORD nKey, WORD nVelocity)
{
    m_Source = *pSource;
    m_pLFO = pLFO;
    m_pEG  = pEG;
    m_prVelScale = (nVelocity * m_Source.m_prVelScale) / 127;
    m_prKeyScale = (nKey * m_Source.m_prKeyScale) / 127;
}


/////////////////////////////////////////////////////////////////////////////////
// DLS2 Lowpass Filter Filter
/*

>>>>> finish low pass filter comment

        b1 = -2.0 * r * cos(theta);
        b2 = r * r;
        K  = (1.0 + b1 + b2) * pow(10.0, -qIndex * 0.0375);

  The Filter :

        z  = (K * sample[i]) - (b1 * z1) - (b2 * z2)
        z2 = z1
        z1 = z

>>> B1 negation turned to positive then used as an add instead of subtraction.

  Resonance : Q
    GainUnits

        -qIndex * 0.0375

        0.0375 = 1.5/40 in db's

    Values
        Q min/max Values are 0db to 22.5db
        Q min/max Values are 0   to 225 in 1/10th db's


  Cutoff Fequency : Fc
    Pitch absolute values

        Absolute Pitch = ((1200 * log2(F/440)) + 6900)

    Values
        Initial Fc min/max Values are 200Hz to 7998Hz
        Initial Fc min/max Values are 5535  to 11921 in abosolute pitch cents


  Table Indexs

        65 - entries in the table

                                Hertz   Pitch
        --------------------------------------
        Max Sample Rate     -> 48000Hz (15023) ---|
                               44100Hz (14877)    |
                               22050Hz (13676)    |
                               .......          9488
        Max Cutoff Freq     -> 7999Hz  (11921)    |
                               .......            |
        Min Cutoff Freq     ->  200Hz  (5535)  ---|


        More Acurately .....

        48KHz       15023.26448623030034519401770744100
        200Hz     -  5534.99577150007811000514765931632
                  =====================================
        Feq Range    9488.26871473022223518887004812496

        Feq Range/1200 =  7.906890596 is the Feq Range in octaves
        Feq Range/100  = 94.882687147 is the Feq Range in setimtones


      Behavoir of Fc to indexes according to ouput Sample Rate

        SampleRate of 48k (15023)
            Fc < 5535  (200Hz)   -> fIndex = 0
            Fc = 11921 (7999Hz)  -> fIndex = 63.86
            Fc > 11935 (8064Hz)  -> fIndex = 64

        SampleRate of 41k (14877)
            Fc = 5535  (200Hz)   -> fIndex = 0
            Fc < 5389  (200Hz)   -> fIndex = 0
            Fc > 11789 (7411Hz)  -> fIndex = 64
            Fc = 11921 (7999Hz)  -> fIndex = 65.32

        SampleRate of 22k (13676)
            Fc < 4188  (92Hz)    -> fIndex = 0
            Fc = 5535  (200Hz)   -> fIndex = 13.44
                 10574 (3675Hz)  -> spec min of 1/6th the sample rate
            Fc > 10588 (3704Hz)  -> fIndex = 64
                 11276 (5510Hz)  -> filter fails one octave bellow Nyquist
            Fc = 11921 (7999Hz)  -> fIndex = 77.33
                 12476 (11025Hz) -> nyquist

  Precision

        0.01 - minimal acuracy for interpolation

        9488.2687
        0.00025 +/- error

        m_aB1[0][63] =    0x33ea24fb  = 0.811166044148771133412393865559
        m_aB1[0][64] =  - 0x2fa8ebf5  = 0.744685163483661751713288716704
                        ============
                          0x04413906  = 0.066480880665109381699105148854

        fIndex's fractional constant  = 0.002687147302222351888700481249

        interpolation of
        m_aB1[0][63] + constant       = 0.810987400229642518622447868604

        difference                    = 0.000178643919128614789945996955

        One 2.30 fixpoint bit         = 0.000000000931322575482840254421

        9488.2687147
        7.906890596 * 1200 = 9488.2687152 <-- precision error

        1-bit lossed when going to intger math
*/
//
void CVoiceFilter::GetCoeff(STIME stTime, PREL prFreqIn, COEFF& cfK, COEFF& cfB1, COEFF& cfB2)
{
    PREL prCutoff;
    DWORD dwFract;
    int iQIndex;
    int iIndex;

    //
    // Check if filter is disabled
    //
    if (m_Source.m_prCutoff == 0x7FFF)
    {
        cfK  = 0x40000000;  // is unity in 2.30 fixpoint
        cfB1 = 0;
        cfB2 = 0;
        return;
    }

    //
    // Accumulate the current Cutoff Frequency
    //
    prCutoff  = m_Source.m_prCutoffSRAdjust;
    prCutoff += m_pLFO->GetCutoff(stTime);
    prCutoff += m_pEG->GetCutoff(stTime);
    prCutoff += m_prVelScale;
    prCutoff += prFreqIn;

    //
    // Set the Resonance Q index
    //
    iQIndex = m_Source.m_iQIndex;

    //
    // Set the cutoff frequency index, and retrive
    // the fractional part for interpolation
    //
    iIndex  = prCutoff;
    if ( iIndex >= 0 )
    {
        dwFract = iIndex % 100;
        iIndex /= 100;
    }
    else
    {
        dwFract = 0;
        iIndex  = -1;
    }

    if (iIndex < 0) // Cutoff fequency is less than 100Hz (at 48k Fs)
    {
        cfK  =  m_aK[iQIndex][0];
        cfB1 = m_aB1[iQIndex][0];
        cfB2 = m_aB2[iQIndex][0];
    }
    else if (iIndex >= FILTER_PARMS_DIM_FC - 1)
    {
        cfK  =  m_aK[iQIndex][FILTER_PARMS_DIM_FC - 1];
        cfB1 = m_aB1[iQIndex][FILTER_PARMS_DIM_FC - 1];
        cfB2 = m_aB2[iQIndex][FILTER_PARMS_DIM_FC - 1];
    }
    else if (iIndex >= FILTER_PARMS_DIM_FC - 5)
    {
        //
        // Not enough headroom to handle the calculation,
        // shift the range douwn by half
        //
        cfK  =  m_aK[iQIndex][iIndex] + (((( m_aK[iQIndex][iIndex+1] -  m_aK[iQIndex][iIndex])   >> 1) * dwFract)/50);
        cfB1 = m_aB1[iQIndex][iIndex] - ((((m_aB1[iQIndex][iIndex]   - m_aB1[iQIndex][iIndex+1]) >> 1) * dwFract)/50);
        cfB2 = m_aB2[iQIndex][iIndex] - ((((m_aB2[iQIndex][iIndex]   - m_aB2[iQIndex][iIndex+1]) >> 1) * dwFract)/50);
    }
    else
    {
        cfK  =  m_aK[iQIndex][iIndex] + (((( m_aK[iQIndex][iIndex+1] -  m_aK[iQIndex][iIndex]))   * dwFract)/100);
        cfB1 = m_aB1[iQIndex][iIndex] - ((((m_aB1[iQIndex][iIndex]   - m_aB1[iQIndex][iIndex+1])) * dwFract)/100);
        cfB2 = m_aB2[iQIndex][iIndex] - ((((m_aB2[iQIndex][iIndex]   - m_aB2[iQIndex][iIndex+1])) * dwFract)/100);
    }
}

//------------------------------------------------------------------------------------
// Reference Filter
// Note: This code is used only for testing or to understance the derivation
// of the above filter code. It was the original source for the current implementation
// aboce was optimized
//------------------------------------------------------------------------------------
/*void CVoiceFilter::GetCoeffRef(STIME stTime, COEFF &cfK, COEFF &cfB1, COEFF &cfB2)
{
    PREL prCutoff;
    int iQIndex;
    int iIndex;
    double fIndex;
    double fIntrp;

    //
    // Check if filter is disabled
    //
    if (m_Source.m_prCutoff == 0x7FFF)
    {
        cfK  = 0x40000000;  // unity in 2.30 fixpoint
        cfB1 = 0;
        cfB2 = 0;
        return;
    }

    //
    // Accumulate the current Cutoff Frequency
    //
    prCutoff  = m_Source.m_prCutoff;
    prCutoff += m_pLFO->GetCutoff(stTime);
    prCutoff += m_pEG->GetCutoff(stTime);
    prCutoff += m_prVelScale;

    //
    // There are 16 resonance values spaced 1.5db arpart
    // DLS2's has a minimum 1.5db error tolerance
    // Range of values it  0db to 22.5db
    // m_Source.m_vrQ are in 1/10 db's
    // The 15.0 represents the 1.5db'in 1/10 db's
    // with the 0.5 for rounding to the nearest index
    //
    iQIndex = (int)((m_Source.m_vrQ / 15.0f) + 0.5f);
    if (iQIndex < 0)
        iQIndex = 0;
    if (iQIndex > FILTER_PARMS_DIM_Q-1) // FILTER_PARMS_DIM_Q = 16
        iQIndex = FILTER_PARMS_DIM_Q-1;

    // >>>>> docdoc
    //
    //
    fIndex = 12.0 * (((prCutoff - m_Source.m_prSampleRate) / 1200.0 ) + 7.906890596);
    iIndex = (int)fIndex;
    fIntrp = fIndex - iIndex;

    if (iIndex < 0)
    {
        cfK  = m_aK [iQIndex][0];
        cfB1 = m_aB1[iQIndex][0];
        cfB2 = m_aB2[iQIndex][0];
    }
    else if (iIndex >= FILTER_PARMS_DIM_FC - 1)
    {
        cfK  = m_aK [iQIndex][FILTER_PARMS_DIM_FC - 1];
        cfB1 = m_aB1[iQIndex][FILTER_PARMS_DIM_FC - 1];
        cfB2 = m_aB2[iQIndex][FILTER_PARMS_DIM_FC - 1];
    }
    else
    {
        //
        // Linearly interpolate the fractional part of the index
        // accross two values of the coeficient table
        //
        cfK  = (COEFF)(m_aK[iQIndex][iIndex] * (1.0 - fIntrp) +
                         m_aK[iQIndex][iIndex+1] * fIntrp);

        cfB1 = (COEFF)(m_aB1[iQIndex][iIndex] * (1.0 - fIntrp) +
                         m_aB1[iQIndex][iIndex+1] * fIntrp);

        cfB2 = (COEFF)(m_aB2[iQIndex][iIndex] * (1.0 - fIntrp) +
                         m_aB2[iQIndex][iIndex+1] * fIntrp);
    }
}*/

BOOL CVoiceFilter::IsFiltered()
{
    return (m_Source.m_prCutoff != 0x7FFF);
}

CDigitalAudio::CDigitalAudio()
{
    m_pfBasePitch = 0;
    m_pfLastPitch = 0;
    m_pfLastSample = 0;
    m_pfLoopEnd = 0;
    m_pfLoopStart = 0;
    m_pfSampleLength = 0;
    m_prLastPitch = 0;
    m_ullLastSample = 0;
    m_ullLoopStart = 0;
    m_ullLoopEnd = 0;
    m_ullSampleLength = 0;
    m_fElGrande = FALSE;
    m_pCurrentBuffer = NULL;
    m_pWaveArt = NULL;
    m_ullSamplesSoFar = 0;
    m_lPrevSample = 0;
    m_lPrevPrevSample = 0;
};

CDigitalAudio::~CDigitalAudio()
{
    if (m_pWaveArt)
    {
        m_pWaveArt->Release();
    }
}

PFRACT CDigitalAudio::m_spfCents[201];
PFRACT CDigitalAudio::m_spfSemiTones[97];
VFRACT CDigitalAudio::m_svfDbToVolume[(MAXDB - MINDB) * 10 + 1];
BOOL CDigitalAudio::m_sfMMXEnabled = FALSE;

#ifdef MMX_ENABLED
BOOL MultiMediaInstructionsSupported();
#endif
#pragma optimize("", off) // Optimize causes crash! Argh!

void CDigitalAudio::Init()
{
    double flTemp;
    VREL    vrdB;

#ifdef MMX_ENABLED
    m_sfMMXEnabled = MultiMediaInstructionsSupported();
#endif // MMX_ENABLED
    for (vrdB = MINDB * 10;vrdB <= MAXDB * 10;vrdB++)
    {
        flTemp = vrdB;
        flTemp /= 100.0;
        flTemp = pow(10.0, flTemp);
        flTemp = pow(flTemp, 0.5);   // square root.
        flTemp *= 4095.0; // 2^12th, but avoid overflow...
        m_svfDbToVolume[vrdB - (MINDB * 10)] = (long) flTemp;
    }

    PREL prRatio;

    for (prRatio = -100;prRatio <= 100;prRatio++)
    {
        flTemp = prRatio;
        flTemp /= 1200.0;
        flTemp = pow(2.0, flTemp);
        flTemp *= 4096.0;
        m_spfCents[prRatio + 100] = (long) flTemp;
    }

    for (prRatio = -48;prRatio <= 48;prRatio++)
    {
        flTemp = prRatio;
        flTemp /= 12.0;
        flTemp = pow(2.0, flTemp);
        flTemp *= 4096.0;
        m_spfSemiTones[prRatio + 48] = (long) flTemp;
    }
}
#pragma optimize("", on)

VFRACT CDigitalAudio::VRELToVFRACT(VREL vrVolume)
{
    vrVolume /= 10;

    if (vrVolume < MINDB * 10)
        vrVolume = MINDB * 10;
    else if (vrVolume >= MAXDB * 10)
        vrVolume = MAXDB * 10;

    return (m_svfDbToVolume[vrVolume - MINDB * 10]);
}

PFRACT CDigitalAudio::PRELToPFRACT(PREL prPitch)
{
    PFRACT pfPitch = 0;
    PREL prOctave;
    if (prPitch > 100)
    {
        if (prPitch > 4800)
        {
            prPitch = 4800;
        }
        prOctave = prPitch / 100;
        prPitch = prPitch % 100;
        pfPitch = m_spfCents[prPitch + 100];
        pfPitch <<= prOctave / 12;
        prOctave = prOctave % 12;
        pfPitch *= m_spfSemiTones[prOctave + 48];
        pfPitch >>= 12;
    }
    else if (prPitch < -100)
    {
        if (prPitch < -4800)
        {
            prPitch = -4800;
        }
        prOctave = prPitch / 100;
        prPitch = (-prPitch) % 100;
        pfPitch = m_spfCents[100 - prPitch];
        pfPitch >>= ((-prOctave) / 12);
        prOctave = (-prOctave) % 12;
        pfPitch *= m_spfSemiTones[48 - prOctave];
        pfPitch >>= 12;
    }
    else
    {
        pfPitch = m_spfCents[prPitch + 100];
    }
    return (pfPitch);
}

void CDigitalAudio::ClearVoice()

{
    if (m_Source.m_pWave != NULL)
    {
        m_Source.m_pWave->PlayOff();
        m_Source.m_pWave->Release();    // Releases wave structure.
        m_Source.m_pWave = NULL;
    }
    if (m_pWaveArt)
    {
        m_pWaveArt->Release();
        m_pWaveArt = NULL;
    }
}

STIME CDigitalAudio::StartVoice(CSynth *pSynth,
                               CSourceSample *pSample,
                               PREL prBasePitch,
                               long lKey)
{
    m_prLastPitch = 0;
    m_lPrevSample = 0;
    m_lPrevPrevSample = 0;
    m_cfLastK  = 0;
    m_cfLastB1 = 0;
    m_cfLastB2 = 0;

    m_Source = *pSample;
    m_pnWave = pSample->m_pWave->m_pnWave;
    m_pSynth = pSynth;

    m_bOneShot = m_Source.m_bOneShot;

    pSample->m_pWave->AddRef(); // Keeps track of Wave usage.
    pSample->m_pWave->PlayOn();

    // Set initial pitch
    prBasePitch += pSample->m_prFineTune;
    prBasePitch += ((lKey - pSample->m_bMIDIRootKey) * 100);
    m_pfBasePitch = PRELToPFRACT(prBasePitch);
    m_pfBasePitch *= pSample->m_dwSampleRate;
    m_pfBasePitch /= pSynth->m_dwSampleRate;
    m_pfLastPitch = m_pfBasePitch;

    m_fElGrande = pSample->m_dwSampleLength >= 0x80000;     // Greater than 512k.
    if ((pSample->m_dwLoopEnd - pSample->m_dwLoopStart) >= 0x80000)
    {   // We can't handle loops greater than 1 meg!
        m_bOneShot = TRUE;
    }

    m_ullLastSample = 0;
    m_ullLoopStart = pSample->m_dwLoopStart;
    m_ullLoopStart = m_ullLoopStart << 12;
    m_ullLoopEnd = pSample->m_dwLoopEnd;
    m_ullLoopEnd = m_ullLoopEnd << 12;
    m_ullSampleLength = pSample->m_dwSampleLength;
    m_ullSampleLength = m_ullSampleLength << 12;
    m_pfLastSample = 0;
    m_pfLoopStart = (long) m_ullLoopStart;
    m_pfLoopEnd = (long) m_ullLoopEnd;

    if (m_ullLoopEnd <= m_ullLoopStart) // Should never happen, but death if it does!
    {
        m_bOneShot = TRUE;
    }
    if (m_fElGrande)
    {
        m_pfSampleLength = 0x7FFFFFFF;
    }
    else
    {
        m_pfSampleLength = (long) m_ullSampleLength;
    }

    m_pCurrentBuffer = NULL;    // Used by wave playing must be null for standard sample
    m_pWaveArt = NULL;
    m_ullSamplesSoFar = 0;

    return (0); // !!! what is this return value?
}


STIME CDigitalAudio::StartWave(CSynth *pSynth,
                               CWaveArt *pWaveArt,
                               PREL prBasePitch,
                               SAMPLE_TIME stVoiceStart,
                               SAMPLE_TIME stLoopStart,
                               SAMPLE_TIME stLoopEnd)
{
    m_pSynth   = pSynth;    // Save Synth

    if (pWaveArt)
    {
        pWaveArt->AddRef();
    }
    if (m_pWaveArt)
    {
        m_pWaveArt->Release();
    }
    m_pWaveArt = pWaveArt;  // Save Wave articulation

    // Reset all wave buffer flags
    CWaveBuffer* pWavBuf = pWaveArt->m_pWaves.GetHead();
    while ( pWavBuf )
    {
        pWavBuf->m_pWave->m_bActive = FALSE;
        pWavBuf = pWavBuf->GetNext();
    }

    // Initialize the current play buffer
    m_pCurrentBuffer = pWaveArt->m_pWaves.GetHead();;

    //if m_pCurrentBuffer is NULL the articulation contains
    //no samples... this shouldn't be possible.
    assert(m_pCurrentBuffer);

    m_pCurrentBuffer->m_pWave->m_bActive = TRUE;
    m_pCurrentBuffer->m_pWave->AddRef(); // Keeps track of Wave usage.
    m_pCurrentBuffer->m_pWave->PlayOn();

    // Fill CSourceSample class with CWave Defaults
    m_Source.m_pWave          = m_pCurrentBuffer->m_pWave;
    m_Source.m_dwSampleLength = m_pCurrentBuffer->m_pWave->m_dwSampleLength;
    m_Source.m_dwSampleRate   = m_pCurrentBuffer->m_pWave->m_dwSampleRate;
    m_Source.m_bSampleType    = m_pCurrentBuffer->m_pWave->m_bSampleType;
    m_Source.m_dwID           = m_pCurrentBuffer->m_pWave->m_dwID;
    m_Source.m_dwLoopStart    = 0;
    m_Source.m_dwLoopEnd      = m_pCurrentBuffer->m_pWave->m_dwSampleLength;
    m_Source.m_bMIDIRootKey   = 0;
    m_Source.m_prFineTune     = 0;

    m_bOneShot                = TRUE;

    // The the current sample pointer
    m_pnWave = m_pCurrentBuffer->m_pWave->m_pnWave;

    // Set initial pitch
    m_pfBasePitch = PRELToPFRACT(prBasePitch);
    m_pfBasePitch *= m_Source.m_dwSampleRate;
    m_pfBasePitch /= pSynth->m_dwSampleRate;
    m_pfLastPitch = m_pfBasePitch;
    m_prLastPitch = 0;

    m_fElGrande = m_Source.m_dwSampleLength >= 0x80000;     // Greater than 512k.

    m_ullLastSample = stVoiceStart;
    m_ullLastSample = m_ullLastSample << 12;
    m_ullSamplesSoFar = 0;
    m_ullLoopStart = m_Source.m_dwLoopStart;
    m_ullLoopStart = m_ullLoopStart << 12;
    m_ullLoopEnd = m_Source.m_dwLoopEnd;
    m_ullLoopEnd = m_ullLoopEnd << 12;
    m_ullSampleLength = m_Source.m_dwSampleLength;
    m_ullSampleLength = m_ullSampleLength << 12;
    m_pfLastSample = (long) m_ullLastSample;
    m_pfLoopStart = (long) m_ullLoopStart;
    m_pfLoopEnd = (long) m_ullLoopEnd;

    if (stLoopStart || stLoopEnd)
    {
        m_bOneShot = FALSE;

        m_ullLoopStart = stLoopStart;
        m_ullLoopStart = m_ullLoopStart << 12;
        m_ullLoopEnd = stLoopEnd;
        m_ullLoopEnd = m_ullLoopEnd << 12;
        m_pfLoopStart = (long) m_ullLoopStart;
        m_pfLoopEnd = (long) m_ullLoopEnd;
    }

    if ((stLoopEnd - stLoopStart) >= 0x80000)
    {
        m_bOneShot = TRUE;
    }

    // This could be WAY beyond the actual wave data range
    // So find out the sample we want to start at
    if(stVoiceStart > stLoopStart)
    {
        SAMPLE_TIME stLoopLen = stLoopEnd - stLoopStart;
        if(m_bOneShot == FALSE && stLoopLen != 0)
        {
            m_ullLastSample = stVoiceStart - stLoopStart;
            m_ullLastSample = m_ullLastSample - (stLoopLen * (m_ullLastSample / stLoopLen));
            m_ullLastSample = stLoopStart + m_ullLastSample;
            m_ullLastSample = m_ullLastSample << 12;
            m_pfLastSample = (long) (m_ullLastSample);
        }

        // Must be a wave with an start offset?
        // In any case we need to correct this or else we crash
        if(m_bOneShot && stVoiceStart > m_Source.m_dwSampleLength)
        {
            m_ullLastSample = 0;
            m_pfLastSample = 0;
        }
    }


    if(m_fElGrande)
    {
        m_pfSampleLength = 0x7FFFFFFF;
    }
    else
    {
        m_pfSampleLength = (long) m_ullSampleLength;
    }

    return (0);
}

/*  If the wave is bigger than one meg, the index can overflow.
    Solve this by assuming no mix session will ever be as great
    as one meg AND loops are never that long. We keep all our
    fractional indexes in two variables. In one case, m_pfLastSample,
    is the normal mode where the lower 12 bits are the fraction and
    the upper 20 bits are the index. And, m_ullLastSample
    is a LONGLONG with an extra 32 bits of index. The mix engine
    does not want the LONGLONGs, so we need to track the variables
    in the LONGLONGs and prepare them for the mixer as follows:
    Prior to mixing,
    if the sample is large (m_fElGrande is set), BeforeSampleMix()
    is called. This finds the starting point for the mix, which
    is either the current position or the start of the loop,
    whichever is earlier. It subtracts this starting point from
    the LONGLONG variables and stores an offset in m_dwAddressUpper.
    It also adjusts the pointer to the wave data appropriately.
    AfterSampleMix() does the inverse, reconstructing the the LONGLONG
    indeces and returning everthing back to normal.
*/

void CDigitalAudio::BeforeBigSampleMix()
{
    if (m_fElGrande)
    {
        ULONGLONG ullBase = 0;
        DWORD dwBase;
        if (m_bOneShot)
        {
            ullBase = m_ullLastSample;
        }
        else
        {
            if (m_ullLastSample < m_ullLoopStart)
            {
                ullBase = m_ullLastSample;
            }
            else
            {
                ullBase = m_ullLoopStart;
            }
        }

        // Keep the value as we want to offset into the wave buffer
        ULONGLONG ullWaveOffset = ullBase;

        ullBase >>= 12;
        dwBase = (DWORD) ullBase & 0xFFFFFFFE;      // Clear bottom bit so 8 bit pointer aligns with short.
        ullBase = dwBase;
        ullBase <<= 12;
        m_dwAddressUpper = dwBase;

        m_pfLastSample = (long) (m_ullLastSample - ullBase);

        if ((m_ullLoopEnd - ullBase) < 0x7FFFFFFF)
        {
            m_pfLoopStart = (long) (m_ullLoopStart - ullBase);
            m_pfLoopEnd = (long) (m_ullLoopEnd - ullBase);
        }
        else
        {
            m_pfLoopStart = 0;
            m_pfLoopEnd = 0x7FFFFFFF;
        }

        ullBase = m_ullSampleLength - ullBase;
        dwBase = (DWORD)(ullWaveOffset >> 12);

        if (ullBase > 0x7FFFFFFF)
        {
            m_pfSampleLength = 0x7FFFFFFF;
        }
        else
        {
            m_pfSampleLength = (long) ullBase;
        }
        if (m_Source.m_bSampleType & SFORMAT_8)
        {
            dwBase >>= 1;
        }
        m_pnWave = &m_Source.m_pWave->m_pnWave[dwBase];
    }
}

void CDigitalAudio::AfterBigSampleMix()
{
    m_pnWave = m_Source.m_pWave->m_pnWave;
    if (m_fElGrande)
    {
        ULONGLONG ullBase = m_dwAddressUpper;
        m_ullLastSample = m_pfLastSample;
        m_ullLastSample += (ullBase << 12);
        m_dwAddressUpper = 0;
    }
}

BOOL CDigitalAudio::Mix(short **ppBuffers,      // Array of mix buffers
                        DWORD dwBufferCount,    // Number of mix buffers
                        DWORD dwInterleaved,    // Are the buffers interleaved data?
                        DWORD dwLength,         // Length to mix, in samples
                        VREL  vrMaxVolumeDelta, // Maximum volume accross all buses
                        VFRACT vfNewVolume[],
                        VFRACT vfLastVolume[],
                        PREL  prPitch,          // Pitch to play the sample too
                        DWORD dwIsFiltered,     // Is the mix filtered
                        COEFF cfK,              // filter coeficients
                        COEFF cfB1,
                        COEFF cfB2)
{
    DWORD i;
    PFRACT pfDeltaPitch;
    PFRACT pfEnd;
    PFRACT pfLoopLen;
    PFRACT pfNewPitch;
    VFRACT vfDeltaVolume[MAX_DAUD_CHAN];
    DWORD dwPeriod = 64;
    DWORD dwSoFar;
    DWORD dwStart; // position in WORDs
    DWORD dwMixChoice = 0;
    DWORD dwBuffers;
    PFRACT pfPreMix;
    COEFFDELTA  cfdK  = 0;
    COEFFDELTA  cfdB1 = 0;
    COEFFDELTA  cfdB2 = 0;

    if (dwLength == 0)      // Attack was instant.
    {
        m_pfLastPitch = (m_pfBasePitch * PRELToPFRACT(prPitch)) >> 12;
        m_prLastPitch = prPitch;
        m_cfLastK  = cfK;
        m_cfLastB1 = cfB1;
        m_cfLastB2 = cfB2;

        return TRUE;
    }

    if ( m_pWaveArt ) // Playing a wave or Streaming
    {
        if ( m_pWaveArt->m_bStream )
        {
            // Check if the buffer is valid yet
            if ( !m_pCurrentBuffer->m_pWave->m_bValid )
            {
                Trace(3, "Warning: Synth starting mix with invalid streaming wave buffer\n\r");
                return TRUE; // not valid yet, get out of here
            }
            m_pCurrentBuffer->m_pWave->m_bActive = TRUE;

            if ( m_pCurrentBuffer->m_pWave->m_bLastSampleInit == FALSE )
            {
                CWaveBuffer* pnextbuffer = m_pCurrentBuffer->GetNextLoop();

                if ( pnextbuffer->m_pWave->m_bValid )
                {
                    DWORD dwSampleLength = m_pCurrentBuffer->m_pWave->m_dwSampleLength;   // Length of sample.

                    if ( m_Source.m_bSampleType == SFORMAT_8 )
                    {
                        ((BYTE*)m_pCurrentBuffer->m_pWave->m_pnWave)[dwSampleLength-1] = ((BYTE*)pnextbuffer->m_pWave->m_pnWave)[0];
                    }
                    else
                    {
                        m_pCurrentBuffer->m_pWave->m_pnWave[dwSampleLength-1] = pnextbuffer->m_pWave->m_pnWave[0];
                    }

                    m_pCurrentBuffer->m_pWave->m_bLastSampleInit = TRUE;
                }
            }
        }
    }

    if ((m_Source.m_pWave == NULL) || (m_Source.m_pWave->m_pnWave == NULL))
    {
        return FALSE;
    }

    DWORD dwMax = max(vrMaxVolumeDelta, abs(prPitch - m_prLastPitch) << 1);
    dwMax >>= 1;
    m_prLastPitch = prPitch;

    if (dwMax > 0)
    {
        dwPeriod = (dwLength << 3) / dwMax;
        if (dwPeriod > 512)
        {
            dwPeriod = 512;
        }
        else if (dwPeriod < 1)
        {
            dwPeriod = 1;
        }
    }
    else
    {
        dwPeriod = 512;     // Make it happen anyway.
    }

    // This makes MMX sound a little better (MMX bug will be fixed)
    dwPeriod += 3;
    dwPeriod &= 0xFFFFFFFC;

    pfNewPitch = m_pfBasePitch * PRELToPFRACT(prPitch);
    pfNewPitch >>= 12;

    pfDeltaPitch = MulDiv(pfNewPitch - m_pfLastPitch, dwPeriod << 8, dwLength);


    if ( dwInterleaved )
    {
        vfDeltaVolume[0] = MulDiv(vfNewVolume[0] - vfLastVolume[0], dwPeriod << 8, dwLength);
        vfDeltaVolume[1] = MulDiv(vfNewVolume[1] - vfLastVolume[1], dwPeriod << 8, dwLength);
    }
    else
    {
        for (dwBuffers = 0; dwBuffers < dwBufferCount; dwBuffers++)
        {
            vfDeltaVolume[dwBuffers] = MulDiv(vfNewVolume[dwBuffers] - vfLastVolume[dwBuffers], dwPeriod << 8, dwLength);
        }
    }

    if ( dwInterleaved )
    {
        dwMixChoice |= SPLAY_INTERLEAVED;
    }

    if (m_sfMMXEnabled && (dwLength > 8))
    {
        dwMixChoice |= SPLAY_MMX;
    }

    dwMixChoice |= m_Source.m_bSampleType;
    dwStart = 0;

    if (dwIsFiltered)
    {
        dwMixChoice |= SPLAY_FILTERED;

        //
        // The coeficients have been stored as DWORD's to gain an additional
        // bit of presision when calculating the interpolation between
        // coefiecients in the table.  Since these calcutlations always
        // result in positive coefiecients no greater the 1.9999,
        // we can safely cast to a signed int, from which negative deltas
        // can be correctly determined.
        //
        cfdK =  MulDiv((LONG)cfK  - (LONG)m_cfLastK,  dwPeriod, dwLength);
        cfdB1 = MulDiv((LONG)cfB1 - (LONG)m_cfLastB1, dwPeriod, dwLength);
        cfdB2 = MulDiv((LONG)cfB2 - (LONG)m_cfLastB2, dwPeriod, dwLength);
    }

    for (;;)
    {
        if (dwLength <= 8)
        {
            dwMixChoice &= ~SPLAY_MMX;
        }

        if (m_fElGrande)
        {
            BeforeBigSampleMix();
        }

        if (m_bOneShot)
        {
            pfEnd = m_pfSampleLength;
            if(m_pCurrentBuffer && m_pCurrentBuffer->m_pWave)
            {
                // We grow the buffers by one sample for interpolation so we can transition smoothly
                // between the multiple streaming buffers. This will cause a click at the end of the 
                // buffer if the wave is ending as there's no valid nex tbuffer. So we check for that
                // and adjust the length of the buffer so that the mix engine doesn't try to interpolate
                // the additional (last) sample. If it's NOT the last buffer then we proceed as planned.
                if((pfEnd >> 12) >= (long)(m_pCurrentBuffer->m_pWave->m_dwSampleLength - 1))
                {
                    CWaveBuffer* pnextbuffer = m_pCurrentBuffer->GetNextLoop();
                    if(pnextbuffer == NULL || pnextbuffer->m_pWave->m_bValid == FALSE)
                    {
                        pfEnd = (m_pCurrentBuffer->m_pWave->m_dwSampleLength - 2) << 12;    
                    }
                    else
                    {
                        pfEnd = (m_pCurrentBuffer->m_pWave->m_dwSampleLength - 1) << 12;
                    }
                }
            }

            pfLoopLen = 0;
            pfPreMix = m_pfLastSample;      // save off last sample pos
        }
        else
        {
            pfEnd = m_pfLoopEnd;
            pfLoopLen = m_pfLoopEnd - m_pfLoopStart;
            pfPreMix = 0;
            if (pfLoopLen <= pfNewPitch)
            {
                return FALSE;
            }

            if(pfLoopLen > m_pfSampleLength)
            {
                return FALSE;
            }
        }

        switch (dwMixChoice)
        {
        case SFORMAT_8 | SPLAY_INTERLEAVED :
            dwSoFar = Mix8(ppBuffers[0], dwLength, dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_16 | SPLAY_INTERLEAVED :
            dwSoFar = Mix16(ppBuffers[0], dwLength, dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_8 | SPLAY_INTERLEAVED | SPLAY_FILTERED | SPLAY_MMX : 
        case SFORMAT_8 | SPLAY_INTERLEAVED | SPLAY_FILTERED  : 
            dwSoFar = Mix8Filter(ppBuffers[0],dwLength,dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen,
                cfdK, cfdB1, cfdB2);
            break;
        case SFORMAT_16 | SPLAY_INTERLEAVED | SPLAY_FILTERED | SPLAY_MMX : 
        case SFORMAT_16 | SPLAY_INTERLEAVED | SPLAY_FILTERED  : 
            dwSoFar = Mix16Filter(ppBuffers[0],dwLength,dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen,
                cfdK, cfdB1, cfdB2);
            break;
#ifdef MMX_ENABLED
        case SFORMAT_8 | SPLAY_MMX | SPLAY_INTERLEAVED :
            dwSoFar = Mix8X(ppBuffers[0], dwLength, dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);

            break;
        case SFORMAT_16 | SPLAY_MMX | SPLAY_INTERLEAVED :
            dwSoFar = Mix16X(ppBuffers[0], dwLength, dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);
            break;
#endif
        case SFORMAT_8 :
        case SFORMAT_8 | SPLAY_MMX :
            dwSoFar = MixMulti8(ppBuffers, dwBufferCount,
                dwLength, dwPeriod,
                vfDeltaVolume,
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_8 | SPLAY_FILTERED :
        case SFORMAT_8 | SPLAY_FILTERED | SPLAY_MMX :
            dwSoFar = MixMulti8Filter(ppBuffers, dwBufferCount,
                dwLength, dwPeriod,
                vfDeltaVolume,
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen,
                cfdK, cfdB1, cfdB2);
            break;
        case SFORMAT_16 :
        case SFORMAT_16 | SPLAY_MMX :
            dwSoFar = MixMulti16(ppBuffers, dwBufferCount,
                dwLength, dwPeriod,
                vfDeltaVolume,
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_16 | SPLAY_FILTERED :
        case SFORMAT_16 | SPLAY_FILTERED | SPLAY_MMX :
            dwSoFar = MixMulti16Filter(ppBuffers, dwBufferCount,
                dwLength, dwPeriod,
                vfDeltaVolume,
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen,
                cfdK, cfdB1, cfdB2);
            break;
        default :
            return (FALSE);
        }

        if (m_fElGrande)
        {
            AfterBigSampleMix();
        }

        if (m_bOneShot)
        {
            // have mixed all we needed at this time to break
            if (dwSoFar >= dwLength)
            {
                m_ullSamplesSoFar += (m_pfLastSample - pfPreMix)>>12;
                break;
            }

            // the mix engine reached the end of the source data
            m_ullSamplesSoFar += ((m_pfLastSample - pfPreMix)>>12)-1;

            if ( m_pWaveArt ) // Playing or Streaming a Wave
            {
                if ( !m_pWaveArt->m_bStream )   // we must be at the end of the buffer
                    return FALSE;

                // Set completion flags
                m_pCurrentBuffer->m_pWave->m_bActive = FALSE;
                m_pCurrentBuffer->m_pWave->m_bValid  = FALSE;
                m_pCurrentBuffer->m_pWave->m_bLastSampleInit = FALSE;

                // Get next buffer
                m_pCurrentBuffer = m_pCurrentBuffer->GetNextLoop();

                // Set new wave pointer to play out of
                m_pnWave = m_pCurrentBuffer->m_pWave->m_pnWave;

                // Check if the buffer is valid yet
                if ( !m_pCurrentBuffer->m_pWave->m_bValid )
                {
                    Trace(2, "Warning: Synth attempting to start invalid streaming wave buffer\n\r");
                    break;  // nothing to play yet, get out of here
                }
                m_pCurrentBuffer->m_pWave->m_bActive = TRUE;

                CWaveBuffer* pnextbuffer = m_pCurrentBuffer->GetNextLoop();
                if ( pnextbuffer->m_pWave->m_bValid )
                {
                    DWORD dwSampleLength = m_pCurrentBuffer->m_pWave->m_dwSampleLength;   // Length of sample.

                    if ( m_Source.m_bSampleType == SFORMAT_8 )
                    {
                        ((BYTE*)m_pCurrentBuffer->m_pWave->m_pnWave)[dwSampleLength-1] = ((BYTE*)pnextbuffer->m_pWave->m_pnWave)[0];
                    }
                    else
                    {
                        m_pCurrentBuffer->m_pWave->m_pnWave[dwSampleLength-1] = pnextbuffer->m_pWave->m_pnWave[0];
                    }

                    m_pCurrentBuffer->m_pWave->m_bLastSampleInit = TRUE;
                }

//>>>>>>>>>> CHECK FOR LOOP POINT, IF SO NOT TRY AGAIN HERE

                dwStart  += dwSoFar << dwInterleaved;
                dwLength -= dwSoFar;
                m_pfLastSample = 0;

//>>>>>>>>>> CHECK INTERLEAVED FLAG FOR CORRECT DISTANCE ????????
                // Move buffer pointers since we are mixing more samples
                for ( i = 0; i < dwBufferCount; i++ )
                    ppBuffers[i] += dwStart;

                continue;   // keep playing
            }
            else
                return FALSE;   // Playing a standard one shot, we hit the end of the buffer
        }
        else
        {
            if (dwSoFar >= dwLength)
                break;

            // Loops are handled in the mix engine, however
            // when you reach the end of source data you will
            // reach this code.

            dwStart  += dwSoFar << dwInterleaved;
            dwLength -= dwSoFar;
            m_pfLastSample -= (m_pfLoopEnd - m_pfLoopStart);

            // Move buffer pointers since we are mixing more samples
            for ( i = 0; i < dwBufferCount; i++ )
                ppBuffers[i] += dwStart;
        }
    }

    m_pfLastPitch = pfNewPitch;
    m_cfLastK  = cfK;
    m_cfLastB1 = cfB1;
    m_cfLastB2 = cfB2;

    return (TRUE);
}

CVoice::CVoice()
{
    m_pControl = NULL;
    m_pPitchBendIn = NULL;
    m_pExpressionIn = NULL;
    m_dwPriority = 0;
    m_nPart = 0;
    m_nKey = 0;
    m_fInUse = FALSE;
    m_fSustainOn = FALSE;
    m_fNoteOn = FALSE;
    m_fTag = FALSE;
    m_stStartTime = 0;
    m_stStopTime = 0x7fffffffffffffff;
    m_stWaveStopTime = 0;
    m_vrVolume = 0;
    m_fAllowOverlap = FALSE;
    m_pRegion = NULL;
    m_pReverbSend = NULL;
    m_pChorusSend = NULL;
    m_dwLoopType = 0;

    for ( int i = 0; i < MAX_DAUD_CHAN; i++ )
    {
        m_vfLastVolume[i] = 0;
        m_vrLastVolume[i] = 0;
    }
}

VREL CVoice::m_svrPanToVREL[128];

void CVoice::Init()
{
    static BOOL fBeenHereBefore = FALSE;
    if (fBeenHereBefore) return;
    fBeenHereBefore = TRUE;
    CVoiceLFO::Init();
    CVoiceEG::Init();
    CDigitalAudio::Init();

    WORD nI;
    for (nI = 1; nI < 128; nI++)
    {
        double flTemp;
        flTemp = nI;
        flTemp /= 127.0;
        flTemp = log10(flTemp);
        flTemp *= 1000.0;
        m_svrPanToVREL[nI] = (long) flTemp;
    }
    m_svrPanToVREL[0] = -2500;
}

void CVoice::StopVoice(STIME stTime)
{
    if (m_fNoteOn)
    {
        if (stTime <= m_stStartTime) stTime = m_stStartTime + 1;
        m_PitchEG.StopVoice(stTime);
        m_VolumeEG.StopVoice(stTime);
        m_fNoteOn = FALSE;
        m_fSustainOn = FALSE;
        m_stStopTime = stTime;
        m_stWaveStopTime = 0;

        if (m_dwLoopType == WLOOP_TYPE_RELEASE)
        {
            m_DigitalAudio.BreakLoop();
        }
    }
}

void CVoice::QuickStopVoice(STIME stTime)
{
    m_fTag = TRUE;
    if (m_fNoteOn || m_fSustainOn)
    {
        if (stTime <= m_stStartTime) stTime = m_stStartTime + 1;
        m_PitchEG.StopVoice(stTime);
        m_VolumeEG.QuickStopVoice(stTime, m_pSynth->m_dwSampleRate);
        m_fNoteOn = FALSE;
        m_fSustainOn = FALSE;
        m_stStopTime = stTime;
    }
    else
    {
        m_VolumeEG.QuickStopVoice(m_stStopTime, m_pSynth->m_dwSampleRate);
    }
}

BOOL CVoice::StartVoice(CSynth *pSynth,
                           CSourceRegion *pRegion,
                           STIME stStartTime,
                           CModWheelIn * pModWheelIn,
                           CPitchBendIn * pPitchBendIn,
                           CExpressionIn * pExpressionIn,
                           CVolumeIn * pVolumeIn,
                           CPanIn * pPanIn,
                           CPressureIn * pPressureIn,
                           CReverbIn * pReverbSend,
                           CChorusIn * pChorusSend,
                           CCutOffFreqIn * pCCutOffFreqIn,
                           CBusIds * pBusIds,
                           WORD nKey,
                           WORD nVelocity,
                           VREL vrVolume,
                           PREL prPitch)
{
    m_pSynth = pSynth;

    CSourceArticulation * pArticulation = pRegion->m_pArticulation;
    if (pArticulation == NULL)
    {
        return FALSE;
    }

    m_dwLoopType = pRegion->m_Sample.m_dwLoopType;

    // if we're going to handle volume later, don't read it now.
    if (!pSynth->m_fAllowVolumeChangeWhilePlayingNote)
        vrVolume += pVolumeIn->GetVolume(stStartTime);

    prPitch += pRegion->m_prTuning;
    m_dwGroup = pRegion->m_bGroup;
    m_fAllowOverlap = pRegion->m_bAllowOverlap;

    vrVolume += CMIDIRecorder::VelocityToVolume(nVelocity);

    vrVolume += pRegion->m_vrAttenuation;

    m_lDefaultPan = pRegion->m_pArticulation->m_sDefaultPan;

    // ignore pan here if allowing pan to vary after note starts
    // or if the source is multichannel or the dest is mono
    //

    m_fIgnorePan = pRegion->IsMultiChannel();
    if (pBusIds->m_dwBusCount == 1)
    {
        DWORD dwFunctionID;
        if (m_pSynth->BusIDToFunctionID(pBusIds->m_dwBusIds[0], &dwFunctionID, NULL, NULL))
        {
            if (dwFunctionID == DSBUSID_LEFT)
            {
                m_fIgnorePan = TRUE;
            }
        }
    }

    VREL vrVolumeL;
    VREL vrVolumeR;
    if ( pSynth->m_dwStereo &&
        !pSynth->m_fAllowPanWhilePlayingNote &&
        !m_fIgnorePan)
    {
        long lPan = pPanIn->GetPan(stStartTime) + m_lDefaultPan;

        if (lPan < 0)
            lPan = 0;

        if (lPan > 127)
            lPan = 127;

        vrVolumeL = m_svrPanToVREL[127 - lPan] + vrVolume;
        vrVolumeR = m_svrPanToVREL[lPan] + vrVolume;
    }
    else
    {
        vrVolumeL = vrVolume;
        vrVolumeR = vrVolume;
    }

    VREL vrVolumeReverb = vrVolume;
    VREL vrVolumeChorus = vrVolume;

    PREL prBusPitchBend = 0;  // This gets a pitch offset that is set by DSound in response to SetFrequency and Doppler commands.
                             // When this is applied to multiple buses, only one of the values can be used, so we always give
                             // preference to the buffer that has DSBUSID_DYNAMIC_0 for the functional id, since that
                             // would most likely be a 3D sound effect.
    BOOL fDynamic = false;

    for( DWORD i = 0; i < pBusIds->m_dwBusCount; i++ )
    {
        DWORD dwFunctionID;
        PREL prGetPitch = 0;
        if (m_pSynth->BusIDToFunctionID(pBusIds->m_dwBusIds[i], &dwFunctionID, &prGetPitch, NULL))
        {
            if (!fDynamic)
            {
                // If no previous bus was dynamic, get this value.
                prBusPitchBend = prGetPitch;
            }
            m_vrBaseVolume[i] = MIN_VOLUME;

            if (DSBUSID_IS_SPKR_LOC(dwFunctionID))
            {
                if (pRegion->IsMultiChannel())
                {
                    // Explicit channel assignment with no pan. For every bus
                    // that matches a bit in the channel mask, turn it on.
                    //
                    if (pRegion->m_dwChannel & (1 << dwFunctionID))
                    {
                        m_vrBaseVolume[i] = vrVolume;
                    }
                }
                else
                {
                    switch(dwFunctionID)
                    {
                    case DSBUSID_LEFT:
                        m_vrBaseVolume[i] = vrVolumeL;
                        break;

                    case DSBUSID_RIGHT:
                        m_vrBaseVolume[i] = vrVolumeR;
                        break;
                    }
                }
            }
            else
            {
                // Not a speaker location, a send or a 3D buffer.
                //
                switch(dwFunctionID)
                {
                case DSBUSID_REVERB_SEND:
                    m_vrBaseVolume[i] = vrVolumeReverb;
                    break;

                case DSBUSID_CHORUS_SEND:
                    m_vrBaseVolume[i] = vrVolumeChorus;
                    break;

                case DSBUSID_NULL:
                    m_vrBaseVolume[i] = MIN_VOLUME;
                    break;

                case DSBUSID_DYNAMIC_0:
                    fDynamic = true;
                default:
                    m_vrBaseVolume[i] = vrVolume;
                }
            }

            m_vrLastVolume[i] = MIN_VOLUME;
            m_vfLastVolume[i] = m_DigitalAudio.VRELToVFRACT(MIN_VOLUME);
        }
    }

    m_stMixTime = m_LFO.StartVoice(&pArticulation->m_LFO,
        stStartTime, pModWheelIn, pPressureIn);

    STIME stMixTime = m_LFO2.StartVoice(&pArticulation->m_LFO2,
        stStartTime, pModWheelIn, pPressureIn);
    if (stMixTime < m_stMixTime)
    {
        m_stMixTime = stMixTime;
    }

    stMixTime = m_PitchEG.StartVoice(&pArticulation->m_PitchEG,
        stStartTime, nKey, nVelocity, 0);
    if (stMixTime < m_stMixTime)
    {
        m_stMixTime = stMixTime;
    }

    // Force attack to never be shorter than a millisecond.
    stMixTime = m_VolumeEG.StartVoice(&pArticulation->m_VolumeEG,
        stStartTime, nKey, nVelocity, pSynth->m_dwSampleRate/1000);
    if (stMixTime < m_stMixTime)
    {
        m_stMixTime = stMixTime;
    }

    if (m_stMixTime > pSynth->m_stMaxSpan)
    {
        m_stMixTime = pSynth->m_stMaxSpan;
    }

    m_Filter.StartVoice(&pArticulation->m_Filter,
        &m_LFO, &m_PitchEG, nKey, nVelocity);

    // Make sure we have a pointer to the wave ready:
    if ((pRegion->m_Sample.m_pWave == NULL) || (pRegion->m_Sample.m_pWave->m_pnWave == NULL))
    {
        return (FALSE);     // Do nothing if no sample.
    }

    m_DigitalAudio.StartVoice(pSynth,
                              &pRegion->m_Sample,
                              prPitch,
                              (long)nKey);

    m_pPitchBendIn = pPitchBendIn;
    m_pExpressionIn = pExpressionIn;
    m_pPanIn = pPanIn;
    m_pReverbSend = pReverbSend;
    m_pChorusSend = pChorusSend;
    m_CCutOffFreqIn = pCCutOffFreqIn;
    m_pVolumeIn = pVolumeIn;
    m_BusIds = *pBusIds;
    m_fNoteOn = TRUE;
    m_fTag = FALSE;
    m_fSustainOn = FALSE;
    m_stStartTime = stStartTime;
    m_stLastMix = stStartTime - 1;
    m_stStopTime = 0x7fffffffffffffff;
    m_stWaveStopTime = 0;

    //
    // Zero length attack,
    // be sure initial settings aren't missed....
    //
    if (m_stMixTime == 0)
    {
        PREL  prNewPitch;
        COEFF cfK, cfB1, cfB2;

        GetNewPitch(stStartTime, prNewPitch);
        GetNewCoeff(stStartTime, m_prLastCutOff, cfK, cfB1, cfB2);

        m_DigitalAudio.Mix(NULL,
                           0,
                           0,
                           0,
                           0,
                           NULL,
                           NULL,
                           prNewPitch + prBusPitchBend,
                           m_Filter.IsFiltered(),
                           cfK, cfB1, cfB2);
    }

    m_vrVolume = MAX_VOLUME;

    return (TRUE);
}

BOOL CVoice::StartWave(CSynth *pSynth,
                       CWaveArt *pWaveArt,
                       DWORD dwVoiceId,
                       STIME stStartTime,
                       CPitchBendIn * pPitchBendIn,
                       CExpressionIn * pExpressionIn,
                       CVolumeIn * pVolumeIn,
                       CPanIn * pPanIn,
                       CReverbIn * pReverbSend,
                       CChorusIn * pChorusSend,
                       CCutOffFreqIn * pCCutOffFreqIn,
                       CBusIds * pBusIds,
                       VREL vrVolume,
                       PREL prPitch,
                       SAMPLE_TIME stVoiceStart,
                       SAMPLE_TIME stLoopStart,
                       SAMPLE_TIME stLoopEnd
                       )
{
    m_pSynth = pSynth;

    DWORD dwFuncId = pWaveArt->m_WaveArtDl.ulBus;

    VREL vrVolumeReverb = vrVolume;
    VREL vrVolumeChorus = vrVolume;

    m_fIgnorePan = (BOOL)(DSBUSID_IS_SPKR_LOC(dwFuncId) && (pWaveArt->m_WaveArtDl.usOptions & F_WAVELINK_MULTICHANNEL));
    if (pBusIds->m_dwBusCount == 1)
    {
        DWORD dwFunctionID;
        if (m_pSynth->BusIDToFunctionID(pBusIds->m_dwBusIds[0], &dwFunctionID, NULL, NULL))
        {
            if (dwFunctionID == DSBUSID_LEFT)
            {
                m_fIgnorePan = TRUE;
            }
        }
    }

    for( DWORD i = 0; i < pBusIds->m_dwBusCount; i++ )
    {
        m_vrBaseVolume[i] = MIN_VOLUME;

        DWORD dwFunctionID;
        if (m_pSynth->BusIDToFunctionID(pBusIds->m_dwBusIds[i], &dwFunctionID, NULL, NULL))
        {
            // If this bus is a speaker location
            //
            if (DSBUSID_IS_SPKR_LOC(dwFunctionID))
            {
                if (pWaveArt->m_WaveArtDl.usOptions & F_WAVELINK_MULTICHANNEL)
                {
                    if (dwFuncId == dwFunctionID)
                    {
                        m_vrBaseVolume[i] = vrVolume;
                    }
                }
                else
                {
                    if (dwFunctionID == DSBUSID_LEFT || dwFunctionID == DSBUSID_RIGHT)
                    {
                        m_vrBaseVolume[i] = vrVolume;
                    }
                }
            }
            else switch (dwFunctionID)
            {
            case DSBUSID_REVERB_SEND:
                m_vrBaseVolume[i] = vrVolumeReverb;
                break;

            case DSBUSID_CHORUS_SEND:
                m_vrBaseVolume[i] = vrVolumeChorus;
                break;

            case DSBUSID_NULL:
                m_vrBaseVolume[i] = MIN_VOLUME;
                break;

            default:
                m_vrBaseVolume[i] = vrVolume;
            }

            m_vrLastVolume[i] = MIN_VOLUME;
            m_vfLastVolume[i] = m_DigitalAudio.VRELToVFRACT(MIN_VOLUME);
        }
    }

    // Initialize an envelope for wave playing
    //
    CSourceEG WaveVolumeEG;
    WaveVolumeEG.Init();
    WaveVolumeEG.m_pcSustain = 1000;
    // Force the envelope attack and release to be no smaller than 4ms. This ensures we won't get
    // clicks if we start and stop at non-zero crossings.
    m_stMixTime = m_VolumeEG.StartVoice(&WaveVolumeEG, stStartTime, 0, 0, pSynth->m_dwSampleRate/250);
    if (m_stMixTime > pSynth->m_stMaxSpan)
    {
        m_stMixTime = pSynth->m_stMaxSpan;
    }

    m_pPitchBendIn = pPitchBendIn;
    m_pExpressionIn = pExpressionIn;
    m_pPanIn = pPanIn;
    m_pReverbSend = pReverbSend;
    m_pChorusSend = pChorusSend;
    m_CCutOffFreqIn = pCCutOffFreqIn;
    m_pVolumeIn = pVolumeIn;
    m_BusIds = *pBusIds;
    m_fNoteOn = TRUE;
    m_fTag = FALSE;
    m_stStartTime = stStartTime;
    m_stLastMix = stStartTime - 1;
    m_stStopTime = 0x7fffffffffffffff;
    m_stWaveStopTime = 0;
    m_dwGroup = 0;
    m_lDefaultPan = 0;
    m_vrVolume = 0;
    m_fAllowOverlap = FALSE;
    m_fSustainOn = FALSE;
    m_dwVoiceId = dwVoiceId;

    m_LFO.Enable(FALSE);             // Disable LFO.
    m_LFO2.Enable(FALSE);            // Disable LFO2.
    m_PitchEG.Enable(FALSE);         // Disable Pitch Envelope.
    m_Filter.m_Source.m_prCutoff = 0x7FFF;

    m_DigitalAudio.StartWave(pSynth,
                             pWaveArt,
                             prPitch,
                             stVoiceStart,
                             stLoopStart,
                             stLoopEnd);

    return (TRUE);
}

SAMPLE_POSITION CVoice::GetCurrentPos()
{
    return m_DigitalAudio.GetCurrentPos();
}

void CVoice::ClearVoice()
{
    m_fInUse = FALSE;
    m_DigitalAudio.ClearVoice();
}

// return the volume delta at time <stTime>.
// volume is sum of volume envelope, LFO, expression, optionally the
// channel volume if we're allowing it to change, and optionally the current
// pan if we're allowing that to change.
// This will be added to the base volume calculated in CVoice::StartVoice().
inline void CVoice::GetNewVolume(STIME stTime, VREL& vrVolume, VREL& vrVolumeL, VREL& vrVolumeR, VREL& vrVolumeReverb, VREL& vrVolumeChorus)
{
    STIME stMixTime = m_stMixTime;

    //
    // the evelope volume is used by code that detects whether this note is off
    // and for voice stealing
    //
    m_vrVolume = m_VolumeEG.GetVolume(stTime, &stMixTime);
    if (stMixTime < m_stMixTime)
        m_stMixTime = stMixTime;

    vrVolume = m_vrVolume;
    vrVolume += m_LFO.GetVolume(stTime, &stMixTime);
    if (stMixTime < m_stMixTime)
        m_stMixTime = stMixTime;

    vrVolume += m_pExpressionIn->GetVolume(stTime);

    if (m_pSynth->m_fAllowVolumeChangeWhilePlayingNote)
        vrVolume += m_pVolumeIn->GetVolume(stTime);

    vrVolume += m_pSynth->m_vrGainAdjust;

    // handle pan here if allowing pan to vary after note starts
    vrVolumeL = vrVolume;
    vrVolumeR = vrVolume;
    if (m_pSynth->m_dwStereo && m_pSynth->m_fAllowPanWhilePlayingNote && !m_fIgnorePan)
    {
        // add current pan & instrument default pan
        LONG lPan;

        if (m_pPanIn)
        {
            lPan = m_pPanIn->GetPan(stTime) + m_lDefaultPan;
        }
        else
        {
            lPan = 63;
        }

        // don't go off either end....
        if (lPan < 0) lPan = 0;
        if (lPan > 127) lPan = 127;
        vrVolumeL += m_svrPanToVREL[127 - lPan];
        vrVolumeR += m_svrPanToVREL[lPan];
    }
    // Get Reverb Send volume
    vrVolumeReverb  = vrVolume + m_pReverbSend->GetVolume(stTime);
    // Get Chorus Send volume
    vrVolumeChorus  = vrVolume + m_pChorusSend->GetVolume(stTime);
}

// Returns the current pitch for time <stTime>.
// Pitch is the sum of the pitch LFO, the pitch envelope, and the current
// pitch bend.
inline void CVoice::GetNewPitch(STIME stTime, PREL& prPitch)
{
    STIME stMixTime = m_stMixTime;

    prPitch = m_LFO.GetPitch(stTime, &stMixTime);
    if (m_stMixTime > stMixTime) m_stMixTime = stMixTime;

    prPitch += m_LFO2.GetPitch(stTime, &stMixTime);
    if (m_stMixTime > stMixTime) m_stMixTime = stMixTime;

    prPitch += m_PitchEG.GetPitch(stTime, &stMixTime);
    if (m_stMixTime > stMixTime) m_stMixTime = stMixTime;

    prPitch += m_pPitchBendIn->GetPitch(stTime);
}

// Returns the current cutoff frequency for time <stTime>.
// cutoff frequency is the sum of the pitch LFO, the pitch envelope, and the current
// MIDI filter CC control.
inline void CVoice::GetNewCoeff(STIME stTime, PREL& prCutOff, COEFF& cfK, COEFF& cfB1, COEFF& cfB2)
{

    DWORD dwfreq;

    // returned frequency is in semitones, where 64 is the mid range
    dwfreq = m_CCutOffFreqIn->GetFrequency(stTime);
    prCutOff = (dwfreq - 64)*100;   // convert to PREL's

    m_Filter.GetCoeff(stTime, prCutOff, cfK, cfB1, cfB2);
}

DWORD CVoice::Mix(short **ppvBuffer,
                  DWORD dwBufferFlags,
                  DWORD dwLength,
                  STIME stStart,
                  STIME stEnd)

{
    BOOL   fInUse    = TRUE;
    BOOL   fFullMix   = TRUE;
    STIME  stEndMix   = stStart;
    STIME  stStartMix = m_stStartTime;
    COEFF  cfK, cfB1, cfB2;
    PREL   prPitch;
    PREL   prCutOff;
    VREL   vrVolume, vrVolumeL, vrVolumeR;
    VREL   vrVolumeReverb, vrVolumeChorus;
    VREL   vrMaxVolumeDelta;
    VFRACT vfNewVolume[MAX_DAUD_CHAN];
    VFRACT vfLastVolume[MAX_DAUD_CHAN];
    short  *ppsMixBuffers[MAX_DAUD_CHAN];

    if (stStartMix < stStart)
    {
        stStartMix = stStart;
    }

    if (m_stLastMix >= stEnd)
    {
        return (0);
    }

    if (m_stLastMix >= stStartMix)
    {
        stStartMix = m_stLastMix;
    }

    while (stStartMix < stEnd && fInUse)
    {
        stEndMix = stStartMix + m_stMixTime;
        if (stEndMix > stEnd)
        {
            stEndMix = stEnd;
        }

        m_stMixTime = m_pSynth->m_stMaxSpan;
        if ((m_stLastMix < m_stStopTime) && (m_stStopTime < stEnd))
        {
            if (m_stMixTime > (m_stStopTime - m_stLastMix))
            {
                m_stMixTime = m_stStopTime - m_stLastMix;
            }
        }

        //
        // Get the new pitch
        //
        GetNewPitch(stEndMix, prPitch);

        //
        // Get the new volume
        //
        GetNewVolume(stEndMix, vrVolume, vrVolumeL, vrVolumeR, vrVolumeReverb, vrVolumeChorus);

        //
        // Get the new filter coeficients
        //
        GetNewCoeff(stEndMix, prCutOff, cfK, cfB1, cfB2);

        //
        // Check to see if the volume is precievable, if not kill voice
        //
        if (m_VolumeEG.InRelease(stEndMix))
        {
            if (m_vrVolume < PERCEIVED_MIN_VOLUME) // End of release slope
            {
                // Breaking the loop ensures that the mixmulti functions don't mix any more samples
                // for looped wave Without this the mix engine will mix a few more samples for
                // looped waves resulting in a pop at the end of the wave.
                m_DigitalAudio.BreakLoop();
                fInUse = FALSE;
            }
        }

        vrMaxVolumeDelta = 0;
        vfNewVolume[0]   = 0;
        ppsMixBuffers[0] = NULL;
        DWORD dwMixBufferCount = 0;
        PREL prBusPitchBend = 0;  // This gets a pitch offset that is set by DSound in response to SetFrequency and Doppler commands.
                                 // When this is applied to multiple buses, only one of the values can be used, so we always give
                                 // preference to the buffer that has DSBUSID_DYNAMIC_0 for the functional id, since that
                                 // would most likely be a 3D sound effect.
        BOOL fDynamic = false;

        if (dwBufferFlags & BUFFERFLAG_MULTIBUFFER)
        {
            // Iterate through each bus id in the voice, assigning a sink bus to each one.
            for ( DWORD nBusID = 0; nBusID < m_BusIds.m_dwBusCount; nBusID++ )
            {
                DWORD dwFunctionalID;
                DWORD dwBusIndex;
                PREL prGetPitch;

                if (m_pSynth->BusIDToFunctionID(m_BusIds.m_dwBusIds[nBusID], &dwFunctionalID, &prGetPitch, &dwBusIndex))
                {
                    if (!fDynamic)
                    {
                        // If no previous bus was dynamic, get this value.
                        prBusPitchBend = prGetPitch;
                    }
                    // Default to original volume (before pan, reverb or chorus modifiers.)
                    VREL vrTemp = vrVolume;
                    // Replace for any of the other cases (left, right, reverb, chorus.)
                    if ( dwFunctionalID == DSBUSID_NULL )
                    {
                        continue;
                    }
                    if ( dwFunctionalID == DSBUSID_LEFT )
                    {
                        vrTemp = vrVolumeL;
                    }
                    if ( dwFunctionalID == DSBUSID_RIGHT )
                    {
                        vrTemp = vrVolumeR;
                    }
                    else if ( dwFunctionalID == DSBUSID_REVERB_SEND )
                    {
                        vrTemp = vrVolumeReverb;
                    }
                    else if ( dwFunctionalID == DSBUSID_CHORUS_SEND )
                    {
                        vrTemp = vrVolumeChorus;
                    }
                    else if ( dwFunctionalID == DSBUSID_DYNAMIC_0 )
                    {
                        fDynamic = true;
                    }

                    vrMaxVolumeDelta = max((long)vrMaxVolumeDelta, abs(vrTemp - m_vrLastVolume[nBusID]));
                    m_vrLastVolume[nBusID] = vrTemp;

                    vrTemp += m_vrBaseVolume[nBusID];
                    vfNewVolume[dwMixBufferCount]  = m_DigitalAudio.VRELToVFRACT(vrTemp);
                    vfLastVolume[dwMixBufferCount] = m_vfLastVolume[nBusID];
                    m_vfLastVolume[nBusID] = vfNewVolume[dwMixBufferCount];
                    ppsMixBuffers[dwMixBufferCount] = &ppvBuffer[dwBusIndex][(stStartMix - stStart)];
                    dwMixBufferCount++;
                }
            }
        }
        else
        {
            // This is the DX7 compatibility case.
            vrMaxVolumeDelta = max((long)vrMaxVolumeDelta, abs(vrVolumeL - m_vrLastVolume[0]));
            m_vrLastVolume[0] = vrVolumeL;
            vfNewVolume[0]  = m_DigitalAudio.VRELToVFRACT(m_vrBaseVolume[0] + vrVolumeL);
            vfLastVolume[0] = m_vfLastVolume[0];
            m_vfLastVolume[0] = vfNewVolume[0];
            dwMixBufferCount = 1;
            if ( dwBufferFlags & BUFFERFLAG_INTERLEAVED )   // Is this a stereo buffer?
            {
                vrMaxVolumeDelta = max((long)vrMaxVolumeDelta, abs(vrVolumeR - m_vrLastVolume[1]));
                m_vrLastVolume[1] = vrVolumeR;
                vfNewVolume[1]  = m_DigitalAudio.VRELToVFRACT(m_vrBaseVolume[1] + vrVolumeR);
                vfLastVolume[1] = m_vfLastVolume[1];
                m_vfLastVolume[1] = vfNewVolume[1];
                ppsMixBuffers[0] = &ppvBuffer[0][(stStartMix - stStart) << 1];
            }
            else    // Or mono?
            {
                ppsMixBuffers[0] = &ppvBuffer[0][(stStartMix - stStart)];
            }
        }
        // If dwMixBufferCount is 0, this indicates there is no buffer available to play into.
        // This is caused by a buffer being deactivated. Under such circumstances, the
        // voice should not continue playing, or it will hold until the buffer reactivates, which
        // doesn't make sense. So, set fInUse to FALSE.
        if (dwMixBufferCount)
        {
            DWORD dwIsFiltered = m_Filter.IsFiltered();
            if (dwIsFiltered)
            {
                vrMaxVolumeDelta = max((long)vrMaxVolumeDelta, abs(prCutOff - m_prLastCutOff));
                m_prLastCutOff = prCutOff;
            }


            //
            // note: mix will in some cases modify the pointers found ppsMixBuffers array
            //
            fFullMix = m_DigitalAudio.Mix(ppsMixBuffers,                    // Array of mix buffers
                                          dwMixBufferCount,                 // Number of mix buffers
                                          (dwBufferFlags & BUFFERFLAG_INTERLEAVED), // Are the buffers interleaved data?
                                          (DWORD) (stEndMix - stStartMix),  // Length to mix in Samples
                                          vrMaxVolumeDelta,                 //
                                          vfNewVolume,
                                          vfLastVolume,
                                          prPitch + prBusPitchBend,         // Pitch to play the sample too
                                          dwIsFiltered,         // Is the mix filtered
                                          cfK, cfB1, cfB2);
            stStartMix = stEndMix;
        }
        else
        {
            fInUse = FALSE;
        }
    }

    m_fInUse = fInUse && fFullMix;
    if (!m_fInUse)
    {
        ClearVoice();
        m_stStopTime = stEndMix;    // For measurement purposes.
    }

    m_stLastMix = stEndMix;

    return (dwLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\duration.cpp ===
// Duration.cpp : Implementation of CDurationTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "duration.h"
#include "toolhelp.h"


CDurationTool::CDurationTool()
{
    ParamInfo Params[DMUS_DURATION_PARAMCOUNT] = 
    {
        { DMUS_DURATION_SCALE, MPT_INT,MP_CAPS_ALL,0,8,1,
            L"Times",L"Scale",NULL},        // Scale - default to 1 (no change)
    };
    InitParams(DMUS_DURATION_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CDurationTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CDurationTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CDurationTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicDurationTool)
	{
		*ppv = static_cast<IDirectMusicDurationTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CDurationTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicDurationTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CDurationTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CDurationTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_DURATION_CHUNK))
	{
        DMUS_IO_DURATION_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_DURATION_SCALE,(float) Header.flScale);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CDurationTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_DURATION_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_DURATION_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_DURATION_HEADER Header;
        GetParamFloat(DMUS_DURATION_SCALE,MAX_REF_TIME,&Header.flScale);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CDurationTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_DURATION_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CDurationTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_DurationPage;
	return NOERROR;
}


/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CDurationTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // Only adjust the durations of notes. 
    if( pPMsg->dwType == DMUS_PMSGT_NOTE ) 
    {
        REFERENCE_TIME rtTime;
        if (m_fMusicTime) rtTime = pPMsg->mtTime;
        else rtTime = pPMsg->rtTime;
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        float flScale;

        GetParamFloat(DMUS_DURATION_SCALE,rtTime,&flScale);
        if (flScale >= 0)
        {
            flScale *= pNote->mtDuration;
            pNote->mtDuration = (MUSIC_TIME) flScale;
        }
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CDurationTool::Clone( IDirectMusicTool ** ppTool)

{
    CDurationTool *pNew = new CDurationTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CDurationTool::SetScale(float flScale) 
{
    return SetParam(DMUS_DURATION_SCALE,flScale);
}

STDMETHODIMP CDurationTool::GetScale(float * pflScale) 
{
    return GetParamFloat(DMUS_DURATION_SCALE,MAX_REF_TIME, pflScale);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\duration.h ===
#ifndef _DURATION_TOOL_
#define _DURATION_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "..\dmtoolprp\toolprops.h"

class CDurationTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicDurationTool

{
public:
	CDurationTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicDurationTool
	STDMETHODIMP SetScale(float flScale) ;
	STDMETHODIMP GetScale(float * pflScale);
};

#endif // _DURATION_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\dmobase.h ===
// dmobase.h - a collection of DMO base classes

// Current hierarchy:
//
//   IMediaObject
//   |
//   +-- C1in1outDMO - generic base class for DMOs with 1 in and 1 out
//   |   |
//   |   +-- FBRDMO - base class for fixed sample size, fixed bitrate DMOs
//   |   |   |
//   |   |   +-- CPCMDMO - base class for PCM audio DMOs
//   |   |
//   |   +-- C1for1 - base class for single sample per buffer 1-in/1-out DMOs
//   |
//   +-- CGenericDMO - resonably generic base class for multi-input/output DMOs
// 

#ifndef __DMOBASE_H_
#define __DMOBASE_H_

#include "dmo.h"
#include "assert.h"
#include "math.h"

//
// locking helper class
//
#ifdef DMO_NOATL
class CDMOAutoLock {
public:
   CDMOAutoLock(CRITICAL_SECTION* pcs)
      : m_pcs(pcs)
   {
      EnterCriticalSection(m_pcs);
   }
   ~CDMOAutoLock() {
      LeaveCriticalSection(m_pcs);
   }
private:
   CRITICAL_SECTION* m_pcs;
};
#else
class CDMOAutoLock {
public:
   CDMOAutoLock(CComAutoCriticalSection* pcs)
      : m_pcs(pcs)
   {
      m_pcs->Lock();
   }
   ~CDMOAutoLock() {
      m_pcs->Unlock();
   }
private:
   CComAutoCriticalSection* m_pcs;
};
#endif


//
// C1in1outDMO - generic base class for 1-input/1-output DMOs.
//
//
//
// C1in1outDMO implements all IMediaObject methods.  The derived class
// customizes the DMO's behavior by overriding some or all of the following
// virtual functions:
//
// Main Streaming:
//    AcceptInput          // accept one new input buffer
//    ProduceOutput        // fill up one output buffer with new data
//    AcceptingInput       // check if DMO is ready for new input
// Other streaming:
//    PrepareForStreaming  // hook called after both types have been set
//    Discontinuity        // notify DMO of a discontinuity
//    DoFlush              // discard all data and start anew
// Mediatype negotiation:
//    GetInputType         // input type enumerator
//    GetOutputType        // output type enumerator
//    CheckInputType       // verifies proposed input type is acceptable
//    CheckOutputType      // verifies proposed output type is acceptable
// Buffer size negotiation:
//    GetInputFlags        // input data flow flags
//    GetOutputFlags       // output fata flow flags
//    GetInputSizeInfo     // input buffer size requirements
//    GetOutputSizeInfo    // output buffer size requirements
//
// This base class assumes that the derived class will not override any
// IMediaObject methods directly - the derived class should override the
// methods listed above instead.
//
//
//
// The base class provides a default implementation for each of the
// overridables listed above.  However, to make a useful DMO the derived class
// probably needs to override at least the following two methods:
//
//    HRESULT AcceptingInput();
//    HRESULT AcceptInput(BYTE* pData,
//                        ULONG ulSize,
//                        DWORD dwFlags,
//                        REFERENCE_TIME rtTimestamp,
//                        REFERENCE_TIME rtTimelength,
//                        IMediaBuffer* pMediaBuffer);
//    HRESULT ProduceOutput(BYTE *pData,
//                        ULONG ulAvail,
//                        ULONG* pulUsed,
//                        DWORD* pdwStatus,
//                        REFERENCE_TIME *prtTimestamp,
//                        REFERENCE_TIME *prtTimelength);
//
// All good DMOs should also override these (the default implementation
// simply accepts any mediatype, which in general is not good DMO behavior):
//
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
//
// DMOs that store data and/or state information may need to implement
//
//    HRESULT PrepareForStreaming();
//    HRESULT Discontinuity();
//    HRESULT Flush();
//
// Finally, DMOs that make any buffer size assumptions will need to override
// these:
//
//    HRESULT GetInputFlags(DWORD* pdwFlags);
//    HRESULT GetOutputFlags(DWORD* pdwFlags);
//    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment);
//    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment);
//
//
//
// The following functions are provided by this base class exclusively for use
// by the derived class.  The derived class should call these to find out the
// currently set mediatype(s) whenever it needs to make a decision that
// depends on the mediatype used.  Each of these returns NULL if the mediatype
// has not been set yet.
//
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//

#define PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulStreamIndex >= 1) \
       return DMO_E_INVALIDSTREAMINDEX

class C1in1outDMO : public IMediaObject
{
public:
    C1in1outDMO() :
       m_bInputTypeSet(FALSE),
       m_bOutputTypeSet(FALSE),
       m_bIncomplete(FALSE)
    {
#ifdef DMO_NOATL
       InitializeCriticalSection(&m_cs);
#endif
    }
    ~C1in1outDMO() {
#ifdef DMO_NOATL
       DeleteCriticalSection(&m_cs);
#endif
    }

public:    
    //
    // IMediaObject methods
    //
    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        CDMOAutoLock l(&m_cs);
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams = 1;
        *pulNumberOfOutputStreams = 1;
        return S_OK;
    }
    STDMETHODIMP GetInputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
       PROLOGUE;
       return GetInputFlags(pdwFlags);
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
       PROLOGUE;
       return GetOutputFlags(pdwFlags);
    }
    STDMETHODIMP GetInputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       return GetInputType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       return GetOutputType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       if (m_bInputTypeSet)
          return MoCopyMediaType(pmt, &m_InputType);
       else
          return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       if (m_bOutputTypeSet)
          return MoCopyMediaType(pmt, &m_OutputType);
       else
          return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       PROLOGUE;
       if (!m_bInputTypeSet)
          return DMO_E_TYPE_NOT_SET;
       return GetInputSizeInfo(pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {
       PROLOGUE;
       if (!m_bOutputTypeSet)
          return DMO_E_TYPE_NOT_SET;
       return GetOutputSizeInfo(pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       PROLOGUE;
       HRESULT hr = CheckInputType(pmt);
       if (FAILED(hr))
          return hr;

       if (dwFlags & DMO_SET_TYPEF_TEST_ONLY)
          return NOERROR;

       // Free any previous mediatype
       if (m_bInputTypeSet)
          MoFreeMediaType(&m_InputType);

       // actually set the type
       MoCopyMediaType(&m_InputType, pmt);
       m_bInputTypeSet = TRUE;

       if (m_bOutputTypeSet)
          PrepareForStreaming();
       return NOERROR;
    }
    STDMETHODIMP SetOutputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       PROLOGUE;
       HRESULT hr = CheckOutputType(pmt);
       if (FAILED(hr))
          return hr;

       if (dwFlags & DMO_SET_TYPEF_TEST_ONLY)
          return NOERROR;

       // Free any previous mediatype
       if (m_bOutputTypeSet)
          MoFreeMediaType(&m_OutputType);

       // actually set the type
       MoCopyMediaType(&m_OutputType, pmt);
       m_bOutputTypeSet = TRUE;

       if (m_bInputTypeSet)
          PrepareForStreaming();
       return NOERROR;
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulStreamIndex,
        DWORD *pdwStatus
    ) {
       PROLOGUE;
       *pdwStatus = 0;
       if (AcceptingInput() == S_OK)
          *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
       return NOERROR;

    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME *prtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME rtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP Discontinuity(ULONG ulStreamIndex) {
       PROLOGUE;
       return Discontinuity();
    }

    STDMETHODIMP Flush()
    {
       CDMOAutoLock l(&m_cs);
       DoFlush();
       return NOERROR;
    }
    STDMETHODIMP AllocateStreamingResources() {return S_OK;}
    STDMETHODIMP FreeStreamingResources() {return S_OK;}
    
    //
    // Processing methods - public entry points
    //
    STDMETHODIMP ProcessInput(
        DWORD ulStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
       PROLOGUE;
       if (AcceptingInput() != S_OK)
          return DMO_E_NOTACCEPTING;
       if (!pBuffer)
          return E_POINTER;

       // deal with the IMediaBuffer so the derived class doesn't have to
       BYTE *pData;
       ULONG ulSize;
       HRESULT hr = pBuffer->GetBufferAndLength(&pData, &ulSize);
       if (FAILED(hr))
          return hr;
       if (pData == NULL)
          ulSize = 0;

       m_bIncomplete = TRUE; // new input means we may be able to produce output

       return AcceptInput(pData, ulSize, dwFlags, rtTimestamp, rtTimelength, pBuffer);
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwReserved,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
       HRESULT hr;
       CDMOAutoLock l(&m_cs);
       
       if (ulOutputBufferCount != 1)
          return E_INVALIDARG;

       pOutputBuffers[0].dwStatus = 0;

       // deal with the IMediaBuffer so the derived class doesn't have to
       BYTE *pOut;
       ULONG ulSize;
       ULONG ulAvail;

       if (pOutputBuffers[0].pBuffer) {
          hr = pOutputBuffers[0].pBuffer->GetBufferAndLength(&pOut, &ulSize);
          if (FAILED(hr)) return hr;
          hr = pOutputBuffers[0].pBuffer->GetMaxLength(&ulAvail);
          if (FAILED(hr)) return hr;
   
          if (ulSize) { // skip any already used portion of the buffer
             if (ulSize > ulAvail)
                return E_INVALIDARG;
             ulAvail -= ulSize;
             pOut += ulSize;
          }
       }
       else
          ulAvail = 0;

       if (ulAvail) { // have output buffer - call process
          ULONG ulProduced = 0;
          hr = ProduceOutput(pOut,
                             ulAvail,
                             &ulProduced,
                             &(pOutputBuffers[0].dwStatus),
                             &(pOutputBuffers[0].rtTimestamp),
                             &(pOutputBuffers[0].rtTimelength));
          if (FAILED(hr))
             return hr;

          HRESULT hrProcess = hr; // remember this in case it's S_FALSE

          // remember the DMO's incomplete status
          if (pOutputBuffers[0].dwStatus | DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE)
             m_bIncomplete = TRUE;
          else
             m_bIncomplete = FALSE;

          if (ulProduced > ulAvail)
             return E_FAIL;

          hr = pOutputBuffers[0].pBuffer->SetLength(ulSize + ulProduced);
          if (FAILED(hr))
             return hr;

          return hrProcess;
       }
       else { // no output buffer - assume they just want the incomplete flag
          if (m_bIncomplete)
             pOutputBuffers[0].dwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;
          return NOERROR;
       }
    }
    
protected:
    //
    // private methods for use by derived class
    //
    DMO_MEDIA_TYPE *InputType() {
       if (m_bInputTypeSet)
          return &m_InputType;
       else
          return NULL;
    }
    DMO_MEDIA_TYPE *OutputType() {
       if (m_bOutputTypeSet)
          return &m_OutputType;
       else
          return NULL;
    }

protected:    
    //
    // To be overriden by the derived class
    //
    virtual HRESULT GetInputFlags(DWORD* pdwFlags) {
       *pdwFlags = 0; // default implementation assumes no lookahead
       return NOERROR;
    }
    virtual HRESULT GetOutputFlags(DWORD* pdwFlags) {
       *pdwFlags = 0;
       return NOERROR;
    }
    
    virtual HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       return DMO_E_NO_MORE_ITEMS; // default implementation exposes no types
    }
    virtual HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       return DMO_E_NO_MORE_ITEMS; // default implementation exposes no types
    }
    virtual HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
       if ((pmt == NULL) || ((pmt->cbFormat > 0) && (pmt->pbFormat == NULL)))
          return E_POINTER;
       return S_OK; // default implementation accepts anything
    }
    virtual HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt) {
       if ((pmt == NULL) || ((pmt->cbFormat > 0) && (pmt->pbFormat == NULL)))
          return E_POINTER;
       return S_OK; // default implementation accepts anything
    }

    virtual HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       *pulSize = 1; // default implementation imposes no size requirements
       *pcbMaxLookahead = 0; // default implementation assumes no lookahead
       *pulAlignment = 1; // default implementation assumes no alignment
       return NOERROR;
    }
    virtual HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       *pulSize = 1; // default implementation imposes no size requirements
       *pulAlignment = 1; // default implementation assumes no alignment
       return NOERROR;
    }

    virtual HRESULT PrepareForStreaming() {
       return NOERROR;
    }
    virtual HRESULT AcceptingInput() {
       return S_FALSE;
    }
    virtual HRESULT Discontinuity() {
       return NOERROR;
    }
    virtual HRESULT DoFlush() {
       return NOERROR;
    }

    virtual HRESULT AcceptInput(BYTE* pData,
                                ULONG ulSize,
                                DWORD dwFlags,
                                REFERENCE_TIME rtTimestamp,
                                REFERENCE_TIME rtTimelength,
                                IMediaBuffer* pMediaBuffer
    ) {
       m_bIncomplete = FALSE;
       return S_FALSE;
    }
    virtual HRESULT ProduceOutput(BYTE *pData,
                                  ULONG ulAvail,
                                  ULONG* pulUsed,
                                  DWORD* pdwStatus,
                                  REFERENCE_TIME *prtTimestamp,
                                  REFERENCE_TIME *prtTimelength
    ) {
       *pulUsed = 0;
       return S_FALSE;
    }

private:
    // mediatype stuff
    BOOL m_bInputTypeSet;
    BOOL m_bOutputTypeSet;
    DMO_MEDIA_TYPE m_InputType;
    DMO_MEDIA_TYPE m_OutputType;
    
    BOOL m_bIncomplete;
#ifdef DMO_NOATL
    CRITICAL_SECTION m_cs;
#else
    CComAutoCriticalSection m_cs;
#endif
};



//
// C1for1DMO - base class for 1-input/1-output DMOs which
//  - work on whole samples at a time, one sample per buffer
//  - produce exactly one output sample for every input sample
//  - don't need to accumulate more than 1 input sample before producing
//  - don't produce any additional stuff at the end
//  - the output sample corresponds in time to the input sample
//
// The derived class must implement:
//    HRESULT Process(BYTE* pIn,
//                    ULONG ulBytesIn,
//                    BYTE* pOut,
//                    ULONG* pulProduced);
//    HRESULT GetSampleSizes(ULONG* pulMaxInputSampleSize,
//                           ULONG* pulMaxOutputSampleSize);
//
//
// The derived class should implement:
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
//
// The derived class may implement if it needs to:
//    HRESULT Init();
//
// The following methods are implemented by the base class.  The derived class
// should call these to find out if the input/output type has been set and if
// so what it was set to.
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//

class C1for1DMO : public C1in1outDMO
{
public:
    C1for1DMO() :
       m_pBuffer(NULL)
    {
    }
    ~C1for1DMO() {
       if (m_pBuffer)
          m_pBuffer->Release();
    }

protected:
    //
    // Implement C1in1outDMO overridables
    //
    virtual HRESULT GetInputFlags(DWORD* pdwFlags) {
       *pdwFlags = DMO_INPUT_STREAMF_WHOLE_SAMPLES |
                   DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
       return NOERROR;
    }
    virtual HRESULT GetOutputFlags(DWORD* pdwFlags) {
       *pdwFlags = DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                   DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
       return NOERROR;
    }
    
    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;
       
       *pulSize = m_ulMaxInputSize;
       *pcbMaxLookahead = 0;
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;
       
       *pulSize = m_ulMaxOutputSize;
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT PrepareForStreaming() {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;

       return Init();
    }
    HRESULT AcceptingInput() {
       return m_pBuffer ? S_FALSE : S_OK; // accept unless holding one already
    }
    HRESULT AcceptInput(BYTE* pData,
                        ULONG ulSize,
                        DWORD dwFlags,
                        REFERENCE_TIME rtTimestamp,
                        REFERENCE_TIME rtTimelength,
                        IMediaBuffer* pMediaBuffer
    ) {
       if (AcceptingInput() != S_OK)
          return E_FAIL;
       m_pData        = pData;
       m_ulSize       = ulSize;
       m_dwFlags      = dwFlags;
       m_rtTimestamp  = rtTimestamp;
       m_rtTimelength = rtTimelength;
       m_pBuffer      = pMediaBuffer;
       pMediaBuffer->AddRef();
       return NOERROR;
    }
    HRESULT DoFlush() {
       if (m_pBuffer) {
          m_pBuffer->Release();
          m_pBuffer = NULL;
       }
       return NOERROR;
    }
    HRESULT ProduceOutput(BYTE *pOut,
                          ULONG ulAvail,
                          ULONG* pulUsed,
                          DWORD* pdwStatus,
                          REFERENCE_TIME *prtTimestamp,
                          REFERENCE_TIME *prtTimelength
    ) {
       *pulUsed = 0;
       *pdwStatus = 0;

       if (!m_pBuffer)
          return S_FALSE;
       if (ulAvail < m_ulMaxOutputSize)
          return E_INVALIDARG;

       HRESULT hr = Process(m_pData,
                            m_ulSize,
                            pOut,
                            pulUsed);
       
       m_pBuffer->Release();
       m_pBuffer = NULL;

       if (FAILED(hr))
          return hr;

       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_SYNCPOINT)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_TIME)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_TIME;
       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_TIMELENGTH)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
       *prtTimestamp = m_rtTimestamp;
       *prtTimelength = m_rtTimelength;

       if (*pulUsed == 0)
          return S_FALSE;
       return hr;
    }
protected:
    //
    // To be implemented by derived class
    //
    virtual HRESULT Process(BYTE* pIn,
                            ULONG ulBytesIn,
                            BYTE* pOut,
                            ULONG* pulProduced) = 0;
    virtual HRESULT GetSampleSizes(ULONG* pulMaxInputSampleSize,
                                   ULONG* pulMaxOutputSampleSize) = 0;
    virtual HRESULT Init() {return NOERROR;}

private:
   IMediaBuffer* m_pBuffer;
   BYTE* m_pData;
   ULONG m_ulSize;
   DWORD m_dwFlags;
   REFERENCE_TIME m_rtTimestamp;
   REFERENCE_TIME m_rtTimelength;

   ULONG m_ulMaxOutputSize;
   ULONG m_ulMaxInputSize;
};


//
// CFBRDMO - DMO base class for 'fixed bitrate' DMOs.  More specifically,
// this base class assumes the following:
//  - 1 input, 1 output;
//  - both input and output consist of equally sized 'quanta';
//  - input/output quantum sizes can be determined from mediatypes;
//  - each output quantum can be generated independently (without looking at
//     previous output quanta);
//  - if multiple input quanta are needed to generate a particular output
//     quantum ('window overhead'), then the range of input required has an upper
//     bound derived from mediatypes on both sides (i.e., both 'lookahead'
//     and 'input memory' are bounded).
//
// The derived class must implement the following virtual functions:
//    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
//    HRESULT GetStreamingParams(
//       DWORD *pdwInputQuantumSize, // in bytes
//       DWORD *pdwOutputQuantumSize, // in bytes
//       DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
//       DWORD *pdwLookBehind,
//       REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
//       REFERENCE_TIME *prtDurationDenominator // optional, normally 1
//    );
// The derived class should also implement the following:
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
// The derived class may need to implement the followng:
//    HRESULT Init();
//    HRESULT Discontinuity();
//
// The derived class may use these entry points into the base class to get
// the currently set mediatypes:
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//
// The sum of *pdwMaxLookahead and *pdwLoookbehind is the 'window overhead' of
// the algorithm (the window overhead is 0 if the algorithm only needs the
// current input sample).
//
// Because the non-zero window overhead case is more complicated, it is handled by a
// separate set of functions in this base class.  The names of all non-zero
// window overhead functions have the 'NZWO' prefix.  The names of the
// zero window overhead functions begin with 'ZWO'.
//
// A data copy on the input side is necessary in the non-zero window overhead case.
//

class CFBRDMO : public C1in1outDMO
{
public:
    CFBRDMO() :
       m_bParametersSet(FALSE),
       m_pMediaBuffer(NULL),
       m_pAllocAddr(NULL),
       m_bStreaming(FALSE)
    {
    }
    ~CFBRDMO() {
       /*
       if (m_bStreaming)
          StopStreaming();
       */
       if (m_pAllocAddr)
          delete[] m_pAllocAddr;
       if (m_pMediaBuffer)
          m_pMediaBuffer->Release();
    }

protected:
    //
    // Implement C1in1outDMO overridables
    //
    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       if (!(InputType() && OutputType()))
          return DMO_E_TYPE_NOT_SET;
       //
       // For efficiency reasons we might like to be fed fairly large amounts
       // of data at a time, but technically all we need is one quantum.
       //
       *pulSize = m_ulInputQuantumSize;
       *pcbMaxLookahead = 0; // this base class does not rely on HOLDS_BUFFERS
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       if (!(InputType() && OutputType()))
          return DMO_E_TYPE_NOT_SET;
       *pulSize = m_ulOutputQuantumSize;
       *pulAlignment = 1;
       return NOERROR;
    }
    
    virtual HRESULT Discontinuity() {
       m_bDiscontinuity = TRUE;
       return NOERROR;
    }

    virtual HRESULT AcceptInput(BYTE* pData,
                                ULONG ulSize,
                                DWORD dwFlags,
                                REFERENCE_TIME rtTimestamp,
                                REFERENCE_TIME rtTimelength,
                                IMediaBuffer* pBuffer
    ) {
       // Every sample is a syncpoint for mediatypes
       // supported by objects of this class.
       assert(dwFlags & DMO_INPUT_DATA_BUFFERF_SYNCPOINT);
       BOOL bTimestamp = (dwFlags & DMO_INPUT_DATA_BUFFERF_TIME) ? TRUE : FALSE;

       if (m_ulWindowOverhead)
          return NZWOProcessInput(pBuffer, pData, ulSize, bTimestamp, rtTimestamp);
       else
          return ZWOProcessInput(pBuffer, pData, ulSize, bTimestamp, rtTimestamp);
    }
    virtual HRESULT ProduceOutput(BYTE *pOut,
                                  ULONG ulAvail,
                                  ULONG* pulUsed,
                                  DWORD* pdwStatus,
                                  REFERENCE_TIME *prtTimestamp,
                                  REFERENCE_TIME *prtTimelength
    ) {
       HRESULT hr;
       if (!m_bParametersSet)
          return DMO_E_TYPE_NOT_SET;
       
       // call Discontinuity() if this is the first ProcessOutput() call
       if (!m_bStreaming) {
          HRESULT hr = Discontinuity();
          if (FAILED(hr))
             return hr;
          m_bStreaming = TRUE;
       }

       *pdwStatus = 0;

       ULONG ulInputQuantaAvailable = InputQuantaAvailable();
       if (!ulInputQuantaAvailable)
          return S_FALSE; // did not produce anything

       ULONG ulOutputQuantaPossible = ulAvail / m_ulOutputQuantumSize;
       if (!ulOutputQuantaPossible)
          return E_INVALIDARG; // this would be rather lame

       ULONG ulQuantaToProcess = min(ulOutputQuantaPossible, ulInputQuantaAvailable);
       assert(ulQuantaToProcess > 0);

       BOOL bTimestamp;
       if (m_ulWindowOverhead)
          hr = NZWOProcessOutput(pOut, ulQuantaToProcess, &bTimestamp, prtTimestamp);
       else
          hr = ZWOProcessOutput(pOut, ulQuantaToProcess, &bTimestamp, prtTimestamp);
       if (FAILED(hr))
          return hr;

       *pulUsed = ulQuantaToProcess * m_ulOutputQuantumSize;

       *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
       if (bTimestamp)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_TIME;

       // any data left ?
       if (InputQuantaAvailable()) // yes - set incomplete
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;
       else if (m_bDiscontinuity) // no - process any discontinuity
          DoFlush();

       return NOERROR;
    }
    HRESULT DoFlush()
    {
       // reset flags
       m_bDiscontinuity = FALSE;
       m_bTimestamps = FALSE;

       if (m_ulWindowOverhead)
          NZWODiscardData();
       else
          ZWODiscardData();
          
       // notify the derived class
       Discontinuity();

       return NOERROR;
    }
    HRESULT AcceptingInput() {
       if (!m_bParametersSet) // uninitialized
          return FALSE;

       BOOL bResult;
       if (m_ulWindowOverhead)
          bResult = NZWOQueryAccept();
       else
          bResult = ZWOQueryAccept();

       return bResult ? S_OK : S_FALSE;
    }
    // End C1in1out overridables implementation
    
private:
    //
    // Common private code (window overhead or no window overhead)
    //
    // returns the number of input quanta available minus any window overhead
    ULONG InputQuantaAvailable() {
       if (m_ulWindowOverhead)
          return NZWOAvail();
       else
          return ZWOAvail();
    }

    // Private method to compute/allocate stuff once all types have been set.
    HRESULT PrepareForStreaming () {
       m_bParametersSet = FALSE;
       // Now that both types are set, query the derived class for params
       HRESULT hr;
       if (FAILED(hr = GetStreamingParams(&m_ulInputQuantumSize,
                               &m_ulOutputQuantumSize,
                               &m_ulLookahead,
                               &m_ulLookbehind,
                               &m_rtDurationNumerator,
                               &m_rtDenominator)))
          return hr;
       if (!m_rtDenominator) {
          assert(!"bad object - duration denominator should not be 0 !");
          return E_FAIL;
       }
       // Attempt to reduce the fraction.  Probably the most complicated number
       // we will ever see is 44100 = (3 * 7 * 2 * 5) ^ 2, so trying the first
       // few numbers should suffice in most cases.
       DWORD dwP[] = {2,3,5,7,11,13,17,19,23,29,31};
       for (DWORD c = 0; c < sizeof(dwP) / sizeof(DWORD); c++) {
          while ((m_rtDurationNumerator % dwP[c] == 0) &&
                 (m_rtDenominator % dwP[c] == 0)) {
             m_rtDurationNumerator /= dwP[c];
             m_rtDenominator /= dwP[c];
          }
       }

       // We cannot afford to have huge denominators, unfortunately, because
       // we store timestamp numerators using 64 bits, so a large denominator
       // could result in timestamp overflows.  So if the denominator is still
       // too large, reduce it anyway with loss of precision.
       ULONG ulMax = 0x10000; // largest acceptable denominator value
       if (m_rtDenominator >= ulMax) {
          double actual_ratio = (double)m_rtDurationNumerator * (double)m_rtDenominator;
          ULONG ulDenominator = 1;
          // Repeatedly increase the denominator until either the actual ratio
          // can be represented precisely using the denominator, or the
          // denominator gets too large.
          do {
             double fractional_part = actual_ratio * (double)ulDenominator 
                                    - floor(actual_ratio * (double)ulDenominator);
             if (fractional_part == 0)
                break;
             ULONG ulNewDenominator = (ULONG)floor(ulDenominator / fractional_part);
             if (ulNewDenominator >= ulMax)
                break;
             ulDenominator = ulNewDenominator;
          } while(1);
          m_rtDurationNumerator = (ULONG)floor(actual_ratio * ulDenominator);
          m_rtDenominator = ulDenominator;
       }

       m_ulWindowOverhead = m_ulLookahead + m_ulLookbehind;
       if (!m_ulWindowOverhead) // No window overhead - the simple case
          m_bParametersSet = TRUE;
       else // The complicated case with window overhead
          AllocateCircularBuffer();
       
       m_bTimestamps = FALSE;
       m_bDiscontinuity = FALSE;

       if (m_bStreaming) {
          //StopStreaming();
          m_bStreaming = FALSE;
       }
       Init();
       return m_bParametersSet ? NOERROR : E_FAIL;
    }
    // end common code

    //
    // zero window overhead case code
    //
    HRESULT ZWOProcessInput(IMediaBuffer* pBuffer,
                                     BYTE* pData,
                                     ULONG ulSize,
                                     BOOL bTimestamp,
                                     REFERENCE_TIME rtTimestamp) {
       assert(!m_pMediaBuffer);
       
       m_bTimestamp = bTimestamp;
       m_rtTimestamp = rtTimestamp;
       m_pData = pData;
       m_ulData = ulSize;
       m_ulUsed = 0;
       
       // make sure they gave us a meaningful amount of data
       if (m_ulData < m_ulInputQuantumSize)
          return S_FALSE;

       // save the buffer we were given
       m_pMediaBuffer = pBuffer;
       pBuffer->AddRef();
       return NOERROR;
    }
    HRESULT ZWOProcessOutput(BYTE* pOut,
                                      ULONG ulQuantaToProcess,
                                      BOOL* pbTimestamp,
                                      REFERENCE_TIME* prtTimestamp) {
       assert(m_ulUsed % m_ulInputQuantumSize == 0);
       HRESULT hr = FBRProcess(ulQuantaToProcess, m_pData + m_ulUsed, pOut);
       if (FAILED(hr)) return hr;
       ZWOConsume(ulQuantaToProcess);

       if (m_bTimestamp) { // there was a timestamp on this input buffer
          // m_rtTimestamp refers to the beginning of the input buffer.
          // Extrapolate to the beginning of the area we just processed.
          *prtTimestamp = m_rtTimestamp +
               (m_ulUsed % m_ulInputQuantumSize) * m_rtDurationNumerator /
                                                   m_rtDenominator;
          *pbTimestamp = TRUE;
       }
       else if (m_bTimestamps) { // there was a timestamp earlier
          // bugbug: should we extrapolate from a previous timestamp ?
          *pbTimestamp = FALSE;
       }
       else // no timestamps at all
          *pbTimestamp = FALSE;

       return NOERROR;
    }
    ULONG ZWOAvail() {
       if (m_pMediaBuffer) {
          assert(m_ulData - m_ulUsed > m_ulInputQuantumSize);
          return (m_ulData - m_ulUsed) / m_ulInputQuantumSize;
       }
       else
          return 0;
    }
    void ZWOConsume(ULONG ulN) { // the zero window overhead version
       assert(m_pMediaBuffer);
       m_ulUsed += ulN * m_ulInputQuantumSize;
       assert(m_ulData >= m_ulUsed);
       if (m_ulData - m_ulUsed < m_ulInputQuantumSize) {
          m_pMediaBuffer->Release();
          m_pMediaBuffer = NULL;
       }
    }
    BOOL ZWOQueryAccept() {
        // accept IFF not holding something already
       if (!m_pMediaBuffer)
          return TRUE;
       else
          return FALSE;
    }
    void ZWODiscardData() {
       if (m_pMediaBuffer) {
          m_pMediaBuffer->Release();
          m_pMediaBuffer = NULL;
       }
    }
    // End zero window overhead case code

    //
    // Non zero window overhead case code.
    //
    HRESULT NZWOProcessInput(IMediaBuffer* pBuffer,
                                  BYTE* pData,
                                  ULONG ulSize,
                                  BOOL bTimestamp,
                                  REFERENCE_TIME rtTimestamp) {
       if (bTimestamp) { // process the timestamp
          if (!m_bTimestamps) { // this is the first timestamp we've seen
             // Just getting started - initialize the timestamp to refer to
             // the first input quantum for which we will actually generate
             // output (the first m_ulLookbehind quanta are pure lookbehind and
             // generate no output).
             m_rtTimestampNumerator = rtTimestamp * m_rtDenominator
                                    + m_ulLookbehind * m_rtDurationNumerator;
   
          }
          else {
             // We are already streaming and just got a new timestamp.  Use it
             // to check if our stored timestamp has somehow drifted away from
             // where it should be and adjust if it is far enough off.
   
             ULONG ulInputQuantaAvailable = InputQuantaAvailable();
             if (ulInputQuantaAvailable) {
                // ulInputQuantaAvailable is how far back in time the next
                // quantum we would process is located relative the beginning
                // of the new buffer we just received.
   
                // Compute what the timestamp back there ought to be now.
                REFERENCE_TIME rtTimestampNumerator;
                rtTimestampNumerator = m_rtDenominator * rtTimestamp
                                     - ulInputQuantaAvailable * m_rtDurationNumerator;
   
                // Adjust the stored timestamp if it is off by more than half
                // the duration of a quantum.  Should also have a DbgLog here.
                if ((m_rtTimestampNumerator >= rtTimestampNumerator + m_rtDurationNumerator / 2) ||
                    (m_rtTimestampNumerator <= rtTimestampNumerator - m_rtDurationNumerator / 2)) {
                   m_rtTimestampNumerator = rtTimestampNumerator;
                }
             }
             else {
                // We must still be accumulating the initial window overhead.
                // Too early to need an adjustment, one would hope.
             }
          }
          m_bTimestamps = TRUE;
       }

       if (BufferUsed() + ulSize > m_ulBufferAllocated)
          return E_FAIL; // need a max input size to prevent this

       // append to our buffer
       AppendData(pData, ulSize);
       
       // are we ready to produce now ?
       if (NZWOAvail())
          return NOERROR;
       else
          return S_FALSE; // no output can be produced yet
    }
    HRESULT NZWOProcessOutput(BYTE* pOut,
                                   ULONG ulQuantaToProcess,
                                   BOOL* pbTimestamp,
                                   REFERENCE_TIME* prtTimestamp) {
       //
       // Handle any timestamps
       //
       if (m_bTimestamps) {
          // In window overhead mode the stored timestamp refers to the input
          // data immediately after lookbehind, which corresponds to the
          // begining of the output buffer by definition of FDRProcess.
          *prtTimestamp = m_rtTimestampNumerator / m_rtDenominator;
          *pbTimestamp = TRUE;
          
       }
       else
          *pbTimestamp = FALSE;

       //
       // Handle the data
       //
       HRESULT hr;
       ULONG ulInputNeeded = m_ulInputQuantumSize * (ulQuantaToProcess + m_ulWindowOverhead);
       assert(ulInputNeeded < BufferUsed());
       if (m_ulDataHead + ulInputNeeded <= m_ulBufferAllocated) {
          // No wraparound, everything is easy
          hr = FBRProcess(ulQuantaToProcess,
                          m_pCircularBuffer + m_ulDataHead + m_ulLookbehind * m_ulInputQuantumSize,
                          pOut);
          if (FAILED(hr))
             return hr;
          NZWOConsume(ulQuantaToProcess);
       }
       else { // The data we want to send wraps around the end
          // Q.: does it wrap around inside the window overhead area
          // or inside the main data area ?
          if (m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize < m_ulBufferAllocated) {
             // The wraparound occurs inside the main data area.  Advance the
             // window overhead up to the wraparound point by processing some data.
             ULONG ulAdvance = m_ulBufferAllocated - (m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize);
             assert(ulAdvance % m_ulInputQuantumSize == 0);
             ulAdvance /= m_ulInputQuantumSize; // convert to quanta
             assert(ulAdvance > 0);
             assert(ulAdvance < ulQuantaToProcess);
             hr = FBRProcess(ulAdvance,
                             m_pCircularBuffer + m_ulDataHead + m_ulLookbehind * m_ulInputQuantumSize,
                             pOut);
             if (FAILED(hr))
                return hr;
             NZWOConsume(ulAdvance);
             
             // Adjust stuff so that the code below can act
             // as if this extra process call never happened.
             pOut += m_ulOutputQuantumSize * ulAdvance;
             ulQuantaToProcess -= ulAdvance;
             assert(ulQuantaToProcess > 0);

             // Now the wraparound point should be exactly on the boundary
             // between window overhead and main data.
             assert(m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize == m_ulBufferAllocated);
          } // wraparound in main data
          
          // When we get here, the wraparound point occurs somewhere inside
          // the window overhead area or right on the border between window overhead and
          // main data.
          assert(m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize >= m_ulBufferAllocated);
          ULONG ulLookaheadToCopy = m_ulBufferAllocated - m_ulDataHead;
          
          // copy to the special area we reserved at the front
          memcpy(m_pCircularBuffer - ulLookaheadToCopy,
                 m_pCircularBuffer + m_ulDataHead,
                 ulLookaheadToCopy);
          
          // Now the block we are interested in is all in one piece
          hr = FBRProcess(ulQuantaToProcess,
                          m_pCircularBuffer - ulLookaheadToCopy  + m_ulLookbehind * m_ulInputQuantumSize,
                          pOut);
          if (FAILED(hr))
             return hr;
          NZWOConsume(ulQuantaToProcess);
       } // data handling - wraparound case
       return NOERROR;
    }
    void AllocateCircularBuffer() {
       // free any previously allocated input buffer
       if (m_pAllocAddr)
          delete[] m_pAllocAddr;

       // bugbug: need a better way to decide this number
       m_ulBufferAllocated = max(m_ulInputQuantumSize * 16, 65536L);
       m_ulDataHead = m_ulDataTail = 0;

       // reserve room at the front for copying window overhead
       ULONG ulPrefix = m_ulWindowOverhead * m_ulInputQuantumSize;
       m_pAllocAddr = new BYTE[m_ulBufferAllocated + ulPrefix];
       if (!m_pAllocAddr)
          return;
       m_pCircularBuffer = m_pAllocAddr + ulPrefix;
       
       m_bParametersSet = TRUE;
    }
    BOOL NZWOQueryAccept() {
       // We are using a temp input buffer.  Is there room to append more ?
       // The answer really depends on how much data they will try to feed
       // us.  Without knowing the maximum input buffer size, we will accept
       // more if the input buffer is less than half full.
       if (2 * BufferUsed() < m_ulBufferAllocated)
          return TRUE;
       else
          return FALSE;
    }
    ULONG NZWOAvail() {
       ULONG ulInputQuantaAvailable = BufferUsed() / m_ulInputQuantumSize;
       if (ulInputQuantaAvailable > m_ulWindowOverhead)
          return ulInputQuantaAvailable - m_ulWindowOverhead;
       else
          return 0;
    }
    void NZWOConsume(ULONG ulN) { // the window overhead version
       assert(ulN * m_ulInputQuantumSize <= BufferUsed());
       m_ulDataHead += ulN * m_ulInputQuantumSize;
       if (m_ulDataHead > m_ulBufferAllocated) //wraparound
          m_ulDataHead -= m_ulBufferAllocated;
       
       // Advance the timestamp.
       // The same denominator is used for both timestamp and duration.
       m_rtTimestampNumerator += ulN * m_rtDurationNumerator;
    }
    ULONG BufferUsed() {
       if (m_ulDataTail >= m_ulDataHead)
          return m_ulDataTail - m_ulDataHead;
       else
          return m_ulBufferAllocated - (m_ulDataHead - m_ulDataTail);
    }
    void AppendData(BYTE *pData, ULONG ulSize) {
       if (m_ulDataTail + ulSize <= m_ulBufferAllocated) { // no wraparound
          memcpy(m_pCircularBuffer + m_ulDataTail, pData, ulSize);
		  m_ulDataTail += ulSize;
       }
       else { // wraparound
          memcpy(m_pCircularBuffer + m_ulDataTail, pData, m_ulBufferAllocated - m_ulDataTail);
          memcpy(m_pCircularBuffer, pData + m_ulBufferAllocated - m_ulDataTail, ulSize - (m_ulBufferAllocated - m_ulDataTail));
		  m_ulDataTail += ulSize;
		  m_ulDataTail -= m_ulBufferAllocated;
       }
    }
    void NZWODiscardData() {
       m_ulDataHead = m_ulDataTail = 0;
    }
    // End window overhead case code


protected:    
    //
    // To be implemebted by the derived class
    //
    virtual HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut) = 0;
    virtual HRESULT GetStreamingParams(
                       DWORD *pdwInputQuantumSize, // in bytes
                       DWORD *pdwOutputQuantumSize, // in bytes
                       DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
                       DWORD *pdwLookbehind,
                       REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
                       REFERENCE_TIME *prtDurationDenominator // optional, normally 1
                    ) = 0;
    virtual HRESULT Init() {
       return NOERROR;
    }
    // Because AllocateStreamingResources() and FreeStreamingResources() are
    // optional, we have no place to call StopStreaming() from except the
    // destructor, and calling a virtual function from the destructor doesn't
    // work.  Without StopStreaming(), StartStreaming() is not much use either.
    // We need to change the IMediaObject spec and make those
    // calls mandatory.  Then we can implement StartStreaming/StopStraming.
    // virtual HRESULT StartStreaming() = 0;
    // virtual HRESULT StopStreaming() = 0;

private:

    BOOL m_bNewInput;

    // streaming parameters
    BOOL m_bParametersSet;
    ULONG m_ulInputQuantumSize;
    ULONG m_ulOutputQuantumSize;
    ULONG m_ulLookahead;
    ULONG m_ulLookbehind;
    ULONG m_ulWindowOverhead;
    REFERENCE_TIME m_rtDurationNumerator;
    REFERENCE_TIME m_rtDenominator;

    // streaming state
    BOOL m_bTimestamps; // we have seen at least one timestamp
    BOOL m_bDiscontinuity;
    BOOL m_bStreaming;
    
    // zero window overhead case input data
    IMediaBuffer *m_pMediaBuffer;
    BYTE *m_pData;
    ULONG m_ulData;
    ULONG m_ulUsed;
    BOOL m_bTimestamp; // timestamp on current buffer
    REFERENCE_TIME m_rtTimestamp;

    // window overhead case input data
    BYTE *m_pCircularBuffer;
    BYTE *m_pAllocAddr;
    ULONG m_ulBufferAllocated;
    ULONG m_ulDataHead;
    ULONG m_ulDataTail;
    REFERENCE_TIME m_rtTimestampNumerator; // uses the same denominator as duration

};


// CPCMDMO - base class for PCM audio transform filters.
// Helps non-converting PCM audio transforms with mediatype negotiation.
// Based on CFBRDMO - study that first.
//
// Derived class must implement:
//     FBRProcess()
// Deriver class may implement:
//   Discontinuity() // default implementaion does nothing
//   Init()          // default implementaion does nothing
//   GetPCMParams()    // default implementation proposes 44100/2/16
//   CheckPCMParams()  // default implementation accepts any 8/16 bit format
//   GetWindowParams()   // default implementation assumes no lookahead/lookbehind
//
// This class conveniently provides the following data members accessible
// by the derived class:
//   ULONG m_ulSamplingRate
//   ULONG m_cChannels
//   BOOL m_b8bit
//
#include <mmreg.h>
#include <uuids.h>

class CPCMDMO : public CFBRDMO
{
protected:
   //
   // implement pure virtual CFBRDMO methods
   //
   HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
      if (ulTypeIndex > 0)
         return DMO_E_NO_MORE_ITEMS;
      return GetType(pmt, OutputType());
   }
   HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
      if (ulTypeIndex > 0)
         return DMO_E_NO_MORE_ITEMS;
      return GetType(pmt, InputType());
   }
   HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
      return CheckType(pmt, OutputType());
   }
   HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt) {
      return CheckType(pmt, InputType());
   }
   HRESULT Init() {
      return NOERROR;
   }
   HRESULT Discontinuity() {
      return NOERROR;
   }
   HRESULT GetStreamingParams(
              DWORD *pdwInputQuantumSize, // in bytes
              DWORD *pdwOutputQuantumSize, // in bytes
              DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
              DWORD *pdwMaxLookbehind,
              REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
              REFERENCE_TIME *prtDurationDenominator // optional, normally 1
           ) {
      // Sanity check: all of this should have been taken care of by base class
      DMO_MEDIA_TYPE* pmtIn =  InputType();
      DMO_MEDIA_TYPE* pmtOut = OutputType();
      if (!pmtIn || !pmtOut)
         return DMO_E_TYPE_NOT_SET;
      if (CheckType(pmtIn, NULL) || CheckType(pmtOut, pmtIn))
         return DMO_E_TYPE_NOT_ACCEPTED;
      
      WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmtIn->pbFormat;
      
      m_b8bit          = (pWave->wBitsPerSample == 8);
      m_cChannels      = pWave->nChannels;
      m_ulSamplingRate = pWave->nSamplesPerSec;
      
      *pdwInputQuantumSize    = pWave->nBlockAlign;
      *pdwOutputQuantumSize   = pWave->nBlockAlign;
      *prtQuantumDuration     = 10000000; // rt units per sec
      *prtDurationDenominator = pWave->nSamplesPerSec;
      
      GetWindowParams(pdwMaxLookahead, pdwMaxLookbehind);
      return NOERROR;
   }

protected:
   //
   // Methods to be overridden by derived class
   //
   // We use this to get lookahead/lookbehind from the derived class
   virtual void GetWindowParams(DWORD *pdwMaxLookahead,
                                DWORD *pdwMaxLookbehind) {
      *pdwMaxLookahead = 0;
      *pdwMaxLookbehind = 0;
   }
   // derived class can override these if it has specific requirements
   virtual void GetPCMParams(BOOL* pb8bit, DWORD* pcChannels, DWORD* pdwSamplesPerSec) {
      // These values are what the DMO will advertise in its media type.
      // Specifying them here does not mean that this is the only acceptable
      // combination - CheckPCMParams() is the ultimate authority on what we will
      // accept.
      *pb8bit = FALSE;
      *pcChannels = 2;
      *pdwSamplesPerSec = 44100;
   }
   virtual BOOL CheckPCMParams(BOOL b8bit, DWORD cChannels, DWORD dwSamplesPerSec) {
      // Default implementation accepts anything.  Override if you have specific
      // requirements WRT sampling rate, number of channels, or bit depth.
      return TRUE;
   }
   
private:
   //
   // private helpers
   //
   HRESULT GetType(DMO_MEDIA_TYPE* pmt, const DMO_MEDIA_TYPE *pmtOther) {
      // If the other type is set, enumerate that.  Otherwise propose 44100/2/16.
      if (pmtOther) {
         MoCopyMediaType(pmt, pmtOther);
         return NOERROR;
      }
   
      HRESULT hr = MoInitMediaType(pmt, sizeof(WAVEFORMATEX));
      if (FAILED(hr))
         return hr;
   
      pmt->majortype  = MEDIATYPE_Audio;
      pmt->subtype    = MEDIASUBTYPE_PCM;
      pmt->formattype = FORMAT_WaveFormatEx;
   
      WAVEFORMATEX* pWave = (WAVEFORMATEX*) pmt->pbFormat;
      pWave->wFormatTag = WAVE_FORMAT_PCM;
   
      BOOL b8bit;
      DWORD cChannels;
      GetPCMParams(&b8bit, &cChannels, &(pWave->nSamplesPerSec));
      (pWave->nChannels) = (unsigned short)cChannels;
      pWave->wBitsPerSample = b8bit ? 8 : 16;
      pWave->nBlockAlign = pWave->nChannels * pWave->wBitsPerSample / 8;
      pWave->nAvgBytesPerSec = pWave->nSamplesPerSec * pWave->nBlockAlign;
      pWave->cbSize = 0;
   
      return NOERROR;
   }
   HRESULT CheckType(const DMO_MEDIA_TYPE *pmt, DMO_MEDIA_TYPE *pmtOther) {
      // verify that this is PCM with a WAVEFORMATEX format specifier
      if ((pmt->majortype  != MEDIATYPE_Audio) ||
          (pmt->subtype    != MEDIASUBTYPE_PCM) ||
          (pmt->formattype != FORMAT_WaveFormatEx) ||
          (pmt->cbFormat < sizeof(WAVEFORMATEX)) ||
          (pmt->pbFormat == NULL))
         return DMO_E_TYPE_NOT_ACCEPTED;
      
      // If other type set, accept only if identical to that.  Otherwise accept
      // any standard PCM audio.
      if (pmtOther) {
         if (memcmp(pmt->pbFormat, pmtOther->pbFormat, sizeof(WAVEFORMATEX)))
            return DMO_E_TYPE_NOT_ACCEPTED;
      }
      else {
         WAVEFORMATEX* pWave = (WAVEFORMATEX*)pmt->pbFormat;
         if ((pWave->wFormatTag != WAVE_FORMAT_PCM) ||
             ((pWave->wBitsPerSample != 8) && (pWave->wBitsPerSample != 16)) ||
             (pWave->nBlockAlign != pWave->nChannels * pWave->wBitsPerSample / 8) ||
             (pWave->nAvgBytesPerSec != pWave->nSamplesPerSec * pWave->nBlockAlign) ||
             !CheckPCMParams((pWave->wBitsPerSample == 8), pWave->nChannels, pWave->nSamplesPerSec))
            return DMO_E_TYPE_NOT_ACCEPTED;
      }
      return NOERROR;
   }

protected:
   // format info - the derived class may look at these (but no modify)
   ULONG m_ulSamplingRate;
   ULONG m_cChannels;
   BOOL m_b8bit;
};


//
// CGenericDMO - generic DMO base class.  This is currently the only base
// class for DMOs that have multiple inputs or multiple outputs.
//
// This base class tries to be reasonably generic.  The derived class reports
// how many streams it supports and describes each stream by calling
// CreateInputStreams() and CreateOutputStreams().  Each of these functions
// takes an array of STREAMDESCRIPTOR structures, each of which poits to an
// array of FORMATENTRY structures.
//
// This base class uses CInputStream and COutputStream classes (both derived
// from CStream) to keep track of input and output stream.  However, these
// objects are not visible to the derived class - the derived class only sees
// stream IDs.
//
// One limitation of the scheme use here is that the derived class cannot
// override the GetType/SetType methods individually for each stream.  It must
// either (a) live with a static, finite set of types communicated via the
// STREAMDESCRIPTOR structure, or (b) override all IMediaObject type methods
// and handle type negotiation for all streams itself.
//
// Processing occurs when the base class calles DoProcess (overridden by the
// derived class).  DoProcess receives an array of input buffer structs and
// an array of output buffer structs.  The base class takes care of talking
// to IMediaBuffers, so the derived class only sees actual data pointers.
//

// flags used to communicate with the derived class
enum _INPUT_STATUS_FLAGS {
   INPUT_STATUSF_RESIDUAL // cannot be further processed w/o additional input
};
                            
// These are used to pass buffers between this class and the derived class.
typedef struct _INPUTBUFFER {
   BYTE *pData;                 // [in] - if NULL, the rest are garbage
   DWORD cbSize;                // [in]
   DWORD cbUsed;                // [out]
   DWORD dwFlags;               // [in] - DMO_INPUT_DATA_BUFFERF_XXX
   DWORD dwStatus;              // [out] - INPUT_STATUSF_XXX from above
   REFERENCE_TIME rtTimestamp;  // [in]
   REFERENCE_TIME rtTimelength; // [in]
} INPUTBUFFER, *PINPUTBUFFER;
typedef struct _OUTPUTBUFFER {
   BYTE *pData;                 // [in]
   DWORD cbSize;                // [in]
   DWORD cbUsed;                // [out]
   DWORD dwFlags;               // [out] - DMO_OUTPUT_DATA_BUFFERF_XXX
   REFERENCE_TIME rtTimestamp;  // [out]
   REFERENCE_TIME rtTimelength; // [out]
} OUTPUTBUFFER, *POUTPUTBUFFER;

// Used by derived class to describe the format supported by each stream
typedef struct _FORMATENTRY
{
    const GUID *majortype;
    const GUID *subtype;
    const GUID *formattype;
    DWORD cbFormat;
    BYTE* pbFormat;
} FORMATENTRY;

// These are used by the derived class to described its streams
typedef struct _INPUTSTREAMDESCRIPTOR {
   DWORD        cFormats;
   FORMATENTRY *pFormats;
   DWORD        dwMinBufferSize;
   BOOL         bHoldsBuffers;
   DWORD        dwMaxLookahead; // used if HOLDS_BUFFERS set
} INPUTSTREAMDESCRIPTOR;
typedef struct _OUTPUTSTREAMDESCRIPTOR {
   DWORD        cFormats;
   FORMATENTRY *pFormats;
   DWORD        dwMinBufferSize;
} OUTPUTSTREAMDESCRIPTOR;

// Common input/output stream stuff
class CStream {
public:
    DMO_MEDIA_TYPE       m_MediaType;
    BOOL                m_bEOS;
    BOOL                m_bTypeSet;

    DWORD        m_cFormats;
    FORMATENTRY *m_pFormats;
    DWORD        m_dwMinBufferSize;

    //  Should really pass in a format type list
    CStream()
    {
        MoInitMediaType(&m_MediaType, 0);
        m_bTypeSet = FALSE;
        Flush();
    }
    ~CStream()
    {
        MoFreeMediaType(&m_MediaType);
    }
    HRESULT Flush() {
       m_bEOS = FALSE;
       return NOERROR;
    }
    HRESULT StreamInfo(unsigned long *pdwFlags)
    {
       if (pdwFlags == NULL) {
           return E_POINTER;
       }
       *pdwFlags = 0;
       return S_OK;
    }
    HRESULT GetType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt)
    {
        if (ulTypeIndex >= m_cFormats) {
            return E_INVALIDARG;
        }
        //  Just return our types
        MoInitMediaType(pmt, m_pFormats[ulTypeIndex].cbFormat);
        pmt->majortype  = *m_pFormats[ulTypeIndex].majortype;
        pmt->subtype    = *m_pFormats[ulTypeIndex].subtype;
        pmt->formattype = *m_pFormats[ulTypeIndex].formattype;
        memcpy(pmt->pbFormat, m_pFormats[ulTypeIndex].pbFormat, m_pFormats[ulTypeIndex].cbFormat);
        return S_OK;
    }
    HRESULT GetCurrentType(DMO_MEDIA_TYPE *pmt)
    {
        if (NULL == pmt) {
            return E_POINTER;
        }

        if (m_bTypeSet) {
           //  BUGBUG check success
           MoCopyMediaType(pmt, &(m_MediaType));
           return S_OK;
        }
        else
           return DMO_E_TYPE_NOT_SET;
    }
    HRESULT SetType(const DMO_MEDIA_TYPE *pmt, DWORD dwFlags)
    {
        //  Need to check this
        HRESULT hr = CheckType(pmt, 0);
        if (FAILED(hr)) {
            return hr;
        }
        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR; // check konly
        }
        //  BUGBUG - check success
        MoCopyMediaType(&m_MediaType, pmt);

        m_bTypeSet = TRUE;;
        return S_OK;
    }
    HRESULT CheckType(const DMO_MEDIA_TYPE *pmt, DWORD dwFlags)
    {
        if (pmt == NULL) {
            return E_POINTER;
        }
        //if (dwFlags & ~DMO_SET_TYPEF_NOT_PARTIAL)
        //    return E_INVALIDARG;

        //  Default - check GUIDs

        bool bMatched = false;
        for (DWORD i = 0; i < m_cFormats; i++) {
            const FORMATENTRY *pFormat = &(m_pFormats[i]);
            if (pmt->majortype  == *(pFormat->majortype) &&
                pmt->subtype    == *(pFormat->subtype) &&
                pmt->formattype == *(pFormat->formattype)) {
                bMatched = true;
                break;
            }
        }

        if (bMatched) {
            return S_OK;
        } else {
            return DMO_E_INVALIDTYPE;
        }
    }
    HRESULT SizeInfo(ULONG *plSize, ULONG *plAlignment)
    {
        if (plSize == NULL || plAlignment == NULL) {
            return E_POINTER;
        }

        *plAlignment = 1;
        *plSize      = m_dwMinBufferSize;
        return S_OK;
    }
};

// Input stream specific stuff
class CInputStream : public CStream {
public:
    BOOL         m_bHoldsBuffers;
    DWORD        m_dwMaxLookahead; // used if HOLDS_BUFFERS set

    // Current input sample
    IMediaBuffer *m_pMediaBuffer;
    DWORD m_dwFlags; // discontinuity, etc.
    REFERENCE_TIME m_rtTimestamp;
    REFERENCE_TIME m_rtTimelength;
    BYTE *m_pData;
    DWORD m_cbSize;
    DWORD m_cbUsed;

    // residual
    BYTE *m_pbResidual;
    DWORD m_cbResidual;
    DWORD m_cbResidualBuffer;

    // temporary buffer for handling the residual
    BYTE *m_pbTemp;

   HRESULT Flush() {
      if (m_pMediaBuffer) {
         m_pMediaBuffer->Release();
         m_pMediaBuffer = NULL;
      }
      return CStream::Flush();
   }
   CInputStream() {
      m_pMediaBuffer = NULL;
      m_pbResidual = NULL;
      m_pbTemp = NULL;
   }
   ~CInputStream() {
      if (m_pMediaBuffer)
         m_pMediaBuffer->Release();
      if (m_pbResidual)
         delete[] m_pbResidual;
   }
   HRESULT StreamInfo(DWORD *pdwFlags) {
      HRESULT hr = CStream::StreamInfo(pdwFlags);
      if (FAILED(hr))
         return hr;
      if (m_bHoldsBuffers)
         *pdwFlags |= DMO_INPUT_STREAMF_HOLDS_BUFFERS;
      return NOERROR;
   }
   HRESULT Init(INPUTSTREAMDESCRIPTOR *pDescriptor) {
      m_cFormats = pDescriptor->cFormats;
      m_pFormats = pDescriptor->pFormats;
      m_dwMinBufferSize = pDescriptor->dwMinBufferSize;
      m_bHoldsBuffers = pDescriptor->bHoldsBuffers;
      m_dwMaxLookahead = pDescriptor->dwMaxLookahead;
      
      // Just in case Init is called multiple times:
      // delete any preexisting stuff.
      if (m_pMediaBuffer) {
         m_pMediaBuffer->Release();
         m_pMediaBuffer = NULL;
      }
      if (m_pbResidual) {
         delete[] m_pbResidual;
         m_pbResidual = NULL;
      }

      m_cbResidual = 0;
      m_cbResidualBuffer = m_dwMinBufferSize * 2; // enough ?
      m_pbResidual = new BYTE[m_cbResidualBuffer];

      return NOERROR;
   }
   HRESULT InputStatus(DWORD *pdwStatus) {
       // objects that hold buffers must implement InputStatus themselves
      assert(!m_bHoldsBuffers);
      *pdwStatus = 0;
      if (!m_pMediaBuffer)
         *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
      return NOERROR;
   }
   HRESULT Deliver(
      IMediaBuffer *pBuffer, // [in], must not be NULL
      DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
      REFERENCE_TIME rtTimestamp, // [in], valid if flag set
      REFERENCE_TIME rtTimelength // [in], valid if flag set
   ) {
      if (!pBuffer)
         return E_POINTER;
       // objects that hold buffers must implement Deliver themselves
      assert(!m_bHoldsBuffers);
      DWORD dwStatus = 0;
      InputStatus(&dwStatus);
      if (!(dwStatus & DMO_INPUT_STATUSF_ACCEPT_DATA))
         return DMO_E_NOTACCEPTING;
      assert(!m_pMediaBuffer); // can't hold multiple buffers

      //Deal with the IMediaBuffer
      HRESULT hr;
      hr = pBuffer->GetBufferAndLength(&m_pData, &m_cbSize);
      if (FAILED(hr))
         return hr;

      if (!m_cbSize) // empty buffer
         return S_FALSE; // no data

      pBuffer->AddRef();
      m_pMediaBuffer = pBuffer;
      m_dwFlags = dwFlags;
      m_rtTimestamp = rtTimestamp;
      m_rtTimelength = rtTimelength;
      m_cbUsed = 0;
      return NOERROR;
   }
   
   //
   // Fetch data from the currently held IMediaBuffer plus any residual
   //
   HRESULT PrepareInputBuffer(INPUTBUFFER *pBuffer)
   {
      // Q.: do we even have any data to give it ?
      if (m_pMediaBuffer) {
         // Is there a residual we need to feed first ?
         if (m_cbResidual) {
            // Yes, prepend the residual to the new input

            // If we have used some of the input buffer by now, we
            // should have also used up any residual with that.
            assert(m_cbUsed == 0);

            // compute how many bytes total we are going to send
            pBuffer->cbSize = m_cbResidual
                                      + m_cbSize;
            
            // Make sure we have at least dwMinBufferSize bytes of data.
            // We really should - the input buffer alone ought to be at
            // least that big.
            assert(pBuffer->cbSize >
                   m_dwMinBufferSize);

            // Is the residual buffer big enough to hold the residual plus
            // all of the new buffer ?
            if (pBuffer->cbSize <= m_cbResidualBuffer) {
               // Yes - wonderful, we can use the residual buffer
               memcpy(m_pbResidual + m_cbResidual,
                      m_pData,
                      m_cbSize);
               pBuffer->pData = m_pbResidual;
            }
            else {
               // No - allocate a sufficiently large temporary buffer.
               // This is supposed to be a rare case.
               m_pbTemp = new BYTE[pBuffer->cbSize];
               if (m_pbTemp == NULL)
                  return E_OUTOFMEMORY;
               // copy the residual
               memcpy(m_pbTemp,
                      m_pbResidual,
                      m_cbResidual);
               // append the new buffer
               memcpy(m_pbTemp + m_cbResidual,
                      m_pData,
                      m_cbSize);

               // set the buffer pointer to our temp buffer
               pBuffer->pData = m_pbTemp;
            }

            // BUGBUG - is this the correct way to handle timestamps &
            // discontinuities when handling a residual ?
            pBuffer->dwFlags = 0; 
         }
         else { // no residual
            pBuffer->pData = m_pData + m_cbUsed;
            pBuffer->cbSize = m_cbSize - m_cbUsed;
            pBuffer->dwFlags = m_dwFlags; 
            pBuffer->rtTimestamp = m_rtTimestamp;
            pBuffer->rtTimelength= m_rtTimelength;
         }
         pBuffer->cbUsed = 0; // derived class should set this
         pBuffer->dwStatus = 0; // derived class should set this
      }
      else {
         pBuffer->pData = NULL;
         pBuffer->cbSize = 0;
      }
      return NOERROR;
   }
   
   //
   // Save any residual and release the IMediaBuffer as appropriate.
   // Returns TRUE if there is enough data left to call ProcesInput again.
   //
   BOOL PostProcessInputBuffer(INPUTBUFFER *pBuffer)
   {
      BOOL bRet = FALSE;
      // did we even give this stream anything ?
      if (m_pMediaBuffer) {
         // Yes, but did it eat any of it ?
         if (pBuffer->cbUsed) {
            // Did we even get past the residual
            if (pBuffer->cbUsed > m_cbResidual) {
               // Yes - reflect this in the current buffer's cbUsed.
               m_cbUsed += (pBuffer->cbUsed - m_cbResidual);
               m_cbResidual = 0;
            }
            else { 
               // No - just subtract from the residual.
               // This is a rather strange case.
               m_cbResidual -= pBuffer->cbUsed;
               memmove(m_pbResidual,
                       m_pbResidual + pBuffer->cbUsed,
                       m_cbResidual);
            }
         }

         // Is there enough left to feed again the next time ?
         if ((m_cbSize - m_cbUsed <
              m_dwMinBufferSize) 
              || (pBuffer->dwStatus & INPUT_STATUSF_RESIDUAL)) {
            // No - copy the residual and release the buffer
            memcpy(m_pbResidual,
                   m_pData + m_cbUsed,
                   m_cbSize - m_cbUsed);
            m_cbResidual
              = pBuffer->cbSize - pBuffer->cbUsed;
            m_pMediaBuffer->Release();
            m_pMediaBuffer = NULL;
         }
         else { // Yes - need another Process call to eat remaining input
            bRet = TRUE;
         }

         // Free any temporary buffer we may have used - rare case
         if (m_pbTemp) {
            delete[] m_pbTemp;
            m_pbTemp = NULL;
         }
      }
      return bRet;
   }
   HRESULT Discontinuity() {
      // BUGBUG - implement
      // m_bDiscontinuity = TRUE;
      return NOERROR;
   }
   HRESULT SizeInfo(ULONG *pulSize,
                    ULONG *pulMaxLookahead,
                    ULONG *pulAlignment) {
      HRESULT hr = CStream::SizeInfo(pulSize, pulAlignment);
      if (FAILED(hr))
         return hr;

      if (m_bHoldsBuffers)
         *pulMaxLookahead = m_dwMaxLookahead;
      else
         *pulMaxLookahead = *pulSize;
      return NOERROR;
   }
};

// Output stream specific stuff
class COutputStream : public CStream {
public:
   BOOL m_bIncomplete;
   DWORD m_cbAlreadyUsed; // temp per-stream variable used during Process
   
   HRESULT Init(OUTPUTSTREAMDESCRIPTOR *pDescriptor) {
      m_cFormats = pDescriptor->cFormats;
      m_pFormats = pDescriptor->pFormats;
      m_dwMinBufferSize = pDescriptor->dwMinBufferSize;
      return NOERROR;
   }

   //
   // Initialize the OUTPUTBUFFER struct with info from the IMediaBuffer 
   //
   HRESULT PrepareOutputBuffer(OUTPUTBUFFER *pBuffer, IMediaBuffer *pMediaBuffer, BOOL bNewInput)
   {
      //
      // See if the caller supplied an output buffer
      //
      if (pMediaBuffer == NULL) {
         // This is allowed to be NULL only if (1) the object did not set
         // the INCOMPLETE flag for this stream during the last Process
         // call, and (2) no new input data has been supplied to the object
         // since the last Process call.  
         if (bNewInput)
            return E_POINTER;
         if (m_bIncomplete)
            return E_POINTER;

         // ok - initialize assuming no buffer
         pBuffer->cbSize = 0;
         pBuffer->pData = NULL;
      }
      else { // the IMediaBuffer is not NULL - deal with it
         HRESULT hr;
         hr = pMediaBuffer->GetMaxLength(&pBuffer->cbSize);
         if (FAILED(hr))
            return hr;

         hr = pMediaBuffer->GetBufferAndLength(
                 &(pBuffer->pData),
                 &(m_cbAlreadyUsed));
         if (FAILED(hr))
            return hr;

         // Check current size - should we even bother with this ?
         if (m_cbAlreadyUsed) {
            if (m_cbAlreadyUsed >= pBuffer->cbSize)
               return E_INVALIDARG; // buffer already full ?!?
            pBuffer->cbSize -= m_cbAlreadyUsed;
            pBuffer->pData += m_cbAlreadyUsed;
         }
      }
      
      // It is really the derived class's job to set these, but we
      // will be nice to it and initialize them anyway just in case.
      pBuffer->cbUsed = 0;
      pBuffer->dwFlags = 0;

      return NOERROR;
   }

   //
   // Copy the OUTPUTBUFFER back into the DMO_OUTPUT_DATA_BUFFER (yawn)
   //
   void PostProcessOutputBuffer(OUTPUTBUFFER *pBuffer, DMO_OUTPUT_DATA_BUFFER *pDMOBuffer, BOOL bForceIncomplete) {
      assert(pBuffer->cbUsed <= pBuffer->cbSize);
      if (pDMOBuffer->pBuffer)
         pDMOBuffer->pBuffer->SetLength(pBuffer->cbUsed + m_cbAlreadyUsed);
      pDMOBuffer->dwStatus = pBuffer->dwFlags;
      pDMOBuffer->rtTimestamp = pBuffer->rtTimestamp;
      pDMOBuffer->rtTimelength = pBuffer->rtTimelength;

      // Even if the derived class did not set INCOMPLETE, we may need to
      // set it anyway if some input buffer we are holding still has
      // enough data to call Process() again.
      if (bForceIncomplete)
         pDMOBuffer->dwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;

      // remember this output stream's INCOMPLETE state
      if (pDMOBuffer->dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE)
         m_bIncomplete = TRUE;
      else
         m_bIncomplete = FALSE;
   }
};

// Code that goes at the beginning of every IMediaObject method
#define INPUT_STREAM_PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulInputStreamIndex >= m_nInputStreams) \
       return DMO_E_INVALIDSTREAMINDEX; \
    CInputStream *pStream = &m_pInputStreams[ulInputStreamIndex]

#define OUTPUT_STREAM_PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulOutputStreamIndex >= m_nOutputStreams) \
       return DMO_E_INVALIDSTREAMINDEX; \
    COutputStream *pStream = &m_pOutputStreams[ulOutputStreamIndex]


class CGenericDMO : public IMediaObject
{
public:
    CGenericDMO() {
#ifdef DMO_NOATL
       InitializeCriticalSection(&m_cs);
#endif
       m_nInputStreams = 0;
       m_nOutputStreams = 0;
    }
#ifdef DMO_NOATL
    ~CGenericDMO() {
       DeleteCriticalSection(&m_cs);
    }
#endif
    
public:
    //
    // Implement IMediaObject methods
    //
    STDMETHODIMP GetInputStreamInfo(ULONG ulInputStreamIndex, DWORD *pdwFlags)
    {
       INPUT_STREAM_PROLOGUE;
       return pStream->StreamInfo(pdwFlags);
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulOutputStreamIndex, DWORD *pdwFlags)
    {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->StreamInfo(pdwFlags);
    }
    STDMETHODIMP GetInputType(ULONG ulInputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       INPUT_STREAM_PROLOGUE;
       return pStream->GetType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulOutputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->GetType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulInputStreamIndex, DMO_MEDIA_TYPE *pmt) {
       INPUT_STREAM_PROLOGUE;
       return pStream->GetCurrentType(pmt);
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulOutputStreamIndex, DMO_MEDIA_TYPE *pmt) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->GetCurrentType(pmt);
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulInputStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       INPUT_STREAM_PROLOGUE;
       return pStream->SizeInfo(pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulOutputStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->SizeInfo(pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulInputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       INPUT_STREAM_PROLOGUE;
       return pStream->SetType(pmt, dwFlags);
    }
    STDMETHODIMP SetOutputType(ULONG ulOutputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->SetType(pmt, dwFlags);
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulInputStreamIndex,
        DWORD *pdwStatus
    ) {
       INPUT_STREAM_PROLOGUE;
       return pStream->InputStatus(pdwStatus);
    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulInputStreamIndex, REFERENCE_TIME *prtLatency) {
       // BUGBUG - I don't know what to do with this right now.
       // Punt to the derived class ?
       return E_NOTIMPL;
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulInputStreamIndex, REFERENCE_TIME rtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP ProcessInput(
        DWORD ulInputStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
       INPUT_STREAM_PROLOGUE;
       return pStream->Deliver(pBuffer, dwFlags, rtTimestamp, rtTimelength);
    }
    STDMETHODIMP Discontinuity(ULONG ulInputStreamIndex) {
       INPUT_STREAM_PROLOGUE;
       return pStream->Discontinuity();
    }

    STDMETHODIMP Flush()
    {
       CDMOAutoLock l(&m_cs);
        
       //  Flush all the streams
       ULONG i;
       for (i = 0; i < m_nInputStreams; i++) {
          m_pInputStreams[i].Flush();
       }
       for (i = 0; i < m_nOutputStreams; i++) {
          m_pOutputStreams[i].Flush();
       }
       return S_OK;
    }

    STDMETHODIMP AllocateStreamingResources() {return S_OK;}
    STDMETHODIMP FreeStreamingResources() {return S_OK;}

    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        CDMOAutoLock l(&m_cs);
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams = m_nInputStreams;
        *pulNumberOfOutputStreams = m_nOutputStreams;
        return S_OK;
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwReserved,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
       CDMOAutoLock l(&m_cs);
       if (ulOutputBufferCount != m_nOutputStreams)
          return E_INVALIDARG;

       HRESULT hr;
       DWORD c;
 
       // Prepare the input buffers
       for (c = 0; c < m_nInputStreams; c++) {
          // objects that hold buffers must implement Process themselves
          assert(!m_pInputStreams[c].m_bHoldsBuffers);
          hr = m_pInputStreams[c].PrepareInputBuffer(&m_pInputBuffers[c]);
          if (FAILED(hr))
             return hr;
       }
 
       //
       // Prepare the output buffers
       //
       for (c = 0; c < m_nOutputStreams; c++) {
          hr = m_pOutputStreams[c].PrepareOutputBuffer(&m_pOutputBuffers[c], pOutputBuffers[c].pBuffer, m_bNewInput);
          if (FAILED(hr))
             return hr;
       }

       hr = DoProcess(m_pInputBuffers,m_pOutputBuffers);
       if (FAILED(hr))
          return hr; // BUGBUG - don't just "return hr", do something !

       // post-process input buffers
       BOOL bSomeInputStillHasData = FALSE;
       for (c = 0; c < m_nInputStreams; c++) {
          if (m_pInputStreams[c].PostProcessInputBuffer(&m_pInputBuffers[c]))
             bSomeInputStillHasData = TRUE;
       }

       // post-process output buffers
       for (c = 0; c < m_nOutputStreams; c++) {
          m_pOutputStreams[c].PostProcessOutputBuffer(&m_pOutputBuffers[c],
                                                      &pOutputBuffers[c],
                                                      bSomeInputStillHasData);
       }

       m_bNewInput = FALSE;
       return NOERROR;
    }

protected:
    //
    // These are called by the derived class at initialization time
    //
    HRESULT CreateInputStreams(INPUTSTREAMDESCRIPTOR *pStreams, DWORD cStreams) {
       CDMOAutoLock l(&m_cs);
       if (pStreams == NULL) {
          return E_POINTER;
       }

       m_pInputStreams = new CInputStream[cStreams];

       if (m_pInputStreams == NULL) {
          return E_OUTOFMEMORY;
       }

       DWORD c;
       for (c = 0; c < cStreams; c++) {
          HRESULT hr = m_pInputStreams[c].Init(&(pStreams[c]));
          if (FAILED(hr)) {
             delete[] m_pInputStreams;
             return hr;
          }
       }

       m_pInputBuffers = new INPUTBUFFER[cStreams];
       if (!m_pInputBuffers) {
          delete[] m_pInputStreams;
          return E_OUTOFMEMORY;
       }

       m_nInputStreams = cStreams;
       return NOERROR;
    }
    HRESULT CreateOutputStreams(OUTPUTSTREAMDESCRIPTOR *pStreams, DWORD cStreams) {
       CDMOAutoLock l(&m_cs);
       if (pStreams == NULL) {
          return E_POINTER;
       }

       m_pOutputStreams = new COutputStream[cStreams];

       if (m_pOutputStreams == NULL) {
          return E_OUTOFMEMORY;
       }

       DWORD c;
       for (c = 0; c < cStreams; c++) {
          HRESULT hr = m_pOutputStreams[c].Init(&(pStreams[c]));
          if (FAILED(hr)) {
             delete[] m_pOutputStreams;
             return hr;
          }
       }
	   
       m_pOutputBuffers = new OUTPUTBUFFER[cStreams];
       if (!m_pOutputBuffers) {
          delete[] m_pOutputStreams;
          return E_OUTOFMEMORY;
       }

       m_nOutputStreams = cStreams;
       return NOERROR;
    }

    virtual HRESULT DoProcess(INPUTBUFFER*, OUTPUTBUFFER *) = 0;

private:

    ULONG           m_nInputStreams;
    CInputStream*   m_pInputStreams;
    ULONG           m_nOutputStreams;
    COutputStream*  m_pOutputStreams;

    INPUTBUFFER*    m_pInputBuffers;
    OUTPUTBUFFER*   m_pOutputBuffers;

    BOOL m_bNewInput;
#ifdef DMO_NOATL
    CRITICAL_SECTION m_cs;
#else
    CComAutoCriticalSection m_cs;
#endif
};

#endif // __DMOBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\echo.cpp ===
// Echo.cpp : Implementation of CEchoTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "echo.h"
#include "toolhelp.h"


CEchoTool::CEchoTool()
{
    ParamInfo Params[DMUS_ECHO_PARAMCOUNT] = 
    {
        { DMUS_ECHO_REPEAT, MPT_INT,MP_CAPS_ALL,0,100,2,
            L"Repeats",L"Repeat",NULL },            // Repeat - twice by default
        { DMUS_ECHO_DECAY, MPT_INT,MP_CAPS_ALL,0,100,12,
            L"dB",L"Decay",NULL },           // Decay - 12 db by default
        { DMUS_ECHO_TIMEUNIT, MPT_ENUM,MP_CAPS_ALL, DMUS_TIME_UNIT_MS,DMUS_TIME_UNIT_1,DMUS_TIME_UNIT_GRID,
            L"",L"Delay Units",L"Milliseconds,Music Clicks,Grid,Beat,Bar,64th note triplets,64th notes,32nd note triplets,32nd notes,16th note triplets,16th notes,8th note triplets,8th notes,Quarter note triplets,Quarter notes,Half note triplets,Half notes,Whole note triplets,Whole notes" },
        { DMUS_ECHO_DELAY, MPT_INT,MP_CAPS_ALL,1,1000,1,
            L"",L"Delay",NULL},   // Delay - 1 grid note by default
        { DMUS_ECHO_GROUPOFFSET, MPT_INT,MP_CAPS_ALL,0,100,0,
            L"Channel Groups",L"Channel Offset", NULL },            // Group offset - none by default
        { DMUS_ECHO_TYPE, MPT_ENUM,MP_CAPS_ALL, DMUS_ECHOT_FALLING,DMUS_ECHOT_RISING_CLIP,DMUS_ECHOT_FALLING_CLIP,
            L"",L"Type",L"Falling,Falling & Truncated,Rising,Rising & Truncated"} // Type - falling by default
    };
    InitParams(DMUS_ECHO_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CEchoTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CEchoTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CEchoTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicEchoTool)
	{
		*ppv = static_cast<IDirectMusicEchoTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CEchoTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicEchoTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CEchoTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CEchoTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_ECHO_CHUNK))
	{
        DMUS_IO_ECHO_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_ECHO_REPEAT,(float) Header.dwRepeat);
            SetParam(DMUS_ECHO_DECAY,(float) Header.dwDecay);
            SetParam(DMUS_ECHO_TIMEUNIT,(float) Header.dwTimeUnit);
            SetParam(DMUS_ECHO_DELAY,(float) Header.dwDelay);
            SetParam(DMUS_ECHO_GROUPOFFSET,(float) Header.dwGroupOffset);
            SetParam(DMUS_ECHO_TYPE,(float) Header.dwType);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CEchoTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_ECHO_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_ECHO_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_ECHO_HEADER Header;
        GetParamInt(DMUS_ECHO_REPEAT,MAX_REF_TIME,(long *) &Header.dwRepeat);
        GetParamInt(DMUS_ECHO_DECAY,MAX_REF_TIME,(long *) &Header.dwDecay);
        GetParamInt(DMUS_ECHO_TIMEUNIT,MAX_REF_TIME,(long *) &Header.dwTimeUnit);
        GetParamInt(DMUS_ECHO_DELAY,MAX_REF_TIME,(long *) &Header.dwDelay);
        GetParamInt(DMUS_ECHO_GROUPOFFSET,MAX_REF_TIME,(long *) &Header.dwGroupOffset);
        GetParamInt(DMUS_ECHO_TYPE,MAX_REF_TIME,(long *) &Header.dwType);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CEchoTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_ECHO_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CEchoTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_EchoPage;
	return NOERROR;
}


static long glResTypes[DMUS_TIME_UNIT_COUNT] = 
{ 1,    // DMUS_TIME_UNIT_MS
  1,    // DMUS_TIME_UNIT_MTIME 
  384,  // DMUS_TIME_UNIT_GRID
  768,  // DMUS_TIME_UNIT_BEAT
  3072, // DMUS_TIME_UNIT_BAR
  32,   // DMUS_TIME_UNIT_64T
  48,   // DMUS_TIME_UNIT_64
  64,   // DMUS_TIME_UNIT_32T  
  96,   // DMUS_TIME_UNIT_32 
  128,  // DMUS_TIME_UNIT_16T     
  192,  // DMUS_TIME_UNIT_16     
  256,  // DMUS_TIME_UNIT_8T    
  384,  // DMUS_TIME_UNIT_8         
  512,  // DMUS_TIME_UNIT_4T  
  768,  // DMUS_TIME_UNIT_4         
  1024, // DMUS_TIME_UNIT_2T   
  1536, // DMUS_TIME_UNIT_2   
  2048, // DMUS_TIME_UNIT_1T
  3072  // DMUS_TIME_UNIT_1
};

/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CEchoTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    // We need to know the time format so we can call GetParamInt() to read control parameters.
    REFERENCE_TIME rtTime;
    if (m_fMusicTime) rtTime = pPMsg->mtTime;
    else rtTime = pPMsg->rtTime;
    // We need to know if there's an offset, because that determines which kinds of messages we process.
    long lGroupOffset;
    GetParamInt(DMUS_ECHO_GROUPOFFSET,rtTime,&lGroupOffset);
    lGroupOffset *= 16; // Convert to pchannels.
    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        IDirectMusicPerformance8 *pPerf8;   // We'll need the DX8 interface to access ClonePMsg.
        if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
        {
            long lRepeats, lDecay, lTimeUnit, lDelay, lType;
            
            GetParamInt(DMUS_ECHO_REPEAT,rtTime,&lRepeats);
            GetParamInt(DMUS_ECHO_DELAY,rtTime,&lDelay);
            GetParamInt(DMUS_ECHO_TIMEUNIT,rtTime,&lTimeUnit);
            GetParamInt(DMUS_ECHO_DECAY,rtTime,&lDecay);
            GetParamInt(DMUS_ECHO_TYPE,rtTime,&lType);
            long lStartVolume;
            if (lTimeUnit > DMUS_TIME_UNIT_BAR)
            {
                lDelay *= glResTypes[lTimeUnit];
            }
            else if (lTimeUnit >= DMUS_TIME_UNIT_GRID)
            {
                DMUS_TIMESIGNATURE TimeSig;
                if (SUCCEEDED(pPerf8->GetParamEx(GUID_TimeSignature,pNote->dwVirtualTrackID,pNote->dwGroupID,DMUS_SEG_ANYTRACK,pNote->mtTime,NULL,&TimeSig)))
                {
                    DWORD dwBeat = (4 * 768) / TimeSig.bBeat;
                    if (lTimeUnit == DMUS_TIME_UNIT_BEAT)
                    {
                        lDelay *= dwBeat;
                    }
                    else if (lTimeUnit == DMUS_TIME_UNIT_GRID)
                    {
                        lDelay *= (dwBeat / TimeSig.wGridsPerBeat);
                    }
                    else 
                    {
                        lDelay *= (dwBeat * TimeSig.bBeatsPerMeasure);
                    }
                }
            }
            lDecay *= 100;  // We'll do our math in 1/100ths of a dB.
            if (lType & DMUS_ECHOT_RISING)
            {
                lStartVolume = MidiToVolume(pNote->bVelocity) - (lRepeats * lDecay);
                lDecay = -lDecay;
            }
            else
            {
                lStartVolume = MidiToVolume(pNote->bVelocity);
            }
            long lCount;
            for (lCount = 0; lCount <= lRepeats; lCount++)
            {
                DMUS_NOTE_PMSG *pCopy = NULL;
                if (lCount > 0)
                {
                    pNote->dwSize = sizeof (DMUS_NOTE_PMSG);
                    pPerf8->ClonePMsg((DMUS_PMSG *) pNote,(DMUS_PMSG **)&pCopy);
                }
                else
                {
                    pCopy = pNote;
                }
                if (pCopy)
                {
                    pCopy->bVelocity = VolumeToMidi(lStartVolume - (lCount * lDecay));
                    pCopy->dwPChannel += (lCount * lGroupOffset);
                    if (lTimeUnit != DMUS_TIME_UNIT_MS)
                    {
                        pCopy->mtTime += (lCount * lDelay);
                        pCopy->dwFlags &= ~DMUS_PMSGF_REFTIME;
                    }
                    else
                    {
                        pCopy->rtTime += (lCount * lDelay * 10000); // Convert from ms to rt.
                        pCopy->dwFlags &= ~DMUS_PMSGF_MUSICTIME;
                    }
                    if (lType & DMUS_ECHOT_FALLING_CLIP)
                    {
                        if (pCopy->mtDuration <= lDecay)
                        {
                            pCopy->mtDuration = lDecay - 1;
                        }
                    }
                    if (lCount) // Don't send the original note. We need it for clone and
                                // it will be requeued on DMUS_S_REQUEUE anyway.
                    {
                        if (SUCCEEDED(pCopy->pGraph->StampPMsg((DMUS_PMSG *)pCopy))) 
                        {
                            pPerf->SendPMsg((DMUS_PMSG *)pCopy);
                        }
                        else
                        {
                            pPerf->FreePMsg((DMUS_PMSG *)pCopy);
                        }
                    }
                }
            }
            pPerf8->Release();
        }
    }
    else if (lGroupOffset > 0)
    {
        IDirectMusicPerformance8 *pPerf8;   // We'll need the DX8 interface to access ClonePMsg.
        if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
        {
            // If the echoes are being sent to other pchannels, duplicate all other events
            // so they go down those pchannels too.
            long lRepeats, lTimeUnit, lDelay;
            GetParamInt(DMUS_ECHO_REPEAT,rtTime,&lRepeats);
            GetParamInt(DMUS_ECHO_DELAY,rtTime,&lDelay);
            GetParamInt(DMUS_ECHO_TIMEUNIT,rtTime,&lTimeUnit);
            if (lTimeUnit > DMUS_TIME_UNIT_MS)
            {
                lDelay *= glResTypes[lTimeUnit];
            }
            long lCount;
            for (lCount = 0; lCount <= lRepeats; lCount++)
            {
                DMUS_PMSG *pCopy = NULL;
                if (lCount > 0)
                {
                    pPerf8->ClonePMsg(pPMsg,&pCopy);
                }
                else
                {
                    pCopy = pPMsg;
                }
                if (pCopy)
                {
                    pCopy->dwPChannel += (lCount * lGroupOffset);
                    if (lTimeUnit != DMUS_TIME_UNIT_MS)
                    {
                        pCopy->mtTime += (lCount * lDelay);
                        pCopy->dwFlags &= ~DMUS_PMSGF_REFTIME;
                    }
                    else
                    {
                        pCopy->rtTime += (lCount * lDelay * 10000); // Convert from ms to rt.
                        pCopy->dwFlags &= ~DMUS_PMSGF_MUSICTIME;
                    }
                    if (lCount) // Don't send the original note. We need it for clone and
                                // it will be requeued on DMUS_S_REQUEUE anyway.
                    {
                        if (SUCCEEDED(pCopy->pGraph->StampPMsg((DMUS_PMSG *)pCopy))) 
                        {
                            pPerf->SendPMsg((DMUS_PMSG *)pCopy);
                        }
                        else
                        {
                            pPerf->FreePMsg((DMUS_PMSG *)pCopy);
                        }
                    }
                }
            }
            pPerf8->Release();
        }
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CEchoTool::Clone( IDirectMusicTool ** ppTool)

{
    CEchoTool *pNew = new CEchoTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CEchoTool::SetRepeat(DWORD dwRepeat) 
{
    return SetParam(DMUS_ECHO_REPEAT,(float) dwRepeat);
}

STDMETHODIMP CEchoTool::SetDecay(DWORD dwDecay) 
{
    return SetParam(DMUS_ECHO_DECAY,(float) dwDecay);
}

STDMETHODIMP CEchoTool::SetTimeUnit(DWORD dwTimeUnit) 
{
    return SetParam(DMUS_ECHO_TIMEUNIT,(float) dwTimeUnit);
}

STDMETHODIMP CEchoTool::SetDelay(DWORD dwDelay) 
{
    return SetParam(DMUS_ECHO_DELAY,(float) dwDelay);
}

STDMETHODIMP CEchoTool::SetGroupOffset(DWORD dwGroupOffset) 
{
    return SetParam(DMUS_ECHO_GROUPOFFSET,(float) dwGroupOffset);
}

STDMETHODIMP CEchoTool::SetType(DWORD dwType) 
{
    return SetParam(DMUS_ECHO_TYPE,(float) dwType);
}

STDMETHODIMP CEchoTool::GetRepeat(DWORD * pdwRepeat) 
{
    return GetParamInt(DMUS_ECHO_REPEAT,MAX_REF_TIME,(long *) pdwRepeat);
}

STDMETHODIMP CEchoTool::GetDecay(DWORD * pdwDecay) 
{
    return GetParamInt(DMUS_ECHO_DECAY,MAX_REF_TIME,(long *) pdwDecay);
}

STDMETHODIMP CEchoTool::GetTimeUnit(DWORD * pdwTimeUnit) 
{
    return GetParamInt(DMUS_ECHO_TIMEUNIT,MAX_REF_TIME,(long *) pdwTimeUnit);
}

STDMETHODIMP CEchoTool::GetDelay(DWORD * pdwDelay) 
{
    return GetParamInt(DMUS_ECHO_DELAY,MAX_REF_TIME,(long *) pdwDelay);
}

STDMETHODIMP CEchoTool::GetGroupOffset(DWORD * pdwGroupOffset) 
{
    return GetParamInt(DMUS_ECHO_GROUPOFFSET,MAX_REF_TIME,(long *) pdwGroupOffset);
}

STDMETHODIMP CEchoTool::GetType(DWORD * pdwType) 
{
    return GetParamInt(DMUS_ECHO_TYPE,MAX_REF_TIME,(long *) pdwType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\guids.cpp ===
#include <objbase.h>
#include "initguid.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "basetool.h"
#include "tools.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\medparam_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Mar 24 17:07:36 2000
 */
/* Compiler settings for C:\dx8\dmusic\dmime\medparam.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IMediaParamInfo = {0x6d6cbb60,0xa223,0x44aa,{0x84,0x2f,0xa2,0xf0,0x67,0x50,0xbe,0x6d}};


const IID IID_IMediaParams = {0x6d6cbb61,0xa223,0x44aa,{0x84,0x2f,0xa2,0xf0,0x67,0x50,0xbe,0x6e}};


const IID IID_IMediaParamsRecordNotify = {0xfea74878,0x4e39,0x4267,{0x8a,0x17,0x6a,0xaf,0x05,0x36,0xff,0x7c}};


const IID IID_IMediaParamsRecord = {0x21b64d1a,0x8e24,0x40f6,{0x87,0x97,0x44,0xcc,0x02,0x1b,0x2a,0x0a}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		= TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\echo.h ===
#ifndef _ECHO_TOOL_
#define _ECHO_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "..\dmtoolprp\toolprops.h"

class CEchoTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicEchoTool

{
public:
	CEchoTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicEchoTool
	STDMETHODIMP SetRepeat(DWORD dwRepeat) ;
	STDMETHODIMP SetDecay(DWORD dwDecay) ;
    STDMETHODIMP SetTimeUnit(DWORD dwTimeUnit) ;
	STDMETHODIMP SetDelay(DWORD dwDelay) ;
    STDMETHODIMP SetGroupOffset(DWORD dwChannelOffset) ;
	STDMETHODIMP SetType(DWORD dwType) ;
	STDMETHODIMP GetRepeat(DWORD * pdwRepeat) ;
	STDMETHODIMP GetDecay(DWORD * pdwDecay) ;
    STDMETHODIMP GetTimeUnit(DWORD * pdwTimeUnit) ;
	STDMETHODIMP GetDelay(DWORD * pdwDelay) ;
	STDMETHODIMP GetType(DWORD * pdwType) ;
    STDMETHODIMP GetGroupOffset(DWORD * pdwChannelOffset) ;
protected:	
};

#endif // _ECHO_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\param.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation. All rights reserved.
//
// Declaration of CParamsManager.
//

#include "dmerror.h"
#include "param.h"
#include "math.h"
#include "..\shared\validate.h"

CParamsManager::CParamsManager()
{
    m_fDirty = FALSE;
    m_fMusicTime = FALSE;
    m_cParams = 0;
    m_pCurveLists = NULL;
    m_pParamInfos = NULL;
    InitializeCriticalSection(&m_ParamsCriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
}

CParamsManager::~CParamsManager()
{
    delete[] m_pCurveLists;
    delete[] m_pParamInfos;
    DeleteCriticalSection(&m_ParamsCriticalSection);
}

HRESULT CParamsManager::InitParams(DWORD cParams, ParamInfo *pParamInfo)
{
    m_pCurveLists = new CCurveList[cParams];
    if (!m_pCurveLists)
        return E_OUTOFMEMORY;

    // save the parameter info
    m_pParamInfos = new ParamInfo[cParams];
    if (!m_pParamInfos)
        return E_OUTOFMEMORY;
    for (DWORD dwIndex = 0; dwIndex < cParams; dwIndex++)
    {
        if (pParamInfo[dwIndex].dwIndex < cParams)
        {
            memcpy(&m_pParamInfos[pParamInfo[dwIndex].dwIndex], &pParamInfo[dwIndex], sizeof(ParamInfo));
        }
    }
    m_cParams = cParams;

    return S_OK;
}

HRESULT CParamsManager::GetParamCount(DWORD *pdwParams)
{
    if (pdwParams == NULL)
        return E_POINTER;

    *pdwParams = m_cParams;
    return S_OK;
}

HRESULT CParamsManager::GetParamInfo(DWORD dwParamIndex, MP_PARAMINFO *pInfo)
{
    if (!pInfo)
    {
        return E_POINTER;
    }
    if (dwParamIndex < m_cParams)
    {
        *pInfo = m_pParamInfos[dwParamIndex].MParamInfo;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CParamsManager::GetParamText(DWORD dwParamIndex, WCHAR **ppwchText)
{
    if (!ppwchText)
    {
        return E_POINTER;
    }
    if (dwParamIndex < m_cParams)
    {
        // write string of format: "Label\0Unit\0Enums1\0Enum2\0...EnumN\0\0"
        ParamInfo &pinfo = m_pParamInfos[dwParamIndex];
        int iUnit = wcslen(pinfo.MParamInfo.szLabel) + 1; // begin writing unit text here
        int iEnums = iUnit + wcslen(pinfo.MParamInfo.szUnitText) + 1; // begin writing enum text here
        int iEnd = iEnums + wcslen(pinfo.pwchText) + 1; // write the final (second) null terminator here
        WCHAR *pwsz = static_cast<WCHAR *>(CoTaskMemAlloc((iEnd + 1) * sizeof(WCHAR)));
        if (!pwsz)
            return E_OUTOFMEMORY;

        // wcscpy will write into various points of the string, neatly terminating each with a null
        wcscpy(pwsz, pinfo.MParamInfo.szLabel);
        wcscpy(pwsz + iUnit, pinfo.MParamInfo.szUnitText);
        wcscpy(pwsz + iEnums, pinfo.pwchText);

        // The text field was defined with commas to separate the enum values.
        // Replace them with NULL characters now.
        for (WCHAR *pwch = pwsz + iEnums; *pwch; ++pwch)
        {
            if (*pwch == L',')
                *pwch = L'\0';
        }

        pwsz[iEnd] = L'\0';

        *ppwchText = pwsz;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CParamsManager::GetNumTimeFormats(DWORD *pdwNumTimeFormats)
{
    if (!pdwNumTimeFormats)
    {
        return E_POINTER;
    }
    *pdwNumTimeFormats = 2;
    return S_OK;
}

HRESULT CParamsManager::GetSupportedTimeFormat(DWORD dwFormatIndex, GUID *pguidTimeFormat)
{
    if (!pguidTimeFormat)
    {
        return E_POINTER;
    }
    if (dwFormatIndex == 0)
    {
        *pguidTimeFormat = GUID_TIME_REFERENCE;
    }
    else
    {
        *pguidTimeFormat = GUID_TIME_MUSIC;
    }
    return S_OK;
}

HRESULT CParamsManager::GetCurrentTimeFormat( GUID *pguidTimeFormat, MP_TIMEDATA *pTimeData)
{
    return E_NOTIMPL;
}

HRESULT CParamsManager::CopyParamsFromSource( CParamsManager * pSource)
{
    HRESULT hr = S_OK;
    hr = InitParams(pSource->m_cParams, pSource->m_pParamInfos);
    if (SUCCEEDED(hr))
    {
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < m_cParams; dwIndex++)
        {
            CCurveItem *pCurve = pSource->m_pCurveLists[dwIndex].GetHead();
            for (;pCurve;pCurve = pCurve->GetNext())
            {
                CCurveItem *pNew = new CCurveItem;
                if (!pNew)
                {
                    return E_OUTOFMEMORY;
                }
                pNew->m_Envelope = pCurve->m_Envelope;
                m_pCurveLists[dwIndex].AddTail(pNew);
            }
        }
    }
    return hr;
}

inline float ValRange(float valToClip, float valMin, float valMax)
{
    return valToClip < valMin
           ? valMin
           : (valToClip > valMax ? valMax : valToClip);
}

HRESULT CParamsManager::GetParamFloat(DWORD dwParamIndex, REFERENCE_TIME rtTime, float *pval)
{
    HRESULT hr = S_OK;

    if (dwParamIndex >= m_cParams)
        return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);
    CCurveList *pList = &m_pCurveLists[dwParamIndex];
    ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
    // if no points, then neutral value
    CCurveItem *pCurve = pList->GetHead();
    if (!pCurve)
    {
        *pval = pInfo->MParamInfo.mpdNeutralValue;
        LeaveCriticalSection(&m_ParamsCriticalSection);
        return S_OK;
    }

    // Find the curve during or before the requested time
    // If the time is during a curve, we will use that.
    // If not, we need the end value of the previous curve.
    // Our list keeps these in backwards order, so we are scanning from the
    // highest point in time backwards.

    for (;pCurve && pCurve->m_Envelope.rtStart > rtTime;pCurve = pCurve->GetNext());

    // If there is no pCurve, there was no curve prior to or during rtTime. Give up.
    if (!pCurve)
    {
        *pval = pInfo->MParamInfo.mpdNeutralValue;
        LeaveCriticalSection(&m_ParamsCriticalSection);
        return S_OK;
    }
    // Now, if pCurve ends before the requested time,
    // return the final value of pCurve, since that will hold until the start of the next curve.
    if (pCurve->m_Envelope.rtEnd < rtTime)
    {
        *pval = pCurve->m_Envelope.valEnd;
        LeaveCriticalSection(&m_ParamsCriticalSection);
        return S_OK;
    }

    // If we get this far, the curve must bound rtTime.

    if (pCurve->m_Envelope.iCurve & MP_CURVE_JUMP)
    {
        *pval = pCurve->m_Envelope.valEnd;
        LeaveCriticalSection(&m_ParamsCriticalSection);
        return S_OK;
    }

    REFERENCE_TIME rtTimeChange = pCurve->m_Envelope.rtEnd - pCurve->m_Envelope.rtStart;
    REFERENCE_TIME rtTimeIntermediate = rtTime - pCurve->m_Envelope.rtStart;

    float fltScalingX = static_cast<float>(rtTimeIntermediate) / rtTimeChange; // horizontal distance along curve between 0 and 1
    float fltScalingY; // height of curve at that point between 0 and 1 based on curve function
    switch (pCurve->m_Envelope.iCurve)
    {
    case MP_CURVE_SQUARE:
        fltScalingY = fltScalingX * fltScalingX;
        break;
    case MP_CURVE_INVSQUARE:
        fltScalingY = (float) sqrt(fltScalingX);
        break;
    case MP_CURVE_SINE:
        //  Maybe we should have a lookup table here?
        fltScalingY = (float) (sin(fltScalingX * 3.1415926535 - (3.1415926535/2)) + 1) / 2;
        break;
    case MP_CURVE_LINEAR:
    default:
        fltScalingY = fltScalingX;
    }
    // Find out if we need to pull the start point from the previous curve,
    // the default neutral value, or the current curve.
    float fStartVal = pCurve->m_Envelope.valStart;
    if (pCurve->m_Envelope.flags & MPF_ENVLP_BEGIN_NEUTRALVAL)
    {
        fStartVal = pInfo->MParamInfo.mpdNeutralValue;
    }
    // Currentval, if it exists, will override neutralval.
    if (pCurve->m_Envelope.flags & MPF_ENVLP_BEGIN_CURRENTVAL)
    {
        // Take advantage of the fact that these are inserted in backwards order.
        // Scan for the previous curve that ends before this time.
        CCurveItem *pPrevious = pCurve->GetNext();
           for (;pPrevious && pPrevious->m_Envelope.rtEnd > rtTime;pPrevious = pPrevious->GetNext());
        if (pPrevious)
        {
            fStartVal = pPrevious->m_Envelope.valEnd;
        }
    }

    // Apply that scaling to the range of the actual points
    *pval = (pCurve->m_Envelope.valEnd - pCurve->m_Envelope.valStart) * fltScalingY + pCurve->m_Envelope.valStart;
    LeaveCriticalSection(&m_ParamsCriticalSection);
    return hr;
}

HRESULT CParamsManager::GetParamInt(DWORD dwParamIndex, REFERENCE_TIME rt, long *pval)
{
    HRESULT hr = E_POINTER;
    if (pval)
    {
        float fVal;
        hr = GetParamFloat(dwParamIndex, rt, &fVal);
        if (SUCCEEDED(hr))
        {
            *pval = (long) (fVal + 1/2);    // Round.
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// IMediaParams

HRESULT CParamsManager::GetParam(DWORD dwParamIndex, MP_DATA *pValue)
{
    V_INAME(CParams::GetParam);
    V_PTR_WRITE(pValue, MP_DATA);
    if (dwParamIndex >= m_cParams)
        return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);

    CCurveList *pList = &m_pCurveLists[dwParamIndex];
    ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
    // if no points, then neutral value
    CCurveItem *pCurve = pList->GetHead();
    if (pCurve)
    {
        *pValue = pCurve->m_Envelope.valEnd;
    }
    else
    {
        *pValue = pInfo->MParamInfo.mpdNeutralValue;
    }
    LeaveCriticalSection(&m_ParamsCriticalSection);
    return S_OK;
}

HRESULT CParamsManager::SetParam(DWORD dwParamIndex, MP_DATA value)
{
    V_INAME(CParams::SetParam);

    if (dwParamIndex >= m_cParams)
        return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);
    m_fDirty = TRUE;
    CCurveList *pList = &m_pCurveLists[dwParamIndex];
    ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
    // If we've already got a list, just force the most recent curve item to this value.
    // Otherwise, create a node and add it.
    CCurveItem *pCurve = pList->GetHead();
    if (!pCurve)
    {
        pCurve = new CCurveItem;
        if (pCurve)
        {
            pCurve->m_Envelope.rtStart =    0x8000000000000000; // Max negative.
            pCurve->m_Envelope.rtEnd =      0x7FFFFFFFFFFFFFFF; // Max positive.
            pCurve->m_Envelope.flags = 0;
            pList->AddHead(pCurve);
        }
        else
        {
            LeaveCriticalSection(&m_ParamsCriticalSection);
            return E_OUTOFMEMORY;
        }
    }
    pCurve->m_Envelope.valStart = value;
    pCurve->m_Envelope.valEnd = value;
    pCurve->m_Envelope.iCurve = MP_CURVE_JUMP;
    LeaveCriticalSection(&m_ParamsCriticalSection);

    return S_OK;
}

HRESULT CParamsManager::AddEnvelope(
    DWORD dwParamIndex,
    DWORD cPoints,
    MP_ENVELOPE_SEGMENT *ppEnvelope)
{
    V_INAME(CParams::AddEnvelope);
    V_PTR_READ(ppEnvelope, *ppEnvelope);

    if (dwParamIndex >= m_cParams)
        return E_INVALIDARG;

    if (!m_pParamInfos)
        return DMUS_E_NOT_INIT;

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_ParamsCriticalSection);
    m_fDirty = TRUE;

    CCurveList *pList = &m_pCurveLists[dwParamIndex];
    ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];

    DWORD dwCount;
    for (dwCount = 0; dwCount < cPoints; dwCount++)
    {
        CCurveItem *pCurve = new CCurveItem;
        if (!pCurve)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        pCurve->m_Envelope = ppEnvelope[dwCount];
        pCurve->m_Envelope.valEnd = ValRange(pCurve->m_Envelope.valEnd,
            pInfo->MParamInfo.mpdMinValue, pInfo->MParamInfo.mpdMaxValue);
        pCurve->m_Envelope.valStart = ValRange(pCurve->m_Envelope.valStart,
            pInfo->MParamInfo.mpdMinValue, pInfo->MParamInfo.mpdMaxValue);
        pList->AddHead(pCurve);
    }

    LeaveCriticalSection(&m_ParamsCriticalSection);

    return hr;
}

HRESULT CParamsManager::FlushEnvelope(
    DWORD dwParamIndex,
    REFERENCE_TIME refTimeStart,
    REFERENCE_TIME refTimeEnd)
{
    if (dwParamIndex >= m_cParams)
        return E_INVALIDARG;

    if (!m_pParamInfos)
        return DMUS_E_NOT_INIT;

    if (refTimeStart >= refTimeEnd)
        return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);
    m_fDirty = TRUE;
    CCurveList *pList = &m_pCurveLists[dwParamIndex];
    ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
    CCurveList TempList;
    CCurveItem *pCurve;
    while (pCurve = pList->RemoveHead())
    {
        if ((pCurve->m_Envelope.rtStart >= refTimeStart) &&
            (pCurve->m_Envelope.rtEnd <= refTimeEnd))
        {
            delete pCurve;
        }
        else
        {
            TempList.AddHead(pCurve);
        }
    }
    while (pCurve = TempList.RemoveHead())
    {
        pList->AddHead(pCurve);
    }
    LeaveCriticalSection(&m_ParamsCriticalSection);

    return S_OK;
}

HRESULT CParamsManager::SetTimeFormat(
    GUID guidTimeFormat,
    MP_TIMEDATA mpTimeData)
{
    if (guidTimeFormat == GUID_TIME_REFERENCE)
    {
        m_fMusicTime = FALSE;
    }
    else if (guidTimeFormat == GUID_TIME_MUSIC)
    {
        m_fMusicTime = TRUE;
    }
    else
    {
        return E_INVALIDARG;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\param.h ===
#ifndef __TOOLPARAM_H__
#define __TOOLPARAM_H__



#include "medparam.h"
#include "alist.h"

typedef struct _ParamInfo
{
    DWORD dwIndex;                      // Which parameter.
    MP_PARAMINFO    MParamInfo;         // Standard MediaParams structure.
    WCHAR *         pwchText;           // Array of text names for enumerated types.
} ParamInfo;

class CCurveItem : public AListItem
{
public:
    CCurveItem* GetNext() { return (CCurveItem*)AListItem::GetNext();}
    MP_ENVELOPE_SEGMENT m_Envelope;     // Envelope segment.
};

class CCurveList : public AList
{
public:
//    void Clear();
    void AddHead(CCurveItem* pCurveItem) { AList::AddHead((AListItem*)pCurveItem);}
//    void Insert(CCurveItem* pCurveItem);
    CCurveItem* GetHead(){return (CCurveItem*)AList::GetHead();}
//    CCurveItem* GetItem(LONG lIndex){return (CCurveItem*)AList::GetItem(lIndex);}
    CCurveItem* RemoveHead(){ return (CCurveItem*)AList::RemoveHead();}
//    void Remove(CCurveItem* pCurveItem){AList::Remove((AListItem*)pCurveItem);}
//    void AddTail(CCurveItem* pCurveItem){AList::AddTail((AListItem*)pCurveItem);}
//    CCurveItem* GetTail(){ return (CCurveItem*)AList::GetTail();}
};

#define MAX_REF_TIME    0x7FFFFFFFFFFFFFFF
#define MP_CAPS_ALL     MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE

class CParamsManager :	public IMediaParams, public IMediaParamInfo
{
public:
    CParamsManager();
    ~CParamsManager();

	// IUnknown
	STDMETHOD(QueryInterface)(REFIID, LPVOID FAR *) PURE;
	STDMETHOD_(ULONG, AddRef)() PURE;
	STDMETHOD_(ULONG, Release)() PURE;

	// IMediaParams
	STDMETHODIMP GetParam(DWORD dwParamIndex, MP_DATA *pValue);
	STDMETHODIMP SetParam( DWORD dwParamIndex,MP_DATA value);
	STDMETHODIMP AddEnvelope(DWORD dwParamIndex,DWORD cPoints,MP_ENVELOPE_SEGMENT *ppEnvelope);
	STDMETHODIMP FlushEnvelope( DWORD dwParamIndex,REFERENCE_TIME refTimeStart,REFERENCE_TIME refTimeEnd);
	STDMETHODIMP SetTimeFormat( GUID guidTimeFormat,MP_TIMEDATA mpTimeData);

    // IMediaParamInfo
    STDMETHODIMP GetParamCount(DWORD *pdwParams);
    STDMETHODIMP GetParamInfo(DWORD dwParamIndex,MP_PARAMINFO *pInfo);
    STDMETHODIMP GetParamText(DWORD dwParamIndex,WCHAR **ppwchText);
    STDMETHODIMP GetNumTimeFormats(DWORD *pdwNumTimeFormats);
    STDMETHODIMP GetSupportedTimeFormat(DWORD dwFormatIndex,GUID *pguidTimeFormat);        
    STDMETHODIMP GetCurrentTimeFormat( GUID *pguidTimeFormat,MP_TIMEDATA *pTimeData);

protected:
    HRESULT InitParams( DWORD cParams, ParamInfo *pParamInfos);
	HRESULT GetParamFloat (DWORD dwParamIndex,REFERENCE_TIME rt,float *pval);
    HRESULT GetParamInt (DWORD dwParamIndex,REFERENCE_TIME rt,long *pval);
    HRESULT CopyParamsFromSource(CParamsManager * pSource);

	// data

	CRITICAL_SECTION m_ParamsCriticalSection;
    BOOL            m_fDirty;       // Has data changed since last file load or save?
	BOOL			m_fMusicTime;	// True if time format is music time, else false for clock time.
	DWORD           m_cParams;		// Nuimber of parameters.
	ParamInfo       *m_pParamInfos; // Array of ParamInfo structures, one for each parameter.
	CCurveList      *m_pCurveLists; // Array of Curve lists, one for each parameter.
};

#endif // __TOOLPARAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\quantize.cpp ===
// Quantize.cpp : Implementation of CQuantizeTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "quantize.h"
#include "toolhelp.h"

CQuantizeTool::CQuantizeTool()
{
    ParamInfo Params[DMUS_QUANTIZE_PARAMCOUNT] = 
    {
        { DMUS_QUANTIZE_STRENGTH, MPT_INT,MP_CAPS_ALL,0,110,80,
            L"Percent",L"Strength",NULL },            // Strength - 80% by default
        { DMUS_QUANTIZE_TIMEUNIT, MPT_ENUM,MP_CAPS_ALL, DMUS_TIME_UNIT_MTIME,DMUS_TIME_UNIT_1,DMUS_TIME_UNIT_GRID,
            L"",L"Resolution Units",L"Music Clicks,Grid,Beat,Bar,64th note triplets,64th notes,32nd note triplets,32nd notes,16th note triplets,16th notes,8th note triplets,8th notes,Quarter note triplets,Quarter notes,Half note triplets,Half notes,Whole note triplets,Whole notes" },
        { DMUS_QUANTIZE_RESOLUTION, MPT_INT,MP_CAPS_ALL,1,1000,1,
            L"",L"Resolution",NULL},   // Resolution - 1 grid note by default
        { DMUS_QUANTIZE_TYPE, MPT_ENUM,MP_CAPS_ALL, DMUS_QUANTIZET_START,DMUS_QUANTIZET_ALL,DMUS_QUANTIZET_START,
            L"",L"Type",L"Start Time,Duration,Start and Duration"} // Type - quantize start time by default
    };
    InitParams(DMUS_QUANTIZE_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CQuantizeTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CQuantizeTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CQuantizeTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicQuantizeTool)
	{
		*ppv = static_cast<IDirectMusicQuantizeTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CQuantizeTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicQuantizeTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CQuantizeTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CQuantizeTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_QUANTIZE_CHUNK))
	{
        DMUS_IO_QUANTIZE_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_QUANTIZE_STRENGTH,(float) Header.dwStrength);
            SetParam(DMUS_QUANTIZE_TIMEUNIT,(float) Header.dwTimeUnit);
            SetParam(DMUS_QUANTIZE_RESOLUTION,(float) Header.dwResolution);
            SetParam(DMUS_QUANTIZE_TYPE,(float) Header.dwType);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CQuantizeTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_QUANTIZE_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_QUANTIZE_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_QUANTIZE_HEADER Header;
        GetParamInt(DMUS_QUANTIZE_STRENGTH,MAX_REF_TIME,(long *)&Header.dwStrength);
        GetParamInt(DMUS_QUANTIZE_TIMEUNIT,MAX_REF_TIME,(long *) &Header.dwTimeUnit);
        GetParamInt(DMUS_QUANTIZE_RESOLUTION,MAX_REF_TIME,(long *) &Header.dwResolution);
        GetParamInt(DMUS_QUANTIZE_TYPE,MAX_REF_TIME,(long *) &Header.dwType);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CQuantizeTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_QUANTIZE_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CQuantizeTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_QuantizePage;
	return NOERROR;
}

/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CQuantizeTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // We need to know the time format so we can call GetParamInt() to read control parameters.
    REFERENCE_TIME rtTime;
    if (m_fMusicTime) rtTime = pPMsg->mtTime;
    else rtTime = pPMsg->rtTime;
    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        IDirectMusicPerformance8 *pPerf8;   // We'll need the DX8 interface to access ClonePMsg.
        if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
        {
            long lStrength, lResolution, lTimeUnit, lType;
            
            GetParamInt(DMUS_QUANTIZE_STRENGTH,rtTime,&lStrength);
            GetParamInt(DMUS_QUANTIZE_RESOLUTION,rtTime,&lResolution);
            GetParamInt(DMUS_QUANTIZE_TIMEUNIT,rtTime,&lTimeUnit);
            GetParamInt(DMUS_QUANTIZE_TYPE,rtTime,&lType);
            DMUS_TIMESIGNATURE TimeSig;
            if (SUCCEEDED(pPerf8->GetParamEx(GUID_TimeSignature,pNote->dwVirtualTrackID,pNote->dwGroupID,DMUS_SEG_ANYTRACK,pNote->mtTime - pNote->nOffset,NULL,&TimeSig)))
            {
                lResolution *= CToolHelper::TimeUnitToTicks(lTimeUnit,&TimeSig);
                if (lResolution < 1) lResolution = 1;
                if ((lType == DMUS_QUANTIZET_START) || (lType == DMUS_QUANTIZET_ALL))
                {
                    MUSIC_TIME mtTime = -TimeSig.mtTime;
                    long lIntervals = (mtTime + (lResolution >> 1)) / lResolution;
                    long lOffset = mtTime - (lIntervals * lResolution);
                    lOffset *= lStrength;
                    lOffset /= 100;
                    pNote->mtTime -= lOffset;
                    pNote->dwFlags &= ~DMUS_PMSGF_REFTIME;
                }
                if ((lType == DMUS_QUANTIZET_LENGTH) || (lType == DMUS_QUANTIZET_ALL))
                {
                    long lIntervals = (pNote->mtDuration + (lResolution >> 1)) / lResolution;
                    if (lIntervals < 1) lIntervals = 1;
                    long lOffset = pNote->mtDuration - (lIntervals * lResolution);
                    lOffset *= lStrength;
                    lOffset /= 100;
                    pNote->mtDuration -= lOffset;
                }
                
            }
            pPerf8->Release();
        }
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CQuantizeTool::Clone( IDirectMusicTool ** ppTool)

{
    CQuantizeTool *pNew = new CQuantizeTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CQuantizeTool::SetStrength(DWORD dwStrength) 
{
    return SetParam(DMUS_QUANTIZE_STRENGTH,(float) dwStrength);
}

STDMETHODIMP CQuantizeTool::SetTimeUnit(DWORD dwTimeUnit) 
{
    return SetParam(DMUS_QUANTIZE_TIMEUNIT,(float) dwTimeUnit);
}

STDMETHODIMP CQuantizeTool::SetResolution(DWORD dwResolution) 
{
    return SetParam(DMUS_QUANTIZE_RESOLUTION,(float) dwResolution);
}

STDMETHODIMP CQuantizeTool::SetType(DWORD dwType) 
{
    return SetParam(DMUS_QUANTIZE_TYPE,(float) dwType);
}

STDMETHODIMP CQuantizeTool::GetStrength(DWORD * pdwStrength) 
{
    return GetParamInt(DMUS_QUANTIZE_STRENGTH,MAX_REF_TIME,(long *) pdwStrength);
}

STDMETHODIMP CQuantizeTool::GetTimeUnit(DWORD * pdwTimeUnit) 
{
    return GetParamInt(DMUS_QUANTIZE_TIMEUNIT,MAX_REF_TIME,(long *) pdwTimeUnit);
}

STDMETHODIMP CQuantizeTool::GetResolution(DWORD * pdwResolution) 
{
    return GetParamInt(DMUS_QUANTIZE_RESOLUTION,MAX_REF_TIME,(long *) pdwResolution);
}

STDMETHODIMP CQuantizeTool::GetType(DWORD * pdwType) 
{
    return GetParamInt(DMUS_QUANTIZE_TYPE,MAX_REF_TIME,(long *) pdwType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\timeshift.h ===
#ifndef _TIMESHIFT_TOOL_
#define _TIMESHIFT_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "..\dmtoolprp\toolprops.h"

class CTimeShiftTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicTimeShiftTool

{
public:
	CTimeShiftTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicTimeShiftTool
    STDMETHODIMP SetTimeUnit(DWORD dwTimeUnit) ;
	STDMETHODIMP SetRange(DWORD dwRange) ;
	STDMETHODIMP SetOffset(long lOffset) ;
    STDMETHODIMP GetTimeUnit(DWORD * pdwTimeUnit) ;
	STDMETHODIMP GetRange(DWORD * pdwRange);
	STDMETHODIMP GetOffset(long * plOffset);
};

#endif // _TIMESHIFT_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\timeshift.cpp ===
// TimeShift.cpp : Implementation of CTimeShiftTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "timeshift.h"
#include "toolhelp.h"


CTimeShiftTool::CTimeShiftTool()
{
    ParamInfo Params[DMUS_TIMESHIFT_PARAMCOUNT] = 
    {
        { DMUS_TIMESHIFT_TIMEUNIT, MPT_ENUM,MP_CAPS_ALL, DMUS_TIME_UNIT_MTIME,DMUS_TIME_UNIT_1,DMUS_TIME_UNIT_GRID,
            L"",L"Resolution Units",L"Music Clicks,Grid,Beat,Bar,64th note triplets,64th notes,32nd note triplets,32nd notes,16th note triplets,16th notes,8th note triplets,8th notes,Quarter note triplets,Quarter notes,Half note triplets,Half notes,Whole note triplets,Whole notes" },
        { DMUS_TIMESHIFT_RANGE, MPT_INT,MP_CAPS_ALL,0,200,0,
            L"Clicks",L"Shift",NULL},        // Time shift - default to 0 (no change)
        { DMUS_TIMESHIFT_OFFSET, MPT_INT,MP_CAPS_ALL,-200,200,0,
            L"Clicks",L"Random Range",NULL},        // Randmomize - default to 0 (no change)
    };
    InitParams(DMUS_TIMESHIFT_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CTimeShiftTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CTimeShiftTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CTimeShiftTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicTimeShiftTool)
	{
		*ppv = static_cast<IDirectMusicTimeShiftTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CTimeShiftTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicTimeShiftTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CTimeShiftTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CTimeShiftTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_TIMESHIFT_CHUNK))
	{
        DMUS_IO_TIMESHIFT_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_TIMESHIFT_TIMEUNIT,(float) Header.dwTimeUnit);
            SetParam(DMUS_TIMESHIFT_RANGE,(float) Header.dwRange);
            SetParam(DMUS_TIMESHIFT_OFFSET,(float) Header.lOffset);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CTimeShiftTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_TIMESHIFT_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_TIMESHIFT_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_TIMESHIFT_HEADER Header;
        GetParamInt(DMUS_TIMESHIFT_TIMEUNIT,MAX_REF_TIME,(long *) &Header.dwTimeUnit);
        GetParamInt(DMUS_TIMESHIFT_RANGE,MAX_REF_TIME,(long *)&Header.dwRange);
        GetParamInt(DMUS_TIMESHIFT_OFFSET,MAX_REF_TIME,&Header.lOffset);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CTimeShiftTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_TIMESHIFT_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CTimeShiftTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_TimeShiftPage;

	return NOERROR;
}


/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CTimeShiftTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // Only adjust the timing of notes. 
    if( pPMsg->dwType == DMUS_PMSGT_NOTE ) 
    {
        REFERENCE_TIME rtTime;
        if (m_fMusicTime) rtTime = pPMsg->mtTime;
        else rtTime = pPMsg->rtTime;
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        IDirectMusicPerformance8 *pPerf8;   // We'll need the DX8 interface to access ClonePMsg.
        if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
        {
            long lOffset;
            DWORD dwRange;
            long lTimeUnit;
            GetParamInt(DMUS_TIMESHIFT_TIMEUNIT,rtTime,&lTimeUnit);
            GetParamInt(DMUS_TIMESHIFT_RANGE,rtTime,(long *)&dwRange);
            GetParamInt(DMUS_TIMESHIFT_OFFSET,rtTime,&lOffset);
            DMUS_TIMESIGNATURE TimeSig;
            if (SUCCEEDED(pPerf8->GetParamEx(GUID_TimeSignature,pNote->dwVirtualTrackID,pNote->dwGroupID,DMUS_SEG_ANYTRACK,pNote->mtTime,NULL,&TimeSig)))
            {
                long lResolution = CToolHelper::TimeUnitToTicks(lTimeUnit,&TimeSig);
                if (lResolution < 1) lResolution = 1;
                if (dwRange)
                {
                    dwRange *= lResolution;
                    pNote->mtTime += (rand() % (dwRange << 1)) - dwRange;
                    pNote->dwFlags &= ~DMUS_PMSGF_REFTIME;
                }
                if (lOffset)
                {
                    lOffset *= lResolution;
                    pNote->mtTime += lOffset;
                    pNote->dwFlags &= ~DMUS_PMSGF_REFTIME;
                }
            }
            pPerf8->Release();
        }   
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CTimeShiftTool::Clone( IDirectMusicTool ** ppTool)

{
    CTimeShiftTool *pNew = new CTimeShiftTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CTimeShiftTool::SetTimeUnit(DWORD dwTimeUnit) 
{
    return SetParam(DMUS_TIMESHIFT_TIMEUNIT,(float) dwTimeUnit);
}

STDMETHODIMP CTimeShiftTool::SetRange( DWORD dwRange) 
{
    return SetParam(DMUS_TIMESHIFT_RANGE,(float)dwRange);
}

STDMETHODIMP CTimeShiftTool::SetOffset( long lOffset)
{
    return SetParam(DMUS_TIMESHIFT_OFFSET,(float)lOffset);
}

STDMETHODIMP CTimeShiftTool::GetTimeUnit(DWORD * pdwTimeUnit) 
{
    return GetParamInt(DMUS_TIMESHIFT_TIMEUNIT,MAX_REF_TIME,(long *) pdwTimeUnit);
}

STDMETHODIMP CTimeShiftTool::GetRange(DWORD *pdwRange) 
{
    return GetParamInt(DMUS_TIMESHIFT_RANGE,MAX_REF_TIME, (long *) pdwRange);
}

STDMETHODIMP CTimeShiftTool::GetOffset(long *plOffset) 
{
    return GetParamInt(DMUS_TIMESHIFT_OFFSET,MAX_REF_TIME, plOffset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolhelp.cpp ===
// ToolHelp.cpp : Global functions.
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "toolhelp.h"

long CToolHelper::m_slMIDIToDB[128] = {       // Global array used to convert MIDI to dB. 
    -9600, -8415, -7211, -6506, -6006, -5619, -5302, -5034, 
    -4802, -4598, -4415, -4249, -4098, -3959, -3830, -3710, 
    -3598, -3493, -3394, -3300, -3211, -3126, -3045, -2968, 
    -2894, -2823, -2755, -2689, -2626, -2565, -2506, -2449, 
    -2394, -2341, -2289, -2238, -2190, -2142, -2096, -2050, 
    -2006, -1964, -1922, -1881, -1841, -1802, -1764, -1726, 
    -1690, -1654, -1619, -1584, -1551, -1518, -1485, -1453, 
    -1422, -1391, -1361, -1331, -1302, -1273, -1245, -1217, 
    -1190, -1163, -1137, -1110, -1085, -1059, -1034, -1010, 
    -985, -961, -938, -914, -891, -869, -846, -824, 
    -802, -781, -759, -738, -718, -697, -677, -657, 
    -637, -617, -598, -579, -560, -541, -522, -504, 
    -486, -468, -450, -432, -415, -397, -380, -363, 
    -347, -330, -313, -297, -281, -265, -249, -233, 
    -218, -202, -187, -172, -157, -142, -127, -113, 
    -98, -84, -69, -55, -41, -27, -13, 0
};


long CToolHelper::m_slDBToMIDI[97] = {        // Global array used to convert db to MIDI.
    127, 119, 113, 106, 100, 95, 89, 84, 80, 75, 
    71, 67, 63, 60, 56, 53, 50, 47, 45, 42, 
    40, 37, 35, 33, 31, 30, 28, 26, 25, 23, 
    22, 21, 20, 19, 17, 16, 15, 15, 14, 13, 
    12, 11, 11, 10, 10, 9, 8, 8, 8, 7, 
    7, 6, 6, 6, 5, 5, 5, 4, 4, 4, 
    4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 
    2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0
};

long CToolHelper::m_slResTypes[DMUS_TIME_UNIT_COUNT] = 
{ 1,    // DMUS_TIME_UNIT_MS
  1,    // DMUS_TIME_UNIT_MTIME 
  384,  // DMUS_TIME_UNIT_GRID
  768,  // DMUS_TIME_UNIT_BEAT
  3072, // DMUS_TIME_UNIT_BAR
  32,   // DMUS_TIME_UNIT_64T
  48,   // DMUS_TIME_UNIT_64
  64,   // DMUS_TIME_UNIT_32T  
  96,   // DMUS_TIME_UNIT_32 
  128,  // DMUS_TIME_UNIT_16T     
  192,  // DMUS_TIME_UNIT_16     
  256,  // DMUS_TIME_UNIT_8T    
  384,  // DMUS_TIME_UNIT_8         
  512,  // DMUS_TIME_UNIT_4T  
  768,  // DMUS_TIME_UNIT_4         
  1024, // DMUS_TIME_UNIT_2T   
  1536, // DMUS_TIME_UNIT_2   
  2048, // DMUS_TIME_UNIT_1T
  3072  // DMUS_TIME_UNIT_1
};


BYTE CToolHelper::VolumeToMidi(long lVolume)

{
    if (lVolume < -9600) lVolume = -9600;
    if (lVolume > 0) lVolume = 0;
    lVolume = -lVolume;
    long lFraction = lVolume % 100;
    lVolume = lVolume / 100;
    long lResult = m_slDBToMIDI[lVolume];
    lResult += ((m_slDBToMIDI[lVolume + 1] - lResult) * lFraction) / 100;
    return (BYTE) lResult;
}

long CToolHelper::MidiToVolume(BYTE bMidi)

{
    if (bMidi > 127) bMidi = 127;
    return m_slMIDIToDB[bMidi];
}

long CToolHelper::TimeUnitToTicks(long lTimeUnit,DMUS_TIMESIGNATURE *pTimeSig) 
{ 
    long lTicks;
    if (lTimeUnit > DMUS_TIME_UNIT_BAR)
    {
        lTicks = m_slResTypes[lTimeUnit];
    }
    else if ((lTimeUnit >= DMUS_TIME_UNIT_GRID) && pTimeSig)
    {
        DWORD dwBeat = (4 * 768) / pTimeSig->bBeat;
        if (lTimeUnit == DMUS_TIME_UNIT_BEAT)
        {
            lTicks = dwBeat;
        }
        else if (lTimeUnit == DMUS_TIME_UNIT_GRID)
        {
            lTicks = (dwBeat / pTimeSig->wGridsPerBeat);
        }
        else 
        {
            lTicks = (dwBeat * pTimeSig->bBeatsPerMeasure);
        }
    }
    else lTicks = 0;
    return lTicks;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\swing.h ===
#ifndef _SWING_TOOL_
#define _SWING_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "..\dmtoolprp\toolprops.h"

class CSwingTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicSwingTool

{
public:
	CSwingTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicSwingTool
	STDMETHODIMP SetStrength(DWORD dwStrength) ;
	STDMETHODIMP GetStrength(DWORD * pdwStrength) ;
protected:	
};

#endif // _SWING_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolhelp.h ===
#ifndef _TOOL_HELP_
#define _TOOL_HELP_

#include "dmusici.h"
#include "tools.h"

// Global class that provides various useful methods.

class CToolHelper 
{
public:
    BYTE VolumeToMidi(long lVolume);
    long MidiToVolume(BYTE bMidi);
    long TimeUnitToTicks(long lTimeUnit,DMUS_TIMESIGNATURE *pTimeSig);
private:
    static long m_slMIDIToDB[128];   // Array for converting MIDI to centibel volume.
    static long m_slDBToMIDI[97];    // For converting volume to MIDI.
    static long m_slResTypes[DMUS_TIME_UNIT_COUNT]; // Array for converting time units into ticks.
};

class CMusicVal
{
public:
    CMusicVal(WORD wMusicVal);
    WORD GetValue();
	void operator+=(CMusicVal Val);
    void operator+=(short nScale);  // Most common transposition would be by scale.
	void operator-=(CMusicVal Val);
	CMusicVal operator+(CMusicVal Val) const;
	CMusicVal operator-(CMusicVal Val) const;
private:
    void CleanUp();
    short       m_sOctave;
    short       m_sChord;
    short       m_sScale;
    short       m_sAccidental;
};

/*inline void CMusicVal::operator +

inline void CPoint::operator-=(SIZE size)
	{ x -= size.cx; y -= size.cy; }
_AFXWIN_INLINE void CPoint::operator+=(POINT point)
	{ x += point.x; y += point.y; }
_AFXWIN_INLINE void CPoint::operator-=(POINT point)
	{ x -= point.x; y -= point.y; }
_AFXWIN_INLINE CPoint CPoint::operator+(SIZE size) const
	{ return CPoint(x + size.cx, y + size.cy); }
_AFXWIN_INLINE CPoint CPoint::operator-(SIZE size) const
	{ return CPoint(x - size.cx, y - size.cy); }
*/
inline CMusicVal::CMusicVal(WORD wMusicVal)

{
    m_sAccidental = wMusicVal & 0xF;
    if (wMusicVal & 0x8) // Negative?
    {
        m_sAccidental |= 0xFFF0;    // Yes, extend sign bit.
    }
    m_sScale = (wMusicVal & 0xF0) >> 4;
    m_sChord = (wMusicVal & 0xF00) >> 8;
    m_sOctave = wMusicVal >> 12;
    if (m_sOctave > 14) // We count the top two octaves as negative.
    {
        m_sOctave -= 16;
    }
}

inline WORD CMusicVal::GetValue()

{
    CleanUp();
    return (WORD) ((m_sOctave << 12) | (m_sChord << 8) | (m_sScale << 4) | (m_sAccidental & 0xF));
}

inline void CMusicVal::CleanUp()

{
    while (m_sAccidental < -8)
    {
        // This should never happen, but it does, do approximate math.
        m_sAccidental += 2;
        m_sScale -= 1;
    }
    while (m_sAccidental > 7)
    {
        // Likewise, this should not happen, so resulting math isn't perfect.
        m_sAccidental -= 2;
        m_sScale += 1;
    }
    while (m_sScale < 0)
    {
        m_sScale += 2;
        m_sChord -= 1;
    }
    while (m_sScale > 7)
    {
        m_sScale -= 2;
        m_sChord += 1;
    }
    while (m_sChord < 0)
    {
        m_sChord += 4;
        m_sOctave -= 1;
    }
    while (m_sChord > 4)
    {
        m_sChord -= 4;
        m_sOctave += 1;
    }
    while (m_sOctave < -2)
    {
        m_sOctave++;
    }
    while (m_sOctave >= 14)
    {
        m_sOctave--;
    }
}

inline void CMusicVal::operator+=(CMusicVal Val)

{ 
    m_sOctave += Val.m_sOctave;
    m_sChord += Val.m_sChord;
    m_sScale += Val.m_sScale;
    m_sAccidental  += Val.m_sAccidental;
}

inline void CMusicVal::operator+=(short nScale)

{ 
    m_sScale += nScale;
}


#endif // _TOOL_HELP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\dmusic.inc
!include $(DXROOT)\project.mk

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmtool

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF



TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\dmtool.def
DLLENTRY=_DllMainCRTStartup
USE_MAPSYM=1
USE_MSVCRT=1


!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif


C_DEFINES= $(C_DEFINES) -D_WIN32


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib		\
	   $(SDK_LIB_PATH)\advapi32.lib		\
           $(SDK_LIB_PATH)\ole32.lib        \
           $(SDK_LIB_PATH)\uuid.lib

INCLUDES=$(INCLUDES) \
    $(DXROOT)\dmusic\shared

SOURCES=\
    ..\alist.cpp                \
    ..\debug.cpp                \
    ..\dll.cpp                  \
    ..\duration.cpp             \
    ..\echo.cpp                 \
    ..\guids.cpp                \
    ..\oledll.cpp               \
    ..\param.cpp                \
	..\swing.cpp				\
    ..\toolhelp.cpp             \
    ..\transpose.cpp			\
	..\quantize.cpp				\
	..\timeshift.cpp			\
	..\velocity.cpp				\
	..\toolprop_i.c				\
    ..\medparam_i.c				\
	..\dmtool.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\quantize.h ===
#ifndef _QUANTIZE_TOOL_
#define _QUANTIZE_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "..\dmtoolprp\toolprops.h"

class CQuantizeTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicQuantizeTool

{
public:
	CQuantizeTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicQuantizeTool
	STDMETHODIMP SetStrength(DWORD dwStrength) ;
    STDMETHODIMP SetTimeUnit(DWORD dwTimeUnit) ;
	STDMETHODIMP SetResolution(DWORD dwResolution) ;
	STDMETHODIMP SetType(DWORD dwType) ;
	STDMETHODIMP GetStrength(DWORD * pdwStrength) ;
    STDMETHODIMP GetTimeUnit(DWORD * pdwTimeUnit) ;
	STDMETHODIMP GetResolution(DWORD * pdwResolution) ;
	STDMETHODIMP GetType(DWORD * pdwType) ;
protected:	
};

#endif // _QUANTIZE_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\swing.cpp ===
// Swing.cpp : Implementation of CSwingTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "swing.h"
#include "toolhelp.h"

CSwingTool::CSwingTool()
{
    ParamInfo Params[DMUS_SWING_PARAMCOUNT] = 
    {
        { DMUS_SWING_STRENGTH, MPT_INT,MP_CAPS_ALL,0,100,100,
            L"Percent",L"Strength",NULL },            // Strength - 100% by default
    };
    InitParams(DMUS_SWING_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CSwingTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSwingTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSwingTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicSwingTool)
	{
		*ppv = static_cast<IDirectMusicSwingTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CSwingTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicSwingTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CSwingTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CSwingTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_SWING_CHUNK))
	{
        DMUS_IO_SWING_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_SWING_STRENGTH,(float) Header.dwStrength);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CSwingTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_SWING_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_SWING_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_SWING_HEADER Header;
        GetParamInt(DMUS_SWING_STRENGTH,MAX_REF_TIME,(long *)&Header.dwStrength);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CSwingTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_SWING_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CSwingTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_SwingPage;
	return NOERROR;
}


/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CSwingTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // We need to know the time format so we can call GetParamInt() to read control parameters.
    REFERENCE_TIME rtTime;
    if (m_fMusicTime) rtTime = pPMsg->mtTime;
    else rtTime = pPMsg->rtTime;
    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        IDirectMusicPerformance8 *pPerf8;   // We'll need the DX8 interface to access ClonePMsg.
        if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
        {
            long lStrength;
            
            GetParamInt(DMUS_SWING_STRENGTH,rtTime,&lStrength);
            DMUS_TIMESIGNATURE TimeSig;
            if (SUCCEEDED(pPerf8->GetParamEx(GUID_TimeSignature,pNote->dwVirtualTrackID,pNote->dwGroupID,DMUS_SEG_ANYTRACK,pNote->mtTime,NULL,&TimeSig)))
            {
                long lGrid = ((4 * 768) / TimeSig.bBeat) / TimeSig.wGridsPerBeat;
                if ((TimeSig.wGridsPerBeat == 3) || (TimeSig.wGridsPerBeat == 6) || 
                    (TimeSig.wGridsPerBeat == 9) || (TimeSig.wGridsPerBeat == 12))
                {
                    // This is already in a triplet feel, so work in reverse.
                    // Adjust the timing, as set by the lStrength parameter.
                    // lStrength is a range from 0 for no swing to 100 for full swing.
                    // We are moving from grids 0,1,2,3,4,5... in triplet feel to grids 
                    // 0,1,2,4,5,6... in non-triplet feel.
                    // So, the notes need to be adjusted in time in either direction.
                    // When we change the time, we clear the DMUS_PMSGF_REFTIME flag, 
                    // telling the performance to recalculate the reference time stamp
                    // in the event when it is requeued.
                    static long lFromTriplet[12] = { 0,1,2,4,5,6,8,9,10,12,13,14 };
                    if (pNote->bGrid < 12)
                    {
                        // Calculate the position we are moving to.
                        long lTwoplet = ((lGrid * 3) / 4) * lFromTriplet[pNote->bGrid];
                        // Calculate the position we are moving from. 
                        lGrid *= pNote->bGrid;
                        // Calculate the new time. Note that we inverse strength since we are going from triplet.
                        pNote->mtTime += ((100 - lStrength) * (lTwoplet - lGrid)) / 100;
		                pNote->dwFlags &= ~DMUS_PMSGF_REFTIME;
                    }
                }
                else if (TimeSig.wGridsPerBeat <= 16)
                {
                    // Adjust the timing, as set by the lStrength parameter.
                    // lStrength is a range from 0 for no swing to 100 for full swing.
                    // We are moving from grids 0,1,2,3 in straight ahead feel to grids 
                    // 0,1,2 in triplet feel.
                    // So, the notes need to be adjusted in time in either direction.
                    // When we change the time, we clear the DMUS_PMSGF_REFTIME flag, 
                    // telling the performance to recalculate the reference time stamp
                    // in the event when it is requeued.
                    static long lToTriplet[16] = { 0,1,2,2,3,4,5,5,6,7,8,8,9,10,11,11 };
                    if (pNote->bGrid < 16)
                    {
                        // Calculate the position we are moving to.
                        long lTriplet = ((lGrid * 4) / 3) * lToTriplet[pNote->bGrid];
                        // Calculate the position we are moving from. 
                        Trace(0,"%ld,%ld,%ld,%ld\t%ld,%ld,%ld\t",
                            (long)TimeSig.bBeatsPerMeasure,(long)TimeSig.bBeat,(long)TimeSig.wGridsPerBeat,
                            lGrid,(long)pNote->bBeat,(long)pNote->bGrid,(long)pNote->nOffset);
                        lGrid *= pNote->bGrid;
                        Trace(0,"%ld,%ld,%ld\n",lStrength,lTriplet,lGrid);
                        pNote->mtTime += (lStrength * (lTriplet - lGrid)) / 100;
		                pNote->dwFlags &= ~DMUS_PMSGF_REFTIME;
                    }
                }
            }
            pPerf8->Release();
        }
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CSwingTool::Clone( IDirectMusicTool ** ppTool)

{
    CSwingTool *pNew = new CSwingTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CSwingTool::SetStrength(DWORD dwStrength) 
{
    return SetParam(DMUS_SWING_STRENGTH,(float) dwStrength);
}

STDMETHODIMP CSwingTool::GetStrength(DWORD * pdwStrength) 
{
    return GetParamInt(DMUS_SWING_STRENGTH,MAX_REF_TIME,(long *) pdwStrength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprop_i.c ===
#include <toolprops_i.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\velocity.h ===
#ifndef _VELOCITY_TOOL_
#define _VELOCITY_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "..\dmtoolprp\toolprops.h"

class CVelocityTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicVelocityTool

{
public:
	CVelocityTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicVelocityTool
	STDMETHODIMP SetStrength(long lStrength) ;
    STDMETHODIMP SetLowLimit(long lVelocityOut) ;
    STDMETHODIMP SetHighLimit(long lVelocityOut) ;
    STDMETHODIMP SetCurveStart(long lVelocityIn) ;
    STDMETHODIMP SetCurveEnd(long lVelocityIn) ;

	STDMETHODIMP GetStrength(long * plStrength) ;
    STDMETHODIMP GetLowLimit(long * plVelocityOut) ;
    STDMETHODIMP GetHighLimit(long * plVelocityOut) ;
    STDMETHODIMP GetCurveStart(long * plVelocityIn) ;
    STDMETHODIMP GetCurveEnd(long * plVelocityIn) ;

protected:	
};

#endif // _VELOCITY_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\controlhelp.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Implementation of CSliderValue.
//

#include "stdafx.h"
#include "ControlHelp.h"
#include <commctrl.h>

//////////////////////////////////////////////////////////////////////////////
// CSliderValue

const short g_sMaxContinuousTicks = 100;
const int g_iMaxCharBuffer = 50; // # characters big enough to hold -FLT_MAX with room to spare

CSliderValue::CSliderValue()
  : m_fInit(false)
{
}

void CSliderValue::SetRange(float fMin, float fMax)

{
    if (m_fInit)
    {
        m_fMin = fMin;
        m_fMax = fMax;

        short sMin;
        short sMax;
        short sTicks = 4; // Lots of ticks become less useful as guides.  Use quarters for fine-grained sliders.
        if (m_fDiscrete) 
        {
            sMin = static_cast<short>(fMin);
            sMax = static_cast<short>(fMax);
            if (sMax - sMin <= 10)
                sTicks = sMax - sMin;
        }
        else
        {
            sMin = 0;
            sMax = g_sMaxContinuousTicks;
        }
    
        SendMessage(m_hwndSlider, TBM_SETRANGE, TRUE, MAKELONG(sMin, sMax));
        SendMessage(m_hwndSlider, TBM_SETTICFREQ, (sMax - sMin) / sTicks, 0);
    }
}

void CSliderValue::Init(
        HWND        hwndSlider,
        HWND        hwndEdit,
        float       fMin, 
        float       fMax, 
        bool        fDiscrete)
{
    if (m_fInit)
        return;

    m_hwndSlider = hwndSlider;
    m_hwndEdit = hwndEdit;
    m_fDiscrete = fDiscrete;
    m_fInit = true;
    SetRange(fMin,fMax);
}

void CSliderValue::SetValue(float fPos)
{
    if (!m_fInit)
        return;

    UpdateEditBox(fPos);
    UpdateSlider();
}

float CSliderValue::GetValue()
{
    if (!m_fInit)
        return 0;

    LRESULT lrLen = SendMessage(m_hwndEdit, WM_GETTEXTLENGTH, 0, 0);
    if (lrLen >= g_iMaxCharBuffer)
        return 0;

    char szText[g_iMaxCharBuffer] = "";
    SendMessage(m_hwndEdit, WM_GETTEXT, g_iMaxCharBuffer, reinterpret_cast<LPARAM>(szText));

    float fVal = static_cast<float>(m_fDiscrete ? atoi(szText) : atof(szText));

    if (fVal < m_fMin) fVal = m_fMin;
    if (fVal > m_fMax) fVal = m_fMax;
    return fVal;
}

float CSliderValue::GetSliderValue()
{
    short sPos = static_cast<short>(SendMessage(m_hwndSlider, TBM_GETPOS, 0, 0));
    if (m_fDiscrete)
    {
        return sPos;
    }

    float fRet = (m_fMax - m_fMin) * sPos / g_sMaxContinuousTicks + m_fMin;
    return fRet;
}

LRESULT CSliderValue::MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_fInit)
        return FALSE;

    switch (uMsg)
    {
    case WM_HSCROLL:
        if (bHandled = (reinterpret_cast<HWND>(lParam) == m_hwndSlider && LOWORD(wParam) >= TB_LINEUP && LOWORD(wParam) <= TB_ENDTRACK))
            UpdateEditBox(GetSliderValue());
        break;

    case WM_COMMAND:
        if (bHandled = (HIWORD(wParam) == EN_KILLFOCUS && reinterpret_cast<HWND>(lParam) == m_hwndEdit))
            UpdateSlider();
        break;

    default:
        bHandled = FALSE;
        break;
    }

    return 0;
}

void CSliderValue::UpdateEditBox(float fPos)
{
    char szText[g_iMaxCharBuffer] = "";

    if (m_fDiscrete)
    {
        short sPos = static_cast<short>(fPos);
        sprintf(szText, "%hd", sPos);
    }
    else
    {
        sprintf(szText, "%.3hf", fPos);
    }

    SendMessage(m_hwndEdit, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(szText));
}

void CSliderValue::UpdateSlider()
{
    float fVal = GetValue();
    short sPos = static_cast<short>(m_fDiscrete ? fVal : g_sMaxContinuousTicks * ((fVal - m_fMin) / (m_fMax - m_fMin)));
    SendMessage(m_hwndSlider, TBM_SETPOS, TRUE, sPos);
    UpdateEditBox(fVal); // this resets the input box back to the set float value in case the input was invalid
}

CComboHelp::CComboHelp()
{
    m_hwndCombo = NULL;
    m_fInit = FALSE;
}

void CComboHelp::Init(HWND hwndCombo, int nID, char *pStrings[], DWORD cbStrings)
{
    DWORD dwIndex;
    m_hwndCombo = hwndCombo;
    m_nID = nID;
    for (dwIndex = 0; dwIndex < cbStrings; dwIndex++)
    {
        SendMessage( hwndCombo,CB_ADDSTRING,0,(LPARAM)pStrings[dwIndex]);
    }
    m_fInit = TRUE;
}

void CComboHelp::SetValue(DWORD dwValue)
{
    SendMessage(m_hwndCombo,CB_SETCURSEL,dwValue,0);
}

DWORD CComboHelp::GetValue()
{
    return SendMessage( m_hwndCombo,CB_GETCURSEL,0,0);
}

LRESULT CComboHelp::MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_fInit)
        return FALSE;

    switch (uMsg)
    {
    case WM_COMMAND:
        bHandled = ((HIWORD(wParam) == CBN_SELCHANGE) && (LOWORD(wParam) == m_nID));
        break;
    default:
        bHandled = FALSE;
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\controlhelp.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Declaration of CSliderValue.
//

#pragma once

class CSliderValue
{
public:
    CSliderValue();
    void Init(HWND hwndSlider, HWND hwndEdit, float fMin, float fMax, bool fDiscrete);
    void SetRange(float fMin, float fMax);
    void SetValue(float fPos);
    float GetValue();

    LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    bool                m_fInit;
    HWND                m_hwndSlider;
    HWND                m_hwndEdit;
    float               m_fMin;
    float               m_fMax;
    bool                m_fDiscrete;

private:
    float GetSliderValue();
    void UpdateEditBox(float fPos);
    void UpdateSlider();
};

class CComboHelp
{
public:
    CComboHelp();
    void Init(HWND hwndCombo, int nID, char *pStrings[], DWORD cbStrings);
    void SetValue(DWORD dwValue);
    DWORD GetValue();
    LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
private:
    bool                m_fInit;
    int                 m_nID;
    HWND                m_hwndCombo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\tools.h ===
#ifndef _TOOLS_H_
#define _TOOLS_H_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

/*  Time unit types. This is used by various tools to define the format for units of time. */

#define DMUS_TIME_UNIT_MS        0   /* Milliseconds. */
#define DMUS_TIME_UNIT_MTIME     1   /* Music Time. */
#define DMUS_TIME_UNIT_GRID      2   /* Grid size in current time signature. */
#define DMUS_TIME_UNIT_BEAT      3   /* Beat size in current time signature. */
#define DMUS_TIME_UNIT_BAR       4   /* Measure size in current time signature. */
#define DMUS_TIME_UNIT_64T       5   /* 64th note triplet. */
#define DMUS_TIME_UNIT_64        6   /* 64th note. */
#define DMUS_TIME_UNIT_32T       7   /* 32nd note triplet. */
#define DMUS_TIME_UNIT_32        8   /* 32nd note. */
#define DMUS_TIME_UNIT_16T       9   /* 16th note triplet. */
#define DMUS_TIME_UNIT_16        10  /* 16th note. */
#define DMUS_TIME_UNIT_8T        11  /* 8th note tripplet. */
#define DMUS_TIME_UNIT_8         12  /* 8th note. */
#define DMUS_TIME_UNIT_4T        13  /* Quarter note triplet. */
#define DMUS_TIME_UNIT_4         14  /* Quarter note. */
#define DMUS_TIME_UNIT_2T        15  /* Half note triplet. */
#define DMUS_TIME_UNIT_2         16  /* Half note. */
#define DMUS_TIME_UNIT_1T        17  /* Whole note triplet. */
#define DMUS_TIME_UNIT_1         18  /* Whole note. */

#define DMUS_TIME_UNIT_COUNT     19  /* Number of time unit types. */


interface IDirectMusicEchoTool;
#ifndef __cplusplus 
typedef interface IDirectMusicEchoTool IDirectMusicEchoTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicEchoTool
DECLARE_INTERFACE_(IDirectMusicEchoTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicEchoTool */
    STDMETHOD(SetRepeat)            (THIS_ DWORD dwRepeat) PURE;
    STDMETHOD(SetDecay)             (THIS_ DWORD dwDecay) PURE;
    STDMETHOD(SetTimeUnit)          (THIS_ DWORD dwTimeUnit) PURE;
    STDMETHOD(SetDelay)             (THIS_ DWORD dwDelay) PURE;
    STDMETHOD(SetGroupOffset)       (THIS_ DWORD dwGroupOffset) PURE;
    STDMETHOD(SetType)              (THIS_ DWORD dwType) PURE;

    STDMETHOD(GetRepeat)            (THIS_ DWORD * pdwRepeat) PURE;
    STDMETHOD(GetDecay)             (THIS_ DWORD * pdwDecay) PURE;
    STDMETHOD(GetTimeUnit)          (THIS_ DWORD * pdwTimeUnit) PURE;
    STDMETHOD(GetDelay)             (THIS_ DWORD * pdwDelay) PURE;
    STDMETHOD(GetGroupOffset)       (THIS_ DWORD * pdwGroupOffset) PURE;
    STDMETHOD(GetType)              (THIS_ DWORD * pdwType) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_ECHO_REPEAT        0   /* How many times to repeat. */
#define DMUS_ECHO_DECAY         1   /* Decay, in decibels, between repeats. */
#define DMUS_ECHO_TIMEUNIT      2   /* Time unit used for converting the delay into music time. */
#define DMUS_ECHO_DELAY         3   /* Duration of time between echoes, in music time. */
#define DMUS_ECHO_GROUPOFFSET   4   /* Offset to add to PChannel in multiples of 16 for routing each echo to a separate output Pchannel. */
#define DMUS_ECHO_TYPE          5   /* Type of echo. (See DMUS_ECHOT_ values.) */

#define DMUS_ECHO_PARAMCOUNT    6   /* Number of parameters (above.) */

/*  Echo types. */

#define DMUS_ECHOT_FALLING      0   /* Regular echo, decreases in velocity with each one. */
#define DMUS_ECHOT_FALLING_CLIP 1   /* Regular echo, truncate notes lengths to just under decay time. */
#define DMUS_ECHOT_RISING       2   /* Echo starts quiet, increases to full velocity. */
#define DMUS_ECHOT_RISING_CLIP  3   /* Rising echo, truncate the lengths. */

#define FOURCC_ECHO_CHUNK        mmioFOURCC('e','c','h','o')

typedef struct _DMUS_IO_ECHO_HEADER
{
    DWORD   dwRepeat;       /* How many times to repeat. */
    DWORD   dwDecay;        /* Decay, in decibels, between repeats. */
    DWORD   dwTimeUnit;     /* Time format used for dwDelay. */
    DWORD   dwDelay;        /* Duration of time between echoes, in units defined by dwTimeUnit. */
    DWORD   dwGroupOffset;  /* Offset to add to PChannel for routing each echo. */
    DWORD   dwType;         /* Type of echo. (See DMUS_ECHOT_ values.) */
} DMUS_IO_ECHO_HEADER;

interface IDirectMusicTransposeTool;
#ifndef __cplusplus 
typedef interface IDirectMusicTransposeTool IDirectMusicTransposeTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicTransposeTool
DECLARE_INTERFACE_(IDirectMusicTransposeTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicTransposeTool */
    STDMETHOD(SetTranspose)         (THIS_ long lTranspose) PURE;
    STDMETHOD(SetType)              (THIS_ DWORD dwType) PURE;

    STDMETHOD(GetTranspose)         (THIS_ long * plTranspose) PURE;
    STDMETHOD(GetType)              (THIS_ DWORD * pdwType) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_TRANSPOSE_AMOUNT   0   /* How far up or down to transpose. */
#define DMUS_TRANSPOSE_TYPE     1   /* Transpose style (linear vs in scale.) */

#define DMUS_TRANSPOSE_PARAMCOUNT    2   /* Number of parameters (above.) */

/*  Transposition types. */

#define DMUS_TRANSPOSET_LINEAR  0   /* Transpose in linear increments. */
#define DMUS_TRANSPOSET_SCALE   1   /* Transpose in scale. */

#define FOURCC_TRANSPOSE_CHUNK        mmioFOURCC('t','r','a','n')

typedef struct _DMUS_IO_TRANSPOSE_HEADER
{
    long    lTranspose;     /* Transpose amount. */
    DWORD   dwType;         /* Type of echo. (See DMUS_ECHOT_ values.) */
} DMUS_IO_TRANSPOSE_HEADER;


interface IDirectMusicDurationTool;
#ifndef __cplusplus 
typedef interface IDirectMusicDurationTool IDirectMusicDurationTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicDurationTool
DECLARE_INTERFACE_(IDirectMusicDurationTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicDurationTool */
    STDMETHOD(SetScale)             (THIS_ float flScale) PURE;

    STDMETHOD(GetScale)             (THIS_ float * pflScale) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_DURATION_SCALE    0   /* Duration multiplier. */

#define DMUS_DURATION_PARAMCOUNT    1   /* Number of parameters (above.) */

#define FOURCC_DURATION_CHUNK        mmioFOURCC('d','u','r','a')

typedef struct _DMUS_IO_DURATION_HEADER
{
    float   flScale;                /* Duration multiplier. */
} DMUS_IO_DURATION_HEADER;


interface IDirectMusicQuantizeTool;
#ifndef __cplusplus 
typedef interface IDirectMusicQuantizeTool IDirectMusicQuantizeTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicQuantizeTool
DECLARE_INTERFACE_(IDirectMusicQuantizeTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicQuantizeTool */
    STDMETHOD(SetStrength)          (THIS_ DWORD dwStrength) PURE;
    STDMETHOD(SetTimeUnit)          (THIS_ DWORD dwTimeUnit) PURE;
    STDMETHOD(SetResolution)        (THIS_ DWORD dwResolution) PURE;
    STDMETHOD(SetType)              (THIS_ DWORD dwType) PURE;

    STDMETHOD(GetStrength)          (THIS_ DWORD * pdwStrength) PURE;
    STDMETHOD(GetTimeUnit)          (THIS_ DWORD * pdwTimeUnit) PURE;
    STDMETHOD(GetResolution)        (THIS_ DWORD * pdwResolution) PURE;
    STDMETHOD(GetType)              (THIS_ DWORD * pdwType) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_QUANTIZE_STRENGTH    0   /* Strength of quantization (0 to 1.) */
#define DMUS_QUANTIZE_TIMEUNIT    1   /* Unit of time used to calculate resolution. */
#define DMUS_QUANTIZE_RESOLUTION  2   /* Quantization resolution in time format defined by dwTimeUnit. */
#define DMUS_QUANTIZE_TYPE        3   /* Flags for quantize start and/or duration. */

#define DMUS_QUANTIZE_PARAMCOUNT  4   /* Number of parameters (above.) */

/*  Quantize types. */

#define DMUS_QUANTIZET_START      0   /* Quantize just start time. */
#define DMUS_QUANTIZET_LENGTH     1   /* Quantize just duration. */
#define DMUS_QUANTIZET_ALL        2   /* Quantize start and duration. */

#define FOURCC_QUANTIZE_CHUNK        mmioFOURCC('q','u','n','t')

typedef struct _DMUS_IO_QUANTIZE_HEADER
{
    DWORD   dwStrength;               /* Quantize multiplier. */
    DWORD   dwTimeUnit;               /* Unit of time used to calculate resolution. */
    DWORD   dwResolution;             /* Quantization resolution in time format defined by dwTimeUnit. */
    DWORD   dwType;                   /* Flags for quantize start and/or duration. */
} DMUS_IO_QUANTIZE_HEADER;


interface IDirectMusicTimeShiftTool;
#ifndef __cplusplus 
typedef interface IDirectMusicTimeShiftTool IDirectMusicTimeShiftTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicTimeShiftTool
DECLARE_INTERFACE_(IDirectMusicTimeShiftTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicTimeShiftTool */
    STDMETHOD(SetTimeUnit)          (THIS_ DWORD dwTimeUnit) PURE;
    STDMETHOD(SetRange)             (THIS_ DWORD dwRange) PURE;
    STDMETHOD(SetOffset)            (THIS_ long lOffset) PURE;

    STDMETHOD(GetTimeUnit)          (THIS_ DWORD * pdwTimeUnit) PURE;
    STDMETHOD(GetRange)             (THIS_ DWORD * pdwRange) PURE;
    STDMETHOD(GetOffset)            (THIS_ long * plOffset) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_TIMESHIFT_TIMEUNIT    0   /* Units for time offset and random range */
#define DMUS_TIMESHIFT_RANGE       1   /* Range for random time offset */
#define DMUS_TIMESHIFT_OFFSET      2   /* Straight offset to add to the note's time. */

#define DMUS_TIMESHIFT_PARAMCOUNT  3   /* Number of parameters (above.) */

#define FOURCC_TIMESHIFT_CHUNK        mmioFOURCC('t','i','m','s')

typedef struct _DMUS_IO_TIMESHIFT_HEADER
{
    DWORD   dwTimeUnit;            /* Unit of time used to calculate resolution. */
    DWORD   dwRange;               /* Range for random time offset */
    long    lOffset;               /* Straight offset to add to the note's time. */
} DMUS_IO_TIMESHIFT_HEADER;


interface IDirectMusicSwingTool;
#ifndef __cplusplus 
typedef interface IDirectMusicSwingTool IDirectMusicSwingTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicSwingTool
DECLARE_INTERFACE_(IDirectMusicSwingTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSwingTool */
    STDMETHOD(SetStrength)          (THIS_ DWORD dwStrength) PURE;

    STDMETHOD(GetStrength)          (THIS_ DWORD * pdwStrength) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_SWING_STRENGTH    0   /* Strength of swing (0 to 100%) */

#define DMUS_SWING_PARAMCOUNT  1   /* Number of parameters (above.) */

#define FOURCC_SWING_CHUNK        mmioFOURCC('q','u','n','t')

typedef struct _DMUS_IO_SWING_HEADER
{
    DWORD   dwStrength;               /* Swing multiplier. */
} DMUS_IO_SWING_HEADER;

interface IDirectMusicVelocityTool;
#ifndef __cplusplus 
typedef interface IDirectMusicVelocityTool IIDirectMusicVelocityTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicVelocityTool
DECLARE_INTERFACE_(IDirectMusicVelocityTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicVelocityTool */
    STDMETHOD(SetStrength)          (THIS_ long lStrength) PURE;
    STDMETHOD(SetLowLimit)          (THIS_ long lVelocityOut) PURE;
    STDMETHOD(SetHighLimit)         (THIS_ long lVelocityOut) PURE;
    STDMETHOD(SetCurveStart)        (THIS_ long lVelocityIn) PURE;
    STDMETHOD(SetCurveEnd)          (THIS_ long lVelocityIn) PURE;

    STDMETHOD(GetStrength)          (THIS_ long * plStrength) PURE;
    STDMETHOD(GetLowLimit)          (THIS_ long * plVelocityOut) PURE;
    STDMETHOD(GetHighLimit)         (THIS_ long * plVelocityOut) PURE;
    STDMETHOD(GetCurveStart)        (THIS_ long * plVelocityIn) PURE;
    STDMETHOD(GetCurveEnd)          (THIS_ long * plVelocityIn) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_VELOCITY_STRENGTH    0   /* Strength of velocity modifier (0 to 100%) */
#define DMUS_VELOCITY_LOWLIMIT    1   /* Minimum value for output velocity */
#define DMUS_VELOCITY_HIGHLIMIT   2   /* Maximum value for output velocity */
#define DMUS_VELOCITY_CURVESTART  3   /* Velocity curve starts at low limit and this input velocity */
#define DMUS_VELOCITY_CURVEEND    4   /* Velocity curve ends at this input velocity and high limit */

#define DMUS_VELOCITY_PARAMCOUNT  5   /* Number of parameters (above.) */

#define FOURCC_VELOCITY_CHUNK        mmioFOURCC('v','e','l','o')

typedef struct _DMUS_IO_VELOCITY_HEADER
{
    long    lStrength;                /* Strength of transformation. */
    long    lLowLimit;                /* Minimum value for output velocity */
    long    lHighLimit;               /* Maximum value for output velocity */
    long    lCurveStart;              /* Velocity curve starts at low limit and this input velocity */
    long    lCurveEnd;                /* Velocity curve ends at this input velocity and high limit */
} DMUS_IO_VELOCITY_HEADER;


/* Class IDs for tools. */

DEFINE_GUID(CLSID_DirectMusicEchoTool, 0x64e49fa4, 0xbacf, 0x11d2, 0x87, 0x2c, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTransposeTool, 0xbb8d0702, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicSwingTool, 0xbb8d0703, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicQuantizeTool, 0xbb8d0704, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicVelocityTool, 0xbb8d0705, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicDurationTool, 0xbb8d0706, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicTimeShiftTool, 0xbb8d0707, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicMuteTool, 0xbb8d0708, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicChordSequenceTool, 0xbb8d0709, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);



/* Interface IDs for tools. */

DEFINE_GUID(IID_IDirectMusicEchoTool, 0x81f60d22, 0x9d10, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(IID_IDirectMusicTransposeTool,0x173803f4, 0x4fd5, 0x4ba1, 0x9e, 0x50, 0xdd, 0x5f, 0x56, 0x69, 0xd2, 0x25);
DEFINE_GUID(IID_IDirectMusicDurationTool,0xc6897cfb, 0x9a43, 0x420f, 0xb6, 0xdb, 0xdd, 0x32, 0xc1, 0x82, 0xe8, 0x33);
DEFINE_GUID(IID_IDirectMusicQuantizeTool,0x652e5667, 0x210d, 0x4d06, 0x83, 0x2a, 0xbc, 0x17, 0x92, 0x7e, 0x51, 0x42);
DEFINE_GUID(IID_IDirectMusicTimeShiftTool,0xc39abaf0, 0xc4f0, 0x4c6b, 0x83, 0x4a, 0xcf, 0x21, 0x7c, 0xbe, 0x95, 0x6d);
DEFINE_GUID(IID_IDirectMusicSwingTool,0xd876ffee, 0x3a6f, 0x43db, 0xa3, 0x5c, 0x68, 0x7b, 0x38, 0x6a, 0x71, 0x65);
DEFINE_GUID(IID_IDirectMusicVelocityTool,0xb15eb722, 0xfb50, 0x4e1f, 0xb2, 0x1, 0xa6, 0x99, 0xe0, 0x47, 0x79, 0x54);
DEFINE_GUID(IID_IDirectMusicMuteTool,0x20cc9511, 0x5802, 0x49a0, 0xba, 0x91, 0x8b, 0x29, 0xb0, 0xf7, 0x22, 0xab);
DEFINE_GUID(IID_IDirectMusicChordSequenceTool,0xc32c1b34, 0xe604, 0x48c1, 0xba, 0x8c, 0x7b, 0x50, 0x10, 0x17, 0xbd, 0x68);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif // _TOOLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\velocity.cpp ===
// Velocity.cpp : Implementation of CVelocityTool
//
// Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "velocity.h"
#include "toolhelp.h"

CVelocityTool::CVelocityTool()
{
    ParamInfo Params[DMUS_VELOCITY_PARAMCOUNT] = 
    {
        { DMUS_VELOCITY_STRENGTH, MPT_INT,MP_CAPS_ALL,0,100,100,
            L"Percent",L"Strength",NULL },            // Strength - 100% by default
        { DMUS_VELOCITY_LOWLIMIT, MPT_INT,MP_CAPS_ALL,1,127,1,
            L"Velocity",L"Lower Limit",NULL },        // Lower limit - 1 by default
        { DMUS_VELOCITY_HIGHLIMIT, MPT_INT,MP_CAPS_ALL,1,127,127,
            L"Velocity",L"Upper Limit",NULL },        // Upper limit - 127 by default
        { DMUS_VELOCITY_CURVESTART, MPT_INT,MP_CAPS_ALL,1,127,1,
            L"Velocity",L"Curve Start",NULL },        // Curve start - 1 by default
        { DMUS_VELOCITY_CURVEEND, MPT_INT,MP_CAPS_ALL,1,127,127,
            L"Velocity",L"Curve End",NULL },          // Curve End - 127 by default
    };
    InitParams(DMUS_VELOCITY_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CVelocityTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CVelocityTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CVelocityTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicVelocityTool)
	{
		*ppv = static_cast<IDirectMusicVelocityTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CVelocityTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicVelocityTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CVelocityTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CVelocityTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_VELOCITY_CHUNK))
	{
        DMUS_IO_VELOCITY_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_VELOCITY_STRENGTH,(float) Header.lStrength);
            SetParam(DMUS_VELOCITY_LOWLIMIT,(float) Header.lLowLimit);
            SetParam(DMUS_VELOCITY_HIGHLIMIT,(float) Header.lHighLimit);
            SetParam(DMUS_VELOCITY_CURVESTART,(float) Header.lCurveStart);
            SetParam(DMUS_VELOCITY_CURVEEND,(float) Header.lCurveEnd);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CVelocityTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_VELOCITY_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_VELOCITY_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_VELOCITY_HEADER Header;
        GetParamInt(DMUS_VELOCITY_STRENGTH,MAX_REF_TIME,&Header.lStrength);
        GetParamInt(DMUS_VELOCITY_LOWLIMIT,MAX_REF_TIME,&Header.lLowLimit);
        GetParamInt(DMUS_VELOCITY_HIGHLIMIT,MAX_REF_TIME,&Header.lHighLimit);
        GetParamInt(DMUS_VELOCITY_CURVESTART,MAX_REF_TIME,&Header.lCurveStart);
        GetParamInt(DMUS_VELOCITY_CURVEEND,MAX_REF_TIME,&Header.lCurveEnd);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CVelocityTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_VELOCITY_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CVelocityTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_VelocityPage;
	return NOERROR;
}


/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CVelocityTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // We need to know the time format so we can call GetParamInt() to read control parameters.
    REFERENCE_TIME rtTime;
    if (m_fMusicTime) rtTime = pPMsg->mtTime;
    else rtTime = pPMsg->rtTime;
    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        long lStrength;
        long lLowLimit, lHighLimit, lCurveStart, lCurveEnd;
        GetParamInt(DMUS_VELOCITY_STRENGTH,rtTime,&lStrength);
        GetParamInt(DMUS_VELOCITY_LOWLIMIT,rtTime,&lLowLimit);
        GetParamInt(DMUS_VELOCITY_HIGHLIMIT,rtTime,&lHighLimit);
        GetParamInt(DMUS_VELOCITY_CURVESTART,rtTime,&lCurveStart);
        GetParamInt(DMUS_VELOCITY_CURVEEND,rtTime,&lCurveEnd);
        if (lCurveStart <= lCurveEnd)
        {
            long lNewVelocity;
            if (pNote->bVelocity <= lCurveStart)
            {
                lNewVelocity = lLowLimit;
            }
            else if (pNote->bVelocity >= lCurveEnd)
            {
                lNewVelocity = lHighLimit;
            }
            else
            {
                // For this case, compute the point on the line between (lCurveStart, lLowLimit) and (lCurveEnd, lHighLimit)
                lNewVelocity = lLowLimit + ((lHighLimit - lLowLimit) * (pNote->bVelocity - lCurveStart)) / (lCurveEnd - lCurveStart);
            }
            // Now, calculate the change we want to apply.
            lNewVelocity -= pNote->bVelocity;
            // Scale it to the amount we'll actually do.
            lNewVelocity = (lNewVelocity * lStrength) / 100;
            lNewVelocity += pNote->bVelocity;
            if (lNewVelocity < 1) lNewVelocity = 1;
            if (lNewVelocity > 127) lNewVelocity = 127;
            pNote->bVelocity = (BYTE) lNewVelocity;
        }

    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CVelocityTool::Clone( IDirectMusicTool ** ppTool)

{
    CVelocityTool *pNew = new CVelocityTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CVelocityTool::SetStrength(long lStrength) 
{
    return SetParam(DMUS_VELOCITY_STRENGTH,(float) lStrength);
}

STDMETHODIMP CVelocityTool::SetLowLimit(long lVelocityOut)
{
    return SetParam(DMUS_VELOCITY_LOWLIMIT,(float) lVelocityOut);
}

STDMETHODIMP CVelocityTool::SetHighLimit(long lVelocityOut)
{
    return SetParam(DMUS_VELOCITY_HIGHLIMIT,(float) lVelocityOut);
}

STDMETHODIMP CVelocityTool::SetCurveStart(long lVelocityIn)
{
    return SetParam(DMUS_VELOCITY_CURVESTART,(float) lVelocityIn);
}

STDMETHODIMP CVelocityTool::SetCurveEnd(long lVelocityIn)
{
    return SetParam(DMUS_VELOCITY_CURVEEND,(float) lVelocityIn);
}

STDMETHODIMP CVelocityTool::GetStrength(long * plStrength) 
{
    return GetParamInt(DMUS_VELOCITY_STRENGTH,MAX_REF_TIME,plStrength);
}

STDMETHODIMP CVelocityTool::GetLowLimit(long * plVelocityOut) 
{
    return GetParamInt(DMUS_VELOCITY_LOWLIMIT,MAX_REF_TIME,plVelocityOut);
}

STDMETHODIMP CVelocityTool::GetHighLimit(long * plVelocityOut) 
{
    return GetParamInt(DMUS_VELOCITY_HIGHLIMIT,MAX_REF_TIME,plVelocityOut);
}

STDMETHODIMP CVelocityTool::GetCurveStart(long * plVelocityIn) 
{
    return GetParamInt(DMUS_VELOCITY_CURVESTART,MAX_REF_TIME,plVelocityIn);
}

STDMETHODIMP CVelocityTool::GetCurveEnd(long * plVelocityIn) 
{
    return GetParamInt(DMUS_VELOCITY_CURVEEND,MAX_REF_TIME,plVelocityIn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\transpose.h ===
#ifndef _TRANSPOSE_TOOL_
#define _TRANSPOSE_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "..\dmtoolprp\toolprops.h"

class CTransposeTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicTransposeTool

{
public:
	CTransposeTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    virtual STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);
    
// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicTransposeTool
	STDMETHODIMP SetTranspose(long lTranspose) ;
	STDMETHODIMP SetType(DWORD dwType) ;
	STDMETHODIMP GetTranspose(long * plTranspose) ;
	STDMETHODIMP GetType(DWORD * pdwType) ;
private:
    static DMUS_CHORD_KEY m_gDefaultChord;
};

#endif // _TRANSPOSE_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\transpose.cpp ===
// Transpose.cpp : Implementation of CTransposeTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "transpose.h"
#include "toolhelp.h"

// We keep a default chord of C7 in the scale of C, in case there is no chord track
// at the time an in scale transposition is requested.

DMUS_CHORD_KEY CTransposeTool::m_gDefaultChord;

CTransposeTool::CTransposeTool()
{
    ParamInfo Params[DMUS_TRANSPOSE_PARAMCOUNT] = 
    {
        { DMUS_TRANSPOSE_AMOUNT, MPT_INT,MP_CAPS_ALL,-24,24,0,
            L"Intervals",L"Transpose",NULL},        // Tranpose - none by default
        { DMUS_TRANSPOSE_TYPE, MPT_ENUM,MP_CAPS_ALL,
            DMUS_TRANSPOSET_LINEAR,DMUS_TRANSPOSET_SCALE,DMUS_TRANSPOSET_SCALE,
            L"",L"Type",L"Linear,In Scale"} // Type - transpose in scale by default
    };
    InitParams(DMUS_TRANSPOSE_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
    wcscpy(m_gDefaultChord.wszName, L"M7");
    m_gDefaultChord.wMeasure = 0;
    m_gDefaultChord.bBeat = 0;
    m_gDefaultChord.bSubChordCount = 1;
    m_gDefaultChord.bKey = 12;
    m_gDefaultChord.dwScale = 0xab5ab5; // default scale is C Major
    m_gDefaultChord.bFlags = 0;
    for (int n = 0; n < DMUS_MAXSUBCHORD; n++)
    {
        m_gDefaultChord.SubChordList[n].dwChordPattern = 0x891; // default chord is major 7
        m_gDefaultChord.SubChordList[n].dwScalePattern = 0xab5ab5; // default scale is C Major
        m_gDefaultChord.SubChordList[n].dwInversionPoints = 0xffffff;
        m_gDefaultChord.SubChordList[n].dwLevels = 0xffffffff;
        m_gDefaultChord.SubChordList[n].bChordRoot = 12; // 2C
        m_gDefaultChord.SubChordList[n].bScaleRoot = 0;
    }
}

STDMETHODIMP_(ULONG) CTransposeTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CTransposeTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CTransposeTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicTransposeTool)
	{
		*ppv = static_cast<IDirectMusicTransposeTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CTransposeTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicTransposeTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CTransposeTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CTransposeTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_TRANSPOSE_CHUNK))
	{
        DMUS_IO_TRANSPOSE_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_TRANSPOSE_AMOUNT,(float) Header.lTranspose);
            SetParam(DMUS_TRANSPOSE_TYPE,(float) Header.dwType);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CTransposeTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_TRANSPOSE_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_TRANSPOSE_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_TRANSPOSE_HEADER Header;
        GetParamInt(DMUS_TRANSPOSE_AMOUNT,MAX_REF_TIME,(long *) &Header.lTranspose);
        GetParamInt(DMUS_TRANSPOSE_TYPE,MAX_REF_TIME,(long *) &Header.dwType);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CTransposeTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_TRANSPOSE_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CTransposeTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_TransposePage;
	return NOERROR;
}

/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CTransposeTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // Only transpose notes that are not on the drum pChannel.
    if( (pPMsg->dwType == DMUS_PMSGT_NOTE ) && ((pPMsg->dwPChannel & 0xF) != 0x9))
    {
        // We need to know the time format so we can call GetParamInt() to read control parameters.
        REFERENCE_TIME rtTime;
        if (m_fMusicTime) rtTime = pPMsg->mtTime;
        else rtTime = pPMsg->rtTime;
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        long lTranspose, lType;
        long lNote = pNote->bMidiValue;
        
        GetParamInt(DMUS_TRANSPOSE_AMOUNT,rtTime,&lTranspose);
        GetParamInt(DMUS_TRANSPOSE_TYPE,rtTime,&lType);
        if (lType == DMUS_TRANSPOSET_LINEAR)
        {
            lNote += lTranspose;
            while (lNote < 0) lNote += 12;
            while (lNote > 127) lNote -= 12;
            pNote->bMidiValue = (BYTE) lNote;
        }
        else
        {
            IDirectMusicPerformance8 *pPerf8;
            if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **) &pPerf8)))
            {
                DMUS_CHORD_KEY Chord;
                DMUS_CHORD_KEY *pChord = &Chord;
                if (FAILED(pPerf8->GetParamEx(GUID_ChordParam,pNote->dwVirtualTrackID,
                                   pNote->dwGroupID,0,pNote->mtTime - pNote->nOffset, NULL, pChord)))
                {
                    // Couldn't find an active scale, use major scale instead.
                    pChord = &m_gDefaultChord;
                }
                WORD wVal;
                // First, use the current chord & scale to convert the note's midi value into scale position.
                if (SUCCEEDED(pPerf->MIDIToMusic(pNote->bMidiValue ,pChord,DMUS_PLAYMODE_PEDALPOINT,pNote->bSubChordLevel,&wVal)))
                {
                    // Scale position is octave position * 7 plus chord position * 2 plus the scale position.
                    long lScalePosition = (((wVal & 0xF000) >> 12) * 7) + (((wVal & 0xF00) >> 8) * 2) + ((wVal & 0xF0) >> 4);
                    // Now that we are looking at scale position, we can add the transposition.
                    lScalePosition += lTranspose;
                    // Make sure we don't wrap around.
                    while (lScalePosition < 0) lScalePosition += 7;
                    // A high MIDI value of 127 translates to scale position 74.
                    while (lScalePosition > 74) lScalePosition -= 7;
                    wVal &= 0x000F; // Keep only the accidental. 
                    // Now, insert the values back in. Start with chord.
                    wVal |= ((lScalePosition / 7) << 12);
                    // Then, scale position.
                    wVal |= ((lScalePosition % 7) << 4);
                    pPerf->MusicToMIDI(wVal,pChord,DMUS_PLAYMODE_PEDALPOINT,
                        pNote->bSubChordLevel,&pNote->bMidiValue);
                }
                pPerf8->Release();
            }
        }
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CTransposeTool::Clone( IDirectMusicTool ** ppTool)

{
    CTransposeTool *pNew = new CTransposeTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CTransposeTool::SetTranspose(long lTranpose) 
{
    return SetParam(DMUS_TRANSPOSE_AMOUNT,(float) lTranpose);
}

STDMETHODIMP CTransposeTool::SetType(DWORD dwType) 
{
    return SetParam(DMUS_TRANSPOSE_TYPE,(float) dwType);
}

#define MAX_REF_TIME    0x7FFFFFFFFFFFFFFF

STDMETHODIMP CTransposeTool::GetTranspose(long * plTranspose) 
{
    return GetParamInt(DMUS_TRANSPOSE_AMOUNT,MAX_REF_TIME, plTranspose);
}

STDMETHODIMP CTransposeTool::GetType(DWORD * pdwType) 
{
    return GetParamInt(DMUS_TRANSPOSE_TYPE,MAX_REF_TIME,(long *) pdwType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\quantizepage.cpp ===
// QuantizePage.cpp : Implementation of CQuantizePage
#include "stdafx.h"
#include "ToolProps.h"
#include "QuantizePage.h"

/////////////////////////////////////////////////////////////////////////////
// CQuantizePage

CQuantizePage::CQuantizePage() 
{
	m_dwTitleID = IDS_TITLEQuantizePage;
	m_dwHelpFileID = IDS_HELPFILEQuantizePage;
	m_dwDocStringID = IDS_DOCSTRINGQuantizePage;
    m_pQuantize = NULL;
}

CQuantizePage::~CQuantizePage()

{
    if (m_pQuantize)
    {
        m_pQuantize->Release();
    }
}

STDMETHODIMP CQuantizePage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicQuantizeTool,(void **) &m_pQuantize);
}


STDMETHODIMP CQuantizePage::Apply(void)

{
    m_pQuantize->SetStrength((DWORD) m_ctStrength.GetValue());
	m_pQuantize->SetResolution((DWORD) m_ctResolution.GetValue());
    m_pQuantize->SetType(m_ctType.GetValue());
    m_pQuantize->SetTimeUnit(m_ctTimeUnit.GetValue()+1);
	m_bDirty = FALSE;
	return S_OK;
}

void CQuantizePage::SetTimeUnitRange()

{
    DWORD dwRes = m_ctTimeUnit.GetValue();
    if (dwRes < 2)
    {
        m_ctResolution.SetRange(0,1000);
    }
    else
    {
        m_ctResolution.SetRange(0,12);
    }
}

LRESULT CQuantizePage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pQuantize)
    {
        static char *pTypes[4] = { "Quantize Off","Quantize Start Time","Quantize Duration",
            "Quantize Start and Duration"};
        static char *pTimeUnit[DMUS_TIME_UNIT_COUNT-1] = { 
            "Music Clicks","Grid", "Beat","Bar",
            "64th note triplets", "64th notes",
            "32nd note triplets",
            "32nd notes","16th note triplets","16th notes",
            "8th note triplets","8th notes","Quarter note triplets",
            "Quarter notes","Half note triplets","Half notes",
            "Whole note triplets", "Whole notes"
        };
        m_ctStrength.Init(GetDlgItem(IDC_STRENGTH),GetDlgItem(IDC_STRENGTH_DISPLAY),0,120,true);
        m_ctResolution.Init(GetDlgItem(IDC_RESOLUTION),GetDlgItem(IDC_RESOLUTION_DISPLAY),0,12,true);
        m_ctType.Init(GetDlgItem(IDC_TYPE),IDC_TYPE,pTypes,4);
        m_ctTimeUnit.Init(GetDlgItem(IDC_TIMEUNIT),IDC_TIMEUNIT,pTimeUnit,DMUS_TIME_UNIT_COUNT-1);

        DWORD dwValue;
        m_pQuantize->GetType(&dwValue);
        m_ctType.SetValue(dwValue);
        m_pQuantize->GetTimeUnit(&dwValue);
        m_ctTimeUnit.SetValue(dwValue-1);
        SetTimeUnitRange();
        m_pQuantize->GetStrength(&dwValue);
        m_ctStrength.SetValue((float)dwValue);
        m_pQuantize->GetResolution(&dwValue);
        m_ctResolution.SetValue((float)dwValue);
    }
	return 1;
}

LRESULT CQuantizePage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctStrength.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctResolution.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled)
        lr = m_ctType.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled) 
    {
        lr = m_ctTimeUnit.MessageHandler(uMsg, wParam, lParam, bHandled);
        if (bHandled) 
        {
            SetTimeUnitRange();
        }
    }
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CQuantizePage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctStrength.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctResolution.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\quantizepage.h ===
// QuantizePage.h : Declaration of the CQuantizePage

#ifndef __QUANTIZEPAGE_H_
#define __QUANTIZEPAGE_H_

#include "resource.h"       // main symbols
#include "..\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_QuantizePage;

/////////////////////////////////////////////////////////////////////////////
// CQuantizePage
class ATL_NO_VTABLE CQuantizePage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CQuantizePage, &CLSID_QuantizePage>,
	public IPropertyPageImpl<CQuantizePage>,
	public CDialogImpl<CQuantizePage>
{
public:
	CQuantizePage();
    virtual ~CQuantizePage();

	enum {IDD = IDD_QUANTIZEPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_QUANTIZEPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CQuantizePage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CQuantizePage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CQuantizePage>)
END_MSG_MAP()

// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    void SetTimeUnitRange();
    IDirectMusicQuantizeTool *m_pQuantize;
    CSliderValue          m_ctStrength;
    CSliderValue          m_ctResolution;
    CComboHelp            m_ctTimeUnit;
    CComboHelp            m_ctType;
};

#endif //__QUANTIZEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\echopage.cpp ===
// EchoPage.cpp : Implementation of CEchoPage
#include "stdafx.h"
#include "ToolProps.h"
#include "EchoPage.h"


/////////////////////////////////////////////////////////////////////////////
// CEchoPage

CEchoPage::CEchoPage() 
{
	m_dwTitleID = IDS_TITLEEchoPage;
	m_dwHelpFileID = IDS_HELPFILEEchoPage;
	m_dwDocStringID = IDS_DOCSTRINGEchoPage;
    m_pEcho = NULL;
}

CEchoPage::~CEchoPage()

{
    if (m_pEcho)
    {
        m_pEcho->Release();
    }
}

STDMETHODIMP CEchoPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicEchoTool,(void **) &m_pEcho);
}


STDMETHODIMP CEchoPage::Apply(void)

{
    m_pEcho->SetRepeat((DWORD) m_ctRepeat.GetValue());
	m_pEcho->SetDecay((DWORD) m_ctDecay.GetValue());
    m_pEcho->SetDelay((DWORD) m_ctDelay.GetValue());
    m_pEcho->SetGroupOffset((DWORD) m_ctOffset.GetValue());
    m_pEcho->SetType(m_ctType.GetValue());
    m_pEcho->SetTimeUnit(m_ctTimeUnit.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

void CEchoPage::SetTimeUnitRange()

{
    DWORD dwRes = m_ctTimeUnit.GetValue();
    if (dwRes < 2)
    {
        m_ctDelay.SetRange(0,1000);
    }
    else
    {
        m_ctDelay.SetRange(0,12);
    }
}

LRESULT CEchoPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pEcho)
    {
        static char *pTypes[4] = { "Falling","Falling, Truncated","Rising","Rising, Truncated"};
        static char *pTimeUnit[DMUS_TIME_UNIT_COUNT] = { 
            "Milliseconds","Music Clicks","Grid", "Beat","Bar",
            "64th note triplets", "64th notes",
            "32nd note triplets",
            "32nd notes","16th note triplets","16th notes",
            "8th note triplets","8th notes","Quarter note triplets",
            "Quarter notes","Half note triplets","Half notes",
            "Whole note triplets", "Whole notes"
        };
        m_ctRepeat.Init(GetDlgItem(IDC_REPEAT),GetDlgItem(IDC_REPEAT_DISPLAY),0,24,true);
        m_ctDelay.Init(GetDlgItem(IDC_DELAY),GetDlgItem(IDC_DELAY_DISPLAY),0,12,true);
        m_ctDecay.Init(GetDlgItem(IDC_DECAY),GetDlgItem(IDC_DECAY_DISPLAY),0,100,true);
        m_ctOffset.Init(GetDlgItem(IDC_OFFSET),GetDlgItem(IDC_OFFSET_DISPLAY),0,10,true);
        m_ctType.Init(GetDlgItem(IDC_TYPE),IDC_TYPE,pTypes,4);
        m_ctTimeUnit.Init(GetDlgItem(IDC_TIMEUNIT),IDC_TIMEUNIT,pTimeUnit,DMUS_TIME_UNIT_COUNT);

        DWORD dwValue;
        m_pEcho->GetType(&dwValue);
        m_ctType.SetValue(dwValue);
        m_pEcho->GetTimeUnit(&dwValue);
        m_ctTimeUnit.SetValue(dwValue);
        SetTimeUnitRange();
        m_pEcho->GetRepeat(&dwValue);
        m_ctRepeat.SetValue((float)dwValue);
        m_pEcho->GetDelay(&dwValue);
        m_ctDelay.SetValue((float)dwValue);
        m_pEcho->GetDecay(&dwValue);
        m_ctDecay.SetValue((float)dwValue);
        m_pEcho->GetGroupOffset(&dwValue);
        m_ctOffset.SetValue((float)dwValue);
    }
	return 1;
}

LRESULT CEchoPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRepeat.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDelay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDecay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled)
        lr = m_ctType.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled) 
    {
        lr = m_ctTimeUnit.MessageHandler(uMsg, wParam, lParam, bHandled);
        if (bHandled) 
        {
            SetTimeUnitRange();
        }
    }
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CEchoPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRepeat.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDelay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDecay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\echopage.h ===
// EchoPage.h : Declaration of the CEchoPage

#ifndef __ECHOPAGE_H_
#define __ECHOPAGE_H_

#include "resource.h"       // main symbols
#include "..\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_EchoPage;

/////////////////////////////////////////////////////////////////////////////
// CEchoPage
class ATL_NO_VTABLE CEchoPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEchoPage, &CLSID_EchoPage>,
	public IPropertyPageImpl<CEchoPage>,
	public CDialogImpl<CEchoPage>
{
public:
	CEchoPage();
    virtual ~CEchoPage();

	enum {IDD = IDD_ECHOPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_ECHOPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEchoPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CEchoPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CEchoPage>)
END_MSG_MAP()

// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//    LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    void SetTimeUnitRange();
    IDirectMusicEchoTool *m_pEcho;
    CSliderValue          m_ctRepeat;
    CSliderValue          m_ctDecay;
    CSliderValue          m_ctDelay;
    CSliderValue          m_ctOffset;
    CComboHelp            m_ctTimeUnit;
    CComboHelp            m_ctType;
};

#endif //__ECHOPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\durationpage.h ===
// DurationPage.h : Declaration of the CDurationPage

#ifndef __DURATIONPAGE_H_
#define __DURATIONPAGE_H_

#include "resource.h"       // main symbols
#include "..\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DurationPage;

/////////////////////////////////////////////////////////////////////////////
// CDurationPage
class ATL_NO_VTABLE CDurationPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDurationPage, &CLSID_DurationPage>,
	public IPropertyPageImpl<CDurationPage>,
	public CDialogImpl<CDurationPage>
{
public:
	CDurationPage();
    virtual ~CDurationPage();

	enum {IDD = IDD_DURATIONPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DURATIONPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDurationPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDurationPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CDurationPage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    IDirectMusicDurationTool *  m_pDuration;
    CSliderValue                m_ctScale;
};

#endif //__DURATIONPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\durationpage.cpp ===
// DurationPage.cpp : Implementation of CDurationPage
#include "stdafx.h"
#include "ToolProps.h"
#include "DurationPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDurationPage

CDurationPage::CDurationPage() 
{
	m_dwTitleID = IDS_TITLEDurationPage;
	m_dwHelpFileID = IDS_HELPFILEDurationPage;
	m_dwDocStringID = IDS_DOCSTRINGDurationPage;
    m_pDuration = NULL;
}

CDurationPage::~CDurationPage()

{
    if (m_pDuration)
    {
        m_pDuration->Release();
    }
}

STDMETHODIMP CDurationPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicDurationTool,(void **) &m_pDuration);
}


STDMETHODIMP CDurationPage::Apply(void)

{
    m_pDuration->SetScale(m_ctScale.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

LRESULT CDurationPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pDuration)
    {
        m_ctScale.Init(GetDlgItem(IDC_SCALE),GetDlgItem(IDC_SCALE_DISPLAY),0,2.0,false);

        float fScale;
        m_pDuration->GetScale(&fScale);
        m_ctScale.SetValue(fScale);
    }
	return 1;
}

LRESULT CDurationPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctScale.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CDurationPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctScale.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ToolProps.rc
//
#define IDS_PROJNAME                    100
#define IDS_TITLEEchoPage               101
#define IDS_HELPFILEEchoPage            102
#define IDS_DOCSTRINGEchoPage           103
#define IDR_ECHOPAGE                    104
#define IDD_ECHOPAGE                    105
#define IDS_TITLETransposePage          106
#define IDS_HELPFILETransposePage       107
#define IDS_DOCSTRINGTransposePage      108
#define IDR_TRANSPOSEPAGE               109
#define IDD_TRANSPOSEPAGE               110
#define IDS_TITLEDurationPage           111
#define IDS_HELPFILEDurationPage        112
#define IDS_DOCSTRINGDurationPage       113
#define IDR_DURATIONPAGE                114
#define IDD_DURATIONPAGE                115
#define IDS_TITLEQuantizePage           116
#define IDS_HELPFILEQuantizePage        117
#define IDS_DOCSTRINGQuantizePage       118
#define IDR_QUANTIZEPAGE                119
#define IDD_QUANTIZEPAGE                120
#define IDS_TITLETimeShiftPage          121
#define IDS_HELPFILETimeShiftPage       122
#define IDS_DOCSTRINGTimeShiftPage      123
#define IDR_TIMESHIFTPAGE               124
#define IDD_TIMESHIFTPAGE               125
#define IDC_REPEAT                      201
#define IDC_REPEAT_DISPLAY              202
#define IDC_DECAY                       203
#define IDC_DECAY_DISPLAY               204
#define IDC_DELAY                       205
#define IDC_DELAY_DISPLAY               206
#define IDC_OFFSET                      207
#define IDC_OFFSET_DISPLAY              208
#define IDC_TIMEUNIT                    209
#define IDC_TYPE                        210
#define IDC_TRANSPOSE                   211
#define IDC_TRANSPOSE_DISPLAY           212
#define IDC_SCALE                       213
#define IDC_SCALE_DISPLAY               214
#define IDC_STRENGTH                    215
#define IDC_STRENGTH_DISPLAY            216
#define IDC_RESOLUTION                  217
#define IDC_RESOLUTION_DISPLAY          218
#define IDC_RANGE                       219
#define IDC_RANGE_DISPLAY               220

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         221
#define _APS_NEXT_SYMED_VALUE           126
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B54A32F6_F277_470E_AC31_3ECE7AB2A3B4__INCLUDED_)
#define AFX_STDAFX_H__B54A32F6_F277_470E_AC31_3ECE7AB2A3B4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B54A32F6_F277_470E_AC31_3ECE7AB2A3B4__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\toolprops.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue Apr 18 15:40:11 2000
 */
/* Compiler settings for C:\nt\multimedia\Directx\dmusic\dmtool\toolprops\ToolProps.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __ToolProps_h__
#define __ToolProps_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __EchoPage_FWD_DEFINED__
#define __EchoPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class EchoPage EchoPage;
#else
typedef struct EchoPage EchoPage;
#endif /* __cplusplus */

#endif 	/* __EchoPage_FWD_DEFINED__ */


#ifndef __TransposePage_FWD_DEFINED__
#define __TransposePage_FWD_DEFINED__

#ifdef __cplusplus
typedef class TransposePage TransposePage;
#else
typedef struct TransposePage TransposePage;
#endif /* __cplusplus */

#endif 	/* __TransposePage_FWD_DEFINED__ */


#ifndef __DurationPage_FWD_DEFINED__
#define __DurationPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class DurationPage DurationPage;
#else
typedef struct DurationPage DurationPage;
#endif /* __cplusplus */

#endif 	/* __DurationPage_FWD_DEFINED__ */


#ifndef __QuantizePage_FWD_DEFINED__
#define __QuantizePage_FWD_DEFINED__

#ifdef __cplusplus
typedef class QuantizePage QuantizePage;
#else
typedef struct QuantizePage QuantizePage;
#endif /* __cplusplus */

#endif 	/* __QuantizePage_FWD_DEFINED__ */


#ifndef __TimeShiftPage_FWD_DEFINED__
#define __TimeShiftPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class TimeShiftPage TimeShiftPage;
#else
typedef struct TimeShiftPage TimeShiftPage;
#endif /* __cplusplus */

#endif 	/* __TimeShiftPage_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __TOOLPROPSLib_LIBRARY_DEFINED__
#define __TOOLPROPSLib_LIBRARY_DEFINED__

/* library TOOLPROPSLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_TOOLPROPSLib;

EXTERN_C const CLSID CLSID_EchoPage;

#ifdef __cplusplus

class DECLSPEC_UUID("5337AF8F-3827-44DD-9EE9-AB6E1AABB60F")
EchoPage;
#endif

EXTERN_C const CLSID CLSID_TransposePage;

#ifdef __cplusplus

class DECLSPEC_UUID("691BD8C2-2B07-4C92-A82E-92D858DE23D6")
TransposePage;
#endif

EXTERN_C const CLSID CLSID_DurationPage;

#ifdef __cplusplus

class DECLSPEC_UUID("79D9CAF8-DBDA-4560-A8B0-07E73A79FA6B")
DurationPage;
#endif

EXTERN_C const CLSID CLSID_QuantizePage;

#ifdef __cplusplus

class DECLSPEC_UUID("623286DC-67F8-4055-A9BE-F7A7176BD150")
QuantizePage;
#endif

EXTERN_C const CLSID CLSID_TimeShiftPage;

#ifdef __cplusplus

class DECLSPEC_UUID("7D3BDEE7-9557-4085-82EE-1B2F02CE4BA6")
TimeShiftPage;
#endif
#endif /* __TOOLPROPSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\toolprops_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Apr 17 13:39:44 2000
 */
/* Compiler settings for C:\nt\multimedia\Directx\dmusic\dmtool\toolprops\ToolProps.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_TOOLPROPSLib = {0x2735B8F3,0xFF4A,0x4AF2,{0x80,0x53,0xBE,0x22,0xC0,0xCA,0x32,0x32}};


const CLSID CLSID_EchoPage = {0x5337AF8F,0x3827,0x44DD,{0x9E,0xE9,0xAB,0x6E,0x1A,0xAB,0xB6,0x0F}};


const CLSID CLSID_TransposePage = {0x691BD8C2,0x2B07,0x4C92,{0xA8,0x2E,0x92,0xD8,0x58,0xDE,0x23,0xD6}};


const CLSID CLSID_DurationPage = {0x79D9CAF8,0xDBDA,0x4560,{0xA8,0xB0,0x07,0xE7,0x3A,0x79,0xFA,0x6B}};


const CLSID CLSID_QuantizePage = {0x623286DC,0x67F8,0x4055,{0xA9,0xBE,0xF7,0xA7,0x17,0x6B,0xD1,0x50}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\transposepage.h ===
// TransposePage.h : Declaration of the CTransposePage

#ifndef __TRANSPOSEPAGE_H_
#define __TRANSPOSEPAGE_H_

#include "resource.h"       // main symbols
#include "..\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_TransposePage;

/////////////////////////////////////////////////////////////////////////////
// CTransposePage
class ATL_NO_VTABLE CTransposePage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTransposePage, &CLSID_TransposePage>,
	public IPropertyPageImpl<CTransposePage>,
	public CDialogImpl<CTransposePage>
{
public:
	CTransposePage();
    virtual ~CTransposePage();

	enum {IDD = IDD_TRANSPOSEPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_TRANSPOSEPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTransposePage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CTransposePage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CTransposePage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    IDirectMusicTransposeTool * m_pTranspose;
    CSliderValue                m_ctTranspose;
    CComboHelp                  m_ctType;
};

#endif //__TRANSPOSEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\timeshiftpage.h ===
// TimeShiftPage.h : Declaration of the CTimeShiftPage

#ifndef __TIMESHIFTPAGE_H_
#define __TIMESHIFTPAGE_H_

#include "resource.h"       // main symbols
#include "..\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_TimeShiftPage;

/////////////////////////////////////////////////////////////////////////////
// CTimeShiftPage
class ATL_NO_VTABLE CTimeShiftPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTimeShiftPage, &CLSID_TimeShiftPage>,
	public IPropertyPageImpl<CTimeShiftPage>,
	public CDialogImpl<CTimeShiftPage>
{
public:
	CTimeShiftPage();
    virtual ~CTimeShiftPage();

	enum {IDD = IDD_TIMESHIFTPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_TIMESHIFTPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTimeShiftPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CTimeShiftPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CTimeShiftPage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    IDirectMusicTimeShiftTool *  m_pTimeShift;
    CSliderValue                 m_ctRange;
    CSliderValue                 m_ctOffset;
};

#endif //__TIMESHIFTPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\timeshiftpage.cpp ===
// TimeShiftPage.cpp : Implementation of CTimeShiftPage
#include "stdafx.h"
#include "ToolProps.h"
#include "TimeShiftPage.h"

/////////////////////////////////////////////////////////////////////////////
// CTimeShiftPage

CTimeShiftPage::CTimeShiftPage() 
{
	m_dwTitleID = IDS_TITLETimeShiftPage;
	m_dwHelpFileID = IDS_HELPFILETimeShiftPage;
	m_dwDocStringID = IDS_DOCSTRINGTimeShiftPage;
    m_pTimeShift = NULL;
}

CTimeShiftPage::~CTimeShiftPage()

{
    if (m_pTimeShift)
    {
        m_pTimeShift->Release();
    }
}

STDMETHODIMP CTimeShiftPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicTimeShiftTool,(void **) &m_pTimeShift);
}


STDMETHODIMP CTimeShiftPage::Apply(void)

{
    m_pTimeShift->SetRange((DWORD)m_ctRange.GetValue());
    m_pTimeShift->SetOffset((long)m_ctOffset.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

LRESULT CTimeShiftPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pTimeShift)
    {
        m_ctRange.Init(GetDlgItem(IDC_RANGE),GetDlgItem(IDC_RANGE_DISPLAY),0,200,true);
        m_ctOffset.Init(GetDlgItem(IDC_OFFSET),GetDlgItem(IDC_OFFSET_DISPLAY),-200,200,true);

        long lValue;
        m_pTimeShift->GetRange((DWORD *)&lValue);
        m_ctRange.SetValue((float)lValue);
        m_pTimeShift->GetOffset(&lValue);
        m_ctOffset.SetValue((float)lValue);
    }
	return 1;
}

LRESULT CTimeShiftPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRange.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CTimeShiftPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRange.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\toolprops.cpp ===
// ToolProps.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ToolPropsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ToolProps.h"

#include "ToolProps_i.c"
#include "EchoPage.h"
#include "TransposePage.h"
#include "DurationPage.h"
#include "QuantizePage.h"
#include "TimeShiftPage.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_EchoPage, CEchoPage)
OBJECT_ENTRY(CLSID_TransposePage, CTransposePage)
OBJECT_ENTRY(CLSID_DurationPage, CDurationPage)
OBJECT_ENTRY(CLSID_QuantizePage, CQuantizePage)
OBJECT_ENTRY(CLSID_TimeShiftPage, CTimeShiftPage)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TOOLPROPSLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtool\toolprops\transposepage.cpp ===
// TransposePage.cpp : Implementation of CTransposePage
#include "stdafx.h"
#include "ToolProps.h"
#include "TransposePage.h"


/////////////////////////////////////////////////////////////////////////////
// CTransposePage

CTransposePage::CTransposePage() 
{
	m_dwTitleID = IDS_TITLETransposePage;
	m_dwHelpFileID = IDS_HELPFILETransposePage;
	m_dwDocStringID = IDS_DOCSTRINGTransposePage;
    m_pTranspose = NULL;
}

CTransposePage::~CTransposePage()

{
    if (m_pTranspose)
    {
        m_pTranspose->Release();
    }
}

STDMETHODIMP CTransposePage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicTransposeTool,(void **) &m_pTranspose);
}


STDMETHODIMP CTransposePage::Apply(void)

{
    m_pTranspose->SetTranspose((long) m_ctTranspose.GetValue());
    m_pTranspose->SetType(m_ctType.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

LRESULT CTransposePage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pTranspose)
    {
        static char *pTypes[2] = { "Linear","In Scale"};
        m_ctTranspose.Init(GetDlgItem(IDC_TRANSPOSE),GetDlgItem(IDC_TRANSPOSE_DISPLAY),-24,24,true);
        m_ctType.Init(GetDlgItem(IDC_TYPE),IDC_TYPE,pTypes,2);

        DWORD dwType;
        m_pTranspose->GetType(&dwType);
        m_ctType.SetValue(dwType);
        long lTranspose;
        m_pTranspose->GetTranspose(&lTranspose);
        m_ctTranspose.SetValue((float)lTranspose);
    }
	return 1;
}

LRESULT CTransposePage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctTranspose.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
        lr = m_ctType.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CTransposePage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctTranspose.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\controlhelp.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Implementation of CSliderValue.
//

#include "stdafx.h"
#include "ControlHelp.h"
#include <commctrl.h>
#include <stdio.h>

//////////////////////////////////////////////////////////////////////////////
// CSliderValue

const short g_sMaxContinuousTicks = 200;
const int g_iMaxCharBuffer = 50; // # characters big enough to hold -FLT_MAX with room to spare

CSliderValue::CSliderValue()
  : m_fInit(false)
{
}

void CSliderValue::SetRange(float fMin, float fMax)

{
    if (m_fInit)
    {
        m_fMin = fMin;
        m_fMax = fMax;

        short sMin;
        short sMax;
        short sTicks = 4; // Lots of ticks become less useful as guides.  Use quarters for fine-grained sliders.
        if (m_fDiscrete) 
        {
            sMin = static_cast<short>(fMin);
            sMax = static_cast<short>(fMax);
            if (sMax - sMin <= 10)
                sTicks = sMax - sMin;
        }
        else
        {
            sMin = 0;
            sMax = g_sMaxContinuousTicks;
        }
    
        SendMessage(m_hwndSlider, TBM_SETRANGE, TRUE, MAKELONG(sMin, sMax));
        SendMessage(m_hwndSlider, TBM_SETTICFREQ, (sMax - sMin) / sTicks, 0);
    }
}

void CSliderValue::Init(
        HWND        hwndSlider,
        HWND        hwndEdit,
        float       fMin, 
        float       fMax, 
        bool        fDiscrete)
{
    if (m_fInit)
        return;

    m_hwndSlider = hwndSlider;
    m_hwndEdit = hwndEdit;
    m_fDiscrete = fDiscrete;
    m_fInit = true;
    SetRange(fMin,fMax);
}

void CSliderValue::SetValue(float fPos)
{
    if (!m_fInit)
        return;

    UpdateEditBox(fPos);
    UpdateSlider();
}

float CSliderValue::GetValue()
{
    if (!m_fInit)
        return 0;

    LRESULT lrLen = SendMessage(m_hwndEdit, WM_GETTEXTLENGTH, 0, 0);
    if (lrLen >= g_iMaxCharBuffer)
        return 0;

    char szText[g_iMaxCharBuffer] = "";
    SendMessage(m_hwndEdit, WM_GETTEXT, g_iMaxCharBuffer, reinterpret_cast<LPARAM>(szText));

    float fVal = static_cast<float>(m_fDiscrete ? atoi(szText) : atof(szText));

    if (fVal < m_fMin) fVal = m_fMin;
    if (fVal > m_fMax) fVal = m_fMax;
    return fVal;
}

float CSliderValue::GetSliderValue()
{
    short sPos = static_cast<short>(SendMessage(m_hwndSlider, TBM_GETPOS, 0, 0));
    if (m_fDiscrete)
    {
        return sPos;
    }

    float fRet = (m_fMax - m_fMin) * sPos / g_sMaxContinuousTicks + m_fMin;
    return fRet;
}

LRESULT CSliderValue::MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_fInit)
        return FALSE;

    switch (uMsg)
    {
    case WM_HSCROLL:
        if (bHandled = (reinterpret_cast<HWND>(lParam) == m_hwndSlider && LOWORD(wParam) >= TB_LINEUP && LOWORD(wParam) <= TB_ENDTRACK))
            UpdateEditBox(GetSliderValue());
        break;

    case WM_COMMAND:
        if (bHandled = (HIWORD(wParam) == EN_KILLFOCUS && reinterpret_cast<HWND>(lParam) == m_hwndEdit))
            UpdateSlider();
        break;

    default:
        bHandled = FALSE;
        break;
    }

    return 0;
}

void CSliderValue::UpdateEditBox(float fPos)
{
    char szText[g_iMaxCharBuffer] = "";

    if (m_fDiscrete)
    {
        short sPos = static_cast<short>(fPos);
        sprintf(szText, "%hd", sPos);
    }
    else
    {
        sprintf(szText, "%.2hf", fPos);
    }

    SendMessage(m_hwndEdit, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(szText));
}

void CSliderValue::UpdateSlider()
{
    float fVal = GetValue();
    short sPos = static_cast<short>(m_fDiscrete ? fVal : g_sMaxContinuousTicks * ((fVal - m_fMin) / (m_fMax - m_fMin)));
    SendMessage(m_hwndSlider, TBM_SETPOS, TRUE, sPos);
    UpdateEditBox(fVal); // this resets the input box back to the set float value in case the input was invalid
}

CComboHelp::CComboHelp()
{
    m_hwndCombo = NULL;
    m_fInit = FALSE;
}

void CComboHelp::Init(HWND hwndCombo, int nID, char *pStrings[], DWORD cbStrings)
{
    DWORD dwIndex;
    m_hwndCombo = hwndCombo;
    m_nID = nID;
    for (dwIndex = 0; dwIndex < cbStrings; dwIndex++)
    {
        SendMessage( hwndCombo,CB_ADDSTRING,0,(LPARAM)pStrings[dwIndex]);
    }
    m_fInit = TRUE;
}

void CComboHelp::SetValue(DWORD dwValue)
{
    SendMessage(m_hwndCombo,CB_SETCURSEL,dwValue,0);
}

DWORD CComboHelp::GetValue()
{
    return (DWORD) SendMessage( m_hwndCombo,CB_GETCURSEL,0,0);
}

LRESULT CComboHelp::MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_fInit)
        return FALSE;

    switch (uMsg)
    {
    case WM_COMMAND:
        bHandled = ((HIWORD(wParam) == CBN_SELCHANGE) && (LOWORD(wParam) == m_nID));
        break;
    default:
        bHandled = FALSE;
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\controlhelp.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Declaration of CSliderValue.
//

#pragma once

class CSliderValue
{
public:
    CSliderValue();
    void Init(HWND hwndSlider, HWND hwndEdit, float fMin, float fMax, bool fDiscrete);
    void SetRange(float fMin, float fMax);
    void SetValue(float fPos);
    float GetValue();

    LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    bool                m_fInit;
    HWND                m_hwndSlider;
    HWND                m_hwndEdit;
    float               m_fMin;
    float               m_fMax;
    bool                m_fDiscrete;

public:
    float GetSliderValue();
    void UpdateEditBox(float fPos);
    void UpdateSlider();
};

class CComboHelp
{
public:
    CComboHelp();
    void Init(HWND hwndCombo, int nID, char *pStrings[], DWORD cbStrings);
    void SetValue(DWORD dwValue);
    DWORD GetValue();
    LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
private:
    bool                m_fInit;
    int                 m_nID;
    HWND                m_hwndCombo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\durationpage.cpp ===
// DurationPage.cpp : Implementation of CDurationPage
#include "stdafx.h"
#include "ToolProps.h"
#include "DurationPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDurationPage

CDurationPage::CDurationPage() 
{
	m_dwTitleID = IDS_TITLEDurationPage;
	m_dwHelpFileID = IDS_HELPFILEDurationPage;
	m_dwDocStringID = IDS_DOCSTRINGDurationPage;
    m_pDuration = NULL;
}

CDurationPage::~CDurationPage()

{
    if (m_pDuration)
    {
        m_pDuration->Release();
    }
}

STDMETHODIMP CDurationPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicDurationTool,(void **) &m_pDuration);
}


STDMETHODIMP CDurationPage::Apply(void)

{
    m_pDuration->SetScale(m_ctScale.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

LRESULT CDurationPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pDuration)
    {
        m_ctScale.Init(GetDlgItem(IDC_SCALE),GetDlgItem(IDC_SCALE_DISPLAY),0,8.0,false);

        float fScale;
        m_pDuration->GetScale(&fScale);
        m_ctScale.SetValue(fScale);
    }
	return 1;
}

LRESULT CDurationPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctScale.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CDurationPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctScale.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\quantizepage.cpp ===
// QuantizePage.cpp : Implementation of CQuantizePage
#include "stdafx.h"
#include "ToolProps.h"
#include "QuantizePage.h"

/////////////////////////////////////////////////////////////////////////////
// CQuantizePage

CQuantizePage::CQuantizePage() 
{
	m_dwTitleID = IDS_TITLEQuantizePage;
	m_dwHelpFileID = IDS_HELPFILEQuantizePage;
	m_dwDocStringID = IDS_DOCSTRINGQuantizePage;
    m_pQuantize = NULL;
}

CQuantizePage::~CQuantizePage()

{
    if (m_pQuantize)
    {
        m_pQuantize->Release();
    }
}

STDMETHODIMP CQuantizePage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicQuantizeTool,(void **) &m_pQuantize);
}


STDMETHODIMP CQuantizePage::Apply(void)

{
    m_pQuantize->SetStrength((DWORD) m_ctStrength.GetValue());
	m_pQuantize->SetResolution((DWORD) m_ctResolution.GetValue());
    m_pQuantize->SetType(m_ctType.GetValue());
    m_pQuantize->SetTimeUnit(m_ctTimeUnit.GetValue()+1);
	m_bDirty = FALSE;
	return S_OK;
}

void CQuantizePage::SetTimeUnitRange()

{
    DWORD dwRes = m_ctTimeUnit.GetValue();
    if (dwRes < 1)
    {
        m_ctResolution.SetRange(0,1000);
    }
    else
    {
        m_ctResolution.SetRange(0,12);
    }
}

LRESULT CQuantizePage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pQuantize)
    {
        static char *pTypes[3] = { "Quantize Start Time","Quantize Duration","Quantize Start and Duration"};
        static char *pTimeUnit[DMUS_TIME_UNIT_COUNT-1] = { 
            "Music Clicks","Grid", "Beat","Bar",
            "64th note triplets", "64th notes",
            "32nd note triplets",
            "32nd notes","16th note triplets","16th notes",
            "8th note triplets","8th notes","Quarter note triplets",
            "Quarter notes","Half note triplets","Half notes",
            "Whole note triplets", "Whole notes"
        };
        m_ctStrength.Init(GetDlgItem(IDC_STRENGTH),GetDlgItem(IDC_STRENGTH_DISPLAY),0,120,true);
        m_ctResolution.Init(GetDlgItem(IDC_RESOLUTION),GetDlgItem(IDC_RESOLUTION_DISPLAY),0,12,true);
        m_ctType.Init(GetDlgItem(IDC_TYPE),IDC_TYPE,pTypes,3);
        m_ctTimeUnit.Init(GetDlgItem(IDC_TIMEUNIT),IDC_TIMEUNIT,pTimeUnit,DMUS_TIME_UNIT_COUNT-1);

        DWORD dwValue;
        m_pQuantize->GetType(&dwValue);
        m_ctType.SetValue(dwValue);
        m_pQuantize->GetTimeUnit(&dwValue);
        m_ctTimeUnit.SetValue(dwValue-1);
        SetTimeUnitRange();
        m_pQuantize->GetStrength(&dwValue);
        m_ctStrength.SetValue((float)dwValue);
        m_pQuantize->GetResolution(&dwValue);
        m_ctResolution.SetValue((float)dwValue);
    }
	return 1;
}

LRESULT CQuantizePage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctStrength.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctResolution.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled)
        lr = m_ctType.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled) 
    {
        lr = m_ctTimeUnit.MessageHandler(uMsg, wParam, lParam, bHandled);
        if (bHandled) 
        {
            SetTimeUnitRange();
        }
    }
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CQuantizePage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctStrength.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctResolution.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B54A32F6_F277_470E_AC31_3ECE7AB2A3B4__INCLUDED_)
#define AFX_STDAFX_H__B54A32F6_F277_470E_AC31_3ECE7AB2A3B4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B54A32F6_F277_470E_AC31_3ECE7AB2A3B4__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\durationpage.h ===
// DurationPage.h : Declaration of the CDurationPage

#ifndef __DURATIONPAGE_H_
#define __DURATIONPAGE_H_

#include "resource.h"       // main symbols
#include "..\dmtool\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DurationPage;

/////////////////////////////////////////////////////////////////////////////
// CDurationPage
class ATL_NO_VTABLE CDurationPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDurationPage, &CLSID_DurationPage>,
	public IPropertyPageImpl<CDurationPage>,
	public CDialogImpl<CDurationPage>
{
public:
	CDurationPage();
    virtual ~CDurationPage();

	enum {IDD = IDD_DURATIONPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DURATIONPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDurationPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDurationPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CDurationPage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    IDirectMusicDurationTool *  m_pDuration;
    CSliderValue                m_ctScale;
};

#endif //__DURATIONPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\echopage.h ===
// EchoPage.h : Declaration of the CEchoPage

#ifndef __ECHOPAGE_H_
#define __ECHOPAGE_H_

#include "resource.h"       // main symbols
#include "..\dmtool\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_EchoPage;

/////////////////////////////////////////////////////////////////////////////
// CEchoPage
class ATL_NO_VTABLE CEchoPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEchoPage, &CLSID_EchoPage>,
	public IPropertyPageImpl<CEchoPage>,
	public CDialogImpl<CEchoPage>
{
public:
	CEchoPage();
    virtual ~CEchoPage();

	enum {IDD = IDD_ECHOPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_ECHOPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEchoPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CEchoPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CEchoPage>)
END_MSG_MAP()

// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//    LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    void SetTimeUnitRange();
    IDirectMusicEchoTool *m_pEcho;
    CSliderValue          m_ctRepeat;
    CSliderValue          m_ctDecay;
    CSliderValue          m_ctDelay;
    CSliderValue          m_ctOffset;
    CComboHelp            m_ctTimeUnit;
    CComboHelp            m_ctType;
};

#endif //__ECHOPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\quantizepage.h ===
// QuantizePage.h : Declaration of the CQuantizePage

#ifndef __QUANTIZEPAGE_H_
#define __QUANTIZEPAGE_H_

#include "resource.h"       // main symbols
#include "..\dmtool\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_QuantizePage;

/////////////////////////////////////////////////////////////////////////////
// CQuantizePage
class ATL_NO_VTABLE CQuantizePage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CQuantizePage, &CLSID_QuantizePage>,
	public IPropertyPageImpl<CQuantizePage>,
	public CDialogImpl<CQuantizePage>
{
public:
	CQuantizePage();
    virtual ~CQuantizePage();

	enum {IDD = IDD_QUANTIZEPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_QUANTIZEPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CQuantizePage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CQuantizePage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CQuantizePage>)
END_MSG_MAP()

// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    void SetTimeUnitRange();
    IDirectMusicQuantizeTool *m_pQuantize;
    CSliderValue          m_ctStrength;
    CSliderValue          m_ctResolution;
    CComboHelp            m_ctTimeUnit;
    CComboHelp            m_ctType;
};

#endif //__QUANTIZEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\echopage.cpp ===
// EchoPage.cpp : Implementation of CEchoPage
#include "stdafx.h"
#include "ToolProps.h"
#include "EchoPage.h"


/////////////////////////////////////////////////////////////////////////////
// CEchoPage

CEchoPage::CEchoPage() 
{
	m_dwTitleID = IDS_TITLEEchoPage;
	m_dwHelpFileID = IDS_HELPFILEEchoPage;
	m_dwDocStringID = IDS_DOCSTRINGEchoPage;
    m_pEcho = NULL;
}

CEchoPage::~CEchoPage()

{
    if (m_pEcho)
    {
        m_pEcho->Release();
    }
}

STDMETHODIMP CEchoPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicEchoTool,(void **) &m_pEcho);
}


STDMETHODIMP CEchoPage::Apply(void)

{
    m_pEcho->SetRepeat((DWORD) m_ctRepeat.GetValue());
	m_pEcho->SetDecay((DWORD) m_ctDecay.GetValue());
    m_pEcho->SetDelay((DWORD) m_ctDelay.GetValue());
    m_pEcho->SetGroupOffset((DWORD) m_ctOffset.GetValue());
    m_pEcho->SetType(m_ctType.GetValue());
    m_pEcho->SetTimeUnit(m_ctTimeUnit.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

void CEchoPage::SetTimeUnitRange()

{
    DWORD dwRes = m_ctTimeUnit.GetValue();
    if (dwRes < 2)
    {
        m_ctDelay.SetRange(0,1000);
    }
    else
    {
        m_ctDelay.SetRange(0,12);
        m_ctDelay.UpdateSlider();
    }
}

LRESULT CEchoPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pEcho)
    {
        static char *pTypes[4] = { "Falling","Falling, Truncated","Rising","Rising, Truncated"};
        static char *pTimeUnit[DMUS_TIME_UNIT_COUNT] = { 
            "Milliseconds","Music Clicks","Grid", "Beat","Bar",
            "64th note triplets", "64th notes",
            "32nd note triplets",
            "32nd notes","16th note triplets","16th notes",
            "8th note triplets","8th notes","Quarter note triplets",
            "Quarter notes","Half note triplets","Half notes",
            "Whole note triplets", "Whole notes"
        };
        m_ctRepeat.Init(GetDlgItem(IDC_REPEAT),GetDlgItem(IDC_REPEAT_DISPLAY),0,24,true);
        m_ctDelay.Init(GetDlgItem(IDC_DELAY),GetDlgItem(IDC_DELAY_DISPLAY),0,12,true);
        m_ctDecay.Init(GetDlgItem(IDC_DECAY),GetDlgItem(IDC_DECAY_DISPLAY),0,100,true);
        m_ctOffset.Init(GetDlgItem(IDC_OFFSET),GetDlgItem(IDC_OFFSET_DISPLAY),0,10,true);
        m_ctType.Init(GetDlgItem(IDC_TYPE),IDC_TYPE,pTypes,4);
        m_ctTimeUnit.Init(GetDlgItem(IDC_TIMEUNIT),IDC_TIMEUNIT,pTimeUnit,DMUS_TIME_UNIT_COUNT);

        DWORD dwValue;
        m_pEcho->GetType(&dwValue);
        m_ctType.SetValue(dwValue);
        m_pEcho->GetTimeUnit(&dwValue);
        m_ctTimeUnit.SetValue(dwValue);
        SetTimeUnitRange();
        m_pEcho->GetRepeat(&dwValue);
        m_ctRepeat.SetValue((float)dwValue);
        m_pEcho->GetDelay(&dwValue);
        m_ctDelay.SetValue((float)dwValue);
        m_pEcho->GetDecay(&dwValue);
        m_ctDecay.SetValue((float)dwValue);
        m_pEcho->GetGroupOffset(&dwValue);
        m_ctOffset.SetValue((float)dwValue);
    }
	return 1;
}

LRESULT CEchoPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRepeat.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDelay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDecay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled)
        lr = m_ctType.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled) 
    {
        lr = m_ctTimeUnit.MessageHandler(uMsg, wParam, lParam, bHandled);
        if (bHandled) 
        {
            SetTimeUnitRange();
        }
    }
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CEchoPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRepeat.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDelay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDecay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\swingpage.cpp ===
// SwingPage.cpp : Implementation of CSwingPage
#include "stdafx.h"
#include "ToolProps.h"
#include "SwingPage.h"

/////////////////////////////////////////////////////////////////////////////
// CSwingPage

CSwingPage::CSwingPage() 
{
	m_dwTitleID = IDS_TITLESwingPage;
	m_dwHelpFileID = IDS_HELPFILESwingPage;
	m_dwDocStringID = IDS_DOCSTRINGSwingPage;
    m_pSwing = NULL;
}

CSwingPage::~CSwingPage()

{
    if (m_pSwing)
    {
        m_pSwing->Release();
    }
}

STDMETHODIMP CSwingPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicSwingTool,(void **) &m_pSwing);
}


STDMETHODIMP CSwingPage::Apply(void)

{
    m_pSwing->SetStrength((DWORD)m_ctSwing.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

LRESULT CSwingPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pSwing)
    {
        m_ctSwing.Init(GetDlgItem(IDC_SWING),GetDlgItem(IDC_SWING_DISPLAY),0,100,true);

        DWORD dwSwing;
        m_pSwing->GetStrength(&dwSwing);
        m_ctSwing.SetValue((float)dwSwing);
    }
	return 1;
}

LRESULT CSwingPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctSwing.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CSwingPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctSwing.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ToolProps.rc
//
#define IDS_PROJNAME                    100
#define IDS_TITLEEchoPage               101
#define IDS_HELPFILEEchoPage            102
#define IDS_DOCSTRINGEchoPage           103
#define IDR_ECHOPAGE                    104
#define IDD_ECHOPAGE                    105
#define IDS_TITLETransposePage          106
#define IDS_HELPFILETransposePage       107
#define IDS_DOCSTRINGTransposePage      108
#define IDR_TRANSPOSEPAGE               109
#define IDD_TRANSPOSEPAGE               110
#define IDS_TITLEDurationPage           111
#define IDS_HELPFILEDurationPage        112
#define IDS_DOCSTRINGDurationPage       113
#define IDR_DURATIONPAGE                114
#define IDD_DURATIONPAGE                115
#define IDS_TITLEQuantizePage           116
#define IDS_HELPFILEQuantizePage        117
#define IDS_DOCSTRINGQuantizePage       118
#define IDR_QUANTIZEPAGE                119
#define IDD_QUANTIZEPAGE                120
#define IDS_TITLETimeShiftPage          121
#define IDS_HELPFILETimeShiftPage       122
#define IDS_DOCSTRINGTimeShiftPage      123
#define IDR_TIMESHIFTPAGE               124
#define IDD_TIMESHIFTPAGE               125
#define IDS_TITLESwingPage              126
#define IDS_HELPFILESwingPage           127
#define IDS_DOCSTRINGSwingPage          128
#define IDR_SWINGPAGE                   129
#define IDD_SWINGPAGE                   130
#define IDS_TITLEVelocityPage           131
#define IDS_HELPFILEVelocityPage        132
#define IDS_DOCSTRINGVelocityPage       133
#define IDR_VELOCITYPAGE                134
#define IDD_VELOCITYPAGE                135
#define IDC_REPEAT                      201
#define IDC_REPEAT_DISPLAY              202
#define IDC_DECAY                       203
#define IDC_DECAY_DISPLAY               204
#define IDC_DELAY                       205
#define IDC_DELAY_DISPLAY               206
#define IDC_OFFSET                      207
#define IDC_OFFSET_DISPLAY              208
#define IDC_TIMEUNIT                    209
#define IDC_TYPE                        210
#define IDC_TRANSPOSE                   211
#define IDC_TRANSPOSE_DISPLAY           212
#define IDC_SCALE                       213
#define IDC_SCALE_DISPLAY               214
#define IDC_STRENGTH                    215
#define IDC_STRENGTH_DISPLAY            216
#define IDC_RESOLUTION                  217
#define IDC_LOWERLIMIT                  217
#define IDC_RESOLUTION_DISPLAY          218
#define IDC_LOWERLIMIT_DISPLAY          218
#define IDC_RANGE                       219
#define IDC_UPPERLIMIT                  219
#define IDC_RANGE_DISPLAY               220
#define IDC_UPPERLIMIT_DISPLAY          220
#define IDC_SWING                       221
#define IDC_CURVESTART                  221
#define IDC_SWING_DISPLAY               222
#define IDC_CURVESTART_DISPLAY          222
#define IDC_CURVEEND                    223
#define IDC_CURVEEND_DISPLAY            224
#define IDC_DISPLAY_CURVE               225

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         226
#define _APS_NEXT_SYMED_VALUE           136
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\sources.inc ===
!ifndef DXROOT
DXROOT=$(BASEDIR)\multimedia\directx
!endif

!include $(DXROOT)\project.mk

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmtoolprp

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF

TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\toolprops.def
DLLENTRY=_DllMainCRTStartup

USE_MSVCRT=1
USE_MAPSYM=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

ATL_VER=30
USE_ATL=1

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\gdi32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\oleaut32.lib \
    $(BASEDIR)\public\sdk\lib\*\kernel32.lib    \
    $(BASEDIR)\public\sdk\lib\*\user32.lib      \
    $(BASEDIR)\public\sdk\lib\*\ole32.lib       \
    $(BASEDIR)\public\sdk\lib\*\uuid.lib

SOURCES=\
    ..\toolprops.idl                      \
    ..\ControlHelp.cpp                   \
    ..\DurationPage.cpp       \
    ..\EchoPage.cpp   \
    ..\QuantizePage.cpp   \
	..\SwingPage.cpp		\
    ..\TimeShiftPage.cpp         \
    ..\TransposePage.cpp      \
	..\VelocityPage.cpp   \
    ..\toolprops.cpp                      \
    ..\toolprops.rc                       \
    ..\StdAfx.cpp

NTTARGETFILE0 = buildidl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\swingpage.h ===
// SwingPage.h : Declaration of the CSwingPage

#ifndef __SWINGPAGE_H_
#define __SWINGPAGE_H_

#include "resource.h"       // main symbols
#include "..\dmtool\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_SwingPage;

/////////////////////////////////////////////////////////////////////////////
// CSwingPage
class ATL_NO_VTABLE CSwingPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSwingPage, &CLSID_SwingPage>,
	public IPropertyPageImpl<CSwingPage>,
	public CDialogImpl<CSwingPage>
{
public:
	CSwingPage(); 
    virtual ~CSwingPage();

	enum {IDD = IDD_SWINGPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_SWINGPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSwingPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CSwingPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CSwingPage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    IDirectMusicSwingTool *     m_pSwing;
    CSliderValue                m_ctSwing;
};

#endif //__SWINGPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\toolprops.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Sun May 21 19:29:49 2000
 */
/* Compiler settings for C:\nt\multimedia\Directx\dmusic\dmtoolprp\ToolProps.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __ToolProps_h__
#define __ToolProps_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __EchoPage_FWD_DEFINED__
#define __EchoPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class EchoPage EchoPage;
#else
typedef struct EchoPage EchoPage;
#endif /* __cplusplus */

#endif 	/* __EchoPage_FWD_DEFINED__ */


#ifndef __TransposePage_FWD_DEFINED__
#define __TransposePage_FWD_DEFINED__

#ifdef __cplusplus
typedef class TransposePage TransposePage;
#else
typedef struct TransposePage TransposePage;
#endif /* __cplusplus */

#endif 	/* __TransposePage_FWD_DEFINED__ */


#ifndef __DurationPage_FWD_DEFINED__
#define __DurationPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class DurationPage DurationPage;
#else
typedef struct DurationPage DurationPage;
#endif /* __cplusplus */

#endif 	/* __DurationPage_FWD_DEFINED__ */


#ifndef __QuantizePage_FWD_DEFINED__
#define __QuantizePage_FWD_DEFINED__

#ifdef __cplusplus
typedef class QuantizePage QuantizePage;
#else
typedef struct QuantizePage QuantizePage;
#endif /* __cplusplus */

#endif 	/* __QuantizePage_FWD_DEFINED__ */


#ifndef __TimeShiftPage_FWD_DEFINED__
#define __TimeShiftPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class TimeShiftPage TimeShiftPage;
#else
typedef struct TimeShiftPage TimeShiftPage;
#endif /* __cplusplus */

#endif 	/* __TimeShiftPage_FWD_DEFINED__ */


#ifndef __SwingPage_FWD_DEFINED__
#define __SwingPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class SwingPage SwingPage;
#else
typedef struct SwingPage SwingPage;
#endif /* __cplusplus */

#endif 	/* __SwingPage_FWD_DEFINED__ */


#ifndef __VelocityPage_FWD_DEFINED__
#define __VelocityPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class VelocityPage VelocityPage;
#else
typedef struct VelocityPage VelocityPage;
#endif /* __cplusplus */

#endif 	/* __VelocityPage_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __TOOLPROPSLib_LIBRARY_DEFINED__
#define __TOOLPROPSLib_LIBRARY_DEFINED__

/* library TOOLPROPSLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_TOOLPROPSLib;

EXTERN_C const CLSID CLSID_EchoPage;

#ifdef __cplusplus

class DECLSPEC_UUID("5337AF8F-3827-44DD-9EE9-AB6E1AABB60F")
EchoPage;
#endif

EXTERN_C const CLSID CLSID_TransposePage;

#ifdef __cplusplus

class DECLSPEC_UUID("691BD8C2-2B07-4C92-A82E-92D858DE23D6")
TransposePage;
#endif

EXTERN_C const CLSID CLSID_DurationPage;

#ifdef __cplusplus

class DECLSPEC_UUID("79D9CAF8-DBDA-4560-A8B0-07E73A79FA6B")
DurationPage;
#endif

EXTERN_C const CLSID CLSID_QuantizePage;

#ifdef __cplusplus

class DECLSPEC_UUID("623286DC-67F8-4055-A9BE-F7A7176BD150")
QuantizePage;
#endif

EXTERN_C const CLSID CLSID_TimeShiftPage;

#ifdef __cplusplus

class DECLSPEC_UUID("7D3BDEE7-9557-4085-82EE-1B2F02CE4BA6")
TimeShiftPage;
#endif

EXTERN_C const CLSID CLSID_SwingPage;

#ifdef __cplusplus

class DECLSPEC_UUID("0B237E01-062A-4A40-8D43-4B5FCD49965A")
SwingPage;
#endif

EXTERN_C const CLSID CLSID_VelocityPage;

#ifdef __cplusplus

class DECLSPEC_UUID("30EC7213-64BE-4EF6-BB1B-463427EC864B")
VelocityPage;
#endif
#endif /* __TOOLPROPSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\timeshiftpage.cpp ===
// TimeShiftPage.cpp : Implementation of CTimeShiftPage
#include "stdafx.h"
#include "ToolProps.h"
#include "TimeShiftPage.h"

/////////////////////////////////////////////////////////////////////////////
// CTimeShiftPage

CTimeShiftPage::CTimeShiftPage() 
{
	m_dwTitleID = IDS_TITLETimeShiftPage;
	m_dwHelpFileID = IDS_HELPFILETimeShiftPage;
	m_dwDocStringID = IDS_DOCSTRINGTimeShiftPage;
    m_pTimeShift = NULL;
}

CTimeShiftPage::~CTimeShiftPage()

{
    if (m_pTimeShift)
    {
        m_pTimeShift->Release();
    }
}

STDMETHODIMP CTimeShiftPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicTimeShiftTool,(void **) &m_pTimeShift);
}


STDMETHODIMP CTimeShiftPage::Apply(void)

{
    m_pTimeShift->SetRange((DWORD)m_ctRange.GetValue());
    m_pTimeShift->SetTimeUnit(m_ctTimeUnit.GetValue()+1);
    m_pTimeShift->SetOffset((long)m_ctOffset.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

void CTimeShiftPage::SetTimeUnitRange()

{
    DWORD dwRes = m_ctTimeUnit.GetValue();
    if (dwRes < 1)
    {
        m_ctOffset.SetRange(-1000,1000);
        m_ctRange.SetRange(0,1000);
    }
    else
    {
        m_ctOffset.SetRange(-48,48);
        m_ctRange.SetRange(0,48);
        m_ctOffset.UpdateSlider();
        m_ctRange.UpdateSlider();
    }
}

LRESULT CTimeShiftPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pTimeShift)
    {
        static char *pTimeUnit[DMUS_TIME_UNIT_COUNT-1] = { 
            "Music Clicks","Grid", "Beat","Bar",
            "64th note triplets", "64th notes",
            "32nd note triplets",
            "32nd notes","16th note triplets","16th notes",
            "8th note triplets","8th notes","Quarter note triplets",
            "Quarter notes","Half note triplets","Half notes",
            "Whole note triplets", "Whole notes"
        };
        m_ctRange.Init(GetDlgItem(IDC_RANGE),GetDlgItem(IDC_RANGE_DISPLAY),0,200,true);
        m_ctOffset.Init(GetDlgItem(IDC_OFFSET),GetDlgItem(IDC_OFFSET_DISPLAY),-200,200,true);
        m_ctTimeUnit.Init(GetDlgItem(IDC_TIMEUNIT),IDC_TIMEUNIT,pTimeUnit,DMUS_TIME_UNIT_COUNT-1);

        long lValue;
        m_pTimeShift->GetTimeUnit((DWORD *)&lValue);
        m_ctTimeUnit.SetValue(lValue-1);
        SetTimeUnitRange();
        m_pTimeShift->GetRange((DWORD *)&lValue);
        m_ctRange.SetValue((float)lValue);
        m_pTimeShift->GetOffset(&lValue);
        m_ctOffset.SetValue((float)lValue);
    }
	return 1;
}

LRESULT CTimeShiftPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRange.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled) 
    {
        lr = m_ctTimeUnit.MessageHandler(uMsg, wParam, lParam, bHandled);
        if (bHandled) 
        {
            SetTimeUnitRange();
        }
    }
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CTimeShiftPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRange.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\timeshiftpage.h ===
// TimeShiftPage.h : Declaration of the CTimeShiftPage

#ifndef __TIMESHIFTPAGE_H_
#define __TIMESHIFTPAGE_H_

#include "resource.h"       // main symbols
#include "..\dmtool\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_TimeShiftPage;

/////////////////////////////////////////////////////////////////////////////
// CTimeShiftPage
class ATL_NO_VTABLE CTimeShiftPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTimeShiftPage, &CLSID_TimeShiftPage>,
	public IPropertyPageImpl<CTimeShiftPage>,
	public CDialogImpl<CTimeShiftPage>
{
public:
	CTimeShiftPage();
    virtual ~CTimeShiftPage();

	enum {IDD = IDD_TIMESHIFTPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_TIMESHIFTPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTimeShiftPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CTimeShiftPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CTimeShiftPage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    void SetTimeUnitRange();
    IDirectMusicTimeShiftTool *  m_pTimeShift;
    CComboHelp                   m_ctTimeUnit;
    CSliderValue                 m_ctRange;
    CSliderValue                 m_ctOffset;
};

#endif //__TIMESHIFTPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\toolprops.cpp ===
// ToolProps.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ToolPropsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ToolProps.h"

#include "ToolProps_i.c"
#include "EchoPage.h"
#include "TransposePage.h"
#include "DurationPage.h"
#include "QuantizePage.h"
#include "TimeShiftPage.h"
#include "SwingPage.h"
#include "VelocityPage.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_EchoPage, CEchoPage)
OBJECT_ENTRY(CLSID_TransposePage, CTransposePage)
OBJECT_ENTRY(CLSID_DurationPage, CDurationPage)
OBJECT_ENTRY(CLSID_QuantizePage, CQuantizePage)
OBJECT_ENTRY(CLSID_TimeShiftPage, CTimeShiftPage)
OBJECT_ENTRY(CLSID_SwingPage, CSwingPage)
OBJECT_ENTRY(CLSID_VelocityPage, CVelocityPage)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TOOLPROPSLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\transposepage.cpp ===
// TransposePage.cpp : Implementation of CTransposePage
#include "stdafx.h"
#include "ToolProps.h"
#include "TransposePage.h"

/////////////////////////////////////////////////////////////////////////////
// CTransposePage

CTransposePage::CTransposePage() 
{
	m_dwTitleID = IDS_TITLETransposePage;
	m_dwHelpFileID = IDS_HELPFILETransposePage;
	m_dwDocStringID = IDS_DOCSTRINGTransposePage;
    m_pTranspose = NULL;
}

CTransposePage::~CTransposePage()

{
    if (m_pTranspose)
    {
        m_pTranspose->Release();
    }
}

STDMETHODIMP CTransposePage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicTransposeTool,(void **) &m_pTranspose);
}


STDMETHODIMP CTransposePage::Apply(void)

{
    m_pTranspose->SetTranspose((long) m_ctTranspose.GetValue());
    m_pTranspose->SetType(m_ctType.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

LRESULT CTransposePage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pTranspose)
    {
        static char *pTypes[2] = { "Linear","In Scale"};
        m_ctTranspose.Init(GetDlgItem(IDC_TRANSPOSE),GetDlgItem(IDC_TRANSPOSE_DISPLAY),-24,24,true);
        m_ctType.Init(GetDlgItem(IDC_TYPE),IDC_TYPE,pTypes,2);

        DWORD dwType;
        m_pTranspose->GetType(&dwType);
        m_ctType.SetValue(dwType);
        long lTranspose;
        m_pTranspose->GetTranspose(&lTranspose);
        m_ctTranspose.SetValue((float)lTranspose);
    }
	return 1;
}

LRESULT CTransposePage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctTranspose.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
        lr = m_ctType.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CTransposePage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctTranspose.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\transposepage.h ===
// TransposePage.h : Declaration of the CTransposePage

#ifndef __TRANSPOSEPAGE_H_
#define __TRANSPOSEPAGE_H_

#include "resource.h"       // main symbols
#include "..\dmtool\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_TransposePage;

/////////////////////////////////////////////////////////////////////////////
// CTransposePage
class ATL_NO_VTABLE CTransposePage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTransposePage, &CLSID_TransposePage>,
	public IPropertyPageImpl<CTransposePage>,
	public CDialogImpl<CTransposePage>
{
public:
	CTransposePage();
    virtual ~CTransposePage();

	enum {IDD = IDD_TRANSPOSEPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_TRANSPOSEPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTransposePage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CTransposePage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CTransposePage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    IDirectMusicTransposeTool * m_pTranspose;
    CSliderValue                m_ctTranspose;
    CComboHelp                  m_ctType;
};

#endif //__TRANSPOSEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\velocitypage.h ===
// VelocityPage.h : Declaration of the CVelocityPage

#ifndef __VELOCITYPAGE_H_
#define __VELOCITYPAGE_H_

#include "resource.h"       // main symbols
#include "..\dmtool\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_VelocityPage;

/////////////////////////////////////////////////////////////////////////////
// CVelocityPage
class ATL_NO_VTABLE CVelocityPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CVelocityPage, &CLSID_VelocityPage>,
	public IPropertyPageImpl<CVelocityPage>,
	public CDialogImpl<CVelocityPage>
{
public:
	CVelocityPage();
    virtual ~CVelocityPage();

	enum {IDD = IDD_VELOCITYPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_VELOCITYPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CVelocityPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CVelocityPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	MESSAGE_HANDLER(WM_PAINT, OnPaint);
	CHAIN_MSG_MAP(IPropertyPageImpl<CVelocityPage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    IDirectMusicVelocityTool *  m_pVelocity;
    CSliderValue                m_ctStrength;
    CSliderValue                m_ctLowLimit;
    CSliderValue                m_ctHighLimit;
    CSliderValue                m_ctCurveStart;
    CSliderValue                m_ctCurveEnd;
    RECT                        m_rectDisplay;
    void                        DrawCurve(HDC hDCIn);
};

#endif //__VELOCITYPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\velocitypage.cpp ===
// VelocityPage.cpp : Implementation of CVelocityPage
#include "stdafx.h"
#include "ToolProps.h"
#include "VelocityPage.h"

/////////////////////////////////////////////////////////////////////////////
// CVelocityPage

CVelocityPage::CVelocityPage() 
{
	m_dwTitleID = IDS_TITLEVelocityPage;
	m_dwHelpFileID = IDS_HELPFILEVelocityPage;
	m_dwDocStringID = IDS_DOCSTRINGVelocityPage;
    m_pVelocity = NULL;
}

CVelocityPage::~CVelocityPage()

{
    if (m_pVelocity)
    {
        m_pVelocity->Release();
    }
}

STDMETHODIMP CVelocityPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicVelocityTool,(void **) &m_pVelocity);
}


STDMETHODIMP CVelocityPage::Apply(void)

{
    m_pVelocity->SetStrength((long) m_ctStrength.GetValue());
    m_pVelocity->SetLowLimit((long) m_ctLowLimit.GetValue());
    m_pVelocity->SetHighLimit((long) m_ctHighLimit.GetValue());
    m_pVelocity->SetCurveStart((long) m_ctCurveStart.GetValue());
    m_pVelocity->SetCurveEnd((long) m_ctCurveEnd.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

LRESULT CVelocityPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pVelocity)
    {
        m_ctStrength.Init(GetDlgItem(IDC_STRENGTH),GetDlgItem(IDC_STRENGTH_DISPLAY),0,100,true);
        m_ctLowLimit.Init(GetDlgItem(IDC_LOWERLIMIT),GetDlgItem(IDC_LOWERLIMIT_DISPLAY),1,127,true);
        m_ctHighLimit.Init(GetDlgItem(IDC_UPPERLIMIT),GetDlgItem(IDC_UPPERLIMIT_DISPLAY),1,127,true);
        m_ctCurveStart.Init(GetDlgItem(IDC_CURVESTART),GetDlgItem(IDC_CURVESTART_DISPLAY),1,127,true);
        m_ctCurveEnd.Init(GetDlgItem(IDC_CURVEEND),GetDlgItem(IDC_CURVEEND_DISPLAY),1,127,true);

        long lValue;
        m_pVelocity->GetStrength(&lValue);
        m_ctStrength.SetValue((float)lValue);
        m_pVelocity->GetLowLimit(&lValue);
        m_ctLowLimit.SetValue((float)lValue);
        m_pVelocity->GetHighLimit(&lValue);
        m_ctHighLimit.SetValue((float)lValue);
        m_pVelocity->GetCurveStart(&lValue);
        m_ctCurveStart.SetValue((float)lValue);
        m_pVelocity->GetCurveEnd(&lValue);
        m_ctCurveEnd.SetValue((float)lValue);

        HWND hWnd = GetDlgItem(IDC_DISPLAY_CURVE);
        ::GetWindowRect(hWnd,&m_rectDisplay);
        ::DestroyWindow(hWnd);
        ScreenToClient(&m_rectDisplay);
    }
	return 1;
}

void CVelocityPage::DrawCurve(HDC hDCIn)

{
    float fLowLimit = m_ctLowLimit.GetValue() * (m_rectDisplay.top - m_rectDisplay.bottom ) / 127;
    float fHighLimit = m_ctHighLimit.GetValue() * (m_rectDisplay.top - m_rectDisplay.bottom) / 127;
    float fCurveStart = m_ctCurveStart.GetValue() * (m_rectDisplay.right - m_rectDisplay.left) / 127;
    float fCurveEnd = m_ctCurveEnd.GetValue() * (m_rectDisplay.right - m_rectDisplay.left ) / 127;
    
    HDC hDC;
    if (!hDCIn)
    {
        hDC = ::GetDC(m_hWnd);
    }
    else
    {
        hDC = hDCIn;
    }
    if (hDC)
    {
        m_rectDisplay.bottom++;
        ::FillRect(hDC, &m_rectDisplay, (HBRUSH) (COLOR_GRADIENTACTIVECAPTION));
        m_rectDisplay.bottom--;
        HPEN hPen = CreatePen(PS_SOLID,1,RGB(0,0,0));
        if (hPen)
        {
            HPEN hOldPen = (HPEN) ::SelectObject(hDC,hPen);
            ::MoveToEx(hDC,m_rectDisplay.left,m_rectDisplay.bottom + (int) fLowLimit,NULL);
            ::LineTo(hDC,m_rectDisplay.left + (int) fCurveStart,m_rectDisplay.bottom + (int) fLowLimit);
            ::LineTo(hDC,m_rectDisplay.left + (int) fCurveEnd,m_rectDisplay.bottom + (int) fHighLimit);
            ::LineTo(hDC,m_rectDisplay.right,m_rectDisplay.bottom + (int) fHighLimit);
            ::DeleteObject(hPen);
        }
        if (!hDCIn)
        {
            ::ReleaseDC(m_hWnd,hDC);
        }
    }
}

LRESULT CVelocityPage::OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
    PAINTSTRUCT Paint;
    HDC hDC = ::BeginPaint(m_hWnd,&Paint);
    if (hDC)
    {
        DrawCurve(hDC);
        ::EndPaint(m_hWnd,&Paint);
    }
    return true;
}

LRESULT CVelocityPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctStrength.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
        lr = m_ctLowLimit.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
        lr = m_ctHighLimit.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
        lr = m_ctCurveStart.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
        lr = m_ctCurveEnd.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
    DrawCurve(NULL);
	return lr;
}


LRESULT CVelocityPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctStrength.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
        lr = m_ctLowLimit.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
        lr = m_ctHighLimit.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
        lr = m_ctCurveStart.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
        lr = m_ctCurveEnd.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
    DrawCurve(NULL);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\daytona\makefile.inc ===
buildidl : $(O)\toolprops.h

$(O)\toolprops.h : ..\toolprops.idl
    $(MIDL) \
    $(INCPATH0) \
    $(C_DEFINES) \
    -header $(O)\toolprops.h \
    -tlb     $O\toolprops.tlb \
    -iid     $O\toolprops_i.c  \
    -dlldata $(PROXY_DIR)\dlldata.c  \
    -proxy   $(PROXY_DIR)\toolprops_p.c  \
    ..\toolprops.idl
    copy $(O)\toolprops_i.c $(DXROOT)\dmusic\shared\toolprops_i.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmtoolprp\win9x\makefile.inc ===
buildidl : $(O)\toolprops.h

$(O)\toolprops.h : ..\toolprops.idl
    $(MIDL) \
    $(INCPATH0) \
    $(C_DEFINES) \
    -header $(O)\toolprops.h \
    -tlb     $O\toolprops.tlb \
    -iid     $O\toolprops_i.c  \
    -dlldata $(PROXY_DIR)\dlldata.c  \
    -proxy   $(PROXY_DIR)\toolprops_p.c  \
    ..\toolprops.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\des8.h ===
//------------------------------------------------------------------------------
//                                                                       
//   des8.h -- Design of DirectX 8 interfaces for DirectMusic 
//                                                                       
//   Copyright (c) 1998-1999 Microsoft Corporation
//                                                                       
//------------------------------------------------------------------------------
//
// Prototypes for new DirectX 8 interfaces for DirectMusic core
//
// This header discusses interfaces which manange wave playback between
// the wave object, the DirectMusic port, and a DirectMusic software synth.
// It does not address communication between the wave track and the wave 
// object or the software synth and DirectSound, or directly between the
// wave object and DirectSound.
//
// These interfaces are based on my understanding of our recent hallway
// discussions.
//
// Issues which need futher discussion are marked with XXX.
//
// 

//
// New schedule breakdown
//
// 1. Port (synth and WDM)
//    a. IDirectMusicPort::DownloadWave
//       Code is very similar for WDM or software synth
//       i.   Get needed information from WO and create IDirectSoundSource   0.5    
//       ii.  If oneshot, track and download header and wave data            3.5
//       iii. If streaming, download header                                  0.5
//
//    b. IDirectMusicPort::UnloadWave
//       i.   Arbitrate with device for 0 refcount of download               1.0
//
//    c. IDirectMusicPort::AllocVoice
//       i.   Allocate voice ID                                              0.5
//       ii.  If streaming, allocate preread samples and streaming buffers   2.5
//
//    d. Voice Service Thread
//       i.   Init and shutdown code at port create/destroy                  1.0
//       ii.  Call listed voices every ~100 ms                               0.5
//
//    e. CDirectMusicVoice::Service
//       i.   Communicate with device to determine each voice position       0.5
//       ii.  Calculate how much more wave data is needed                    1.0
//       iii. Fill wave data from IDirectSoundSource and send to device      1.0
//       iv.  Determine when playback is complete and stop voice             0.5
//
//    f. IDirectMusicVoice::Play
//       i.   Communicate request to device                                  0.3
//       ii.  Send down timestamped preread data                             0.3
//       iii. Insert into VST                                                0.3
//
//    g. IDirectMusicVoice::Stop
//       i.   Flag voice as stopped                                          0.5
//       ii.  Forward request to device                                      0.0
//
//    h. Setup and connection
//
//    i. Move sink code into DSound                                          3.0
//    
//      
                                                                           15.5
//
// Things to change
//
// * We will model the DownloadWave interface after the Download interface 
//   and will pass things down to the synth as such:
//
//   DLH + WAD -> Download header + Wave Articulation Data
//                                  (contains loop points and count, etc.)
//
//   DLH + DATA -> Download header + data
//   
// * For oneshot data we want to do download refcounting like we do for
//   regular DLS downloads. For streams we do not since the data that comes
//   down in each download is the next set of data for the device to play.
//
// Download waves first, then wave articulations
// Separate multichannel downloads
// Rotating buffers and refresh for streaming
//   

// New generic typedefs and #defines
//
typedef ULONGLONG SAMPLE_TIME;                  // Sample position w/in stream
typedef SAMPLESPOS *PSAMPLE_TIME;

#define DMUS_DOWNLOADINFO_WAVEARTICULATION  4   // Wave articulation data 
#define DMUS_DOWNLOADINFO_STREAMINGWAVE     5   // One chunk of a streaming
                                                // wave 
                                                
// This is built by the wave object from the 'smpl' chunk embedded in the
// wave file if there is one, else it is just defaults.
//                    
typedef struct _DMUS_WAVEART
{
    DWORD               cbSize;                 // As usual
    WSMPL               WSMP;                   // Wave sample as per DLS1
    WLOOP               WLOOP[1];               // If cSampleCount > 1    
} DMUS_WAVEART; 


//------------------------------------------------------------------------------
//
// IDirectSoundSource
//
// An IDirectSound source is the interface to what we've been calling the
// viewport object.
//
// 
//
interface IDirectSoundSource
{  
    // Init
    //
    // Gives the interface of the connected sink
    STDMETHOD(Init)
    (THIS_
        IDirectSoundSink *pSink                 // Connected sink
    );
    
    // GetFormat
    //
    // Returns the format the source is returning the wave data in
    //
    STDMETHOD(GetFormat)
        (THIS_
         LPWAVEFORMATEX *pwfx,                  // Wave format to fill in
         LPDWORD pcbwfx                         // Size of wave format,
                                                // returns actual size
        ) PURE;
                                                      
    // Seek
    //
    // Seek to the given sample position in the stream. May be inexact
    // due to accuracy settings of wave object. To account for this
    //          
    STDMETHOD(Seek)
        (THIS_
         SAMPLEPOS sp                           // New sample position         
        ) PURE;

    // Read
    //
    // Read the given amount of sample data into the provided buffer starting
    // from the read cursor. The read cursor is set with seek and advanced
    // with each successive call to Read.
    //
    STDMETHOD(Read)
        (THIS_
         LPVOID *ppvBuffer,                     // Array of pvBuffer's
         DWORD cpvBuffer,                       // and how many are passed in
         PSAMPLEPOS pcb                         // In: number of samples to read
                                                // Out: number of samples read
        ) PURE;    
        
    // GetSize
    //
    // Returns the size of the entire wave, in bytes, in the requested format
    //
    STDMETHOD(GetSize)
        (THIS_
         PULONG *pcb                            // Out: Bytes in stream
        ) PURE;
};

//------------------------------------------------------------------------------
//
// IDirectSoundSink
//
// An IDirectSound sink is the interface which feeds itself from one 
// IDirectSoundSource. It is based on the IDirectMusicSynthSink interface
// 
//
interface IDirectSoundSink
{
    // Init
    //
    // Sets up the source to render from
    //
    STDMETHOD(Init)
    (THIS_
        IDirectSoundSource *pSource             // The source from which we read
    ) PURE;
    
    // SetMasterClock
    //
    // Sets the master clock (reference time) to use
    //
    STDMETHOD(SetMasterClock)
    (THIS_
        IReferenceClock *pClock                 // Master timebase
    ) PURE;
    
    // GetLatencyClock
    //
    // Returns the clock which reads latency time, relative to 
    // the master clock
    //
    STDMETHOD(GetLatencyClock)
    (THIS_
        IReferenceClock **ppClock               // Returns latency clock
    ) PURE;
    
    // Activate
    //
    // Starts or stops rendering
    //
    STDMETHOD(Activate)
    (THIS_
        BOOL fEnable                            // Get ready or stop
    ) PURE;
    
    // SampleToRefTime
    //
    // Converts a sample position in the stream to
    // master clock time
    //
    STDMETHOD(SampleToRefTime)
    (THIS_
        SAMPLE_TIME sp,                         // Sample time in
        REFERENCE_TIME *prt                     // Reference time out
    ) PURE;
    
    // RefToSampleTime
    //
    // Converts a reference time to the nearest
    // sample
    //
    STDMETHOD(RefToSampleTime)
    (THIS_
        REFERENCE_TIME rt,                      // Reference time in
        SAMPLE_TIME *psp                        // Sample time out
    ) PURE;
};

//------------------------------------------------------------------------------
//
// IDirectSoundWave
//
// Public interface for the wave object
//
#define DSWCS_F_DEINTERLEAVED 0x00000001        // Multi-channel data as
                                                // multiple buffers

interface IDirectSoundWave
{
    // GetWaveArticulation
    //
    // Returns wave articulation data, either based on a 'smpl' chunk 
    // from the wave file or a default.
    //
    STDMETHOD(GetWaveArticulation)
    (THIS_
        WAVEARTICULATION *pArticulation         // Articulation to fill in
    ) PURE;
    
    // CreateSource
    //
    // Creates a new IDirectSoundSource to read wave data from
    // this wave
    //
    STDMEHTOD(CreateSource)
    (THIS_
        IDirectSoundSource **ppSource           // Created viewport object
        LPWAVEFORMATEX pwfex,                   // Desired format
        DWORD dwFlags                           // DSWCS_xxx
    ) PURE;
};

//------------------------------------------------------------------------------
//
// IDirectMusicPort8
//
// 
//

#define DMDLW_STREAM                            0x00000001

interface IDirectMusicPort8 extends IDirectMusicPort
{ 
    // DownloadWave
    //
    // Creates a downloaded wave object representing the wave on this
    // port. 
    //
    STDMETHOD(DownloadWave)
        (THIS_
         IDirectSoundWave *pWave,               // Wave object
         ULONGLONG rtStart,                     // Start position (stream only)
         DWORD dwFlags,                         // DMDLW_xxx
         IDirectSoundDownloadedWave **ppWave    // Returned downloaded wave
        ) PURE;
        
    // UnloadWave
    //
    // Releases the downloaded wave object as soon as there are no voices
    // left referencing it.
    //
    STDMETHOD(UnloadWave)
        (THIS_ 
         IDirectSoundDownloadedWave *pWave      // Wave to unload
        ) PURE;

    // AllocVoice
    //
    // Allocate one playback instance of the downloaded wave on this
    // port.
    //
    STDMETHOD(AllocVoice)
        (THIS_
         IDirectSoundDownloadedWave *pWave,     // Wave to play on this voice
         DWORD dwChannel,                       // Channel and channel group
         DWORD dwChannelGroup,                  //  this voice will play on
         SAMPLE_TIME stReadAhead,               // How much to read ahead
         IDirectMusicVoice **ppVoice            // Returned voice
        ) PURE;        
};
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// DownloadWave (normal use)
//   
// 1. Application calls GetObject to load segment which contains a wave track.
//    This causes GetObject to be called on all related waves, creating wave
//    objects for all of them. 
//
// 2. Wave track calls SetParam on each wave object to set up author-time 
//    parameters on the wave. This includes:
//    - One-shot versus stream-ness
//    - Readahead amount
//
// 3. Application calls SetParam(GUID_Download,...) to force download. As well
//    as downloading DLS instruments (band track), the wave track calls 
//    DownloadWave for every wave to download. (Note: are we using the same GUID
//    for download? It doesn't appear that SetParam on a segment is broadcast
//    too all tracks, but rather is sent to the first track that understands
//    the GUID, or the nth if an index is given. This would mean that 
//    the application would have to call SetParam twice with the same GUID 
//    and a different track index if there are both band and wave tracks 
//    in the segment??
//
//    Returned is an IDirectMusicDownloadedWave(DirectSound?) to track the wave.
//
//    The following happen during the DownloadWave method call:
//
// 4. The port queries the wave object for the stream-ness and readahead
//    properties. 
//
// XXX We decided that these things were per wave object, right? 
//     (As opposed to the viewport). And the wave object already knows them or 
//     is the right object to provide reasonable defaults. 
//
// 5. The port requests a viewport from the wave object in its native format.
//
// 6. The port allocates buffer space. The buffer must be big enough to handle
//    the entire wave in the case of the one shot, or at least big enough to
//    handle the readahead samples in the streaming case. The streaming buffer
//    may be allocated larger, however, if it is going to be used for the
//    entire streaming session. Buffer choice here may be affected by the
//    underlying port. 
//
//    I assume we are going to parallel the DLS architecture as much as 
//    possible here and are going to be able to trigger a downloaded wave
//    more than once at the same time. In that case the buffer would have
//    to be stored in the _voice_, not the DownloadedWave (except perhaps
//    for the readahead which should always be kept around). Is this 
//    duplication of effort if we're going to be caching in the wave
//    object as well?
//
// 7. If the wave is a one-shot, then the port will request the entire data
//    for the wave from the viewport and downloads it to the device. At this
//    point the viewport is released since the entire data for the wave is in
//    the synth. If the wave is streaming, then nothing is done at the device
//    level.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// UnloadWave
//
// This tells the port that the application is done with the wave as soon as
// there are no more voice references to it. Internally it just calls 
// Release() on the downloaded wave object. The dlwave object can then no longer
// be used to create voices. However, the dlwave will only really be released
// once all voices that currently use it are released.
//
// This is identical to calling Release() on the dlwave object directly
// (why does it exist?)
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// AllocVoice
//
// Allocate a voice object to play back the a wave on a channel group
//
// This call is simple. All it does it ask the synth for a voice ID (which
// is just a cookie that only has meaning to the synth) and creates the voice
// object.
//
// At this point the download is bound to the channel, since MIDI articulations
// sent to the voice before playback begins will need to know that.
//
// The voice object addref's the downloaded wave object.
//

//------------------------------------------------------------------------------
//
// IDirectMusicVoice 
//
// One playback instance of a downloaded wave on a port
//
// Note that since we're already bound to a channel after the voice is
// created, we don't need any methods on the voice object for MIDI
// articulation. That can just go through the normal synth mechanism.
//
interface IDirectMusicVoice
{
public:
    // Play
    //
    STDMETHOD(Play)
        (_THIS
         REFERENCE_TIME rtStart,                // Time to play
         REFERENCE_TIME rtStartInWave           // XXX Move this
                                                // Where in stream to start         
        ) PURE;
    
    // Should stop be scheduled or immediate?
    //    
    STDMETHOD(Stop)
        (_THIS                                  
          REFERENCE_TIME rtStop,                // When to stop
        ) PURE;
};
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// QueryInterface(IID_IKsControl)
//
// All of the effects control should be in the DirectSound side now. 
// However, IKsControl can still be used as in 6.1 and 7 to determine
// synth caps.
// 
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// Play
//
// XXX I am not sure this is the right place to deal with preread. However, 
//     we can't deal with it at DownloadWave(), because we don't know at that
//     point where to start (the app may play the stream from different
//     starting points on different voice). We *could* do it at voice allocation
//     time; that would just mean that the stream start position is fixed for
//     a particular voice no matter how many times the voice is triggered.
//     This is an issue because preread may take some time if decompression is
//     taking place and the seek request is far into the wave; it may cause
//     problems with low-latency Play commands.
//
//     Note that I am delegating the quality versus efficiency flag to private
//     communication between the wave object and the wave track or application.
//
// 1. Call Play() on the synth voice ID associated with this voice. If the 
//    associated wave is a one-shot, this is all that needs to be done.
//
// 2. For a stream, no preread data has been allocated yet. Tell the wave
//    object to seek to the given position and preread. Give the preread data
//    to the device via StreamVoiceData().
//
// 3. If the associated wave is a stream, insert this voice into the voice
//    service list. This will cause push-pull arbiration to be done on the
//    voice until it finishes or Stop() is called.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// Stop
//
// 1. Call Stop() on the synth voice.
//
// 2. If the voice is streaming and not done, pull it from the voice service
//    thread.
//

//------------------------------------------------------------------------------
//
// IDirectMusicSynth8
//
// New methods on the synthesizer interface for managing wave playback.
// A parallel to these methods will be needed on a hardware synth, probably
// implemented as a property set.
//
interface IDirectMusicSynth8 extends IDirectMusicSynth
{ 
public:
    STDMETHOD(DownloadWave)
        (THIS_
         LPHANDLE pHandle,                  // Returned handle representing DL
         LPVOID pvData,                     // Initial data
                                            // XXX >1 channel -> buffers?
         LPBOOL pbFree,                     // Is port allowed to free data?
         BOOL bStream                       // This is preroll data for a stream                                        
        ) PURE;
        
    STDMETHOD(UnloadWave)               
        (THIS_ 
         HANDLE phDownload,                 // Handle from DownloadWave
         HRESULT (CALLBACK *pfnFreeHandle)(HANDLE,HANDLE), 
                                            // Callback to call when done
                                            
         HANDLE hUserData                   // User data to pass back in 
                                            // callback
        ) PURE; 
        
    STDMETHOD(PlayVoice)
        (THIS_
         REFERENCE_TIME rt,                 // Time to start playback
         DWORD dwVoiceId,                   // Voice ID allocated by port
         DWORD dwChannelGroup,              // Channel group and
         DWORD dwChannel,                   // channel to start voice on
         DWORD dwDLId                       // Download ID of the wave to play
                                            // (This will be of the wave 
                                            // articulation)
        ) PURE;
        
    STDMETHOD(StopVoice)
        (THIS_
         DWORD dwVoice,                     // Voice to stop
         REFERENCE_TIME rt                  // When to stop
        ) PURE;
        
    struct VOICE_POSITION
    {
        ULONGLONG   ullSample;              // Sample w/in wave
        DWORD       dwSamplesPerSec;        // Playback rate at current pitch
    };
    
    STDMETHOD(GetVoicePosition)
        (THIS_
         HANDLE ahVoice[],                  // Array of handles to get position
         DWORD cbVoice,                     // Elements in ahVoice and avp
         VOICE_POSITION avp[]               // Returned voice position
        ) PURE;
        
    STDMETHOD(StreamVoiceData)
        (THIS_
         HANDLE hVoice,                     // Which voice this data is for
         LPVOID pvData,                     // New sample data
         DWORD cSamples                     // Number of samples in pvData
        ) PURE;        
};
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// DownloadWave
//
// This could be the same as Download except that we need to deal with
// the streaming case.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// UnloadWave
//
// Works just like Unload. In the streaming case, the callback will be
// called after _all_ data in the stream is free. Note that if UnloadWave
// is called while the wave is still playing, this could be quite some
// time.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// PlayVoice
//
// Schedule the voice to be played. The synth already has the data 
// for a oneshot wave, so starting playback is very fast. If the data is
// to be streamed it is the caller's responsibility (i.e. the port) to 
// keep the stream fed via StreamVoiceData()
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// StopVoice 
//
// Just what it says.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// GetVoicePosition
//
// This call retrieves the position of a set of voices. For each voice, the
// current sample position relative to the start of the stream and the 
// average number of samples per second at the current pitch is returned. This
// gives the caller all the information it needs to stay ahead of the 
// voice playback. This call is intended for use on streaming voices.
//
// Note that the playback position is an implication that all data up to the
// point of that sample is done with and the buffer space can be freed. This
// allows recycling of buffers in a streaming wave.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// StreamVoiceData
//
// This call queues more data for a streaming voice. 
//
// XXX This implies that there will be a discontinuity in the memory used
// by the synth mixer. How do we deal with that?
//
//

//------------------------------------------------------------------------------
//
// General questions and discussion
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// What can be underneath a DirectMusic port? 
//
// In 6.1 and 7 this was easy; either a SW synth on top of DSound 
// (synth port), or a kernel sw synth or hw synth (WDM port). (Not
// counting the dmusic16 code which will not be changing in 8).
//
// What are the scenarios we have now? Does it make sense (or is it even
// possible in light of backwards compat) to change what a port wraps?
// The two scenarios which match the existing ports are:
//
// Scenario: Software synthesizer on top of DirectSound as we have today.
// The hookup logic changes (we're talking n mono busses, etc.) but the 
// mechanics do not: the application can still just hand us a DirectSound
// object and we connect it to the bottom of the synthesizer. This still has
// to work with pre-8 applications making the same set of API calls they
// always did, but internally it can be totally different.
// XXX Did we ever expose the IDirectMusicSynthSink and methods for hooking
// it up? Can this change? (It has to...) I _think_ this was a DDK thing...
// The application can also create a DX8 DirectSound buffer with all the
// bells and whistles and have that work as well. We need some (DX8) specific
// mechanism for routing what goes out of the synth into the n mono inputs
// of the DirectSound buffer if it's more than just a legacy stereo buffer.
// 
//
// Scenario: We sit on top of a hardware or KM synth on top of *everything*
// else in kernel mode. We need private communication between DirectMusic,
// DirectSound, and SysAudio in order to hook this up, or we need to
// delegate the graph building tasks totally to DirectSound and have it
// deal exlusively with SysAudio connections. The latter is probably the
// way to go. In this case we fail if we cannot get a WDM driver under
// DirectSound to talk to, or if the DirectSound buffer is not totally in
// hardware. (This all argues for having DirectSound be able to instantiate
// the KM synth on top of the buffer rather than arbitrating with DirectMusic
// to do it). We need to define this interface ASAP.
// (Me, Dugan, Mohan, MikeM).
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMUSIC"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dlsstrm.cpp ===
//
// dlsstrm.cpp
// 
// Copyright (c) 1995-1999 Microsoft Corporation. All rights reserved.
//

#include "debug.h"
#include "dmusicc.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream; 
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(0,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent) 
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
	    HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(0,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
		    {
			    hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(0," Type %s",szName);
                    }
#endif
                }
		    }
#ifdef DBG
            if (m_fDebugOn) Trace(0,"\n");
#endif
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(0,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
		li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD))); 
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + 
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dlsstrm.h ===
//
// dlsstrm.h
//
// Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
//


#ifndef DMSTRM_H
#define DMSTRM_H

// Macro to round up an odd size to RIFF 16 bit boundary.
#define RIFF_ALIGN(dwSize) (dwSize + (dwSize & 1))

typedef struct _RIFFIO
{
    FOURCC          ckid;           /* chunk ID */
    long            cksize;         /* chunk size */
    FOURCC          fccType;        /* form type or list type */
    long            lRead;          /* How much of this chunk has been read so far. */
    _RIFFIO *       pParent;        /* pointer to parent chunk */
    LARGE_INTEGER   liPosition;     /* Filled in by MarkPosition() when handing stream to another component. */
} RIFFIO;


class CRiffParser
{
public:
    CRiffParser(IStream *pStream);
    void        DebugOn() { m_fDebugOn = TRUE; } // Turns on tracing of parsing. Only available in debug builds.
    BOOL        NextChunk(HRESULT * pHr); // Does the work of LeaveChunk, MoreChunks, and EnterChunk in one call. 
    void        EnterList(RIFFIO *pChunk); // Descend into a new list.
    void        LeaveList();    // Pop out of the current list. 
    BOOL        MoreChunks();   // Returns true if there are more chunks to process in this LIST or RIFF.
    HRESULT     EnterChunk();   // Reads header of next chunk in this LIST or RIFF container.
    HRESULT     LeaveChunk();   // Move to the end of the current chunk in the LIST or RIFF.
    void        MarkPosition(); // Stores the absolute position of the start of the current chunk.
    HRESULT     SeekBack();     // Scan back to the beginning of the current chunk.
    HRESULT     SeekForward();  // Scan forward to the end of the current chunk.
    HRESULT     Read(void *pv,ULONG cb); // Reads data from stream. 
    HRESULT     Skip(ULONG ulBytes); // Seeks forward ulBytes.
    void        EnteringComponent() { m_fInComponent = true; } 
    BOOL        ComponentFailed() { return m_fComponentFailed; }
    IStream *   GetStream() { return m_pStream; }
    RIFFIO *    GetChunk() { return m_pChunk; }
private:
    BOOL        m_fDebugOn;     // Set true to turn tracing of parsing on. 
    BOOL        m_fFirstPass;   // Used by NextChunk to understand whether this is the first time in the list.
    IStream *   m_pStream;      // Stream to operate on. 
    RIFFIO *    m_pChunk;       // Current chunk that we are in. 
    RIFFIO *    m_pParent;      // Parent chunk of current chunk.
    long        m_lRead;        // How far we've read in the current chunk.
    BOOL        m_fComponentFailed; // Set true if a component failed to load, yet the file is okay.
    BOOL        m_fInComponent; // Set to true when inside a component's chunk.
};

#endif // #ifndef DLSSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmart.cpp ===
//
// dmart.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
//

#include "dmusicc.h"
#include "alist.h"
#include "dlsstrm.h"
#include "debug.h"
#include "dmart.h"
#include "dmcrchk.h"
#include "dls2.h"

#define FIVE_HERTZ  (-55791972)
#define MIN_TIME    (-783819269)    // Time cents for one ms.

// To support legacy articulation connection blocks
// Generic Destinations
#define CONN_DST_RESERVED          0x0002

// EG1 Destinations
#define CONN_DST_EG1_RESERVED      0x0208

// EG2 Destinations
#define CONN_DST_EG2_RESERVED      0x030c


CArticData::CArticData()

{
    m_ConnectionList.cbSize = sizeof(CONNECTIONLIST);
    m_ConnectionList.cConnections = 0;
    m_pConnections = NULL;
}

CArticData::~CArticData()

{
    if (m_pConnections) delete[] m_pConnections;
}

HRESULT CArticData::GenerateLevel1(DMUS_ARTICPARAMS *pParamStruct)

{
    if (pParamStruct)
    {
	    ZeroMemory(pParamStruct, sizeof(DMUS_ARTICPARAMS));
	    
        pParamStruct->LFO.pcFrequency = FIVE_HERTZ;
        pParamStruct->LFO.tcDelay = MIN_TIME;

	    pParamStruct->VolEG.tcAttack = MIN_TIME;
        pParamStruct->VolEG.tcDecay = MIN_TIME;
        pParamStruct->VolEG.ptSustain = 1000 << 16;
        pParamStruct->VolEG.tcRelease = MIN_TIME;
    
	    pParamStruct->PitchEG.tcAttack = MIN_TIME;
        pParamStruct->PitchEG.tcDecay = MIN_TIME;
        pParamStruct->PitchEG.ptSustain = 1000 << 16;
        pParamStruct->PitchEG.tcRelease = MIN_TIME;

        DWORD dwIndex;
        CONNECTION *pConnection;
		for (dwIndex = 0; dwIndex < m_ConnectionList.cConnections; dwIndex++)
		{
            pConnection = &m_pConnections[dwIndex];
			switch (pConnection->usSource)
			{
			case CONN_SRC_NONE :
				switch (pConnection->usDestination)
				{
				case CONN_DST_LFO_FREQUENCY :
					pParamStruct->LFO.pcFrequency =
						(PCENT) pConnection->lScale;
					break;
				case CONN_DST_LFO_STARTDELAY :
					pParamStruct->LFO.tcDelay =
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG1_ATTACKTIME :
					pParamStruct->VolEG.tcAttack = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG1_DECAYTIME :
					pParamStruct->VolEG.tcDecay = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG1_RESERVED :
					pParamStruct->VolEG.ptSustain = 
						(PERCENT) pConnection->lScale << 16;
					break;
				case CONN_DST_EG1_SUSTAINLEVEL :
					pParamStruct->VolEG.ptSustain = 
						(PERCENT) pConnection->lScale;
					break;
				case CONN_DST_EG1_RELEASETIME :
					pParamStruct->VolEG.tcRelease = 
						(TCENT) pConnection->lScale; 
					break;
				case CONN_DST_EG2_ATTACKTIME :
					pParamStruct->PitchEG.tcAttack = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG2_DECAYTIME :
					pParamStruct->PitchEG.tcDecay = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG2_RESERVED :
					pParamStruct->PitchEG.ptSustain = 
						(PERCENT) pConnection->lScale << 16;
					break;
				case CONN_DST_EG2_SUSTAINLEVEL :
					pParamStruct->PitchEG.ptSustain = 
						(PERCENT) pConnection->lScale;
					break;
				case CONN_DST_EG2_RELEASETIME :
					pParamStruct->PitchEG.tcRelease = 
						(TCENT) pConnection->lScale; 
					break;
				case CONN_DST_RESERVED :
					pParamStruct->Misc.ptDefaultPan = 
						(PERCENT) pConnection->lScale << 16;
					break;
				case CONN_DST_PAN :
					pParamStruct->Misc.ptDefaultPan = 
						(PERCENT) pConnection->lScale;
					break;
				}
				break;
			case CONN_SRC_LFO :
				switch (pConnection->usControl)
				{
				case CONN_SRC_NONE :
					switch (pConnection->usDestination)
					{
					case CONN_DST_ATTENUATION :
						pParamStruct->LFO.gcVolumeScale = 
							(GCENT) pConnection->lScale; 
						break;
					case CONN_DST_PITCH :
						pParamStruct->LFO.pcPitchScale = 
							(PCENT) pConnection->lScale; 
						break;
					}
					break;
				case CONN_SRC_CC1 :
					switch (pConnection->usDestination)
					{
					case CONN_DST_ATTENUATION :
						pParamStruct->LFO.gcMWToVolume = 
							(GCENT) pConnection->lScale; 
						break;
					case CONN_DST_PITCH :
						pParamStruct->LFO.pcMWToPitch = 
							(PCENT) pConnection->lScale; 
						break;
					}
					break;
				}
				break;
			case CONN_SRC_KEYONVELOCITY :
				switch (pConnection->usDestination)
				{
				case CONN_DST_EG1_ATTACKTIME :
					pParamStruct->VolEG.tcVel2Attack = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG2_ATTACKTIME :
					pParamStruct->PitchEG.tcVel2Attack = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_ATTENUATION :
					break;
				}
				break;
			case CONN_SRC_KEYNUMBER :
				switch (pConnection->usDestination)
				{
				case CONN_DST_EG1_DECAYTIME :
					pParamStruct->VolEG.tcKey2Decay = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG2_DECAYTIME :
					pParamStruct->PitchEG.tcKey2Decay = 
						(TCENT) pConnection->lScale;
					break;
				}
				break;
			case CONN_SRC_EG2 :
				switch (pConnection->usDestination)
				{
				case CONN_DST_PITCH :
					pParamStruct->PitchEG.pcRange = 
						(PCENT) pConnection->lScale; 
					break;
				}
				break;
			}
		
		}
	}
    return S_OK;
}

DWORD CArticData::Size()

{
    if (m_pConnections)
    {
        return (m_ConnectionList.cConnections * sizeof CONNECTION) + sizeof CONNECTIONLIST;
    }
    return 0;
}

BOOL CArticData::Write(void * pv, DWORD* pdwCurrentOffset)

{
    if (m_pConnections)
    {
        CONNECTIONLIST *pList = (CONNECTIONLIST *) pv;
        CONNECTION *pConnection = (CONNECTION *) ((BYTE *)pv + sizeof(CONNECTIONLIST));
        *pList = m_ConnectionList;
        memcpy(pConnection,m_pConnections,m_ConnectionList.cConnections * sizeof CONNECTION);
        *pdwCurrentOffset += Size();
    }
    return TRUE;
}

HRESULT CArticData::Load(CRiffParser *pParser)
{
	HRESULT hr = S_OK;

    CONNECTION *pOldConnections = m_pConnections;
    DWORD dwOldCount = m_ConnectionList.cConnections;

	hr = pParser->Read(&m_ConnectionList, sizeof(m_ConnectionList));
	if(SUCCEEDED(hr))
	{	
        DWORD dwSize = m_ConnectionList.cConnections * sizeof(CONNECTION);
        if (dwSize > (pParser->GetChunk()->cksize - sizeof(CONNECTIONLIST)))
        {
            return E_FAIL;  // corrupt file.
        }
        m_pConnections = new CONNECTION[m_ConnectionList.cConnections + dwOldCount];
        if (m_pConnections)
        {
		    hr = pParser->Read(m_pConnections,dwSize);
            if (SUCCEEDED(hr))
            {
                if (pOldConnections && dwOldCount)
                {
                    memcpy(&m_pConnections[m_ConnectionList.cConnections],
                        pOldConnections,dwOldCount * sizeof(CONNECTION));
                    m_ConnectionList.cConnections += dwOldCount;
                }
            }
            else
            {
                delete[] m_pConnections;
                m_pConnections = pOldConnections;
                m_ConnectionList.cConnections = dwOldCount;

            }
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
            
	return hr;
}



//////////////////////////////////////////////////////////////////////
// Class CArticulation

//////////////////////////////////////////////////////////////////////
// CArticulation::CArticulation

CArticulation::CArticulation() 

{ 
    m_dwCountExtChk = 0; 
    m_fDLS1 = TRUE;
    m_fNewFormat = FALSE;
    m_fCSInitialized = FALSE;
//    InitializeCriticalSection(&m_DMArtCriticalSection);
    m_fCSInitialized = TRUE;
}

CArticulation::~CArticulation()

{
    if (m_fCSInitialized)
    {
    	Cleanup();
//    	DeleteCriticalSection(&m_DMArtCriticalSection);
    }
}

//////////////////////////////////////////////////////////////////////
// CArticulation::Load

HRESULT CArticulation::Load(CRiffParser *pParser)
{
	HRESULT hr = S_OK;

	RIFFIO ck;

//	EnterCriticalSection(&m_DMArtCriticalSection);

    pParser->EnterList(&ck);
    while (pParser->NextChunk(&hr))
    {
		switch(ck.ckid)
		{
        case FOURCC_CDL :
            hr = m_Condition.Load(pParser);
            break;
        case FOURCC_ART2 :
        case FOURCC_ART1 : 
            hr = m_ArticData.Load(pParser);
            break;
		default:
			// If we get here we have an unknown chunk
			CExtensionChunk* pExtensionChunk = new CExtensionChunk;
			if(pExtensionChunk)
			{
				hr = pExtensionChunk->Load(pParser);

				if(SUCCEEDED(hr))
				{
					m_ExtensionChunkList.AddHead(pExtensionChunk);
					m_dwCountExtChk++;
				}
				else
				{
					delete pExtensionChunk;
				}
			}
			else
			{
				hr = E_OUTOFMEMORY;
			} 
			break;
		}
	}
    pParser->LeaveList();
	
	if(FAILED(hr))
	{
		Cleanup();
	}

//	LeaveCriticalSection(&m_DMArtCriticalSection);
    
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CArticulation::Cleanup

void CArticulation::Cleanup()
{
//	EnterCriticalSection(&m_DMArtCriticalSection);

/*    if (m_pArticTree)
    {
        delete m_pArticTree;
        m_pArticTree = NULL;
    }*/

	while(!m_ExtensionChunkList.IsEmpty())
	{
		CExtensionChunk* pExtChk = m_ExtensionChunkList.RemoveHead();
		m_dwCountExtChk--;
		delete pExtChk;
	}

//	LeaveCriticalSection(&m_DMArtCriticalSection);

	assert(m_dwCountExtChk == 0);
}

DWORD CArticulation::Count()
{
	// Return the number of Offset Table entries needed during a call to Write
    if (m_Condition.m_fOkayToDownload)
    {
        DWORD dwCount = m_dwCountExtChk + 1;
        if (m_Condition.m_fOkayToDownload && m_ArticData.Size()) dwCount++;
        return dwCount;
    }
    return 0;
}

void CArticulation::SetPort(CDirectMusicPortDownload *pPort,BOOL fNewFormat, BOOL fSupportsDLS2)

{
    m_fNewFormat = fNewFormat;
    if (fSupportsDLS2)
    {
        m_Condition.Evaluate(pPort);
    }
    else
    {
        m_Condition.m_fOkayToDownload = m_fDLS1;
    }
}

BOOL CArticulation::CheckForConditionals()

{
    return  m_Condition.HasChunk();
}

//////////////////////////////////////////////////////////////////////
// CArticulation::Size

DWORD CArticulation::Size()
{
	DWORD dwSize = 0;
	DWORD dwCountExtChk = 0;
	
    if (!m_Condition.m_fOkayToDownload)
    {
        return 0;
    }

//    EnterCriticalSection(&m_DMArtCriticalSection);


    if (m_fNewFormat)
    {
	    dwSize += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION2));
    }
    else
    {
        dwSize += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION));
    }
	
    if (m_Condition.m_fOkayToDownload && m_ArticData.Size())
    {
        if (m_fNewFormat)
        {
            dwSize += CHUNK_ALIGN(m_ArticData.Size());
        }
        else
        {
		    dwSize += CHUNK_ALIGN(sizeof(DMUS_ARTICPARAMS));
	    }
    }

	// Calculate the space need for Articulation's extension chunks
	CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	for(; pExtChk; pExtChk = pExtChk->GetNext())
	{
		dwSize += pExtChk->Size();
		dwCountExtChk++;
	}

	// We want to validate the number of extension chunks
	if(m_dwCountExtChk != dwCountExtChk)
	{
		assert(false);
		dwSize = 0;
	}

//	LeaveCriticalSection(&m_DMArtCriticalSection);

	return dwSize;
}

//////////////////////////////////////////////////////////////////////
// CArticulation::Write

HRESULT CArticulation::Write(void* pv, 
							 DWORD* pdwCurOffset, 
							 DWORD* pDMWOffsetTable,
							 DWORD* pdwCurIndex,
                             DWORD dwNextArtIndex)
{
	assert(pv);
	assert(pdwCurOffset);
	assert(pDMWOffsetTable);
	assert(pdwCurIndex);
	
    HRESULT hr = S_OK;
	
    if (!m_Condition.m_fOkayToDownload)
    {
        return hr;        // This actually should never happen.
    }   

//	EnterCriticalSection(&m_DMArtCriticalSection);

    DWORD dwRelativeCurOffset = 0;

    ULONG *pulFirstExtCkIdx = NULL;
        
    if (m_fNewFormat)
    {     
    	DMUS_ARTICULATION2* pArt = (DMUS_ARTICULATION2 *)pv;
        dwRelativeCurOffset = CHUNK_ALIGN(sizeof(DMUS_ARTICULATION2));
	    (*pdwCurOffset) += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION2));
        pArt->ulNextArtIdx = dwNextArtIndex;
        if (m_ArticData.Size())
        {
            pDMWOffsetTable[*pdwCurIndex] = *pdwCurOffset;
		    pArt->ulArtIdx = (*pdwCurIndex)++;
            DWORD dwOffsetStart = *pdwCurOffset; 
            m_ArticData.Write((BYTE *)pv + dwRelativeCurOffset,pdwCurOffset);
            dwRelativeCurOffset += (*pdwCurOffset - dwOffsetStart);	
        }
        else
	    {
		    pArt->ulArtIdx = 0;
	    }
        pulFirstExtCkIdx = &pArt->ulFirstExtCkIdx;
    }
    else
    {
        DMUS_ARTICULATION* pArt = (DMUS_ARTICULATION *)pv;
	    dwRelativeCurOffset = CHUNK_ALIGN(sizeof(DMUS_ARTICULATION));
	        (*pdwCurOffset) += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION));

	    if(m_ArticData.Size())
	    {
		    pDMWOffsetTable[*pdwCurIndex] = *pdwCurOffset;
		    pArt->ulArt1Idx = (*pdwCurIndex)++;

            m_ArticData.GenerateLevel1((DMUS_ARTICPARAMS*)
                ((BYTE *)pv + dwRelativeCurOffset));
		    dwRelativeCurOffset += CHUNK_ALIGN(sizeof(DMUS_ARTICPARAMS));
		    (*pdwCurOffset) += CHUNK_ALIGN(sizeof(DMUS_ARTICPARAMS));
	    }
	    else
	    {
		    pArt->ulArt1Idx = 0;
	    }
        pulFirstExtCkIdx = &pArt->ulFirstExtCkIdx;
    }

	// Write extension chunks
	CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	if(pExtChk)
	{
		DWORD dwCountExtChk = m_dwCountExtChk;
        DWORD dwIndexNextExtChk;
        *pulFirstExtCkIdx = dwIndexNextExtChk = *pdwCurIndex;
		for(; pExtChk && SUCCEEDED(hr) && dwCountExtChk > 0; pExtChk = pExtChk->GetNext())
		{
			if(dwCountExtChk == 1)
			{
				dwIndexNextExtChk = 0;
			}
			else
			{
				dwIndexNextExtChk++;    // Add one, since the extension chunks are all in a row.
			}

			pDMWOffsetTable[(*pdwCurIndex)++] = *pdwCurOffset;
            // Store current position to calculate new dwRelativeCurOffset.
            DWORD dwOffsetStart = *pdwCurOffset;            
			hr = pExtChk->Write(((BYTE *)pv + dwRelativeCurOffset), 
								pdwCurOffset,
								dwIndexNextExtChk);
            dwRelativeCurOffset += (*pdwCurOffset - dwOffsetStart);		
			dwCountExtChk--;
		}
	}
	else
	{
		// If no extension chunks set to zero
		*pulFirstExtCkIdx = 0;
	}

//	LeaveCriticalSection(&m_DMArtCriticalSection);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmart.h ===
//
// dmart.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
//

#ifndef DMART_H
#define DMART_H

#include "dmextchk.h"

class CRiffParser;

class CArticData 
{
public:
	CArticData();
	~CArticData();
    HRESULT         Load(CRiffParser *pParser);
    HRESULT         GenerateLevel1(DMUS_ARTICPARAMS *pParamStuct);
inline DWORD        Size();
    BOOL            Write(void *pv,DWORD* pdwCurrentOffset);
private:
    CONNECTIONLIST  m_ConnectionList;
    CONNECTION *    m_pConnections;
};


class CArticulation : public AListItem
{
public:
	CArticulation();
	~CArticulation();
	CArticulation* GetNext(){return(CArticulation*)AListItem::GetNext();}

	HRESULT Load(CRiffParser *pParser);
	HRESULT Write(void* pv, 
				  DWORD* pdwCurrentOffset, 
				  DWORD* pDMWOffsetTable,
				  DWORD* pdwCurIndex,
                  DWORD dwNextArtIndex);
    void SetPort(CDirectMusicPortDownload *pPort,BOOL fNewFormat, BOOL fSupportsDLS2);
    BOOL CheckForConditionals();
	DWORD Size();
	DWORD Count();

private:
	void Cleanup();

//	CRITICAL_SECTION	m_DMArtCriticalSection;
    BOOL                m_fCSInitialized;
    CArticData          m_ArticData;            // Articulation chunk from file.
    CExtensionChunkList	m_ExtensionChunkList;   // Unknown additional data chunks.
	DWORD				m_dwCountExtChk;        // Number of extension chunks.
    CConditionChunk     m_Condition;            // Optional conditional chunk;
    BOOL                m_fNewFormat;           // True if the synth handles the INSTRUMENT2 format.
public:
    BOOL                m_fDLS1;                // True if DLS1 chunk.
};

class CArticulationList : public AList
{
public:
	CArticulationList(){}
	~CArticulationList()
	{
		while(!IsEmpty())
		{
			CArticulation* pArticulation = RemoveHead();
			delete pArticulation;
		}
	}

    CArticulation* GetHead(){return (CArticulation *)AList::GetHead();}
	CArticulation* GetItem(LONG lIndex){return (CArticulation*)AList::GetItem(lIndex);}
    CArticulation* RemoveHead(){return(CArticulation *)AList::RemoveHead();}
	void Remove(CArticulation* pArticulation){AList::Remove((AListItem *)pArticulation);}
	void AddTail(CArticulation* pArticulation){AList::AddTail((AListItem *)pArticulation);}
};

#endif // #ifndef DMART_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmbuffer.cpp ===
// dmbuffer.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Implementation of IDirectMusicBuffer
//
// @doc EXTERNAL
//
//
#include <objbase.h>
#include "debug.h"

#include "dmusicp.h"
#include "validate.h"

const GUID guidZero = {0};

static BYTE bMessageLength[128] = 
{
    // Channel
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // Note off 0x80-0x8f
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // Note on 0x90-0x9f
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // Key pressure 0xa0-0xaf
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // Control Change 0xb0-0xbf
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,     // Patch change 0xc0-0xcf
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,     // Channel pressure 0xd0-0xdf
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // Pitch bend 0xe0-0xef

    // SysEx
    0,                                                  // 0xf0 SOX invalid in this context

    // System common
    2,                                                  // 0xf1 MTC quarter frame
    3,                                                  // 0xf2 SPP
    2,                                                  // 0xf3 Song select
    0,                                                  // 0xf4 Undefined
    0,                                                  // 0xf5 Undefined
    1,                                                  // 0xf6 Tune request
    0,                                                  // 0xf7 EOX invalid in this context

    // System realtime
    1,                                                  // 0xf8 Timing clock
    0,                                                  // 0xf9 Undefined
    1,                                                  // 0xfa Start
    1,                                                  // 0xfb Continue
    1,                                                  // 0xfc Start
    0,                                                  // 0xfd Undefined
    1,                                                  // 0xfe Active Sense
    1,                                                  // 0xff System Reset
};

//
// Constructor. Takes number of bytes
//
CDirectMusicBuffer::CDirectMusicBuffer(
                                       DMUS_BUFFERDESC &dmbd)
   : m_BufferDesc(dmbd)
{
    m_cRef = 1;
    m_pbContents = NULL;
}

// Destructor
// Clean up after ourselves
//
CDirectMusicBuffer::~CDirectMusicBuffer()
{
    if (m_pbContents) {
        delete[] m_pbContents;
    }
}

// Init
//
// Allocates the buffer; gives us a chance to return out of memory
//
HRESULT
CDirectMusicBuffer::Init()
{
    m_maxContents = DWORD_ROUNDUP(m_BufferDesc.cbBuffer);

    m_pbContents = new BYTE[m_maxContents];
    if (NULL == m_pbContents) {
        return E_OUTOFMEMORY;
    }

    m_cbContents = 0;
    m_idxRead = 0;
    m_totalTime = 0;

    if (m_BufferDesc.guidBufferFormat == KSDATAFORMAT_TYPE_MUSIC ||
        m_BufferDesc.guidBufferFormat == guidZero)
    {
        m_BufferDesc.guidBufferFormat = KSDATAFORMAT_SUBTYPE_MIDI;
    }
    
    return S_OK;
}

// @method HRESULT | IDirectMusicBuffer | GetRawBufferPtr | Returns a pointer to the buffer's contents.
//
// @comm
//
// Returns a pointer to the underlying buffer data structure.
// This method returns a pointer to the raw data of the buffer. The format of this data is implementation
// dependent. The lifetime of this data is the same as the lifetime of the buffer object; therefore, the
// returned pointer should not be held past the next call to the <m Release> method.
//
// @rdesc
//
// @flag S_OK | On success
// @flag E_POINTER | If the given <p ppData> pointer is invalid
//
STDMETHODIMP
CDirectMusicBuffer::GetRawBufferPtr(
    LPBYTE *ppData)         // @parm Receives a pointer to the buffer's data.
{
    V_INAME(IDirectMusicBuffer::GetRawBufferPointer);
    V_PTRPTR_WRITE(ppData);
    
    *ppData = m_pbContents;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | GetStartTime | Gets the start time of the data in the buffer.
//
// @comm
// Gets the start time of the data in the buffer.  The start time is relative to DirectMusic's master clock.
//
// @rdesc
//
// @flag S_OK | On success
// @flag DMUS_E_BUFFER_EMPTY | If there is no data in the buffer
// @flag E_POINTER | If the passed <p prt> pointer is invalid
// 
STDMETHODIMP
CDirectMusicBuffer::GetStartTime(
    LPREFERENCE_TIME prt)       // @parm Receives the start time.
{
    V_INAME(IDirectMusicBuffer::GetStartTime);
    V_PTR_WRITE(prt, REFERENCE_TIME);
    
    if (m_cbContents)
    {
        *prt = m_rtBase;
        return S_OK;
    }

    return DMUS_E_BUFFER_EMPTY;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | GetUsedBytes | Returns the amount of music data currently in the buffer.
//
// @comm
// Gets the number of bytes of data in the buffer.
//
// @rdesc
//
// @flag S_OK | On success
// @flag E_POINTER | If the given <p pcb> pointer is invalid.
//
STDMETHODIMP
CDirectMusicBuffer::GetUsedBytes(
    LPDWORD pcb)                // @parm Receives the number of used bytes.
{
    V_INAME(IDirectMusicBuffer::GetUsedBytes);
    V_PTR_WRITE(pcb, DWORD);
    
    *pcb = m_cbContents;
    
    return S_OK;
}


// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | GetMaxBytes | Returns the maximum number of bytes the buffer can hold.
//
// @comm
// Retrieves the maximum number of bytes that can be stored in the buffer.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | The given <p pcb> pointer was invalid.
//
STDMETHODIMP
CDirectMusicBuffer::GetMaxBytes(
    LPDWORD pcb)                // @parm Receives the maximum number of bytes the buffer can hold.
{
    V_INAME(IDirectMusicBuffer::GetMaxBytes);
    V_PTR_WRITE(pcb, DWORD);
    
    *pcb = m_maxContents;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | GetBufferFormat | Returns the GUID representing the buffer format.
//
// @comm
// Retrieves the GUID representing the format of the buffer. If the format was not specified, then KSDATAFORMAT_SUBTYPE_MIDI
// will be returned.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | The given <p pGuidFormat> pointer was invalid.
//
STDMETHODIMP
CDirectMusicBuffer::GetBufferFormat(
    LPGUID pGuidFormat)                // @parm Receives the GUID format of the buffer
{
    V_INAME(IDirectMusicBuffer::GetBufferFormat);
    V_PTR_WRITE(pGuidFormat, GUID);

    *pGuidFormat = m_BufferDesc.guidBufferFormat;
    
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | SetStartTime | Sets the start time of the buffer.
//
// @comm
// Sets the start time of the data in the buffer.  Times in DirectMusic
// are relative to master clock which can be retrieved and set with the
// <i IDirectMusic> interface. For more information about the master clock,
// see the description of <om IDirectMusic::SetMasterClock>.
//
// @rdesc
//
// @flag S_OK | On success
//
STDMETHODIMP
CDirectMusicBuffer::SetStartTime(
    REFERENCE_TIME rt)          // @parm The new start time for the buffer.
{
    m_rtBase = rt;
    
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | SetUsedBytes | Sets the number of bytes of data in the buffer.
//
// @comm
// This method allows an application to repack a buffer manually. Generally this should only be done
// if the data format in the buffer is different from the default format provided by DirectMusic. (i.e.
// in a format other than KSDATAFORMAT_SUBTYPE_MIDI).
//
// @rdesc
//
// @flag S_OK | On success
// @flag DMUS_E_BUFFER_FULL | If the specified number of bytes exceeds the maximum buffer size as returned by <m GetMaxBytes>.
//
STDMETHODIMP
CDirectMusicBuffer::SetUsedBytes(
    DWORD cb)                   // @parm The number of valid data bytes in the buffer
{
    if (cb > m_maxContents)
    {
        return DMUS_E_BUFFER_FULL;
    }
    
    m_cbContents = cb;
    
    return S_OK;
}

// CDirectMusicBuffer::QueryInterface
//
STDMETHODIMP
CDirectMusicBuffer::QueryInterface(const IID &iid,
                                   void **ppv)
{
    V_INAME(IDirectMusicBuffer::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicBuffer) {
        *ppv = static_cast<IDirectMusicBuffer*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// CDirectMusicBuffer::AddRef
//
STDMETHODIMP_(ULONG)
CDirectMusicBuffer::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CDirectMusicBuffer::Release
//
STDMETHODIMP_(ULONG)
CDirectMusicBuffer::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | Flush | Empties the buffer.
//
// @comm
// Discards all data in the buffer.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
//
STDMETHODIMP
CDirectMusicBuffer::Flush()
{
    m_cbContents = 0;
    m_totalTime = 0;
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | TotalTime | Returns the total time spanned by the data in the buffer.
//
// @comm
// As with all times in DirectMusic, the time is specified in 100 ns units.
// 
// @rdesc Returns one of the following
//
// @flag S_OK | On success.
// @flag E_POINTER | If the <p prtTime> pointer is invalid.
//
STDMETHODIMP
CDirectMusicBuffer::TotalTime(
                              LPREFERENCE_TIME prtTime)      // @parm Received the total time spanned by the buffer
{
    V_INAME(IDirectMusicBuffer::TotalTile);
    V_PTR_WRITE(prtTime, REFERENCE_TIME);
    
    *prtTime = m_totalTime;
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | PackStructured | Inserts a MIDI channel message event at the end of the buffer.
//
// @comm
// There must be at least 24 bytes free in the buffer to insert a channel message.
//
// Although buffers may overlap in time, events within a buffer may not. All events in a buffer must
// be packed in order of ascending time.
//
// @rdesc
//
// @flag S_OK | On success.
// @flag E_OUTOFMEMORY | If there is no room in the buffer for the event.
//
STDMETHODIMP
CDirectMusicBuffer::PackStructured(
                                   REFERENCE_TIME rt,   // @parm The absolute time of the event
                                   DWORD dwChannelGroup,// @parm The channel group of the event on the outgoing port
                                   DWORD dwMsg)         // @parm The channel message to pack 
{
    BYTE b0 = (BYTE)(dwMsg & 0x000000FF);
    BYTE bLength = (b0 & 0x80) ? bMessageLength[b0 & 0x7f] : 0;
    if (bLength == 0)
    {
        return DMUS_E_INVALID_EVENT;
    }

    DMUS_EVENTHEADER *pHeader = AllocEventHeader(rt, 
                                                 bLength, 
                                                 dwChannelGroup, 
                                                 DMUS_EVENT_STRUCTURED);
    if (pHeader == NULL)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory((LPBYTE)(pHeader + 1), &dwMsg, bLength);

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | PackUnstructured | Inserts a MIDI channel message event at the end of the buffer.
//
// @comm
// There must be at least 16 bytes plus the quadword-aligned size of the message
// free in the buffer to insert a channel message.
//
// Although buffers may overlap in time, events within a buffer may not. All events in a buffer must
// be packed in order of ascending time.
// 
// @rdesc
//  
// @flag S_OK | On success.
// @flag E_OUTOFMEMORY | If there is no room in the buffer for the event.
// @flag E_POINTER | If the <p lpb> pointer is invalid.
//
//
STDMETHODIMP
CDirectMusicBuffer::PackUnstructured(
                              REFERENCE_TIME rt,    // @parm The absolute time of the event
                              DWORD dwChannelGroup, // @parm The channel group of the event on the outgoing port
                              DWORD cb,             // @parm The size in bytes of the event
                              LPBYTE lpb)           // @parm The next event must be played contigously
{
    V_INAME(IDirectMusicBuffer::PackSysEx);
    V_BUFPTR_READ(lpb, cb);

    DMUS_EVENTHEADER *pHeader = AllocEventHeader(rt, 
                                                 cb, 
                                                 dwChannelGroup,
                                                 0);
    if (pHeader == NULL)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory((LPBYTE)(pHeader + 1), lpb, cb);
    
    
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | ResetReadPtr | Causes the next to GetNextEvent to return the first event in the buffer.
//
// @comm
// Moves the read pointer to the start of the data in the buffer.
//
// @rdesc
//
// @flag S_OK | On success
//
STDMETHODIMP
CDirectMusicBuffer::ResetReadPtr()
{
    m_idxRead = 0;
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | GetNextEvent | Returns the next event in the buffer and advances the read pointer.
//
// @comm
// Any of the passed pointers may be NULL if the pointed-to item is not needed.
//
// The pointer returned in <p ppData> is only valid for the lifetime of the buffer object. It should only
// be held until the next call of the object's Release method.
//
// @rdesc
//
// @flag S_OK | On success
// @flag S_FALSE | If there are no more events in the buffer
// @flag E_POINTER | If any of the pointers is invalid
//
STDMETHODIMP
CDirectMusicBuffer::GetNextEvent(
                                 LPREFERENCE_TIME prt,      // @parm Receives the time of the event
                                 LPDWORD pdwChannelGroup,   // @parm Receives the channel group of the event
                                 LPDWORD pdwLength,         // @parm Receives the length in bytes of the event
                                 LPBYTE *ppData)            // @parm Receives a pointer to the event data
{
    V_INAME(IDirectMusicBuffer::GetNextEvent);
    V_PTR_WRITE_OPT(prt, REFERENCE_TIME);
    V_PTR_WRITE_OPT(pdwChannelGroup, DWORD);
    V_PTR_WRITE_OPT(pdwLength, DWORD);
    V_PTRPTR_WRITE_OPT(ppData);
            
    if (m_idxRead >= m_cbContents) {
        return S_FALSE;
    }

    LPDMUS_EVENTHEADER pHeader = (LPDMUS_EVENTHEADER)(m_pbContents + m_idxRead);
    m_idxRead += DMUS_EVENT_SIZE(pHeader->cbEvent);

    if (pdwLength) {
        *pdwLength = pHeader->cbEvent;
    }

    if (pdwChannelGroup) {
        *pdwChannelGroup = pHeader->dwChannelGroup;
    }

    if (prt) {
        *prt = m_rtBase + pHeader->rtDelta;
    }

    if (ppData) {
        *ppData = (LPBYTE)(pHeader + 1);
    }

    return S_OK;
}



DMUS_EVENTHEADER *
CDirectMusicBuffer::AllocEventHeader(
    REFERENCE_TIME rt,
    DWORD cbEvent,
    DWORD dwChannelGroup,
    DWORD dwFlags)
{
    DMUS_EVENTHEADER *pHeader;
    LPBYTE pbWalk = m_pbContents;
    DWORD  cbWalk = m_cbContents;

    // Add in header size and round up
    //
    DWORD cbNewEvent = DMUS_EVENT_SIZE(cbEvent);

    if (m_maxContents - m_cbContents < cbNewEvent)
    {
        return NULL;
    }

    if (m_cbContents == 0)
    {
        // Empty buffer
        //
        m_rtBase = rt;
        m_cbContents = cbNewEvent;
        pHeader = (DMUS_EVENTHEADER*)m_pbContents;
    }
    else if (rt >= m_rtBase + m_totalTime)
    {
        // At end of buffer
        //
        if (rt - m_rtBase > m_totalTime)
            m_totalTime = rt - m_rtBase;
        
        pHeader = (DMUS_EVENTHEADER*)(m_pbContents + m_cbContents);
        m_cbContents += cbNewEvent;
    }
    else if (rt < m_rtBase)
    {
        // New first event and have to adjust all the offsets.
        //
        REFERENCE_TIME rtDelta = m_rtBase - rt;

        while (cbWalk)
        {
            assert(cbWalk >= sizeof(DMUS_EVENTHEADER));

            DMUS_EVENTHEADER *pTmpHeader = (DMUS_EVENTHEADER*)pbWalk;
            DWORD cbTmpEvent = DMUS_EVENT_SIZE(pTmpHeader->cbEvent);
            assert(cbWalk >= cbTmpEvent);

            pTmpHeader->rtDelta += rtDelta;
            m_totalTime = pTmpHeader->rtDelta;

            cbWalk -= cbTmpEvent;
            pbWalk += cbTmpEvent;
        }        

        m_rtBase = rt;
        MoveMemory(m_pbContents + cbNewEvent, m_pbContents, m_cbContents);

        m_cbContents += cbNewEvent;
        pHeader = (DMUS_EVENTHEADER*)m_pbContents;
    }
    else
    {
        // Out of order event. Search until we find where it goes
        //
        for (;;)
        {
            assert(cbWalk >= sizeof(DMUS_EVENTHEADER));
            
            DMUS_EVENTHEADER *pTmpHeader = (DMUS_EVENTHEADER*)pbWalk;
            DWORD cbTmpEvent = DMUS_EVENT_SIZE(pTmpHeader->cbEvent);
            assert(cbWalk >= cbTmpEvent);

            if (m_rtBase + pTmpHeader->rtDelta > rt)
            {
                break;
            }

            cbWalk -= cbTmpEvent;
            pbWalk += cbTmpEvent;
        }        

        // pbWalk points to first byte to go *after* the new event, which will be the new
        // event's location. cbWalk is the number of bytes left in the buffer
        //
        MoveMemory(pbWalk + cbNewEvent, pbWalk, cbWalk);
        
        m_cbContents += cbNewEvent;
        pHeader = (DMUS_EVENTHEADER*)pbWalk;
    }

    pHeader->cbEvent            = cbEvent;
    pHeader->dwChannelGroup     = dwChannelGroup;
    pHeader->rtDelta            = rt - m_rtBase;
    pHeader->dwFlags            = dwFlags;

    return pHeader;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmclock.cpp ===
//
// DMClock.CPP
//
// Copyright (c) 1997-2001 Microsoft Corporation
//
// Code for dealing with master clocks
//

#include <objbase.h>
#include "debug.h"
#include <mmsystem.h>

#include "dmusicp.h"
#include "debug.h"
#include "validate.h"

const char cszClockMemory[] = "DirectMusicMasterClock";
const char cszClockMutex[]  = "DirectMusicMasterClockMutex";

// CMasterClock::CMasterClock
//
// All real initialization is done in Init
//
CMasterClock::CMasterClock()
{
    m_cRef = 0;
    m_cRefPrivate = 0;

    m_pMasterClock = NULL;
    m_hClockMemory = NULL;
    m_pClockMemory = NULL;
    m_hClockMutex  = NULL;
    m_pExtMasterClock = NULL;
    m_llExtOffset = 0;
    m_pSinkSync = NULL;
}

// CMasterClock::~CMasterClock
//
CMasterClock::~CMasterClock()
{
    Close();
}

// CMasterClock::Init
//
// Create Windows objects for shared memory and synchronization
// Create the list of clocks
//
HRESULT CMasterClock::Init()
{
    // Create a file mapping object for the shared master clock settings
    //
    m_hClockMemory = CreateFileMapping(INVALID_HANDLE_VALUE,    // Use paging file
                                       NULL,                    // Default security descriptor
                                       PAGE_READWRITE,
                                       0,                       // High DWORD of size
                                       sizeof(CLOCKSHARE),
                                       cszClockMemory);
    if (m_hClockMemory == NULL)
    {
        TraceI(0, "CreateFileMapping failed! [%d]\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    // Was this the call that created the shared memory?
    //
    BOOL fFirst = (GetLastError() != ERROR_ALREADY_EXISTS);

    m_pClockMemory = (CLOCKSHARE*)MapViewOfFile(m_hClockMemory,
                                                FILE_MAP_WRITE,
                                                0, 0,                // Start mapping at the beginning
                                                0);                  // Map entire file
    if (m_pClockMemory == NULL)
    {
        TraceI(0, "MapViewOfFile failed! [%d]\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    m_hClockMutex = CreateMutex(NULL,             // Default security descriptor
                                fFirst,           // Own mutex if we are first instance
                                cszClockMutex);
    if (m_hClockMutex == NULL)
    {
        TraceI(0, "CreateMutex failed! [%d]\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    if (fFirst)
    {
        // We are the first instance and we own the mutex to modify the shared memory.
        //
        m_pClockMemory->guidClock = GUID_SysClock;
        m_pClockMemory->dwFlags = 0;

        ReleaseMutex(m_hClockMutex);
    }

    // Initialize list of possible clocks
    //
    UpdateClockList();

    return S_OK;
}

// CMasterClock::Close
//
// Release all resources.
//  Release master clock
//  Release list of enum'ed clocks
//  Release Windows objects for shared memory and synchronization
//
void CMasterClock::Close()
{
    CNode<CLOCKENTRY *> *pClockNode;
    CNode<CLOCKENTRY *> *pClockNext;

    // Clock wrapped by CMasterClock
    //
    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }

    if (m_pExtMasterClock)
    {
        m_pExtMasterClock->Release();
        m_pExtMasterClock = NULL;
    }

    if (m_pSinkSync)
    {
        m_pSinkSync->Release();
        m_pSinkSync = NULL;
    }

    // List of enum'ed clocks
    //
    for (pClockNode = m_lstClocks.GetListHead(); pClockNode; pClockNode = pClockNext)
    {
        pClockNext = pClockNode->pNext;

        delete pClockNode->data;
        m_lstClocks.RemoveNodeFromList(pClockNode);
    }

    // Everything else
    //
    if (m_hClockMutex)
    {
        CloseHandle(m_hClockMutex);
    }

    if (m_pClockMemory)
    {
        UnmapViewOfFile(m_pClockMemory);
    }

    if (m_hClockMemory)
    {
        CloseHandle(m_hClockMemory);
    }
}

// CMasterClock::UpdateClockList()
//
// Make sure the list of available clocks is up to date
//
HRESULT CMasterClock::UpdateClockList()
{
    HRESULT hr;

    CNode<CLOCKENTRY *> *pNode;
    CNode<CLOCKENTRY *> *pNext;

    for (pNode = m_lstClocks.GetListHead(); pNode; pNode = pNode->pNext)
    {
        pNode->data->fIsValid = FALSE;
    }

    // Add the system clock. This clock must *always* be there
    //
#if defined(USE_WDM_DRIVERS)
    hr = AddPcClocks(this);
#else
    hr = S_FALSE;
#endif

    if (FAILED(hr) || hr == S_FALSE)
    {
        AddSysClocks(this);
    }

    AddDsClocks(this);

    // Remove nodes which are no longer valid
    //
    for (pNode = m_lstClocks.GetListHead(); pNode; pNode = pNext)
    {
        pNext = pNode->pNext;

        if (!pNode->data->fIsValid)
        {
            delete pNode->data;
            m_lstClocks.RemoveNodeFromList(pNode);
        }
    }

    return m_lstClocks.GetNodeCount() ? S_OK : S_FALSE;
}

// CMasterClock::AddClock
//
// Add the given clock to the list if it isn't there already
//
HRESULT CMasterClock::AddClock(
    PCLOCKENTRY pClock)
{
    CNode<CLOCKENTRY *> *pNode;

    for (pNode = m_lstClocks.GetListHead(); pNode; pNode = pNode->pNext)
    {
        if (pClock->cc.guidClock == pNode->data->cc.guidClock)
        {
            pNode->data->fIsValid = TRUE;
            return S_OK;
        }
    }

    // No existing entry - need to create a new one
    //
    PCLOCKENTRY pNewClock = new CLOCKENTRY;
    if (NULL == pNewClock)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory(pNewClock, pClock, sizeof(CLOCKENTRY));
    pNewClock->fIsValid = TRUE;

    if (NULL == m_lstClocks.AddNodeToList(pNewClock))
    {
        delete pNewClock;
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

// CMasterClock::GetMasterClockInterface
//
// Retrieve the wrapped master clock. This should be the *only* way
// DirectMusic gets the master clock. It is responsible for creating
// the clock and updating the shared memory if the clock does not
// exist yet.
//
HRESULT CMasterClock::GetMasterClockInterface(IReferenceClock **ppClock)
{
    WaitForSingleObject(m_hClockMutex, INFINITE);

    if (m_pMasterClock == NULL)
    {
        // We don't have a wrapped clock yet
        //
        HRESULT hr = CreateMasterClock();
        if (FAILED(hr))
        {
            ReleaseMutex(m_hClockMutex);
            return hr;
        }

        // Now we do. This means it can no longer be changed.
        //
        m_pClockMemory->dwFlags |= CLOCKSHARE_F_LOCKED;
    }

    // We have the clock. We return an interface to *this* object, which is also
    // a clock and wraps the real one. This allows us to track releases.
    //
    *ppClock = (IReferenceClock*)this;
    AddRef();

    ReleaseMutex(m_hClockMutex);

    return S_OK;
}

// CMasterClock::CreateMasterClock
//
// Actually create the clock object.
//
// This method is private to CMasterClock and assumes the mutex is taken so it can
// access the shared memory.
//
HRESULT CMasterClock::CreateMasterClock()
{
    HRESULT hr;
    CNode<CLOCKENTRY *> *pNode;
    CLOCKENTRY *pClock;

    // Assume clock will not be found
    //
    hr = E_INVALIDARG;

    pClock = NULL;
    for (pNode = m_lstClocks.GetListHead(); pNode; pNode = pNode->pNext)
    {
        if (m_pClockMemory->guidClock == pNode->data->cc.guidClock)
        {
            pClock = pNode->data;
            break;
        }
    }

    if (pClock)
    {
        hr = pClock->pfnGetInstance(&m_pMasterClock, this);
    }

    if (SUCCEEDED(hr))
    {
        if (FAILED(m_pMasterClock->QueryInterface(IID_IDirectSoundSinkSync, (void**)&m_pSinkSync)))
        {
            // This is OK, not all clocks support this
            //
            m_pSinkSync = NULL;
        }
    }

    return hr;
}

// CMasterClock::SyncToExternalClock
//
// Sync to an application-given master clock
//
void CMasterClock::SyncToExternalClock()
{
    HRESULT hr;

    assert(m_pExtMasterClock);
    assert(m_pMasterClock);

    REFERENCE_TIME rtSystem;
    hr = m_pMasterClock->GetTime(&rtSystem);

    REFERENCE_TIME rtExternal;
    if (SUCCEEDED(hr))
    {
        hr = m_pExtMasterClock->GetTime(&rtExternal);
    }

    if (SUCCEEDED(hr))
    {
        LONGLONG drift = (rtSystem + m_llExtOffset) - rtExternal;
        m_llExtOffset -= drift / 100;
    }
}

// CMasterClock::EnumMasterClock
//
// Traverse the list looking for the given node
//
HRESULT CMasterClock::EnumMasterClock(
    DWORD           dwIndex,
    LPDMUS_CLOCKINFO lpClockInfo,
    DWORD           dwVer)
{
    CNode<CLOCKENTRY *> *pNode;
    DWORD dwSize; // Used to preserve the dwSize parameter

    pNode = m_lstClocks.GetListHead();
    if (dwIndex == 0 || pNode == NULL)
    {
        UpdateClockList();
    }

    pNode = m_lstClocks.GetListHead();
    if (NULL == pNode)
    {
        return E_NOINTERFACE;
    }

    while (dwIndex-- && pNode)
    {
        pNode = pNode->pNext;
    }

    if (pNode == NULL)
    {
        return S_FALSE;
    }

    // Let's capture the dwSize parameter and preserve it past the memcopy.
    // if we dont' do this then the dwSize probably becomes the size of the
    // largerst strucure
    dwSize = lpClockInfo->dwSize;

    switch (dwVer)
    {
        case 7:
        default:
            memcpy(lpClockInfo, &pNode->data->cc, sizeof(DMUS_CLOCKINFO7));
            break;

        case 8:
            memcpy(lpClockInfo, &pNode->data->cc, sizeof(DMUS_CLOCKINFO8));
    }

    // Now restore the dwSize member
    lpClockInfo->dwSize = dwSize;

    return S_OK;
}


// CMasterClock::GetMasterClock
//
// Return the guid and/or interface to the master clock.
// The master clock may be created as a side effect of this call if one does not
// exist already.
//
HRESULT CMasterClock::GetMasterClock(
    LPGUID pguidClock,
    IReferenceClock **ppClock)
{
    HRESULT hr = S_OK;

    WaitForSingleObject(m_hClockMutex, INFINITE);

    if (pguidClock)
    {
        *pguidClock = m_pClockMemory->guidClock;
    }

    if (ppClock)
    {
        hr = GetMasterClockInterface(ppClock);
    }

    ReleaseMutex(m_hClockMutex);

    return hr;
}

// CMasterClock::SetMasterClock
//
// If the master clock can be updated (i.e. there are no open instances of it),
// then change the shared memory which indicates the GUID.
//
HRESULT CMasterClock::SetMasterClock(REFGUID rguidClock)
{
    HRESULT hr;
    CNode<CLOCKENTRY *> *pNode;
    CLOCKENTRY *pClock;

    WaitForSingleObject(m_hClockMutex, INFINITE);



    if (m_pClockMemory->dwFlags & CLOCKSHARE_F_LOCKED)
    {
        hr = DMUS_E_PORTS_OPEN;
    }
    else
    {
        // Assume clock will not be found
        //
        hr = E_INVALIDARG;

        pClock = NULL;
        for (pNode = m_lstClocks.GetListHead(); pNode; pNode = pNode->pNext)
        {
            if (rguidClock == pNode->data->cc.guidClock)
            {
                pClock = pNode->data;
                break;
            }
        }

        if (pClock)
        {
            // It exists! Save the GUID for later
            //
            m_pClockMemory->guidClock = rguidClock;
            hr = S_OK;
        }
    }

    ReleaseMutex(m_hClockMutex);

    return hr;
}

// CMasterClock::SetMasterClock
//
// This version takes an IReferenceClock and uses it to override the clock
// for this process.
//
// This clock is allowed to be jittery. What will actually happen is that the
// system master clock will be locked to this clock so that the master clock
// will be fine grained.
//
HRESULT CMasterClock::SetMasterClock(IReferenceClock *pClock)
{
    HRESULT hr = S_OK;

    WaitForSingleObject(m_hClockMutex, INFINITE);

    // We must have the default system clock first so we can sync it
    //
    if (pClock && m_pMasterClock == NULL)
    {
        // We don't have a wrapped clock yet
        //
        hr = CreateMasterClock();

        if (SUCCEEDED(hr))
        {
            // Now we do. This means it can no longer be changed.
            //
            m_pClockMemory->dwFlags |= CLOCKSHARE_F_LOCKED;
        }
    }

    // Now set up sync to this master clock
    //
    if (SUCCEEDED(hr))
    {
        if (pClock)
        {
            REFERENCE_TIME rtSystem;
            REFERENCE_TIME rtExternal;

            hr = m_pMasterClock->GetTime(&rtSystem);

            if (SUCCEEDED(hr))
            {
                hr = pClock->GetTime(&rtExternal);
            }

            if (SUCCEEDED(hr))
            {
                m_llExtOffset = rtExternal - rtSystem;
            }
        }
    }

    // If everything went well, switch over to the new clock
    //
    if (SUCCEEDED(hr))
    {
        if (m_pExtMasterClock)
        {
            m_pExtMasterClock->Release();
            m_pExtMasterClock = NULL;
        }

        m_pExtMasterClock = pClock;

        if (m_pExtMasterClock)
        {
            m_pExtMasterClock->AddRef();
        }
    }

    ReleaseMutex(m_hClockMutex);

    return S_OK;
}

// CMasterClock::AddRefPrivate
//
// Release a private reference to the master clock held by DirectMusic
//
LONG CMasterClock::AddRefPrivate()
{
    InterlockedIncrement(&m_cRefPrivate);
    return m_cRefPrivate;
}

// CMasterClock::ReleasePrivate
//
// Release a private reference to the master clock held by DirectMusic
//
LONG CMasterClock::ReleasePrivate()
{
    long cRefPrivate = InterlockedDecrement(&m_cRefPrivate);

    if (cRefPrivate == 0 && m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return cRefPrivate;
}

// CMasterClock::CreateDefaultMasterClock
//
// Creates a private instance of the hardware clock we're using. This is always
// the first entry in the clock list
//
HRESULT CMasterClock::CreateDefaultMasterClock(IReferenceClock **ppClock)
{
    HRESULT hr = S_OK;
    CLOCKENTRY *pClock;

    WaitForSingleObject(m_hClockMutex, INFINITE);

    if (m_lstClocks.GetListHead() == NULL)
    {
        UpdateClockList();
    }

    if (m_lstClocks.GetListHead() == NULL)
    {
        hr = E_NOINTERFACE;
    }

    if (SUCCEEDED(hr))
    {
        pClock = m_lstClocks.GetListHead()->data;
        hr = pClock->pfnGetInstance(ppClock, this);
    }

    ReleaseMutex(m_hClockMutex);

    return hr;
}

STDMETHODIMP CMasterClock::SetClockOffset(LONGLONG llOffset)
{
    if (m_pSinkSync)
    {
        return m_pSinkSync->SetClockOffset(llOffset);
    }
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// IReferenceClock interface
//
//

// CMasterClock::QueryInterface
//
// Standard COM implementation
//
STDMETHODIMP CMasterClock::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusic::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else if (iid == IID_IDirectSoundSinkSync)
    {
        // Only support this if the wrapped clock supports it
        //
        if (m_pSinkSync)
        {
            *ppv = static_cast<IDirectSoundSinkSync*>(this);
        }
        else
        {
            return E_NOINTERFACE;
        }
    }
    else
    {
        // Some master clocks expose private interfaces. Wrap them.
        //
        // Note that these interfaces acrue to the reference count of the wrapped
        // clock, not CMasterClock
        //
        if (m_pMasterClock)
        {
            return m_pMasterClock->QueryInterface(iid, ppv);
        }

        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

// CMasterClock::AddRef
//
STDMETHODIMP_(ULONG) CMasterClock::AddRef()
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

// CMasterClock::Release
//
// Since we are tracking a reference count for our wrapped clock, this
// gets a little strange. We have to release that object and change the
// shared memory on the last release, but we don't release ourselves (the
// wrapper object stays around for the life of this instance of DirectMusic).
//
STDMETHODIMP_(ULONG) CMasterClock::Release()
{
    WaitForSingleObject(m_hClockMutex, INFINITE);

    m_cRef--;
    if (m_cRef == 0)
    {
        // Last release! Get rid of the clock and mark the shared memory
        // as unlocked.
        //
        m_pMasterClock->Release();
        m_pMasterClock = NULL;

        m_pClockMemory->dwFlags &= ~CLOCKSHARE_F_LOCKED;
    }

    ReleaseMutex(m_hClockMutex);

    if (m_cRefPrivate == 0 && m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CMasterClock::GetTime
//
// This is possibly called directly by an app and thus needs parameter validation
//
STDMETHODIMP CMasterClock::GetTime(REFERENCE_TIME *pTime)
{
    V_INAME(IReferenceClock::GetTime);
    V_PTR_WRITE(pTime, REFERENCE_TIME);

    HRESULT hr = E_NOINTERFACE;

    if (m_pMasterClock)
    {
        REFERENCE_TIME rt = 0;

        hr = m_pMasterClock->GetTime(&rt);

        if (SUCCEEDED(hr) && m_pExtMasterClock)
        {
            SyncToExternalClock();
            rt += m_llExtOffset;
        }

        *pTime = rt;
    }

    return hr;
}

// CMasterClock::AdviseTime
//
// This is possibly called directly by an app and thus needs parameter validation
//
STDMETHODIMP CMasterClock::AdviseTime(REFERENCE_TIME baseTime,
                                           REFERENCE_TIME streamTime,
                                           HANDLE hEvent,
                                           DWORD * pdwAdviseCookie)
{
    V_INAME(IReferenceClock::AdviseTime);
    V_PTR_WRITE(pdwAdviseCookie, DWORD);

    if (m_pMasterClock)
    {
        return m_pMasterClock->AdviseTime(baseTime, streamTime, hEvent, pdwAdviseCookie);
    }

    return E_NOINTERFACE;
}

// CMasterClock::AdvisePeriodic
//
// This is possibly called directly by an app and thus needs parameter validation
//
STDMETHODIMP CMasterClock::AdvisePeriodic(REFERENCE_TIME startTime,
                                               REFERENCE_TIME periodTime,
                                               HANDLE hSemaphore,
                                               DWORD * pdwAdviseCookie)
{
    V_INAME(IReferenceClock::AdvisePeriodic);
    V_PTR_WRITE(pdwAdviseCookie, DWORD);

    if (m_pMasterClock)
    {
        return m_pMasterClock->AdvisePeriodic(startTime, periodTime, hSemaphore, pdwAdviseCookie);
    }

    return E_NOINTERFACE;
}

// CMasterClock::AdvisePeriodic
//
// This is possibly called directly by an app
//
STDMETHODIMP CMasterClock::Unadvise(DWORD dwAdviseCookie)
{
    if (m_pMasterClock)
    {
        return m_pMasterClock->Unadvise(dwAdviseCookie);
    }

    return E_NOINTERFACE;
}

// CMasterClock::GetParam
//
// Called by a client to request internal information from the clock
// implementation
//
STDMETHODIMP CMasterClock::GetParam(REFGUID rguidType, LPVOID pBuffer, DWORD cbSize)
{
    if (m_pMasterClock == NULL)
    {
        // Master clock must exist first
        //
        return E_NOINTERFACE;
    }

    IMasterClockPrivate *pPrivate;

    HRESULT hr = m_pMasterClock->QueryInterface(IID_IMasterClockPrivate, (void**)&pPrivate);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pPrivate->GetParam(rguidType, pBuffer, cbSize);

    pPrivate->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmcollec.h ===
//
// dmcollec.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
//

#ifndef DMCOLLEC_H
#define DMCOLLEC_H

#include "dmusici.h"
#include "dminstru.h"

class CCopyright;
class CRiffParser;

typedef struct _DMUS_WAVEOFFSET
{
	DWORD	dwId;
	DWORD	dwOffset;
} DMUS_WAVEOFFSET;

typedef struct _DMUS_PATCHENTRY
{
	ULONG	ulId;
	ULONG	ulPatch;
	ULONG	ulOffset;
} DMUS_PATCHENTRY;

class CCollection : public IDirectMusicCollection, public IPersistStream, public IDirectMusicObject
{
friend class CInstrObj;
friend class CWaveObj;
friend class CInstrument;

public:
	enum {DM_OFFSET_RIFFCHUNK_DATA = 8, 
		  DM_WAVELISTCHK_OFFSET_FROM_WAVE_TBL_BASE = 12, 
		  DM_WAVELISTCHK_OFFSET_FROM_WAVE_FORMTYPE = 8};
    
	// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IPersist
	STDMETHODIMP GetClassID(CLSID* pClassID) {return E_NOTIMPL;}

    // IPersistStream
	STDMETHODIMP IsDirty() {return S_FALSE;}
    STDMETHODIMP Load(IStream* pIStream);
    STDMETHODIMP Save(IStream* pIStream, BOOL fClearDirty) {return E_NOTIMPL;}
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

	// IDirectMusicCollection
	STDMETHODIMP GetInstrument(DWORD dwPatch, IDirectMusicInstrument** pInstrument);
	STDMETHODIMP EnumInstrument(DWORD dwIndex, DWORD* pdwPatch, LPWSTR pName, DWORD cwchName);

	// Class
	CCollection();
    ~CCollection();

private:
	void Cleanup();
	HRESULT Parse(CRiffParser *pParser);
	HRESULT BuildInstrumentOffsetTable(CRiffParser *pParser);
	HRESULT BuildWaveOffsetTable(CRiffParser *pParser);

	HRESULT ExtractInstrument(DWORD& dwPatch, CInstrObj** pInstrObj);
	HRESULT ExtractWave(DWORD dwId, CWaveObj** ppWaveObj);
	
	HRESULT ValidateOffset(DWORD dwOffset)
	{
		if( (dwOffset < m_dwStartRiffChunk)  || 
		    (m_dwStartRiffChunk + m_dwSizeRiffChunk < m_dwStartRiffChunk) ||
		    (dwOffset > (m_dwStartRiffChunk + m_dwSizeRiffChunk - 1))
		  )
		{
			return DMUS_E_INVALIDOFFSET;
		}
	
		return S_OK;            
	}

    STDMETHODIMP FindInstrument(DWORD dwPatch, CInstrument** ppDMDLInst);
    STDMETHODIMP AddInstrument(CInstrument* pDMDLInst);
    STDMETHODIMP RemoveInstrument(CInstrument* pDMDLInst);

private:
    IStream *                       m_pStream;              // Stream used for reading the collection and pulling waves out for downloading.    
    DWORD                           m_dwSizeRiffChunk;			// Size of DLS chunk, for validation.
    DWORD                           m_dwStartRiffChunk;         // Start of DLS chunk in file (could be embedded in larger file.)
    DWORD							m_dwFirstInsId;
	ULONG							m_dwNumPatchTableEntries;
	DMUS_PATCHENTRY*				m_pPatchTable;
	DWORD							m_dwFirstWaveId;				
	DWORD                           m_dwWaveTableBaseAddress;		// Used to hold the start of waves within DLS file
	DMUS_WAVEOFFSET*				m_pWaveOffsetTable;	
    DWORD                           m_dwWaveOffsetTableSize;    // Used to verify that references are within range (check for bad wave links in file.)
	CCopyright*						m_pCopyright;
    WCHAR			                m_wszName[DMUS_MAX_NAME]; // Name of DLS collection.
	DLSVERSION						m_vVersion;					
	GUID							m_guidObject;
	bool							m_bLoaded;
	long							m_cRef;
    CInstrumentList                 m_InstList;
    CRITICAL_SECTION                m_CDMCollCriticalSection;
    BOOL                            m_fCSInitialized;
};

#endif // #ifndef DMCOLLEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmcollec.cpp ===
//
// dmcollec.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay
//
// @doc EXTERNAL
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include "debug.h"
#include <objbase.h>
#include "dmusicp.h"
#include "debug.h"
#include "dlsstrm.h"
#include "dmcrchk.h"
#include "dminsobj.h"
#include "dmcollec.h"
#include "validate.h"
#include <strsafe.h>

//////////////////////////////////////////////////////////////////////
// Class CCollection

//////////////////////////////////////////////////////////////////////
// CCollection::CCollection

CCollection::CCollection() 
{
    m_pStream = NULL;
    m_dwSizeRiffChunk = 0;
    m_dwFirstInsId = 0;
    m_dwNumPatchTableEntries = 0;
    m_pPatchTable = NULL;
    m_dwFirstWaveId = 0;
    m_dwWaveTableBaseAddress = 0;
    m_pWaveOffsetTable = NULL;
    m_dwWaveOffsetTableSize = 0;
    m_pCopyright = NULL;
    m_guidObject = GUID_NULL;
    m_bLoaded = false;
    m_cRef = 1;
    m_fCSInitialized = FALSE;
    InterlockedIncrement(&g_cComponent);
    InitializeCriticalSection(&m_CDMCollCriticalSection);
    m_fCSInitialized = TRUE;
    ZeroMemory(&m_vVersion, sizeof(m_vVersion));
    m_wszName[0] = 0;
}
    
//////////////////////////////////////////////////////////////////////
// CCollection::~CCollection()

CCollection::~CCollection()
{
    if (m_fCSInitialized)
    {
        Cleanup();

        EnterCriticalSection(&m_CDMCollCriticalSection);

        if ((!m_InstList.IsEmpty()))
        {
#ifdef DBG
            assert(FALSE); // should never happen (as long as instruments keep a refcnt on us)
#endif // DBG
            while (!m_InstList.IsEmpty())
            {
                m_InstList.RemoveHead();
            }
        }

        LeaveCriticalSection(&m_CDMCollCriticalSection);

        DeleteCriticalSection(&m_CDMCollCriticalSection);
    }

    InterlockedDecrement(&g_cComponent);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CCollection::QueryInterface

STDMETHODIMP CCollection::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicCollection::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


    if(iid == IID_IUnknown || iid == IID_IDirectMusicCollection)
    {
        *ppv = static_cast<IDirectMusicCollection*>(this);
    } 
    else if(iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if(iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if(iid == IID_IPersist)
    {
        *ppv = static_cast<IPersist*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CCollection::AddRef

STDMETHODIMP_(ULONG) CCollection::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CCollection::Release

STDMETHODIMP_(ULONG) CCollection::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

//////////////////////////////////////////////////////////////////////
// CCollection::Load

STDMETHODIMP CCollection::Load(IStream* pStream)
{
    // Argument validation
    V_INAME(CCollection::Load);
    V_PTR_READ(pStream, IStream);

    // If we have a previous DLS stream return with an error
    if(m_pStream)
    {
        return DMUS_E_ALREADY_LOADED;
    }
    pStream->AddRef();
    m_pStream = pStream;
    HRESULT hr = S_OK;
    RIFFIO ckMain;
    CRiffParser Parser(pStream);
    // Get the current position in the stream and save for validation.
    Parser.EnterList(&ckMain);  
    Parser.MarkPosition();
    // This should be the start of the data chunk, so add the size of the RIFF header.
    m_dwStartRiffChunk = (DWORD) ckMain.liPosition.QuadPart + 8;
    if (Parser.NextChunk(&hr))
    {
        // Now that we've read the header, store the size of the data to follow (which
        // should be the entire DLS collection if in fact this is FOURCC_DLS).
        // This will be used for validation later.
        m_dwSizeRiffChunk = ckMain.cksize;
        if (ckMain.fccType == FOURCC_DLS)
        {
            // We have a DLS Collection we now want to parse it
            hr = Parse(&Parser);
        }
        else
        {
            hr = DMUS_E_NOTADLSCOL;
        }
    }

    m_bLoaded = true;

    if(FAILED(hr))
    {
        // If not a DLS Collection or some other error release allocated resources
        Cleanup();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicObject

//////////////////////////////////////////////////////////////////////
// CCollection::GetDescriptor

STDMETHODIMP CCollection::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CCollection::GetDescriptor);
    // Deal with the fact that we wrote incorrect invalidation tests for DX7, and then
    // crafted the code to pass.
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    if (pDesc->dwSize)
    {
        V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    }
    else
    {
        pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    }

    if(m_vVersion.dwVersionMS || m_vVersion.dwVersionLS)
    {
        pDesc->dwValidData |= DMUS_OBJ_VERSION;
        pDesc->vVersion.dwVersionMS = m_vVersion.dwVersionMS;
        pDesc->vVersion.dwVersionLS = m_vVersion.dwVersionLS;
    }

    if(m_pCopyright != NULL && 
       m_pCopyright->m_byFlags & DMC_FOUNDINAM)
    {
        if (m_pCopyright->m_pwzName)
        {
            pDesc->dwValidData |= DMUS_OBJ_NAME;
            StringCchCopyW(pDesc->wszName, DMUS_MAX_NAME, m_pCopyright->m_pwzName);
        }
    }

    if(m_guidObject != GUID_NULL)
    {
        pDesc->dwValidData |= DMUS_OBJ_OBJECT;
        pDesc->guidObject = m_guidObject;
    }

    if (m_wszName[0])
    {
        StringCchCopyW(pDesc->wszName, DMUS_MAX_NAME, m_wszName);
        pDesc->dwValidData |= DMUS_OBJ_NAME;
    }
    
    pDesc->guidClass = CLSID_DirectMusicCollection;
    pDesc->dwValidData |= DMUS_OBJ_CLASS;

    if(m_bLoaded)
    {
        pDesc->dwValidData |= DMUS_OBJ_LOADED;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CCollection::SetDescriptor

STDMETHODIMP CCollection::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CCollection::SetDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC);
    if (pDesc->dwSize)
    {
        V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
    }
    
    DWORD dwTemp = pDesc->dwValidData;

    if(pDesc->dwValidData == 0)
    {
        return S_OK;
    }

    if(pDesc->dwValidData & DMUS_OBJ_OBJECT)
    {
        m_guidObject = pDesc->guidObject;
    }

    if(pDesc->dwValidData & DMUS_OBJ_CLASS)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_CLASS;
    }

    if(pDesc->dwValidData & DMUS_OBJ_NAME)
    {
        StringCchCopyW(m_wszName, DMUS_MAX_NAME, pDesc->wszName);
    }

    if(pDesc->dwValidData & DMUS_OBJ_CATEGORY)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_CATEGORY;
    }

    if(pDesc->dwValidData & DMUS_OBJ_FILENAME)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_FILENAME;
    }

    if(pDesc->dwValidData & DMUS_OBJ_FULLPATH)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_FULLPATH;
    }

    if(pDesc->dwValidData & DMUS_OBJ_URL)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_URL;
    }

    if(pDesc->dwValidData & DMUS_OBJ_VERSION)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_VERSION;
    }
    
    if(pDesc->dwValidData & DMUS_OBJ_DATE)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_DATE;
    }

    if(pDesc->dwValidData & DMUS_OBJ_LOADED)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_LOADED;
    }
    
    return dwTemp == pDesc->dwValidData ? S_OK : S_FALSE;
}

//////////////////////////////////////////////////////////////////////
// CCollection::ParseDescriptor

STDMETHODIMP CCollection::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) 
{
    // Argument validation
    V_INAME(CCollection::ParseDescriptor);
    V_PTR_READ(pStream, IStream);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    // This is needed to make up for regression issues.
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    CRiffParser Parser(pStream);
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;
    DWORD dwValidData;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == FOURCC_DLS))
    {
        dwValidData = DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicCollection;
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case FOURCC_DLID:
                hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
                dwValidData |= DMUS_OBJ_OBJECT;
                break;
            case FOURCC_VERS:
                hr = Parser.Read( &pDesc->vVersion, sizeof(DLSVERSION) );
                dwValidData |= DMUS_OBJ_VERSION;
                break;
            case FOURCC_LIST:
                if (ckNext.fccType == mmioFOURCC('I','N','F','O'))
                {
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        if (ckUNFO.ckid == mmioFOURCC('I','N','A','M'))
                        {
                            char szName[DMUS_MAX_NAME];
                            hr = Parser.Read(szName, DMUS_MAX_NAME);
                            szName[DMUS_MAX_NAME-1] = '\0';
                            MultiByteToWideChar(CP_ACP, 0, szName, -1, pDesc->wszName, DMUS_MAX_NAME);
                            dwValidData |= DMUS_OBJ_NAME;
                        }
                    }
                    Parser.LeaveList();          
                }
                break;
            }
        }
        Parser.LeaveList();
    }
    else
    {
        hr = DMUS_E_NOTADLSCOL;
    }
    if (SUCCEEDED(hr))
    {
        pDesc->dwValidData = dwValidData;
    }
    return hr;
}

STDMETHODIMP CCollection::GetInstrument(
    DWORD dwPatch,                          // @parm Instrument patch number, including bank select and drum flag.
    IDirectMusicInstrument** ppInstrument)  // @parm Return value in pointer to <i IDirectMusicInstrument> interface.
{
    // Argument validation
    V_INAME(CCollection::GetInstrument);
    V_PTRPTR_WRITE(ppInstrument);

    // We use 0x7F to strip out the Drum Kit flag
    BYTE bMSB = (BYTE) ((dwPatch >> 16) & 0x7F);
    BYTE bLSB = (BYTE) (dwPatch >> 8);
    BYTE bInstrument = (BYTE) dwPatch;

    if (bMSB < 0 || bMSB > 127 ||
       bLSB < 0 || bLSB > 127 ||
       bInstrument < 0 || bInstrument > 127)
    {
        return DMUS_E_INVALIDPATCH;
    } 
    
    EnterCriticalSection(&m_CDMCollCriticalSection);

    HRESULT hr = E_FAIL;

    CInstrument* pDMInstrument = NULL;
    
    hr = FindInstrument(dwPatch, &pDMInstrument);
    
    if (!pDMInstrument && SUCCEEDED(hr))
    {
        try
        {
            pDMInstrument = new CInstrument();
        }
        catch( ... )
        {
            pDMInstrument = NULL;
        }

        if (pDMInstrument)
        {
            hr = pDMInstrument->Init(dwPatch, this);

            if (SUCCEEDED(hr))
            {
                hr = AddInstrument(pDMInstrument);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (FAILED(hr))
    {
        if (pDMInstrument)
        {
            pDMInstrument->Release();
        }
    }
    else
    {
        *ppInstrument = pDMInstrument;
    }

    LeaveCriticalSection(&m_CDMCollCriticalSection);

    return hr;
}

STDMETHODIMP CCollection::EnumInstrument(
    DWORD dwIndex,      // @parm Index into collection's list of instruments.
    DWORD* pdwPatch,    // @parm Pointer to DWORD variable to store patch number in.
    LPWSTR pwszName,        // @parm Address of the WCHAR buffer to receive the instrument name.
                        // NULL, if no name desired.
    DWORD dwNameLen)    // @parm Length of the instrument name buffer in WCHARs.
{
    // Argument validation
    V_INAME(IDirectMusicCollection::EnumInstrument);    
    V_PTR_WRITE(pdwPatch, DWORD);

    if(pwszName && (dwNameLen > 0))
    {
        V_BUFPTR_WRITE(pwszName, (sizeof(WCHAR) * dwNameLen));
    }

    if(dwIndex >= m_dwNumPatchTableEntries)
    {
        return S_FALSE;
    }

    HRESULT hr = S_OK;

    *pdwPatch = m_pPatchTable[dwIndex].ulPatch;

    if(pwszName && dwNameLen != 0)
    {
        pwszName[0] = '\0';

        LARGE_INTEGER li;
        li.QuadPart = m_pPatchTable[dwIndex].ulOffset;
        assert(m_pStream);
        // Seek to beginning of the instrument list chunk in DLS file
        hr = m_pStream->Seek(li,STREAM_SEEK_SET,NULL);
        RIFFIO ckMain;
        CRiffParser Parser(m_pStream);
        Parser.EnterList(&ckMain);
        if (Parser.NextChunk(&hr))
        {
            if ((ckMain.ckid == FOURCC_LIST) && (ckMain.fccType == FOURCC_INS))
            {
                RIFFIO ckInfo;
                Parser.EnterList(&ckInfo);
                while (Parser.NextChunk(&hr))
                {
                    if ((ckInfo.ckid == FOURCC_LIST) && (ckInfo.fccType == mmioFOURCC('I','N','F','O')))
                    {
                        RIFFIO ckName;
                        Parser.EnterList(&ckName);
                        while (Parser.NextChunk(&hr))
                        {
                            if (ckName.ckid == mmioFOURCC('I','N','A','M'))
                            {
                                char szName[DMUS_MAX_NAME];
                                hr = Parser.Read(szName, min(dwNameLen,DMUS_MAX_NAME));
                                szName[min(dwNameLen,DMUS_MAX_NAME)-1] = '\0';
                                MultiByteToWideChar(CP_ACP, 0, szName, -1, pwszName, dwNameLen);
                                break;
                            }
                        }
                        Parser.LeaveList();
                        break;
                    }
                }
                Parser.LeaveList();
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    
    return hr;
}
 
//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CCollection::Cleanup

void CCollection::Cleanup()
{
    if(m_pStream)
    {
        m_pStream->Release();
        m_pStream = NULL;
    }

    if(m_pPatchTable)
    {
        delete [] m_pPatchTable;
        m_pPatchTable = NULL;
        m_dwNumPatchTableEntries = 0;
    }
    
    delete[] m_pWaveOffsetTable;
    m_pWaveOffsetTable = NULL;

    delete m_pCopyright;
    m_pCopyright = NULL;

    m_bLoaded = false;
}

//////////////////////////////////////////////////////////////////////
// CCollection::Parse

HRESULT CCollection::Parse(CRiffParser *pParser)
{   
    RIFFIO ckNext;
    HRESULT hr = S_OK;
    BOOL fJustDidInfo = false; // Hack to work around bad file, which caused a regression.
                               // Here for DX7 compatibility.
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        fJustDidInfo = false;
        switch(ckNext.ckid)
        {
        case FOURCC_VERS:
            hr = pParser->Read(&m_vVersion, sizeof(DLSVERSION));
            break;
        case FOURCC_DLID:
            hr = pParser->Read(&m_guidObject, sizeof(GUID));
            break;
        case FOURCC_COLH:
            DLSHEADER dlsHeader;
            hr = pParser->Read(&dlsHeader, sizeof(DLSHEADER));
            if(SUCCEEDED(hr))
            {
                m_dwNumPatchTableEntries = dlsHeader.cInstruments;
                m_pPatchTable = new DMUS_PATCHENTRY[m_dwNumPatchTableEntries];
                if(m_pPatchTable == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            break;
        case FOURCC_PTBL:
            hr = BuildWaveOffsetTable(pParser);
            break;
        case FOURCC_LIST:
            switch(ckNext.fccType)
            {
                case mmioFOURCC('I','N','F','O'):
                    fJustDidInfo = true;
                    m_pCopyright = new CCopyright(true);
                    if(m_pCopyright)
                    {
                        hr = m_pCopyright->Load(pParser);
                        if((m_pCopyright->m_byFlags & DMC_FOUNDICOP) == 0 &&
                           (m_pCopyright->m_byFlags & DMC_FOUNDINAM) == 0)
                        {
                            delete m_pCopyright;
                            m_pCopyright = NULL;
                            break;
                        }
                        if (m_pCopyright->m_byFlags & DMC_FOUNDINAM)
                        {
                            if (m_pCopyright->m_pwzName)
                            {
                                 StringCchCopyW(m_wszName, DMUS_MAX_NAME, m_pCopyright->m_pwzName);
                            }
                        }
                    }
                    else
                    {
                        hr =  E_OUTOFMEMORY;
                    }
                    break;
                case FOURCC_WVPL:
                {           
                    pParser->MarkPosition();
                    // We need to store the start of the wave table. This should point to the first
                    // Wave in the file. So, we take our current position.
                    m_dwWaveTableBaseAddress = (DWORD) ckNext.liPosition.QuadPart; //DM_WAVELISTCHK_OFFSET_FROM_WAVE_TBL_BASE;
                    hr = ValidateOffset(m_dwWaveTableBaseAddress);
                    break;
                }
                case FOURCC_LINS :
                    hr = BuildInstrumentOffsetTable(pParser);
                    break;
            }
            break;
        }
    }
    if (FAILED(hr) && fJustDidInfo)
    {
        hr = S_OK;
    }
    pParser->LeaveList();

    // If we return an error Parse() is expecting the caller to call Cleanup
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CCollection::BuildInstrumentOffsetTable

HRESULT CCollection::BuildInstrumentOffsetTable(CRiffParser *pParser)
{
    CDirectMusicPort::GetDLIdP(&m_dwFirstInsId, m_dwNumPatchTableEntries);
    DWORD dwCurId = m_dwFirstInsId;
    DWORD dwIndex = 0;  
    RIFFIO ckNext;  
    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        if ((ckNext.ckid == FOURCC_LIST) && (ckNext.fccType == FOURCC_INS))
        {
            RIFFIO ck;
            pParser->MarkPosition();
            DWORD dwSavedPos = (DWORD) ckNext.liPosition.QuadPart - 12; 
            pParser->EnterList(&ck);
            while (pParser->NextChunk(&hr))
            {
                if (ck.ckid == FOURCC_INSH)
                {
                    DWORD dwPatch;
                    INSTHEADER instHeader;
                    hr = pParser->Read(&instHeader, sizeof(INSTHEADER));
                    if(SUCCEEDED(hr))
                    {
                        dwPatch = instHeader.Locale.ulInstrument;
                        dwPatch |= (instHeader.Locale.ulBank) << 8;
                        dwPatch |= (instHeader.Locale.ulBank & 0x80000000);
                        if (dwIndex < m_dwNumPatchTableEntries)
                        {
                            m_pPatchTable[dwIndex].ulId = dwCurId++;
                            m_pPatchTable[dwIndex].ulOffset = dwSavedPos;
                            m_pPatchTable[dwIndex++].ulPatch = dwPatch;
                        }
                        else hr = E_FAIL;
                    }
                }
            }
            pParser->LeaveList();
        }
    }
    pParser->LeaveList();

    if(SUCCEEDED(hr) && dwIndex != m_dwNumPatchTableEntries)
    {
        hr = E_FAIL;
    }

    // If we return an error BuildInstrumentOffsetTable() is expecting the caller to call Cleanup
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CCollection::BuildWaveOffsetTable

HRESULT CCollection::BuildWaveOffsetTable(CRiffParser *pParser)
{
    POOLCUE* pTablePoolCue = NULL;
    POOLTABLE pt;
    HRESULT hr = pParser->Read(&pt, sizeof(POOLTABLE));

    if(SUCCEEDED(hr))
    {
        pTablePoolCue = new POOLCUE[pt.cCues];
        
        if(pTablePoolCue == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pParser->Read(pTablePoolCue, pt.cCues * sizeof(POOLCUE));
            if(SUCCEEDED(hr))
            {
                CDirectMusicPort::GetDLIdP(&m_dwFirstWaveId, pt.cCues);
                m_pWaveOffsetTable = new DMUS_WAVEOFFSET[pt.cCues];
                m_dwWaveOffsetTableSize = pt.cCues;
                if(m_pWaveOffsetTable)
                {
                    for(DWORD i = 0; i < pt.cCues; i++)
                    {
                        m_pWaveOffsetTable[i].dwId = m_dwFirstWaveId + i;
                        m_pWaveOffsetTable[i].dwOffset = pTablePoolCue[i].ulOffset;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
    
    if (pTablePoolCue)
    {
        delete [] pTablePoolCue;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CCollection::ExtractInstrument

HRESULT CCollection::ExtractInstrument(DWORD& dwPatch, CInstrObj** pInstrObj)
{
    // Argument validation - Debug
    assert(pInstrObj);

    // Bug 42673: If we create a collection and never call load on it m_pStream can be NULL
    // assert(m_pStream);
    if(m_pStream == NULL)
    {
        Trace(1, "ERROR: CCollection::ExtractInstrument failed. Collection is not loaded (stream is NULL)\n");
        return DMUS_E_NOT_LOADED;
    }

    HRESULT hr = E_FAIL;

    bool bFound = false;

    *pInstrObj = NULL;      

    for(DWORD dwIndex = 0; dwIndex < m_dwNumPatchTableEntries; dwIndex++)
    {
        if(dwPatch == m_pPatchTable[dwIndex].ulPatch)
        {
            bFound = true;
            hr = S_OK;
            break;
        }
    }
    
    if(bFound)
    {
        CInstrObj *pInstrument;
        try
        {
            pInstrument = new CInstrObj;
        }
        catch( ... )
        {
            pInstrument = NULL;
        }
        if(pInstrument)
        {
            LARGE_INTEGER li;
            li.QuadPart = m_pPatchTable[dwIndex].ulOffset;
            // Seek to beginning of the instrument list chunk in DLS file
            hr = m_pStream->Seek(li,STREAM_SEEK_SET,NULL);
            CRiffParser Parser(m_pStream);
            RIFFIO ckNext;
            Parser.EnterList(&ckNext);
            if (Parser.NextChunk(&hr))
            {
                if ((ckNext.ckid == FOURCC_LIST) && (ckNext.fccType == FOURCC_INS))
                {
                    hr = pInstrument->Load(m_pPatchTable[dwIndex].ulId, &Parser, this);
                    if(SUCCEEDED(hr))
                    {
                        hr = pInstrument->FixupWaveRefs();
                    }
                }
            }
            if(FAILED(hr))
            {
                delete pInstrument;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        } 
        if (SUCCEEDED(hr))
        {
            *pInstrObj = pInstrument;
        }
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////
// CCollection::ExtractWave

HRESULT CCollection::ExtractWave(DWORD dwId, CWaveObj** ppWaveObj)
{
    // Assumption validation - Debug
    assert(ppWaveObj);

#ifdef DBG
    if(dwId >= CDirectMusicPortDownload::sNextDLId)
    {
        assert(FALSE);
    }
#endif

    assert(m_pStream);

    HRESULT hr;
    DWORD dwOffset  = m_dwWaveTableBaseAddress
                      + m_pWaveOffsetTable[dwId - m_dwFirstWaveId].dwOffset; 
//                    - DM_WAVELISTCHK_OFFSET_FROM_WAVE_FORMTYPE;
    
    if (dwOffset < m_dwWaveTableBaseAddress) {
        hr = DMUS_E_INVALIDOFFSET;
    }
    else {
        hr = ValidateOffset(dwOffset);
    }

    if(FAILED(hr))
    {
        return hr;
    }

    LARGE_INTEGER li;
    li.QuadPart = dwOffset;
    // Seek to beginning of the wave list chunk in DLS file
    hr = m_pStream->Seek(li,STREAM_SEEK_SET,NULL);

    if(SUCCEEDED(hr))
    {
        try
        {
            *ppWaveObj = new CWaveObj;
        }
        catch( ... )
        {
            *ppWaveObj = NULL;
        }

        if(*ppWaveObj)
        {
            CRiffParser Parser(m_pStream);
            RIFFIO ckNext;
            Parser.EnterList(&ckNext);
            if (Parser.NextChunk(&hr))
            {
                if ((ckNext.ckid == FOURCC_LIST) && ((ckNext.fccType == FOURCC_wave) || (ckNext.fccType == mmioFOURCC('W', 'A', 'V', 'E'))))
                {
                    hr = (*ppWaveObj)->Load(dwId, &Parser, this);
                }
            }
            if(FAILED(hr))
            {
                delete *ppWaveObj;
                *ppWaveObj = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CCollection::FindInstrument

STDMETHODIMP
CCollection::FindInstrument(DWORD dwPatch,CInstrument** ppDMInst)
{
    assert(ppDMInst);

    HRESULT hr = S_FALSE;

    for (CInstrument* pDMInst = m_InstList.GetHead();
        pDMInst; pDMInst = pDMInst->GetNext())
    {
        if (pDMInst->m_dwOriginalPatch == dwPatch)
        {
            *ppDMInst = pDMInst;
            (*ppDMInst)->AddRef();
            hr = S_OK;
            break;
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CCollection::AddInstrument

STDMETHODIMP
CCollection::AddInstrument(CInstrument* pDMInst)
{
    assert(pDMInst);

    m_InstList.AddTail(pDMInst);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CCollection::RemoveInstrument

STDMETHODIMP
CCollection::RemoveInstrument(CInstrument* pDMInst)
{
    assert(pDMInst);

    EnterCriticalSection(&m_CDMCollCriticalSection);
    m_InstList.Remove(pDMInst);
    LeaveCriticalSection(&m_CDMCollCriticalSection);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmcount.h ===
//
// dmcount.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn 
//

#ifndef DMCOUNT_H
#define DMCOUNT_H

class CWaveID : public AListItem
{
friend class CInstrObj;
friend class CWaveObj;

public:
	CWaveID(DWORD dwId) {m_dwId = dwId;} 
	~CWaveID() {}

	CWaveID* GetNext(){return(CWaveID*)AListItem::GetNext();}

private:
	DWORD	m_dwId;
};

class CWaveIDList : public AList
{
public:
	CWaveIDList(){}
	~CWaveIDList() 
	{
		while(!IsEmpty())
		{
			CWaveID* pWaveID = RemoveHead();
			delete pWaveID;
		}
	}

    CWaveID* GetHead(){return(CWaveID *)AList::GetHead();}
	CWaveID* GetItem(LONG lIndex){return(CWaveID*)AList::GetItem(lIndex);}
    CWaveID* RemoveHead(){return(CWaveID *)AList::RemoveHead();}
	void Remove(CWaveID* pWaveID){AList::Remove((AListItem *)pWaveID);}
	void AddTail(CWaveID* pWaveID){AList::AddTail((AListItem *)pWaveID);}
};

#endif // #ifndef DMCOUNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmcrchk.cpp ===
//
// dmcrck.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay

#include "dmusicc.h"
#include "alist.h"
#include "dlsstrm.h"
#include "debug.h"
#include "dmcrchk.h"

//////////////////////////////////////////////////////////////////////
// Class CCopyright

//////////////////////////////////////////////////////////////////////
// CCopyright::Load

HRESULT CCopyright::Load(CRiffParser *pParser)
{
	HRESULT hr = S_OK;
    RIFFIO ckNext;

    pParser->EnterList(&ckNext);
	while(pParser->NextChunk(&hr))
	{
		switch(ckNext.ckid)
		{
        case mmioFOURCC('I','C','O','P'):
			m_byFlags |= DMC_FOUNDICOP;
			// We want to make sure we only allocate extra bytes if the chunk size is 
			// greater then the DMUS_MIN_DATA_SIZE
			if(pParser->GetChunk()->cksize < DMUS_MIN_DATA_SIZE)
			{
				m_dwExtraChunkData = 0;
			}
			else
			{
				m_dwExtraChunkData = pParser->GetChunk()->cksize - DMUS_MIN_DATA_SIZE;
			}
			
			m_pDMCopyright  = (DMUS_COPYRIGHT*) 
				new BYTE[CHUNK_ALIGN(sizeof(DMUS_COPYRIGHT) + m_dwExtraChunkData)];

			if(m_pDMCopyright)
			{
				hr = pParser->Read(m_pDMCopyright->byCopyright, pParser->GetChunk()->cksize);
				m_pDMCopyright->cbSize = pParser->GetChunk()->cksize;
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
			break;
		case mmioFOURCC('I','N','A','M'):
		    if(m_byFlags & DMC_LOADNAME)
		    {
			    m_pwzName = new WCHAR[DMUS_MAX_NAME];
			    if(m_pwzName)
			    {
				    char szName[DMUS_MAX_NAME];
				    hr = pParser->Read(szName,sizeof(szName));
				    if(SUCCEEDED(hr))
				    {
					    MultiByteToWideChar(CP_ACP, 0, szName, -1, m_pwzName, DMUS_MAX_NAME);
				    }
			    }
			    else
			    {
				    hr = E_OUTOFMEMORY;
			    }
		    }
            m_byFlags |= DMC_FOUNDINAM;
		    break;
	    }
    }
    pParser->LeaveList();
	if(FAILED(hr))
	{
		Cleanup();
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CCopyright::Write

HRESULT CCopyright::Write(void* pv, DWORD* dwCurOffset)
{
	// Argument validation
	assert(pv);
	assert(dwCurOffset);

	HRESULT hr = S_OK;

	CopyMemory(pv, (void *)m_pDMCopyright, Size());
	*dwCurOffset += Size();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmcrchk.h ===
//
// dmcrchk.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.


#ifndef DMCRCHK_H
#define DMCRCHK_H

#define	DMC_FOUNDICOP (1 << 0)
#define	DMC_FOUNDINAM (1 << 1)
#define	DMC_LOADNAME  (1 << 2)

#include "dmusici.h"

#ifndef CHUNK_ALIGN
#define SIZE_ALIGN	sizeof(BYTE *)
#define CHUNK_ALIGN(x) (((x) + SIZE_ALIGN - 1) & ~(SIZE_ALIGN - 1))
#endif

class CRiffParser;

class CCopyright
{
friend class CCollection;
friend class CInstrObj;
friend class CWaveObj;

public:
	CCopyright(bool bLoadName = false) : 
	m_byFlags(0),
	m_pwzName(NULL),
	m_pDMCopyright(NULL), 
	m_dwExtraChunkData(0){if(bLoadName){m_byFlags |= DMC_LOADNAME;};}

	~CCopyright(){Cleanup();}

	HRESULT Load(CRiffParser *pParser);
	HRESULT Write(void* pv, DWORD* dwOffset);

	DWORD Size() {return CHUNK_ALIGN(sizeof(DMUS_COPYRIGHT) + m_dwExtraChunkData);}
	DWORD Count()
	{
		// Return the number of Offset Table entries needed during a call to Write
		return 1;
	}

private:
	void Cleanup()
	{
		delete [] (BYTE *)m_pDMCopyright;
		delete [] m_pwzName;
	}

private:
	BYTE			m_byFlags;
	WCHAR*			m_pwzName;
	DMUS_COPYRIGHT*	m_pDMCopyright;
	DWORD			m_dwExtraChunkData;
};


#endif // #ifndef DMCRCHK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmdlinst.cpp ===
//
// dmdlinst.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn
//

#include "debug.h"
#include "dmusicc.h"
#include "dmdlinst.h"
#include "validate.h"

//////////////////////////////////////////////////////////////////////
// Class CDownloadedInstrument

CDownloadedInstrument::~CDownloadedInstrument() 
{
    // If pDMDLInst->m_ppDownloadedBuffers == NULL we have been unloaded
    if(m_pPort && m_ppDownloadedBuffers != NULL)
    {
        Trace(0, "WARNING: DirectMusicDownloadedInstrument final release before unloaded!\n");
        m_cRef++; // This is ugly but it prevents a circular reference see Unload's implementation
        
        if (m_cDLRef >= 1)
        {
            // we need to remove ourselves from the port collection, or else we leave the port in an invalid state
            m_cDLRef = 1;

            if (FAILED(m_pPort->UnloadInstrument(this)))
            {
                TraceI(0, "~CDownloadedInstrument- UnloadInstrument failed\n");
            }
        }
    }

    if (m_ppDownloadedBuffers) delete [] m_ppDownloadedBuffers;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDownloadedInstrument::QueryInterface

STDMETHODIMP CDownloadedInstrument::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicDownloadedInstrument::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


    if(iid == IID_IUnknown || iid == IID_IDirectMusicDownloadedInstrument)
    {
        *ppv = static_cast<IDirectMusicDownloadedInstrument*>(this);
    } 
    else if(iid == IID_IDirectMusicDownloadedInstrumentPrivate) 
    {
        *ppv = static_cast<IDirectMusicDownloadedInstrumentPrivate*>(this);
    } 
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDownloadedInstrument::AddRef

STDMETHODIMP_(ULONG) CDownloadedInstrument::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDownloadedInstrument::Release

STDMETHODIMP_(ULONG) CDownloadedInstrument::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmdload.cpp ===
//
// dmdload.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn
//
// @doc EXTERNAL 
//

#include "debug.h"
#include <objbase.h>
#include "dmusicp.h"
#include "dmdload.h"
#include "validate.h"

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::CDownloadBuffer

CDownloadBuffer::CDownloadBuffer() : 
m_DLHandle(NULL),
m_dwDLId(0xFFFFFFFF),
m_pvBuffer(NULL),
m_dwSize(0),
m_lDownloadCount(0),
m_cRef(1)
{
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::~CDownloadBuffer

CDownloadBuffer::~CDownloadBuffer()
{
	// If assert fires we have not unloaded from a port; this is a problem
	// It should never happen since the download code will have a reference
	assert(m_lDownloadCount == 0);

	delete [] m_pvBuffer;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::QueryInterface

STDMETHODIMP CDownloadBuffer::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicDownload::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


	if(iid == IID_IUnknown || iid == IID_IDirectMusicDownload)
	{
        *ppv = static_cast<IDirectMusicDownload*>(this);
    } 
	else if(iid == IID_IDirectMusicDownloadPrivate)
	{
		*ppv = static_cast<IDirectMusicDownloadPrivate*>(this);
	}
	else
	{
        *ppv = NULL;
        return E_NOINTERFACE;
	}

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::AddRef

STDMETHODIMP_(ULONG) CDownloadBuffer::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::Release

STDMETHODIMP_(ULONG) CDownloadBuffer::Release()
{
    if(!InterlockedDecrement(&m_cRef))
	{
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicDownload

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::GetBuffer

/*

@method HRESULT | IDirectMusicDownload | GetBuffer | 
Returns a pointer to a buffer which contains
the data buffer managed by the <i IDirectMusicDownload>
inteface. Authoring tools 
that create instruments and download them
directly to the synthesizer use this method to access the
memory and write the instrument definition into it.  

@rdesc Returned codes include:

@flag S_OK | Success.
@flag DMUS_E_BUFFERNOTAVAILABLE | Buffer is not available, probably
because data has already been downloaded to DLS device. 
@flag E_POINTER | Invalid pointer.

@xref <i IDirectMusicDownload>, <i IDirectMusicPortDownload>, 
<om IDirectMusicPortDownload::GetBuffer>

*/

STDMETHODIMP CDownloadBuffer::GetBuffer(
    void** ppvBuffer,   // @parm Pointer to store address of data buffer in.
    DWORD* pdwSize)     // @parm Size of the returned buffer, in bytes.
{
	// Argument validation
	V_INAME(IDirectMusicDownload::GetBuffer);
	V_PTRPTR_WRITE(ppvBuffer);
	V_PTR_WRITE(pdwSize, DWORD);

	if(IsDownloaded() == S_OK)
	{
		return DMUS_E_BUFFERNOTAVAILABLE;
	}

	*ppvBuffer = ((LPBYTE)m_pvBuffer) + m_dwHeaderSize;
	*pdwSize = m_dwSize;
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::SetBuffer

HRESULT CDownloadBuffer::SetBuffer(void* pvBuffer, DWORD dwHeaderSize, DWORD dwSize)
{
	// Assumption validation - Debug
	// We should never have a non-NULL pvBuffer and a size of zero
#ifdef DBG
	if(pvBuffer && dwSize == 0)
	{
		assert(false);
	}
#endif

	m_pvBuffer = pvBuffer;
    m_dwHeaderSize = dwHeaderSize;
	m_dwSize = dwSize;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::GetBuffer

HRESULT CDownloadBuffer::GetBuffer(void** ppvBuffer)
{
	// Argument validation - Debug
	assert(ppvBuffer);

	*ppvBuffer = ((LPBYTE)m_pvBuffer) + m_dwHeaderSize;
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::GetHeader

HRESULT CDownloadBuffer::GetHeader(void** ppvHeader, DWORD *pdwHeaderSize)
{
	// Argument validation - Debug
	assert(ppvHeader);
    assert(pdwHeaderSize);

	*ppvHeader = m_pvBuffer;
    *pdwHeaderSize = m_dwHeaderSize;
    
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmdlinst.h ===
//
// dmdlinst.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn
//
// @doc EXTERNAL

#ifndef DMDLINST_H
#define DMDLINST_H

#include "alist.h"

// IDirectMusicDownloadedInstrumentPrivate
//

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownloadedInstrumentPrivate 
DECLARE_INTERFACE_(IDirectMusicDownloadedInstrumentPrivate, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectMusicDownloadedInstrumentPrivate
    // No methods at this time
};

DEFINE_GUID(IID_IDirectMusicDownloadedInstrumentPrivate, 0x94feda0, 0xa3bb, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

/*
@interface IDirectMusicDownloadedInstrument | 
<i IDirectMusicDownloadedInstrument> is used to keep 
track of a downloaded instrument. It should be
used exactly twice:

First, when an instrument is downloaded via a call to 
<om IDirectMusicPort::DownloadInstrument>, 
<i IDirectMusicDownloadedInstrument> is returned apon
successful download. 

Second, when unloading the instrument via a call to
<om IDirectMusicPort::UnloadInstrument>.

Once the instrument has been unloaded, 
<i IDirectMusicDownloadedInstrument> becomes invalid.

@base public | IUnknown

@xref <i IDirectMusicCollection>, <i IDirectMusicPort>,
<i IDirectMusicInstrument>, 
<om IDirectMusicPort::DownloadInstrument>,
<om IDirectMusicPort::UnloadInstrument>

@ex Download the instrument, then unload it (fat lot of
good that will do us, but, hey, this is only a demo). 
Notice that
<p pDLInstrument> is never AddRef'd or Release'd. These are
automatically managed by the calls to Download and Unload. | 

    HRESULT myFickleDownload(   
        IDirectMusicInstrument* pInstrument,
        IDirectMusicPort *pPort,
        DWORD dwPatch)

    {
        HRESULT hr;
        IDirectMusicDownloadedInstrument * pDLInstrument;
        hr = pPort->DownloadInstrument(pInstrument, &pDLInstrument, NULL, 0);
        if (SUCCEEDED(hr))
        {
            pPort->UnloadInstrument(pDLInstrument);
        }
        return hr;
    }
*/


class CDownloadedInstrument : public IDirectMusicDownloadedInstrument,
    public IDirectMusicDownloadedInstrumentPrivate, public AListItem
{
friend class CDirectMusicPortDownload;

public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicDownloadedInstrument
    //
    // No methods at this time

private:
    friend class CDirectMusicPortDownload;

    CDownloadedInstrument() 
    {
        m_ppDownloadedBuffers = NULL;
        m_pPort = NULL;
        m_dwDLTotal = 0;
        m_dwDLSoFar = 0;
        m_cRef = 1;
        m_cDLRef = 0;
    }
    ~CDownloadedInstrument();

    CDownloadedInstrument* GetNext() {return (CDownloadedInstrument*)AListItem::GetNext();}

private:
    IDirectMusicDownload**   m_ppDownloadedBuffers;  // Array of downloaded buffers, starting with the instrument, 
                                                // and then one for each wave.
    IDirectMusicPort*        m_pPort;           // Port that this 
    DWORD                    m_dwDLTotal;       // Number of objects in the array pointed to by m_pDLList.
    DWORD                    m_dwDLSoFar;       // How many have been downloaded so far.
    long                     m_cRef;
    long                     m_cDLRef;
};

class CDLInstrumentList : public AList
{
private:
    friend class CDirectMusicPortDownload;

    CDLInstrumentList(){}
    ~CDLInstrumentList() 
    {
        while (!IsEmpty())
        {
            CDownloadedInstrument* pDMDLInst = RemoveHead();
            if (pDMDLInst)
            {
                pDMDLInst->Release();
            }
        }
    }

    CDownloadedInstrument* GetHead(){return (CDownloadedInstrument*)AList::GetHead();}
    CDownloadedInstrument* GetItem(LONG lIndex){return (CDownloadedInstrument*)AList::GetItem(lIndex);}
    CDownloadedInstrument* RemoveHead(){return (CDownloadedInstrument*)AList::RemoveHead();}
    void Remove(CDownloadedInstrument* pDMDLInst){AList::Remove((AListItem*)pDMDLInst);}
    void AddTail(CDownloadedInstrument* pDMDLInst){AList::AddTail((AListItem*)pDMDLInst);}
};

#endif // #ifndef DMDLINST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmdload.h ===
//
// dmdload.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn
// @doc EXTERNAL
//

#include "..\shared\validate.h"

#ifndef DMDLOAD_H
#define DMDLOAD_H

/*
@interface IDirectMusicDownload | 
The <i IDirectMusicDownload> interface represents
a contiguous memory chunk, used for downloading to a
DLS synth port. 

The <i IDirectMusicDownload> interface and its contained
memory chunk are always created with a call to
<om IDirectMusicPortDownload::AllocateBuffer>.
The memory can then be accessed via the one method
that <i IDirectMusicDownload> provides: 
<om IDirectMusicDownload::GetBuffer>.

@base public | IUnknown

@meth HRESULT | GetBuffer | Returns the memory segment and its size.

@xref <i IDirectMusic>, <i IDirectMusicPortDownload>,
<om IDirectMusicPortDownload::AllocateBuffer>

*/

// IDirectMusicDownloadPrivate
//
#undef  INTERFACE
#define INTERFACE  IDirectMusicDownloadPrivate 
DECLARE_INTERFACE_(IDirectMusicDownloadPrivate, IUnknown)
{
	// IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	// IDirectMusicDownloadPrivate
    STDMETHOD(SetBuffer)			(THIS_ void* pvBuffer, DWORD dwHeaderSize, DWORD dwSize) PURE;
	STDMETHOD(GetBuffer)			(THIS_ void** ppvBuffer) PURE;
    STDMETHOD(GetHeader)            (THIS_ void** ppvHeader, DWORD* dwHeaderSize) PURE;
};

DEFINE_GUID(IID_IDirectMusicDownloadPrivate, 0x19e55e60, 0xa146, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

class CDownloadBuffer : public IDirectMusicDownload, public IDirectMusicDownloadPrivate, public AListItem
{
friend class CDirectMusicPort;
friend class CDirectMusicSynthPort;
friend class CDirectMusicPortDownload;
friend class CDLBufferList;
friend HRESULT CALLBACK FreeHandle(HANDLE hHandle, HANDLE hUserData);
friend void writewave(IDirectMusicDownload* pDMDownload);
friend void writeinstrument(IDirectMusicDownload* pDMDownload);

public:
    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IDirectMusicDownload
    STDMETHODIMP GetBuffer(void** ppvBuffer, DWORD* pdwSize);

	// IDirectMusicDownloadPrivate
    STDMETHODIMP SetBuffer(void* pvBuffer, DWORD dwHeaderSize, DWORD dwSize);
	STDMETHODIMP GetBuffer(void** ppvBuffer);
    STDMETHODIMP GetHeader(void** ppvHeader, DWORD *pdwHeaderSize);

private:	
    // Class
    CDownloadBuffer();
    ~CDownloadBuffer();

	CDownloadBuffer* GetNext(){return(CDownloadBuffer*)AListItem::GetNext();}

	long IncDownloadCount()
	{
		// Should never be less than zero
		assert(m_lDownloadCount >= 0);
		
		InterlockedIncrement(&m_lDownloadCount);
		
		return(m_lDownloadCount);
	}
	
	long DecDownloadCount()
	{
		InterlockedDecrement(&m_lDownloadCount);
		
		// Should never be less than zero		
		assert(m_lDownloadCount >= 0);
		
		return(m_lDownloadCount);
	}
	
	HRESULT IsDownloaded()
	{
		// Should never be less than zero
		assert(m_lDownloadCount >= 0);
		
		return(m_DLHandle ? S_OK : S_FALSE);
	}

private:
	HANDLE					m_DLHandle;
	DWORD					m_dwDLId;
	void*					m_pvBuffer;
    DWORD                   m_dwHeaderSize;
	DWORD					m_dwSize;
	long					m_lDownloadCount;
	long					m_cRef;
};

class CDLBufferList : public AList
{
friend class CDirectMusicPortDownload;
friend class CDownloadedInstrument;
friend class CDirectMusicSynthPort;
friend class CDirectMusicPort;

private:
	CDLBufferList(){}
	~CDLBufferList()
	{
		while(!IsEmpty())
		{
			CDownloadBuffer* pDownload = RemoveHead();
			delete pDownload;
		}
	}

    CDownloadBuffer* GetHead(){return (CDownloadBuffer *)AList::GetHead();}
	CDownloadBuffer* GetItem(LONG lIndex){return (CDownloadBuffer*)AList::GetItem(lIndex);}
    CDownloadBuffer* RemoveHead(){return(CDownloadBuffer *)AList::RemoveHead();}
	void Remove(CDownloadBuffer* pDownload){AList::Remove((AListItem *)pDownload);}
	void AddTail(CDownloadBuffer* pDownload){AList::AddTail((AListItem *)pDownload);}
};

#endif // #ifndef DMDLOAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmdll.cpp ===
//
// dmdll.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Dll entry points as well IDirectMusicFactory & 
// IDirectMusicCollectionFactory implementations
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <objbase.h>
#include "debug.h"
#include "debug.h"

#include "oledll.h"

#include "dmusicp.h"
#include "dmcollec.h"
#include "dminstru.h"
#include "dswave.h"
#include "dmvoice.h"
#include "verinfo.h"

//////////////////////////////////////////////////////////////////////
// Globals

// Version information for our class
//
TCHAR g_szFriendlyName[]    = TEXT("DirectMusic");
TCHAR g_szVerIndProgID[]    = TEXT("Microsoft.DirectMusic");
TCHAR g_szProgID[]          = TEXT("Microsoft.DirectMusic.1");

TCHAR g_szCollFriendlyName[]    = TEXT("DirectMusicCollection");
TCHAR g_szCollVerIndProgID[]    = TEXT("Microsoft.DirectMusicCollection");
TCHAR g_szCollProgID[]          = TEXT("Microsoft.DirectMusicCollection.1");

// Thunk helper dll
const char g_szDM32[]      = "DMusic32.dll";
const char g_szKsUser[]    = "KsUser.dll";

// Dll's hModule
//
HMODULE g_hModule = NULL;
HMODULE g_hModuleDM32 = NULL;
HMODULE g_hModuleKsUser = NULL;

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;

// Flags DMI_F_xxx from dmusicp.h
//
DWORD g_fFlags;

static char const g_szDoEmulation[] = "DoEmulation";

//////////////////////////////////////////////////////////////////////
// CDirectMusicFactory::QueryInterface

HRESULT __stdcall
CDirectMusicFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(IDirectMusicFactory::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicFactory::AddRef

ULONG __stdcall
CDirectMusicFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicFactory::Release

ULONG __stdcall
CDirectMusicFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicFactory::CreateInstance

HRESULT __stdcall
CDirectMusicFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

//
// Removed since we depend on dsound timebomb
//
#if 0
	#pragma message( "Remove time bomb for final!" )
    SYSTEMTIME  st;

    GetSystemTime( &st );

   if ((st.wYear > DX_EXPIRE_YEAR) || 
      ((st.wYear == DX_EXPIRE_YEAR) && (st.wMonth > DX_EXPIRE_MONTH)) ||
      ((st.wYear == DX_EXPIRE_YEAR) && (st.wMonth == DX_EXPIRE_MONTH) && (st.wDay > DX_EXPIRE_DAY)))
   {
        if (0 == MessageBox(NULL, DX_EXPIRE_TEXT,
                            "Microsoft DirectMusic", MB_OK))
        {
            Trace(-1, DX_EXPIRE_TEXT "\n");
            *ppv = NULL;
        }

        return E_FAIL;
    }
#endif

    CDirectMusic *pDM = new CDirectMusic;
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    // Do initialiazation
    //
    hr = pDM->Init();
    if (!SUCCEEDED(hr)) {
        delete pDM;
        return hr;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicFactory::LockServer

HRESULT __stdcall
CDirectMusicFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCollectionFactory::QueryInterface

STDMETHODIMP CDirectMusicCollectionFactory::QueryInterface(const IID &iid,
														   void **ppv)
{
    V_INAME(IDirectMusicCollectionFactory::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


	if(iid == IID_IUnknown || iid == IID_IClassFactory) 
	{
        *ppv = static_cast<IClassFactory*>(this);
    } 
	else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCollectionFactory::AddRef

STDMETHODIMP_(ULONG) CDirectMusicCollectionFactory::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCollectionFactory::Release

STDMETHODIMP_(ULONG) CDirectMusicCollectionFactory::Release()
{
    if(!InterlockedDecrement(&m_cRef)) 
	{
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCollectionFactory::CreateInstance

STDMETHODIMP CDirectMusicCollectionFactory::CreateInstance(IUnknown* pUnknownOuter,
														   const IID& iid,
														   void** ppv)
{
    // Argument validation - Debug
    assert(pUnknownOuter == NULL);

	if(pUnknownOuter) 
    {
         return CLASS_E_NOAGGREGATION;
    }

    CCollection *pDMC;
    try
    {
        pDMC = new CCollection;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if(pDMC == NULL) 
	{
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pDMC->QueryInterface(iid, ppv);
    
    pDMC->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCollectionFactory::LockServer

STDMETHODIMP CDirectMusicCollectionFactory::LockServer(BOOL bLock)
{
    if(bLock) 
	{
        InterlockedIncrement(&g_cLock);
    } 
	else 
	{
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
	IUnknown* pIUnknown = NULL;

    if(clsid == CLSID_DirectMusic)
    {

		pIUnknown = static_cast<IUnknown*> (new CDirectMusicFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicCollection) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicCollectionFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
    pIUnknown->Release();

    return hr;
}

//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusic,
                     g_szFriendlyName,
                     g_szVerIndProgID,
                     g_szProgID);

    UnregisterServer(CLSID_DirectMusicCollection,
                     g_szCollFriendlyName,
                     g_szCollVerIndProgID,
                     g_szCollProgID);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectMusic,
                   g_szFriendlyName,
                   g_szVerIndProgID,
                   g_szProgID);

	RegisterServer(g_hModule,
				   CLSID_DirectMusicCollection,
				   g_szCollFriendlyName,
				   g_szCollVerIndProgID,
				   g_szCollProgID);
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// LoadDmusic32 - Load if not already loaded
BOOL LoadDmusic32()
{
    if (g_hModuleDM32)
    {
        return TRUE;
    }

    g_hModuleDM32 = (HMODULE)LoadLibrary(g_szDM32);
    if (NULL == g_hModuleDM32)
    {
        Trace(-1, "Could not LoadLibrary Dmusic32.dll. WinMM devices will not be enumerated.\n");
        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
// LoadKsUser - Load if not already loaded
BOOL LoadKsUser()
{
    if (g_hModuleKsUser)
    {
        return TRUE;
    }

    g_hModuleKsUser = (HMODULE)LoadLibrary(g_szKsUser);
    if (NULL == g_hModuleKsUser)
    {
        Trace(-1, "Could not LoadLibrary KSUser.dll. WDM devices will not be enumerated.\n");
        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    OSVERSIONINFO osvi;
    static int nReferenceCount = 0;
    static BOOL fCSInitialized = FALSE;

#ifdef DBG
    if (dwReason < nReasons)
    {
        TraceI(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        TraceI(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (++nReferenceCount == 1)
            {
                #ifdef DBG
                    DebugInit();
                #endif

                if (!DisableThreadLibraryCalls(hModule))
                {
                    TraceI(0, "DisableThreadLibraryCalls failed.\n");
                }

                g_hModule = hModule;

                osvi.dwOSVersionInfoSize = sizeof(osvi);
                GetVersionEx(&osvi);
                if (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
                {
                    TraceI(0, "Running on Win9x\n");
                    g_fFlags |= DMI_F_WIN9X;
                }

                try 
                {
				    InitializeCriticalSection(&CDirectMusicPortDownload::sDMDLCriticalSection);
                    InitializeCriticalSection(&CDirectSoundWave::sDSWaveCritSect);
                    InitializeCriticalSection(&CDirectMusicVoice::m_csVST);
                }
                catch( ... )
                {
                    return FALSE;
                }
                fCSInitialized = TRUE;
            }

            break;

        case DLL_PROCESS_DETACH:
            if (--nReferenceCount == 0)
            {
                if (fCSInitialized)
                {
				    DeleteCriticalSection(&CDirectMusicPortDownload::sDMDLCriticalSection);
                    DeleteCriticalSection(&CDirectSoundWave::sDSWaveCritSect);
                    DeleteCriticalSection(&CDirectMusicVoice::m_csVST);
                    fCSInitialized = FALSE;
                }

                TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
                // Assert if we still have some objects hanging around
                assert(g_cComponent == 0);
                assert(g_cLock == 0);
            }
            break;
            
    }
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmdsclk.cpp ===
//
// DMDSClk.CPP
//
// Copyright (c) 1997-2001 Microsoft Corporation
//
// DirectSound buffer tweaked master clock
//

#include <objbase.h>
#include "debug.h"
#include <mmsystem.h>

#include "dmusicp.h"
#include "debug.h"
#include "validate.h"
#include "resource.h"

class CDsClock : public IReferenceClock, public IDirectSoundSinkSync
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie);
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie);
    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // IDirectSoundSinkSync
    //
    STDMETHODIMP SetClockOffset(LONGLONG llClockOffset);

    // Class
    //
    CDsClock();
    ~CDsClock();
    HRESULT Init(CMasterClock *pMasterClock);

private:
    long m_cRef;
    IReferenceClock         *m_pHardwareClock;
    LONGLONG                m_llOffset;
};



static HRESULT CreateDsClock(IReferenceClock **ppClock, CMasterClock *pMasterClock);

// AddDsClocks
//
HRESULT AddDsClocks(CMasterClock *pMasterClock)
{
    CLOCKENTRY ce;

    ZeroMemory(&ce, sizeof(ce));
    ce.cc.dwSize = sizeof(ce.cc);
    ce.cc.guidClock = GUID_DsClock;
    ce.cc.ctType = DMUS_CLOCK_SYSTEM;
    ce.cc.dwFlags = 0;
    ce.pfnGetInstance = CreateDsClock;

    int cch;
    int cchMax = sizeof(ce.cc.wszDescription) / sizeof(WCHAR);

    char sz[sizeof(ce.cc.wszDescription) / sizeof(WCHAR)];
    cch = LoadString(g_hModule,
                     IDS_DSOUNDCLOCK,
                     sz,
                     sizeof(sz));
    if (cch)
    {
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            sz,
            -1,
            ce.cc.wszDescription,
            sizeof(ce.cc.wszDescription));
    }
    else
    {
        *ce.cc.wszDescription = 0;
    }

    return pMasterClock->AddClock(&ce);
}

static HRESULT CreateDsClock(IReferenceClock **ppClock, CMasterClock *pMasterClock)
{
    TraceI(3, "Creating Ds clock\n");

    CDsClock *pClock = new CDsClock();
    if (pClock == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pClock->Init(pMasterClock);
    if (FAILED(hr))
    {
        delete pClock;
        return hr;
    }

    hr = pClock->QueryInterface(IID_IReferenceClock, (void**)ppClock);
    pClock->Release();

    return hr;
}

CDsClock::CDsClock() :
    m_cRef(1),
    m_pHardwareClock(NULL),
    m_llOffset(0)
{
}

CDsClock::~CDsClock()
{
    RELEASE(m_pHardwareClock);
}

// CDsClock::QueryInterface
//
// Standard COM implementation
//
STDMETHODIMP CDsClock::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusic::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else if (iid == IID_IDirectSoundSinkSync)
    {
        *ppv = static_cast<IDirectSoundSinkSync*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

// CDsClock::AddRef
//
STDMETHODIMP_(ULONG) CDsClock::AddRef()
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

// CDsClock::Release
//
STDMETHODIMP_(ULONG) CDsClock::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CDsClock::Init
//
HRESULT CDsClock::Init(CMasterClock *pMasterClock)
{
    // Get the 'real' clock
    //
    return pMasterClock->CreateDefaultMasterClock(&m_pHardwareClock);
}

// CDsClock::SetClockOffset
//
STDMETHODIMP
CDsClock::SetClockOffset(LONGLONG llOffset)
{
    m_llOffset += llOffset;

    return S_OK;
}

STDMETHODIMP
CDsClock::GetTime(REFERENCE_TIME *pTime)
{
    HRESULT hr;

    assert(m_pHardwareClock);

    hr = m_pHardwareClock->GetTime(pTime);

    if (SUCCEEDED(hr))
    {
        *pTime += m_llOffset;
    }

    return hr;
}

STDMETHODIMP
CDsClock::AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDsClock::AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDsClock::Unadvise(DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmeport.h ===
//
// dmeport.h
//
// Emulation for MME drivers on NT
//
// Copyright (c) 1997-2000 Microsoft Corporation
// 
#ifndef _DMEPORT_
#define _DMEPORT_

#include "..\shared\dmusiccp.h"

#define SYSEX_SIZE            4096
#define SYSEX_BUFFERS         8

typedef HRESULT (*PORTENUMCB)(
    LPVOID pInstance,          // @parm Callback instance data
    DMUS_PORTCAPS &dmpc,                              
    PORTTYPE pt,                              
    int idxDev,                // @parm The WinMM or SysAudio device ID of this driver
    int idxPin,                // @parm The Pin ID of the device or -1 if the device is a legacy device
    int idxNode,               // @parm The node ID of the device's synth node (unused for legacy)
    HKEY hkPortsRoot);         // @parm Where port information is stored in the registry


extern HRESULT EnumLegacyDevices(CDirectMusic *pDM, PORTENUMCB pCB);
extern HRESULT CreateCDirectMusicEmulatePort(
    PORTENTRY *pPE,
    CDirectMusic *pDM,
    DMUS_PORTPARAMS8 *pPortParams,
    IDirectMusicPort8 **pPort);
    
extern HRESULT MMRESULTToHRESULT(
    MMRESULT mmr);

struct QUEUED_SYSEX_EVENT : public QUEUED_EVENT
{
    BYTE            m_abRest[sizeof(MIDIHDR) + SYSEX_SIZE - sizeof(DWORD)];
};

#define EVENT_F_MIDIHDR 0x00000001  // This event starts with a MIDIHDR
    

#include "tpool.h"

#define THREAD_KILL_TIMEOUT         5000
#define THREAD_WORK_BUFFER_SIZE     4096

#define QWORD_ALIGN(x) (((x) + 7) & ~7)

#define MIDI_CHANNELS               16

// 10 ms in 100ns units
//
#define FIXED_LEGACY_LATENCY_OFFSET (10L * 10L * 1000L)

struct DMQUEUEDEVENT
{
    DMQUEUEDEVENT           *m_pNext;
    DMEVENT                 m_event;
    LPBYTE                  m_pbEvent;
};

class CEmulateLatencyClock : public IReferenceClock
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime,  
				    REFERENCE_TIME streamTime,
				    HANDLE hEvent,            
				    DWORD * pdwAdviseCookie); 

    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime,
					REFERENCE_TIME periodTime,
					HANDLE hSemaphore,   
					DWORD * pdwAdviseCookie);

    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // Class
    //
    CEmulateLatencyClock(IReferenceClock *pMasterClock);
    ~CEmulateLatencyClock();

    void Close();

private:
    long m_cRef;
    IReferenceClock *m_pMasterClock;
};

// Struct for holding a property item supported by the synth
//

class CDirectMusicEmulatePort;

typedef HRESULT (CDirectMusicEmulatePort::*GENPROPHANDLER)(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);

#define GENPROP_F_STATIC                0x00000000
#define GENPROP_F_FNHANDLER             0x00000001


struct GENERICPROPERTY
{
    const GUID *pguidPropertySet;       // What property set?
    ULONG       ulId;                   // What item?

    ULONG       ulSupported;            // Get/Set flags for QuerySupported

    ULONG       ulFlags;                // GENPROP_F_xxx

    LPVOID      pPropertyData;          // Data to be returned
    ULONG       cbPropertyData;         // and its size    

    GENPROPHANDLER pfnHandler;          // Handler fn iff GENPROP_F_FNHANDLER
};


class CDirectMusicEmulatePort : 
    public IDirectMusicPort8, 
    public IDirectMusicThru,
    public IDirectMusicPortPrivate, 
    public IKsControl
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPort
    //
    STDMETHODIMP PlayBuffer(LPDIRECTMUSICBUFFER pBuffer);
    STDMETHODIMP SetReadNotificationHandle(HANDLE hEvent);
    STDMETHODIMP Read(LPDIRECTMUSICBUFFER pBuffer);
	STDMETHODIMP DownloadInstrument(IDirectMusicInstrument*,
                                            IDirectMusicDownloadedInstrument**,
                                            DMUS_NOTERANGE*,
                                            DWORD);
	STDMETHODIMP UnloadInstrument(IDirectMusicDownloadedInstrument*);
    
    STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
    STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    STDMETHODIMP Compact();
    STDMETHODIMP GetCaps(LPDMUS_PORTCAPS pPortCaps);
	STDMETHODIMP DeviceIoControl(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, 
	                                 LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNumChannelGroups(DWORD dwNumChannelGroups);
    STDMETHODIMP GetNumChannelGroups(LPDWORD pdwNumChannelGroups);
    STDMETHODIMP Activate(BOOL fActivate);
    STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
    STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize);
        
    // IDirectMusicThru
    STDMETHODIMP ThruChannel(DWORD dwSourceChannelGroup, 
                             DWORD dwSourceChannel, 
                             DWORD dwDestinationChannelGroup,
                             DWORD dwDestinationChannel,
                             LPDIRECTMUSICPORT pDestinationPort);
    
    // IDirectMusicPortP
    //
    STDMETHODIMP DownloadWave(
         IN  IDirectSoundWave *pWave,               
         OUT IDirectSoundDownloadedWaveP **ppWave,
         IN  REFERENCE_TIME rtStartHint
        );
        
    STDMETHODIMP UnloadWave(
         IN  IDirectSoundDownloadedWaveP *pWave      
        );
            
    STDMETHODIMP AllocVoice(
         IN  IDirectSoundDownloadedWaveP *pWave,     
         IN  DWORD dwChannel,                       
         IN  DWORD dwChannelGroup,                  
         IN  REFERENCE_TIME rtStart,                     
         IN  SAMPLE_TIME stLoopStart,
         IN  SAMPLE_TIME stLoopEnd,         
         OUT IDirectMusicVoiceP **ppVoice            
        );        
        
    STDMETHODIMP AssignChannelToBuses(
         IN DWORD dwChannelGroup,
         IN DWORD dwChannel,
         IN LPDWORD pdwBusses,
         IN DWORD cBussCount
        );        

    STDMETHODIMP SetSink(
        IN IDirectSoundConnect *pSinkConnect
       );        

    STDMETHODIMP GetSink(
        IN IDirectSoundConnect **ppSinkConnect
       );        

    // IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    // IDirectMusicPortPrivate
    STDMETHODIMP Close();

    STDMETHODIMP StartVoice(          
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart,
         DWORD dwDLId,
         LONG prPitch,
         LONG vrVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd);

    STDMETHODIMP StopVoice(
         DWORD dwVoiceID,
         REFERENCE_TIME rtStop);
    
    STDMETHODIMP GetVoiceState(
        DWORD dwVoice[], 
        DWORD cbVoice,
        DMUS_VOICE_STATE VoiceState[]);
         
    STDMETHODIMP Refresh(
        DWORD dwDownloadID,
        DWORD dwFlags);
         
    // Class
    //
    CDirectMusicEmulatePort(PORTENTRY *pPE, CDirectMusic *pDM);
    virtual ~CDirectMusicEmulatePort();
    virtual HRESULT Init(LPDMUS_PORTPARAMS pPortParams);

    virtual HRESULT LegacyCaps(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer) PURE;

    
   

private:
    long                    m_cRef;
    IDirectMusicPortNotify  *m_pNotify;
    DMUS_PORTCAPS           m_dmpc;
    long                    m_lActivated;    

    CEmulateLatencyClock    *m_pLatencyClock;
    
protected:    
    CDirectMusic            *m_pDM;
    UINT                    m_id;
    IReferenceClock         *m_pMasterClock;

private:
    static GENERICPROPERTY m_aProperty[];
    static const int m_nProperty;
    static GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);
    
private:
    HRESULT InitializeClock();
    
protected:
    virtual HRESULT ActivateLegacyDevice(BOOL fActivate) PURE;
};

class CDirectMusicEmulateInPort : public CDirectMusicEmulatePort
{
    friend static VOID CALLBACK midiInProc(
        HMIDIIN             hMidiIn, 
        UINT                wMsg, 
        DWORD_PTR           dwInstance, 
        DWORD_PTR           dwParam1, 
        DWORD_PTR           dwParam2);

public:
    // Class
    //
    CDirectMusicEmulateInPort(PORTENTRY *pPE, CDirectMusic *pDM);
    ~CDirectMusicEmulateInPort();

    HRESULT LegacyCaps(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);
    HRESULT Init(LPDMUS_PORTPARAMS pPortParams);

    DWORD InputWorker();
    STDMETHODIMP Close();
    HRESULT ActivateLegacyDevice(BOOL fActivate);
    
    // IDirectMusicPort
    //    
    STDMETHODIMP SetReadNotificationHandle(HANDLE hEvent);
    STDMETHODIMP Read(LPDIRECTMUSICBUFFER pBuffer);

    // IDirectMusicThru
    //
    STDMETHODIMP ThruChannel(DWORD dwSourceChannelGroup, 
                             DWORD dwSourceChannel, 
                             DWORD dwDestinationChannelGroup,
                             DWORD dwDestinationChannel,
                             LPDIRECTMUSICPORT pDestinationPort);

private:
    HANDLE                  m_hAppEvent;

    EVENT_POOL              m_FreeEvents;        
    EVENT_QUEUE             m_ReadEvents;

    IDirectMusicBuffer      *m_pThruBuffer;
    LPDMUS_THRU_CHANNEL     m_pThruMap;

    
    CRITICAL_SECTION        m_csEventQueues;
    BOOL                    m_fCSInitialized;

    HMIDIIN                 m_hmi;
    REFERENCE_TIME          m_rtStart;

    BOOL                    m_fFlushing;
    LONG                    m_lPendingSysExBuffers;
    QUEUED_SYSEX_EVENT      m_SysExBuffers[SYSEX_BUFFERS];
    
    // Clock sync stuff
    //
    bool                    m_fSyncToMaster;        // Need to sync to master clock
    LONGLONG                m_lTimeOffset;          // Time difference
    LONGLONG                m_lBaseTimeOffset;      // Time difference when input is started
    IReferenceClock        *m_pPCClock;             // PortCls clock

private:
    HRESULT PostSysExBuffers();
    HRESULT FlushSysExBuffers();
    void Callback(UINT wMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
    BOOL RecordShortEvent(DWORD_PTR dwMessage,  REFERENCE_TIME rtTime);
    BOOL RecordSysEx(DWORD_PTR dwMessage,  REFERENCE_TIME rtTime);
    void QueueEvent(QUEUED_EVENT *pEvent);
    void ThruEvent(DMEVENT *pEvent);

    // Clock sync stuff
    //
    void SyncClocks();
};

class CDirectMusicEmulateOutPort : public CDirectMusicEmulatePort
{
    friend static VOID CALLBACK midiOutProc(
        HMIDIOUT            hMidiOut, 
        UINT                wMsg, 
        DWORD_PTR           dwInstance, 
        DWORD_PTR           dwParam1, 
        DWORD_PTR           dwParam2);

    friend static VOID CALLBACK timerProc(
        UINT                    uTimerID, 
        UINT                    uMsg, 
        DWORD_PTR               dwUser, 
        DWORD_PTR               dw1, 
        DWORD_PTR               dw2);

public:
    CDirectMusicEmulateOutPort(PORTENTRY *pPE, CDirectMusic *pDM);
    ~CDirectMusicEmulateOutPort();

    HRESULT LegacyCaps(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);
    HRESULT Init(LPDMUS_PORTPARAMS pPortParams);

    STDMETHODIMP Close();
    HRESULT ActivateLegacyDevice(BOOL fActivate);
    

private:
    STDMETHODIMP PlayBuffer(LPDIRECTMUSICBUFFER pBuffer);
    void Callback(UINT wMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
    void Timer();
    void SetNextTimer();
    
private:
    HMIDIOUT                m_hmo;
    CRITICAL_SECTION        m_csPlayQueue;
    DMQUEUEDEVENT          *m_pPlayQueue;
    CPool<DMQUEUEDEVENT>    m_poolEvents;
    LONG                    m_lTimerId;
    BOOL                    m_fClosing;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmeport.cpp ===
//
// dmeport.cpp
//
// Emulation for MME drivers on NT
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Open device
// PlayBuffer
// Activate
// Close: Close device
// InputWorkerDataReady
// Take out share stuff
//
// 
#include <windows.h>
#include <mmsystem.h>
#include <regstr.h>
#include <string.h>

#include "debug.h"
#include "dmusicp.h"
#include "dmeport.h"
#include "resource.h"

//
// Registry location of legacy driver port definitions
const char cszPortsRoot[] = REGSTR_PATH_PRIVATEPROPERTIES "\\Midi\\Ports";

// String to tag emulated ports
// 
static WCHAR wszEmulated[128];

#define MAXCCH(x) (sizeof(x) / sizeof(x[0]))

//------------------------------------------------------------------------------
//
// EnumLegacyDevices
//
// Update the port list with legacy devices enumerated via 
// the WinMM MIDI API.
//
//
HRESULT EnumLegacyDevices(
    LPVOID              pInstance,
    PORTENUMCB          cb)                          
{
    MIDIOUTCAPS         moc;
    MIDIINCAPS          mic;
    int                 idxDev;
    int                 cDev;
    UINT                cAdded;
    HRESULT             hr;
    HKEY                hkPortsRoot;
    DMUS_PORTCAPS       dmpc;

    if (wszEmulated[0] == 0)
    {
        char    sz[128];
        int     cch;

        cch = LoadString(g_hModule,
                         IDS_EMULATED,
                         sz,
                         sizeof(sz));
        if (cch)
        {
            MultiByteToWideChar(
                CP_OEMCP,
                0,
                sz,
                -1,
                wszEmulated,
                MAXCCH(wszEmulated));
        }
    }

    // Initialize caps with stuff that doesn't change
    //
    ZeroMemory(&dmpc, sizeof(dmpc));
    dmpc.dwSize = sizeof(dmpc);
    dmpc.dwMaxChannelGroups = 1;


    // Try to open the port registry key. We will continue even if this fails and use
    // non-persistent GUID's.
    //
    if (RegCreateKey(HKEY_LOCAL_MACHINE, cszPortsRoot, &hkPortsRoot))
    {
        hkPortsRoot = NULL;
    }

    cAdded = 0;
    
    // MIDI output devices
    //
    // Starts at -1 == MIDI mapper
    //
    cDev = (int)midiOutGetNumDevs();
    for (idxDev = -1; idxDev < cDev; ++idxDev)
    {
        if (midiOutGetDevCaps((UINT)idxDev, &moc, sizeof(moc)))
        {
            continue;
        }

        WCHAR wsz[128];

        MultiByteToWideChar(
            CP_OEMCP,
            0,
            moc.szPname,
            -1,
            wsz,
            MAXCCH(wsz));

        wcscat(wsz, wszEmulated);

        wcsncpy(dmpc.wszDescription, wsz, MAXCCH(dmpc.wszDescription) - 1);
        dmpc.wszDescription[MAXCCH(dmpc.wszDescription) - 1] = 0;

        dmpc.dwClass = DMUS_PC_OUTPUTCLASS;
        dmpc.dwType  = DMUS_PORT_WINMM_DRIVER;
        dmpc.dwFlags = DMUS_PC_SHAREABLE;

        if (moc.wTechnology == MOD_MIDIPORT)
        {
            dmpc.dwFlags |= DMUS_PC_EXTERNAL;
        }
        
        hr = (*cb)(pInstance,
                   dmpc,
                   ptLegacyDevice,
                   idxDev,
                   -1,
                   -1,          
                   hkPortsRoot);
        if (SUCCEEDED(hr))
        {
            ++cAdded;
        }
        else if (hr == E_OUTOFMEMORY)
        {
            return hr;
        }
    }

    // MIDI input devices
    //
    // NOTE: Starts at 0, no input mapper
    //
    cDev = (int)midiInGetNumDevs();
    for (idxDev = 0; idxDev < cDev; ++idxDev)
    {
        if (midiInGetDevCaps((UINT)idxDev, &mic, sizeof(mic)))
        {
            continue;
        }
                   
        WCHAR wsz[128];

        MultiByteToWideChar(
            CP_OEMCP,
            0,
            mic.szPname,
            -1,
            wsz,
            MAXCCH(wsz));

        wcscat(wsz, wszEmulated);

        wcsncpy(dmpc.wszDescription, wsz, MAXCCH(dmpc.wszDescription) - 1);
        dmpc.wszDescription[MAXCCH(dmpc.wszDescription) - 1] = 0;

        
        dmpc.dwClass = DMUS_PC_INPUTCLASS;
        dmpc.dwFlags = DMUS_PC_EXTERNAL;
        
        hr = (*cb)(pInstance,
                   dmpc,
                   ptLegacyDevice,
                   idxDev,
                   -1,        // PinID -1 flags as legacy device
                   -1,
                   hkPortsRoot);
        if (SUCCEEDED(hr))
        {
            ++cAdded;
        }
        else if (hr == E_OUTOFMEMORY)
        {
            return hr;
        }
    }

    if (hkPortsRoot)
    {
        RegCloseKey(hkPortsRoot);
    }

    return cAdded ? S_OK : S_FALSE;
}

//------------------------------------------------------------------------------
//
// CreateCDirectMusicEmulatePort
//
//
HRESULT CreateCDirectMusicEmulatePort(
    PORTENTRY                   *pPE,
    CDirectMusic                *pDM,
    DMUS_PORTPARAMS8            *pPortParams,
    IDirectMusicPort8           **pPort)
{
    HRESULT hr;

    *pPort = NULL;
    
    CDirectMusicEmulatePort *pEPort;
    
    if (pPE->pc.dwClass == DMUS_PC_OUTPUTCLASS)
    {
        pEPort = new CDirectMusicEmulateOutPort(pPE, pDM);
    }
    else
    {
        pEPort = new CDirectMusicEmulateInPort(pPE, pDM);
    }
    if (NULL == pEPort)
    {
        return E_OUTOFMEMORY;
    }

    hr = pEPort->Init(pPortParams);
    if (!SUCCEEDED(hr))
    {
        delete pEPort;
        return hr;
    }
    
    *pPort = pEPort;
    
    return hr;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::CDirectMusicEmulatePort
//
//
CDirectMusicEmulatePort::CDirectMusicEmulatePort(
                                                 PORTENTRY *pPE,    
                                                 CDirectMusic *pDM) :
                                                 m_cRef(1)
                                                 ,m_id(pPE->idxDevice)
                                                 ,m_pDM(pDM)
                                                 ,m_pLatencyClock(NULL)
                                                 ,m_pMasterClock(NULL)
                                                 ,m_lActivated(0)
                                                 ,m_dmpc(pPE->pc)
{
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::~CDirectMusicEmulatePort
//
//
CDirectMusicEmulatePort::~CDirectMusicEmulatePort()
{
    Close();
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::Init
//
//

// Flags we recognize 
//
#define DMUS_ALL_FLAGS (DMUS_PORTPARAMS_VOICES |            \
                        DMUS_PORTPARAMS_CHANNELGROUPS |     \
                        DMUS_PORTPARAMS_AUDIOCHANNELS |     \
                        DMUS_PORTPARAMS_SAMPLERATE |        \
                        DMUS_PORTPARAMS_EFFECTS |           \
                        DMUS_PORTPARAMS_SHARE)

// Of those, which do we actually look at?
//
#define DMUS_SUP_FLAGS (DMUS_PORTPARAMS_CHANNELGROUPS)

HRESULT CDirectMusicEmulatePort::Init(
    LPDMUS_PORTPARAMS   pPortParams)
{
    HRESULT             hr;
    BOOL                fChangedParms;

    // Get, but don't hold onto, the notification interface
    //
    hr = m_pDM->QueryInterface(IID_IDirectMusicPortNotify, (void**)&m_pNotify);
    if (FAILED(hr))
    {
        return hr;
    }
    m_pNotify->Release();

    // Munge the portparams to match what we support.
    //
    fChangedParms = FALSE;
    if (pPortParams->dwValidParams & ~DMUS_ALL_FLAGS) 
    {
        Trace(0, "Undefined flags in port parameters: %08X\n", pPortParams->dwValidParams & ~DMUS_ALL_FLAGS);
        // Flags set we don't recognize.
        //
        pPortParams->dwValidParams &= DMUS_ALL_FLAGS;
        fChangedParms = TRUE;
    }

    // We recognize these flags but don't support them.
    //
    if (pPortParams->dwValidParams & ~DMUS_SUP_FLAGS)
    {
        pPortParams->dwValidParams &= DMUS_SUP_FLAGS;
        fChangedParms = TRUE;
    }

    // Channel groups better be one.
    //
    if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
    {
        if (pPortParams->dwChannelGroups != 1)
        {
            pPortParams->dwChannelGroups = 1;
            fChangedParms = TRUE;
        }
    }
    else
    {
        pPortParams->dwValidParams |= DMUS_PORTPARAMS_CHANNELGROUPS;
        pPortParams->dwChannelGroups = 1;
    }

    // Set up the master clock and our latency clock
    //
    hr = InitializeClock();
    if (FAILED(hr))
    {
        return hr;
    }

    return fChangedParms ? S_FALSE : S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::InititalizeClock
//
//
HRESULT CDirectMusicEmulatePort::InitializeClock()
{
    HRESULT             hr;
    GUID                guidMasterClock;

    hr = m_pDM->GetMasterClock(&guidMasterClock, &m_pMasterClock);
    if (FAILED(hr))
    {
        return hr;
    }

    m_pLatencyClock = new CEmulateLatencyClock(m_pMasterClock);

    if (NULL == m_pLatencyClock)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::QueryInterface
//
//
STDMETHODIMP CDirectMusicEmulatePort::QueryInterface(
    const IID       &iid,
    void            **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicPort)
    {
        *ppv = static_cast<IDirectMusicPort*>(this);
    }
    else if (iid == IID_IDirectMusicPort8)
    {
        *ppv = static_cast<IDirectMusicPort8*>(this);
    }
    else if (iid == IID_IDirectMusicPortPrivate)
    {
        *ppv = static_cast<IDirectMusicPortPrivate*>(this);
    }
    else if (iid == IID_IKsControl)
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else if (iid == IID_IDirectMusicThru)
    {
        *ppv = static_cast<IDirectMusicThru*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::AddRef
//
//
STDMETHODIMP_(ULONG) CDirectMusicEmulatePort::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::Release
//
//
STDMETHODIMP_(ULONG) CDirectMusicEmulatePort::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        if (m_pNotify)
        {
            m_pNotify->NotifyFinalRelease(static_cast<IDirectMusicPort*>(this));
        }
        
        delete this;
        return 0;
    }

    return m_cRef;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::Compact
//
//
STDMETHODIMP CDirectMusicEmulatePort::Compact()
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetCaps
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetCaps(
    LPDMUS_PORTCAPS pPortCaps)
{
    V_INAME(IDirectMusicPort::GetCaps);
    V_STRUCTPTR_WRITE(pPortCaps, DMUS_PORTCAPS);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    CopyMemory(pPortCaps, &m_dmpc, sizeof(DMUS_PORTCAPS));

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::DeviceIoControl
//
//
STDMETHODIMP CDirectMusicEmulatePort::DeviceIoControl(
    DWORD           dwIoControlCode, 
    LPVOID          lpInBuffer, 
    DWORD           nInBufferSize, 
    LPVOID          lpOutBuffer, 
    DWORD           nOutBufferSize, 
    LPDWORD         lpBytesReturned, 
    LPOVERLAPPED    lpOverlapped)
{
    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::SetNumChannelGroups
//
//
STDMETHODIMP CDirectMusicEmulatePort::SetNumChannelGroups(
    DWORD           dwNumChannelGroups)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (dwNumChannelGroups != 1)
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::PlayBuffer 
//
//
STDMETHODIMP CDirectMusicEmulatePort::PlayBuffer(
    IDirectMusicBuffer *pIBuffer)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetNumChannelGroups
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetNumChannelGroups(
    LPDWORD     pdwChannelGroups)
{
    V_INAME(IDirectMusicPort::GetNumChannelGroups);
    V_PTR_WRITE(pdwChannelGroups, DWORD);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    *pdwChannelGroups = 1;
    
    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::Read
//
//
STDMETHODIMP CDirectMusicEmulatePort::Read(
    IDirectMusicBuffer *pIBuffer)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::SetReadNotificationHandle
//
//
STDMETHODIMP CDirectMusicEmulatePort::SetReadNotificationHandle(
    HANDLE hEvent)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::DownloadInstrument 
//
//
STDMETHODIMP CDirectMusicEmulatePort::DownloadInstrument(
    IDirectMusicInstrument              *pInstrument,
    IDirectMusicDownloadedInstrument    **pDownloadedInstrument,
    DMUS_NOTERANGE                      *pRange,
    DWORD                               dw)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::UnloadInstrument 
//
//
STDMETHODIMP CDirectMusicEmulatePort::UnloadInstrument(
    IDirectMusicDownloadedInstrument *pDownloadedInstrument)
{
    V_INAME(IDirectMusicPort::UnloadInstrument);
    V_INTERFACE(pDownloadedInstrument);

    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetLatencyClock
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetLatencyClock(
    IReferenceClock **ppClock)
{
    V_INAME(IDirectMusicPort::GetLatencyClock);
    V_PTRPTR_WRITE(ppClock);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    m_pLatencyClock->AddRef();
    *ppClock = m_pLatencyClock;
    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetRunningStats
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetRunningStats(
    LPDMUS_SYNTHSTATS pStats)
{
    V_INAME(IDirectMusicPort::GetRunningStats);
    V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS);

    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::Activate
//
//
STDMETHODIMP CDirectMusicEmulatePort::Activate(
    BOOL    fActivate)
{
	V_INAME(IDirectMusicPort::Activate);
    
    HRESULT hr;
	
	if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate)
    {
        if (InterlockedExchange(&m_lActivated, 1)) 
        {
            Trace(0, "Activate: Already active\n");
            // Already activated
            //
            return S_FALSE;
        }    

        hr = ActivateLegacyDevice(TRUE);
        if (FAILED(hr))
        {
            Trace(0, "Activate: Activate Failed with 0x%08X\n", hr);
            InterlockedExchange(&m_lActivated, 0);
        }
    }
    else
    {
        if (InterlockedExchange(&m_lActivated, 0) == 0)
        {
            Trace(0, "Activate: Already inactive\n");
            // Already deactivated
            //
            return S_FALSE;
        }

        hr = ActivateLegacyDevice(FALSE);
        if (FAILED(hr))
        {
            Trace(0, "Activate: Deactivate Failed with 0x%08X\n", hr);
            InterlockedExchange(&m_lActivated, 1);
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::SetChannelPriority
//
//
STDMETHODIMP CDirectMusicEmulatePort::SetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    DWORD dwPriority)
{
    return E_NOTIMPL;
}
    
//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetChannelPriority
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    LPDWORD pdwPriority)
{
    return E_NOTIMPL;
}    


//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::Close
//
//
STDMETHODIMP CDirectMusicEmulatePort::Close()
{
    Activate(FALSE);

    if (m_pLatencyClock)
    {
        m_pLatencyClock->Close();
        m_pLatencyClock->Release();
        m_pLatencyClock = NULL;
    }

    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }

    m_pDM = NULL;
    m_pNotify = NULL;

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::StartVoice
//
//
STDMETHODIMP CDirectMusicEmulatePort::StartVoice(          
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart,
         DWORD dwDLId,
         LONG prPitch,
         LONG vrVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd)
{
    return E_NOTIMPL;
}    

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::StopVoice
//
//
STDMETHODIMP CDirectMusicEmulatePort::StopVoice(
     DWORD dwVoiceID,
     REFERENCE_TIME rtStop)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetVoiceState
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetVoiceState(   
     DWORD dwVoice[], 
     DWORD cbVoice,
     DMUS_VOICE_STATE VoiceState[])
{
    return E_NOTIMPL;
}
    
//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::Refresh
//
//
STDMETHODIMP CDirectMusicEmulatePort::Refresh(
     DWORD dwDownloadID,
     DWORD dwFlags)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::ThruChannel
//
//
STDMETHODIMP CDirectMusicEmulatePort::ThruChannel(
    DWORD               dwSourceChannelGroup, 
    DWORD               dwSourceChannel, 
    DWORD               dwDestinationChannelGroup,
    DWORD               dwDestinationChannel,
    LPDIRECTMUSICPORT   pDestinationPort)
{
    V_INAME(IDirectMusicPort::Thru);
    V_INTERFACE_OPT(pDestinationPort);

    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::SetDirectSound
//
//
STDMETHODIMP CDirectMusicEmulatePort::SetDirectSound(
    LPDIRECTSOUND           pDirectSound, 
    LPDIRECTSOUNDBUFFER     pDirectSoundBuffer)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetFormat
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetFormat(
    LPWAVEFORMATEX  pWaveFormatEx, 
    LPDWORD         pdwWaveFormatExSize, 
    LPDWORD         pdwBufferSize)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::DownloadWave
//
//
STDMETHODIMP CDirectMusicEmulatePort::DownloadWave(
         IN  IDirectSoundWave *pWave,               
         OUT IDirectSoundDownloadedWaveP **ppWave,
         IN  REFERENCE_TIME rtStartHint)    
{                                   
    V_INAME(IDirectMusicPort::DownloadWave);
    V_INTERFACE(pWave);
	V_PTRPTR_WRITE(ppWave);

    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::UnloadWave
//
//
STDMETHODIMP CDirectMusicEmulatePort::UnloadWave(
    IN  IDirectSoundDownloadedWaveP *pWave)
{
    V_INAME(IDirectMusicPort::UnloadWave);
    V_INTERFACE(pWave);

    return E_NOTIMPL;
}

            
//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::AllocVoice
//
//
STDMETHODIMP CDirectMusicEmulatePort::AllocVoice(
	 IDirectSoundDownloadedWaveP *pWave,     
	 DWORD dwChannel,                       
	 DWORD dwChannelGroup,                  
	 REFERENCE_TIME rtStart,                     
	 SAMPLE_TIME stLoopStart,
	 SAMPLE_TIME stLoopEnd,         
	 IDirectMusicVoiceP **ppVoice)
{
    V_INAME(IDirectMusicPort::AllocVoice);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppVoice);

    return E_NOTIMPL;
}        

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::AssignChannelToBuses
//
//
STDMETHODIMP CDirectMusicEmulatePort::AssignChannelToBuses(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwBuses,
    DWORD cBusCount)
{
    return E_NOTIMPL;
}        

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::SetSink
//
//
STDMETHODIMP CDirectMusicEmulatePort::SetSink(
    IDirectSoundConnect *pSinkConnect)
{
    return E_NOTIMPL;
}        

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetSink
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetSink(
    IDirectSoundConnect **ppSinkConnect)
{
    return E_NOTIMPL;
}        

GENERICPROPERTY CDirectMusicEmulatePort::m_aProperty[] = 
{      
    { &GUID_DMUS_PROP_LegacyCaps,           // Set
      0,                                    // Item
      KSPROPERTY_SUPPORT_GET,               // KS support flags
      GENPROP_F_FNHANDLER,                  // GENPROP flags
      NULL, 0,                              // static data and size
      CDirectMusicEmulatePort::LegacyCaps   // Handler
    }
};

const int CDirectMusicEmulatePort::m_nProperty = sizeof(m_aProperty) / sizeof(m_aProperty[0]);

//------------------------------------------------------------------------------
// 
// CDirectMusicEmulatePort::FindPropertyItem
//
// Given a GUID and an item ID, find the associated property item in the synth's
// table of SYNPROPERTY's.
//
// Returns a pointer to the entry or NULL if the item was not found.
//
GENERICPROPERTY *CDirectMusicEmulatePort::FindPropertyItem(REFGUID rguid, ULONG ulId)
{
    GENERICPROPERTY *pPropertyItem = &m_aProperty[0];
    GENERICPROPERTY *pEndOfItems = pPropertyItem + m_nProperty;

    for (; pPropertyItem != pEndOfItems; pPropertyItem++)
    {
        if (*pPropertyItem->pguidPropertySet == rguid && 
             pPropertyItem->ulId == ulId)
        {
            return pPropertyItem;
        }
    }

    return NULL;
}

#define KS_VALID_FLAGS (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET| KSPROPERTY_TYPE_BASICSUPPORT)

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::KsProperty
//
//
STDMETHODIMP CDirectMusicEmulatePort::KsProperty(
    PKSPROPERTY pPropertyIn, ULONG ulPropertyLength,
    LPVOID pvPropertyData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pPropertyIn, ulPropertyLength);
    V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    DWORD dwFlags = pPropertyIn->Flags & KS_VALID_FLAGS;
    if ((dwFlags == 0) || (dwFlags == (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET)))
    {
    }

    GENERICPROPERTY *pProperty = FindPropertyItem(pPropertyIn->Set, pPropertyIn->Id);

    if (pProperty == NULL)
    {
        return DMUS_E_UNKNOWN_PROPERTY;
    }

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_GET))
            {
                return DMUS_E_GET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                *pulBytesReturned = ulDataLength;
                return (this->*pfn)(pPropertyIn->Id, KSPROPERTY_SUPPORT_GET, pvPropertyData, pulBytesReturned);
            }
    
            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pvPropertyData, pProperty->pPropertyData, ulDataLength);
            *pulBytesReturned = ulDataLength;

            return S_OK;

        case KSPROPERTY_TYPE_SET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_SET))
            {
                return DMUS_E_SET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                return (this->*pfn)(pPropertyIn->Id, KSPROPERTY_SUPPORT_SET, pvPropertyData, &ulDataLength);
            }

            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pProperty->pPropertyData, pvPropertyData, ulDataLength);

            return S_OK;
            

        case KSPROPERTY_TYPE_BASICSUPPORT:
            if (pProperty == NULL)
            {
                return DMUS_E_UNKNOWN_PROPERTY;
            }

            // XXX Find out what convention is for this!!
            //
            if (ulDataLength < sizeof(DWORD))
            {
                return E_INVALIDARG;
            }

            *(LPDWORD)pvPropertyData = pProperty->ulSupported;    
            *pulBytesReturned = sizeof(DWORD);
            
            return S_OK;
    }

    Trace(-1, "%s: Flags must contain one of\n"
              "\tKSPROPERTY_TYPE_SET, KSPROPERTY_TYPE_GET, or KSPROPERTY_TYPE_BASICSUPPORT\n");
    return E_INVALIDARG;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::KsMethod
//
//
STDMETHODIMP CDirectMusicEmulatePort::KsMethod(
    PKSMETHOD pMethod, ULONG ulMethodLength,
    LPVOID pvMethodData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynth::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    return DMUS_E_UNKNOWN_PROPERTY;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::KsEvent
//
//
STDMETHODIMP CDirectMusicEmulatePort::KsEvent(
    PKSEVENT pEvent, ULONG ulEventLength,
    LPVOID pvEventData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    return DMUS_E_UNKNOWN_PROPERTY;
}


//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::CEmulateLatencyClock
//
//
CEmulateLatencyClock::CEmulateLatencyClock(IReferenceClock *pMasterClock) :
   m_cRef(1),
   m_pMasterClock(pMasterClock)
{
    pMasterClock->AddRef();
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::~CEmulateLatencyClock
//
//
CEmulateLatencyClock::~CEmulateLatencyClock()
{
    Close();
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::QueryInterface
//
//
STDMETHODIMP CEmulateLatencyClock::QueryInterface(
    const IID &iid,
    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::AddRef
//
//
STDMETHODIMP_(ULONG) CEmulateLatencyClock::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::Release
//
//
STDMETHODIMP_(ULONG) CEmulateLatencyClock::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::GetTime
//
//
STDMETHODIMP
CEmulateLatencyClock::GetTime(REFERENCE_TIME *pTime)
{
    REFERENCE_TIME rt;

    V_INAME(IReferenceClock::GetTime);
    V_PTR_WRITE(pTime, REFERENCE_TIME);

    if (!m_pMasterClock)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }
    
    HRESULT hr = m_pMasterClock->GetTime(&rt);

    rt += 3 * FIXED_LEGACY_LATENCY_OFFSET;          // Default : 10 ms
    *pTime = rt;

    return hr;
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::AdviseTime
//
//
STDMETHODIMP CEmulateLatencyClock::AdviseTime(
    REFERENCE_TIME baseTime,  
    REFERENCE_TIME streamTime,
    HANDLE hEvent,            
    DWORD * pdwAdviseCookie)
{
    return DMUS_E_UNKNOWN_PROPERTY;
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::AdvisePeriodic
//
//
STDMETHODIMP CEmulateLatencyClock::AdvisePeriodic(
    REFERENCE_TIME startTime,
    REFERENCE_TIME periodTime,
    HANDLE hSemaphore,   
    DWORD * pdwAdviseCookie)
{
    return DMUS_E_UNKNOWN_PROPERTY;
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::Unadvise
//
//
STDMETHODIMP CEmulateLatencyClock::Unadvise(
    DWORD dwAdviseCookie)
{
    return DMUS_E_UNKNOWN_PROPERTY;
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::Close
//
//
void CEmulateLatencyClock::Close()
{
    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::MMRESULTToHRESULT
//
//
HRESULT MMRESULTToHRESULT(
    MMRESULT mmr)
{
    switch (mmr)
    {
    case MMSYSERR_NOERROR:
        return S_OK;

    case MMSYSERR_ALLOCATED:
        return DMUS_E_DEVICE_IN_USE;

    case MIDIERR_BADOPENMODE:
        return DMUS_E_ALREADYOPEN;

    case MMSYSERR_NOMEM:
        return E_OUTOFMEMORY;
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmecport.cpp ===
//
// dmecport.cpp
//
// Emulated Capture port (NT)
//
// Copyright (c) 1997-2000 Microsoft Corporation
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#include <windows.h>
#include <mmsystem.h>
#include <regstr.h>

#include "debug.h"
#include "dmusicp.h"
#include "dmeport.h"

#define IS_STATUS_BYTE(x)     ((x) & 0x80)
#define IS_CHANNEL_MSG(x)     (((x) & 0xF0) != 0xF0)
#define IS_SYSEX(x)           ((x) == 0xF0)

static VOID CALLBACK midiInProc(
    HMIDIIN                 hMidiIn, 
    UINT                    wMsg, 
    DWORD_PTR               dwInstance, 
    DWORD_PTR               dwParam1,     
    DWORD_PTR               dwParam2);

static inline REFERENCE_TIME MsToRefTime(REFERENCE_TIME ms)
{
    return ms * 10 * 1000L;
}

static unsigned g_cbChanMsg[16] =
{
    0, 0, 0, 0, 0, 0, 0, 0, /* Running status */
    3, 3, 3, 3, 2, 2, 3, 0
};

static unsigned g_cbSysCommData[16] =
{
    1, 2, 3, 2, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1
};

//------------------------------------------------------------------------------
// 
// CDirectMusicEmulateInPort::CDirectMusicEmulateInPort
//
//
CDirectMusicEmulateInPort::CDirectMusicEmulateInPort(
                                                 PORTENTRY *pPE,    
                                                 CDirectMusic *pDM) :
                                                 CDirectMusicEmulatePort(pPE, pDM)
                                                 ,m_pThruBuffer(NULL)
                                                 ,m_pThruMap(NULL)
                                                 ,m_fCSInitialized(FALSE)
                                                 ,m_hAppEvent(NULL)
                                                 ,m_hmi(NULL)
                                                 ,m_lPendingSysExBuffers(0)
                                                 ,m_fFlushing(FALSE)
                                                 ,m_fSyncToMaster(TRUE)
                                                 ,m_lTimeOffset(0)
                                                 ,m_lBaseTimeOffset(0)
                                                 ,m_pPCClock(NULL)
{
}

//------------------------------------------------------------------------------
// 
// CDirectMusicEmulateInPort::~CDirectMusicEmulateInPort
//
//
CDirectMusicEmulateInPort::~CDirectMusicEmulateInPort()
{
    Close();    
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::Init
//
//
HRESULT CDirectMusicEmulateInPort::Init(
    LPDMUS_PORTPARAMS pPortParams)
{
    HRESULT         hr;

    hr = CDirectMusicEmulatePort::Init(pPortParams);
    if (FAILED(hr))
    {
        return hr;
    }

    // Allocate thru map for 16 channels, since we only have one channel group
    // Initialize to no thruing (destination port is NULL).
    //
    m_pThruMap = new DMUS_THRU_CHANNEL[MIDI_CHANNELS];
    HRESULT hrTemp = HRFromP(m_pThruMap);
    if (FAILED(hrTemp))
    {
    	return hrTemp;
    }
    
    ZeroMemory(m_pThruMap, MIDI_CHANNELS * sizeof(DMUS_THRU_CHANNEL));

    // Create thruing buffer
    //
    DMUS_BUFFERDESC dmbd;
    ZeroMemory(&dmbd, sizeof(dmbd));
    dmbd.dwSize = sizeof(dmbd);
    dmbd.cbBuffer = 4096;               // XXX Where should we get this???

    hrTemp = m_pDM->CreateMusicBuffer(&dmbd, &m_pThruBuffer, NULL);
    if (FAILED(hrTemp))
    {
        Trace(0, "Failed to create thruing buffer\n");
        return hrTemp;
    }

    // Initialize cs to protect event queues.
    //
    // Unfortunately this can throw an exception if out of memory.
    //
    _try 
    {
        InitializeCriticalSection(&m_csEventQueues);
    } 
    _except (EXCEPTION_EXECUTE_HANDLER) 
    {
        return E_OUTOFMEMORY;
    }
    
    m_fCSInitialized = TRUE;

    // If we have WDM ports, then the default master clock will be the
    // portcls clock.
    //
    hrTemp = m_pDM->GetMasterClockWrapperI()->CreateDefaultMasterClock(&m_pPCClock);
    if (FAILED(hrTemp))
    {
		Close();
		return hrTemp;
    }

    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;

    hrTemp = m_pMasterClock->GetTime(&rtMasterClock);
    if (FAILED(hrTemp))
    {
    	Close();
    	return hrTemp;
    }
    
    hrTemp = m_pPCClock->GetTime(&rtSlaveClock);
    if (FAILED(hrTemp))
    {
        Close();
        return hrTemp;
    }

    m_lTimeOffset = rtMasterClock - rtSlaveClock;

    return hr;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::Close
//
//
HRESULT CDirectMusicEmulateInPort::Close()
{
    if (m_hmi)
    {
        midiInReset(m_hmi);
        midiInClose(m_hmi);
        m_hmi = NULL;
    }

    if (m_pPCClock)
    {
        m_pPCClock->Release();
        m_pPCClock = NULL;
    }

    if (m_pThruMap)
    {
        for (int iChannel = 0; iChannel < 16; iChannel++)
        {
            if (m_pThruMap[iChannel].pDestinationPort == NULL)
            {
                continue;
            }

            m_pThruMap[iChannel].pDestinationPort->Release();
        }

        delete[] m_pThruMap;
        m_pThruMap = NULL;
    }

    if (m_pThruBuffer)
    {
        m_pThruBuffer->Release();
        m_pThruBuffer = NULL;
    }

    if (m_hAppEvent)
    {
        m_hAppEvent = NULL;
    }

    if (m_fCSInitialized)
    {
        DeleteCriticalSection(&m_csEventQueues);
    }

    return CDirectMusicEmulatePort::Close();
}
    
//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::Read
//
//
STDMETHODIMP CDirectMusicEmulateInPort::Read(
    IDirectMusicBuffer *pIBuffer)
{
    HRESULT hr;
    
    V_INAME(IDirectMusicPort::Read);
    V_INTERFACE(pIBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    LPBYTE pbBuffer;
    hr = pIBuffer->GetRawBufferPtr(&pbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD cbBuffer;
    hr = pIBuffer->GetMaxBytes(&cbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    TraceI(1, "Read: buffer size %u\n", cbBuffer);

    LPBYTE pbData = pbBuffer;

    // Since events are now buffered, we read them out of the local queue
    //
    //
    EnterCriticalSection(&m_csEventQueues);

    REFERENCE_TIME rtStart;

    if (m_ReadEvents.pFront)
    {
        rtStart = m_ReadEvents.pFront->e.rtDelta;
    }
    else
    {
        TraceI(2, "Read: No events queued\n");
    }

    while (m_ReadEvents.pFront)
    {               
        if (cbBuffer < sizeof(DMUS_EVENTHEADER) + sizeof(DWORD)) 
        {
            TraceI(2, "Read: No more room for events in buffer.\n");
            break;
        }

        QUEUED_EVENT *pQueuedEvent = m_ReadEvents.pFront;
        LPBYTE pbSrc;
        DWORD cbData;

        if (pQueuedEvent->e.dwFlags & EVENT_F_MIDIHDR)
        {
            LPMIDIHDR pmh = (LPMIDIHDR)&pQueuedEvent->e.abEvent[0];

            // Split up recorded sysex if needed.
            //
            cbData = pmh->dwBytesRecorded - pmh->dwOffset;
            DWORD cbQueuedEvent = QWORD_ALIGN(sizeof(DMUS_EVENTHEADER) + cbData);

            if (cbQueuedEvent > cbBuffer) 
            {
                DWORD dwOverflow = QWORD_ALIGN(cbQueuedEvent - cbBuffer);

                cbData -= dwOverflow;
                cbQueuedEvent = QWORD_ALIGN(sizeof(DMUS_EVENTHEADER) + cbData);
            }

            assert(cbQueuedEvent <= cbBuffer);
            assert(cbData <= pmh->dwBytesRecorded - pmh->dwOffset);

            pbSrc = (LPBYTE)(pmh->lpData + pmh->dwOffset);
            pmh->dwOffset += cbData;
        }
        else
        {
            cbData = pQueuedEvent->e.cbEvent;
            pbSrc = &pQueuedEvent->e.abEvent[0];
        }

        DMUS_EVENTHEADER *peh = (DMUS_EVENTHEADER*)pbData;

        peh->rtDelta = pQueuedEvent->e.rtDelta - rtStart;
        peh->cbEvent = cbData;
        peh->dwFlags = 0;
        peh->dwChannelGroup = 1;

        memcpy(pbData + sizeof(DMUS_EVENTHEADER), pbSrc, cbData);

        cbData = QWORD_ALIGN(cbData + sizeof(DMUS_EVENTHEADER));
        pbData += cbData;
        cbBuffer -= cbData;

        m_ReadEvents.pFront = pQueuedEvent->pNext;

        if (pQueuedEvent->e.dwFlags & EVENT_F_MIDIHDR)
        {
            LPMIDIHDR pmh = (LPMIDIHDR)&pQueuedEvent->e.abEvent[0];

            if (pmh->dwOffset = pmh->dwBytesRecorded)
            {
                InterlockedIncrement(&m_lPendingSysExBuffers);
                
                MMRESULT mmr = midiInAddBuffer(m_hmi, pmh, sizeof(*pmh));

                if (mmr)
                {
                    TraceI(0, "Failed to re-add sysex buffer! mmr=%d\n", mmr);
                    InterlockedDecrement(&m_lPendingSysExBuffers);
                }
            }
        }
        else
        {
            // This event came out of the pool
            //
            m_FreeEvents.Free(pQueuedEvent);
        }
    }

    if (m_ReadEvents.pFront == NULL)
    {
        m_ReadEvents.pRear = NULL;
    }

    LeaveCriticalSection(&m_csEventQueues);

    // Update the buffer header information to match the events just packed
    //
    TraceI(2, "Read: Leaving with %u bytes in buffer\n", (unsigned)(pbData - pbBuffer));
    pIBuffer->SetStartTime(rtStart);
    pIBuffer->SetUsedBytes((DWORD)(pbData - pbBuffer));

    return (pbData == pbBuffer) ? S_FALSE : S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::SetReadNotificationHandle
//
//
STDMETHODIMP CDirectMusicEmulateInPort::SetReadNotificationHandle(
    HANDLE hEvent)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    m_hAppEvent = hEvent;

    return S_OK;    
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::ThruChannel
//
//
STDMETHODIMP CDirectMusicEmulateInPort::ThruChannel(
    DWORD               dwSourceChannelGroup, 
    DWORD               dwSourceChannel, 
    DWORD               dwDestinationChannelGroup,
    DWORD               dwDestinationChannel,
    LPDIRECTMUSICPORT   pDestinationPort)
{
    V_INAME(IDirectMusicPort::Thru);
    V_INTERFACE_OPT(pDestinationPort);

    // Channel group must not be zero (broadcast) but in range 1..NumChannelGroups]
    // (which for legacy is always 1)
    //
    if (dwSourceChannelGroup != 1 ||
        dwSourceChannel > 15)
    {
        return E_INVALIDARG;
    }
    
    // Given a port means enable thruing for this channel; NULL means
    // disable.
    //
    if (pDestinationPort)
    {
        // Enabling thruing on this channel. First look at the destination port.
        //
        DMUS_PORTCAPS dmpc;
        dmpc.dwSize = sizeof(dmpc);
        HRESULT hr = pDestinationPort->GetCaps(&dmpc);
        if (FAILED(hr))
        {
            TraceI(0, "ThruChannel: Destination port failed portcaps [%08X]\n", hr);
            return hr;
        }

        // Port must be an output port
        //
        if (dmpc.dwClass != DMUS_PC_OUTPUTCLASS)
        {
            return DMUS_E_PORT_NOT_RENDER;
        }

        // Channel group and channel must be in range.
        //
        if (dwDestinationChannel > 15 ||
            dwDestinationChannelGroup > dmpc.dwMaxChannelGroups) 
        {
            return E_INVALIDARG;
        }

        // Release existing port
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            // Reference to another port type, release it.
            // (NOTE: No need to turn off native dmusic16 thruing at this point,
            // that's handled in dmusic16).
            //
            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
        }


        m_pThruMap[dwSourceChannel].dwDestinationChannel = dwDestinationChannel;
        m_pThruMap[dwSourceChannel].dwDestinationChannelGroup = dwDestinationChannelGroup;
        m_pThruMap[dwSourceChannel].pDestinationPort = pDestinationPort;

        pDestinationPort->AddRef();
    } 
    else
    {
        // Disabling thruing on this channel
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
            m_pThruMap[dwSourceChannel].pDestinationPort = NULL;
        }
    }

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::LegacyCaps
//
//
HRESULT CDirectMusicEmulateInPort::LegacyCaps(
    ULONG               ulId, 
    BOOL                fSet, 
    LPVOID              pbBuffer, 
    PULONG              pcbBuffer)
{
    if (fSet == KSPROPERTY_SUPPORT_SET)
    {
        return DMUS_E_SET_UNSUPPORTED;
    }

    MIDIINCAPS  mic;
    LPBYTE      pbData;
    ULONG       cbData;

    MMRESULT mmr = midiInGetDevCaps(m_id, &mic, sizeof(mic));
    if (mmr)
    {
        TraceI(0, "midiInGetDevCaps failed!\n");
        return MMRESULTToHRESULT(mmr);
    }

    pbData = (LPBYTE)&mic;
    cbData = sizeof(mic);

    ULONG cbToCopy = min(*pcbBuffer, cbData);
    CopyMemory(pbBuffer, pbData, cbToCopy);
    *pcbBuffer = cbToCopy;

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::ActivateLegacyDevice
//
//
HRESULT CDirectMusicEmulateInPort::ActivateLegacyDevice(
    BOOL fActivate)
{
    HRESULT hr = S_OK;
    MMRESULT mmr;

    if (fActivate)
    {
        // BUGBUG SysEx
        //
        TraceI(0, "Emulate in activate\n");
        assert(m_hmi == NULL);

        hr = MMRESULTToHRESULT(mmr = midiInOpen(
            &m_hmi,
            m_id,
            (DWORD_PTR)midiInProc,
            (DWORD_PTR)this,
            CALLBACK_FUNCTION));

        if (SUCCEEDED(hr))
        {
            hr = m_pMasterClock->GetTime(&m_rtStart);
        }

        if (SUCCEEDED(hr))
        {
            hr = PostSysExBuffers();
        }

        if (SUCCEEDED(hr))
        {    
            hr = MMRESULTToHRESULT(mmr = midiInStart(m_hmi));
        }

        if( SUCCEEDED(hr) && m_pPCClock != NULL )
        {
            REFERENCE_TIME rtMasterClock;
            REFERENCE_TIME rtSlaveClock;

            //protect the success code!
            HRESULT hrTemp = m_pMasterClock->GetTime(&rtMasterClock);
            if (SUCCEEDED(hrTemp))
            {
                hrTemp = m_pPCClock->GetTime(&rtSlaveClock);
            }


            if SUCCEEDED(hrTemp)
            {
                 m_lBaseTimeOffset = rtMasterClock - rtSlaveClock;
            }
            else
            {
                //since we've failed, let the failure code fall through
                hr = hrTemp;
            }
        }

        //If we have failed somewhere above, we need to 
        //release the midi-in handle.  the best way to do
        //that is to call this function and deactivate the
        //port!
        if (FAILED(hr))
        {
            HRESULT hrTemp = S_OK;
            hrTemp = ActivateLegacyDevice( FALSE );
        }
    }
    else
    {
        hr = FlushSysExBuffers();

        if (SUCCEEDED(hr))
        {
            hr = MMRESULTToHRESULT(midiInClose(m_hmi));
            m_hmi = NULL;
        }
    }

    return hr;
}    

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::PostSysExBuffers
//
// Initialize and send sysex buffers down to the midi in handle.
//
HRESULT CDirectMusicEmulateInPort::PostSysExBuffers()
{
    HRESULT hr;
    MMRESULT mmr;
    int nBuffer;

    // This will make sure we don't try to unprepare any buffers
    // filled with random garbage.
    //
    for (nBuffer = 0; nBuffer < SYSEX_BUFFERS; nBuffer++)
    {
        LPMIDIHDR pmh = (LPMIDIHDR)&m_SysExBuffers[nBuffer].e.abEvent[0];

        pmh->dwFlags = 0;
    }

    for (nBuffer = 0; nBuffer < SYSEX_BUFFERS; nBuffer++)
    {
        LPMIDIHDR pmh = (LPMIDIHDR)&m_SysExBuffers[nBuffer].e.abEvent[0];

        memset(pmh, 0, sizeof(*pmh));
        pmh->lpData         = (LPSTR)(pmh + 1);
        pmh->dwBufferLength = SYSEX_SIZE;
        pmh->dwUser         = (DWORD_PTR)&m_SysExBuffers[nBuffer];

        hr = MMRESULTToHRESULT(mmr = midiInPrepareHeader(m_hmi, pmh, sizeof(*pmh)));
        if (FAILED(hr))
        {
            return hr;   
        }

        InterlockedIncrement(&m_lPendingSysExBuffers);
        hr = MMRESULTToHRESULT(mmr = midiInAddBuffer(m_hmi, pmh, sizeof(*pmh)));
        if (FAILED(hr))
        {
            InterlockedDecrement(&m_lPendingSysExBuffers);
            return hr;
        }               
    }

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::FlushSysExBuffers
//
// Get all pending sysex buffers back
//
HRESULT CDirectMusicEmulateInPort::FlushSysExBuffers()
{
    MMRESULT mmr;
    int nBuffer;

    m_fFlushing = true;
    
    mmr = midiInReset(m_hmi);
    if (mmr)
    {
        TraceI(0, "midiInReset failed %d!\n", mmr);
        return MMRESULTToHRESULT(mmr);
    }

    LONG lMaxRetry = 500;           // ~ 5 seconds
    while (m_lPendingSysExBuffers)
    {
        TraceI(0, "%d pending sysex buffers\n", m_lPendingSysExBuffers);

        Sleep(10);

        if (!--lMaxRetry) 
        {
            TraceI(0, "Waited too long for sysex to flush from WinMM, continuing anyway.\n");
            break;
        }
    }

    for (nBuffer = 0; nBuffer < SYSEX_BUFFERS; nBuffer++)
    {
        LPMIDIHDR pmh = (LPMIDIHDR)&m_SysExBuffers[nBuffer].e.abEvent[0];

        if (pmh->dwFlags & MHDR_PREPARED)
        {
            midiInUnprepareHeader(m_hmi, pmh, sizeof(*pmh));
        }
    }       

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::Callback()
//
// Process a message from the MIDI API's
//
void CDirectMusicEmulateInPort::Callback(UINT wMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    REFERENCE_TIME rt;

    // dwParam1 == timestamp
    // dwParam2 == data 
    //
    rt = m_rtStart + MsToRefTime(dwParam2);

    SyncClocks();
    //SlaveToMaster(&rt);
    rt += m_lTimeOffset - m_lBaseTimeOffset;

    switch (wMsg)
    {
    case MIM_DATA:
        RecordShortEvent(dwParam1, rt);        
        break;
    
    case MIM_LONGDATA:
        RecordSysEx(dwParam1, rt);        
        break;
    }
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::RecordShortEvent
//
// Record a short message (channel messsage or system message).
//// Queue the incoming data as quickly as possible.
//
// Returns TRUE if the data was successfully recorded; FALSE otherwise.
//
BOOL CDirectMusicEmulateInPort::RecordShortEvent(
    DWORD_PTR               dwMessage,           
    REFERENCE_TIME          rtTime)              
{
    QUEUED_EVENT           *pEvent;
    LPBYTE                  pb;
    BYTE                    b;


    pEvent = m_FreeEvents.Alloc();
    if (pEvent == NULL)
    {
        return FALSE;
    }

    pEvent->e.dwChannelGroup = 1;
    pEvent->e.dwFlags = 0;

    // Now we have to parse and rebuild the channel message.
    //
    // NOTE: Endian specific code ahead
    //
    pb = (LPBYTE)&dwMessage;

    assert(!IS_SYSEX(*pb));         /* This should *always* be in MIM_LONGDATA */
    assert(IS_STATUS_BYTE(*pb));    /* API guarantees no running status */

    // Copying over all the bytes is harmless (we have a DWORD in both
    // source and dest) and is faster than checking to see if we have to.
    // 
    b = pEvent->e.abEvent[0] = *pb++;
    pEvent->e.abEvent[1] = *pb++;
    pEvent->e.abEvent[2] = *pb++;

    if (IS_CHANNEL_MSG(b))
    {
        // 8x, 9x, Ax, Bx, Cx, Dx, Ex 
        // 0x..7x invalid, that would need running status 
        // Fx handled below   
        
        pEvent->e.cbEvent = g_cbChanMsg[(b >> 4) & 0x0F];

        // This is also our criteria for thruing
        //
        //ThruClientList(poh, dwMessage);
    }
    else
    {
        // F1..FF 
        // F0 is sysex, should never see it here 
        pEvent->e.cbEvent = g_cbSysCommData[b & 0x0F];
    }

    pEvent->e.rtDelta = rtTime;
    
    ThruEvent(&pEvent->e);

    // ThruEvent mucks with the time.
    //
    pEvent->e.rtDelta = rtTime;

    QueueEvent(pEvent);

    return TRUE;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::RecordSysEx
//
// Record a sysex event
//
// Returns TRUE if the data was successfully recorded; FALSE otherwise.
//
BOOL CDirectMusicEmulateInPort::RecordSysEx(
    DWORD_PTR               dwMessage,           
    REFERENCE_TIME          rtTime)              
{
    LPMIDIHDR pmh = (LPMIDIHDR)dwMessage;
    QUEUED_SYSEX_EVENT *pEvent = (QUEUED_SYSEX_EVENT *)pmh->dwUser;

    if (!m_fFlushing)
    {
        // Used to walk the data
        pmh->dwOffset = 0;
        
        pEvent->e.dwChannelGroup = 1;
        pEvent->e.dwFlags = EVENT_F_MIDIHDR;
        pEvent->e.cbEvent = pmh->dwBytesRecorded;
        pEvent->e.rtDelta = rtTime;
    
        QueueEvent(pEvent);
    }
    
    InterlockedDecrement(&m_lPendingSysExBuffers);    

    return TRUE;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::QueueEvent
//
// Queue a recorded event in the proper order in the read queue.
//
void CDirectMusicEmulateInPort::QueueEvent(QUEUED_EVENT *pEvent)
{

    EnterCriticalSection(&m_csEventQueues);

    if (m_ReadEvents.pRear)
    {
        m_ReadEvents.pRear->pNext = pEvent;
    }
    else
    {
        m_ReadEvents.pFront = pEvent;
    }

    m_ReadEvents.pRear = pEvent;
    pEvent->pNext = NULL;

    if (m_hAppEvent)
    {
        try
        {
            SetEvent(m_hAppEvent);
        } 
        catch (...)
        {
            Trace(0, "Capture: Application notify event handle prematurely free'd!\n");
        }
    }

    LeaveCriticalSection(&m_csEventQueues);
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::ThruEvent
//
//
void CDirectMusicEmulateInPort::ThruEvent(
    DMEVENT *pEvent)
{
    // Since we know we only have one event and we already have it in the right format,
    // just slam it into the thru buffer. We only have to do this because we might modify 
    // it.
    //
    LPBYTE pbData;
    DWORD  cbData;
    DWORD  cbEvent = DMUS_EVENT_SIZE(pEvent->cbEvent);

    // First see if the event is thruable
    //
    if (pEvent->cbEvent > 3 || ((pEvent->abEvent[0] & 0xF0) == 0xF0))
    {
        // SysEx of some description
        return;
    }

    // Note: legacy driver assures no running status
    //
    DWORD dwSourceChannel = (DWORD)(pEvent->abEvent[0] & 0x0F);

    DMUS_THRU_CHANNEL *pThru = &m_pThruMap[dwSourceChannel];
    if (pThru->pDestinationPort == NULL ||
        pThru->fThruInWin16)
    {
        return;
    }

    if (FAILED(m_pThruBuffer->GetRawBufferPtr(&pbData)))
    {
        TraceI(0, "Thru: GetRawBufferPtr\n");
        return;
    }

    if (FAILED(m_pThruBuffer->GetMaxBytes(&cbData)))
    {
        TraceI(0, "Thru: GetMaxBytes\n");
        return;
    }

    if (cbEvent > cbData)
    {
        TraceI(0, "Thru: cbData %u  cbEvent %u\n", cbData, cbEvent);
        return;
    }
    
    if (FAILED(m_pThruBuffer->SetStartTime(pEvent->rtDelta)) ||
        FAILED(m_pThruBuffer->SetUsedBytes(cbEvent)))
    {
        TraceI(0, "Thru: buffer setup failed\n");
    }

    pEvent->rtDelta = 50000;
    CopyMemory(pbData, pEvent, cbEvent);

    pEvent = (DMEVENT*)pbData;
    pEvent->dwChannelGroup = pThru->dwDestinationChannelGroup;
    pEvent->abEvent[0] = (BYTE)((pEvent->abEvent[0] & 0xF0) | pThru->dwDestinationChannel);

    pThru->pDestinationPort->PlayBuffer(m_pThruBuffer);
}

static VOID CALLBACK midiInProc(
    HMIDIIN                 hMidiIn, 
    UINT                    wMsg, 
    DWORD_PTR               dwInstance, 
    DWORD_PTR               dwParam1,     
    DWORD_PTR               dwParam2)
{
    CDirectMusicEmulateInPort *pPort = (CDirectMusicEmulateInPort*)dwInstance;

    pPort->Callback(wMsg, dwParam1, dwParam2);    
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::SyncClocks
//
//
void CDirectMusicEmulateInPort::SyncClocks()
{
    HRESULT hr;
    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;
    LONGLONG drift;

    if (m_fSyncToMaster
	&&	m_pPCClock)
    {
        hr = m_pMasterClock->GetTime(&rtMasterClock);

        if (SUCCEEDED(hr))
        {
            hr = m_pPCClock->GetTime(&rtSlaveClock);
        }
    
        if (SUCCEEDED(hr))
        {
            drift = (rtSlaveClock + m_lTimeOffset) - rtMasterClock;

            // Work-around 46782 for DX8 release:
            // If drift is greater than 10ms, jump to the new offset value instead
            // of drifting there slowly.
            if( drift > 10000 * 10
            ||  drift < 10000 * -10 )
            {
                m_lTimeOffset -= drift;
            }
            else
            {
                m_lTimeOffset -= drift / 100;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmerport.cpp ===
//
// dmerport.cpp
//
// Emulated Render port (NT)
//
// Copyright (c) 1997-1999 Microsoft Corporation
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <windows.h>
#include <mmsystem.h>
#include <regstr.h>

#include "debug.h"
#include "dmusicp.h"
#include "dmeport.h"

static VOID CALLBACK midiOutProc(
    HMIDIOUT                hMidiOut, 
    UINT                    wMsg, 
    DWORD_PTR               dwInstance, 
    DWORD_PTR               dwParam1,     
    DWORD_PTR               dwParam2);

static VOID CALLBACK timerProc(
    UINT                    uTimerID, 
    UINT                    uMsg, 
    DWORD_PTR               dwUser, 
    DWORD_PTR               dw1, 
    DWORD_PTR               dw2);

//------------------------------------------------------------------------------
// 
// CDirectMusicEmulateOutPort::CDirectMusicEmulateOutPort
//
//
CDirectMusicEmulateOutPort::CDirectMusicEmulateOutPort(
                                                 PORTENTRY *pPE,    
                                                 CDirectMusic *pDM) :
                                                 CDirectMusicEmulatePort(pPE, pDM),
                                                 m_hmo(NULL),
                                                 m_pPlayQueue(NULL),
                                                 m_lTimerId(0),
                                                 m_fClosing(FALSE)
{
}

//------------------------------------------------------------------------------
// 
// CDirectMusicEmulateOutPort::~CDirectMusicEmulateOutPort
//
//
CDirectMusicEmulateOutPort::~CDirectMusicEmulateOutPort()
{
    Close();    
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::Init
//
//
HRESULT CDirectMusicEmulateOutPort::Init(
    LPDMUS_PORTPARAMS pPortParams)
{
    HRESULT         hr;

    hr = CDirectMusicEmulatePort::Init(pPortParams);
    if (FAILED(hr))
    {
        return hr;
    }

    try 
    {
        InitializeCriticalSection(&m_csPlayQueue);
    }
    catch(...)
    {
        return E_OUTOFMEMORY;
    }

    return hr;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::Close
//
//
HRESULT CDirectMusicEmulateOutPort::Close()
{
    m_fClosing = TRUE;
    if (m_lTimerId)
    {
        timeKillEvent(m_lTimerId);
        m_lTimerId = 0;
    }

    DeleteCriticalSection(&m_csPlayQueue);

    return CDirectMusicEmulatePort::Close();
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::LegacyCaps
//
//
HRESULT CDirectMusicEmulateOutPort::LegacyCaps(
    ULONG               ulId, 
    BOOL                fSet, 
    LPVOID              pbBuffer, 
    PULONG              pcbBuffer)
{
    if (fSet == KSPROPERTY_SUPPORT_SET)
    {
        return DMUS_E_SET_UNSUPPORTED;
    }

    MIDIOUTCAPS moc;
    LPBYTE      pbData;
    ULONG       cbData;

    MMRESULT mmr = midiOutGetDevCaps(m_id, &moc, sizeof(moc));
    if (mmr)
    {
        TraceI(0, "midiOutGetDevCaps failed!\n");
        return MMRESULTToHRESULT(mmr);
    }

    pbData = (LPBYTE)&moc;
    cbData = sizeof(moc);

    ULONG cbToCopy = min(*pcbBuffer, cbData);
    CopyMemory(pbBuffer, pbData, cbToCopy);
    *pcbBuffer = cbToCopy;

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::ActivateLegacyDevice
//
//
HRESULT CDirectMusicEmulateOutPort::ActivateLegacyDevice(
    BOOL fActivate)
{
    MMRESULT mmr;

    if (fActivate)
    {
        TraceI(0, "Emulate out activate\n");
        assert(m_hmo == NULL);
        mmr = midiOutOpen(
            &m_hmo,
            m_id,
            (DWORD_PTR)midiOutProc,
            (DWORD_PTR)this,
            CALLBACK_FUNCTION);
        timeBeginPeriod(5);
    }
    else
    {
        TraceI(0, "Emulate out deactivate\n");
        if (m_lTimerId)
        {
            timeKillEvent(m_lTimerId);
            m_lTimerId = 0;
        }
        assert(m_hmo);
        mmr = midiOutClose(m_hmo);
        m_hmo = NULL;
        timeEndPeriod(5);
    }
    
    if (mmr) 
    {
        TraceI(0, "Emulate out activate(%d) returned mmr %d\n", 
            fActivate, mmr);
    }       

    return MMRESULTToHRESULT(mmr);
}    

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::PlayBuffer 
//
//
STDMETHODIMP CDirectMusicEmulateOutPort::PlayBuffer(
    IDirectMusicBuffer *pIBuffer)
{
    LPBYTE                  pbBuffer;
    DWORD                   cbBuffer;
    REFERENCE_TIME          rtStart;
    MMRESULT                mmr;

    if (!m_hmo)
    {
        return DMUS_E_SYNTHINACTIVE;
    }

    // Get buffer parameters
    // 
    HRESULT hr = pIBuffer->GetRawBufferPtr(&pbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }
    
    hr = pIBuffer->GetUsedBytes(&cbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pIBuffer->GetStartTime(&rtStart);
    if (FAILED(hr))
    {
        return hr;
    }

    // Walk buffer and insert events
    //
    EnterCriticalSection(&m_csPlayQueue);

    while (cbBuffer)
    {
        if (cbBuffer < sizeof(DMEVENT)) 
        {
            hr = E_INVALIDARG;
            break;
        }

        DMEVENT *pev = (DMEVENT*)pbBuffer;
        DWORD cbEvent = DMUS_EVENT_SIZE(pev->cbEvent);
        if (cbEvent > cbBuffer)
        {
            hr = E_INVALIDARG;
            break;
        }
        
        pbBuffer += cbEvent;
        cbBuffer -= cbEvent;
        
        // We only play events on channel group 1 (0 is broadcast, so we
        // play that as well).
        //
        if (pev->dwChannelGroup > 1)
        {
            continue;
        }

        // Allocate an event to queue
        //
        DMQUEUEDEVENT *pqe = m_poolEvents.Alloc();
        if (pqe == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        pqe->m_event = *pev;
        pqe->m_event.rtDelta += rtStart;

        if (pev->cbEvent > sizeof(pqe->m_event.abEvent)) 
        {
            pqe->m_pbEvent = new BYTE[sizeof(MIDIHDR) + pev->cbEvent];
            if (pqe->m_pbEvent == NULL)
            {
                m_poolEvents.Free(pqe);
                hr = E_OUTOFMEMORY;
                break;
            }
            LPMIDIHDR pmh = (LPMIDIHDR)pqe->m_pbEvent;

            memset(pmh, 0, sizeof(*pmh));
            pmh->lpData             = (LPSTR)(pmh + 1);
            pmh->dwBufferLength     = pev->cbEvent;
            pmh->dwBytesRecorded    = pev->cbEvent;
            pmh->dwUser             = (DWORD_PTR)pqe;

            memcpy(pmh->lpData, pev->abEvent, pev->cbEvent);
                
            LeaveCriticalSection(&m_csPlayQueue);
            mmr = midiOutPrepareHeader(m_hmo, pmh, sizeof(*pmh));
            EnterCriticalSection(&m_csPlayQueue);
            
            if (mmr)
            {
                delete[] pqe->m_pbEvent;
                pqe->m_pbEvent = pqe->m_event.abEvent;
                m_poolEvents.Free(pqe);
                
                hr = MMRESULTToHRESULT(mmr);
                break;
            }
        }
        else
        {
            pqe->m_pbEvent = pqe->m_event.abEvent;
        }

        // Queue the event
        //
        DMQUEUEDEVENT *pPrev;        
        DMQUEUEDEVENT *pCurr;

        for (pPrev = NULL, pCurr = m_pPlayQueue; pCurr; pPrev = pCurr, pCurr = pCurr->m_pNext) 
        {
            if (pqe->m_event.rtDelta < pCurr->m_event.rtDelta)
            {
                break;
            }
        }

        if (pPrev) 
        {
            pPrev->m_pNext = pqe;
        }        
        else
        {
            m_pPlayQueue = pqe;
        }

        pqe->m_pNext = pCurr;

        TraceI(4, "Enqueued at %I64d\n", pqe->m_event.rtDelta);

        REFERENCE_TIME rt = 0;
        for (pqe = m_pPlayQueue; pqe; pqe = pqe->m_pNext) {
            if (pqe->m_event.rtDelta < rt) {
                TraceI(0, "Queue out of order!\n");
            }
            rt = pqe->m_event.rtDelta;
        }
                
    }
    
    LeaveCriticalSection(&m_csPlayQueue);

    SetNextTimer();

    return hr;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::Callback
//
//
void CDirectMusicEmulateOutPort::Callback(
    UINT                    wMsg,   
    DWORD_PTR               dwParam1, 
    DWORD_PTR               dwParam2)
{
    if (wMsg == MOM_DONE)
    {
        EnterCriticalSection(&m_csPlayQueue);
        
        midiOutUnprepareHeader(m_hmo, (MIDIHDR*)dwParam1, sizeof(MIDIHDR));
        
        DMQUEUEDEVENT *pqe =(DMQUEUEDEVENT*)((LPMIDIHDR)dwParam1)->dwUser;
        
        delete[] pqe->m_pbEvent;
        pqe->m_pbEvent = pqe->m_event.abEvent;
        m_poolEvents.Free(pqe);
        
        LeaveCriticalSection(&m_csPlayQueue);
    }
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::Timer
//
//
void CDirectMusicEmulateOutPort::Timer()
{
    REFERENCE_TIME          rtNow;
    MMRESULT                mmr;
    bool                    fFree;

    if (m_fClosing)
    {
        TraceI(2, "Timer: Closing.\n");
        return;
    }

    HRESULT hr = m_pMasterClock->GetTime(&rtNow);
    if (FAILED(hr))
    {
        TraceI(1, "Timer: SetNextTimer() because this one failed to read the time.\n");
        SetNextTimer();
        return;
    }

    EnterCriticalSection(&m_csPlayQueue);
    TraceI(0, "Timer thread: it is now %I64d\n", rtNow);
    if (m_pPlayQueue)
        TraceI(0, "Timer thread: queue head %I64d\n", m_pPlayQueue->m_event.rtDelta);

    while (m_pPlayQueue && m_pPlayQueue->m_event.rtDelta <= rtNow)
    {
        DMQUEUEDEVENT *pqe = m_pPlayQueue;
        m_pPlayQueue = m_pPlayQueue->m_pNext;

        DWORD dwLate = (DWORD)((rtNow - pqe->m_event.rtDelta) / (10 * 1000));
        
        if (pqe->m_event.cbEvent <= sizeof(pqe->m_event.abEvent))
        {
            mmr = midiOutShortMsg(m_hmo, *(LPDWORD)pqe->m_event.abEvent);
            if (mmr) 
            {
                break;
            }                
            fFree = true;
        }
        else
        {
            LPMIDIHDR pmh = (LPMIDIHDR)pqe->m_pbEvent;
            
            LeaveCriticalSection(&m_csPlayQueue);
            mmr = midiOutLongMsg(m_hmo, pmh, sizeof(*pmh));
            EnterCriticalSection(&m_csPlayQueue);
            if (mmr)
            {
                break;
            }
            
            fFree = false;                               
        }

        if (fFree)
        {
            m_poolEvents.Free(pqe);
        }
    }

    LeaveCriticalSection(&m_csPlayQueue);

    SetNextTimer();
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::SetNextTimer
//
//
void CDirectMusicEmulateOutPort::SetNextTimer()
{
    REFERENCE_TIME rtNow;
    REFERENCE_TIME rtDelta;
    HRESULT hr = m_pMasterClock->GetTime(&rtNow);

    if (FAILED(hr))
    {
        TraceI(1, "SetNextTimer: GetTime failed\n");
        return;
    }

    EnterCriticalSection(&m_csPlayQueue);

    if (m_pPlayQueue == NULL || m_fClosing)
    {
        TraceI(2, "SetNextTimer: Nothing queued or closing.\n");
        LeaveCriticalSection(&m_csPlayQueue);
        return;
    }
    else
    {
        rtDelta = m_pPlayQueue->m_event.rtDelta - rtNow;   
    }

    LeaveCriticalSection(&m_csPlayQueue);
    
    
 

    if (m_lTimerId)
    {
        TraceI(2, "SetNextTimer: Reset old timer\n");

        timeKillEvent(m_lTimerId);
        m_lTimerId = 0;
    }

    LONG msDelta = (DWORD)(rtDelta / (10 * 1000));

    if (msDelta < 5) 
    {
        TraceI(2, "SetNextTimer: delta bumped -> 5 ms\n");
        msDelta = 5;
    }

    m_lTimerId = timeSetEvent(msDelta, 5, timerProc, (DWORD_PTR)this, TIME_ONESHOT | TIME_CALLBACK_FUNCTION | TIME_KILL_SYNCHRONOUS);
    if (!m_lTimerId)
    {
        TraceI(1, "timeSetEvent failed!\n");
    }

    TraceI(4, "SetNextTimer in %d ms\n", msDelta);
}

//------------------------------------------------------------------------------
//
// midiOutProc
//
//
static VOID CALLBACK midiOutProc(
    HMIDIOUT                hMidiOut, 
    UINT                    wMsg, 
    DWORD_PTR               dwInstance, 
    DWORD_PTR               dwParam1, 
    DWORD_PTR               dwParam2)
{
    ((CDirectMusicEmulateOutPort*)dwInstance)->Callback(wMsg, dwParam1, dwParam2);
}

//------------------------------------------------------------------------------
//
// timerProc
//
//
static VOID CALLBACK timerProc(
    UINT                    uTimerID, 
    UINT                    uMsg, 
    DWORD_PTR               dwUser, 
    DWORD_PTR               dw1, 
    DWORD_PTR               dw2)
{
    ((CDirectMusicEmulateOutPort*)dwUser)->Timer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmextchk.cpp ===
//
// dmextchk.cpp
//
// Copyright (c) 1997-2001 Microsoft Corporation.  All rights reserved.
//

#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicc.h"
#include "alist.h"
#include "dlsstrm.h"
#include "debug.h"
#include "dmextchk.h"
#include "dls2.h"
#include "dmportdl.h"

//////////////////////////////////////////////////////////////////////
// Class CExtensionChunk

//////////////////////////////////////////////////////////////////////
// CExtensionChunk::Load

HRESULT CExtensionChunk::Load(CRiffParser *pParser)
{
    HRESULT hr = S_OK;

    DWORD cbRead = 0;
    RIFFIO *pChunk = pParser->GetChunk();

    if(pChunk->cksize < DMUS_MIN_DATA_SIZE)
    {
        m_dwExtraChunkData = 0;
    }
    else
    {
        m_dwExtraChunkData = pChunk->cksize - DMUS_MIN_DATA_SIZE;
    }

    m_pExtensionChunk = (DMUS_EXTENSIONCHUNK*)
        new BYTE[CHUNK_ALIGN(sizeof(DMUS_EXTENSIONCHUNK) + m_dwExtraChunkData)];

    if(m_pExtensionChunk)
    {
        m_pExtensionChunk->cbSize = pChunk->cksize;
        m_pExtensionChunk->ulNextExtCkIdx = 0; // We will set this member to its final value later
        m_pExtensionChunk->ExtCkID = pChunk->ckid;

        hr = pParser->Read(m_pExtensionChunk->byExtCk, pChunk->cksize);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if(FAILED(hr))
    {
        Cleanup();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CExtensionChunk::Write

HRESULT CExtensionChunk::Write(void* pv, DWORD* pdwCurOffset, DWORD dwIndexNextExtChk)
{
    // Argument validation - Debug
    assert(pv);
    assert(pdwCurOffset);

    HRESULT hr = S_OK;

    CopyMemory(pv, (void *)m_pExtensionChunk, Size());
    *pdwCurOffset += Size();
    ((DMUS_EXTENSIONCHUNK*)pv)->ulNextExtCkIdx = dwIndexNextExtChk;

    return hr;
}

BOOL CStack::Push(long lData)

{
    if (m_dwIndex >= STACK_DEPTH) return FALSE;
    m_lStack[m_dwIndex++] = lData;
    return TRUE;
}

long CStack::Pop()

{
    if (m_dwIndex > 0)
    {
        return m_lStack[--m_dwIndex];
    }
    return 0;
}

BOOL CConditionChunk::Evaluate(CDirectMusicPortDownload *pPort)

{
    long lLength = m_dwLength;
    if ( lLength )
    {
        CStack  Stack;
        BOOL fResult = FALSE;
        BYTE *pData = m_bExpression;
        while (lLength > 0)
        {
            USHORT usToken;
            long lTemp;
            long lOpA, lOpB;
            GUID dlsid;
            memcpy(&usToken,pData,sizeof(USHORT));
            pData += sizeof(USHORT);
            lLength -= sizeof(USHORT);
            if ((usToken > 0) && (usToken < DLS_CDL_NOT))
            {
                lOpA = Stack.Pop();
                lOpB = Stack.Pop();
                switch (usToken)
                {
                case DLS_CDL_AND :
                    lTemp = lOpA & lOpB;
                    break;
                case DLS_CDL_OR :
                    lTemp = lOpA | lOpB;
                    break;
                case DLS_CDL_XOR :
                    lTemp = lOpA ^ lOpB;
                    break;
                case DLS_CDL_ADD :
                    lTemp = lOpA + lOpB;
                    break;
                case DLS_CDL_SUBTRACT :
                    lTemp = lOpA - lOpB;
                    break;
                case DLS_CDL_MULTIPLY :
                    lTemp = lOpA * lOpB;
                    break;
                case DLS_CDL_DIVIDE :
                    if (lOpB) lTemp = lOpA / lOpB;
                    else lTemp = 0;
                    break;
                case DLS_CDL_LOGICAL_AND :
                    lTemp = lOpA && lOpB;
                    break;
                case DLS_CDL_LOGICAL_OR :
                    lTemp = lOpA || lOpB;
                    break;
                case DLS_CDL_LT :
                    lTemp = lOpA < lOpB;
                    break;
                case DLS_CDL_LE :
                    lTemp = lOpA <= lOpB;
                    break;
                case DLS_CDL_GT :
                    lTemp = lOpA > lOpB;
                    break;
                case DLS_CDL_GE :
                    lTemp = lOpA >= lOpB;
                    break;
                case DLS_CDL_EQ :
                    lTemp = lOpA == lOpB;
                    break;
                }
                Stack.Push(lTemp);
            }
            else if (usToken == DLS_CDL_NOT)
            {
                Stack.Push(!Stack.Pop());
            }
            else if (usToken == DLS_CDL_CONST)
            {
                memcpy(&lTemp,pData,sizeof(long));
                pData += sizeof(long);
                lLength -= sizeof(long);
                Stack.Push(lTemp);
            }
            else if (usToken == DLS_CDL_QUERY)
            {
                memcpy(&dlsid,pData,sizeof(DLSID));
                pData += sizeof(DLSID);
                lLength -= sizeof(DLSID);
                pPort->QueryDLSFeature(dlsid,&lTemp);
                Stack.Push(lTemp);
            }
            else if (usToken == DLS_CDL_QUERYSUPPORTED)
            {
                memcpy(&dlsid,pData,sizeof(DLSID));
                pData += sizeof(DLSID);
                lLength -= sizeof(DLSID);
                Stack.Push(SUCCEEDED(pPort->QueryDLSFeature(dlsid,&lTemp)));
            }
        }
        return (m_fOkayToDownload = (BOOL) Stack.Pop());
    }
    return (m_fOkayToDownload = TRUE);
}

HRESULT CConditionChunk::Load(CRiffParser *pParser)
{
    HRESULT hr = S_OK;

    if (m_bExpression)
    {
        delete m_bExpression;
        m_bExpression = NULL;
        m_dwLength = 0;
    }
    RIFFIO *pChunk = pParser->GetChunk();
    m_bExpression = new BYTE[pChunk->cksize];
    if (m_bExpression)
    {
        m_dwLength = pChunk->cksize;
        hr = pParser->Read(m_bExpression, pChunk->cksize);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmextchk.h ===
//
// dmextchk.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay

#ifndef DMEXTCHK_H
#define DMEXTCHK_H

#ifndef CHUNK_ALIGN
#define SIZE_ALIGN	sizeof(BYTE *)
#define CHUNK_ALIGN(x) (((x) + SIZE_ALIGN - 1) & ~(SIZE_ALIGN - 1))
#endif

class CRiffParser;
class CExtensionChunk : public AListItem
{
public:
	CExtensionChunk() : m_pExtensionChunk(NULL), m_dwExtraChunkData(0){}
	~CExtensionChunk() {Cleanup();}

	CExtensionChunk* GetNext(){return(CExtensionChunk*)AListItem::GetNext();}
	
	HRESULT Load(CRiffParser *pParser);
	HRESULT Write(void* pv, DWORD* pdwOffset, DWORD dwIdxNextExtChk);
	
	DWORD Size(){return CHUNK_ALIGN(sizeof(DMUS_EXTENSIONCHUNK) + m_dwExtraChunkData);}
	DWORD Count()
	{
		// Return the number of Offset Table entries needed during a call to Write
		return 1;
	}

private:
	void Cleanup()
	{	
		delete [] (BYTE *)m_pExtensionChunk;
	} 

private:
	DMUS_EXTENSIONCHUNK* m_pExtensionChunk;
	DWORD m_dwExtraChunkData;
};

class CDirectMusicPortDownload;

class CExtensionChunkList : public AList
{
friend class CCollection;
friend class CInstrObj;
friend class CWaveObj;
friend class CRegion;
friend class CArticulation;

private:
	CExtensionChunkList(){}
	~CExtensionChunkList()
	{
		while(!IsEmpty())
		{
			CExtensionChunk* pExtensionChunk = RemoveHead();
			delete pExtensionChunk;
		}
	}

    CExtensionChunk* GetHead(){return (CExtensionChunk *)AList::GetHead();}
	CExtensionChunk* GetItem(LONG lIndex){return (CExtensionChunk*)AList::GetItem(lIndex);}
    CExtensionChunk* RemoveHead(){return(CExtensionChunk *)AList::RemoveHead();}
	void Remove(CExtensionChunk* pExtensionChunk){AList::Remove((AListItem *)pExtensionChunk);}
	void AddTail(CExtensionChunk* pExtensionChunk){AList::AddTail((AListItem *)pExtensionChunk);}
};


#define STACK_DEPTH 20

class CStack {
public:
    CStack() { m_dwIndex = 0; }
    BOOL        Push(long lData);
    long        Pop();
private:
    DWORD       m_dwIndex;
    long        m_lStack[STACK_DEPTH];
};

class CConditionChunk {
public:
                CConditionChunk()
                {
                    m_bExpression = NULL;
                    m_dwLength = 0;
                    m_fOkayToDownload = TRUE;
                }
                ~CConditionChunk()
                {
                    if (m_bExpression) delete m_bExpression;
                }
    BOOL        Evaluate(CDirectMusicPortDownload *pPort);
    HRESULT     Load(CRiffParser *pParser);
    BOOL        HasChunk() 
                {
                    return m_dwLength;
                }
    BOOL        m_fOkayToDownload; // Result of evaluation.
private:
    BYTE *      m_bExpression;  // Expression in binary form, copied from file.
    DWORD       m_dwLength;     // Length of binary expression chunk.
};


#endif // #ifndef DMEXTCHK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dminsobj.h ===
//
// dminsobj.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay
//

#ifndef DMINSOBJ_H
#define DMINSOBJ_H

#include "dmregion.h"
#include "dmextchk.h"
#include "dmcount.h"

class CCopyright;
class CArticulation;
class CRiffParser;

class CInstrObj : public AListItem      
{       
friend class CCollection;
friend class CInstrument;
friend class CDirectMusicPortDownload;

private:
	CInstrObj();
	~CInstrObj();

	CInstrObj* GetNext(){return (CInstrObj*)AListItem::GetNext();}
	HRESULT Load(DWORD dwId, CRiffParser *pParser, CCollection* pParent);
	HRESULT Size(DWORD* pdwSize);
	HRESULT Write(void* pvoid);
    void SetPort(CDirectMusicPortDownload *pPort,BOOL fAllowDLS2);
    void CheckForConditionals();

	void Cleanup();
	HRESULT BuildRegionList(CRiffParser *pParser);
	HRESULT ExtractRegion(CRiffParser *pParser, BOOL fDLS1);
	HRESULT BuildWaveIDList();
	HRESULT	GetWaveCount(DWORD* pdwCount);
	HRESULT GetWaveIDs(DWORD* pdwWaveIds);
	HRESULT FixupWaveRefs();

private:
//	CRITICAL_SECTION		m_DMInsCriticalSection;
    BOOL                    m_fCSInitialized;
	DWORD                   m_dwPatch;
	CRegionList				m_RegionList;
//	DWORD					m_dwCountRegion;
	CArticulationList		m_ArticulationList;
	CCopyright*				m_pCopyright;
	CExtensionChunkList		m_ExtensionChunkList;
	DWORD					m_dwCountExtChk;
	DWORD					m_dwId;
	
	// Weak reference since we live in a CInstrument which has 
	// a reference to the collection
	CCollection*	        m_pParent;										

	CWaveIDList				m_WaveIDList;   // List of WaveIDs, one for each wave that this instrument references.
	DWORD                   m_dwNumOffsetTableEntries;
	DWORD					m_dwSize;       // Size required to download instrument to current port.
    CDirectMusicPortDownload * m_pPort;     // Used to track which port condition chunks, etc, are valid for.
    BOOL                    m_fNewFormat;   // Indicates the current port handles INSTRUMENT2 chunks. 
    BOOL                    m_fHasConditionals; // Indicates the instrument has conditional chunks.
#ifdef DBG
	bool					m_bLoaded;
#endif
};      

#endif // #ifndef DMINSOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dminstru.h ===
//
// dminstru.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn 
//
// @doc EXTERNAL
//

#ifndef DMINSTRU_H
#define DMINSTRU_H

class CCollection;
class CInstrObj;

#include "alist.h"
#include "dmwavobj.h"
#include "dminsobj.h"

// IDirectMusicInstrumentPrivate
//

#undef  INTERFACE
#define INTERFACE  IDirectMusicInstrumentPrivate 
DECLARE_INTERFACE_(IDirectMusicInstrumentPrivate, IUnknown)
{
	// IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	// IDirectMusicInstrumentPrivate
	// No methods at this time
};

DEFINE_GUID(IID_IDirectMusicInstrumentPrivate, 0xbcb20080, 0xa40c, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

/*
@interface IDirectMusicInstrument | 
<i IDirectMusicInstrument> manages downloading
an individual instrument from a DLS collection 
(<i IDirectMusicCollection>.)

@comm 
The only way to create an <i IDirectMusicInstrument> for
downloading is to first open an <i IDirectMusicCollection>,
then call <om IDirectMusicCollection::GetInstrument>
to get the requested instrument.

To download an instrument, pass it to <om IDirectMusicPort::Download>,
which, if successful, returns a pointer to an
<i IDirectMusicDownloadedInstrument> interface. 
The <i IDirectMusicDownloadedInstrument> interface is
used only to unload the instrument.

@base public | IUnknown

@meth HRESULT | GetPatch | Returns the patch number of the instrument.
@meth HRESULT | SetPatch | Assign a new patch number to the instrument.

@xref <i IDirectMusicCollection>, <i IDirectMusicPort>,
<i IDirectMusicDownloadedInstrument>, 
<om IDirectMusicCollection::GetInstrument>,
<om IDirectMusicPort::DownloadInstrument>,
<om IDirectMusicPerformance::DownloadInstrument>

@ex Access an instrument from a collection and download it. In addition,
set a range of notes within the instrument to download. This is not
required, but it can improve efficiency because only the waves needed
to render the specified range are downloaded to the synth. | 

	HRESULT myDownload(
		IDirectMusicCollection *pCollection,		// DLS collection.
		IDirectMusicPort *pPort,					// Port to download to.
		IDirectMusicDownloadedInstrument **ppDLInstrument, // Returned.
		DWORD dwPatch,								// Requested instrument.				
		DWORD dwLowNote,							// Low note of range.
		DWORD dwHighNote)							// High note of range.

	{
		HRESULT hr;
		IDirectMusicInstrument* pInstrument;
		hr = pCollection->GetInstrument(dwPatch, &pInstrument);
		if (SUCCEEDED(hr))
		{
			DMUS_NOTERANGE NoteRange[1]; // Optional note range.
			NoteRange[0].dwLowNote = dwLowNote;
			NoteRange[0].dwHighNote = dwHighNote;
			hr = pPort->DownloadInstrument(pInstrument, ppDLInstrument, NoteRange, 1);
			pInstrument->Release();
		}
		return hr;
	}
*/


class CInstrument : public IDirectMusicInstrument, public IDirectMusicInstrumentPrivate, public AListItem
{
friend class CCollection;
friend class CDirectMusicPortDownload;

public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IDirectMusicInstrument
	STDMETHODIMP GetPatch(DWORD* pdwPatch);
	STDMETHODIMP SetPatch(DWORD dwPatch);

private:
    // Class
    //
    CInstrument();
    ~CInstrument();

    CInstrument* GetNext() {return (CInstrument*)AListItem::GetNext();}

	HRESULT Init(DWORD dwPatch, 
				 CCollection* pParentCollection);

	HRESULT GetWaveCount(DWORD* pdwCount);
	HRESULT GetWaveDLIDs(DWORD* pdwIds);
	HRESULT GetWaveSize(DWORD dwId, DWORD* pdwSize, DWORD * pdwSampleSize);
	HRESULT GetWave(DWORD dwDLId, IDirectMusicDownload* pIDMDownload);
    void SetPort(CDirectMusicPortDownload *pPort, BOOL fAllowDLS2);
	HRESULT GetInstrumentSize(DWORD* pdwSize);
	HRESULT GetInstrument(IDirectMusicDownload* pIDMDownload);
	
	DWORD GetInstrumentDLID()
	{
		if(m_dwId != -1)
		{
			return m_dwId;
		}
		else
		{
			return m_pInstrObj->m_dwId;		
		}
	}
	
	void Cleanup();


private:
	CRITICAL_SECTION				m_DMICriticalSection;
	DWORD                           m_dwOriginalPatch;
    DWORD                           m_dwPatch;
	CCollection*			        m_pParentCollection;
	CInstrObj*						m_pInstrObj;
	CWaveObjList					m_WaveObjList;
	bool							m_bInited;
	DWORD							m_dwId;
	long							m_cRef;
};

class CInstrumentList : public AList
{
friend class CCollection;

private:
    CInstrumentList(){}
    ~CInstrumentList() 
    {
        while (!IsEmpty())
        {
            CInstrument* pInstrument = RemoveHead();
            if (pInstrument)
            {
                pInstrument->Release();
            }
        }
    }

    CInstrument* GetHead(){return (CInstrument*)AList::GetHead();}
    CInstrument* GetItem(LONG lIndex){return (CInstrument*)AList::GetItem(lIndex);}
    CInstrument* RemoveHead(){return (CInstrument*)AList::RemoveHead();}
    void Remove(CInstrument* pInstrument){AList::Remove((AListItem*)pInstrument);}
    void AddTail(CInstrument* pInstrument){AList::AddTail((AListItem*)pInstrument);}
};

#endif // #ifndef DMINSTRU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dminsobj.cpp ===
//
// dminsobj.cpp
//
// Copyright (c) 1997-2001 Microsoft Corporation. All rights reserved.
//

#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicc.h"
#include "alist.h"
#include "dmart.h"
#include "debug.h"
#include "dlsstrm.h"
#include "debug.h"
#include "dmcollec.h"
#include "dmcrchk.h"
#include "dmportdl.h"
#include "dminsobj.h"
#include "dls2.h"

#pragma warning(disable:4530)


//////////////////////////////////////////////////////////////////////
// Class CInstrObj

//////////////////////////////////////////////////////////////////////
// CInstrObj::CInstrObj

CInstrObj::CInstrObj()
{
    m_fCSInitialized = FALSE;
//  InitializeCriticalSection(&m_DMInsCriticalSection);
    m_fCSInitialized = TRUE;

    m_fHasConditionals = TRUE;  // Set to true just in case.
    m_dwPatch = 0;
    m_pCopyright = NULL;
    m_dwCountExtChk = 0;
    m_dwId = 0;
    m_pParent = NULL;
    m_dwNumOffsetTableEntries = 0;
    m_dwSize = 0;
    m_pPort = NULL;
#ifdef DBG
    m_bLoaded = false;
#endif
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::~CInstrObj

CInstrObj::~CInstrObj()
{
    if (m_fCSInitialized)
    {
        Cleanup();
        // DeleteCriticalSection(&m_DMInsCriticalSection);
    }
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::Load

HRESULT CInstrObj::Load(DWORD dwId, CRiffParser *pParser, CCollection* pParent)
{
    if(dwId >= CDirectMusicPortDownload::sNextDLId)
    {
        assert(FALSE); // We want to make it known if we get here
        return DMUS_E_INVALID_DOWNLOADID;
    }

    HRESULT hr = S_OK;

    // Argument validation - Debug
    assert(pParent);

    RIFFIO ckNext;
//  EnterCriticalSection(&m_DMInsCriticalSection);
    pParser->EnterList(&ckNext);
    m_dwId = dwId;
    m_pParent = pParent; // We reference no need to Addref
    BOOL fDLS1;
    while (pParser->NextChunk(&hr))
    {
        fDLS1 = FALSE;
        switch(ckNext.ckid)
        {
            case FOURCC_DLID:
                break;

            case FOURCC_INSH :
            {
                INSTHEADER instHeader;
                hr = pParser->Read(&instHeader,sizeof(INSTHEADER));
                m_dwPatch = instHeader.Locale.ulInstrument;
                m_dwPatch |= (instHeader.Locale.ulBank) << 8;
                m_dwPatch |= (instHeader.Locale.ulBank & 0x80000000);
                break;
            }
            case FOURCC_LIST :
                switch (ckNext.fccType)
                {
                    case FOURCC_LRGN :
                        hr = BuildRegionList(pParser);
                        break;

                    case mmioFOURCC('I','N','F','O') :
                        m_pCopyright = new CCopyright   ;
                        if(m_pCopyright)
                        {
                            hr = m_pCopyright->Load(pParser);
                            if((m_pCopyright->m_byFlags & DMC_FOUNDICOP) == 0)
                            {
                                delete m_pCopyright;
                                m_pCopyright = NULL;
                            }
                        }
                        else
                        {
                            hr =  E_OUTOFMEMORY;
                        }
                        break;

                    case FOURCC_LART :
                        fDLS1 = TRUE;
                    case FOURCC_LAR2 :
                        CArticulation *pArticulation;

                        try
                        {
                            pArticulation = new CArticulation;
                        }
                        catch( ... )
                        {
                            pArticulation = NULL;
                        }

                        if(pArticulation)
                        {
                            pArticulation->m_fDLS1 = fDLS1;
                            hr = pArticulation->Load(pParser);
                            m_ArticulationList.AddHead(pArticulation);
                            // Note: If the load failed, this will get deleted in the destructor of the instrument.
                        }
                        else
                        {
                            hr =  E_OUTOFMEMORY;
                        }

                        break;

                    default:
                        // If we get here we have an unknown chunk
                        CExtensionChunk* pExtensionChunk = new CExtensionChunk;
                        if(pExtensionChunk)
                        {
                            hr = pExtensionChunk->Load(pParser);
                            m_ExtensionChunkList.AddHead(pExtensionChunk);
                            m_dwCountExtChk++;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        break;
                }
                break;

            default:
                // If we get here we have an unknown chunk
                CExtensionChunk* pExtensionChunk = new CExtensionChunk;
                if(pExtensionChunk)
                {
                    hr = pExtensionChunk->Load(pParser);
                    m_ExtensionChunkList.AddHead(pExtensionChunk);
                    m_dwCountExtChk++;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                break;
        }

    }
    pParser->LeaveList();

    if(FAILED(hr))
    {
        Cleanup();
    }

#ifdef DBG
    if(SUCCEEDED(hr))
    {
        m_bLoaded = true;
    }
#endif

    CheckForConditionals();

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::Cleanup

void CInstrObj::Cleanup()
{
//  EnterCriticalSection(&m_DMInsCriticalSection);

    while(!m_RegionList.IsEmpty())
    {
        CRegion* pRegion = m_RegionList.RemoveHead();
        delete pRegion;
    }

    while(!m_ArticulationList.IsEmpty())
    {
        CArticulation* pArticulation = m_ArticulationList.RemoveHead();
        delete pArticulation;
    }

    delete m_pCopyright;
    m_pCopyright = NULL;

    while(!m_ExtensionChunkList.IsEmpty())
    {
        CExtensionChunk* pExtChk = m_ExtensionChunkList.RemoveHead();
        m_dwCountExtChk--;
        delete pExtChk;
    }

    // If asserts fire we did not cleanup all of our regions and extension chunks
    assert(!m_dwCountExtChk);

    // Weak reference since we live in a CInstrument which has
    // a strong reference to the collection
    m_pParent = NULL;

    while(!m_WaveIDList.IsEmpty())
    {
        CWaveID* pWaveID = m_WaveIDList.RemoveHead();
        delete pWaveID;
    }

#ifdef DBG
    m_bLoaded = false;
#endif

//  LeaveCriticalSection(&m_DMInsCriticalSection);
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::BuildRegionList

HRESULT CInstrObj::BuildRegionList(CRiffParser *pParser)
{
    HRESULT hr = S_OK;

    RIFFIO ckNext;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        if (ckNext.ckid == FOURCC_LIST)
        {
            if (ckNext.fccType == FOURCC_RGN)
            {
                hr = ExtractRegion(pParser, TRUE);
            }
            else if (ckNext.fccType == FOURCC_RGN2)
            {
                hr = ExtractRegion(pParser, FALSE);
            }
        }
    }
    pParser->LeaveList();

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::ExtractRegion

HRESULT CInstrObj::ExtractRegion(CRiffParser *pParser, BOOL fDLS1)
{
    HRESULT hr = S_OK;

//  EnterCriticalSection(&m_DMInsCriticalSection);

    CRegion* pRegion;

    try
    {
        pRegion = new CRegion;
    }
    catch( ... )
    {
        pRegion = NULL;
    }

    if(pRegion)
    {
        pRegion->m_fDLS1 = fDLS1;
        hr = pRegion->Load(pParser);

        if(SUCCEEDED(hr))
        {
            m_RegionList.AddHead(pRegion);
        }
        else
        {
            delete pRegion;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::BuildWaveIDList

HRESULT CInstrObj::BuildWaveIDList()
{
    // Assumption validation - Debug
#ifdef DBG
    assert(m_bLoaded);
#endif

    HRESULT hr = S_OK;
    CWaveIDList TempList;
    CWaveID* pWaveID;

//  EnterCriticalSection(&m_DMInsCriticalSection);

    CRegion* pRegion = m_RegionList.GetHead();
    for(; pRegion && SUCCEEDED(hr); pRegion = pRegion->GetNext())
    {
        bool bFound = false;
        DWORD dwId = pRegion->GetWaveId();
        pWaveID = TempList.GetHead();
        for(; pWaveID && !bFound; pWaveID = pWaveID->GetNext())
        {
            if(dwId == pWaveID->m_dwId)
            {
                bFound = true;
            }
        }

        if(!bFound)
        {
            pWaveID = new CWaveID(dwId);
            if(pWaveID)
            {
                TempList.AddHead(pWaveID);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if(FAILED(hr))
    {
        while(!m_WaveIDList.IsEmpty())
        {
            pWaveID = TempList.RemoveHead();
            delete pWaveID;
        }
    }

    // Reverse list so it is in same order as region list.

    while (pWaveID = TempList.RemoveHead())
    {
        m_WaveIDList.AddHead(pWaveID);
    }

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::GetWaveCount

HRESULT CInstrObj::GetWaveCount(DWORD* pdwCount)
{
    // Assumption validation - Debug
#ifdef DBG
    assert(m_bLoaded);
#endif
    assert(pdwCount);

    HRESULT hr = S_OK;

//  EnterCriticalSection(&m_DMInsCriticalSection);

    if(m_WaveIDList.IsEmpty())
    {
        hr = BuildWaveIDList();
    }

    *pdwCount = m_WaveIDList.GetCount();

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::GetWaveIDs

HRESULT CInstrObj::GetWaveIDs(DWORD* pdwWaveIds)
{
    // Assumption validation - Debug
    assert(pdwWaveIds);

#ifdef DBG
    assert(m_bLoaded);
#endif

//  EnterCriticalSection(&m_DMInsCriticalSection);

    HRESULT hr = S_OK;

    if(m_WaveIDList.IsEmpty())
    {
        hr = BuildWaveIDList();
    }

    if(FAILED(hr))
    {
//      LeaveCriticalSection(&m_DMInsCriticalSection);
        return hr;
    }

    CWaveID* pWaveID = m_WaveIDList.GetHead();
    for(int i = 0; pWaveID; pWaveID = pWaveID->GetNext(), i++)
    {
        pdwWaveIds[i] = pWaveID->m_dwId;
    }

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return hr;
}

void CInstrObj::SetPort(CDirectMusicPortDownload *pPort,BOOL fAllowDLS2)

{
    if (m_pPort != pPort) // Make sure we have our settings for the current port.
    {
        m_dwSize = 0;     // Force the size to be recomputed (since conditional chunks can cause a change in size.)
        m_pPort = pPort;
        BOOL fSupportsDLS2 = FALSE;
        pPort->QueryDLSFeature(GUID_DMUS_PROP_INSTRUMENT2,(long *) &m_fNewFormat);
        if (m_fNewFormat)
        {
            pPort->QueryDLSFeature(GUID_DMUS_PROP_DLS2,(long *) &fSupportsDLS2);
            fSupportsDLS2 = fSupportsDLS2 && fAllowDLS2;
        }
        CArticulation *pArticulation = m_ArticulationList.GetHead();
        for (;pArticulation;pArticulation = pArticulation->GetNext())
        {
            pArticulation->SetPort(pPort,m_fNewFormat,fSupportsDLS2);
        }
        CRegion* pRegion = m_RegionList.GetHead();
        for(; pRegion; pRegion = pRegion->GetNext())
        {
            pRegion->SetPort(pPort,m_fNewFormat,fSupportsDLS2);
        }
    }
}

void CInstrObj::CheckForConditionals()

{
    m_fHasConditionals = FALSE;
    CArticulation *pArticulation = m_ArticulationList.GetHead();
    for (;pArticulation;pArticulation = pArticulation->GetNext())
    {
        m_fHasConditionals = m_fHasConditionals || pArticulation->CheckForConditionals();
    }
    CRegion* pRegion = m_RegionList.GetHead();
    for(; pRegion; pRegion = pRegion->GetNext())
    {
        m_fHasConditionals = m_fHasConditionals || pRegion->CheckForConditionals();
    }
}


//////////////////////////////////////////////////////////////////////
// CInstrObj::Size

HRESULT CInstrObj::Size(DWORD* pdwSize)
{
    // Assumption validation - Debug
    assert(pdwSize);
#ifdef DBG
    assert(m_bLoaded);
#endif

    // If we have already calculated the size we do not need to do it again
    if(m_dwSize)
    {
        *pdwSize = m_dwSize;
        return S_OK;
    }

    HRESULT hr = S_OK;

    m_dwSize = 0;
    m_dwNumOffsetTableEntries = 0;

    DWORD dwCountExtChk = 0;

//  EnterCriticalSection(&m_DMInsCriticalSection);

    // Calculate the space needed for DMUS_DOWNLOADINFO
    m_dwSize += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

    // Calculate the space needed for DMUS_INSTRUMENT
    m_dwSize += CHUNK_ALIGN(sizeof(DMUS_INSTRUMENT));
    m_dwNumOffsetTableEntries++;

    // Calculate the space needed for Instrument's extension chunks
    CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
    for(; pExtChk; pExtChk = pExtChk->GetNext())
    {
        m_dwSize += pExtChk->Size();
        m_dwNumOffsetTableEntries += pExtChk->Count();
        dwCountExtChk++;
    }

    // We want to validate the number of extension chunks
    if(m_dwCountExtChk == dwCountExtChk)
    {
        // Calculate the space needed for Instrument's copyright
        if(m_pCopyright)
        {
            m_dwSize += m_pCopyright->Size();
            m_dwNumOffsetTableEntries += m_pCopyright->Count();
        }
        // If instrument does not have one use collection's
        else if(m_pParent->m_pCopyright && (m_pParent->m_pCopyright)->m_pDMCopyright)
        {
            m_dwSize += m_pParent->m_pCopyright->Size();
            m_dwNumOffsetTableEntries += m_pParent->m_pCopyright->Count();
        }

        // Calculate the space needed for Instrument's Articulation
        CArticulation *pArticulation = m_ArticulationList.GetHead();
        while (pArticulation)
        {
            while (pArticulation && (pArticulation->Count() == 0))
            {
                pArticulation = pArticulation->GetNext();
            }
            if (pArticulation)
            {
                m_dwSize += pArticulation->Size();
                m_dwNumOffsetTableEntries += pArticulation->Count();
                if (m_fNewFormat)
                {
                    pArticulation = pArticulation->GetNext();
                }
                else break;
            }
        }

        // Calculate the space needed for Instrument's regions
        CRegion* pRegion = m_RegionList.GetHead();
        for(; pRegion; pRegion = pRegion->GetNext())
        {
            m_dwSize += pRegion->Size();
            m_dwNumOffsetTableEntries += pRegion->Count();
        }

        // Calculate the space needed for offset table
        m_dwSize += CHUNK_ALIGN(m_dwNumOffsetTableEntries * sizeof(ULONG));
    }
    else
    {
        hr = E_FAIL;
    }

    // If everything went well, we have the size
    if(SUCCEEDED(hr))
    {
        *pdwSize = m_dwSize;
    }
    else
    {
        m_dwSize = 0;
    }

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::Write

HRESULT CInstrObj::Write(void* pvoid)
{
    // Assumption validation - Debug
    assert(pvoid);
#ifdef DBG
    assert(m_bLoaded);
#endif

    DWORD dwSize = 0;
    Size(&dwSize);

    HRESULT hr = S_OK;

//  EnterCriticalSection(&m_DMInsCriticalSection);

    DWORD dwCurIndex = 0;   // Used to determine what index to store offset in Offset Table
    DWORD dwCurOffset = 0;  // Offset relative to beginning of passed in memory

    // Write DMUS_DOWNLOADINFO
    DMUS_DOWNLOADINFO *pDLInfo = (DMUS_DOWNLOADINFO *) pvoid;
    if (m_fNewFormat)
    {
        pDLInfo->dwDLType = DMUS_DOWNLOADINFO_INSTRUMENT2;
    }
    else
    {
        pDLInfo->dwDLType = DMUS_DOWNLOADINFO_INSTRUMENT;
    }
    pDLInfo->dwDLId = m_dwId;
    pDLInfo->dwNumOffsetTableEntries = m_dwNumOffsetTableEntries;
    pDLInfo->cbSize = dwSize;

    dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

    DMUS_OFFSETTABLE* pDMOffsetTable = (DMUS_OFFSETTABLE *)(((BYTE*)pvoid) + dwCurOffset);

    // Increment pass the DMUS_OFFSETTABLE structure; we will fill the other members in later
    dwCurOffset += CHUNK_ALIGN(m_dwNumOffsetTableEntries * sizeof(DWORD));

    // First entry in ulOffsetTable is the address of the first object.
    pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
    dwCurIndex++;


    // Write Instrument MIDI address
    DMUS_INSTRUMENT* pDMInstrument = (DMUS_INSTRUMENT*)(((BYTE *)pvoid) + dwCurOffset);

    pDMInstrument->ulPatch = m_dwPatch;
    pDMInstrument->ulFlags = 0;

    // Set if a GM instrument
    if(m_pParent->m_guidObject == GUID_DefaultGMCollection)
    {
        pDMInstrument->ulFlags |= DMUS_INSTRUMENT_GM_INSTRUMENT;
    }

    // Increment pass the DMUS_INSTRUMENT structure; we will fill the other members in later
    dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_INSTRUMENT));

    // Write regions
    pDMInstrument->ulFirstRegionIdx = 0;
    CRegion* pRegion = m_RegionList.GetHead();
    while (pRegion && (pRegion->Count() == 0))
    {
        pRegion = pRegion->GetNext();
    }
    while (pRegion)
    {
        DWORD dwNextRegionIndex = 0;
        CRegion *pNextRegion = pRegion->GetNext();
        // Make sure the next chunk can also be downloaded.
        while (pNextRegion && (pNextRegion->Count() == 0))
        {
            pNextRegion = pNextRegion->GetNext();
        }
        if (pNextRegion)
        {
            dwNextRegionIndex = dwCurIndex + pRegion->Count();
        }
        if (pDMInstrument->ulFirstRegionIdx == 0)
        {
            pDMInstrument->ulFirstRegionIdx = dwCurIndex;
        }

        pDMOffsetTable->ulOffsetTable[dwCurIndex++] = dwCurOffset;
        hr = pRegion->Write(((BYTE *)pvoid + dwCurOffset),
                            &dwCurOffset,
                            pDMOffsetTable->ulOffsetTable,
                            &dwCurIndex,
                            dwNextRegionIndex);
        if (FAILED(hr)) break;
        pRegion = pNextRegion;
    }

    if(SUCCEEDED(hr))
    {
        // Write extension chunks
        CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
        if(pExtChk)
        {
            DWORD dwCountExtChk = m_dwCountExtChk;
            DWORD dwIndexNextExtChk;
            pDMInstrument->ulFirstExtCkIdx = dwIndexNextExtChk = dwCurIndex;

            for(; pExtChk && SUCCEEDED(hr) && dwCountExtChk > 0; pExtChk = pExtChk->GetNext())
            {
                if(dwCountExtChk == 1)
                {
                    dwIndexNextExtChk = 0;
                }
                else
                {
                    dwIndexNextExtChk = dwCurIndex + 1;
                }

                pDMOffsetTable->ulOffsetTable[dwCurIndex++] = dwCurOffset;
                hr = pExtChk->Write(((BYTE *)pvoid + dwCurOffset),
                                    &dwCurOffset,
                                    dwIndexNextExtChk);

                dwCountExtChk--;
            }
        }
        else
        {
            // If no extension chunks set to zero
            pDMInstrument->ulFirstExtCkIdx = 0;
        }
    }

    if(SUCCEEDED(hr))
    {
        // Write copyright information
        if(m_pCopyright)
        {
            pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
            pDMInstrument->ulCopyrightIdx = dwCurIndex;
            hr = m_pCopyright->Write(((BYTE *)pvoid + dwCurOffset),
                                     &dwCurOffset);
            dwCurIndex++;
        }
        // If instrument does not have one use collection's
        else if(m_pParent->m_pCopyright && (m_pParent->m_pCopyright)->m_pDMCopyright)
        {
            pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
            pDMInstrument->ulCopyrightIdx = dwCurIndex;
            hr = m_pParent->m_pCopyright->Write((BYTE *)pvoid + dwCurOffset, &dwCurOffset);
            dwCurIndex++;
        }
        else
        {
            pDMInstrument->ulCopyrightIdx = 0;
        }
    }

    if(SUCCEEDED(hr))
    {
        pDMInstrument->ulGlobalArtIdx = 0;
        // Write global articulation if we have one
        CArticulation *pArticulation = m_ArticulationList.GetHead();
        // Scan past articulation chunks that will not be downloaded.
        while (pArticulation && (pArticulation->Count() == 0))
        {
            pArticulation = pArticulation->GetNext();
        }
        while (pArticulation)
        {
            DWORD dwNextArtIndex = 0;
            CArticulation *pNextArt = NULL;
            if (m_fNewFormat)
            {
                pNextArt = pArticulation->GetNext();
                // Make sure the next chunk can also be downloaded.
                while (pNextArt && (pNextArt->Count() == 0))
                {
                    pNextArt = pNextArt->GetNext();
                }
                if (pNextArt)
                {
                    dwNextArtIndex = dwCurIndex + pArticulation->Count();
                }
            }
            if (pDMInstrument->ulGlobalArtIdx == 0)
            {
                pDMInstrument->ulGlobalArtIdx = dwCurIndex;
            }
            pDMOffsetTable->ulOffsetTable[dwCurIndex++] = dwCurOffset;
            hr = pArticulation->Write(((BYTE *)pvoid + dwCurOffset),
                                        &dwCurOffset,
                                        pDMOffsetTable->ulOffsetTable,
                                        &dwCurIndex,
                                        dwNextArtIndex);
            pArticulation = pNextArt;
            if (FAILED(hr)) break;
        }

    }

    if(FAILED(hr))
    {
        // If we fail we want to cleanup the contents of passed in buffer
        ZeroMemory(pvoid, dwSize);
    }

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::FixupWaveRefs

HRESULT CInstrObj::FixupWaveRefs()
{

//  EnterCriticalSection(&m_DMInsCriticalSection);

    CRegion* pRegion = m_RegionList.GetHead();

    for(; pRegion; pRegion = pRegion->GetNext())
    {
        if (pRegion->m_WaveLink.ulTableIndex < m_pParent->m_dwWaveOffsetTableSize)
        {
            pRegion->m_WaveLink.ulTableIndex = m_pParent->m_pWaveOffsetTable[pRegion->m_WaveLink.ulTableIndex].dwId;
        }
        else
        {
            Trace(1,"Error: Bad DLS file has out of range wavelink.\n");
            return DMUS_E_BADWAVELINK;
        }
    }

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmpcclk.cpp ===
//
// DMPcClk.CPP
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Wrapper for using clock from portclass as the DirectMusic master clock
// (Win9x only)
// 
//
#include <objbase.h>
#include <winerror.h>
#include <setupapi.h>
#include "dmusicp.h"
#include "suwrap.h"
#include "debug.h"
#include "resource.h"

// Since we only allocate one of these clocks in the entire system,
// this stuff is global.
//

// We have to be able to get the process id of someone with a handle to
// the clock. Since the original creator might go away before other users,
// we store the process id of everyone who uses the clock. This implies
// a max limit on concurrent processes using it.
//
#define MAX_CLOCK_SHARERS   64              // Max processes who can access clock   
                                            // at once.
typedef struct PCCLOCKSHARE
{
    LONG                cRef;               // Count of processes using handle

    struct 
    {
        HANDLE          hPcClock;           // This user's handle and
        DWORD           dwProcessId;        // process id
    } aUsers[MAX_CLOCK_SHARERS];

} *PPCCLOCKSHARE;

class CPcClock : public IReferenceClock
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie); 
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie);
    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // Class
    //
    CPcClock();
    ~CPcClock();
    HRESULT Init();

private:
    long m_cRef;

    HRESULT CreatePcClockShared();
    void    DeletePcClockShared();
    HRESULT CreatePcClockHandle();
    HRESULT DuplicatePcClockHandle();

private:
    static const char m_cszPcClockMemory[];       // Name of shared memory object
    static const char m_cszPcClockMutex[];        // Name of mutex protecting shared memory

    static LONG m_lSharedMemoryInitialized;       // Has this process initialized shared memory?
    static HANDLE m_hFileMapping;                 // File mapping handle for shared memory
    static PPCCLOCKSHARE m_pShared;               // Pointer to shared memory
    static HANDLE m_hPcClockMutex;                // Mutex for shared memory access
    static HANDLE m_hClock;                       // Clock handle in this process
};

HRESULT CreatePcClock(IReferenceClock **ppClock, CMasterClock *pMasterClock);
static BOOL LookForPortClock(PHANDLE phClock);

const char       CPcClock::m_cszPcClockMemory[] = "DirectMusiCPcClock";
const char       CPcClock::m_cszPcClockMutex[]  = "DirectMusiCPcClockMutex";

LONG             CPcClock::m_lSharedMemoryInitialized = 0;
HANDLE           CPcClock::m_hFileMapping = NULL;         
PPCCLOCKSHARE    CPcClock::m_pShared = NULL;        
HANDLE           CPcClock::m_hPcClockMutex = NULL;
HANDLE           CPcClock::m_hClock;                


// AddPcClocPc
//
// Add Pc clock to the list of clocPc.
//
HRESULT AddPcClocks(CMasterClock *pMasterClock)
{
    HANDLE hClock;

    // Make sure we can create a default Pc clock
    //
    DWORD ms = timeGetTime();
    if (!LookForPortClock(&hClock))
    {
        TraceI(1, "Could not create Pc clock\n");
        return S_FALSE;
    }
    TraceI(3, "LookForPortClock took %d\n", timeGetTime() - ms);

    CloseHandle(hClock);

    CLOCKENTRY ce;

    ZeroMemory(&ce, sizeof(ce));
    ce.cc.dwSize = sizeof(ce.cc);
    ce.cc.guidClock = GUID_SysClock;         
    ce.cc.ctType = DMUS_CLOCK_SYSTEM;
    ce.cc.dwFlags = DMUS_CLOCKF_GLOBAL;
    ce.pfnGetInstance = CreatePcClock;

    int cch;
    int cchMax = sizeof(ce.cc.wszDescription) / sizeof(WCHAR);

    char sz[sizeof(ce.cc.wszDescription) / sizeof(WCHAR)];
    cch = LoadString(g_hModule,
                     IDS_SYSTEMCLOCK,
                     sz,
                     sizeof(sz));
    if (cch)
    {
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            sz,
            -1,
            ce.cc.wszDescription,
            sizeof(ce.cc.wszDescription));
    }
    else
    {
        *ce.cc.wszDescription = 0;
    }

    return pMasterClock->AddClock(&ce);
}

// CreatePcClock
//
// Return an IReferenceClock based on the one Pc clock in the system
//
HRESULT CreatePcClock(IReferenceClock **ppClock, CMasterClock *pMasterClock)
{
    TraceI(3, "Creating Pc clock\n");

    CPcClock *pClock = new CPcClock;

    if (pClock == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pClock->Init();
    if (FAILED(hr))
    {
        delete pClock;
        return hr;
    }

    hr = pClock->QueryInterface(IID_IReferenceClock, (void**)ppClock);
    pClock->Release();

    return hr;
}

// CPcClock::CPcClock()
//
// 
CPcClock::CPcClock() : 
    m_cRef(1)
{
}

// CPcClock::~CPcClock()
//
// 
CPcClock::~CPcClock()
{
    if (InterlockedDecrement(&m_lSharedMemoryInitialized) == 0)
    {
        DeletePcClockShared();        
    }
}

// CPcClock::QueryInterface
//
// Standard COM implementation
//
STDMETHODIMP CPcClock::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusic::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

// CPcClock::AddRef
// 
STDMETHODIMP_(ULONG) CPcClock::AddRef()
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

// CPcClock::Release
//
STDMETHODIMP_(ULONG) CPcClock::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CPcClock::Init
//
HRESULT CPcClock::Init()
{
    HRESULT hr;

    if (InterlockedIncrement(&m_lSharedMemoryInitialized) == 1)
    {
        hr = CreatePcClockShared();
        if (FAILED(hr))
        {
            return hr;
        }    
    }

    return S_OK;
}

// CPcClock::CreatePcClocPchared
//
// Initialize the shared memory object in this process.
// Make sure a handle to the Pc clock exists in this process.
//
HRESULT CPcClock::CreatePcClockShared()
{
    HRESULT hr;
    DWORD dwErr;

    // Create and take the mutex up front. This is neccesary to guarantee that if 
    // we are the first process in the system to create this object, then we do 
    // initialization before anyone else can access the shared memory object.
    //
    m_hPcClockMutex = CreateMutex(NULL,             // Default security descriptor
                                  FALSE,            // Own mutex if we are first instance
                                  m_cszPcClockMutex);
    if (m_hPcClockMutex == NULL)
    {
        TraceI(0, "CreateMutex failed! [%d]\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    WaitForSingleObject(m_hPcClockMutex, INFINITE);

    // Create the file mapping and view of the shared memory, noticing if we are the first 
    // object to create it.
    //
    m_hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE,    // Use paging file
                                       NULL,                    // Default security descriptor
                                       PAGE_READWRITE,  
                                       0,                       // High DWORD of size
                                       sizeof(PCCLOCKSHARE),
                                       m_cszPcClockMemory);
    dwErr = GetLastError();
    if (m_hFileMapping == NULL)
    {
        ReleaseMutex(m_hPcClockMutex);
        
        return HRESULT_FROM_WIN32(dwErr);
    }    

    BOOL fFirst = (dwErr != ERROR_ALREADY_EXISTS);

    m_pShared = (PPCCLOCKSHARE)MapViewOfFile(m_hFileMapping,
                                             FILE_MAP_WRITE,
                                             0, 0,                // Start mapping at the beginning
                                             0);                  // Map entire file
    if (m_pShared == NULL)
    {
        TraceI(0, "MapViewOfFile failed! [%d]\n", GetLastError());

        ReleaseMutex(m_hPcClockMutex);
        return E_OUTOFMEMORY;
    }

    // Initialize the refernce count if we are the first process, and increment
    // it in any case. (Note we're still in the mutex, so we don't need 
    // InterlockedIncrement.
    //
    if (fFirst)
    {
        m_pShared->cRef = 0;
        ZeroMemory(m_pShared->aUsers, sizeof(m_pShared->aUsers));
    }
    ++m_pShared->cRef;

    // If the clock handle doesn't exist yet, create it; else duplicate it. 
    //
    if (m_pShared->cRef == 1)
    {
        hr = CreatePcClockHandle();
    }
    else
    {
        hr = DuplicatePcClockHandle();
    }

    // Release the mutex and return success or failure.
    //
    ReleaseMutex(m_hPcClockMutex);

    return hr;
}

// CPcClock::DeletePcClocPchared
//
// The last instance of CPcClock in this process is being deleted. 
//
void CPcClock::DeletePcClockShared()
{
    // If the mutex was never created, then none of the other objects could have
    // been created.
    //
    if (m_hPcClockMutex)
    {
        WaitForSingleObject(m_hPcClockMutex, INFINITE);

        if (m_pShared)
        {
            for (int i = 0; i < MAX_CLOCK_SHARERS; i++)
            {
                if (m_pShared->aUsers[i].dwProcessId == GetCurrentProcessId())
                {
                    m_pShared->aUsers[i].dwProcessId = 0;
                    m_pShared->aUsers[i].hPcClock = NULL;

                    break;
                }
            }
        }

        if (m_hClock)
        {
            CloseHandle(m_hClock);
            m_hClock = NULL;
        }        

        if (m_pShared)
        {
            UnmapViewOfFile(m_pShared);
            m_pShared = NULL;
        }

        if (m_hFileMapping)
        {
            CloseHandle(m_hFileMapping);
            m_hFileMapping = NULL;
        }
                
        ReleaseMutex(m_hPcClockMutex);
        CloseHandle(m_hPcClockMutex);                            
    }
}

// CPcClock::CreatePcClockHandle
//
// Create the first and only Pc clock handle in the system
//
HRESULT CPcClock::CreatePcClockHandle()
{
    // Attempt to open the clock
    //
    if (!LookForPortClock(&m_hClock))
    {
        TraceI(0, "Could not create Pc clock\n");
        return S_FALSE;
    }

    // Successful clock open. Since we're creating, we know we're the first
    // instance of the clock and therefore the users array is empty.
    //
    m_pShared->aUsers[0].hPcClock = m_hClock;
    m_pShared->aUsers[0].dwProcessId = GetCurrentProcessId();    

    return S_OK;
}

// CPcClock::DuplicatePcClockHandle
//
// There is already a Pc clock in the system. Duplicate the handle in this process
// context.
//
HRESULT CPcClock::DuplicatePcClockHandle()
{
    // Find another user of the clock; also, find a slot in the users array for
    // this process
    //
    int iEmptySlot = -1;
    int iOtherProcess = -1;
    HANDLE hClock = NULL;

    for (int i = 0; 
         (i < MAX_CLOCK_SHARERS) && (iEmptySlot == -1 || !hClock); 
         i++)
    {
        if (m_pShared->aUsers[i].dwProcessId == 0 && iEmptySlot == -1)
        {
            iEmptySlot = i;
            continue;
        }

        if (hClock)
        {
            continue;
        }            

        HANDLE hOtherProcess = OpenProcess(PROCESS_DUP_HANDLE, 
                                           FALSE,
                                           m_pShared->aUsers[i].dwProcessId);
        if (hOtherProcess == NULL)
        {
            TraceI(0, "OpenProcess: %d\n", GetLastError());
            m_pShared->aUsers[i].dwProcessId = 0;
            m_pShared->aUsers[i].hPcClock = NULL;
            continue;
        }

        BOOL fSuccess = DuplicateHandle(hOtherProcess,
                                        m_pShared->aUsers[i].hPcClock,
                                        GetCurrentProcess(),
                                        &hClock,
                                        GENERIC_READ|GENERIC_WRITE,
                                        FALSE,
                                        0);
        if (!fSuccess)
        {
            TraceI(0, "DuplicateHandle: %d\n", GetLastError());
        }

        CloseHandle(hOtherProcess);

        if (!fSuccess)
        {
            // Other process exists, but could not duplicate handle
            //
            m_pShared->aUsers[i].dwProcessId = 0;
            m_pShared->aUsers[i].hPcClock = NULL;

            hClock = NULL;
        }
    }

    assert(iEmptySlot != -1);
    assert(hClock);

    m_hClock = hClock;

    m_pShared->aUsers[iEmptySlot].dwProcessId = GetCurrentProcessId();
    m_pShared->aUsers[iEmptySlot].hPcClock = hClock;

    return S_OK;
}

STDMETHODIMP 
CPcClock::GetTime(REFERENCE_TIME *pTime)
{
    KSPROPERTY ksp;

    ZeroMemory(&ksp, sizeof(ksp));
    ksp.Set   = KSPROPSETID_SynthClock;
    ksp.Id    = KSPROPERTY_SYNTH_MASTERCLOCK;
    ksp.Flags = KSPROPERTY_TYPE_GET;


    if (!Property(m_hClock,
                  sizeof(ksp),
                  (PKSIDENTIFIER)&ksp,
                  sizeof(*pTime),
                  pTime,
                  NULL))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }           
    
    return S_OK;
}

STDMETHODIMP 
CPcClock::AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CPcClock::AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CPcClock::Unadvise(DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}


static BOOL    
LookForPortClock(PHANDLE phClock)
{
    SetupAPI suwrap;
    HANDLE hFilter = INVALID_HANDLE_VALUE;

    if (!suwrap.IsValid()) 
    {
        return FALSE;
    }

    *phClock = (HANDLE)NULL;

	GUID *pClassGuid = const_cast<GUID*>(&KSCATEGORY_AUDIO);
	HDEVINFO hDevInfo = suwrap.SetupDiGetClassDevs(pClassGuid,
											NULL,
											NULL,
											DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
	if (hDevInfo == NULL || hDevInfo == INVALID_HANDLE_VALUE)
	{
		TraceI(0, "Could not open SetupDiGetClassDevs\n");
        return FALSE;
	}

	SP_DEVICE_INTERFACE_DATA DevInterfaceData;
	DevInterfaceData.cbSize = sizeof(DevInterfaceData);

	BYTE rgbStorage[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + _MAX_PATH];
	SP_DEVICE_INTERFACE_DETAIL_DATA * pDevInterfaceDetails = (SP_DEVICE_INTERFACE_DETAIL_DATA *)rgbStorage;
	pDevInterfaceDetails->cbSize = sizeof(*pDevInterfaceDetails);

    int iDevice = 0;

	while (suwrap.SetupDiEnumDeviceInterfaces(hDevInfo, NULL, pClassGuid, iDevice++, &DevInterfaceData))
    {
		if (suwrap.SetupDiGetDeviceInterfaceDetail(hDevInfo, 
		                                    &DevInterfaceData, 
		                                    pDevInterfaceDetails,
 										    sizeof(rgbStorage), 
 										    NULL, 
 										    NULL))
        {
            // Have to convert this since there's no CreateFileW on Win9x.
            //
            hFilter = CreateFile(pDevInterfaceDetails->DevicePath,
                                        GENERIC_READ | GENERIC_WRITE, 
                                        0,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                        NULL);
            if (hFilter == NULL || hFilter == INVALID_HANDLE_VALUE)
            {
                continue;
            }

            KSPROPERTY ksp;

            ZeroMemory(&ksp, sizeof(ksp));
            ksp.Set   = KSPROPSETID_SynthClock;
            ksp.Id    = KSPROPERTY_SYNTH_MASTERCLOCK;
            ksp.Flags = KSPROPERTY_TYPE_GET;

            REFERENCE_TIME rt;

            if (!Property(
                hFilter,
                sizeof(ksp),
                (PKSIDENTIFIER)&ksp,
                sizeof(rt),
                &rt,
                NULL))
            {
                CloseHandle(hFilter);
                hFilter = INVALID_HANDLE_VALUE;
                continue;
            }
            
            break;
        }
    }

    suwrap.SetupDiDestroyDeviceInfoList(hDevInfo);

    if (hFilter != INVALID_HANDLE_VALUE)
    {
        *phClock = hFilter;
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmport.cpp ===
//
// dmport.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: CDirectMusicPort : Implements the WDM version of IDirectMusicPort.
//
// @doc EXTERNAL
//
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <objbase.h>
#include <mmsystem.h>
#include <regstr.h>

#include "debug.h"
#include "dmusicp.h"
#include "dminstru.h"
#include "dmdlinst.h"
#include "validate.h"

#pragma warning(disable:4200)

static const GUID guidZero;

#ifdef DBG
extern void _TraceIGuid(int iLevel, GUID *pGUID);
#define TraceIGuid _TraceIGuid
#else
#define TraceIGuid(x,y)
#endif

#define POSTED_STREAM_READ_IRPS     (60)
#define BYTES_PER_READ_IRP          (QWORD_ALIGN(2 * QWORD_ALIGN(sizeof(DMEVENT) + sizeof(DWORD)) - 1))

typedef struct
{
    KSSTREAM_HEADER     kssh;
    OVERLAPPED          overlapped;
    char                buffer[BYTES_PER_READ_IRP];
} READ_IRP;

// @globalv:(INTERNAL) Registry location of WDM driver port definitions
//
// @comm This might need to change
//
const char cszWDMPortsRoot[] = REGSTR_PATH_PRIVATEPROPERTIES "\\Midi\\WDMPort";

HRESULT EnumerateSADDevice(
    CDirectMusic        *pDirectMusic,
    HKEY                hkPortsRoot,
    LPSTR               pInstIdPrefDev,
    HANDLE              hSysAudio,
    ULONG               idxDevice,
    ULONG               *plEnumeratedPorts);

HRESULT EnumerateSADDevicePin(
    CDirectMusic        *pDirectMusic,
    HKEY                hkPortsRoot,
    HANDLE              hSysAudio,
    ULONG               idxDevice,
    ULONG               idxPin,
    BOOL                fOnPrefDev,
    LPWSTR              wszDescription,
    LPSTR               psrtInstanceId,
    ULONG               *plEnumeratedPorts,
    LPWSTR              szDIName);

static DWORD WINAPI FreeWDMHandle(LPVOID lpThreadParameter);
static DWORD WINAPI CaptureThread(LPVOID lpThreadParameter);

//////////////////////////////////////////////////////////////////////
// EnumerateWDMDevices
//
HRESULT EnumerateWDMDevices(CDirectMusic *pDirectMusic)
{
    HANDLE          hSysAudio;
    HKEY            hkPortsRoot;
    ULONG           cTotalDevices;
    ULONG           idxDevice;
    LPSTR           pInstIdPrefDev = NULL;
    ULONG           lEnumeratedPorts;

    // Determine the instance ID of the preferred wave audio device
    //  pInstIDPrefDev will allocate a string buffer
    if (!InstanceIdOfPreferredAudioDevice(&pInstIdPrefDev))
    {
        TraceI(0, "Could not determine a preferred wave audio device\n");

        if (pInstIdPrefDev!= NULL) delete[] pInstIdPrefDev;
        pInstIdPrefDev = NULL;

    }
    else
    {
        TraceI(1, "Preferred device [%s]\n", pInstIdPrefDev);
    }

    // Open or create the reg key to store WDM driver linkages
    //
    if (RegCreateKey(HKEY_LOCAL_MACHINE,
                     cszWDMPortsRoot,
                     &hkPortsRoot))
    {
        hkPortsRoot = NULL;
    }

    // Description of standard streaming interface driver must support to be
    // enumerated
    //

    // If we can't open SysAudio, we can't enum any WDM devices
    //
    if (!OpenDefaultDevice(KSCATEGORY_SYSAUDIO, &hSysAudio))
    {
        return S_FALSE;
    }

    // Figure out how many devices there are and walk the list of them.
    //
    if (!GetSysAudioDeviceCount(hSysAudio, &cTotalDevices))
    {
        return S_FALSE;
    }

    // Enumerate and get info on each SAD device
    //

    lEnumeratedPorts = 0;
    for (idxDevice = 0; idxDevice < cTotalDevices; ++idxDevice)
    {
        EnumerateSADDevice(pDirectMusic,
                           hkPortsRoot,
                           pInstIdPrefDev,
                           hSysAudio,
                           idxDevice,
                           &lEnumeratedPorts);
    }

    TraceI(1, "EnumerateWDMDevices: Added %lu ports\n", lEnumeratedPorts);

    if (hkPortsRoot)
    {
        RegCloseKey(hkPortsRoot);
    }

    CloseHandle(hSysAudio);

    //Deallocate pInstIdPrefDev
    if (pInstIdPrefDev != NULL) delete[] pInstIdPrefDev;

    return lEnumeratedPorts ? S_OK : S_FALSE;
}

HRESULT EnumerateSADDevice(
    CDirectMusic        *pDirectMusic,
    HKEY                hkPortsRoot,
    LPSTR               pInstIdPrefDev,
    HANDLE              hSysAudio,
    ULONG               idxDevice,
    ULONG               *plEnumeratedPorts)
{
    LPSTR               pstrInstanceId = NULL;

    ULONG               cPins;
    ULONG               idxPin;
    WCHAR               wszDIName[256];
    CHAR                szDIName[256];
    WCHAR               wszDescription[DMUS_MAX_DESCRIPTION];
    BOOL                fOnPrefDev;

    // Set SysAudio to talk to us about this device number
    //
    if (!SetSysAudioDevice(hSysAudio, idxDevice))
    {
        TraceI(0, "EnumerateSADDevice: Failed to set device to %d\n", idxDevice);
        return S_FALSE;
    }

    if (!GetDeviceFriendlyName(hSysAudio, idxDevice, wszDescription, ELES(wszDescription)))
    {
        TraceI(0, "AddWDMDevices: Failed to get friendly name!\n");
        return S_FALSE;
    }

    char sz[256];
    wcstombs(sz, wszDescription, sizeof(sz));
    TraceI(1, "Looking at [%s]\n", sz);

    fOnPrefDev = FALSE;
    if (!GetDeviceInterfaceName(hSysAudio, idxDevice, wszDIName, ELES(wszDIName)))
    {
        TraceI(0, "No interface name for device.\n");
        return S_FALSE;
    }

    wcstombs(szDIName, wszDIName, sizeof(szDIName));
    if (!DINameToInstanceId(szDIName, &pstrInstanceId))
    {
        TraceI(0, "Could not determine instance ID\n");
        return S_FALSE;
    }
    TraceI(1, "DIName [%s]\nInstId [%s]\n",
        szDIName,
        pstrInstanceId);

    if (pInstIdPrefDev)
    {
        if (!_stricmp(pstrInstanceId, pInstIdPrefDev))
        {
            TraceI(1, "This filter is on the preferred audio device\n");
            fOnPrefDev = TRUE;
        }
    }

    HRESULT hr = S_FALSE;
    // Get the number of pin types on this device
    //
    if (GetNumPinTypes(hSysAudio, &cPins))
    {
        for (idxPin = 0; idxPin < cPins; idxPin++)
        {
            hr = EnumerateSADDevicePin(pDirectMusic,
                                       hkPortsRoot,
                                       hSysAudio,
                                       idxDevice,
                                       idxPin,
                                       fOnPrefDev,
                                       wszDescription,
                                       pstrInstanceId,
                                       plEnumeratedPorts,
                                       wszDIName);
        }
    }
    else
    {
        TraceI(0, "AddWDMDevices: Failed to get number of pin types for device %d\n", idxDevice);
    }

    delete[] pstrInstanceId;

    return hr;
}

HRESULT EnumerateSADDevicePin(
    CDirectMusic        *pDirectMusic,
    HKEY                hkPortsRoot,
    HANDLE              hSysAudio,
    ULONG               idxDevice,
    ULONG               idxPin,
    BOOL                fOnPrefDev,
    LPWSTR              wszDescription,
    LPSTR               pstrInstanceId,
    ULONG               *plEnumeratedPorts,
    LPWSTR              wszDIName)
{
    ULONG               idxNode;
    KSPIN_DATAFLOW      dataflow;
    SYNTHCAPS           caps;
    DMUS_PORTCAPS       dmpc;

    // First make sure this pin speaks standard KS streaming. If not, we can't use it.
    //
    if (!PinSupportsInterface(hSysAudio, idxPin, KSINTERFACESETID_Standard, KSINTERFACE_STANDARD_STREAMING))
    {
        TraceI(1, "EnumerateSADDevicePin: Pin %d does not support standard streaming\n", idxPin);
        return S_FALSE;
    }

    // Supports standard streaming, now make sure it supports synth format.
    //
    if (!PinSupportsDataRange(hSysAudio, idxPin, KSDATAFORMAT_TYPE_MUSIC, KSDATAFORMAT_SUBTYPE_DIRECTMUSIC))
    {
        TraceI(1, "EnumerateSADDevicePin: Pin %d does not support DirectMusic data range\n", idxPin);
        return S_FALSE;
    }

    // Get the data flow direction
    //
    if (!PinGetDataFlow(hSysAudio, idxPin, &dataflow))
    {
        TraceI(0, "EnumerateSADDevicePin: PinGetDataFlow failed!\n");
        return S_FALSE;
    }

    // Find the synth caps node
    //
    idxNode = FindGuidNode(hSysAudio, idxPin, KSNODETYPE_DMSYNTH_CAPS);
    if (idxNode == -1)
    {
        if ((idxNode = FindGuidNode(hSysAudio, idxPin, KSCATEGORY_SYNTHESIZER)) == -1)
        {
            TraceI(1, "EnumerateSADDevicePin: Pin %d has no reachable synthcaps or synth node.\n", idxPin);
            return S_FALSE;
        }
    }

    // Get the caps
    //
    ZeroMemory(&caps, sizeof(caps));
    if (!GetFilterCaps(hSysAudio, idxNode, &caps))
    {
        TraceI(0, "EnumerateSADDevicePin: Pin %d with synth node failed caps!\n", idxPin);
        return S_FALSE;
    }

    TraceI(2, "Pin %d works for %s\n",
             idxPin,
             (dataflow == KSPIN_DATAFLOW_OUT) ? "capture" : "render");

    ZeroMemory(&dmpc, sizeof(dmpc));
    dmpc.dwSize = sizeof(dmpc);

    dmpc.dwClass                = dataflow == KSPIN_DATAFLOW_OUT ? DMUS_PC_INPUTCLASS : DMUS_PC_OUTPUTCLASS;
    dmpc.dwType                 = DMUS_PORT_KERNEL_MODE;

    wcscpy(dmpc.wszDescription, wszDescription);

    dmpc.guidPort               = caps.Guid;
    dmpc.dwFlags                = caps.Flags;
    dmpc.dwMemorySize           = caps.MemorySize;
    dmpc.dwMaxChannelGroups     = caps.MaxChannelGroups;
    dmpc.dwMaxVoices            = caps.MaxVoices;
    dmpc.dwMaxAudioChannels     = caps.MaxAudioChannels;
    dmpc.dwEffectFlags          = caps.EffectFlags;


    PORTENTRY *pPort = NULL;

    // We may have to fixup the guids

    pPort = pDirectMusic->GetPortByGUID(dmpc.guidPort);

    while(pPort != NULL)
    {
        //The port is in the list

        //Is this port the same as another one?
        if (wcscmp(wszDIName,pPort->wszDIName)==0 && idxPin == pPort->idxPin)
        {
            // The GUID and DeviceID and the PIN# Match
            // This is great, lets get outta the loop
            pPort = NULL;
        }
        else
        {
            //The GUID is in use by another device
            //We need to increment the guid and try again
            dmpc.guidPort.Data1++;

            //Get the new port.
            pPort = pDirectMusic->GetPortByGUID(dmpc.guidPort);
        }

    }

    pDirectMusic->AddDevice(dmpc,
                  ptWDMDevice,
                  idxDevice,
                  idxPin,
                  idxNode,
                  (caps.Flags & SYNTH_PC_SOFTWARESYNTH) ? FALSE : fOnPrefDev,
                  hkPortsRoot,
                  wszDIName,
                  pstrInstanceId);
    ++*plEnumeratedPorts;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CreateCDirectMusicPort
//
HRESULT
CreateCDirectMusicPort(
                       PORTENTRY *pPE,
                       CDirectMusic *pDM,
                       LPDMUS_PORTPARAMS pPortParams,
                       IDirectMusicPort **ppPort)
{
    HRESULT hr = S_OK;
    CDirectMusicPort *pPort = NULL;

    try
    {
        pPort = new CDirectMusicPort(pPE, pDM);
    } catch(...)
    {
    }

    if (pPort == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = pPort->Init(pPortParams);
    }

    if (SUCCEEDED(hr))
    {
        *ppPort = static_cast<IDirectMusicPort*>(pPort);
    }
    else
    {
        delete pPort;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::CDirectMusicPort

CDirectMusicPort::CDirectMusicPort(PORTENTRY *pPE,
                                   CDirectMusic *pDM) :
m_cRef(1),
m_pDM(pDM),
m_hUnloadThread(NULL),
m_phUnloadEventList(NULL),
m_hCaptureWake(NULL),
m_phNewUnloadEventList(NULL),
m_hCopiedEventList(NULL),
m_dwNumEvents(0),
m_dwNumEventsAllocated(256),
m_fHasActivated(FALSE),
m_pDirectSound(NULL),
m_lActivated(0),
m_pMasterClock(NULL),
m_fShutdownThread(FALSE),
m_pThruMap(NULL),
m_pThruBuffer(NULL),
m_dwChannelGroups(0),
m_fDirectSoundSet(FALSE),
m_hCaptureThread(NULL),
m_fSyncToMaster(TRUE),
m_lTimeOffset(0),
m_pPCClock(NULL)
{
    InterlockedIncrement(&g_cComponent);

    m_fPortCSInitialized = FALSE;
    m_fQueueCSInitialized = FALSE;

    InitializeCriticalSection(&m_DMPortCriticalSection);
    m_fPortCSInitialized = TRUE;

    InitializeCriticalSection(&m_csEventQueues);
    m_fQueueCSInitialized = TRUE;

    InitializeCriticalSection(&m_OverlappedCriticalSection);

    // Note: on pre-Blackcomb OS's, InitializeCriticalSection can raise an exception;
    // if it ever pops in stress, we should add an exception handler and retry loop.

    OverlappedStructs *pOverlappedStructs = new OverlappedStructs;
    if( pOverlappedStructs )
    {
        if( NULL != m_lstOverlappedStructs.AddNodeToList( pOverlappedStructs ) )
        {
            ZeroMemory( pOverlappedStructs->aOverlappedIO, sizeof( OVERLAPPED ) * OVERLAPPED_ARRAY_SIZE );
            ZeroMemory( pOverlappedStructs->afOverlappedInUse, sizeof( BOOL ) * OVERLAPPED_ARRAY_SIZE );
            ZeroMemory( pOverlappedStructs->apOverlappedBuffer, sizeof( BYTE * ) * OVERLAPPED_ARRAY_SIZE );
        }
        else
        {
            delete pOverlappedStructs;

            // Don't need to fail - we'll just try to create a new one when PlayBuffer() is called
        }
    }

    m_hPin = INVALID_HANDLE_VALUE;
    m_hSysAudio = INVALID_HANDLE_VALUE;

    m_fIsOutput = (pPE->pc.dwClass == DMUS_PC_OUTPUTCLASS) ? TRUE : FALSE;

    // XXX Can these change? Think about FrankYe's PnP stuff
    //

    dmpc = pPE->pc;
    m_pNotify = NULL;
    m_pClock = NULL;

    m_guidPort = pPE->pc.guidPort;
    m_fAudioDest = pPE->fAudioDest;

    m_fCanDownload = (pPE->pc.dwFlags & DMUS_PC_DLS) ||
                     (pPE->pc.dwFlags & DMUS_PC_DLS2);

    if (!m_fAudioDest)
    {
        m_idxDev = pPE->idxDevice;
        m_idxPin = pPE->idxPin;
        m_idxSynthNode = pPE->idxNode;
    }
    else
    {
        PORTDEST *pChosenDest = NULL;

        CNode<PORTDEST*> *pNode;

        for (pNode = pPE->lstDestinations.GetListHead(); pNode; pNode=pNode->pNext)
        {
            // Choose either first or default
            //
            if (pChosenDest == NULL || pNode->data->fOnPrefDev)
            {
                pChosenDest = pNode->data;
            }
        }

        //So what happens if fOnPrefDev never returns true?
        assert(pChosenDest);

        m_idxDev = pChosenDest->idxDevice;
        m_idxPin = pChosenDest->idxPin;
        m_idxSynthNode = pChosenDest->idxNode;
    }
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::~CDirectMusicPort

CDirectMusicPort::~CDirectMusicPort()
{
    if (m_fPortCSInitialized && m_fQueueCSInitialized)
    {
        Close();

#ifdef DBG
        EnterCriticalSection(&m_DMPortCriticalSection);

        // This list should be empty when we get here
        CDownloadBuffer* pDownload = m_UnloadedList.GetHead();
        if(pDownload)
        {
            assert(false);
        }

        LeaveCriticalSection(&m_DMPortCriticalSection);
#endif
    }

    if (m_fPortCSInitialized)  DeleteCriticalSection(&m_DMPortCriticalSection);
    if (m_fQueueCSInitialized) DeleteCriticalSection(&m_csEventQueues);

    DeleteCriticalSection(&m_OverlappedCriticalSection);

    // Cleanup the array of overlapped structures
    CNode<OverlappedStructs *> *pOverlappedNode, *pOverlappedNext;
    for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode; pOverlappedNode = pOverlappedNext)
    {
        pOverlappedNext = pOverlappedNode->pNext;

        delete pOverlappedNode->data;
        m_lstOverlappedStructs.RemoveNodeFromList(pOverlappedNode);
    }

    InterlockedDecrement(&g_cComponent);
}

struct KS_PORTPARAMS
{
    KSNODEPROPERTY      ksnp;
    SYNTH_PORTPARAMS    spp;
};

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Init
//
HRESULT
CDirectMusicPort::Init(LPDMUS_PORTPARAMS pPortParams)
{
    HRESULT hr = E_FAIL;
    BOOL fValidParamChanged = FALSE;

    // Allocate thru map for 16 channels, since we only have one channel group
    // Initialize to no thruing (destination port is NULL).
    //
    m_pThruMap = new DMUS_THRU_CHANNEL[MIDI_CHANNELS];
    if (m_pThruMap == NULL)
    {
        return E_OUTOFMEMORY;
    }

    DMUS_BUFFERDESC dmbd;
    ZeroMemory(&dmbd, sizeof(dmbd));
    dmbd.dwSize = sizeof(dmbd);
    dmbd.cbBuffer = 4096;               // XXX Where should we get this???

    hr = m_pDM->CreateMusicBuffer(&dmbd, &m_pThruBuffer, NULL);
    if (FAILED(hr))
    {
        TraceI(0, "Failed to create thruing buffer\n");
        return hr;
    }

    ZeroMemory(m_pThruMap, MIDI_CHANNELS * sizeof(DMUS_THRU_CHANNEL));

    // Get a handle to SysAudio
    //
    if (!OpenDefaultDevice(KSCATEGORY_SYSAUDIO, &m_hSysAudio))
    {
        TraceI(0, "CDirectMusicPort::Init failed to open SysAudio\n");
        return E_FAIL;
    }

    if (!SetSysAudioDevice(m_hSysAudio, m_idxDev))
    {
        TraceI(0, "Failed to set device on SysAudio\n");
        goto Cleanup;
    }

    if (!CreateVirtualSource(m_hSysAudio, &m_ulVirtualSourceIndex))
    {
        TraceI(0, "Failed to create virtual source\n");
        goto Cleanup;
    }

    hr = CreatePin(m_hSysAudio, m_idxPin, &m_hPin);
    if (FAILED(hr))
    {
        TraceI(0, "Failed to create pin: %x\n", hr);
        goto Cleanup;
    }

    if (!AttachVirtualSource(m_hPin, m_ulVirtualSourceIndex))
    {
        TraceI(0, "Failed to attach virtual source\n");
        goto Cleanup;
    }

    // Set port params
    //
    if (pPortParams)
    {
        KS_PORTPARAMS kspp;

        ZeroMemory(&kspp, sizeof(kspp));
        kspp.ksnp.Property.Set    = KSPROPSETID_Synth;
        kspp.ksnp.Property.Id     = KSPROPERTY_SYNTH_PORTPARAMETERS;
        kspp.ksnp.Property.Flags  = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
        kspp.ksnp.NodeId          = m_idxSynthNode;
        kspp.ksnp.Reserved        = 0;
        kspp.spp.ValidParams      = pPortParams->dwValidParams;
        kspp.spp.Voices           = pPortParams->dwVoices;
        kspp.spp.ChannelGroups    = pPortParams->dwChannelGroups;
        kspp.spp.AudioChannels    = pPortParams->dwAudioChannels;
        kspp.spp.SampleRate       = pPortParams->dwSampleRate;
        kspp.spp.EffectsFlags     = pPortParams->dwEffectFlags;
        kspp.spp.Share            = pPortParams->fShare;

        assert
        (
            DMUS_PORTPARAMS_VOICES == SYNTH_PORTPARAMS_VOICES &&
            DMUS_PORTPARAMS_CHANNELGROUPS == SYNTH_PORTPARAMS_CHANNELGROUPS &&
            DMUS_PORTPARAMS_AUDIOCHANNELS == SYNTH_PORTPARAMS_AUDIOCHANNELS &&
            DMUS_PORTPARAMS_SAMPLERATE == SYNTH_PORTPARAMS_SAMPLERATE &&
            DMUS_PORTPARAMS_EFFECTS == SYNTH_PORTPARAMS_EFFECTS &&
            DMUS_PORTPARAMS_SHARE == SYNTH_PORTPARAMS_SHARE
        );

        SYNTH_PORTPARAMS spp;
        if (!Property(m_hPin,
                      sizeof(kspp),
                      (PKSIDENTIFIER)&kspp,
                      sizeof(spp),
                      &spp,
                      NULL))
        {
            hr = WIN32ERRORtoHRESULT(GetLastError());
            goto Cleanup;
        }

        if ((pPortParams->dwValidParams != spp.ValidParams) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_VOICES) &&
             (pPortParams->dwVoices != spp.Voices)) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS) &&
             (pPortParams->dwChannelGroups != spp.ChannelGroups)) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_AUDIOCHANNELS) &&
             (pPortParams->dwAudioChannels != spp.AudioChannels)) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_SAMPLERATE) &&
             (pPortParams->dwSampleRate != spp.SampleRate)) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_EFFECTS) &&
             (pPortParams->dwEffectFlags != spp.EffectsFlags)) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_SHARE) &&
             (pPortParams->fShare != (BOOL) spp.Share)))
        {
            fValidParamChanged = TRUE;

            pPortParams->dwValidParams  = spp.ValidParams;
            pPortParams->dwVoices       = spp.Voices;
            pPortParams->dwChannelGroups= spp.ChannelGroups;
            pPortParams->dwAudioChannels= spp.AudioChannels;
            pPortParams->dwSampleRate   = spp.SampleRate;
            pPortParams->dwEffectFlags  = spp.EffectsFlags;
            pPortParams->fShare         = (BOOL) spp.Share;
        }

        TraceI(0, "dmport: create: fValidParamChanged %d\n",
            (int)fValidParamChanged);

        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
        {
            m_dwChannelGroups = pPortParams->dwChannelGroups;
        }
        else if (FAILED(GetNumChannelGroups(&m_dwChannelGroups)))
        {
            m_dwChannelGroups = 1;
        }

        if (m_fIsOutput)
        {
            InitChannelPriorities(1, m_dwChannelGroups);
        }
    }

    // create latency clock
    //
    m_pClock = new CPortLatencyClock(m_hPin, m_idxSynthNode, this);
    if (!m_pClock)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Get our notification interface
    //
    hr = m_pDM->QueryInterface(IID_IDirectMusicPortNotify, (void**)&m_pNotify);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    m_pNotify->Release();

    if (m_fIsOutput)
    {
        // Render only
        //
        // set volume boost default (zero)
        //

        KSNODEPROPERTY ksnp;
        LONG lVolume;

        ksnp.Property.Set   = KSPROPSETID_Synth;
        ksnp.Property.Id    = KSPROPERTY_SYNTH_VOLUMEBOOST;
        ksnp.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
        ksnp.NodeId         = m_idxSynthNode;
        ksnp.Reserved       = 0;

        lVolume = 0;

        if (!Property(m_hPin,
                      sizeof(ksnp),
                      (PKSIDENTIFIER)&ksnp,
                      sizeof(lVolume),
                      &lVolume,
                      NULL))
        {
            if (!(dmpc.dwFlags & DMUS_PC_EXTERNAL))
            {
                hr = WIN32ERRORtoHRESULT(GetLastError());
                TraceI(0, "Could not set default volume boost %08X\n", hr);
                goto Cleanup;
            }
        }

        // Initialize download. This creates all the events needed for asynchronously
        // dealing with unload.
        //
        hr = InitializeDownloadObjects();
    }
    else
    {
        // Capture only
        //
        // Set up the thread to post multiple IRP's to the pin and queue the data
        // when it gets to user mode.
        //
        hr = InitializeCapture();
    }

    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = m_pDM->GetMasterClock(NULL, &m_pMasterClock);
    if (FAILED(hr))
    {
        TraceI(0, "Failed to get master clock\n");
        goto Cleanup;
    }

#if 0
    // We need to get the handle from the master clock and pass it down to the
    // pin so the timebase will be the same.
    //
    IMasterClockPrivate *pPrivate;

    hr = m_pMasterClock->QueryInterface(IID_IMasterClockPrivate, (void**)&pPrivate);
    if (FAILED(hr))
    {
        TraceI(0, "Master clock is not a Ks clock -- cannot instantiate WDM port!\n");
        goto Cleanup;
    }

    HANDLE hClock;
    hr = pPrivate->GetParam(GUID_KsClockHandle, &hClock, sizeof(hClock));
    pPrivate->Release();

    if (FAILED(hr))
    {
        TraceI(0, "Could not get handle of Ks clock\n");
        goto Cleanup;
    }
#endif  // WIN95

    PinSetState(KSSTATE_STOP);

#if 0

    KSPROPERTY ksp;

    ksp.Set =   KSPROPSETID_Stream;
    ksp.Id =    KSPROPERTY_STREAM_MASTERCLOCK;
    ksp.Flags = KSPROPERTY_TYPE_SET;

    if (!Property(m_hPin,
                  sizeof(ksp),
                  (PKSIDENTIFIER)&ksp,
                  sizeof(HANDLE),
                  &hClock,
                  NULL))
    {
        hr = WIN32ERRORtoHRESULT(GetLastError());
        TraceI(0, "Could not set the master clock handle on the kernel pin %08X\n", hr);
        goto Cleanup;
    }
#endif

    PinSetState(KSSTATE_PAUSE);

    TraceI(2, "CDirectMusicPort::Init() Pin %p\n", m_hPin);

    // If we have WDM ports, then the default master clock will be the
    // portcls clock.
    //
    hr = m_pDM->GetMasterClockWrapperI()->CreateDefaultMasterClock(&m_pPCClock);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;

    hr = m_pMasterClock->GetTime(&rtMasterClock);
    if (SUCCEEDED(hr))
    {
        hr = m_pPCClock->GetTime(&rtSlaveClock);
    }

    if (FAILED(hr))
    {
        goto Cleanup;
    }

    m_lTimeOffset = rtMasterClock - rtSlaveClock;


    if (fValidParamChanged)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    if (FAILED(hr))
    {
        Close();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
//
// InitializeDownloadObjects
//
// Create the events to handle asynchronous download notification and
// start the download thread.
//
HRESULT
CDirectMusicPort::InitializeDownloadObjects()
{
    m_phUnloadEventList = new HANDLE[m_dwNumEventsAllocated];
    if (m_phUnloadEventList == NULL)
    {
        TraceI(0, "Failed to alloc memory for unload event list\n");
        return E_OUTOFMEMORY;
    }

    // Used to Kill the unload thread
    m_phUnloadEventList[0] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_phUnloadEventList[0] == NULL)
    {
        TraceI(0, "Failed to create kill event\n");
        return E_FAIL;
    }
    m_dwNumEvents++;

    // Used to Wake unload thread
    m_phUnloadEventList[1] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_phUnloadEventList[1] == NULL)
    {
        TraceI(0, "Failed to create wake event\n");
        return E_FAIL;
    }
    m_dwNumEvents++;


    // Used for asynchronously sending down events

    m_phUnloadEventList[2] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_phUnloadEventList[2] == NULL)
    {
        TraceI(0, "Failed to create overlapped struct event\n");
        return E_FAIL;
    }
    m_dwNumEvents++;

    // Now, use the same event for all the OVERLAPPED structures
    EnterCriticalSection( &m_OverlappedCriticalSection );
    CNode<OverlappedStructs *> *pOverlappedNode;
    for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode; pOverlappedNode = pOverlappedNode->pNext)
    {
        OverlappedStructs *pOverlappedStructs = pOverlappedNode->data;
        if( pOverlappedStructs )
        {
            for( int iEvent = 0; iEvent < OVERLAPPED_ARRAY_SIZE; iEvent++ )
            {
                pOverlappedStructs->aOverlappedIO[iEvent].hEvent = m_phUnloadEventList[2];
            }
        }
    }
    LeaveCriticalSection( &m_OverlappedCriticalSection );


    m_hCopiedEventList = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_hCopiedEventList == NULL)
    {
        TraceI(0, "Failed to create copy event\n");
        return E_FAIL;
    }

    DWORD dwThreadId;

    m_hUnloadThread = CreateThread(NULL, 0, ::FreeWDMHandle, this, 0, &dwThreadId);
    if(m_hUnloadThread == NULL)
    {
        TraceI(0, "Failed to create unload thread\n");
        return E_FAIL;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
// InitializeCapture
//
HRESULT
CDirectMusicPort::InitializeCapture()
{
    DWORD dwError;
    DWORD dwThreadId;

    m_hCaptureWake = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_hCaptureWake == NULL)
    {
        dwError = GetLastError();
        TraceI(0, "Failed to create capture thread wakeup event %d\n", dwError);
        return WIN32ERRORtoHRESULT(dwError);
    }

    m_hCaptureThread = CreateThread(NULL, 0, ::CaptureThread, this, 0, &dwThreadId);
    if (m_hCaptureThread == NULL)
    {
        dwError = GetLastError();
        TraceI(0, "Failed to create capture thread %d\n", dwError);
        return WIN32ERRORtoHRESULT(dwError);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::QueryInterface

STDMETHODIMP
CDirectMusicPort::QueryInterface(const IID &iid,
                                 void **ppv)
{
    V_INAME(IDirectMusicPort::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicPort)
    {
        *ppv = static_cast<IDirectMusicPort*>(this);
    }
    else if (iid == IID_IDirectMusicPortP)
    {
        *ppv = static_cast<IDirectMusicPortP*>(this);
    }
    else if (iid == IID_IDirectMusicPortDownload)
    {
        *ppv = static_cast<IDirectMusicPortDownload*>(this);
    }
    else if (iid == IID_IDirectMusicPortPrivate)
    {
        *ppv = static_cast<IDirectMusicPortPrivate*>(this);
    }
    else if (iid == IID_IKsControl)
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else if (iid == IID_IDirectMusicThru)
    {
        *ppv = static_cast<IDirectMusicThru*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }


    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::AddRef

STDMETHODIMP_(ULONG)
CDirectMusicPort::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Release

STDMETHODIMP_(ULONG)
CDirectMusicPort::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {

        if (m_pNotify)
        {
            m_pNotify->NotifyFinalRelease(static_cast<IDirectMusicPort*>(this));
        }

        delete this;
        return 0;
    }

    return m_cRef;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | Compact | Compacts downloaded DLS data to create a large chunk of contiguous sample memory.
//
// @comm
// The IDirectMusicPort::Compact method is used to instruct the hardware
// or driver to compact DLS/wavetable memory, thus making the largest
// possible contiguous chunk of memory available for new instruments to
// be downloaded.  This method is only valid for an output port that
// supports wavetable synthesis.  This call is passed directly to the
// driver, which handles compacting of the memory whether it is on the
// card or in host memory.
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully.
//
STDMETHODIMP
CDirectMusicPort::Compact()
{
    KSNODEPROPERTY      ksnp;

    // Compact takes no parameters
    //
    ksnp.Property.Set     = KSPROPSETID_Synth_Dls;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_DLS_COMPACT;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;

    ksnp.NodeId           = m_idxSynthNode;
    ksnp.Reserved         = 0;

    if (!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                  0,
                  NULL,
                  NULL))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | GetCaps | Gets the capabilities of the port.
//
// @comm
// The IDirectMusicPort::GetCaps method retrieves the port's capabilities.
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If the <p pPortCaps> pointer is invalid.
// @flag E_INVALIDARG | If the <p PortCaps> struct pointed to is not the correct size.
//
STDMETHODIMP
CDirectMusicPort::GetCaps(
    LPDMUS_PORTCAPS pPortCaps)          // @parm Pointer to the <t DMUS_PORTCAPS> structure to receive the capabilities of the port.
{
    V_INAME(IDirectMusicPort::GetCaps);
    V_STRUCTPTR_WRITE(pPortCaps, DMUS_PORTCAPS);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    CopyMemory(pPortCaps, &dmpc, sizeof(DMUS_PORTCAPS));
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | DeviceIoControl | Performs a DeviceIoControl on the underlying
// file handle implementing the port.
//
// @comm
// This method wraps a call to the system DeviceIoControl API on the file handle implementing
// the port. This method is only supported on ports implemented by a WDM filter graph. In the
// case of a WDM filter graph, the file handle used will be the topmost pin in the graph.
//
// DirectMusic reserves the right to refuse to perform defined KS operations on a pin which
// might collide with operations it is performing on the filter graph. User defined operations,
// however, will never be blocked.
//
// For more information on the semantics of the DeviceIoControl call, see the Win32 API documentation.
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If any of the passed pointers were invalid.
// @flag E_NOTIMPL | If the port is not a WDM port.
// @flag E_INVALIDARG | If the specified IO control code is not allowed (such as IOCTL_KS_PROPERTY).
//
// Other return codes as defined by the system DeviceIoControl API call or the underlying driver responding
// to the call.
//
STDMETHODIMP
CDirectMusicPort::DeviceIoControl(
    DWORD dwIoControlCode,              // @parm Control code of operation to perform
    LPVOID lpInBuffer,                  // @parm Pointer to buffer to supply input data
    DWORD nInBufferSize,                // @parm Size of input buffer
    LPVOID lpOutBuffer,                 // @parm Pointer to buffer to receive output buffer
    DWORD nOutBufferSize,               // @parm Size of output buffer
    LPDWORD lpBytesReturned,            // @parm Pointer to variable to receive output byte count
    LPOVERLAPPED lpOverlapped)          // @parm Pointer to overlapped structure for asynrchronous operation
{
    V_INAME(IDirectMusicPort::DeviceIoControl);
    V_BUFPTR_READ_OPT(lpInBuffer, nInBufferSize);
    V_BUFPTR_WRITE_OPT(lpOutBuffer, nOutBufferSize);
    V_PTR_WRITE(lpBytesReturned, DWORD);
    V_PTR_WRITE(lpOverlapped, OVERLAPPED);

    BOOL fResult;

    if (dwIoControlCode == IOCTL_KS_PROPERTY)
    {
        TraceI(0, "DeviceIoControl: Use IKsControl to set or get property items.");
        return E_INVALIDARG;
    }

    fResult = ::DeviceIoControl(m_hPin,
                                dwIoControlCode,
                                lpInBuffer,
                                nInBufferSize,
                                lpOutBuffer,
                                nOutBufferSize,
                                lpBytesReturned,
                                lpOverlapped);

    return fResult ? S_OK : WIN32ERRORtoHRESULT(GetLastError());
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | SetNumChannelGroups | Sets the number of channel groups requested for this port.
//
// @comm
// The IDirectMusicPort::SetNumChannelGroups method changes the number
// of channel groups that the application needs on the port.  If the
// number of requested channel groups could not be allocated,
// E_INVALIDARG is returned.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_INVALIDARG | If the requested number of channel groups could not be allocated
//
STDMETHODIMP
CDirectMusicPort::SetNumChannelGroups(
    DWORD dwChannelGroups)      // @parm The number of channel groups on this port that the application wants to allocate.
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    KSNODEPROPERTY      ksnp;

    ksnp.Property.Set     = KSPROPSETID_Synth;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_CHANNELGROUPS;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId           = m_idxSynthNode;
    ksnp.Reserved         = 0;

    if (!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                  sizeof(DWORD),
                  &dwChannelGroups,
                  NULL))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    DWORD dwActualChannelGroups = 0;
    ksnp.Property.Set     = KSPROPSETID_Synth;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_CHANNELGROUPS;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId           = m_idxSynthNode;
    ksnp.Reserved         = 0;

    ULONG ulBytesReturned;
    if ((!Property(m_hPin,
                   sizeof(ksnp),
                   (PKSIDENTIFIER)&ksnp,
                   sizeof(DWORD),
                   &dwActualChannelGroups,
                   &ulBytesReturned)) ||
        (ulBytesReturned != sizeof(DWORD)))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    if( dwActualChannelGroups != dwChannelGroups )
    {
        return E_INVALIDARG;
    }

    if (m_fIsOutput && (dwChannelGroups > m_dwChannelGroups))
    {
        InitChannelPriorities(m_dwChannelGroups + 1, dwChannelGroups);
    }

    m_dwChannelGroups = dwChannelGroups;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | GetNumChannelGroups | Gets the number of channel groups used  for this port.
//
// @comm
// The IDirectMusicPort::GetNumChannelGroups method get the number
// of channel groups that the application is using on the port.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If the passed pointer is invalid
//
STDMETHODIMP
CDirectMusicPort::GetNumChannelGroups(
    LPDWORD pdwChannelGroups)      // @parm Contains the number of channel groups currently in use by this port on return
{
    V_INAME(IDirectMusicPort::GetNumChannelGroups);
    V_PTR_WRITE(pdwChannelGroups, DWORD);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    KSNODEPROPERTY      ksnp;

    ksnp.Property.Set     = KSPROPSETID_Synth;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_CHANNELGROUPS;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId           = m_idxSynthNode;
    ksnp.Reserved         = 0;

    ULONG ulBytesReturned;
    if ((!Property(m_hPin,
                   sizeof(ksnp),
                   (PKSIDENTIFIER)&ksnp,
                   sizeof(DWORD),
                   pdwChannelGroups,
                   &ulBytesReturned)) ||
        (ulBytesReturned != sizeof(DWORD)))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | PlayBuffer | Queues a DirectMusicBuffer object for playback.
//
// @comm
// The IDirectMusicPort::PlayBuffer method is used to queue a
// buffer for playback by the port.  The buffer is only in use by the
// system for the duration of this method and is free to be reused after
// this method returns.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If the <p pIBuffer> pointer is invalid.
// @flag E_NOTIMPL | If the port is not an output port.
//
STDMETHODIMP
CDirectMusicPort::PlayBuffer(
    IDirectMusicBuffer *pIBuffer)               // @parm A pointer to an <i IDirectMusicBuffer> interface representing the
                                                // object which should be added to the port's playback queue.
{
    DWORD cbData;
    LPBYTE pbData;
    REFERENCE_TIME rtStart;
    HRESULT hr;

    V_INAME(IDirectMusicPort::PlayBuffer);
    V_INTERFACE(pIBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (!m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    if (!m_lActivated)
    {
        return DMUS_E_SYNTHINACTIVE;
    }

    hr = pIBuffer->GetUsedBytes(&cbData);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pIBuffer->GetRawBufferPtr(&pbData);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pIBuffer->GetStartTime(&rtStart);
    if (FAILED(hr))
    {
        return hr;
    }

    SyncClocks();
    MasterToSlave(&rtStart);

    KSSTREAM_HEADER kssh;
    ULONG cbRet;

    kssh.Size               = sizeof(KSSTREAM_HEADER);
    kssh.TypeSpecificFlags  = 0;

    kssh.PresentationTime.Time        = rtStart;
    kssh.PresentationTime.Numerator   = 1;
    kssh.PresentationTime.Denominator = 1;

    kssh.Duration     = 0;
    kssh.FrameExtent  = cbData;
    kssh.DataUsed     = cbData;
    // Assigned to a temporary buffer later on
    //kssh.Data         = pbData;
    kssh.Data         = 0;
    kssh.OptionsFlags = 0;

    // Try and find an available OVERLAPPED structure
    int iOverlapped;
    OverlappedStructs *pOverlappedStructsToUse = NULL;
    EnterCriticalSection( &m_OverlappedCriticalSection );

    // Iterate through the list of overlapped structure arrays
    CNode<OverlappedStructs *> *pOverlappedNode;
    for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode && !pOverlappedStructsToUse; pOverlappedNode = pOverlappedNode->pNext)
    {
        // get a pointer to each array
        OverlappedStructs *pOverlappedStructs = pOverlappedNode->data;
        if( pOverlappedStructs )
        {
            // Iterate through the array
            for( iOverlapped = 0; iOverlapped < OVERLAPPED_ARRAY_SIZE; iOverlapped++ )
            {
                if( !pOverlappedStructs->afOverlappedInUse[iOverlapped] )
                {
                    // Found a free one - exit the loop
                    pOverlappedStructsToUse = pOverlappedStructs;
                    break;
                }
            }
        }
    }

    // Didn't find a free one
    if( !pOverlappedStructsToUse )
    {
        TraceI(0, "PlayBuffer: Failed to find a free OVERLAPPED structure - trying to free one\n");

        // Iterate through the list of overlapped structure arrays
        for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode && !pOverlappedStructsToUse; pOverlappedNode = pOverlappedNode->pNext)
        {
            // get a pointer to each array
            OverlappedStructs *pOverlappedStructs = pOverlappedNode->data;
            if( pOverlappedStructs )
            {
                // Iterate through the array
                for( iOverlapped = 0; iOverlapped < OVERLAPPED_ARRAY_SIZE; iOverlapped++ )
                {
                    if( HasOverlappedIoCompleted( &(pOverlappedStructs->aOverlappedIO[iOverlapped]) ) )
                    {
                        // Found a completed one - exit the loop and re-use it
                        pOverlappedStructs->aOverlappedIO[iOverlapped].Internal = 0;
                        pOverlappedStructs->aOverlappedIO[iOverlapped].InternalHigh = 0;
                        pOverlappedStructs->aOverlappedIO[iOverlapped].Offset = 0;
                        pOverlappedStructs->aOverlappedIO[iOverlapped].OffsetHigh = 0;
                        delete pOverlappedStructs->apOverlappedBuffer[iOverlapped];
                        pOverlappedStructs->apOverlappedBuffer[iOverlapped] = NULL;
                        pOverlappedStructs->afOverlappedInUse[iOverlapped] = FALSE;

                        pOverlappedStructsToUse = pOverlappedStructs;
                        break;
                    }
                }
            }
        }

        // Still didn't find a free one
        if( !pOverlappedStructsToUse )
        {
            TraceI(0, "PlayBuffer: All OVERLAPPED structures in use - creating new ones\n");

            // Create a new structure with another 200 OVERLAPPED structures
            OverlappedStructs *pOverlappedStructs = new OverlappedStructs;
            if( pOverlappedStructs )
            {
                // If we could allocate the memory, add it to the list
                if( NULL != m_lstOverlappedStructs.AddNodeToList( pOverlappedStructs ) )
                {
                    // Initialize the array of structures
                    ZeroMemory( pOverlappedStructs->aOverlappedIO, sizeof( OVERLAPPED ) * OVERLAPPED_ARRAY_SIZE );
                    ZeroMemory( pOverlappedStructs->afOverlappedInUse, sizeof( BOOL ) * OVERLAPPED_ARRAY_SIZE );
                    ZeroMemory( pOverlappedStructs->apOverlappedBuffer, sizeof( BYTE * ) * OVERLAPPED_ARRAY_SIZE );
                    for( int iEvent = 0; iEvent < OVERLAPPED_ARRAY_SIZE; iEvent++ )
                    {
                        pOverlappedStructs->aOverlappedIO[iEvent].hEvent = m_phUnloadEventList[2];
                    }

                    // Now, flag to use the first item in the new structure
                    pOverlappedStructsToUse = pOverlappedStructs;
                    iOverlapped = 0;
                }
                else
                {
                    // Out of memory - fail
                    delete pOverlappedStructs;
                    LeaveCriticalSection( &m_OverlappedCriticalSection );
                    return E_OUTOFMEMORY;
                }
            }
            else
            {
                // Out of memory - fail
                LeaveCriticalSection( &m_OverlappedCriticalSection );
                return E_OUTOFMEMORY;
            }
        }
    }

    // Try and allocate a buffer to store the memory in while the driver is using it
    pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped] = new BYTE[cbData];
    if( NULL == pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped] )
    {
        // Out of memory - fail
        LeaveCriticalSection( &m_OverlappedCriticalSection );
        return E_OUTOFMEMORY;
    }
    CopyMemory(pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped], pbData, cbData);

    // Set the KS Stream to use the just-allocated buffer
    kssh.Data         = pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped];

    // Mark the OVERLAPPED structure as in use
    pOverlappedStructsToUse->afOverlappedInUse[iOverlapped] = TRUE;

    BOOL fResult;
    fResult = ::DeviceIoControl(m_hPin,
                                IOCTL_KS_WRITE_STREAM,
                                &kssh,
                                sizeof(KSSTREAM_HEADER),
                                &kssh,
                                sizeof(KSSTREAM_HEADER),
                                &cbRet,
                                &(pOverlappedStructsToUse->aOverlappedIO[iOverlapped]));

    // If we failed
    if( !fResult )
    {
        // Get the error code
        DWORD dwErrorCode = GetLastError();

        // If we're just pending
        if( ERROR_IO_PENDING == dwErrorCode )
        {
            // That's expected - return S_OK
            hr = S_OK;
        }
        else
        {
            // Other error - convert to a HRESULT
            hr = WIN32ERRORtoHRESULT( dwErrorCode );

            // Mark the OVERLAPPED structure as free
            pOverlappedStructsToUse->afOverlappedInUse[iOverlapped] = FALSE;
            pOverlappedStructsToUse->aOverlappedIO[iOverlapped].Internal = 0;
            pOverlappedStructsToUse->aOverlappedIO[iOverlapped].InternalHigh = 0;
            pOverlappedStructsToUse->aOverlappedIO[iOverlapped].Offset = 0;
            pOverlappedStructsToUse->aOverlappedIO[iOverlapped].OffsetHigh = 0;

            // Free the memory we allocated
            delete pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped];
            pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped] = NULL;
        }
    }
    else
    {
        // We succeeded - return S_OK
        hr = S_OK;
    }

    LeaveCriticalSection( &m_OverlappedCriticalSection );

    return hr;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | SetReadNotificationHandle | Sets an event to pulse when music data has been captured.
//
// @comm
// The IDirectMusicPort::SetReadNotificationHandle method sets the event
// notification status. This method specifies an event that is to be set
// when MIDI messages are available to be read with the
// <om IDirectMusicPort::Read> method. The event will be pulsed whenever new
// data is available.  To turn off event notification, call
// SetEventNotification with a NULL value for the hEvent parameter.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
//
STDMETHODIMP
CDirectMusicPort::SetReadNotificationHandle(
    HANDLE hEvent)              // @parm  An event handle returned from the Window's CreateEvent call.  It identifies the
                                // event that is to be notified when data is available to be read.
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    m_hAppEvent = hEvent;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | Read | Reads captured music data into a DirectMusicBuffer.
//
// @comm
//
// The IDirectMusicPort::Read method fills the buffer object with
// incoming MIDI data.  Read should be called with new buffer objects
// until no more data is available to be read.  When there is no more
// data to read, the method returns S_FALSE.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If the <p pIBuffer> pointer is invalid.
// @flag E_NOTIMPL | If the port is not an input port.


STDMETHODIMP
CDirectMusicPort::Read(
    IDirectMusicBuffer *pIBuffer)                          // @parm A buffer that will be filled with incoming MIDI data
{
    V_INAME(IDirectMusicPort::Read);
    V_INTERFACE(pIBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }


    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    LPBYTE pbBuffer;
    HRESULT hr = pIBuffer->GetRawBufferPtr(&pbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD cbBuffer;
    hr = pIBuffer->GetMaxBytes(&cbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    TraceI(1, "Read: buffer size %u\n", cbBuffer);

    LPBYTE pbData = pbBuffer;

    // Since events are now buffered, we read them out of the local queue
    //
    //
    EnterCriticalSection(&m_csEventQueues);

    REFERENCE_TIME rtStart= 0;

    if (m_ReadEvents.pFront)
    {
        rtStart = m_ReadEvents.pFront->e.rtDelta;
    }
    else
    {
        TraceI(2, "Read: No events queued\n");
    }

    while (m_ReadEvents.pFront)
    {
        QUEUED_EVENT *pQueuedEvent = m_ReadEvents.pFront;

        DWORD cbQueuedEvent = DMUS_EVENT_SIZE(pQueuedEvent->e.cbEvent);
        TraceI(2, "Read: cbEvent %u  cbQueuedEvent %u\n",
            pQueuedEvent->e.cbEvent,
            cbQueuedEvent);

        if (cbQueuedEvent > cbBuffer)
        {
            TraceI(2, "Read: No more room for events in buffer.\n");
            break;
        }

        TraceI(2, "Read: Got an event!\n");

        pQueuedEvent->e.rtDelta -= rtStart;

        CopyMemory(pbData,
                   &pQueuedEvent->e,
                   sizeof(DMEVENT) - sizeof(DWORD) + pQueuedEvent->e.cbEvent);

        pbData += cbQueuedEvent;
        cbBuffer -= cbQueuedEvent;

        m_ReadEvents.pFront = pQueuedEvent->pNext;

        if (pQueuedEvent->e.cbEvent <= sizeof(DWORD))
        {
            // This event came out of the pool
            //
            m_FreeEvents.Free(pQueuedEvent);
        }
        else
        {
            // This event was allocated via new char[]
            //
            char *pOriginalMemory = (char*)pQueuedEvent;
            delete[] pOriginalMemory;
        }
    }

    if (m_ReadEvents.pFront == NULL)
    {
        m_ReadEvents.pRear = NULL;
    }

    LeaveCriticalSection(&m_csEventQueues);

    // Update the buffer header information to match the events just packed
    //
    TraceI(2, "Read: Leaving with %u bytes in buffer\n", (unsigned)(pbData - pbBuffer));
    pIBuffer->SetStartTime(rtStart);
    pIBuffer->SetUsedBytes((DWORD)(pbData - pbBuffer));

    return (pbData == pbBuffer) ? S_FALSE : S_OK;
}
/*
@struct DMUS_NOTERANGE | Contains a range of notes. An array of
<t DMUS_NOTERANGE> structures is used as an optional parameter
by <om IDirectMusicPort::DownloadInstrument> to
determine which regions within the DLS instrument to download.

@field DWORD | dwSize | Contains the total size in bytes of the structure
@field DWORD | dwLowNote | Sets the low note for the range within the
<i IDirectMusicInstrument> to download.
@field DWORD | dwHighNote | Sets the high note for the range within the
<i IDirectMusicInstrument> to download.

@xref <om IDirectMusicPort::DownloadInstrument>,
<om IDirectMusicPerformance::DownloadInstrument>
*/

/*
@method:(EXTERNAL) HRESULT | IDirectMusicPort | DownloadInstrument |
Downloads an <i IDirectMusicInstrument> to the port.

<om IDirectMusicPort::DownloadInstrument> pulls the
instrument data from <p pInstrument>
and sends it to the synthesizer.

The instrument is parsed and converted into a series of
instrument articulation and wave memory chunks. In addition, if
the waves are compressed, the download operation decompresses the
waves and write the uncompressed data into the memory chunks.

The optional <p pNoteRanges> parameter allows the caller to
economize on allocated memory. When specificed, only the wave and
articulation data for the required ranges of notes are downloaded.

The address of an <i IDirectMusicDownloadedInstrument> interface pointer,
which is later used to unload the instrument, is returned.

@rdesc Returns one of the following:
@flag S_OK | The operation completed successfully.
@flag E_POINTER | If any of the pointers is invalid
@flag E_NOTIMPL | If the port does not support DLS.

@xref <i IDirectMusic>,
<i IDirectMusicPort>,
<om IDirectMusicSynth::Download>,
<om IDirectMusicBand::Download>,
<om IDirectMusicPerformance::DownloadInstrument>
*/
STDMETHODIMP
CDirectMusicPort::DownloadInstrument(
    IDirectMusicInstrument* pInstrument,                        // @parm Contains a pointer to an <i IDirectMusicInstrument> object
                                                                // from which <om IDirectMusicPort::Download> extracts the necessary
                                                                // instrument data to be downloaded.

    IDirectMusicDownloadedInstrument** ppDownloadedInstrument,  // @parm Address of the <i IDirectMusicDownloadedInstrument> interface pointer.
                                                                // This interface pointer is later used to unload the instrument with a call
                                                                // to <om IDirectMusicPort::Unload>.

    DMUS_NOTERANGE* pNoteRanges,                                // @parm An optional pointer to an array of <t DMUS_NOTERANGE>
                                                                // structures. Each <t DMUS_NOTERANGE> structure in the array specifies a
                                                                // contiguous range of MIDI notes to which the instrument must
                                                                // respond. An instrument region will be downloaded only if at least one
                                                                // note in that region is specified in the <t DMUS_NOTERANGE> structures.  If
                                                                // none of the notes contained within a specific instrument region is
                                                                // included in any of the <t DMUS_NOTERANGE> structures, then that region and
                                                                // its associated wave data will not be downloaded. This allows for the
                                                                // more efficient usage of the device's resources as well as improved
                                                                // efficiency of downloads.
                                                                // However, if the entire instrument is desired (and that is usually the
                                                                // case,) <p pNoteRanges> can be set
                                                                // to NULL.

    DWORD dwNumNoteRanges)                                      // @parm The number of <t DMUS_NOTERANGE> structures in the array pointed to by
                                                                // <p pNoteRanges>. If this value is set to 0, <p pNoteRanges> is
                                                                // ignored and all regions and wave data for the instrument are downloaded.
{
    V_INAME(IDirectMusicPort::DownloadInstrument);
    V_INTERFACE(pInstrument);
    V_PTRPTR_WRITE(ppDownloadedInstrument);
    V_BUFPTR_READ(pNoteRanges, (dwNumNoteRanges * sizeof(DMUS_NOTERANGE)));

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (!m_fCanDownload)
    {
        return E_NOTIMPL;
    }

    return CDirectMusicPortDownload::DownloadP(pInstrument,
                                               ppDownloadedInstrument,
                                               pNoteRanges,
                                               dwNumNoteRanges,
                                               TRUE);
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicPort | UnloadInstrument |
Unloads an instrument
previously downloaded with <om IDirectMusicPort::Download>. Once an
instrument has been unloaded it is no longer available to process
MIDI messages.

@rdesc Returns one of the following
@flag S_OK | The operation completed successfully.
@flag E_POINTER | If the <p pDownloadedInstrument> pointer is invalid.
@flag E_NOTIMPL | If the port does not support DLS.

@xref <i IDirectMusic>,
<i IDirectMusicPort>,
<om IDirectMusicSynth::Unload>,
<om IDirectMusicBand::Unload>,
<om IDirectMusicPerformance::UnloadInstrument>
*/

STDMETHODIMP
CDirectMusicPort::UnloadInstrument(
    IDirectMusicDownloadedInstrument* pDownloadedInstrument)    // @parm Pointer to an <i IDirectMusicDownloadedInstrument> interface.
                                                                // This interface pointer was obtained by a call to
                                                                // <om IDirectMusicPort::DownloadInstrument>.
{
    V_INAME(IDirectMusicPort::UnloadInstrument);
    V_INTERFACE(pDownloadedInstrument);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (!m_fCanDownload)
    {
        return E_NOTIMPL;
    }

    return CDirectMusicPortDownload::UnloadP(pDownloadedInstrument);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Download

typedef struct
{
    KSNODEPROPERTY  ksnp;
    SYNTH_BUFFER    dlsBuffer;
} KSPROPERTY_DOWNLOAD;

STDMETHODIMP
CDirectMusicPort::Download(IDirectMusicDownload* pIDMDownload)
{
    V_INAME(IDirectMusicPort::Download);
    V_INTERFACE(pIDMDownload);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    EnterCriticalSection(&m_DMDLCriticalSection);

    // If you can QI pIDMDownload for private interface IDirectMusicDownloadPrivate
    // pIDMDownload is of type CDownloadBuffer.
    IDirectMusicDownloadPrivate* pDMDLP = NULL;
    HRESULT hr = pIDMDownload->QueryInterface(IID_IDirectMusicDownloadPrivate, (void **)&pDMDLP);

    if(SUCCEEDED(hr))
    {
        pDMDLP->Release();

        hr = ((CDownloadBuffer *)pIDMDownload)->IsDownloaded();
        if(hr != S_FALSE)
        {
            LeaveCriticalSection(&m_DMDLCriticalSection);
            return DMUS_E_ALREADY_DOWNLOADED;
        }

        void* pvBuffer = NULL;
        DWORD dwSize;
        hr = ((CDownloadBuffer *)pIDMDownload)->GetBuffer(&pvBuffer, &dwSize);

        if(pvBuffer == NULL)
        {
            hr = DMUS_E_BUFFERNOTSET;
        }

        if(SUCCEEDED(hr))
        {
            KSPROPERTY_DOWNLOAD kspDownload;
            SYNTHDOWNLOAD sd;
            ULONG ulBytesReturned;

            ZeroMemory(&kspDownload, sizeof(kspDownload));
            kspDownload.ksnp.Property.Set    = KSPROPSETID_Synth_Dls;
            kspDownload.ksnp.Property.Id     = KSPROPERTY_SYNTH_DLS_DOWNLOAD;
            kspDownload.ksnp.Property.Flags  = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
            kspDownload.ksnp.NodeId          = m_idxSynthNode;
            kspDownload.ksnp.Reserved        = 0;

            kspDownload.dlsBuffer.BufferSize    = dwSize;
            kspDownload.dlsBuffer.BufferAddress = pvBuffer;

            if (!Property(m_hPin,
                          sizeof(kspDownload),
                          (PKSIDENTIFIER)&kspDownload,
                          sizeof(sd),
                          &sd,
                          &ulBytesReturned))
            {
                hr = WIN32ERRORtoHRESULT(GetLastError());
            }
            else if (ulBytesReturned < sizeof(sd))
            {
                hr = DMUS_E_DRIVER_FAILED;
            }
            else
            {
                hr = S_OK;
            }

            if(SUCCEEDED(hr))
            {
                ((CDownloadBuffer *)pIDMDownload)->m_DLHandle = sd.DownloadHandle;

                // AddRef() before we add it to the list.
                pIDMDownload->AddRef();
                DWORD dwID = ((DMUS_DOWNLOADINFO*)pvBuffer)->dwDLId;
                ((CDownloadBuffer *)pIDMDownload)->m_dwDLId = dwID;
                m_DLBufferList[dwID % DLB_HASH_SIZE].AddHead((CDownloadBuffer*)pIDMDownload);

                ((CDownloadBuffer*)pIDMDownload)->IncDownloadCount();

                if(sd.Free)
                {
                    pvBuffer = NULL;
                    DWORD dw;
                    ((CDownloadBuffer *)pIDMDownload)->GetHeader(&pvBuffer, &dw);
                    ((CDownloadBuffer *)pIDMDownload)->SetBuffer(NULL, 0, 0);
                    delete [] pvBuffer;
                }
                else
                {
                    // If we do not free buffer we need to AddRef()
                    // We do not want buffer to go away until the IDirectMusicPort is
                    // finished with it.
                    pIDMDownload->AddRef();
                }
            }
            else if(FAILED(hr))
            {
                ((CDownloadBuffer *)pIDMDownload)->m_DLHandle = NULL;
            }
        }
    }

    LeaveCriticalSection(&m_DMDLCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Unload

STDMETHODIMP
CDirectMusicPort::Unload(IDirectMusicDownload* pIDMDownload)
{
    V_INAME(IDirectMusicPort::Unload);
    V_INTERFACE(pIDMDownload);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    EnterCriticalSection(&m_DMDLCriticalSection);

    // If you can QI pIDMDownload for private interface IDirectMusicDownloadPrivate
    // pIDMDownload is of type CDownloadBuffer.
    IDirectMusicDownloadPrivate* pDMDLP = NULL;
    HRESULT hr = pIDMDownload->QueryInterface(IID_IDirectMusicDownloadPrivate, (void **)&pDMDLP);

    if(SUCCEEDED(hr))
    {
        pDMDLP->Release();

        if (((CDownloadBuffer *)pIDMDownload)->IsDownloaded() == S_OK)
        {
            if(((CDownloadBuffer *)pIDMDownload)->DecDownloadCount() == 0)
            {
                m_DLBufferList[((CDownloadBuffer *)pIDMDownload)->m_dwDLId % DLB_HASH_SIZE].Remove((CDownloadBuffer *)pIDMDownload);

#if 0
                if(m_dwNumEvents < m_dwNumEventsAllocated)
                {
                    m_phUnloadEventList[m_dwNumEvents] = CreateEvent(NULL, TRUE, FALSE, NULL);
                    m_dwNumEvents++;
                }
                else
                {
                    // Allocate more handles
                }
#endif

                KSNODEPROPERTY ksnp;

                ksnp.Property.Set = KSPROPSETID_Synth_Dls;
                ksnp.Property.Id = KSPROPERTY_SYNTH_DLS_UNLOAD;
                ksnp.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
                ksnp.NodeId = m_idxSynthNode;
                ksnp.Reserved = 0;

                HANDLE hDLHandle = ((CDownloadBuffer *)pIDMDownload)->m_DLHandle;

#if 0
                if (!PropertyAsync(m_hPin,
                                   sizeof(ksnp),
                                   (PKSIDENTIFIER)&ksnp,
                                   sizeof(HANDLE),
                                   &hDLHandle,
                                   NULL,
                                   &(((CDownloadBuffer *)pIDMDownload)->m_DLHandle))) // XXX DLHandle is not currently event handle!!!
                {
                    hr = WIN32ERRORtoHRESULT(GetLastError());
                }
                else
                {
                    void* pBuffer = NULL;
                    ((CDownloadBuffer*)pIDMDownload)->GetBuffer(&pBuffer);

                    if(pBuffer == NULL && WaitForSingleObject((((CDownloadBuffer *)pIDMDownload)->m_DLHandle), 0) == WAIT_OBJECT_0)
                    {
                        pIDMDownload->Release();
                    }
                    else
                    {
                        m_UnloadedList.AddTail((CDownloadBuffer*)pIDMDownload);
                    }

                    hr = S_OK;
                }
#else
                if (!Property(m_hPin,
                              sizeof(ksnp),
                              (PKSIDENTIFIER)&ksnp,
                              sizeof(HANDLE),
                              &hDLHandle,
                              NULL))
                {
                    hr = WIN32ERRORtoHRESULT(GetLastError());
                }
                else
                {
                    pIDMDownload->Release();
                    hr = S_OK;
                }
#endif
            }
        }
        else
        {
            TraceI(0, "CDirectMusicPort::Unload- not downloaded\n");
        }
    }

    LeaveCriticalSection(&m_DMDLCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::GetAppend

STDMETHODIMP
CDirectMusicPort::GetAppend(DWORD* pdwAppend)
{
    V_INAME(IDirectMusicPort::GetAppend);
    V_PTR_WRITE(pdwAppend, DWORD);

    if(!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    KSNODEPROPERTY ksnp;

    ksnp.Property.Set = KSPROPSETID_Synth_Dls;
    ksnp.Property.Id = KSPROPERTY_SYNTH_DLS_APPEND;
    ksnp.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId = m_idxSynthNode;
    ksnp.Reserved = 0;

    ULONG ulBytesReturned;
    if((!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                   sizeof(DWORD),
                   pdwAppend,
                   &ulBytesReturned)) ||
        (ulBytesReturned != sizeof(DWORD)))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | GetLatencyClock | Gets an <i IReferenceClock> which returns the port's latency clock.
//
// @comm
// The IDirectMusicPort::GetLatencyClock is used to get an
// IReferenceClock interface pointer to the port's latency clock.  The
// latency clock specifies the nearest time in the future at which an
// event can be played on time.  The latency clock is based on the
// DirectMusic master clock, which is set with
// <om IDirectMusic::SetMasterClock>.
//
// In accordance with COM rules, GetLatencyClock performs an AddRef on the
// returned interface. Therefore the application must call Release on the returned
// interface at some point.
//
// @rdesc
//
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If the <p ppClock> pointer is invalid
//
STDMETHODIMP
CDirectMusicPort::GetLatencyClock(
    IReferenceClock **ppClock)              // @parm Address of the latency clock's <i IReferenceClock> interface pointer.
{
    V_INAME(IDirectMusicPort::GetLatencyClock);
    V_PTRPTR_WRITE(ppClock);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    m_pClock->AddRef();
    *ppClock = m_pClock;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | GetRunningStats | Gets detailed statistics about the performance of a software synthesizer.
//
// @comm
//
// The IDirectMusicPort::GetRunningStats method fills in a
// <t DMUS_SYNTHSTATS> structure with the current information about the state
// of the port's synthesizer.  See the <t DMUS_SYNTHSTATS> structure for
// details on the type of data that is reported with regards to the
// synthesizer's current status.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | The given <p pStats> pointer was invalid.
// @flag E_INVALIDARG | The given <p pStats> struct was not the correct size.
// @flag E_NOTIMPL | If the port is not a software synthesizer.
//
STDMETHODIMP
CDirectMusicPort::GetRunningStats(
    LPDMUS_SYNTHSTATS pStats)                                // @parm Pointer to the <t DMUS_SYNTHSTATS> structure to receive
                                                            // running statistics of the synthesizer.
{
    V_INAME(IDirectMusicPort::GetRunningStats);
    V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS);

    if(!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    KSNODEPROPERTY ksnp;

    ksnp.Property.Set = KSPROPSETID_Synth;
    ksnp.Property.Id = KSPROPERTY_SYNTH_RUNNINGSTATS;
    ksnp.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId = m_idxSynthNode;
    ksnp.Reserved = 0;

    ULONG ulBytesReturned;

    SYNTH_STATS stats;

    if((!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                  sizeof(stats),
                  &stats,
                  &ulBytesReturned)) ||
        (ulBytesReturned < sizeof(stats)))
    {
        TraceI(1, "GetRunningStats: GetLastError() %d\n", GetLastError());
        return E_NOTIMPL;
    }

    pStats->dwValidStats    = stats.ValidStats;
    pStats->dwVoices        = stats.Voices;
    pStats->dwTotalCPU      = stats.TotalCPU;
    pStats->dwCPUPerVoice   = stats.CPUPerVoice;
    pStats->dwLostNotes     = stats.LostNotes;
    pStats->dwFreeMemory    = stats.FreeMemory;
    pStats->lPeakVolume     = stats.PeakVolume;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Activate

STDMETHODIMP
CDirectMusicPort::Activate(
    BOOL fActivate)
{
    V_INAME(IDirectMusicPort::Activate);


    if (fActivate)
    {
        if (m_fAudioDest && !m_fDirectSoundSet)
        {
            BOOL fGotDSound = FALSE;

            // Note: If any of this fails, will fall back to preferred
            // device set up at port create.
            //
            LPDIRECTSOUND pDSound;
            if (FAILED(m_pDM->GetDirectSoundI(&pDSound)))
            {
                TraceI(0, "Failed to get DSound from DirectMusic object!\n");
            }
            else
            {
                if (SUCCEEDED(SetDirectSoundI(pDSound, NULL, FALSE)))
                {
                    fGotDSound = TRUE;
                }
                else
                {
                    TraceI(0, "Failed to set DSound on port!\n");
                }

                m_pDM->ReleaseDirectSoundI();
            }
        }

        if (InterlockedExchange(&m_lActivated, 1))
        {
            return S_FALSE;
        }
    }
    else
    {
        if (InterlockedExchange(&m_lActivated, 0) == 0)
        {
            return S_FALSE;
        }
    }


    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    BOOL fResult = PinSetState(fActivate ? KSSTATE_RUN : KSSTATE_ACQUIRE);

    if (fResult && fActivate)
    {
        m_fHasActivated = TRUE;
    }

    return fResult ? S_OK : WIN32ERRORtoHRESULT(GetLastError());
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::SetChannelPriority

typedef struct
{
    KSNODEPROPERTY              ksnp;
    SYNTHVOICEPRIORITY_INSTANCE vpi;
} KSPROPERTY_VOICEPRIORITY;

STDMETHODIMP
CDirectMusicPort::SetChannelPriority(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    DWORD dwPriority)
{
    KSPROPERTY_VOICEPRIORITY kvp;

    ZeroMemory(&kvp, sizeof(kvp));
    kvp.ksnp.Property.Set    = KSPROPSETID_Synth;
    kvp.ksnp.Property.Id     = KSPROPERTY_SYNTH_VOICEPRIORITY;
    kvp.ksnp.Property.Flags  = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
    kvp.ksnp.NodeId          = m_idxSynthNode;
    kvp.ksnp.Reserved        = 0;

    kvp.vpi.ChannelGroup = dwChannelGroup;
    kvp.vpi.Channel      = dwChannel;

    ULONG ulBytesReturned;
    if ((!Property(m_hPin,
                   sizeof(kvp),
                   (PKSIDENTIFIER)&kvp,
                   sizeof(DWORD),
                   &dwPriority,
                   &ulBytesReturned)) ||
        (ulBytesReturned != sizeof(DWORD)))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::GetChannelPriority

STDMETHODIMP
CDirectMusicPort::GetChannelPriority(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwPriority)
{
    V_INAME(IDirectMusicPort::GetChannelPriority);
    V_PTR_WRITE(pdwPriority, DWORD);

    KSPROPERTY_VOICEPRIORITY kvp;

    ZeroMemory(&kvp, sizeof(kvp));
    kvp.ksnp.Property.Set    = KSPROPSETID_Synth;
    kvp.ksnp.Property.Id     = KSPROPERTY_SYNTH_VOICEPRIORITY;
    kvp.ksnp.Property.Flags  = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    kvp.ksnp.NodeId          = m_idxSynthNode;
    kvp.ksnp.Reserved        = 0;

    kvp.vpi.ChannelGroup = dwChannelGroup;
    kvp.vpi.Channel      = dwChannel;

    ULONG ulBytesReturned;
    if ((!Property(m_hPin,
                   sizeof(kvp),
                   (PKSIDENTIFIER)&kvp,
                   sizeof(DWORD),
                   pdwPriority,
                   &ulBytesReturned)) ||
        (ulBytesReturned != sizeof(DWORD)))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::SetDirectSound

STDMETHODIMP
CDirectMusicPort::SetDirectSound(
    LPDIRECTSOUND pDirectSound,
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    V_INAME(IDirectMusicPort::SetDirectSound);
    V_INTERFACE_OPT(pDirectSound);
    V_INTERFACE_OPT(pDirectSoundBuffer);

    if (m_fHasActivated)
    {
        return DMUS_E_ALREADY_ACTIVATED;
    }

    if (pDirectSoundBuffer && !pDirectSound)
    {
        return E_INVALIDARG;
    }

    return SetDirectSoundI(pDirectSound, pDirectSoundBuffer, TRUE);
}

HRESULT
CDirectMusicPort::SetDirectSoundI(
    LPDIRECTSOUND pDirectSound,
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer,
    BOOL fSetByUser)
{
    LPSTR pstrInterface = NULL;
    HRESULT hr = DirectSoundDevice(pDirectSound, &pstrInterface);
    if (FAILED(hr))
    {
        return hr;
    }

    PORTENTRY *pPort = m_pDM->GetPortByGUID(m_guidPort);

    LPSTR pstrInstanceId = NULL;

    if ((pPort == NULL) ||
        (!(pPort->fAudioDest)) ||
        (!DINameToInstanceId(pstrInterface, &pstrInstanceId)))
    {
        delete[] pstrInterface;
        return DMUS_E_DRIVER_FAILED;
    }

    // We don't need this anymore
    delete[] pstrInterface;

    CNode<PORTDEST *> *pNode;
    PORTDEST *pDest;

    for (pNode = pPort->lstDestinations.GetListHead();
         pNode;
         pNode = pNode->pNext)
    {
        pDest = pNode->data;

        if (!_stricmp(pDest->pstrInstanceId, pstrInstanceId))
        {
            m_idxDev = pDest->idxDevice;
            m_idxPin = pDest->idxPin;
            m_idxSynthNode = pDest->idxNode;

            delete[] pstrInstanceId;

            if (!m_fDirectSoundSet && fSetByUser)
            {
                m_fDirectSoundSet = TRUE;
            }

            return pDirectSoundBuffer ? DMUS_S_NOBUFFERCONTROL  : S_OK;
        }
    }

    delete[] pstrInstanceId;
    return DMUS_E_DRIVER_FAILED;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::GetFormat

STDMETHODIMP
CDirectMusicPort::GetFormat(
    LPWAVEFORMATEX pwfex,
    LPDWORD pdwwfex,
    LPDWORD pcbBuffer)
{
    V_INAME(IDirectMusicPort::GetFormat);
    V_PTR_WRITE(pdwwfex, DWORD);
    V_BUFPTR_WRITE_OPT(pwfex, *pdwwfex);
    V_PTR_WRITE_OPT(pcbBuffer, DWORD);

    BOOL fSizeQuery = (pwfex == NULL);

    // kernel mode drivers don't use the buffer size parameter
    //

    if (pcbBuffer != NULL)
    {
        *pcbBuffer = 0;
    }

    KSNODEPROPERTY      ksnp;

    ksnp.Property.Set     = KSPROPSETID_Synth_Dls;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_DLS_WAVEFORMAT;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;

    ksnp.NodeId           = m_idxSynthNode;
    ksnp.Reserved         = 0;

    // If we're doing a size query, use a WAVEFORMATEX on the stack
    //
    if (fSizeQuery)
    {
        WAVEFORMATEX wfex;

        DWORD cb = sizeof(WAVEFORMATEX);
        if (!Property(m_hPin,
                      sizeof(ksnp),
                      (PKSIDENTIFIER)&ksnp,
                      cb,
                      &wfex,
                      &cb))
        {
            DWORD dwError = GetLastError();

            if (dwError != ERROR_INSUFFICIENT_BUFFER)
            {
                return WIN32ERRORtoHRESULT(dwError);
            }
        }

        // ERROR_INSUFFICIENT_BUFFER or success (the format fit in our wfex).
        // We should have back the amount of space the driver needed for
        // the format.
        //
        *pdwwfex = cb;
        return S_OK;
    }

    assert(pwfex);

    // Not a size query, just fill the user's wfex buffer
    //
    if (!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                  *pdwwfex,
                  pwfex,
                  pdwwfex))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    return S_OK;
}

// CDirectMusicPort::DownloadWave
//
STDMETHODIMP
CDirectMusicPort::DownloadWave(
    IDirectSoundWave *pWave,
    IDirectSoundDownloadedWaveP **ppWave,
    REFERENCE_TIME rtStartHint)
{
    V_INAME(IDirectMusicPort::DownloadWave);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppWave);

    return E_NOTIMPL;
}

// CDirectMusicPort::UnloadWave
//
STDMETHODIMP
CDirectMusicPort::UnloadWave(
    IDirectSoundDownloadedWaveP *pDownloadedWave)
{
    V_INAME(IDirectMusicPort::UnloadWave);
    V_INTERFACE(pDownloadedWave);

    return E_NOTIMPL;
}


// CDirectMusicPort::AllocVoice
//
STDMETHODIMP
CDirectMusicPort::AllocVoice(
    IDirectSoundDownloadedWaveP *pWave,
    DWORD dwChannel,
    DWORD dwChannelGroup,
    REFERENCE_TIME rtStart,
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd,
    IDirectMusicVoiceP **ppVoice)
{
    V_INAME(IDirectMusicPort::AllocVoice);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppVoice);

    return E_NOTIMPL;
}

// CDirectMusicPort::SetSink
//
STDMETHODIMP
CDirectMusicPort::SetSink(
    IDirectSoundConnect *pSinkConnect)
{
    V_INAME(IDirectMusicPort::SetSink);
    V_INTERFACE(pSinkConnect);

    return E_NOTIMPL;
}

// CDirectMusicPort::GetSink
//
STDMETHODIMP
CDirectMusicPort::GetSink(
    IDirectSoundConnect **ppSinkConnect)
{
    V_INAME(IDirectMusicPort::SetSink);
    V_PTRPTR_WRITE(ppSinkConnect);

    return E_NOTIMPL;
}

// CDirectMusicPort::AssignChannelToBuses
//
STDMETHODIMP
CDirectMusicPort::AssignChannelToBuses(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwBuses,
    DWORD cBusCount)
{
    return E_NOTIMPL;
}

// CDirectMusicPort::ThruChannel
//
STDMETHODIMP
CDirectMusicPort::ThruChannel(
    DWORD dwSourceChannelGroup,
    DWORD dwSourceChannel,
    DWORD dwDestinationChannelGroup,
    DWORD dwDestinationChannel,
    LPDIRECTMUSICPORT pDestinationPort)
{
    V_INAME(IDirectMusicPort::Thru);
    V_INTERFACE_OPT(pDestinationPort);

    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    // Channel group must not be zero (broadcast) but in range 1..NumChannelGroups]
    // (which for legacy is always 1)
    //
    // XXX Fix this!
    //
    if (dwSourceChannelGroup != 1 ||
        dwSourceChannel > 15)
    {
        TraceI(0, "ThruChannel: dwSourceChannelGroup %d is invalid\n", dwSourceChannelGroup);
        return E_INVALIDARG;
    }

    // Given a port means enable thruing for this channel; NULL means
    // disable.
    //
    if (pDestinationPort)
    {
        // Enabling thruing on this channel. First look at the destination port.
        //
        DMUS_PORTCAPS dmpc;
        dmpc.dwSize = sizeof(dmpc);
        HRESULT hr = pDestinationPort->GetCaps(&dmpc);
        if (FAILED(hr))
        {
            TraceI(0, "ThruChannel: Destination port failed portcaps [%08X]\n", hr);
            return hr;
        }

        // Port must be an output port
        //
        if (dmpc.dwClass != DMUS_PC_OUTPUTCLASS)
        {
            return DMUS_E_PORT_NOT_RENDER;
        }

        // Channel group and channel must be in range.
        //
        if (dwDestinationChannel > 15 ||
            dwDestinationChannelGroup > dmpc.dwMaxChannelGroups)
        {
            TraceI(0, "ThruChannel: dwDestinationChannelGroup %d is invalid -or- \n", dwDestinationChannelGroup);
            TraceI(0, "ThruChannel: dwDestinationChannel %d is invalid\n", dwDestinationChannel);
            TraceI(0, "ThruChannel: Destination has %d channel groups\n", dmpc.dwMaxChannelGroups);

            return E_INVALIDARG;
        }

        // Release existing port
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            // Reference to another port type, release it.
            // (NOTE: No need to turn off native dmusic16 thruing at this point,
            // that's handled in dmusic16).
            //
            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
        }


        m_pThruMap[dwSourceChannel].dwDestinationChannel = dwDestinationChannel;
        m_pThruMap[dwSourceChannel].dwDestinationChannelGroup = dwDestinationChannelGroup;
        m_pThruMap[dwSourceChannel].pDestinationPort = pDestinationPort;
        m_pThruMap[dwSourceChannel].fThruInWin16 = FALSE;

        TraceI(2, "ThruChannel: From (%u,%u) -> (%u,%u,%p)\n",
            dwSourceChannelGroup,
            dwSourceChannel,
            dwDestinationChannelGroup,
            dwDestinationChannel,
            pDestinationPort);

        pDestinationPort->AddRef();
    }
    else
    {
        // Disabling thruing on this channel
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
            m_pThruMap[dwSourceChannel].pDestinationPort = NULL;
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Close

STDMETHODIMP
CDirectMusicPort::Close()
{
    if (m_hPin != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hPin);
        m_hPin = INVALID_HANDLE_VALUE;
    }

    if (m_hSysAudio != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hSysAudio);
        m_hSysAudio = INVALID_HANDLE_VALUE;
    }

    if (m_hCaptureThread != NULL)
    {
        m_fShutdownThread = TRUE;
        SetEvent(m_hCaptureWake);
        if (WaitForSingleObject(m_hCaptureThread, 5000) == WAIT_TIMEOUT)
        {
            TraceI(0, "Capture thread refused to die.\n");
        }

        CloseHandle(m_hCaptureThread);
        m_hCaptureThread = NULL;
    }

    if (m_hCopiedEventList != NULL)
    {
        CloseHandle(m_hCopiedEventList);
        m_hCopiedEventList = NULL;
    }

    if (m_phUnloadEventList)
    {
        BOOL bStatus = SetEvent(m_phUnloadEventList[0]);

#ifdef DBG
        if(!bStatus)
        {
            TraceI(0, "Failed to SetEvent used to notify unload thread to terminate\n");
        }
#endif

        if (m_hUnloadThread)
        {
            WaitForSingleObject(m_hUnloadThread, INFINITE);
        }

        // Clean up the OVERLAPPED array

        // Continue waiting until all overlapped IO has completed
        BOOL fContinue = TRUE;
        while( fContinue )
        {
            // First clear the event and fContinue flag
            ResetEvent( m_phUnloadEventList[2] );
            fContinue = FALSE;

            // Check if any IO has not yet completed
            EnterCriticalSection( &m_OverlappedCriticalSection );

            // Iterate through the list of overlapped structure arrays
            CNode<OverlappedStructs *> *pOverlappedNode;
            for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode; pOverlappedNode = pOverlappedNode->pNext)
            {
                // get a pointer to each array
                OverlappedStructs *pOverlappedStructs = pOverlappedNode->data;
                if( pOverlappedStructs )
                {
                    // Iterate through the array
                    for( int iOverlapped = 0; iOverlapped < OVERLAPPED_ARRAY_SIZE; iOverlapped++ )
                    {
                        // Only look at the structures that are in use
                        if( pOverlappedStructs->afOverlappedInUse[iOverlapped] )
                        {
                            if( HasOverlappedIoCompleted( &(pOverlappedStructs->aOverlappedIO[iOverlapped]) ) )
                            {
                                // Found a completed one - clean it up
                                pOverlappedStructs->aOverlappedIO[iOverlapped].Internal = 0;
                                pOverlappedStructs->aOverlappedIO[iOverlapped].InternalHigh = 0;
                                pOverlappedStructs->aOverlappedIO[iOverlapped].Offset = 0;
                                pOverlappedStructs->aOverlappedIO[iOverlapped].OffsetHigh = 0;
                                delete pOverlappedStructs->apOverlappedBuffer[iOverlapped];
                                pOverlappedStructs->apOverlappedBuffer[iOverlapped] = NULL;

                                // Flag the structure as available
                                pOverlappedStructs->afOverlappedInUse[iOverlapped] = FALSE;
                            }
                            else
                            {
                                // Still waiting for the IO to complete
                                fContinue = TRUE;
                            }
                        }
                    }
                }
            }

            LeaveCriticalSection( &m_OverlappedCriticalSection );

            // If continuing, wait until the event is signaled
            if( fContinue )
            {
                if (WaitForSingleObject(m_phUnloadEventList[2], 1000) == WAIT_TIMEOUT)
                {
                    TraceI(0, "Close: overlapped IO is taking very long to complete.\n");
                }
            }
        }

        // Cleanup all allocated events
        for(DWORD dwCount = 0; dwCount < m_dwNumEvents; dwCount++)
        {
            if(m_phUnloadEventList[dwCount])
            {
                CloseHandle(m_phUnloadEventList[dwCount]);
                m_phUnloadEventList[dwCount] = NULL;
            }
        }

        delete [] m_phUnloadEventList;
        m_phUnloadEventList = NULL;
    }

    if (m_hUnloadThread)
    {
        CloseHandle(m_hUnloadThread);
        m_hUnloadThread = NULL;
    }

    if (m_phNewUnloadEventList)
    {
        delete [] m_phNewUnloadEventList;
        m_phNewUnloadEventList = NULL;
    }

    if (m_pClock)
    {
        m_pClock->Release();
        m_pClock = NULL;
    }

    if (m_pPCClock)
    {
        m_pPCClock->Release();
        m_pPCClock = NULL;
    }

    if (m_pDirectSound)
    {
        m_pDirectSound->Release();
        m_pDirectSound = NULL;
    }

    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }

    if (m_pThruMap)
    {
        delete[] m_pThruMap;
        m_pThruMap = NULL;
    }

    if (m_pThruBuffer)
    {
        m_pThruBuffer->Release();
        m_pThruBuffer = NULL;
    }

    m_pDM = NULL;

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::StartVoice
//
STDMETHODIMP CDirectMusicPort::StartVoice(
     DWORD dwVoiceId,
     DWORD dwChannel,
     DWORD dwChannelGroup,
     REFERENCE_TIME rtStart,
     DWORD dwDLId,
     LONG prPitch,
     LONG vrVolume,
     SAMPLE_TIME stVoiceStart,
     SAMPLE_TIME stLoopStart,
     SAMPLE_TIME stLoopEnd)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::StopVoice
//
STDMETHODIMP CDirectMusicPort::StopVoice(
     DWORD dwVoiceId,
     REFERENCE_TIME rtStop)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::GetVoiceState
//
STDMETHODIMP CDirectMusicPort::GetVoiceState(
    DWORD dwVoice[],
    DWORD cbVoice,
    DMUS_VOICE_STATE dwVoiceState[])
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSynthPort::Refresh
//
STDMETHODIMP CDirectMusicPort::Refresh(
    DWORD dwDownloadId,
    DWORD dwFlags)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return E_NOTIMPL;
}

/*
@method:(EXTERNAL) HRESULT | IKsControl | KsProperty | Get or set the value of a property.

This method forwards a property request to the port. A property request consists of a property set
and id to set or get, and associated data. In some cases instance data is required to specify which
instance of a property should should be accessed.

The operation performed and property to be accessed are specicified by a <c KSPROPERTY> structure. This
structure contains Set and Id members which specify the property item to access. The Flags field may contain
exactly one of the following flags to specify the operation:

@flag KSPROPERTY_TYPE_GET | To retrieve the given property item's value
@flag KSPROPERTY_TYPE_SET | To store the given property item's valud
@flag KSPROPERTY_TYPE_BASICSUPPORT | To determine the type of support available for the property set

For KSPROPERTY_TYPE_BASICSUPPORT, the data returned in <p *pvPropertyData> will be a DWORD containing these same
flags indicating which operations are possible.

@ex The following code uses KsProperty to determine if the port supports General MIDI in hardware:

    BOOL IsGMSupported(IDirectMusicPort *pPort)
    {
        HRESULT     hr;
        IKsControl  *pControl;
        KSPROPERTY  ksp;
        DWORD       dwIsSupported;
        ULONG       cb;
        BOOL        fIsSupported;

        hr = pPort->QueryInterface(IID_IKsControl, (void**)&pControl);
        if (FAILED(hr))
        {
            // Port does not support properties, assume no GM support
            //
            return FALSE;
        }

        // Ask about GM
        //
        ksp.Set   = GUID_DMUS_PROP_GM_Hardware;
        ksp.Id    = 0;                            // Per dmusicc.h, item 0 is support, which returns a DWORD boolean
        ksp.Flags = KSPROPERTY_TYPE_GET;          // Retrieve the value

        hr = pControl->KsProperty(&ksp,
                                  sizeof(ksp),    // If there was instance data, it would immediately follow ksp and
                                                  // the length would reflect this.
                                  &dwIsSupported,
                                  sizeof(dwIsSupported),
                                  &cb);

        fIsSupported = FALSE;
        if (SUCCEEDED(hr) || cb >= sizeof(dwIsSupported)
        {
            // Set is supported
            //
            fIsSupported = (BOOL)(dwIsSupported ? TRUE : FALSE);
        }

         pControl->Release();

        return fIsSupported;
    }

@rdesc

@flag S_OK | The operation completed successfully.
@flag E_POINTER | If any pointer parameter invalid
@flag DMUS_E_UNKNOWN_PROPERTY  | If the specified property set or item is unsupported by this port.


*/
STDMETHODIMP
CDirectMusicPort::KsProperty(
        IN PKSPROPERTY  pProperty,              // @parm The property item and operation to perform. If this property contains
                                                // instance data, then that data should reside in memory immediately
                                                // following the KSPROPERTY structure.
        IN ULONG        ulPropertyLength,       // @parm The length of the memory pointed to by <p pProperty>, including any
                                                // instance data.
        IN OUT LPVOID   pvPropertyData,         // @parm For a set operation, a memory buffer containing data representing
                                                // the new value of the property. For a get operation, a memory buffer big
                                                // enough to hold the value of the property. For a basic support query,
                                                // a pointer to a buffer at least the size of a DWORD.
        IN ULONG        ulDataLength,           // @parm The length of the buffer pointed to by <p pvPropertyData>.
        OUT PULONG      pulBytesReturned)       // @parm On a get or basic support call, the number of bytes returned in
                                                // <p pvPropertyData> by the port.
{
    LONG lVolume;

    V_INAME(DirectMusicPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pProperty, ulPropertyLength);
    V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);


    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (ulPropertyLength < sizeof(KSPROPERTY))
    {
        return E_INVALIDARG;
    }

    //Check that the buffer isn't NULL
    //
    if (pvPropertyData == NULL)
    {
        return E_POINTER;
    }

    // Don't let callers touch property sets we use
    //
    if (pProperty->Set == KSPROPSETID_Synth)
    {
        if (pProperty->Id != KSPROPERTY_SYNTH_VOLUME)
        {
            return DMUS_E_UNKNOWN_PROPERTY;
        }
        else if (ulDataLength != sizeof(LONG))
        {
            return E_INVALIDARG;
        }
        else if (pProperty->Flags & KSPROPERTY_TYPE_SET)
        {
            lVolume = *(LONG*)pvPropertyData;

            // Clamp to -200..+20 db
            //
            if (lVolume < -20000)
            {
                lVolume = -20000;
                pvPropertyData = &lVolume;
            }
            else if (lVolume > 2000)
            {
                lVolume = 2000;
                pvPropertyData = &lVolume;
            }
        }
    }
    else if (pProperty->Set == KSPROPSETID_Synth_Dls)
    {
        return DMUS_E_UNKNOWN_PROPERTY;
    }

    // We already have a properly formatted struct; send it down.
    //
    BOOL fResult;
    fResult = SyncIoctl(m_hPin,
                        IOCTL_KS_PROPERTY,
                        pProperty,
                        ulPropertyLength,
                        pvPropertyData,
                        ulDataLength,
                        pulBytesReturned);

    if (!fResult)
    {
        // try topology node
        PKSNODEPROPERTY pksnp = (PKSNODEPROPERTY)new BYTE[sizeof(KSNODEPROPERTY) - sizeof(KSPROPERTY) + ulPropertyLength];
        if (pksnp == NULL)
        {
            return E_OUTOFMEMORY;
        }
        memcpy(&pksnp->Property, pProperty, sizeof(KSPROPERTY));
        pksnp->Property.Flags |= KSPROPERTY_TYPE_TOPOLOGY;
        pksnp->NodeId   = m_idxSynthNode;
        pksnp->Reserved = 0;

        fResult = SyncIoctl(m_hPin,
                            IOCTL_KS_PROPERTY,
                            pksnp,
                            sizeof(KSNODEPROPERTY) - sizeof(KSPROPERTY) + ulPropertyLength,
                            pvPropertyData,
                            ulDataLength,
                            pulBytesReturned);

        delete [] pksnp;
    }

#ifdef DBG
    if (!fResult)
    {
        TraceI(1, "DeviceIoControl: %08X\n", GetLastError());

        TraceI(1, "KS Item: ");
        TraceIGuid(1, &pProperty->Set);
        TraceI(1, "\t#%d\n", pProperty->Id);
        TraceI(1, "\tFlags: %08X\n", pProperty->Flags);
    }
#endif // DBG

    if (!fResult)
    {
        DWORD dwError = GetLastError();

        if (dwError)
        {
            return WIN32ERRORtoHRESULT(dwError);
        }
        else
        {
            return E_NOINTERFACE;
        }
    }

    return S_OK;
}

/*
@method:(EXTERNAL) HRESULT | IKsControl | KsEvent | Enable or disable firing of the given event.

@comm

Currently DirectMusic does not contain support for events.

*/
STDMETHODIMP
CDirectMusicPort::KsEvent(
        IN PKSEVENT     pEvent,
        IN ULONG        ulEventLength,
        IN OUT LPVOID   pvEventData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned)
{
    V_INAME(DirectMusicPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    // We already have a properly formatted struct; send it down.
    //
    BOOL fResult;
    fResult = SyncIoctl(m_hPin,
                        IOCTL_KS_ENABLE_EVENT,  // XXX Fix this!!!
                        pEvent,
                        ulEventLength,
                        pvEventData,
                        ulDataLength,
                        pulBytesReturned);

    if (!fResult)
    {
        // NYI: try topology node
    }

#ifdef DBG
    if (!fResult)
    {
        TraceI(0, "DeviceIoControl: %08X\n", GetLastError());
    }
#endif // DBG

    return fResult ? S_OK : WIN32ERRORtoHRESULT(GetLastError());
}


/*
@method:(EXTERNAL) HRESULT | IKsControl | Method | Calls the specified Ks method.

@comm

Currently DirectMusic does not contain support for methods.

*/
STDMETHODIMP
CDirectMusicPort::KsMethod(
        IN PKSMETHOD    pMethod,
        IN ULONG        ulMethodLength,
        IN OUT LPVOID   pvMethodData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned)
{
    V_INAME(DirectMusicPort::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulMethodLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    // We already have a properly formatted struct; send it down.
    //
    BOOL fResult;
    fResult = SyncIoctl(m_hPin,
                        IOCTL_KS_METHOD,
                        pMethod,
                        ulMethodLength,
                        pvMethodData,
                        ulDataLength,
                        pulBytesReturned);

    if (!fResult)
    {
        // NYI: try topology node
    }

#ifdef DBG
    if (!fResult)
    {
        TraceI(0, "DeviceIoControl: %08X\n", GetLastError());
    }
#endif // DBG

    return fResult ? S_OK : WIN32ERRORtoHRESULT(GetLastError());
}
//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::PinSetState

BOOL CDirectMusicPort::PinSetState(KSSTATE DeviceState)
{
    KSPROPERTY      ksp;

    ksp.Set    = KSPROPSETID_Connection;
    ksp.Id     = KSPROPERTY_CONNECTION_STATE;
    ksp.Flags  = KSPROPERTY_TYPE_SET;

    return Property(m_hPin,
                    sizeof(KSPROPERTY),
                    &ksp,
                    sizeof(DeviceState),
                    &DeviceState,
                    NULL);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::FreeWDMHandle

void CDirectMusicPort::FreeWDMHandle()
{
    while(1)
    {
        // If the unload list has been cleaned up on us, exit the
        // thread. This can happen under really heavy load (like
        // stress) when downloads are being unloaded right at
        // port release time
        //
        DWORD dwIndex;
        try
        {
            // Fix 43266: Make sure both of these are non-zero before calling
            // WaitForMultipleObjects
            if( NULL != m_phUnloadEventList
            &&  0 != m_dwNumEvents )
            {
                dwIndex = WaitForMultipleObjects(m_dwNumEvents,
                                                 m_phUnloadEventList,
                                                 FALSE,
                                                 INFINITE);
            }
            else
            {
                return;
            }
        }
        catch (...)
        {
            return;
        }

        if(dwIndex == 0 || dwIndex == WAIT_FAILED)
        {
            // If first event is signaled or error it is time to die.
            return;
        }
        else if(dwIndex == 1)
        {
            // If second event is signaled we need to changes the objects
            // we are waiting on.
            continue;

        }
        else if(dwIndex == 2 )
        {
            // If third event is signaled, we need to check which
            // OVERLAPPED structures are in use

            // But, first clear the event
            ResetEvent( m_phUnloadEventList[2] );

            EnterCriticalSection( &m_OverlappedCriticalSection );

            // Iterate through the list of overlapped structure arrays
            CNode<OverlappedStructs *> *pOverlappedNode;
            for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode; pOverlappedNode = pOverlappedNode->pNext)
            {
                // get a pointer to each array
                OverlappedStructs *pOverlappedStructs = pOverlappedNode->data;
                if( pOverlappedStructs )
                {
                    // Iterate through the array
                    for( int iOverlapped = 0; iOverlapped < OVERLAPPED_ARRAY_SIZE; iOverlapped++ )
                    {
                        if( pOverlappedStructs->afOverlappedInUse[iOverlapped]
                        &&  HasOverlappedIoCompleted( &(pOverlappedStructs->aOverlappedIO[iOverlapped]) ) )
                        {
                            // Found a completed one - clean it up
                            pOverlappedStructs->aOverlappedIO[iOverlapped].Internal = 0;
                            pOverlappedStructs->aOverlappedIO[iOverlapped].InternalHigh = 0;
                            pOverlappedStructs->aOverlappedIO[iOverlapped].Offset = 0;
                            pOverlappedStructs->aOverlappedIO[iOverlapped].OffsetHigh = 0;
                            delete pOverlappedStructs->apOverlappedBuffer[iOverlapped];
                            pOverlappedStructs->apOverlappedBuffer[iOverlapped] = NULL;

                            // Flag the structure as available
                            pOverlappedStructs->afOverlappedInUse[iOverlapped] = FALSE;
                        }
                    }
                }
            }

            LeaveCriticalSection( &m_OverlappedCriticalSection );
        }
        else if(dwIndex == 3)
        {
            // If fourth event is signaled we need to change our event list
            if(m_phNewUnloadEventList)
            {
                CopyMemory(m_phNewUnloadEventList, m_phUnloadEventList, (sizeof(HANDLE) * m_dwNumEvents));
                delete [] m_phUnloadEventList;
                m_phUnloadEventList = m_phNewUnloadEventList;
                m_phNewUnloadEventList = NULL;
                PulseEvent(m_hCopiedEventList);
            }
            else
            {
                // We should never get here
                assert(false);
                PulseEvent(m_hCopiedEventList);
            }
        }
        else
        {
            assert(dwIndex > 3);
            for(DWORD i = 0; i < m_dwNumEvents; i++)
            {
                DWORD dwState = WaitForSingleObject(m_phUnloadEventList[i], 0);
                if(dwState == WAIT_OBJECT_0)
                {
                    CDownloadBuffer* pDownload = m_UnloadedList.GetHead();
                    for( ; pDownload; pDownload = pDownload->GetNext())
                    {
                        if(m_phUnloadEventList[i] == (((CDownloadBuffer *)pDownload)->m_DLHandle))
                        {
                            void* pvBuffer = NULL;
                            DWORD dw;
                            HRESULT hr = ((CDownloadBuffer *)pDownload)->GetHeader(&pvBuffer, &dw);

                            if(SUCCEEDED(hr))
                            {
                                hr = ((CDownloadBuffer *)pDownload)->SetBuffer(NULL, 0, 0);
                                if(SUCCEEDED(hr))
                                {
                                    delete [] pvBuffer;
                                    pDownload->Release();
                                }
                            }
                            break;
                        }
                    }
                }
#ifdef DBG
                else if(dwState == WAIT_FAILED)
                {
                    assert(false);
                    return;
                }
                else if(dwState == WAIT_ABANDONED)
                {
                    // We should never get here
                    assert(false);
                }
#endif
            }
        }
    }
}

//////////////////////////////////////////////////////////////////////
// FreeWDMHandle

static DWORD WINAPI FreeWDMHandle(LPVOID lpThreadParameter)
{
    ((CDirectMusicPort *)lpThreadParameter)->FreeWDMHandle();

    return 0;
}

//////////////////////////////////////////////////////////////////////
//
// CaptureThread
//
void CDirectMusicPort::CaptureThread()
{
    READ_IRP    irp[POSTED_STREAM_READ_IRPS];
    READ_IRP    *pirp;

    assert(POSTED_STREAM_READ_IRPS + 1 < MAXIMUM_WAIT_OBJECTS);
    HANDLE      aWaitHandles[POSTED_STREAM_READ_IRPS + 1];
    HANDLE      *pWaitHandles;

    ULONG       cbRet;

    // Create events. If this fails, don't go any farther
    //
    ZeroMemory(irp, sizeof(irp));

    for (pirp = &irp[0], pWaitHandles = &aWaitHandles[0];
         pirp <= &irp[POSTED_STREAM_READ_IRPS-1];
         pirp++, pWaitHandles++)
    {
        *pWaitHandles = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (*pWaitHandles == NULL)
        {
            TraceI(0, "Failed to CreateEvent in CaptureThread\n");

            int idx = (int) (pWaitHandles - aWaitHandles);

            pWaitHandles = aWaitHandles;
            while (idx--)
            {
                CloseHandle(*pWaitHandles++);
                return;
            }
        }

        pirp->overlapped.hEvent = *pWaitHandles;
    }

    // Initialize IRP's
    //
    for (pirp = &irp[0]; pirp <= &irp[POSTED_STREAM_READ_IRPS-1]; pirp++)
    {
        pirp->kssh.Size = sizeof(KSSTREAM_HEADER);

        pirp->kssh.PresentationTime.Numerator   = 1;
        pirp->kssh.PresentationTime.Denominator = 1;

        pirp->kssh.FrameExtent  = BYTES_PER_READ_IRP;
        pirp->kssh.Data         = &pirp->buffer[0];

        TraceI(2, "About to DeviceIoControl\n");
        if (!::DeviceIoControl(m_hPin,
                               IOCTL_KS_READ_STREAM,
                               NULL, 0,
                               &pirp->kssh, sizeof(pirp->kssh),
                               &cbRet,
                               &pirp->overlapped))
        {
#ifdef DBG
            DWORD dwError = GetLastError();
            if (dwError != ERROR_IO_PENDING)
            {
                TraceI(0, "CaptureThread: Warning: AsyncIoctl failed %d\n", dwError);
            }
#endif
        }
    }

    // Last event is the thread wakeup event
    //
    aWaitHandles[POSTED_STREAM_READ_IRPS] = m_hCaptureWake;

    // Process events and shove them into the read queue
    //
    for(;;)
    {
        WaitForMultipleObjects(POSTED_STREAM_READ_IRPS + 1,
                               &aWaitHandles[0],
                               FALSE,               // Wake on any, not all
                               INFINITE);

        // First see if the thread is dying. If so, get out of here.
        //
        if (m_fShutdownThread)
        {
            for (pWaitHandles = &aWaitHandles[0];
                 pWaitHandles <= &aWaitHandles[POSTED_STREAM_READ_IRPS-1];
                 pWaitHandles++)
            {
                CloseHandle(*pWaitHandles);
            }

            return;
        }

        // Still alive. Process any queued data.
        //
        for (pirp = &irp[0]; pirp <= &irp[POSTED_STREAM_READ_IRPS-1]; pirp++)
        {
            if (WaitForSingleObject(pirp->overlapped.hEvent, 0) != WAIT_OBJECT_0)
            {
                continue;
            }

            assert(pirp->kssh.PresentationTime.Numerator == pirp->kssh.PresentationTime.Denominator);
            if (pirp->kssh.DataUsed)
            {
                InputWorkerDataReady(pirp->kssh.PresentationTime.Time,
                                     (LPBYTE)pirp->kssh.Data,
                                     pirp->kssh.DataUsed);
                if (m_hAppEvent)
                {
                    try
                    {
                        SetEvent(m_hAppEvent);
                    }
                    catch (...)
                    {
                        Trace(0, "Capture: Application notify event handle prematurely free'd!\n");
                    }
                }
            }

            ResetEvent(pirp->overlapped.hEvent);
            pirp->kssh.DataUsed = 0;
            pirp->kssh.OptionsFlags = 0;

            if (!::DeviceIoControl(m_hPin,
                                   IOCTL_KS_READ_STREAM,
                                   NULL, 0,
                                   &pirp->kssh, sizeof(pirp->kssh),
                                   &cbRet,
                                   &pirp->overlapped))
            {
                if (GetLastError() != ERROR_IO_PENDING)
                {
                    TraceI(0, "CaptureThread: Warning: AsyncIoctl repost failed %d\n", GetLastError());
                }
            }
        }
    }
}

// CDirectMusicPort::InputWorkerDataReady()
//
// The input worker thread has been notified that there is data available.
// Read any pending events from the 16-bit DLL, perform needed thruing, and
// save the data in a queue so we can repackage it on the read request
// from the client.
//
void CDirectMusicPort::InputWorkerDataReady(REFERENCE_TIME rtStart, LPBYTE pbData, ULONG cbData)
{
    DMEVENT *pEvent;
    DWORD cbRounded;

    TraceI(2, "Enter InputWorkerDataReady()\n");

    SyncClocks();
    SlaveToMaster(&rtStart);

    for(;;)
    {
        if (cbData == 0)
        {
            return;
        }

        // Copy temporary buffer as events into queue
        //
        while (cbData)
        {
            pEvent = (DMEVENT*)pbData;
            cbRounded = DMUS_EVENT_SIZE(pEvent->cbEvent);

            TraceI(2, "cbData %u  cbRounded %u\n", cbData, cbRounded);

            if (cbRounded > cbData)
            {
                TraceI(0, "InputWorkerDataReady: Event ran off end of buffer\n");
                break;
            }

            cbData -= cbRounded;
            pbData += cbRounded;

            EnterCriticalSection(&m_csEventQueues);

            QUEUED_EVENT *pQueuedEvent;
            int cbEvent;


            if (pEvent->cbEvent <= sizeof(DWORD))
            {
                // Channel message or other really small event, take from
                // free pool.
                //
                pQueuedEvent = m_FreeEvents.Alloc();
                cbEvent = sizeof(DMEVENT);

                TraceI(4, "Queue [%02X %02X %02X %02X]\n",
                    pEvent->abEvent[0],
                    pEvent->abEvent[1],
                    pEvent->abEvent[2],
                    pEvent->abEvent[3]);
            }
            else
            {
                // SysEx or other long event, just allocate it
                //
                cbEvent = DMUS_EVENT_SIZE(pEvent->cbEvent);
                pQueuedEvent = (QUEUED_EVENT*)new char[QUEUED_EVENT_SIZE(pEvent->cbEvent)];
            }

            if (pQueuedEvent)
            {

                CopyMemory(&pQueuedEvent->e, pEvent, cbEvent);

                // rtDelta is the absolute time of the event while it's in our queue
                //
                pQueuedEvent->e.rtDelta += rtStart;
                ThruEvent(&pQueuedEvent->e);


                if (m_ReadEvents.pFront)
                {
                    m_ReadEvents.pRear->pNext = pQueuedEvent;
                }
                else
                {
                    m_ReadEvents.pFront = pQueuedEvent;
                }

                m_ReadEvents.pRear = pQueuedEvent;
                pQueuedEvent->pNext = NULL;
            }
            else
            {
                TraceI(1, "InputWorker: Failed to allocate event; dropping\n");
            }
            LeaveCriticalSection(&m_csEventQueues);
        }
    }
    TraceI(2, "Leave InputWorkerDataReady()\n");
}

void CDirectMusicPort::ThruEvent(
    DMEVENT *pEvent)
{
    // Since we know we only have one event and we already have it in the right format,
    // just slam it into the thru buffer. We only have to do this because we might modify
    // it.
    //
    LPBYTE pbData;
    DWORD  cbData;
    DWORD  cbEvent = DMUS_EVENT_SIZE(pEvent->cbEvent);

    // First see if the event is thruable
    //
    if (pEvent->cbEvent > 3 || ((pEvent->abEvent[0] & 0xF0) == 0xF0))
    {
        // SysEx of some description
        return;
    }

    DWORD dwSourceChannel = (DWORD)(pEvent->abEvent[0] & 0x0F);

    DMUS_THRU_CHANNEL *pThru = &m_pThruMap[dwSourceChannel];
    if (pThru->pDestinationPort == NULL ||
        pThru->fThruInWin16)
    {
        return;
    }

    if (FAILED(m_pThruBuffer->GetRawBufferPtr(&pbData)))
    {
        TraceI(0, "Thru: GetRawBufferPtr\n");
        return;
    }

    if (FAILED(m_pThruBuffer->GetMaxBytes(&cbData)))
    {
        TraceI(0, "Thru: GetMaxBytes\n");
        return;
    }

    if (cbEvent > cbData)
    {
        TraceI(0, "Thru: cbData %u  cbEvent %u\n", cbData, cbEvent);
        return;
    }

    if (FAILED(m_pThruBuffer->SetStartTime(pEvent->rtDelta)) ||
        FAILED(m_pThruBuffer->SetUsedBytes(cbEvent)))
    {
        TraceI(0, "Thru: buffer setup failed\n");
    }

    CopyMemory(pbData, pEvent, cbEvent);

    pEvent = (DMEVENT*)pbData;
    pEvent->rtDelta = 5 * 10000;
    pEvent->dwChannelGroup = pThru->dwDestinationChannelGroup;
    pEvent->abEvent[0] = (BYTE)((pEvent->abEvent[0] & 0xF0) | pThru->dwDestinationChannel);

    pThru->pDestinationPort->PlayBuffer(m_pThruBuffer);
}


//////////////////////////////////////////////////////////////////////
//
// CaptureThread
//
static DWORD WINAPI CaptureThread(LPVOID lpThreadParameter)
{
    ((CDirectMusicPort *)lpThreadParameter)->CaptureThread();

    return 0;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::InitChannelPriorities

static DWORD adwChannelPriorities[16] =
{
    DAUD_CHAN1_DEF_VOICE_PRIORITY,
    DAUD_CHAN2_DEF_VOICE_PRIORITY,
    DAUD_CHAN3_DEF_VOICE_PRIORITY,
    DAUD_CHAN4_DEF_VOICE_PRIORITY,
    DAUD_CHAN5_DEF_VOICE_PRIORITY,
    DAUD_CHAN6_DEF_VOICE_PRIORITY,
    DAUD_CHAN7_DEF_VOICE_PRIORITY,
    DAUD_CHAN8_DEF_VOICE_PRIORITY,
    DAUD_CHAN9_DEF_VOICE_PRIORITY,
    DAUD_CHAN10_DEF_VOICE_PRIORITY,
    DAUD_CHAN11_DEF_VOICE_PRIORITY,
    DAUD_CHAN12_DEF_VOICE_PRIORITY,
    DAUD_CHAN13_DEF_VOICE_PRIORITY,
    DAUD_CHAN14_DEF_VOICE_PRIORITY,
    DAUD_CHAN15_DEF_VOICE_PRIORITY,
    DAUD_CHAN16_DEF_VOICE_PRIORITY
};

void CDirectMusicPort::InitChannelPriorities(
    UINT uLowCG,
    UINT uHighCG)
{
    while (uLowCG <= uHighCG)
    {
        for (UINT uChannel = 0; uChannel < 16; uChannel++)
        {
            SetChannelPriority(uLowCG, uChannel, adwChannelPriorities[uChannel]);
        }

        uLowCG++;
    }
}

HRESULT WIN32ERRORtoHRESULT(DWORD dwError)
{
    HRESULT                 hr;

    switch(dwError)
    {
        case ERROR_SUCCESS:
            hr = S_OK;
            break;

        case ERROR_INVALID_FUNCTION:
        case ERROR_BAD_COMMAND:
        case ERROR_INVALID_DATA:
        case ERROR_INVALID_PARAMETER:
        case ERROR_INSUFFICIENT_BUFFER:
        case ERROR_NOACCESS:
        case ERROR_INVALID_FLAGS:
            hr = E_INVALIDARG;
            break;

        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_OUTOFMEMORY:
        case ERROR_NO_SYSTEM_RESOURCES:
        case ERROR_NONPAGED_SYSTEM_RESOURCES:
        case ERROR_PAGED_SYSTEM_RESOURCES:
            hr = E_OUTOFMEMORY;
            break;

        case ERROR_NOT_SUPPORTED:
        case ERROR_CALL_NOT_IMPLEMENTED:
        case ERROR_PROC_NOT_FOUND:
        case ERROR_NOT_FOUND:
            hr = E_NOTIMPL;
            break;

        default:
            hr = E_FAIL;
            break;
    }

    return hr;
}


void CDirectMusicPort::MasterToSlave(
    REFERENCE_TIME *prt)
{
    if (m_fSyncToMaster)
    {
        *prt -= m_lTimeOffset;
    }
}

void CDirectMusicPort::SlaveToMaster(
    REFERENCE_TIME *prt)
{
    if (m_fSyncToMaster)
    {
        *prt += m_lTimeOffset;
    }
}

void CDirectMusicPort::SyncClocks()
{
    HRESULT hr;
    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;
    LONGLONG drift;

    if (m_fSyncToMaster)
    {
        hr = m_pMasterClock->GetTime(&rtMasterClock);

        if (SUCCEEDED(hr))
        {
            hr = m_pPCClock->GetTime(&rtSlaveClock);
        }

        if (SUCCEEDED(hr))
        {
            drift = (rtSlaveClock + m_lTimeOffset) - rtMasterClock;

            // Work-around 46782 for DX8 release:
            // If drift is greater than 10ms, jump to the new offset value instead
            // of drifting there slowly.
            if( drift > 10000 * 10
            ||  drift < 10000 * -10 )
            {
                m_lTimeOffset -= drift;
            }
            else
            {
                m_lTimeOffset -= drift / 100;
            }
        }
    }
}

// CPortLatencyClock
//
CPortLatencyClock::CPortLatencyClock(
    HANDLE hPin,
    ULONG ulNodeId,
    CDirectMusicPort *pPort) : m_cRef(1), m_hPin(hPin), m_ulNodeId(ulNodeId), m_pPort(pPort)
{
}

// CPortLatencyClock::~CPortLatencyClock
//
CPortLatencyClock::~CPortLatencyClock()
{
}

// CPortLatencyClock::QueryInterface
//
STDMETHODIMP
CPortLatencyClock::QueryInterface(const IID &iid,
                                  void **ppv)
{
    V_INAME(IReferenceClock::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
    }
    else if (iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

// CPortLatencyClock::AddRef
//
STDMETHODIMP_(ULONG)
CPortLatencyClock::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CPortLatencyClock::Release
//
STDMETHODIMP_(ULONG)
CPortLatencyClock::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CPortLatencyClock::GetTime
//
STDMETHODIMP
CPortLatencyClock::GetTime(
    REFERENCE_TIME *pTime)
{
    V_INAME(IDirectMusicPort:IReferenceClock::GetTime);
    V_PTR_WRITE(pTime, REFERENCE_TIME);

    assert(sizeof(REFERENCE_TIME) == sizeof(ULONGLONG));

    KSNODEPROPERTY      ksnp;

    ksnp.Property.Set     = KSPROPSETID_Synth;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_LATENCYCLOCK;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId           = m_ulNodeId;
    ksnp.Reserved         = 0;

    ULONG ulBytesReturned;
    if (!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                  sizeof(REFERENCE_TIME),
                  pTime,
                  &ulBytesReturned))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    if (ulBytesReturned < sizeof(REFERENCE_TIME))
    {
        return DMUS_E_DRIVER_FAILED;
    }

    if( m_pPort )
    {
        m_pPort->SlaveToMaster( pTime );
    }

    return S_OK;
}

// CPortLatencyClock::AdviseTime
//
STDMETHODIMP
CPortLatencyClock::AdviseTime(
    REFERENCE_TIME baseTime,
    REFERENCE_TIME streamTime,
    HANDLE hEvent,
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

// CPortLatencyClock::AdvisePeriodic
//
STDMETHODIMP
CPortLatencyClock::AdvisePeriodic(
    REFERENCE_TIME startTime,
    REFERENCE_TIME periodTime,
    HANDLE hSemaphore,
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

// CPortLatencyClock::Unadvise
//
STDMETHODIMP
CPortLatencyClock::Unadvise(
    DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmksclk.cpp ===
//
// DMKSClk.CPP
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Wrapper for using a KS clock as the DirectMusic master clock
//
// 
//
#include <objbase.h>
#include <winerror.h>
#include "dmusicp.h"
#include "debug.h"
#include "resource.h"

// Since we only allocate one of these clocks in the entire system,
// this stuff is global.
//

// We have to be able to get the process id of someone with a handle to
// the clock. Since the original creator might go away before other users,
// we store the process id of everyone who uses the clock. This implies
// a max limit on concurrent processes using it.
//
#define MAX_CLOCK_SHARERS   64              // Max processes who can access clock   
                                            // at once.
typedef struct KSCLOCKSHARE
{
    LONG                cRef;               // Count of processes using handle

    struct 
    {
        HANDLE          hKsClock;           // This user's handle and
        DWORD           dwProcessId;        // process id
    } aUsers[MAX_CLOCK_SHARERS];

} *PKSCLOCKSHARE;

class CKsClock : public IReferenceClock, public IMasterClockPrivate
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie); 
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie);
    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // IMasterClockPrivate
    STDMETHODIMP GetParam(REFGUID rguidType, LPVOID pBuffer, DWORD cbSize);

    // Class
    //
    CKsClock();
    ~CKsClock();
    HRESULT Init();

private:
    long m_cRef;

    HRESULT CreateKsClockShared();
    void    DeleteKsClockShared();
    HRESULT CreateKsClockHandle();
    HRESULT DuplicateKsClockHandle();

private:
    static const char m_cszKsClockMemory[];       // Name of shared memory object
    static const char m_cszKsClockMutex[];        // Name of mutex protecting shared memory

    static LONG m_lSharedMemoryInitialized;       // Has this process initialized shared memory?
    static HANDLE m_hFileMapping;                 // File mapping handle for shared memory
    static PKSCLOCKSHARE m_pShared;               // Pointer to shared memory
    static HANDLE m_hKsClockMutex;                // Mutex for shared memory access
    static HANDLE m_hClock;                       // Clock handle in this process
};

static HRESULT CreateKsClock(IReferenceClock **ppClock, CMasterClock *pMasterClock);

const char       CKsClock::m_cszKsClockMemory[] = "DirectMusicKsClock";
const char       CKsClock::m_cszKsClockMutex[]  = "DirectMusicKsClockMutex";

LONG             CKsClock::m_lSharedMemoryInitialized = 0;
HANDLE           CKsClock::m_hFileMapping = NULL;         
PKSCLOCKSHARE    CKsClock::m_pShared = NULL;        
HANDLE           CKsClock::m_hKsClockMutex = NULL;
HANDLE           CKsClock::m_hClock;                

#ifdef DEAD_CODE

// AddKsClocks
//
// Add Ks clock to the list of clocks.
//
HRESULT AddKsClocks(CMasterClock *pMasterClock)
{
    HANDLE hClock;

    // Make sure we can create a default Ks clock
    //
    if (!OpenDefaultDevice(KSCATEGORY_CLOCK, &hClock))
    {
        TraceI(0, "Could not create Ks clock\n");
        return S_FALSE;
    }

    CloseHandle(hClock);

    CLOCKENTRY ce;

    ZeroMemory(&ce, sizeof(ce));
    ce.cc.dwSize = sizeof(ce);
    ce.cc.guidClock = GUID_SysClock;         
    ce.cc.ctType = DMUS_CLOCK_SYSTEM;
    ce.dwFlags = DMUS_CLOCKF_GLOBAL;
    ce.pfnGetInstance = CreateKsClock;

    int cch;
    int cchMax = sizeof(ce.cc.wszDescription) / sizeof(WCHAR);

    char sz[sizeof(ce.cc.wszDescription) / sizeof(WCHAR)];
    cch = LoadString(g_hModule,
                     IDS_SYSTEMCLOCK,
                     sz,
                     sizeof(sz));
    if (cch)
    {
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            sz,
            -1,
            ce.cc.wszDescription,
            sizeof(ce.cc.wszDescription));
    }
    else
    {
        *ce.cc.wszDescription = 0;
    }

    return pMasterClock->AddClock(&ce);
}
#endif

// CreateKsClock
//
// Return an IReferenceClock based on the one Ks clock in the system
//
static HRESULT CreateKsClock(IReferenceClock **ppClock)
{
    HRESULT hr;

    TraceI(0, "Creating KS clock\n");

    CKsClock *pClock = new CKsClock();

    hr = pClock->Init();
    if (FAILED(hr))
    {
        delete pClock;
        return hr;
    }

    hr = pClock->QueryInterface(IID_IReferenceClock, (void**)ppClock);
    pClock->Release();

    return hr;
}

// CKsClock::CKsClock()
//
// 
CKsClock::CKsClock() : 
    m_cRef(1)
{
}

// CKsClock::~CKsClock()
//
// 
CKsClock::~CKsClock()
{
    if (InterlockedDecrement(&m_lSharedMemoryInitialized) == 0)
    {
        DeleteKsClockShared();        
    }
}

// CKsClock::QueryInterface
//
// Standard COM implementation
//
STDMETHODIMP CKsClock::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusic::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else if (iid == IID_IMasterClockPrivate)
    {
        *ppv = static_cast<IMasterClockPrivate*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

// CKsClock::AddRef
// 
STDMETHODIMP_(ULONG) CKsClock::AddRef()
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

// CKsClock::Release
//
STDMETHODIMP_(ULONG) CKsClock::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CKsClock::Init
//
HRESULT CKsClock::Init()
{
    HRESULT hr;

    if (InterlockedIncrement(&m_lSharedMemoryInitialized) == 1)
    {
        hr = CreateKsClockShared();
        if (FAILED(hr))
        {
            return hr;
        }    
    }

    return S_OK;
}

// CKsClock::CreateKsClockShared
//
// Initialize the shared memory object in this process.
// Make sure a handle to the Ks clock exists in this process.
//
HRESULT CKsClock::CreateKsClockShared()
{
    HRESULT hr;
    DWORD dwErr;

    // Create and take the mutex up front. This is neccesary to guarantee that if 
    // we are the first process in the system to create this object, then we do 
    // initialization before anyone else can access the shared memory object.
    //
    m_hKsClockMutex = CreateMutex(NULL,             // Default security descriptor
                                  FALSE,            // Own mutex if we are first instance
                                  m_cszKsClockMutex);
    if (m_hKsClockMutex == NULL)
    {
        TraceI(0, "CreateMutex failed! [%d]\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    WaitForSingleObject(m_hKsClockMutex, INFINITE);

    // Create the file mapping and view of the shared memory, noticing if we are the first 
    // object to create it.
    //
    m_hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE,    // Use paging file
                                       NULL,                    // Default security descriptor
                                       PAGE_READWRITE,  
                                       0,                       // High DWORD of size
                                       sizeof(KSCLOCKSHARE),
                                       m_cszKsClockMemory);
    dwErr = GetLastError();
    if (m_hFileMapping == NULL)
    {
        ReleaseMutex(m_hKsClockMutex);
        
        return HRESULT_FROM_WIN32(dwErr);
    }    

    BOOL fFirst = (dwErr != ERROR_ALREADY_EXISTS);

    m_pShared = (PKSCLOCKSHARE)MapViewOfFile(m_hFileMapping,
                                             FILE_MAP_WRITE,
                                             0, 0,                // Start mapping at the beginning
                                             0);                  // Map entire file
    if (m_pShared == NULL)
    {
        TraceI(0, "MapViewOfFile failed! [%d]\n", GetLastError());

        ReleaseMutex(m_hKsClockMutex);
        return E_OUTOFMEMORY;
    }

    // Initialize the refernce count if we are the first process, and increment
    // it in any case. (Note we're still in the mutex, so we don't need 
    // InterlockedIncrement.
    //
    if (fFirst)
    {
        m_pShared->cRef = 0;
        ZeroMemory(m_pShared->aUsers, sizeof(m_pShared->aUsers));
    }
    ++m_pShared->cRef;

    // If the clock handle doesn't exist yet, create it; else duplicate it. 
    //
    if (m_pShared->cRef == 1)
    {
        hr = CreateKsClockHandle();
    }
    else
    {
        hr = DuplicateKsClockHandle();
    }

    // Release the mutex and return success or failure.
    //
    ReleaseMutex(m_hKsClockMutex);

    return hr;
}

// CKsClock::DeleteKsClockShared
//
// The last instance of CKsClock in this process is being deleted. 
//
void CKsClock::DeleteKsClockShared()
{
    // If the mutex was never created, then none of the other objects could have
    // been created.
    //
    if (m_hKsClockMutex)
    {
        WaitForSingleObject(m_hKsClockMutex, INFINITE);

        if (m_pShared)
        {
            for (int i = 0; i < MAX_CLOCK_SHARERS; i++)
            {
                if (m_pShared->aUsers[i].dwProcessId == GetCurrentProcessId())
                {
                    m_pShared->aUsers[i].dwProcessId = 0;
                    m_pShared->aUsers[i].hKsClock = NULL;

                    break;
                }
            }
        }

        if (m_hClock)
        {
            CloseHandle(m_hClock);
            m_hClock = NULL;
        }        

        if (m_pShared)
        {
            UnmapViewOfFile(m_pShared);
            m_pShared = NULL;
        }

        if (m_hFileMapping)
        {
            CloseHandle(m_hFileMapping);
            m_hFileMapping = NULL;
        }
                
        ReleaseMutex(m_hKsClockMutex);
        CloseHandle(m_hKsClockMutex);                            
    }
}

// CKsClock::CreateKsClockHandle
//
// Create the first and only Ks clock handle in the system
//
HRESULT CKsClock::CreateKsClockHandle()
{
    // Attempt to open the clock
    //
    if (!OpenDefaultDevice(KSCATEGORY_CLOCK, &m_hClock))
    {
        m_hClock = NULL;

        TraceI(0, "Could not create Ks clock\n");
        return E_FAIL;
    }

    KSPROPERTY      ksp;
    KSSTATE			state;

    ksp.Set    = KSPROPSETID_Clock;
    ksp.Id     = KSPROPERTY_CLOCK_STATE;
    ksp.Flags  = KSPROPERTY_TYPE_SET;

	state      = KSSTATE_RUN;

    if (!Property(m_hClock,
                  sizeof(ksp),
                  (PKSIDENTIFIER)&ksp,
                  sizeof(state), 
                  &state,
                  NULL))
    {
        CloseHandle(m_hClock);
        m_hClock = NULL;
        TraceI(0, "Could not set clock into run state\n");
        return E_FAIL;
    }

    // Successful clock open. Since we're creating, we know we're the first
    // instance of the clock and therefore the users array is empty.
    //
    m_pShared->aUsers[0].hKsClock = m_hClock;
    m_pShared->aUsers[0].dwProcessId = GetCurrentProcessId();    

    return S_OK;
}

// CKsClock::DuplicateKsClockHandle
//
// There is already a Ks clock in the system. Duplicate the handle in this process
// context.
//
HRESULT CKsClock::DuplicateKsClockHandle()
{
    // Find another user of the clock; also, find a slot in the users array for
    // this process
    //
    int iEmptySlot = -1;
    int iOtherProcess = -1;
    HANDLE hClock = NULL;

    for (int i = 0; 
         (i < MAX_CLOCK_SHARERS) && (iEmptySlot == -1 || !hClock); 
         i++)
    {
        if (m_pShared->aUsers[i].dwProcessId == 0 && iEmptySlot == -1)
        {
            iEmptySlot = i;
            continue;
        }

        if (hClock)
        {
            continue;
        }            

        HANDLE hOtherProcess = OpenProcess(PROCESS_DUP_HANDLE, 
                                           FALSE,
                                           m_pShared->aUsers[i].dwProcessId);
        if (hOtherProcess == NULL)
        {
            TraceI(0, "OpenProcess: %d\n", GetLastError());
            m_pShared->aUsers[i].dwProcessId = 0;
            m_pShared->aUsers[i].hKsClock = NULL;
            continue;
        }

        BOOL fSuccess = DuplicateHandle(hOtherProcess,
                                        m_pShared->aUsers[i].hKsClock,
                                        GetCurrentProcess(),
                                        &hClock,
                                        GENERIC_READ|GENERIC_WRITE,
                                        FALSE,
                                        0);
        if (!fSuccess)
        {
            TraceI(0, "DuplicateHandle: %d\n", GetLastError());
        }

        CloseHandle(hOtherProcess);

        if (!fSuccess)
        {
            // Other process exists, but could not duplicate handle
            //
            m_pShared->aUsers[i].dwProcessId = 0;
            m_pShared->aUsers[i].hKsClock = NULL;

            hClock = NULL;
        }
    }

    assert(iEmptySlot != -1);
    assert(hClock);

    m_hClock = hClock;

    m_pShared->aUsers[iEmptySlot].dwProcessId = GetCurrentProcessId();
    m_pShared->aUsers[iEmptySlot].hKsClock = hClock;

    return S_OK;
}

STDMETHODIMP 
CKsClock::GetTime(REFERENCE_TIME *pTime)
{
    KSPROPERTY ksp;

    ksp.Set   = KSPROPSETID_Clock;
    ksp.Id    = KSPROPERTY_CLOCK_TIME;
    ksp.Flags = KSPROPERTY_TYPE_GET;

    if (!Property(m_hClock,
                  sizeof(ksp),
                  (PKSIDENTIFIER)&ksp,
                  sizeof(*pTime),
                  pTime,
                  NULL))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }           
    
    return S_OK;
}

STDMETHODIMP 
CKsClock::AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CKsClock::AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CKsClock::Unadvise(DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}

//
// CKsClock::GetParam (IMasterClockPrivate)
//
// This method is used internally by the port to get the user mode handle of the Ks clock
// we're using. The handle is then downloaded to kernel mode where it is referenced as a
// file object and used by the filters as the timebase as well.
//
STDMETHODIMP 
CKsClock::GetParam(REFGUID rguidType, LPVOID pBuffer, DWORD cbSize)
{
    if (rguidType == GUID_KsClockHandle)
    {
        if (cbSize != sizeof(HANDLE))
        {
            return E_INVALIDARG;
        }

        *(LPHANDLE)pBuffer = m_hClock;
        return S_OK;
    }

    return DMUS_E_TYPE_UNSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmportdl.cpp ===
//
// dmportdl.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
//

#include "debug.h"
#include "dmusicp.h"
#include "dminstru.h"
#include "dminsobj.h"
#include "dmdlinst.h"
#include "dmportdl.h"
#include "dswave.h"
#include "validate.h"
#include "dmvoice.h"
#include <limits.h>

DWORD CDirectMusicPortDownload::sNextDLId = 0;
CRITICAL_SECTION CDirectMusicPortDownload::sDMDLCriticalSection;

 
#ifdef DMUS_GEN_INS_DATA
void writewave(IDirectMusicDownload* pDMDownload, DWORD dwId);
void writeinstrument(IDirectMusicDownload* pDMDownload, DWORD dwId);
#endif

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::CDirectMusicPortDownload

CDirectMusicPortDownload::CDirectMusicPortDownload() :
m_cRef(1),
m_fNewFormat(NEWFORMAT_NOT_RETRIEVED),
m_dwAppend(APPEND_NOT_RETRIEVED)
{
    m_fDMDLCSinitialized = m_fCDMDLCSinitialized = FALSE;

    InitializeCriticalSection(&m_DMDLCriticalSection);
    m_fDMDLCSinitialized = TRUE;

    InitializeCriticalSection(&m_CDMDLCriticalSection);
    m_fCDMDLCSinitialized = TRUE;

    // Note: on pre-Blackcomb OS's, InitializeCriticalSection can raise an exception;
    // if it ever pops in stress, we should add an exception handler and retry loop.
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::~CDirectMusicPortDownload

CDirectMusicPortDownload::~CDirectMusicPortDownload()
{
    DWORD dwIndex;
#ifdef DBG
    BOOL fAssert = TRUE;
#endif
    if (m_fDMDLCSinitialized && m_fCDMDLCSinitialized)
    {    
#ifdef DBG
        EnterCriticalSection(&m_CDMDLCriticalSection);
        if (!m_DLInstrumentList.IsEmpty())
        {
            Trace(0, "ERROR: IDirectMusicDownloadedInstrument objects not unloaded before port final release!\n");
            fAssert = FALSE;
        }
        LeaveCriticalSection(&m_CDMDLCriticalSection);

        EnterCriticalSection(&m_DMDLCriticalSection);

        for (dwIndex = 0; dwIndex < DLB_HASH_SIZE; dwIndex++)
        {
            if (!m_DLBufferList[dwIndex].IsEmpty())
            {
                if (fAssert)
                {
                    assert(FALSE);
                    break;
                }
            }
        }
        LeaveCriticalSection(&m_DMDLCriticalSection);
    #endif // DBG

        // remove any bad list items before they are illegally destroyed in list dtor
        EnterCriticalSection(&m_CDMDLCriticalSection);
        if (!m_DLInstrumentList.IsEmpty())
        {
            m_DLInstrumentList.RemoveAll();
        }
        LeaveCriticalSection(&m_CDMDLCriticalSection);

        EnterCriticalSection(&m_DMDLCriticalSection);
        for (dwIndex = 0; dwIndex < DLB_HASH_SIZE; dwIndex++)
        {
            if (!m_DLBufferList[dwIndex].IsEmpty())
            {
                m_DLBufferList[dwIndex].RemoveAll();
            }
        }
        LeaveCriticalSection(&m_DMDLCriticalSection);
    }

    if (m_fDMDLCSinitialized)
    {
        DeleteCriticalSection(&m_DMDLCriticalSection);
    }

    if (m_fCDMDLCSinitialized)
    {
        DeleteCriticalSection(&m_CDMDLCriticalSection);
    }
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::QueryInterface

STDMETHODIMP CDirectMusicPortDownload::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicDownload::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


    if(iid == IID_IUnknown || iid == IID_IDirectMusicPortDownload) 
    {
        *ppv = static_cast<IDirectMusicPortDownload*>(this);
    } 
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::AddRef

STDMETHODIMP_(ULONG) CDirectMusicPortDownload::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::Release

STDMETHODIMP_(ULONG) CDirectMusicPortDownload::Release()
{
    if(!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicPortDownload

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::AllocateBuffer

STDMETHODIMP 
CDirectMusicPortDownload::AllocateBuffer(
    DWORD dwSize,
    IDirectMusicDownload** ppIDMDownload) 
{
    // Argument validation
    V_INAME(CDirectMusicPortDownload::AllocateBuffer);
    V_PTRPTR_WRITE(ppIDMDownload);

    if(dwSize <= 0)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;

    CDownloadBuffer* pdmdl = NULL;
    BYTE* pbuf = new BYTE[dwSize + sizeof(KSNODEPROPERTY)];

    if(pbuf)
    {
        pdmdl = new CDownloadBuffer;
        if(pdmdl)
        {
            hr = pdmdl->SetBuffer(pbuf, sizeof(KSNODEPROPERTY), dwSize);
            if(SUCCEEDED(hr))
            {
                *ppIDMDownload = (IDirectMusicDownload*)pdmdl;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if(FAILED(hr))
    {
        if (pdmdl) delete pdmdl;
        if (pbuf) delete [] pbuf;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetBuffer

STDMETHODIMP 
CDirectMusicPortDownload::GetBuffer(
    DWORD dwDLId,
    IDirectMusicDownload** ppIDMDownload)
{
    // Argument validation
    V_INAME(CDirectMusicPortDownload::GetBuffer);
    V_PTRPTR_WRITE(ppIDMDownload);

    if(dwDLId >= CDirectMusicPortDownload::sNextDLId)
    {
        return DMUS_E_INVALID_DOWNLOADID;
    }

    return GetBufferInternal(dwDLId,ppIDMDownload);
}

STDMETHODIMP 
CDirectMusicPortDownload::GetBufferInternal(
    DWORD dwDLId,IDirectMusicDownload** ppIDMDownload)
{
    EnterCriticalSection(&m_DMDLCriticalSection);

    bool bFound = false;    
    
    // Check the download list
    CDownloadBuffer* pDownload = m_DLBufferList[dwDLId % DLB_HASH_SIZE].GetHead();

    for( ; pDownload; pDownload = pDownload->GetNext())
    {
        if(dwDLId == pDownload->m_dwDLId)
        {
            *ppIDMDownload = pDownload;
            (*ppIDMDownload)->AddRef();
            bFound = true;
            break;
        }
    }

    LeaveCriticalSection(&m_DMDLCriticalSection);

    return bFound ? S_OK : DMUS_E_NOT_DOWNLOADED_TO_PORT;   
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::Download

STDMETHODIMP CDirectMusicPortDownload::Download(IDirectMusicDownload* pIDMDownload)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::Unload

STDMETHODIMP CDirectMusicPortDownload::Unload(IDirectMusicDownload* pIDMDownload)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetAppend

STDMETHODIMP CDirectMusicPortDownload::GetAppend(DWORD* pdwAppend)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetDLId

STDMETHODIMP CDirectMusicPortDownload::GetDLId(
    DWORD* pdwStartDLId,
    DWORD dwCount)
{
    // Argument validation
    V_INAME(CDirectMusicPortDownload::GetDLId);
    V_PTR_WRITE(pdwStartDLId, DWORD);

    if(dwCount <= 0 || (sNextDLId + dwCount) > ULONG_MAX)
    {
        return E_INVALIDARG;
    }

    GetDLIdP(pdwStartDLId, dwCount);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetDLIdP

void CDirectMusicPortDownload::GetDLIdP(DWORD* pdwStartDLId, DWORD dwCount)
{
    assert(pdwStartDLId);

    EnterCriticalSection(&sDMDLCriticalSection);
    
    *pdwStartDLId = sNextDLId;
    
    sNextDLId += dwCount;
    
    LeaveCriticalSection(&sDMDLCriticalSection);
}

//////////////////////////////////////////////////////////////////////
// Internal

void CDirectMusicPortDownload::ClearDLSFeatures()

{
    m_DLSFeatureList.Clear();
}

STDMETHODIMP
CDirectMusicPortDownload::QueryDLSFeature(REFGUID rguidID, long *plResult)

{
    *plResult = 0;      // Set to 0, which is the default for when the GUID is not supported.
    CDLSFeature *pFeature = m_DLSFeatureList.GetHead();
    for (;pFeature;pFeature = pFeature->GetNext())
    {
        if (rguidID == pFeature->m_guidID)
        {
            *plResult = pFeature->m_lResult;
            return pFeature->m_hr;
        }
    }
    IKsControl *pControl;
    HRESULT hr = QueryInterface(IID_IKsControl, (void**)&pControl);
    if (SUCCEEDED(hr))
    {
        KSPROPERTY ksp;
        ULONG cb;

        ZeroMemory(&ksp, sizeof(ksp));
        ksp.Set   = rguidID;
        ksp.Id    = 0;
        ksp.Flags = KSPROPERTY_TYPE_GET;

        hr = pControl->KsProperty(&ksp,
                             sizeof(ksp),
                             (LPVOID)plResult,
                             sizeof(*plResult),
                             &cb);
        pControl->Release();
        pFeature = new CDLSFeature;
        if (pFeature)
        {
            pFeature->m_hr = hr;
            pFeature->m_guidID = rguidID;
            pFeature->m_lResult = *plResult;
            m_DLSFeatureList.AddHead(pFeature);
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::DownloadP

STDMETHODIMP
CDirectMusicPortDownload::DownloadP(IDirectMusicInstrument* pInstrument,
                                    IDirectMusicDownloadedInstrument** ppDownloadedInstrument,
                                    DMUS_NOTERANGE* pNoteRanges,
                                    DWORD dwNumNoteRanges,
                                    BOOL fVersion2)
{
#ifdef DBG
    // Argument validation
    // We only want to do this in a DEBUG build since whoever calls us needs to do 
    // the RELEASE build validation
    V_INAME(IDirectMusicPortDownload::DownloadP);
    V_PTR_READ(pInstrument, IDirectMusicInstrument); 
    V_PTRPTR_WRITE(ppDownloadedInstrument);
    V_BUFPTR_READ(pNoteRanges, (dwNumNoteRanges * sizeof(DMUS_NOTERANGE)));
#endif

    // If you can QI pInstrument for private interface IDirectMusicInstrumentPrivate 
    // pInstrument is of type CInstrument.
    IDirectMusicInstrumentPrivate* pDMIP = NULL;
    HRESULT hr = pInstrument->QueryInterface(IID_IDirectMusicInstrumentPrivate, (void **)&pDMIP);

    if (FAILED(hr))
    {
        return hr;
    }

    pDMIP->Release();

    EnterCriticalSection(&m_CDMDLCriticalSection);

    hr = GetCachedAppend(&m_dwAppend);
    if (FAILED(hr))
    {
        LeaveCriticalSection(&m_CDMDLCriticalSection);
        return hr;
    }

    if (m_fNewFormat == NEWFORMAT_NOT_RETRIEVED)
    {
        QueryDLSFeature(GUID_DMUS_PROP_INSTRUMENT2,(long *) &m_fNewFormat);
    }

    CInstrument *pCInstrument = (CInstrument *)pInstrument;

    // Get number of waves in an instrument
    DWORD dwCount;
    hr = pCInstrument->GetWaveCount(&dwCount);

    // Get Download ID's for each wave in instrument
    DWORD* pdwWaveIds = NULL;   
    if (SUCCEEDED(hr))
    {
        pdwWaveIds = new DWORD[dwCount];
        if (pdwWaveIds)
        {
            hr = pCInstrument->GetWaveDLIDs(pdwWaveIds);
        }
        else
        {
            hr = E_OUTOFMEMORY;             
        }
    }

    // Get DownloadedInstrument object
    CDownloadedInstrument* pDMDLInst = NULL;
    IDirectMusicPort* pIDMPort = NULL;
    DWORD dwDLId = pCInstrument->GetInstrumentDLID();
    BOOL fInstrumentNeedsDownload = FALSE;
    if (SUCCEEDED(hr))
    {
        hr = QueryInterface(IID_IDirectMusicPort, (void **)&pIDMPort);
        
        if (SUCCEEDED(hr))
        {
            hr = FindDownloadedInstrument(dwDLId, &pDMDLInst);

            if (!pDMDLInst && SUCCEEDED(hr))
            {
                fInstrumentNeedsDownload = TRUE;
                pDMDLInst = new CDownloadedInstrument;

                if (pDMDLInst)
                {       
                    // Allocate an IDirectMusicDownload pointer for each wave and one for the instrument
                    pDMDLInst->m_ppDownloadedBuffers = new IDirectMusicDownload*[dwCount + 1];
                    if (pDMDLInst->m_ppDownloadedBuffers)
                    {
                        pDMDLInst->m_dwDLTotal = dwCount + 1;
                        memset(pDMDLInst->m_ppDownloadedBuffers, 0, pDMDLInst->m_dwDLTotal * sizeof(IDirectMusicDownload*));
                        pDMDLInst->m_pPort = pIDMPort;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        pDMDLInst->Release(); 
                        pDMDLInst = NULL;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            // don't let DMDLInst hold a refcnt on the port so we can final-release the port if the app
            //  misses a DMDLInst release
            pIDMPort->Release(); pIDMPort = NULL;
        }
    }
    
    DWORD dwSize;
    
    // Download the data for each wave if necessary
    if (SUCCEEDED(hr))
    {
        // First, make sure all conditional chunks are evaluated properly for this port.
        pCInstrument->SetPort(this, fVersion2);
        // All waves are already down?
        if (pDMDLInst->m_dwDLSoFar < dwCount) 
        {
            // Find out which waves need to be downloaded. 
            DWORD* pdwWaveRefs = NULL;  

            pdwWaveRefs = new DWORD[dwCount];
            if (pdwWaveRefs)
            {
                DWORD dwWaveIndex;
                hr = GetWaveRefs(&pDMDLInst->m_ppDownloadedBuffers[1], 
                    pdwWaveRefs, pdwWaveIds, dwCount, 
                    pCInstrument, pNoteRanges, dwNumNoteRanges);
                for(dwWaveIndex = 0; dwWaveIndex < dwCount && SUCCEEDED(hr); dwWaveIndex++)
                {
                    if (!pdwWaveRefs[dwWaveIndex] || pDMDLInst->m_ppDownloadedBuffers[dwWaveIndex + 1])
                    {
                        continue;
                    }
            
                    // Determine if we need to download the wave
                    IDirectMusicDownload* pDMDownload = NULL;

                    hr = GetBufferInternal(pdwWaveIds[dwWaveIndex], &pDMDownload);

                    // If NULL not downloaded so we need to download
                    if (pDMDownload == NULL && hr == DMUS_E_NOT_DOWNLOADED_TO_PORT)
                    {
				        DWORD dwSampleSize;	// Bit size of wave data.
                        hr = pCInstrument->GetWaveSize(pdwWaveIds[dwWaveIndex], &dwSize, &dwSampleSize);
                        if (SUCCEEDED(hr))
                        {
                            dwSize += (m_dwAppend * (dwSampleSize / 8));

                            hr = AllocateBuffer(dwSize, &pDMDownload);
                            if (SUCCEEDED(hr))
                            {
                                hr = pCInstrument->GetWave(pdwWaveIds[dwWaveIndex], pDMDownload);
#ifdef DMUS_GEN_INS_DATA
                                if (SUCCEEDED(hr))
                                {
                                    writewave(pDMDownload, pdwWaveIds[dwWaveIndex]);
                                }
#endif
                            }

                            if (SUCCEEDED(hr))
                            {
                                hr = Download(pDMDownload);
                            }

                            if (SUCCEEDED(hr))
                            {
                                pDMDLInst->m_ppDownloadedBuffers[dwWaveIndex + 1] = pDMDownload;
                                pDMDLInst->m_dwDLSoFar++;  
                                fInstrumentNeedsDownload = TRUE;
                            }

                            if (FAILED(hr) && pDMDownload != NULL)
                            {
                                pDMDownload->Release();
                                pDMDLInst->m_ppDownloadedBuffers[dwWaveIndex + 1] = NULL;
                            }
                        }
                    }
                    else if (SUCCEEDED(hr))
                    {
                        if (pDMDLInst->m_ppDownloadedBuffers[dwWaveIndex + 1] == NULL)
                        {
                            ((CDownloadBuffer*)pDMDownload)->IncDownloadCount();
                            pDMDLInst->m_ppDownloadedBuffers[dwWaveIndex + 1] = pDMDownload;
                            pDMDLInst->m_dwDLSoFar++;
                        }
                        else
                        {
                            pDMDownload->Release(); // for being found
                            pDMDownload = NULL;
                        }
                    }
                }
                delete [] pdwWaveRefs;
            }
            else
            {
                hr = E_OUTOFMEMORY;             
            }
        }
    }

    // Download instrument data
    if (SUCCEEDED(hr))
    {
        // Determine if we need to downloaded the instrument
        if (fInstrumentNeedsDownload)
        {
            // First, get the old download, if it exists (this should be the case
            // when an instrument needs to be updated because more waves were downloaded.)
            IDirectMusicDownload* pDMOldDownload = NULL;
            GetBufferInternal(dwDLId, &pDMOldDownload);

            hr = pCInstrument->GetInstrumentSize(&dwSize);
        
            IDirectMusicDownload* pDMNewDownload = NULL;
        
            if (SUCCEEDED(hr))
            {
                hr = AllocateBuffer(dwSize, &pDMNewDownload);
                if (SUCCEEDED(hr))
                {
                    hr = pCInstrument->GetInstrument(pDMNewDownload);
#ifdef DMUS_GEN_INS_DATA                        
                    if (SUCCEEDED(hr))
                    {
                        writeinstrument(pDMNewDownload, dwDLId);
                    }
#endif
                }
            
                if (SUCCEEDED(hr))
                {
                    hr = Download(pDMNewDownload);
                }
            
                if (SUCCEEDED(hr))
                {
                    pDMDLInst->m_ppDownloadedBuffers[0] = pDMNewDownload;
                }

                if (FAILED(hr) && pDMNewDownload != NULL)
                {
                    pDMNewDownload->Release();
                    pDMDLInst->m_ppDownloadedBuffers[0] = NULL;
                }
            }
        
            if (pDMOldDownload)
            {
                Unload(pDMOldDownload);
                pDMOldDownload->Release(); // for being found
                pDMOldDownload->Release(); // to destroy
                pDMOldDownload = NULL;
            }
        }
    }

    delete [] pdwWaveIds;

    if (FAILED(hr))
    {
        if (pDMDLInst)
        {
            if (!pDMDLInst->m_cDLRef)
            {
                CDownloadBuffer* pDMDL = NULL;

                for(DWORD i = 0; i < pDMDLInst->m_dwDLTotal; i++)
                {   
                    pDMDL = (CDownloadBuffer*)(pDMDLInst->m_ppDownloadedBuffers[i]);
        
                    if(pDMDL)
                    {
                        Unload((IDirectMusicDownload*)pDMDL);
                        pDMDL->Release();
                    }
                }   

                delete [] (pDMDLInst->m_ppDownloadedBuffers);
                pDMDLInst->m_ppDownloadedBuffers = NULL;
            }

            pDMDLInst->Release();
        }
    }
    else
    {
        if (!pDMDLInst->m_cDLRef)
        {
            hr = AddDownloadedInstrument(pDMDLInst);
        }

        pDMDLInst->m_cDLRef++;
        *ppDownloadedInstrument = pDMDLInst;
    }

    LeaveCriticalSection(&m_CDMDLCriticalSection);
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::UnloadP

STDMETHODIMP
CDirectMusicPortDownload::UnloadP(IDirectMusicDownloadedInstrument* pDownloadedInstrument)
{
#ifdef DBG
    // Argument validation
    // We only want to do this in a DEBUG build since whoever calls us needs to do 
    // the RELEASE build validation
    V_INAME(IDirectMusicPortDownload::UnloadP);
    V_PTR_READ(pDownloadedInstrument, IDirectMusicDownloadedInstrument); 
#endif

    // If you can QI pDownloadedInstrument for private interface IDirectMusicDownloadedInstrumentPrivate 
    // pDownloadedInstrument is of type CDownloadedInstrument.
    IDirectMusicDownloadedInstrumentPrivate* pDMDIP = NULL;
    HRESULT hr = pDownloadedInstrument->QueryInterface(IID_IDirectMusicDownloadedInstrumentPrivate, (void **)&pDMDIP);

    if(FAILED(hr))
    {
        return hr;
    }

    pDMDIP->Release();

    CDownloadedInstrument* pDMDLInst = (CDownloadedInstrument *)pDownloadedInstrument;

    IDirectMusicPort* pIDMP = NULL;
        
    QueryInterface(IID_IDirectMusicPort, (void **)&pIDMP);
    
    // Make sure we are downloaded to this port and that we have not been previously unloaded
    // If pDMDLInst->m_ppDownloadedBuffers == NULL we may have been downloadeded to this port but are no longer
    if(pDMDLInst->m_pPort != pIDMP || pDMDLInst->m_ppDownloadedBuffers == NULL)
    {
        pIDMP->Release();
        return DMUS_E_NOT_DOWNLOADED_TO_PORT;
    }
    
    pIDMP->Release();

    EnterCriticalSection(&m_CDMDLCriticalSection);

    if (pDMDLInst->m_cDLRef && --pDMDLInst->m_cDLRef == 0)
    {
        CDownloadBuffer* pDMDL = NULL;

        for(DWORD i = 0; i < pDMDLInst->m_dwDLTotal; i++)
        {   
            pDMDL = (CDownloadBuffer*)(pDMDLInst->m_ppDownloadedBuffers[i]);
        
            if(pDMDL)
            {
                Unload((IDirectMusicDownload*)pDMDL);
                pDMDL->Release();
            }
        }   

        delete [] (pDMDLInst->m_ppDownloadedBuffers);
        pDMDLInst->m_ppDownloadedBuffers = NULL;
        RemoveDownloadedInstrument(pDMDLInst);
    }
    else
    {
        hr = S_FALSE;
    }

    LeaveCriticalSection(&m_CDMDLCriticalSection);

    return hr;
}



//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetWaveRefs

STDMETHODIMP
CDirectMusicPortDownload::GetWaveRefs(IDirectMusicDownload* ppDownloadedBuffers[],
                                      DWORD* pdwWaveRefs,
                                      DWORD* pdwWaveIds,
                                      DWORD dwNumWaves,
                                      CInstrument* pCInstrument,
                                      DMUS_NOTERANGE* pNoteRanges,
                                      DWORD dwNumNoteRanges)
{
    assert(pdwWaveRefs);
    assert(ppDownloadedBuffers);
    assert(pCInstrument);
    assert(dwNumNoteRanges ? (pNoteRanges != NULL) : TRUE);

    memset(pdwWaveRefs, 0, dwNumWaves * sizeof(DWORD));

    // Get number of waves in an instrument
    DWORD dwCount;
    if (FAILED(pCInstrument->GetWaveCount(&dwCount)))
    {
        return E_UNEXPECTED;
    }

    if (dwCount != dwNumWaves)
    {
        return E_INVALIDARG;
    }

    CInstrObj *pInstObj = pCInstrument->m_pInstrObj;
    
    if (pInstObj)
    {
        if (pInstObj->m_fHasConditionals || dwNumNoteRanges)
        {
            CRegion *pRegion = pInstObj->m_RegionList.GetHead();
            DWORD dwWaveIdx;
            for (dwWaveIdx = 0; dwWaveIdx < dwNumWaves; dwWaveIdx++)
            {
                // Check if the wave is already downloaded.
                if (!ppDownloadedBuffers[dwWaveIdx])
                {
                    // We always scan forward through the regions, since they are in the same order as the array.
                    for (;pRegion;pRegion = pRegion->GetNext())
                    {
                        // Does this region point to the next wave? If not, it must be a duplicate.
                        if (pRegion->m_WaveLink.ulTableIndex == pdwWaveIds[dwWaveIdx])
                        {
                            // Conditional chunk allow download?
                            if (pRegion->m_Condition.m_fOkayToDownload)
                            {
                                // Verify against note ranges.
                                if (dwNumNoteRanges)
                                {
                                    DWORD dwLowNote = DWORD(pRegion->m_RgnHeader.RangeKey.usLow);
                                    DWORD dwHighNote = DWORD(pRegion->m_RgnHeader.RangeKey.usHigh);

                                    for (DWORD dwNRIdx = 0; dwNRIdx < dwNumNoteRanges; dwNRIdx++)
                                    {
                                        if (dwHighNote < pNoteRanges[dwNRIdx].dwLowNote ||
                                            dwLowNote > pNoteRanges[dwNRIdx].dwHighNote)
                                        {
                                            continue;
                                        }
                                        else
                                        {
                                            pdwWaveRefs[dwWaveIdx]++;
                                            break;
                                        }
                                    }
                                }
                                else
                                {
                                    pdwWaveRefs[dwWaveIdx]++;
                                }
                            }
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            DWORD dwIndex;
            for (dwIndex = 0; dwIndex < dwNumWaves; dwIndex++)
            {
                if (!ppDownloadedBuffers[dwIndex])
                {
                    pdwWaveRefs[dwIndex]++;
                }
            }
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::FindDownloadedInstrument

STDMETHODIMP
CDirectMusicPortDownload::FindDownloadedInstrument(DWORD dwId,
                                                   CDownloadedInstrument** ppDMDLInst)
{
    assert(ppDMDLInst);

    HRESULT hr = S_FALSE;

    for (CDownloadedInstrument* pDMDLInst = m_DLInstrumentList.GetHead();
        pDMDLInst; pDMDLInst = pDMDLInst->GetNext())
    {
        IDirectMusicDownload* pDMDownload = pDMDLInst->m_ppDownloadedBuffers[0];
        
        if (pDMDownload && ((CDownloadBuffer*)pDMDownload)->m_dwDLId == dwId)
        {
            *ppDMDLInst = pDMDLInst;
            (*ppDMDLInst)->AddRef();
            hr = S_OK;
            break;
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::AddDownloadedInstrument

STDMETHODIMP
CDirectMusicPortDownload::AddDownloadedInstrument(CDownloadedInstrument* pDMDLInst)
{
    assert(pDMDLInst);

    m_DLInstrumentList.AddTail(pDMDLInst);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::RemoveDownloadedInstrument

STDMETHODIMP
CDirectMusicPortDownload::RemoveDownloadedInstrument(CDownloadedInstrument* pDMDLInst)
{
    assert(pDMDLInst);

    m_DLInstrumentList.Remove(pDMDLInst);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::FreeBuffer

STDMETHODIMP
CDirectMusicPortDownload::FreeBuffer(IDirectMusicDownload* pIDMDownload)                                       
{
    // Argument validation
    assert(pIDMDownload);

    void* pvBuffer = NULL; 

    // If you can QI pIDMDownload for private interface IDirectMusicDownloadPrivate 
    // pIDMDownload is of type CDownloadBuffer.
    IDirectMusicDownloadPrivate* pDMDLP = NULL;
    HRESULT hr = pIDMDownload->QueryInterface(IID_IDirectMusicDownloadPrivate, (void **)&pDMDLP);

    if(SUCCEEDED(hr))
    {
        pDMDLP->Release();
        
        hr = ((CDownloadBuffer*)pIDMDownload)->IsDownloaded();
        
        if(hr != S_FALSE)
        {
            return DMUS_E_BUFFERNOTAVAILABLE;
        }

        DWORD dwSize;
        hr = ((CDownloadBuffer*)pIDMDownload)->GetHeader(&pvBuffer, &dwSize);
    }

    if(SUCCEEDED(hr))
    {
        hr = ((CDownloadBuffer*)pIDMDownload)->SetBuffer(NULL, 0, 0);
        delete [] pvBuffer;
    }

    return hr;
}

#ifdef DMUS_GEN_INS_DATA
void writewave(IDirectMusicDownload* pDMDownload, DWORD dwId)
{
    DWORD dwSize = 0;
    void* pvBuffer = NULL;
    HRESULT hr = pDMDownload->GetBufferInternal(&pvBuffer, &dwSize);

    HANDLE hfw = NULL;
    if(SUCCEEDED(hr))
    {
        char filename[1024];
        wsprintf(filename, "%s%d%s", "d:\\InstrumentData\\wavedata", dwId, ".dat");
        hfw = CreateFile(filename,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
    }

    if(pvBuffer && hfw != INVALID_HANDLE_VALUE)
    {

        DWORD w;
        BOOL b = WriteFile(hfw, 
                           ((BYTE *)pvBuffer),
                           dwSize,
                           &w,
                           NULL);
    }

    CloseHandle(hfw);
}

void writeinstrument(IDirectMusicDownload* pDMDownload, DWORD dwId)
{
    DWORD dwSize = 0;
    void* pvBuffer = NULL;
    HANDLE hfi = NULL;
    HRESULT hr = pDMDownload->GetBufferinternal(&pvBuffer, &dwSize);
    
    if(SUCCEEDED(hr))
    {
        char filename[1024];
        wsprintf(filename, "%s%d%s", "d:\\InstrumentData\\instrumentdata", dwId, ".dat");
        hfi = CreateFile(filename,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
    }

    if(pvBuffer && hfi != INVALID_HANDLE_VALUE)
    {

        DWORD w;
        BOOL b = WriteFile(hfi, 
                           ((BYTE *)pvBuffer),
                           dwSize,
                           &w,
                           NULL);
    }
    
    CloseHandle(hfi);
}
#endif // #ifdef DMUS_GEN_INS_DATA

//#############################################################################
//
// Wave object support after this
//
//
//#############################################################################

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::DownloadWaveP
//
// This function supports the DownloadWave method on IDirectMusicPort.
// It is not related directly to DLS functionality, but rather to
// downloading oneshot and streaming waves from an IDirectSoundWave.
//
// rtStart is not the starting time on the master clock, but rather
// the offset within the stream (if this is a stream).
//

STDMETHODIMP 
CDirectMusicPortDownload::DownloadWaveP(IDirectSoundWave *pIDSWave,               
                                        IDirectSoundDownloadedWaveP **ppWave,
                                        REFERENCE_TIME rtStartHint)
{
    HRESULT                     hr = S_OK;
    CDirectSoundWave            *pDSWave = NULL;
    BOOL                        fIsStreaming = FALSE;
    BOOL                        fUseNoPreRoll = FALSE;
    REFERENCE_TIME              rtReadAhead = 0;
    DWORD                       dwFlags = 0;

    hr = pIDSWave->GetStreamingParms(&dwFlags, &rtReadAhead);
    fIsStreaming = dwFlags & DMUS_WAVEF_STREAMING ? TRUE : FALSE;
    fUseNoPreRoll = dwFlags & DMUS_WAVEF_NOPREROLL ? TRUE : FALSE;

    EnterCriticalSection(&m_CDMDLCriticalSection);
    
    // See if there is already a CDirectSoundWave object
    // wrapping this interface
    //
    if (SUCCEEDED(hr))
    {
        TraceI(2, "DownloadWaveP: Got interface %p\n", pIDSWave);
        
        // We want to download streaming waves everytime
        if(fIsStreaming == FALSE)
        {
            pDSWave = CDirectSoundWave::GetMatchingDSWave(pIDSWave);
        }
    
        if (pDSWave == NULL) 
        {
            TraceI(2, "Hmmmm. nope, haven't seen that before.\n");
            // This object has not been seen before. Wrap it.
            //
            pDSWave = new CDirectSoundWave(
                pIDSWave, 
                fIsStreaming ? true : false,
                rtReadAhead,
                fUseNoPreRoll ? true : false,
                rtStartHint);
            hr = HRFromP(pDSWave);

            if (SUCCEEDED(hr))
            {
                hr = pDSWave->Init(this);
                if (FAILED(hr))
                {
                    delete pDSWave;
                    pDSWave = NULL;
                }
            }
        }
        else 
        {
            TraceI(2, "Found download %p\n", pDSWave);
        }
    }

    // Download wave data if needed. This will do nothing on streaming waves.
    //
    if (SUCCEEDED(hr))
    {
        hr = pDSWave->Download();
    }

    if (SUCCEEDED(hr))
    {
        assert(pDSWave);
        hr = pDSWave->QueryInterface(IID_IDirectSoundDownloadedWaveP, (void**)ppWave);
    }

    if (FAILED(hr) && pDSWave)
    {
        // Something failed, unload anything we downloaded.
        //
        pDSWave->Unload();
    }

    RELEASE(pDSWave);

    LeaveCriticalSection(&m_CDMDLCriticalSection);

    return hr;
}    

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::UnloadWaveP
//
STDMETHODIMP
CDirectMusicPortDownload::UnloadWaveP(IDirectSoundDownloadedWaveP *pWave)
{
    CDirectSoundWave *pDSWave = static_cast<CDirectSoundWave*>(pWave);

    // XXX Stop playing voices?
    //
    HRESULT hr = pDSWave->Unload();
	if (SUCCEEDED(hr))
	{
		hr = pDSWave->Release();
	}
    
    return hr;    
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::AllocVoice
//
// Voice management is neccessarily very tied to download management,
// so it makes sense for the download manager to dole out voices.
// 
// Methods on IDirectMusicPortPrivate are used to contain the port-
// specific code to do things like play.
//
STDMETHODIMP
CDirectMusicPortDownload::AllocVoice(
    IDirectSoundDownloadedWaveP *pWave,          // Wave to play on this voice
    DWORD dwChannel,                            // Channel and channel group
    DWORD dwChannelGroup,                       //  this voice will play on
    REFERENCE_TIME rtStart,                     // Where to start (stream only)
    SAMPLE_TIME stLoopStart,                    // Loop start and end
    SAMPLE_TIME stLoopEnd,                      //  (one shot only)
    IDirectMusicVoiceP **ppVoice                 // Returned voice
)
{
    CDirectSoundWave *pDSWave = static_cast<CDirectSoundWave*>(pWave);

    HRESULT hr;
    CDirectMusicVoice *pVoice;

    IDirectMusicPort *pPort;
    hr = QueryInterface(IID_IDirectMusicPort, (void**)&pPort);

    if (SUCCEEDED(hr))
    {
        pVoice = new CDirectMusicVoice(
            this, 
            pWave,
            dwChannel,
            dwChannelGroup,
            rtStart, 
            pDSWave->GetReadAhead(),
            stLoopStart,
            stLoopEnd);

        hr = HRFromP(pVoice);

        pPort->Release();
    }

    if (SUCCEEDED(hr))
    {
        hr = pVoice->Init();
    }

    if (SUCCEEDED(hr))
    {
        *ppVoice = static_cast<IDirectMusicVoiceP*>(pVoice);
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetCachedAppend
//
STDMETHODIMP
CDirectMusicPortDownload::GetCachedAppend(DWORD *pdw)
{
    HRESULT                 hr = S_OK;

    if (m_dwAppend == APPEND_NOT_RETRIEVED)
    {
        hr = GetAppend(&m_dwAppend);
    }

    *pdw = m_dwAppend;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dminstru.cpp ===
//
// dminstru.cpp
//
// Copyright (c) 1997-2001 Microsoft Corporation. All rights reserved.
//
// @doc EXTERNAL
//

#include "debug.h"
#include "dmusicp.h"
#include "dmusicc.h"

#include "alist.h"
#include "debug.h"
#include "dmcollec.h"
#include "dmportdl.h"
#include "dminstru.h"
#include "dminsobj.h"
#include "validate.h"

//////////////////////////////////////////////////////////////////////
// Class CInstrument

//////////////////////////////////////////////////////////////////////
// CInstrument::CInstrument

CInstrument::CInstrument() :
m_dwOriginalPatch(0),
m_dwPatch(0),
m_pParentCollection(NULL),
m_pInstrObj(NULL),
m_bInited(false),
m_dwId(-1),
m_cRef(1)
{
    InitializeCriticalSection(&m_DMICriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
}

//////////////////////////////////////////////////////////////////////
// CInstrument::~CInstrument

CInstrument::~CInstrument()
{
    Cleanup();
    DeleteCriticalSection(&m_DMICriticalSection);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CInstrument::QueryInterface

STDMETHODIMP CInstrument::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicInstrument::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if(iid == IID_IUnknown || iid == IID_IDirectMusicInstrument)
    {
        *ppv = static_cast<IDirectMusicInstrument*>(this);
    }
    else if(iid == IID_IDirectMusicInstrumentPrivate)
    {
        *ppv = static_cast<IDirectMusicInstrumentPrivate*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CInstrument::AddRef

STDMETHODIMP_(ULONG) CInstrument::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CInstrument::Release

STDMETHODIMP_(ULONG) CInstrument::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        if(m_pParentCollection)
        {
            m_pParentCollection->RemoveInstrument(this);
        }

        if(!m_cRef) // remotely possible that collection bumped before we were removed
        {
            delete this;
            return 0;
        }
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicInstrument

//////////////////////////////////////////////////////////////////////
// CInstrument::GetPatch

/*

@method:(EXTERNAL) HRESULT | IDirectMusicInstrument | GetPatch |
Gets the MIDI patch number from the instrument. The MIDI
patch number is an address composed of the MSB and LSB
bank selects, and program change number. An optional flag
bit indicates that the instrument is a drum, rather than
melodic, instrument.

@comm The patch number returned in <p dwPatch> describes the
full patch address, including the MIDI parameters for MSB and LSB
bank select. MSB is shifted left 16 bits and LSB is shifted
8 bits. Program change is stored in the bottom 8 bits.

In addition, the high bit (0x80000000)
must be set if the instrument is
specifically a drum kit, intended to be played on MIDI
channel 10.
Note that this a special tag for DLS Level 1,
since DLS Level 1 always plays drums on MIDI channel 10.
However, future versions of DLS will probably do away with
the differentiation of drums verses melodic isntruments.
All channels will support drums and the format differences
between drums and melodic instruments will go away.

@rdesc Returns one of the following

@flag S_OK | Success
@flag E_POINTER | Invalid pointer in <p pdwPatch>.


@xref <i IDirectMusicCollection>,
<i IDirectMusicInstrument>,
<om IDirectMusicInstrument::SetPatch>,
<om IDirectMusicCollection::GetInstrument>
*/

STDMETHODIMP CInstrument::GetPatch(
    DWORD* pdwPatch)    // @parm Returned patch number.
{
    if(!m_bInited)
    {
        return DMUS_E_NOT_INIT;
    }

    // Argument validation
    V_INAME(IDirectMusicInstrument::GetPatch);
    V_PTR_WRITE(pdwPatch, DWORD);

    *pdwPatch = m_dwPatch;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CInstrument::SetPatch
/*
@method:(EXTERNAL) HRESULT | IDirectMusicInstrument | SetPatch |
Sets the MIDI patch number for the instrument. Although
each instrument in a DLS collection has a predefined
patch number, the patch number
can be reassigned once the instrument
has been pulled from the <i IDirectMusicCollection>
via a call to <om IDirectMusicCollection::GetInstrument>.

@rdesc Returns one of the following

@flag S_OK | Success
@flag DMUS_E_INVALIDPATCH | Invalid MIDI address in <p dwPatch>.

@xref <i IDirectMusicCollection>,
<i IDirectMusicInstrument>,
<om IDirectMusicInstrument::GetPatch>,
<om IDirectMusicCollection::GetInstrument>

@ex The following example gets an instrument from a collection,
remaps its
MSB bank select to a different bank, then downloads the
instrument. |

    HRESULT myRemappedDownload(
        IDirectMusicCollection *pCollection,
        IDirectMusicPort *pPort,
        IDirectMusicDownloadedInstrument **ppDLInstrument,
        BYTE bMSB,       // Requested MIDI MSB for patch bank select.
        DWORD dwPatch)   // Requested patch.

    {
        HRESULT hr;
        IDirectMusicInstrument* pInstrument;
        hr = pCollection->GetInstrument(dwPatch, &pInstrument);
        if (SUCCEEDED(hr))
        {
            dwPatch &= 0xFF00FFFF;  // Clear MSB.
            dwPatch |= bMSB << 16;  // Stick in new MSB value.
            pInstrument->SetPatch(dwPatch);
            hr = pPort->DownloadInstrument(pInstrument, ppDLInstrument, NULL, 0);
            pInstrument->Release();
        }
        return hr;
    }
*/

STDMETHODIMP CInstrument::SetPatch(
    DWORD dwPatch)  // @parm New patch number to assign to instrument.
{
    // Argument validation - Runtime
    if(!m_bInited)
    {
        return DMUS_E_NOT_INIT;
    }

    // We use 0x7F to strip out the Drum Kit flag
    BYTE bMSB = (BYTE) ((dwPatch >> 16) & 0x7F);
    BYTE bLSB = (BYTE) (dwPatch >> 8);
    BYTE bInstrument = (BYTE) dwPatch;

    if(bMSB < 0 || bMSB > 127 ||
       bLSB < 0 || bLSB > 127 ||
       bInstrument < 0 || bInstrument > 127)
    {
        return DMUS_E_INVALIDPATCH;
    }

    m_dwPatch = dwPatch;
    CDirectMusicPort::GetDLIdP(&m_dwId, 1);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CInstrument::Cleanup

void CInstrument::Cleanup()
{
    EnterCriticalSection(&m_DMICriticalSection);

    while(!m_WaveObjList.IsEmpty())
    {
        CWaveObj* pWaveObj = m_WaveObjList.RemoveHead();
        if(pWaveObj)
        {
            delete pWaveObj;
        }
    }

    if(m_pInstrObj)
    {
        delete m_pInstrObj;
    }

    if(m_pParentCollection)
    {
        m_pParentCollection->Release();
        m_pParentCollection = NULL;
    }

    m_bInited = false;

    LeaveCriticalSection(&m_DMICriticalSection);
}

//////////////////////////////////////////////////////////////////////
// CInstrument::Init

HRESULT CInstrument::Init(DWORD dwPatch, CCollection* pParentCollection)
{
    // Argument validation - Debug
    assert(pParentCollection);

    m_dwOriginalPatch = m_dwPatch = dwPatch;
    m_pParentCollection = pParentCollection;
    m_pParentCollection->AddRef();

    HRESULT hr = pParentCollection->ExtractInstrument(dwPatch, &m_pInstrObj);

    if(FAILED(hr) || hr == S_FALSE)
    {
        Cleanup();
        return DMUS_E_INVALIDPATCH;
    }

    m_bInited = true;

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetWaveCount

HRESULT CInstrument::GetWaveCount(DWORD* pdwCount)
{
    // Assumption validation - Debug
    assert(m_pInstrObj);
    assert(pdwCount);

    return(m_pInstrObj->GetWaveCount(pdwCount));
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetWaveIDs

HRESULT CInstrument::GetWaveDLIDs(DWORD* pdwIds)
{
    assert(m_pInstrObj);
    assert(pdwIds);

    return(m_pInstrObj->GetWaveIDs(pdwIds));
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetWaveSize

HRESULT CInstrument::GetWaveSize(DWORD dwId, DWORD* pdwSize, DWORD* pdwSampleSize)
{
    assert(pdwSize);

    if(dwId >= CDirectMusicPortDownload::sNextDLId)
    {
        assert(FALSE); // We want to make it known if we get here
        return DMUS_E_INVALID_DOWNLOADID;
    }

    EnterCriticalSection(&m_DMICriticalSection);

    HRESULT hr = E_FAIL;
    bool bFound = false;

    CWaveObj* pWaveObj = m_WaveObjList.GetHead();

    for(; pWaveObj; pWaveObj = pWaveObj->GetNext())
    {
        if(dwId == pWaveObj->m_dwId)
        {
            bFound = true;
            hr = S_OK;
            break;
        }
    }

    if(!bFound)
    {
        hr = m_pParentCollection->ExtractWave(dwId, &pWaveObj);
        if(SUCCEEDED(hr))
        {
            m_WaveObjList.AddHead(pWaveObj);
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = pWaveObj->Size(pdwSize,pdwSampleSize);
    }

    LeaveCriticalSection(&m_DMICriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetWave

HRESULT CInstrument::GetWave(DWORD dwWId, IDirectMusicDownload* pIDMDownload)
{
    assert(pIDMDownload);

    if(dwWId >= CDirectMusicPortDownload::sNextDLId)
    {
        assert(FALSE); // We want to make it known if we get here
        return DMUS_E_INVALID_DOWNLOADID;
    }

    EnterCriticalSection(&m_DMICriticalSection);

    HRESULT hr = E_FAIL;
    bool bFound = false;

    CWaveObj* pWaveObj = m_WaveObjList.GetHead();

    for(; pWaveObj; pWaveObj = pWaveObj->GetNext())
    {
        if(dwWId == pWaveObj->m_dwId)
        {
            bFound = true;
            hr = S_OK;
            break;
        }
    }

    if(!bFound)
    {
        hr = m_pParentCollection->ExtractWave(dwWId, &pWaveObj);
        if(SUCCEEDED(hr))
        {
            m_WaveObjList.AddHead(pWaveObj);
        }
    }

    void* pvoid = NULL;
    DWORD dwBufSize = 0;
    DWORD dwWaveSize = 0;
    DWORD dwSampleSize = 0;

    if(SUCCEEDED(hr))
    {
        hr = pIDMDownload->GetBuffer(&pvoid, &dwBufSize);

        if(SUCCEEDED(hr))
        {
            hr = pWaveObj->Size(&dwWaveSize,&dwSampleSize);

            if(FAILED(hr) || dwWaveSize > dwBufSize)
            {
                hr =  DMUS_E_INSUFFICIENTBUFFER;
            }
            else
            {
                hr = pWaveObj->Write((BYTE *)pvoid);
            }
        }
    }

    LeaveCriticalSection(&m_DMICriticalSection);

    return hr;
}

void CInstrument::SetPort(CDirectMusicPortDownload *pPort, BOOL fAllowDLS2)
{
    assert(m_pInstrObj);
    m_pInstrObj->SetPort(pPort,fAllowDLS2);
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetInstrumentSize

HRESULT CInstrument::GetInstrumentSize(DWORD* pdwSize)
{
    assert(m_pInstrObj);
    assert(pdwSize);

    return(m_pInstrObj->Size(pdwSize));
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetInstrument

HRESULT CInstrument::GetInstrument(IDirectMusicDownload* pIDMDownload)
{
    assert(m_pInstrObj);
    assert(pIDMDownload);

    void* pvoid = NULL;
    DWORD dwBufSize = 0;
    DWORD dwInstSize = 0;

    HRESULT hr = pIDMDownload->GetBuffer(&pvoid, &dwBufSize);

    if(SUCCEEDED(hr))
    {
        hr = m_pInstrObj->Size(&dwInstSize);

        if(FAILED(hr) || dwInstSize > dwBufSize)
        {
            hr = DMUS_E_INSUFFICIENTBUFFER;
        }
        else
        {
            hr = m_pInstrObj->Write((BYTE *)pvoid);

            // We need to adjust dwDLId if the m_dwPatch was changed with a call to SetPatch
            // as well as adjust the ulPatch to reflect the patch set with SetPatch
            if(SUCCEEDED(hr))
            {
                DMUS_OFFSETTABLE* pDMOffsetTable = (DMUS_OFFSETTABLE *)
                    (((BYTE *)pvoid) + (DWORD) CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO)));
                DMUS_INSTRUMENT* pDMInstrument = (DMUS_INSTRUMENT *)
                    (((BYTE *)pvoid) + pDMOffsetTable->ulOffsetTable[0]);

                if(m_dwPatch != pDMInstrument->ulPatch)
                {
                    assert(m_dwId != -1);
                    ((DMUS_DOWNLOADINFO*)pvoid)->dwDLId = m_dwId;
                    pDMInstrument->ulPatch = m_dwPatch;
                }
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmregion.h ===
//
// dmregion.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay

#ifndef DMREGION_H
#define DMREGION_H

#include "dmextchk.h"
#include "dmart.h"

class CRiffParser;

class CRegion : public AListItem
{
friend CInstrObj;

public:
	CRegion(); 
	~CRegion();

	CRegion* GetNext(){return(CRegion*)AListItem::GetNext();}
	HRESULT Load(CRiffParser *pParser);
	HRESULT Write(void* pv, DWORD* pdwCurOffset, DWORD* pDMIOffsetTable, 
        DWORD* pdwCurIndex, DWORD dwIndexNextRegion);
    void SetPort(CDirectMusicPortDownload *pPort,BOOL fNewFormat, BOOL fSupportsDLS2);
    BOOL CheckForConditionals();
	DWORD Size();
	DWORD Count();

	DWORD GetWaveId() {return(m_WaveLink.ulTableIndex);};
private:
	void Cleanup();

private:
//    CRITICAL_SECTION	m_DMRegionCriticalSection;
    BOOL                m_fCSInitialized;
public:
	RGNHEADER			m_RgnHeader;
	WAVELINK			m_WaveLink;
	WSMPL				m_WSMP;
	WLOOP				m_WLOOP[1];
    CConditionChunk     m_Condition;            // Optional conditional chunk;
private:
	CArticulationList	m_ArticulationList;
	CExtensionChunkList m_ExtensionChunkList;
	DWORD				m_dwCountExtChk;
    BOOL                m_fNewFormat;           // Port can handle new format.
    BOOL                m_fDLS1;                // This is a DLS1 region.
};

class CRegionList : public AList
{
friend class CInstrObj;
friend class CCDirectMusicPortDownload;

public:
	CRegionList(){}
	~CRegionList() 
	{
		while(!IsEmpty())
		{
			CRegion* pRegion = RemoveHead();
			delete pRegion;
		}
	}

    CRegion* GetHead(){return(CRegion *)AList::GetHead();}
	CRegion* GetItem(LONG lIndex){return(CRegion*)AList::GetItem(lIndex);}
    CRegion* RemoveHead(){return(CRegion *)AList::RemoveHead();}
	void Remove(CRegion* pRegion){AList::Remove((AListItem *)pRegion);}
	void AddTail(CRegion* pRegion){AList::AddTail((AListItem *)pRegion);}
};

#endif // #ifndef DMREGION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmregion.cpp ===
//
// dmregion.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <objbase.h>
#include "dmusicp.h"
#include "alist.h"
#include "dlsstrm.h"
#include "debug.h"
#include "dmart.h"
#include "debug.h"
#include "dmcollec.h"
#include "dmregion.h"
#include "dls2.h"

//////////////////////////////////////////////////////////////////////
// Class CRegion

//////////////////////////////////////////////////////////////////////
// CRegion::CRegion

CRegion::CRegion()
{
    m_dwCountExtChk = 0;
    m_fDLS1 = TRUE;
    m_fNewFormat = FALSE;
    m_fCSInitialized = FALSE;
//	InitializeCriticalSection(&m_DMRegionCriticalSection);
    m_fCSInitialized = TRUE;
	
	ZeroMemory(&m_RgnHeader, sizeof(m_RgnHeader));
	ZeroMemory(&m_WaveLink, sizeof(m_WaveLink));
	ZeroMemory(&m_WSMP, sizeof(m_WSMP));
	ZeroMemory(&m_WLOOP, sizeof(m_WLOOP));
}

//////////////////////////////////////////////////////////////////////
// CRegion::~CRegion

CRegion::~CRegion() 
{
    if (m_fCSInitialized)
    {
    	Cleanup();
//	    DeleteCriticalSection(&m_DMRegionCriticalSection);
    }
}

//////////////////////////////////////////////////////////////////////
// CRegion::Load

HRESULT CRegion::Load(CRiffParser *pParser)
{
    HRESULT hr = S_OK;

	RIFFIO ckNext;
    BOOL fDLS1;

//	EnterCriticalSection(&m_DMRegionCriticalSection);
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        fDLS1 = FALSE;
		switch(ckNext.ckid)
		{
        case FOURCC_CDL :
            hr = m_Condition.Load(pParser);
            break;
		case FOURCC_RGNH :
			hr = pParser->Read(&m_RgnHeader,sizeof(RGNHEADER));
			break;
		case FOURCC_WSMP :
			hr = pParser->Read(&m_WSMP, sizeof(WSMPL));
			if(m_WSMP.cSampleLoops)
			{
				hr = pParser->Read(m_WLOOP, sizeof(WLOOP));
			}
			break;
		case FOURCC_WLNK :
			hr = pParser->Read(&m_WaveLink,sizeof(WAVELINK));
			break;
		case FOURCC_LIST :
			switch (ckNext.fccType)
			{
            case FOURCC_LART :
                fDLS1 = TRUE;
            case FOURCC_LAR2 :
                CArticulation *pArticulation;
                                       
                try
                {
                    pArticulation = new CArticulation;
                }
                catch( ... )
                {
                    pArticulation = NULL;
                }

				if(pArticulation)
				{
                    pArticulation->m_fDLS1 = fDLS1;
					hr = pArticulation->Load(pParser);
                    m_ArticulationList.AddHead(pArticulation); 
				}
				else
				{
					hr =  E_OUTOFMEMORY;
				}
				
				break;

    		default:
				// If we get here we have an unknown chunk
				CExtensionChunk* pExtensionChunk = new CExtensionChunk;
				if(pExtensionChunk)
				{
					hr = pExtensionChunk->Load(pParser);
                    m_ExtensionChunkList.AddHead(pExtensionChunk);								
					m_dwCountExtChk++;
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
				break;
			}
			break;

		default:
			// If we get here we have an unknown chunk
			CExtensionChunk* pExtensionChunk = new CExtensionChunk;
			if(pExtensionChunk)
			{
				hr = pExtensionChunk->Load(pParser);
                m_ExtensionChunkList.AddHead(pExtensionChunk);								
				m_dwCountExtChk++;
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
			break;
		}
	}
    pParser->LeaveList();
	if(FAILED(hr))
	{
		Cleanup();
	}
//	LeaveCriticalSection(&m_DMRegionCriticalSection);

	return hr; 
}	

//////////////////////////////////////////////////////////////////////
// CRegion::Cleanup

void CRegion::Cleanup()
{
//	EnterCriticalSection(&m_DMRegionCriticalSection);
	
    while(!m_ArticulationList.IsEmpty())
	{
		CArticulation* pArticulation = m_ArticulationList.RemoveHead();
		delete pArticulation;
	}

	while(!m_ExtensionChunkList.IsEmpty())
	{
		CExtensionChunk* pExtChk = m_ExtensionChunkList.RemoveHead();
		delete pExtChk;
	}
	
//	LeaveCriticalSection(&m_DMRegionCriticalSection);
}

DWORD CRegion::Count()

{
	// Return the number of Offset Table entries needed during a call to Write
    if (m_Condition.m_fOkayToDownload)
    {
        DWORD dwCount = m_dwCountExtChk + 1;
        CArticulation *pArticulation = m_ArticulationList.GetHead();
        while (pArticulation)
        {
            while (pArticulation && (pArticulation->Count() == 0))
            {
                pArticulation = pArticulation->GetNext();
            }
            if (pArticulation)
            {
                dwCount += pArticulation->Count();
                if (m_fNewFormat)
                {
                    pArticulation = pArticulation->GetNext();
                }
                else
                {
                    break;
                }
            }
        }
        return dwCount;
    }
    return 0;
}


void CRegion::SetPort(CDirectMusicPortDownload *pPort, BOOL fNewFormat, BOOL fSupportsDLS2)

{
    m_fNewFormat = fNewFormat;
    if (fSupportsDLS2)
    {
        m_Condition.Evaluate(pPort);
    }
    else
    {
        m_Condition.m_fOkayToDownload = m_fDLS1;
    }
    if (m_Condition.m_fOkayToDownload)
    {
 	    CArticulation *pArticulation = m_ArticulationList.GetHead();
        for (;pArticulation;pArticulation = pArticulation->GetNext())
        {
            pArticulation->SetPort(pPort,fNewFormat,fSupportsDLS2);
	    }
    }
}

BOOL CRegion::CheckForConditionals()

{
    BOOL fHasConditionals = FALSE;
 	CArticulation *pArticulation = m_ArticulationList.GetHead();
    for (;pArticulation;pArticulation = pArticulation->GetNext())
    {
        fHasConditionals = fHasConditionals || pArticulation->CheckForConditionals();
	}
    return fHasConditionals || !m_fDLS1 || m_Condition.HasChunk();
}

//////////////////////////////////////////////////////////////////////
// CRegion::Size

DWORD CRegion::Size()
{
	DWORD dwSize = 0;
	DWORD dwCountExtChk = 0;

    if (!m_Condition.m_fOkayToDownload)
    {
        return 0;
    }

//    EnterCriticalSection(&m_DMRegionCriticalSection);

	dwSize += CHUNK_ALIGN(sizeof(DMUS_REGION));

	// Calculate the space need for Region's articulation
	CArticulation *pArticulation = m_ArticulationList.GetHead();
    while (pArticulation)
    {
        while (pArticulation && (pArticulation->Count() == 0))
        {
            pArticulation = pArticulation->GetNext();
        }
        if (pArticulation)
        {
		    dwSize += pArticulation->Size();
            if (m_fNewFormat)
            {
                pArticulation = pArticulation->GetNext();
            }
            else
            {
                break;
            }
        }
	}

	// Calculate the space need for Region's extension chunks
	CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	for(; pExtChk; pExtChk = pExtChk->GetNext())
	{
		dwSize += pExtChk->Size();
		dwCountExtChk++;
	}

	// We want to validate the number of extension chunks
	if(m_dwCountExtChk != dwCountExtChk)
	{
		assert(false);
		dwSize = 0;
	}

//	LeaveCriticalSection(&m_DMRegionCriticalSection);
	
	return dwSize;
}

//////////////////////////////////////////////////////////////////////
// CRegion::Write

HRESULT CRegion::Write(void* pv, 
					   DWORD* pdwCurOffset, 
					   DWORD* pDMIOffsetTable, 
					   DWORD* pdwCurIndex, 
					   DWORD dwIndexNextRegion)
{
	HRESULT hr = S_OK;

	// Argument validation - Debug
	assert(pv);
	assert(pdwCurOffset);
	assert(pDMIOffsetTable);
	assert(pdwCurIndex);

    if (!m_Condition.m_fOkayToDownload)
    {
        return S_OK;
    }

//    EnterCriticalSection(&m_DMRegionCriticalSection);

	CopyMemory(pv, (void *)&m_RgnHeader, sizeof(RGNHEADER));
	
	((DMUS_REGION*)pv)->WaveLink = m_WaveLink;
	((DMUS_REGION*)pv)->WSMP = m_WSMP;
	((DMUS_REGION*)pv)->WLOOP[0] = m_WLOOP[0];
	((DMUS_REGION*)pv)->ulNextRegionIdx = dwIndexNextRegion;

	*pdwCurOffset += CHUNK_ALIGN(sizeof(DMUS_REGION));
	DWORD dwRelativeCurOffset = CHUNK_ALIGN(sizeof(DMUS_REGION));
	
	// Write extension chunks
	CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	if(pExtChk)
	{
		DWORD dwCountExtChk = m_dwCountExtChk;
		DWORD dwIndexNextExtChk;
		((DMUS_REGION*)pv)->ulFirstExtCkIdx = dwIndexNextExtChk = *pdwCurIndex;
		
		for(; pExtChk && SUCCEEDED(hr) && dwCountExtChk > 0; pExtChk = pExtChk->GetNext())
		{
			if(dwCountExtChk == 1)
			{
				dwIndexNextExtChk = 0;
			}
			else
			{
				dwIndexNextExtChk = dwIndexNextExtChk + 1;
			}
			
			pDMIOffsetTable[(*pdwCurIndex)++] = *pdwCurOffset;
            // Store current position to calculate new dwRelativeCurOffset.
            DWORD dwOffsetStart = *pdwCurOffset; 
			hr = pExtChk->Write(((BYTE *)pv + dwRelativeCurOffset), 
								pdwCurOffset,
								dwIndexNextExtChk);
            dwRelativeCurOffset += (*pdwCurOffset - dwOffsetStart);
			dwCountExtChk--;
		}
	}
	else
	{
		// If no extension chunks set to zero
		((DMUS_REGION*)pv)->ulFirstExtCkIdx = 0;
	}
	
	if(SUCCEEDED(hr))
	{
        ((DMUS_REGION*)pv)->ulRegionArtIdx = 0;
		// Write region articulation if we have one
		CArticulation *pArticulation = m_ArticulationList.GetHead();
        while (pArticulation && (pArticulation->Count() == 0))
        {
            pArticulation = pArticulation->GetNext();
        }
        while (pArticulation)
		{
            DWORD dwNextArtIndex = 0;
            CArticulation *pNextArt = NULL;
            if (m_fNewFormat)
            {
                pNextArt = pArticulation->GetNext();
                while (pNextArt && (pNextArt->Count() == 0))
                {
                    pNextArt = pNextArt->GetNext();
                }
                if (pNextArt)
                {
                    dwNextArtIndex = *pdwCurIndex + pArticulation->Count();
                }
            }
            if (((DMUS_REGION*)pv)->ulRegionArtIdx == 0)
            {
                ((DMUS_REGION*)pv)->ulRegionArtIdx = *pdwCurIndex;
            }
			pDMIOffsetTable[(*pdwCurIndex)++] = *pdwCurOffset;
            // Store current position to calculate new dwRelativeCurOffset.
            DWORD dwOffsetStart = *pdwCurOffset; 
            hr = pArticulation->Write(((BYTE *)pv + dwRelativeCurOffset),
										pdwCurOffset,
										pDMIOffsetTable,
										pdwCurIndex,
                                        dwNextArtIndex);
            dwRelativeCurOffset += (*pdwCurOffset - dwOffsetStart);
            pArticulation = pNextArt;
		}
	}

//	LeaveCriticalSection(&m_DMRegionCriticalSection);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmportdl.h ===
//
// dmportdl.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// @doc EXTERNAL
//

#ifndef DMPORTDL_H
#define DMPORTDL_H 

#include "dmusicc.h"
#include "dmdlinst.h"
#include "dmdload.h"
////#include "dmdlwave.h"
#include "..\shared\dmusiccp.h"

class CDLSFeature : public AListItem
{
public:
	CDLSFeature*    GetNext(){return(CDLSFeature*)AListItem::GetNext();}
    GUID    m_guidID;       // GUID for query.
    long    m_lResult;      // Data returned by query.
    HRESULT m_hr;           // Indicates whether the synth supported the Query.
};

class CDLSFeatureList : public AList
{
public:
    ~CDLSFeatureList() { Clear(); }
    void Clear()
	{
		while(!IsEmpty())
		{
			CDLSFeature* pFeature = RemoveHead();
			delete pFeature;
		}
	}
    CDLSFeature* GetHead(){return (CDLSFeature *)AList::GetHead();}
    CDLSFeature* RemoveHead(){return(CDLSFeature *)AList::RemoveHead();}
	void Remove(CDLSFeature* pFeature){AList::Remove((AListItem *)pFeature);}
};

#define DLB_HASH_SIZE   31  // Hash table for download buffer lists.

class CDirectSoundWave;

class CDirectMusicPortDownload : public IDirectMusicPortDownload
{
friend class CCollection;
friend class CInstrument;
friend class CInstrObj;
friend class CConditionChunk;
friend class CDirectMusicDownloadedWave;
friend class CDirectMusicVoice;
friend class CDirectSoundWaveDownload;

public:
    CDirectMusicPortDownload();
    virtual ~CDirectMusicPortDownload();

    STDMETHODIMP GetDLId(DWORD* pdwStartDLId, DWORD dwCount);
    
    STDMETHOD(Refresh)(
        THIS_
        DWORD dwDLId,
        DWORD dwFlags) PURE;

    static void GetDLIdP(DWORD* pdwStartDLId, DWORD dwCount);
        
protected:
    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPortDownload
    STDMETHODIMP GetBuffer(DWORD dwId, IDirectMusicDownload** ppIDMDownload);
    STDMETHODIMP AllocateBuffer(DWORD dwSize, IDirectMusicDownload** ppIDMDownload);
    STDMETHODIMP FreeBuffer(IDirectMusicDownload* pIDMDownload);
    STDMETHODIMP Download(IDirectMusicDownload* pIDMDownload);
    STDMETHODIMP Unload(IDirectMusicDownload* pIDMDownload);
    STDMETHODIMP GetAppend(DWORD* pdwAppend);

    
    // Class
    STDMETHODIMP DownloadP(IDirectMusicInstrument* pInstrument,
                           IDirectMusicDownloadedInstrument** ppDownloadedInstrument,
                           DMUS_NOTERANGE* NoteRanges,
                           DWORD dwNumNoteRanges,
                           BOOL fVersion2);
    STDMETHODIMP UnloadP(IDirectMusicDownloadedInstrument* pDownloadedInstrument);
    
    STDMETHODIMP DownloadWaveP(IDirectSoundWave *pWave,               
                               IDirectSoundDownloadedWaveP **ppWave,
                               REFERENCE_TIME rtStartHint);
                               
    STDMETHODIMP UnloadWaveP(IDirectSoundDownloadedWaveP *pWave);                               

    STDMETHODIMP AllocVoice(
        IDirectSoundDownloadedWaveP *pWave,          // Wave to play on this voice
        DWORD dwChannel,                            // Channel and channel group
        DWORD dwChannelGroup,                       //  this voice will play on
        REFERENCE_TIME rtStart,
        SAMPLE_TIME stLoopStart,
        SAMPLE_TIME stLoopEnd,                                                        
        IDirectMusicVoiceP **ppVoice);               // Returned voice
        
    STDMETHODIMP GetCachedAppend(                                            
        DWORD *pdw);                                // DWORD to receive append        
        
        
private:  
    STDMETHODIMP GetBufferInternal(DWORD dwDLId,IDirectMusicDownload** ppIDMDownload);
    STDMETHODIMP QueryDLSFeature(REFGUID rguidID, long * plResult);
    void ClearDLSFeatures();
    STDMETHODIMP GetWaveRefs(IDirectMusicDownload* ppDownloadedBuffers[],
                             DWORD* pdwWaveRefs,
                             DWORD* pdwWaveIds,
                             DWORD dwNumWaves,
                             CInstrument* pCInstrument,
                             DMUS_NOTERANGE* NoteRanges,
                             DWORD dwNumNoteRanges);
    STDMETHODIMP FindDownloadedInstrument(DWORD dwId, CDownloadedInstrument** ppDMDLInst);
    STDMETHODIMP AddDownloadedInstrument(CDownloadedInstrument* pDMDLInst);
    STDMETHODIMP RemoveDownloadedInstrument(CDownloadedInstrument* pDMDLInst);
    
    STDMETHODIMP FindDownloadedWaveObject(IDirectSoundWave *pWave,
                                          CDirectMusicDownloadedWave **ppDLWave);
                                          
    STDMETHODIMP AddDownloadedWaveObject(CDirectMusicDownloadedWave *pDLWave);                                          

    STDMETHODIMP RemoveDownloadedWaveObject(CDirectMusicDownloadedWave *pDLWave);
    
    STDMETHODIMP AllocWaveArticulation(IDirectSoundWave *pWave, IDirectMusicDownload **ppDownload);
    
public:
    static CRITICAL_SECTION sDMDLCriticalSection;
    static DWORD sNextDLId;

protected:
    CDLSFeatureList             m_DLSFeatureList;       // Cached list of DLS queries, built and then freed during each download.
    CDLInstrumentList			m_DLInstrumentList;     // Linked list of downloaded instruments,
                                                        // each represented by an IDirectMusicDownloadedInstrument
                                                        // interface. 
    CDLBufferList	            m_DLBufferList[DLB_HASH_SIZE];         // Linked list of downloaded buffers, each
                                                        // represented by an IDirectMusicDownload interface.
    CRITICAL_SECTION			m_DMDLCriticalSection;  // For the interface
    BOOL                        m_fDMDLCSinitialized;    
    DWORD						m_dwAppend;             // Append in samples, as required by synth.
    DWORD                       m_fNewFormat;           // Set if the synth handles DMUS_INSTRUMENT2 chunks.
    long						m_cRef;
    
    // Additions to track downloaded wave objects
    //
//    CDMDLWaveList               m_DLWaveList;           // Holds all wave obj interfaces downloaded to this port

private:    
    CRITICAL_SECTION m_CDMDLCriticalSection; // for the class
    BOOL             m_fCDMDLCSinitialized;};

#define APPEND_NOT_RETRIEVED	0xFFFFFFFF
#define NEWFORMAT_NOT_RETRIEVED 0xFFFFFFFF

#endif // #ifndef DMPORTDL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmsport7.h ===
//
// dmsport7.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// CDirectMusicSynthPort7 implementation; code specific to DX-7 style ports
// 
#ifndef _DMSPORT7_H_
#define _DMSPORT7_H_

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7
//
class CDirectMusicSynthPort7 : public CDirectMusicSynthPort
{
public:
    CDirectMusicSynthPort7(
        PORTENTRY           *pe,
        CDirectMusic        *pDM,
        IDirectMusicSynth   *pSynth);

    ~CDirectMusicSynthPort7();

    HRESULT Initialize(
        DMUS_PORTPARAMS *pPortParams);   

    // Overridden public methods
    //
    STDMETHODIMP Close();

    STDMETHODIMP Activate(
        BOOL fActivate);

    STDMETHODIMP KsProperty(
        IN PKSPROPERTY  pProperty,
        IN ULONG        ulPropertyLength,
        IN OUT LPVOID   pvPropertyData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned);

    STDMETHODIMP GetFormat(
        LPWAVEFORMATEX  pwfex,
        LPDWORD         pdwwfex,
        LPDWORD         pcbBuffer);

    STDMETHODIMP SetDirectSound(
        LPDIRECTSOUND       pDirectSound,
        LPDIRECTSOUNDBUFFER pDirectSoundBuffer);

private:
    void CacheSinkUsesDSound();

private:
    IDirectMusicSynth       *m_pSynth;              // 6.1/7.0 Synth 
    IDirectMusicSynthSink   *m_pSink;               //  and sink 
    bool                    m_fSinkUsesDSound;      // Does sink use dsound?
    bool                    m_fUsingDirectMusicDSound;
                                                    // Using default dsound
    LPDIRECTSOUND           m_pDirectSound;         // Directsound object and
    LPDIRECTSOUNDBUFFER     m_pDirectSoundBuffer;   //  buffer
    LPWAVEFORMATEX          m_pwfex;                // Cached wave format
    long                    m_lActivated;           // Is port active?
    bool                    m_fHasActivated;        // Has it ever activated?
};

#endif // _DMSPORT7_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmsport.cpp ===
//
// dmsport.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// CDirectMusicSynthPort implementation; code common to DX7 and DX8 style ports.
// 
#include <objbase.h>
#include "debug.h"
#include <mmsystem.h>

#include "dmusicp.h"
#include "validate.h"
#include "debug.h"
#include "dmvoice.h"

#include "dmsport7.h"
#include "dmsport8.h"

const GUID guidZero = {0};

HRESULT CALLBACK FreeHandle(HANDLE hHandle, HANDLE hUserData);

////////////////////////////////////////////////////////////////////////////////
//
// CreateCDirectMusicSynthPort
//
// Determine which type of port (DX7 or DX8) is being created and which
// types the requested synth supports. Create the highest level of 
// port possible.
//
HRESULT 
CreateCDirectMusicSynthPort(
    PORTENTRY               *pe, 
    CDirectMusic            *pDM, 
    UINT                    uVersion,
    DMUS_PORTPARAMS         *pPortParams,
    IDirectMusicPort        **ppPort)
{
    HRESULT hr = S_OK;

    // Determine what type of connection we can get. We can only
    // do DX-8 if we've been asked for it and the synth supports
    // it.
    //
    IDirectMusicSynth *pSynth = NULL;
    IDirectMusicSynth8 *pSynth8 = NULL;

    bool fAudioPathSet = false;
    bool fAudioPath = false;

    if (uVersion >= 8 && (pPortParams->dwValidParams & DMUS_PORTPARAMS_FEATURES))
    {
        fAudioPathSet = true;                
        fAudioPath = (pPortParams->dwFeatures & DMUS_PORT_FEATURE_AUDIOPATH) ? true : false;
    }

    if (!fAudioPath)
    {
        // Specifically requested old style interface.
        //
        uVersion = 7;
    }

    if (uVersion >= 8) 
    {
        // Asked for DX-8 interfaces.
        //
        hr = CoCreateInstance(
            pe->pc.guidPort,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IDirectMusicSynth8,
            (void**)&pSynth8);

        // If creation failed for some legitimate reason, return.
        // If E_NOINTERFACE then we can try to fall back on DX-7.
        //
        if (FAILED(hr) && hr != E_NOINTERFACE)
        {
            return hr;
        }
    }
       
    if (uVersion < 8 || hr == E_NOINTERFACE)
    {
        // Asked for DX-7 interfaces or we couldn't get DX-8 interfaces.
        //
        hr = CoCreateInstance(
            pe->pc.guidPort,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IDirectMusicSynth,
            (void**)&pSynth);

        // If synth doesn't support that, we have nothing to fall back
        // onto.
        //
        if (FAILED(hr)) 
        {
            return hr;
        }
    }

    // Create and initialize the correct type of port.
    //        
    if (pSynth)
    {
        assert(!pSynth8);
    
        CDirectMusicSynthPort7 *pPort7 = new CDirectMusicSynthPort7(pe, pDM, pSynth);

        if (pPort7 == NULL) 
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pPort7->Initialize(pPortParams);
        }

        if (SUCCEEDED(hr))
        {
            *ppPort = static_cast<IDirectMusicPort*>(pPort7);
            (*ppPort)->AddRef();
        }

        RELEASE(pPort7);
        RELEASE(pSynth);

        if (SUCCEEDED(hr) && fAudioPath)
        {
            // They asked for an audio path but ended up without it
            //
            pPortParams->dwFeatures &= ~DMUS_PORT_FEATURE_AUDIOPATH;
            hr = S_FALSE;
        }
    }
    else if (pSynth8)
    {
        assert(!pSynth);

        CDirectMusicSynthPort8 *pPort8 = new CDirectMusicSynthPort8(pe, pDM, pSynth8);

        if (pPort8 == NULL) 
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pPort8->Initialize(pPortParams);
        }

        if (SUCCEEDED(hr))
        {
            *ppPort = static_cast<IDirectMusicPort*>(pPort8);
            (*ppPort)->AddRef();
        }

        RELEASE(pPort8);
        RELEASE(pSynth8);
    }
    else
    {
        assert(false);
    }

    return hr;
}   

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::CDirectMusicSynthPort
//
CDirectMusicSynthPort::CDirectMusicSynthPort(
    PORTENTRY           *pPE,
    CDirectMusic        *pDM,
    IDirectMusicSynth   *pSynth)
{
    m_cRef                  = 1;
    
    m_pDM                   = pDM;
    m_pSynth                = pSynth;
    m_dmpc                  = pPE->pc;

    m_pNotify               = NULL;
    m_pSynthPropSet         = NULL;
    m_pSinkPropSet          = NULL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::~CDirectMusicSynthPort
//
CDirectMusicSynthPort::~CDirectMusicSynthPort()
{
    Close();
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::QueryInterface
//
STDMETHODIMP
CDirectMusicSynthPort::QueryInterface(const IID &iid,
                                        void **ppv)
{
    V_INAME(IDirectMusicPort::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicPort)
    {
        *ppv = static_cast<IDirectMusicPort*>(this);
    }
    else if (iid == IID_IDirectMusicPortP)
    {
        *ppv = static_cast<IDirectMusicPortP*>(this);
    }
    else if (iid == IID_IDirectMusicPortDownload)
    {
        *ppv = static_cast<IDirectMusicPortDownload*>(this);		
    }
    else if (iid == IID_IDirectMusicPortPrivate)
    {
        *ppv = static_cast<IDirectMusicPortPrivate*>(this);
    }
    else if (iid == IID_IKsControl)
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::AddRef
//
STDMETHODIMP_(ULONG)
CDirectMusicSynthPort::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Release
//
STDMETHODIMP_(ULONG)
CDirectMusicSynthPort::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Initialize
//
// Initialization common to all versions
//
HRESULT
CDirectMusicSynthPort::Initialize(
    DMUS_PORTPARAMS *pPortParams)
{
    HRESULT hr;

    // Get our notification interface
    //
    hr = m_pDM->QueryInterface(IID_IDirectMusicPortNotify, (void**)&m_pNotify);
    if (SUCCEEDED(hr))
    {
        // HACK HACK: Don't hold a refcount against DirectMusic
        //
        m_pNotify->Release();
    }
    else
    {
        TraceI(1, "Failed to get IDirectMusicPortNotify\n");
    }

    // Save off property set handler
    //
    if (SUCCEEDED(hr))
    {
        hr = m_pSynth->QueryInterface(
            IID_IKsControl, 
            (void**)&m_pSynthPropSet);
        if (FAILED(hr)) 
        {
            TraceI(1, "NOTE: Synth has no property set\n");
              
            // This is a warning, not an error
            //
            hr = S_OK;
        }
    }

    // Cache number of channel groups
    //
    if (SUCCEEDED(hr))
    {
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
        {
            m_dwChannelGroups = pPortParams->dwChannelGroups;
        }
        else
        {
            m_dwChannelGroups = 1;
        }

        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_FEATURES)
        {
            m_dwFeatures = pPortParams->dwFeatures;
        }
        else
        {
            m_dwFeatures = 0;
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Close
//
STDMETHODIMP CDirectMusicSynthPort::Close()
{
    if (m_pNotify)
    {   
        m_pNotify->NotifyFinalRelease(static_cast<IDirectMusicPort*>(this));
        m_pNotify = NULL;
    }

    RELEASE(m_pSynthPropSet);
    RELEASE(m_pSinkPropSet);

    m_pDM = NULL;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::InitChannelPriorities 
//
//
static DWORD adwChannelPriorities[16] =
{
    DAUD_CHAN1_DEF_VOICE_PRIORITY,
    DAUD_CHAN2_DEF_VOICE_PRIORITY,
    DAUD_CHAN3_DEF_VOICE_PRIORITY,
    DAUD_CHAN4_DEF_VOICE_PRIORITY,
    DAUD_CHAN5_DEF_VOICE_PRIORITY,
    DAUD_CHAN6_DEF_VOICE_PRIORITY,
    DAUD_CHAN7_DEF_VOICE_PRIORITY,
    DAUD_CHAN8_DEF_VOICE_PRIORITY,
    DAUD_CHAN9_DEF_VOICE_PRIORITY,
    DAUD_CHAN10_DEF_VOICE_PRIORITY,
    DAUD_CHAN11_DEF_VOICE_PRIORITY,
    DAUD_CHAN12_DEF_VOICE_PRIORITY,
    DAUD_CHAN13_DEF_VOICE_PRIORITY,
    DAUD_CHAN14_DEF_VOICE_PRIORITY,
    DAUD_CHAN15_DEF_VOICE_PRIORITY,
    DAUD_CHAN16_DEF_VOICE_PRIORITY
};

void CDirectMusicSynthPort::InitChannelPriorities(
    UINT uLowCG,
    UINT uHighCG)
{
    while (uLowCG <= uHighCG)
    {
        for (UINT uChannel = 0; uChannel < 16; uChannel++)
        {
            m_pSynth->SetChannelPriority(uLowCG, uChannel, adwChannelPriorities[uChannel]);        
        }

        uLowCG++;
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::SetSinkKsControl 
//
//
void CDirectMusicSynthPort::SetSinkKsControl(
    IKsControl *pSinkKsControl)
{
    RELEASE(m_pSinkPropSet);

    m_pSinkPropSet = pSinkKsControl;
    if (m_pSinkPropSet) 
    {
        m_pSinkPropSet->AddRef();
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::InitializeVolumeBoost
//
//
void CDirectMusicSynthPort::InitializeVolumeBoost()
{
    HRESULT hr;

    if (m_pSynthPropSet)
    {
    	// set volume boost
        //
    	KSPROPERTY ksp;
    	ULONG cb;
        ULONG lVolume = 0;          // zero boost by default

    	ZeroMemory(&ksp, sizeof(ksp));
    	ksp.Set   = KSPROPSETID_Synth;
    	ksp.Id    = KSPROPERTY_SYNTH_VOLUMEBOOST;
    	ksp.Flags = KSPROPERTY_TYPE_SET;

    	hr = m_pSynthPropSet->KsProperty(&ksp,
    		     				        sizeof(ksp),
    			     			        (LPVOID)&lVolume,
    				     		        sizeof(lVolume),
    					     	        &cb);
        if (FAILED(hr))
        {
            TraceI(2, "NOTE: Set volume boost failed %08X\n", hr);
        }
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Compact
//
STDMETHODIMP CDirectMusicSynthPort::Compact()
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetCaps
//
STDMETHODIMP CDirectMusicSynthPort::GetCaps(
    LPDMUS_PORTCAPS pPortCaps)
{
    V_INAME(IDirectMusicPort::GetCaps);
    V_STRUCTPTR_WRITE(pPortCaps, DMUS_PORTCAPS);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    CopyMemory(pPortCaps, &m_dmpc, sizeof(DMUS_PORTCAPS));
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::DeviceIoControl
//
STDMETHODIMP CDirectMusicSynthPort::DeviceIoControl(
    DWORD           dwIoControlCode, 
    LPVOID          lpInBuffer, 
    DWORD           nInBufferSize, 
    LPVOID          lpOutBuffer, 
    DWORD           nOutBufferSize, 
    LPDWORD         lpBytesReturned, 
    LPOVERLAPPED    lpOverlapped)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::SetNumChannelGroups
//
STDMETHODIMP CDirectMusicSynthPort::SetNumChannelGroups(
    DWORD dwChannelGroups)      
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    HRESULT hr = m_pSynth->SetNumChannelGroups(dwChannelGroups);

    if (FAILED(hr))
    {
        return hr;
    }

    if (dwChannelGroups > m_dwChannelGroups)
    {
        InitChannelPriorities(m_dwChannelGroups + 1, dwChannelGroups);
    }
    
    m_dwChannelGroups = dwChannelGroups;

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetNumChannelGroups
//
STDMETHODIMP CDirectMusicSynthPort::GetNumChannelGroups(
    LPDWORD pdwChannelGroups)      
{
    V_INAME(IDirectMusicPort::GetNumChannelGroups);
    V_PTR_WRITE(pdwChannelGroups, DWORD);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    *pdwChannelGroups = m_dwChannelGroups;
    
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::PlayBuffer
//
STDMETHODIMP CDirectMusicSynthPort::PlayBuffer(
    IDirectMusicBuffer *pIBuffer)
{
    HRESULT hr;
    REFERENCE_TIME rt;
    DWORD cb;
    LPBYTE lpb;

    V_INAME(IDirectMusicPort::PlayBuffer);
    V_INTERFACE(pIBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    hr = pIBuffer->GetStartTime(&rt);
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    hr = pIBuffer->GetUsedBytes(&cb);
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    hr = pIBuffer->GetRawBufferPtr(&lpb);
    if (!SUCCEEDED(hr))
    {
        return hr;
    }
    
    return m_pSynth->PlayBuffer(rt, lpb, cb);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::SetEventNotification
//
STDMETHODIMP CDirectMusicSynthPort::SetReadNotificationHandle(
    HANDLE hEvent)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Read
//
STDMETHODIMP CDirectMusicSynthPort::Read(
	IDirectMusicBuffer *pIBuffer)                          
{
    V_INAME(IDirectMusicPort::Read);
    V_INTERFACE(pIBuffer);
    
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::DownloadInstrument
//
STDMETHODIMP CDirectMusicSynthPort::DownloadInstrument(
    IDirectMusicInstrument* pInstrument,
    IDirectMusicDownloadedInstrument** ppDownloadedInstrument,
    DMUS_NOTERANGE* pNoteRanges,
    DWORD dwNumNoteRanges)
{
    V_INAME(IDirectMusicPort::DownloadInstrument);
    V_INTERFACE(pInstrument);
	V_PTRPTR_WRITE(ppDownloadedInstrument);
	V_BUFPTR_READ(pNoteRanges, (dwNumNoteRanges * sizeof(DMUS_NOTERANGE)));

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

	return CDirectMusicPortDownload::DownloadP(pInstrument,
											   ppDownloadedInstrument,
											   pNoteRanges,
											   dwNumNoteRanges,
                                               TRUE);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::UnloadInstrument
//
STDMETHODIMP CDirectMusicSynthPort::UnloadInstrument(
    IDirectMusicDownloadedInstrument* pDownloadedInstrument)
{
    V_INAME(IDirectMusicPort::UnloadInstrument);
    V_INTERFACE(pDownloadedInstrument);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

	return CDirectMusicPortDownload::UnloadP(pDownloadedInstrument);
}

//////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Download
//
STDMETHODIMP CDirectMusicSynthPort::Download(
	IDirectMusicDownload* pIDMDownload)	
{
    V_INAME(IDirectMusicPort::Download);
    V_INTERFACE(pIDMDownload);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

	EnterCriticalSection(&m_DMDLCriticalSection);

	// If you can QI pIDMDownload for private interface IDirectMusicDownloadPrivate 
	// pIDMDownload is of type CDownloadBuffer.
	IDirectMusicDownloadPrivate* pDMDLP = NULL;
	HRESULT hr = pIDMDownload->QueryInterface(IID_IDirectMusicDownloadPrivate, (void **)&pDMDLP);

	if(SUCCEEDED(hr))
	{
		pDMDLP->Release();		

		hr = ((CDownloadBuffer *)pIDMDownload)->IsDownloaded();
		if(hr != S_FALSE)
		{
			LeaveCriticalSection(&m_DMDLCriticalSection);
			return DMUS_E_ALREADY_DOWNLOADED;
		}

		void* pvBuffer = NULL;

		hr = ((CDownloadBuffer *)pIDMDownload)->GetBuffer(&pvBuffer);

		if(pvBuffer == NULL)
		{
			hr = DMUS_E_BUFFERNOTSET;
		}

        if (SUCCEEDED(hr) && !(m_dwFeatures & DMUS_PORT_FEATURE_STREAMING))
        {
            DMUS_DOWNLOADINFO *pdl = (DMUS_DOWNLOADINFO*)pvBuffer;

            if (pdl->dwDLType == DMUS_DOWNLOADINFO_STREAMINGWAVE)
            {
                // That feature is disabled, pretend we don't understand
                //
                hr = DMUS_E_UNKNOWNDOWNLOAD;
            }
        }

		BOOL bFree = false;
		if(SUCCEEDED(hr))
		{
			hr = m_pSynth->Download(&(((CDownloadBuffer *)pIDMDownload)->m_DLHandle),
									pvBuffer, 
									&bFree);

			if(SUCCEEDED(hr))
			{
				// AddRef() before we add it to the list.
				pIDMDownload->AddRef();
                DWORD dwID = ((DMUS_DOWNLOADINFO*)pvBuffer)->dwDLId;
				((CDownloadBuffer *)pIDMDownload)->m_dwDLId = dwID;
				m_DLBufferList[dwID % DLB_HASH_SIZE].AddHead((CDownloadBuffer*)pIDMDownload);
				((CDownloadBuffer*)pIDMDownload)->IncDownloadCount();

				if(bFree)
				{
					pvBuffer = NULL;
                    DWORD dw;
					((CDownloadBuffer *)pIDMDownload)->GetHeader(&pvBuffer, &dw);
					((CDownloadBuffer *)pIDMDownload)->SetBuffer(NULL, 0, 0);
					delete [] pvBuffer;
				}
				else
				{
					// If we do not free buffer we need to AddRef()
					// We do not want buffer to go away until the IDirectMusicPort is 
					// finished with it.
					pIDMDownload->AddRef();
				}
			}
			else if(FAILED(hr))
			{
				((CDownloadBuffer *)pIDMDownload)->m_DLHandle = NULL;
			}
		}
	}
	
	LeaveCriticalSection(&m_DMDLCriticalSection);

	return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Unload
//
STDMETHODIMP CDirectMusicSynthPort::Unload(
	IDirectMusicDownload* pIDMDownload)	
{
    V_INAME(IDirectMusicPort::Unload);
    V_INTERFACE(pIDMDownload);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

	EnterCriticalSection(&m_DMDLCriticalSection);


	// If you can QI pIDMDownload for private interface IDirectMusicDownloadPrivate 
	// pIDMDownload is of type CDownloadBuffer.
	IDirectMusicDownloadPrivate* pDMDLP = NULL;
	HRESULT hr = pIDMDownload->QueryInterface(IID_IDirectMusicDownloadPrivate, (void **)&pDMDLP);

	if(SUCCEEDED(hr))
	{
		pDMDLP->Release();

        if (((CDownloadBuffer *)pIDMDownload)->IsDownloaded() == S_OK)
        {
		    if(((CDownloadBuffer *)pIDMDownload)->DecDownloadCount() == 0)
		    {
			    m_DLBufferList[((CDownloadBuffer *)pIDMDownload)->m_dwDLId % DLB_HASH_SIZE].Remove(
                    (CDownloadBuffer *)pIDMDownload);
			    pIDMDownload->Release();
			    hr = m_pSynth->Unload(((CDownloadBuffer *)pIDMDownload)->m_DLHandle, FreeHandle, (HANDLE)pIDMDownload);
		    }
        }
        else
        {
            TraceI(0, "CDirectMusicSynthPort::Unload- not downloaded\n");
        }
	}

	LeaveCriticalSection(&m_DMDLCriticalSection);
	
	return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetAppend
//
STDMETHODIMP CDirectMusicSynthPort::GetAppend(
    DWORD* pdwAppend)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    V_INAME(IDirectMusicPort::GetAppend);
    V_PTR_WRITE(pdwAppend, DWORD);

    return m_pSynth->GetAppend(pdwAppend);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetLatencyClock
//
STDMETHODIMP CDirectMusicSynthPort::GetLatencyClock(
    IReferenceClock **ppClock)
{
    V_INAME(IDirectMusicPort::GetLatencyClock);
    V_PTRPTR_WRITE(ppClock);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->GetLatencyClock(ppClock);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetRunningStats
//
STDMETHODIMP CDirectMusicSynthPort::GetRunningStats(
    LPDMUS_SYNTHSTATS pStats)
{
    V_INAME(IDirectMusicPort::GetRunningStats);
    V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->GetRunningStats(pStats);
}

#if 0
// XXX Different

#endif

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicPort::SetChannelPriority
//
STDMETHODIMP CDirectMusicSynthPort::SetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    DWORD dwPriority)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->SetChannelPriority(dwChannelGroup, dwChannel, dwPriority);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicPort::GetChannelPriority
//
STDMETHODIMP CDirectMusicSynthPort::GetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    LPDWORD pdwPriority)
{
    V_INAME(IDirectMusicPort::GetChannelPriority);
    V_PTR_WRITE(pdwPriority, DWORD);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->GetChannelPriority(dwChannelGroup, dwChannel, pdwPriority);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicPort::SetDirectSound
//
// XXX What does this mean in terms of DX8?
// XXX This can probably become pure virtual
//
STDMETHODIMP
CDirectMusicSynthPort::SetDirectSound(
    LPDIRECTSOUND pDirectSound,
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    V_INAME(IDirectMusicPort::SetDirectSound);
    V_INTERFACE_OPT(pDirectSound);
    V_INTERFACE_OPT(pDirectSoundBuffer);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetFormat
//
// XXX What does pcbBuffer mean in terms of DX8?
// XXX This can probably become pure virtual
//
STDMETHODIMP CDirectMusicSynthPort::GetFormat(
    LPWAVEFORMATEX  pwfex,
    LPDWORD         pdwwfex,
    LPDWORD         pcbBuffer)
{
    V_INAME(IDirectMusicPort::GetFormat);
    V_PTR_WRITE(pdwwfex, DWORD);
    V_BUFPTR_WRITE_OPT(pwfex, *pdwwfex);
    V_PTR_WRITE_OPT(pcbBuffer, DWORD);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::DownloadWave
//
STDMETHODIMP CDirectMusicSynthPort::DownloadWave(
    IDirectSoundWave *pWave,          
    IDirectSoundDownloadedWaveP **ppWave,
    REFERENCE_TIME rtStartHint)
{
    V_INAME(IDirectMusicPort::DownloadWave);
    V_INTERFACE(pWave);
	V_PTRPTR_WRITE(ppWave);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::UnloadWave
//
STDMETHODIMP CDirectMusicSynthPort::UnloadWave(
    IDirectSoundDownloadedWaveP *pDownloadedWave)
{
    V_INAME(IDirectMusicPort::UnloadWave);
    V_INTERFACE(pDownloadedWave);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::AllocVoice
//
STDMETHODIMP 
CDirectMusicSynthPort::AllocVoice(
    IDirectSoundDownloadedWaveP *pWave,     
    DWORD dwChannel,                       
    DWORD dwChannelGroup,                  
    REFERENCE_TIME rtStart,                     
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd,         
    IDirectMusicVoiceP **ppVoice)
{
    V_INAME(IDirectMusicPort::AllocVoice);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppVoice);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::AssignChannelToBuses
//
STDMETHODIMP 
CDirectMusicSynthPort::AssignChannelToBuses(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwBuses,
    DWORD cBusCount)
{
    V_INAME(IDirectMusicPort::AssignChannelToBuses);
    V_BUFPTR_WRITE(pdwBuses, sizeof(DWORD) * cBusCount);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::StartVoice
//
STDMETHODIMP CDirectMusicSynthPort::StartVoice(          
    DWORD dwVoiceId,
    DWORD dwChannel,
    DWORD dwChannelGroup,
    REFERENCE_TIME rtStart,
    DWORD dwDLId,
    LONG prPitch,
    LONG vrVolume,
    SAMPLE_TIME stVoiceStart,
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::StopVoice
//
STDMETHODIMP CDirectMusicSynthPort::StopVoice(          
    DWORD dwVoiceId,
    REFERENCE_TIME rtStop)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetVoiceState
//
STDMETHODIMP CDirectMusicSynthPort::GetVoiceState(
    DWORD dwVoice[], 
    DWORD cbVoice,
    DMUS_VOICE_STATE VoiceState[]) 
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Refresh
//
STDMETHODIMP CDirectMusicSynthPort::Refresh(
    DWORD dwDownloadId,
    DWORD dwFlags)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::SetSink
//
STDMETHODIMP CDirectMusicSynthPort::SetSink(
    IDirectSoundConnect *pSinkConnect)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetSink
//
STDMETHODIMP CDirectMusicSynthPort::GetSink(
    IDirectSoundConnect **ppSinkConnect)
{
    return E_NOTIMPL;
}


////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::KsProperty
//
STDMETHODIMP CDirectMusicSynthPort::KsProperty(
        IN PKSPROPERTY  pProperty,
        IN ULONG        ulPropertyLength,
        IN OUT LPVOID   pvPropertyData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned)
{
    LONG lVolume;

    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pProperty, ulPropertyLength);

    // pvPropertyData is not optional on a SET operation
    //
    if (pProperty->Flags & KSPROPERTY_TYPE_SET)
    {
        V_BUFPTR_WRITE(pvPropertyData, ulDataLength);
    } 
    else 
    {
        V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
    }
    
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    HRESULT hr = DMUS_E_UNKNOWN_PROPERTY;

    // Don't let callers touch property sets we use
    //
    if (pProperty->Set == KSPROPSETID_Synth) 
    {
        if (pProperty->Id != KSPROPERTY_SYNTH_VOLUME)
        {
            return DMUS_E_UNKNOWN_PROPERTY;
        }
        else if (ulDataLength != sizeof(LONG))
        {
            return E_INVALIDARG;
        }
        else if (pProperty->Flags & KSPROPERTY_TYPE_SET)
        {
            lVolume = *(LONG*)pvPropertyData;

            // Clamp to -200..+20 db
            //
            if (lVolume < -20000) 
            {
                lVolume = -20000;
                pvPropertyData = &lVolume;
            }
            else if (lVolume > 2000)
            {
                lVolume = 2000;
                pvPropertyData = &lVolume;
            }
        }
    }
    else if (pProperty->Set == KSPROPSETID_Synth_Dls)
    {
        return DMUS_E_UNKNOWN_PROPERTY;
    }


    if (m_pSynthPropSet)
    {
        hr = m_pSynthPropSet->KsProperty(pProperty, 
                                         ulPropertyLength,
                                         pvPropertyData,
                                         ulDataLength,
                                         pulBytesReturned);
    }

    if (hr == DMUS_E_UNKNOWN_PROPERTY && m_pSinkPropSet) 
    {
        hr = m_pSinkPropSet->KsProperty(pProperty, 
                                        ulPropertyLength,
                                        pvPropertyData,
                                        ulDataLength,
                                        pulBytesReturned);
    }
    
    return hr;        
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::KsMethod
//
STDMETHODIMP CDirectMusicSynthPort::KsMethod(
        IN PKSMETHOD    pMethod,
        IN ULONG        ulMethodLength,
        IN OUT LPVOID   pvMethodData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    // If they don't support it, then it's unknown
    //
    HRESULT hr = DMUS_E_UNKNOWN_PROPERTY;
    if (m_pSynthPropSet)
    {
        hr = m_pSynthPropSet->KsMethod(pMethod, 
                                       ulMethodLength,
                                       pvMethodData,
                                       ulDataLength,
                                       pulBytesReturned);
    }

    if (hr == DMUS_E_UNKNOWN_PROPERTY && m_pSinkPropSet) 
    {
        hr = m_pSinkPropSet->KsMethod(pMethod, 
                                      ulMethodLength,
                                      pvMethodData,
                                      ulDataLength,
                                      pulBytesReturned);
    }
    
    return hr;        
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::KsEvent
//
STDMETHODIMP CDirectMusicSynthPort::KsEvent(
        IN PKSEVENT     pEvent,
        IN ULONG        ulEventLength,
        IN OUT LPVOID   pvEventData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    HRESULT hr = DMUS_E_UNKNOWN_PROPERTY;

    if (m_pSynthPropSet)
    {
        hr = m_pSynthPropSet->KsEvent(pEvent, 
                                      ulEventLength,
                                      pvEventData,
                                      ulDataLength,
                                      pulBytesReturned);
    }

    if (hr == DMUS_E_UNKNOWN_PROPERTY && m_pSinkPropSet) 
    {
        hr = m_pSinkPropSet->KsEvent(pEvent, 
                                     ulEventLength,
                                     pvEventData,
                                     ulDataLength,
                                     pulBytesReturned);
    }
    
    return hr;        
}

////////////////////////////////////////////////////////////////////////////////
//
// FreeHandle - Callback function used by Synth
//
HRESULT CALLBACK FreeHandle(HANDLE hHandle, HANDLE hUserData)
{
    DWORD dw;
	void* pvBuffer = NULL;
	HRESULT hr = ((CDownloadBuffer *)hUserData)->GetHeader(&pvBuffer, &dw);
	
	if(SUCCEEDED(hr))
	{
		hr = ((CDownloadBuffer *)hUserData)->SetBuffer(NULL, 0, 0);
		delete [] pvBuffer;
	}

	((CDownloadBuffer *)hUserData)->Release();

	return hr;
}

#if 0
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetCachedFormat
//
HRESULT CDirectMusicSynthPort::GetCachedFormat(LPWAVEFORMATEX *ppwfex)
{
    HRESULT hr;

    if (m_pwfex == NULL) 
    {
        DWORD cbWaveFormat;

        hr = m_pSynth->GetFormat(NULL, &cbWaveFormat);
        if (FAILED(hr))
        {
            TraceI(0, "DownloadWave: Synth failed GetFormat size query %08X\n", hr);
            return hr;
        }

        m_pwfex = (LPWAVEFORMATEX)(new BYTE[cbWaveFormat]);
        if (m_pwfex == NULL)
        {
            return E_OUTOFMEMORY;
        }

        hr = m_pSynth->GetFormat(m_pwfex, &cbWaveFormat);
        if (FAILED(hr)) 
        {
            delete[] m_pwfex;
            m_pwfex =  NULL;

            TraceI(0, "DownloadWave: Synth failed GetFormat %08X\n", hr);
            return hr;
        }
    }

    *ppwfex = m_pwfex;

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmsport7.cpp ===
//
// dmsport7.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// CDirectMusicSynthPort7 implementation; code specific to DX-7 style ports
// 
#include <objbase.h>
#include "debug.h"
#include <mmsystem.h>

#include "dmusicp.h"
#include "validate.h"
#include "debug.h"
#include "dmvoice.h"
#include "dmsport7.h"
#include "..\shared\dmusiccp.h" // For class ids.

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::CDirectMusicSynthPort7
//
//
CDirectMusicSynthPort7::CDirectMusicSynthPort7(
    PORTENTRY           *pe,
    CDirectMusic        *pDM,
    IDirectMusicSynth   *pSynth) :

        CDirectMusicSynthPort(pe, pDM, pSynth)
{
    m_pSynth = pSynth;
    m_pSynth->AddRef();

    m_pSink                     = NULL;
    m_fSinkUsesDSound           = false;
    m_fUsingDirectMusicDSound   = false;    
    m_pDirectSound              = NULL;
    m_pDirectSoundBuffer        = NULL;
    m_pwfex                     = NULL;
    m_lActivated                = 0;
    m_fHasActivated             = false;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::CDirectMusicSynthPort7
//
//
CDirectMusicSynthPort7::~CDirectMusicSynthPort7()
{
    Close();
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::Initialize
//
//
HRESULT CDirectMusicSynthPort7::Initialize(
    DMUS_PORTPARAMS *pPortParams)
{
    HRESULT             hrOpen;

    HRESULT             hr = CDirectMusicSynthPort::Initialize(pPortParams);
	IReferenceClock*    pClock = NULL;

    // Create the sink
    //
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_DirectMusicSynthSink,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDirectMusicSynthSink,
                              (LPVOID*)&m_pSink);
        if (FAILED(hr))
        {
            TraceI(1, "CoCreateInstance sink %08X\n", hr);
        }
    }

    // Give the sink's IKsControl to the base class. This needs to be
    // done here since the sink is a different type between 7 and 8.
    //
    if (SUCCEEDED(hr))
    {
        IKsControl *pKsControl = NULL;

        HRESULT hrTemp = m_pSink->QueryInterface(
            IID_IKsControl, 
            (void**)&pKsControl);
        if (FAILED(hrTemp))
        {
            TraceI(2, "NOTE: Sink has no property set interface.\n");
        }

        SetSinkKsControl(pKsControl);
        RELEASE(pKsControl);
    }

    // Get the master clock and give it to the synth and sink
    //
    if (SUCCEEDED(hr))
    {	
	    hr = m_pDM->GetMasterClock(NULL, &pClock);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to GetMasterClock %08X\n", hr);
        }
    }

    if (SUCCEEDED(hr)) 
    {
        hr = m_pSynth->SetMasterClock(pClock);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to SetMasterClock on synth %08X\n", hr);
        }
    }        

    if (SUCCEEDED(hr)) 
    {
        hr = m_pSink->SetMasterClock(pClock);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to SetMasterClock on sink %08X\n", hr);
        }
    }        

    // Connect sink to synth
    //
    if (SUCCEEDED(hr))
    {
        hr = m_pSynth->SetSynthSink(m_pSink);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to SetSink on synth %08X\n", hr);
        }
    }

    // Open the synth. We have to be careful to save the return code because
    // if S_FALSE is returned here it must be returned to the caller.
    //
    if (SUCCEEDED(hr))
    {
    	hrOpen = m_pSynth->Open(pPortParams);
        if (FAILED(hrOpen))
        {
            hr = hrOpen;
            TraceI(1, "Failed to open synth %08lX\n", hr);
        }
    }

    // Initialize channel priorities and volume boost
    //
    if (SUCCEEDED(hr))
    {
        InitChannelPriorities(1, m_dwChannelGroups);
        InitializeVolumeBoost();
    }

    CacheSinkUsesDSound();

    RELEASE(pClock);

    return SUCCEEDED(hr) ? hrOpen : hr;
}       

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::Close
//
STDMETHODIMP CDirectMusicSynthPort7::Close()
{
    if (m_pSynth)
    {
        m_pSynth->Activate(FALSE);
        m_pSynth->Close();

        RELEASE(m_pSynth);
    }

    RELEASE(m_pSink);
    RELEASE(m_pDirectSoundBuffer);
    RELEASE(m_pDirectSound);

    delete[] m_pwfex;
    m_pwfex = NULL;

    CDirectMusicSynthPort::Close();

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::Activate
//
STDMETHODIMP CDirectMusicSynthPort7::Activate(
    BOOL fActivate)
{
    HRESULT hr;

	V_INAME(IDirectMusicPort::Activate);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate)
    {
        if (InterlockedExchange(&m_lActivated, 1))
        {
            return S_FALSE;
        }
    }
    else
    {
        if (InterlockedExchange(&m_lActivated, 0) == 0) 
        {
            return S_FALSE;
        }
    }
	
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate)
    {
        if (m_fSinkUsesDSound)
        {
            if (m_pDirectSound == NULL)
            {
                m_fUsingDirectMusicDSound = true;

                hr = m_pDM->GetDirectSoundI(&m_pDirectSound);
                if (FAILED(hr))
                {
                    m_pDirectSound = NULL;
                    m_fUsingDirectMusicDSound = false;
                    m_lActivated = 0;
                    return hr;
                }
            }

            hr = m_pSink->SetDirectSound(m_pDirectSound, m_pDirectSoundBuffer);
            if (FAILED(hr))
            {
                if (m_fUsingDirectMusicDSound)
                {
                    m_pDM->ReleaseDirectSoundI();
                    m_pDirectSound = NULL;
                }
                m_fUsingDirectMusicDSound = false;
                m_lActivated = 0;
                return hr;
            }
        }
    }

    hr = m_pSynth->Activate(fActivate);
    if (FAILED(hr))
    {
        // Flip back activate state -- operation failed
        //
        m_lActivated = fActivate ? 0 : 1;

        return hr;
    }

    // XXX Reset activation flags???
    //
    if (fActivate)
    {
        m_fHasActivated = true;
    }
    else
    {
        if (m_fSinkUsesDSound)
        {
            m_pSink->SetDirectSound(NULL, NULL);        
            if (m_fUsingDirectMusicDSound)
            {
                m_pDM->ReleaseDirectSoundI();
                m_pDirectSound = NULL;
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::KsProperty
//
STDMETHODIMP CDirectMusicSynthPort7::KsProperty(
    IN PKSPROPERTY  pProperty,
    IN ULONG        ulPropertyLength,
    IN OUT LPVOID   pvPropertyData,
    IN ULONG        ulDataLength,
    OUT PULONG      pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pProperty, ulPropertyLength);
    V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (pProperty->Set == GUID_DMUS_PROP_SetSynthSink &&
        pProperty->Id == 0)
    {
        if (pProperty->Flags & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            if (ulDataLength < sizeof(ULONG))
            {
                return E_INVALIDARG;
            }
            else
            {
                *PULONG(pvPropertyData) = KSPROPERTY_TYPE_BASICSUPPORT |
                                          KSPROPERTY_TYPE_SET;
                *pulBytesReturned = sizeof(ULONG);
                return S_OK;
            }
        }
        else if (pProperty->Flags & KSPROPERTY_TYPE_GET)
        {
            return DMUS_E_GET_UNSUPPORTED;
        }

        // Trying to set a sink. Take care of it in the port
        //
        if (m_fHasActivated)
        {
            return DMUS_E_ALREADY_ACTIVATED;
        }

        if (ulDataLength != sizeof(LPUNKNOWN))
        {
            return E_INVALIDARG;
        }
            
        LPUNKNOWN pUnknown = *(LPUNKNOWN*)pvPropertyData;
        V_INTERFACE(pUnknown);

        IDirectMusicSynthSink *pSink;

        HRESULT hr;        
        hr = pUnknown->QueryInterface(IID_IDirectMusicSynthSink, (void**)&pSink);
        if (FAILED(hr))
        {
            return hr;
        }

        m_pSink->Release();
        m_pSink = pSink;
        m_pSink->AddRef();

        // Give synth sink master clock
        //
        IReferenceClock* pClock;
        
        hr = m_pDM->GetMasterClock(NULL, &pClock);

        if (FAILED(hr))
        {
            TraceI(1, "Failed to create master clock\n");
            return hr;
        }
        
        hr = m_pSink->SetMasterClock(pClock);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to set master clock on sink\n");
            return hr;
        }
        else
        {
            TraceI(1, "(KsProperty) Sink succeeded set master clock\n");
        }

        pClock->Release();

        hr = m_pSynth->SetSynthSink(m_pSink);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to set sink on synth\n");
            return hr;
        }

        // Recache the sink property set interface
        //
        IKsControl *pKsControl = NULL;
        hr = m_pSink->QueryInterface(IID_IKsControl, (void**)&pKsControl);
        if (FAILED(hr))
        {
            TraceI(0, "Warning: Sink does not support IKsControl\n");
            pKsControl = NULL;
        }

        SetSinkKsControl(pKsControl);

        CacheSinkUsesDSound();

        return S_OK;
    }

    // All other properties run through the default handlers
    //
    return CDirectMusicSynthPort::KsProperty(
        pProperty,
        ulPropertyLength,
        pvPropertyData,
        ulDataLength,
        pulBytesReturned);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::GetFormat
//
STDMETHODIMP CDirectMusicSynthPort7::GetFormat(
    LPWAVEFORMATEX  pwfex,
    LPDWORD         pdwwfex,
    LPDWORD         pcbBuffer)
{
    V_INAME(IDirectMusicPort::GetFormat);
    V_PTR_WRITE(pdwwfex, DWORD);
    V_BUFPTR_WRITE_OPT(pwfex, *pdwwfex);
    V_PTR_WRITE_OPT(pcbBuffer, DWORD);

    HRESULT hr = m_pSynth->GetFormat(pwfex, pdwwfex);
    if (FAILED(hr))
    {
        return hr;
    }

    //only get the buffer size if pcbBuffer is valid
    if (pcbBuffer != NULL)
    {
        hr = m_pSink->GetDesiredBufferSize(pcbBuffer);
    }
    
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicPort7::SetDirectSound
//
STDMETHODIMP CDirectMusicSynthPort7::SetDirectSound(
    LPDIRECTSOUND       pDirectSound,
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    V_INAME(IDirectMusicPort::SetDirectSound);
    V_INTERFACE_OPT(pDirectSound);
    V_INTERFACE_OPT(pDirectSoundBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_lActivated)
    {
        return DMUS_E_ALREADY_ACTIVATED;
    }

    if (pDirectSoundBuffer && !pDirectSound)
    {
        return E_INVALIDARG;
    }

    if (m_pDirectSound)
    {
        if (m_fUsingDirectMusicDSound)
        {
            ((CDirectMusic*)m_pDM)->ReleaseDirectSoundI();
            m_pDirectSound = NULL;
        }
        else
        {
            m_pDirectSound->Release();
        }
    }

    if (m_pDirectSoundBuffer)
    {
        m_pDirectSoundBuffer->Release();
    }

    m_pDirectSound = pDirectSound;
    m_pDirectSoundBuffer = pDirectSoundBuffer;

    if (m_pDirectSound)
    {
        m_pDirectSound->AddRef();
    }

    if (m_pDirectSoundBuffer)
    {
        m_pDirectSoundBuffer->AddRef();
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::CacheSinkUsesDSound
//
void CDirectMusicSynthPort7::CacheSinkUsesDSound()
{
    m_fSinkUsesDSound = false;

    if (m_pSinkPropSet) 
    {
        HRESULT hr;
        KSPROPERTY ksp;
        ULONG ulUsesDSound;
        ULONG cb;

    	ZeroMemory(&ksp, sizeof(ksp));
    	ksp.Set   = GUID_DMUS_PROP_SinkUsesDSound;
    	ksp.Id    = 0;
    	ksp.Flags = KSPROPERTY_TYPE_GET;

        hr = m_pSinkPropSet->KsProperty(&ksp,
    				       	            sizeof(ksp),
    						            (LPVOID)&ulUsesDSound,
    						            sizeof(ulUsesDSound),
    						            &cb);
        if (SUCCEEDED(hr) && ulUsesDSound)
        {
            TraceI(2, "This synth sink uses DirectSound\n");
            m_fSinkUsesDSound = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmsport8.h ===
//
// dmsport8.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// CDirectMusicSynthPort8 implementation; code specific to DX-8 style ports
// 

#ifndef _DMSPORT8_H_
#define _DMSPORT8_H_

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8
//
class CDirectMusicSynthPort8 : public CDirectMusicSynthPort
{
public:
    CDirectMusicSynthPort8(
        PORTENTRY           *pe,
        CDirectMusic        *pDM,
        IDirectMusicSynth8  *pSynth);

    ~CDirectMusicSynthPort8();

    HRESULT Initialize(
        DMUS_PORTPARAMS *pPortParams);   

    // Overridden public methods
    //
    STDMETHODIMP Close();

    STDMETHODIMP Activate(
        BOOL fActivate);
        
    STDMETHODIMP SetDirectSound(
        LPDIRECTSOUND       pDirectSound,
        LPDIRECTSOUNDBUFFER pDirectSoundBuffer);

    STDMETHODIMP DownloadWave(
        IDirectSoundWave *pWave,               
        IDirectSoundDownloadedWaveP **ppWave,
        REFERENCE_TIME rtStartHint);

    STDMETHODIMP UnloadWave(
        IDirectSoundDownloadedWaveP *pDownloadedWave);

    STDMETHODIMP AllocVoice(
        IDirectSoundDownloadedWaveP  *pWave,     
        DWORD                       dwChannel,                       
        DWORD                       dwChannelGroup,                  
        REFERENCE_TIME              rtStart,                     
        SAMPLE_TIME                 stLoopStart,
        SAMPLE_TIME                 stLoopEnd,
        IDirectMusicVoiceP           **ppVoice);

    STDMETHODIMP AssignChannelToBuses(
        DWORD       dwChannelGroup,
        DWORD       dwChannel,
        LPDWORD     pdwBuses,
        DWORD       cBusCount);

    STDMETHODIMP StartVoice(          
        DWORD               dwVoiceId,
        DWORD               dwChannel,
        DWORD               dwChannelGroup,
        REFERENCE_TIME      rtStart,
        DWORD               dwDLId,
        LONG                prPitch,
        LONG                vrVolume,
        SAMPLE_TIME         stStartVoice,
        SAMPLE_TIME         stLoopStart,
        SAMPLE_TIME         stLoopEnd);

    STDMETHODIMP StopVoice(          
        DWORD               dwVoiceId,
        REFERENCE_TIME      rtStop);

    STDMETHODIMP GetVoiceState(
        DWORD               dwVoice[], 
        DWORD               cbVoice,
        DMUS_VOICE_STATE    VoiceState[]);

    STDMETHODIMP Refresh(
        DWORD   dwDownloadId,
        DWORD   dwFlags);

    STDMETHODIMP SetSink(
        LPDIRECTSOUNDCONNECT pSinkConnect);
        
    STDMETHODIMP GetSink(
        LPDIRECTSOUNDCONNECT* ppSinkConnect);

    STDMETHODIMP GetFormat(
        LPWAVEFORMATEX  pwfex,
        LPDWORD         pdwwfex,
        LPDWORD         pcbBuffer);
	
private:
    IDirectMusicSynth8     *m_pSynth;               // 8.0 Synth 
    bool                    m_fUsingDirectMusicDSound;
                                                    // Using default dsound
    LPDIRECTSOUND8          m_pDirectSound;         // Directsound object
    LPDIRECTSOUNDCONNECT    m_pSinkConnect;         // DirectSound sink
    LPDIRECTSOUNDBUFFER     m_pdsb[4];              // Sink buffers
    LPDIRECTSOUNDSOURCE     m_pSource;              // Synth's source
    
    static WAVEFORMATEX     s_wfexDefault;          // Default format
    
    bool                    m_fVSTStarted;          // Has voice service thread
                                                    //  been started?
    DWORD                   m_dwChannelGroups;      // How many channel groups
    
    LONG                    m_lActivated;           // Is port active?
    bool                    m_fHasActivated;        // Has ever activated?
    DWORD                   m_dwSampleRate;         // Sample rate for synth
    
private:
    HRESULT AllocDefaultSink();
    HRESULT CreateAndConnectDefaultSink();
};



#endif // _DMSPORT8_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmsport8.cpp ===
//
// dmsport8.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// CDirectMusicSynthPort8 implementation; code specific to DX-8 style ports
// 
#include <objbase.h>
#include "debug.h"
#include <mmsystem.h>

#include "dmusicp.h"
#include "validate.h"
#include "debug.h"
#include "dmvoice.h"
#include "dmsport8.h"
#include "dsoundp.h"    // For IDirectSoundConnect

static const DWORD g_dwDefaultSampleRate = 22050;

WAVEFORMATEX CDirectMusicSynthPort8::s_wfexDefault = 
{
    WAVE_FORMAT_PCM,            // wFormatTag
    1,                          // nChannels
    g_dwDefaultSampleRate,      // nSamplesPerSec
    g_dwDefaultSampleRate * 2,  // nAvgBytesPerSec
    2,                          // nBlockAlign
    8 * 2,                      // wBitsPerSample
    0                           // cbSize
};

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::CDirectMusicSynthPort8
//
//
CDirectMusicSynthPort8::CDirectMusicSynthPort8(
    PORTENTRY           *pe,
    CDirectMusic        *pDM,
    IDirectMusicSynth8  *pSynth) :

        CDirectMusicSynthPort(pe, pDM, static_cast<IDirectMusicSynth*>(pSynth))
{
    m_pSynth = pSynth;
    m_pSynth->AddRef();

    m_fUsingDirectMusicDSound   = false;
    m_pDirectSound              = NULL;
    m_pSinkConnect              = NULL;
    m_fVSTStarted               = false;
    m_pSource                   = NULL;
    m_lActivated                = 0;
    m_fHasActivated             = false;
    m_dwSampleRate              = g_dwDefaultSampleRate;

    memset(m_pdsb, 0, sizeof(m_pdsb));

}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::CDirectMusicSynthPort8
//
//
CDirectMusicSynthPort8::~CDirectMusicSynthPort8()
{
    Close();
}
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::Initialize
//
//
HRESULT CDirectMusicSynthPort8::Initialize(
    DMUS_PORTPARAMS     *pPortParams)
{
    HRESULT hr      = CDirectMusicSynthPort::Initialize(pPortParams);
    HRESULT hrOpen  = S_OK;

    if (m_pSynth == NULL) 
    {
        // XXX error code
        //
        return E_FAIL;
    }

    // We need DirectSound before connection now
    //
    LPDIRECTSOUND pDirectSound;

    hr = ((CDirectMusic*)m_pDM)->GetDirectSoundI(&pDirectSound);

    // Make sure we have DirectSound 8.
    //
    if (SUCCEEDED(hr))
    {
        hr = pDirectSound->QueryInterface(IID_IDirectSound8, (void**)&m_pDirectSound);
        RELEASE(pDirectSound);
    }

    if (SUCCEEDED(hr))
    {
        // Override default sample rate
        //
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SAMPLERATE)
        {
            m_dwSampleRate = pPortParams->dwSampleRate;
        }
    }

    // Create and hand out the master clock
    //
	IReferenceClock* pClock = NULL;

    if (SUCCEEDED(hr))
    {
	    hr = m_pDM->GetMasterClock(NULL, &pClock);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pSynth->SetMasterClock(pClock);
        RELEASE(pClock);
    }

    // Start the voice service thread
    //
    if (SUCCEEDED(hr))
    {
        hr = CDirectMusicVoice::StartVoiceServiceThread((IDirectMusicPort*)this);
    }

    if (SUCCEEDED(hr))
    {
        m_fVSTStarted = true;
    }

    // Open the synth. We have to be careful to save the return code because
    // if S_FALSE is returned here it must be returned to the caller.
    //
    if (SUCCEEDED(hr))
    {
    	hrOpen = m_pSynth->Open(pPortParams);
        if (FAILED(hrOpen))
        {
            hr = hrOpen;
            TraceI(1, "Failed to open synth %08lX\n", hr);
        }
    }

    // Set up channel priorities and volume boost
    // 
    if (SUCCEEDED(hr))
    {    
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
        {
            m_dwChannelGroups = pPortParams->dwChannelGroups;
        }
        else
        {
            m_dwChannelGroups = 1;
        }

        InitChannelPriorities(1, m_dwChannelGroups);
        InitializeVolumeBoost();
    }

    // Save source so we can connect to it later
    //
    if (SUCCEEDED(hr))
    {
        hr = m_pSynth->QueryInterface(IID_IDirectSoundSource, (void**)&m_pSource);
    }

    if (FAILED(hr))
    {
        Close();
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::Close
//
STDMETHODIMP CDirectMusicSynthPort8::Close()
{
    // Stop voice service thread
    //
    if (m_fVSTStarted)
    {
        CDirectMusicVoice::StopVoiceServiceThread((IDirectMusicPort*)this);
        m_fVSTStarted = FALSE;
    }
    
    // Turn off and close
    //
    if (m_pSynth) 
    {
        m_pSynth->Activate(false);
        m_pSynth->Close();
        RELEASE(m_pSynth);
    }

    // Force synth and sink to disassociate
    //
    if (m_pSinkConnect)
    {
        m_pSinkConnect->RemoveSource(m_pSource);
    }

    if (m_pSource) 
    {
        m_pSource->SetSink(NULL);            
    }

    // Release everything
    //
    RELEASE(m_pdsb[0]);
    RELEASE(m_pdsb[1]);
    RELEASE(m_pdsb[2]);
    RELEASE(m_pdsb[3]);

    RELEASE(m_pSinkConnect);
    RELEASE(m_pSource);
    RELEASE(m_pDirectSound);

    return CDirectMusicSynthPort::Close();
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::Activate
//
// XXX Write me
//
STDMETHODIMP CDirectMusicSynthPort8::Activate(
    BOOL fActivate)
{
    HRESULT hr = S_OK;

	V_INAME(IDirectMusicPort::Activate);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate)
    {
        if (InterlockedExchange(&m_lActivated, 1))
        {
            return S_FALSE;
        }
    }
    else
    {
        if (InterlockedExchange(&m_lActivated, 0) == 0) 
        {
            return S_FALSE;
        }
    }
	
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate && !m_pSinkConnect)
    {
        hr = CreateAndConnectDefaultSink();
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pSynth->Activate(fActivate);
    }

    if (SUCCEEDED(hr))
    {
        m_fHasActivated = true;
    }
    else
    {
        // Flip back activate state -- operation failed
        //
        m_lActivated = fActivate ? 0 : 1;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::SetDirectSound
//
STDMETHODIMP CDirectMusicSynthPort8::SetDirectSound(
    LPDIRECTSOUND       pDirectSound,
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    V_INAME(IDirectMusicPort::SetDirectSound);
    V_INTERFACE(pDirectSound);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_lActivated)
    {
        return DMUS_E_ALREADY_ACTIVATED;
    }

    if (pDirectSoundBuffer)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    IDirectSound8 *pDirectSound8;

    // Make sure we have an IDirectSound8, and as a side effect AddRef
    //
    hr = pDirectSound->QueryInterface(IID_IDirectSound8, (void**)&pDirectSound8);
    
    if (SUCCEEDED(hr))
    {
        RELEASE(m_pDirectSound);
        m_pDirectSound = pDirectSound8;
    }
        
    return hr;        
}
       
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::DownloadWave
//
STDMETHODIMP CDirectMusicSynthPort8::DownloadWave(
    IDirectSoundWave            *pWave,               
    IDirectSoundDownloadedWaveP  **ppWave,
    REFERENCE_TIME              rtStartHint)
{
    V_INAME(IDirectMusicPort::DownloadWave);
    V_INTERFACE(pWave);
	V_PTRPTR_WRITE(ppWave);

    TraceI(1, "DownloadWave %08X\n", pWave);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }
	return CDirectMusicPortDownload::DownloadWaveP(pWave,
                                                   ppWave,
                                                   rtStartHint);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::UnloadWave
//
STDMETHODIMP CDirectMusicSynthPort8::UnloadWave(
    IDirectSoundDownloadedWaveP *pDownloadedWave)
{
    V_INAME(IDirectMusicPort::UnloadWave);
    V_INTERFACE(pDownloadedWave);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return CDirectMusicPortDownload::UnloadWaveP(pDownloadedWave);
}

            
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::AllocVoice
//
STDMETHODIMP CDirectMusicSynthPort8::AllocVoice(
    IDirectSoundDownloadedWaveP  *pWave,     
    DWORD                       dwChannel,                       
    DWORD                       dwChannelGroup,                  
    REFERENCE_TIME              rtStart,                     
    SAMPLE_TIME                 stLoopStart,
    SAMPLE_TIME                 stLoopEnd,         
    IDirectMusicVoiceP           **ppVoice)
{
    V_INAME(IDirectMusicPort::AllocVoice);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppVoice);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return CDirectMusicPortDownload::AllocVoice(
        pWave,
        dwChannel,
        dwChannelGroup,
        rtStart,
        stLoopStart,
        stLoopEnd,
        ppVoice);
}        

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::AssignChannelToBuses
//
STDMETHODIMP CDirectMusicSynthPort8::AssignChannelToBuses(
    DWORD       dwChannelGroup,
    DWORD       dwChannel,
    LPDWORD     pdwBuses,
    DWORD       cBusCount)
{
    V_INAME(IDirectMusicPort::AssignChannelToBuses);
    V_BUFPTR_WRITE(pdwBuses, sizeof(DWORD) * cBusCount);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->AssignChannelToBuses(
        dwChannelGroup,
        dwChannel,
        pdwBuses,
        cBusCount);
}        


////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::StartVoice
//
STDMETHODIMP CDirectMusicSynthPort8::StartVoice(          
    DWORD               dwVoiceId,
    DWORD               dwChannel,
    DWORD               dwChannelGroup,
    REFERENCE_TIME      rtStart,
    DWORD               dwDLId,
    LONG                prPitch,
    LONG                vrVolume,
    SAMPLE_TIME         stVoiceStart, 
    SAMPLE_TIME         stLoopStart,
    SAMPLE_TIME         stLoopEnd)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    // XXX make cg/c order consistent
    // XXX make API names consistent
    //
    return m_pSynth->PlayVoice(rtStart,
                               dwVoiceId,
                               dwChannelGroup,
                               dwChannel,
                               dwDLId,
                               prPitch, 
                               vrVolume,
                               stVoiceStart,
                               stLoopStart,
                               stLoopEnd);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::StopVoice
//
STDMETHODIMP CDirectMusicSynthPort8::StopVoice(          
    DWORD               dwVoiceId,
    REFERENCE_TIME      rtStop)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->StopVoice(rtStop,
                               dwVoiceId);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::GetVoiceState
//
STDMETHODIMP CDirectMusicSynthPort8::GetVoiceState(
    DWORD               dwVoice[], 
    DWORD               cbVoice,
    DMUS_VOICE_STATE    VoiceState[])
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->GetVoiceState(dwVoice, cbVoice, VoiceState);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::Refresh
//
STDMETHODIMP CDirectMusicSynthPort8::Refresh(
    DWORD   dwDownloadId,
    DWORD   dwFlags)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->Refresh(dwDownloadId, dwFlags);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::SetSink
//
STDMETHODIMP CDirectMusicSynthPort8::SetSink(
    IDirectSoundConnect *pSinkConnect)
{
    V_INAME(IDirectMusicPort::SetSink);
    V_INTERFACE(pSinkConnect);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_fHasActivated)
    {
        return DMUS_E_ALREADY_ACTIVATED;
    }

    // Do this in the order which permits the easiest backing out.
    HRESULT hr = pSinkConnect->AddSource(m_pSource);

    if (SUCCEEDED(hr))
    {
        hr = m_pSource->SetSink(pSinkConnect);
        if (FAILED(hr))
        {
            pSinkConnect->RemoveSource(m_pSource);
        }
    }
    
    if (SUCCEEDED(hr))
    {
        if (m_pSinkConnect)
        {
            m_pSinkConnect->RemoveSource(m_pSource);

            // This does nothing if the sink is already not ours.

            RELEASE(m_pdsb[0]);
            RELEASE(m_pdsb[1]);
            RELEASE(m_pdsb[2]);
            RELEASE(m_pdsb[3]);
        
            RELEASE(m_pSinkConnect);
        }

        pSinkConnect->AddRef();
        m_pSinkConnect = pSinkConnect;
    }


    // We've got the connection to the sink, let's set KSControl on the Sink
    if (SUCCEEDED(hr))
    {
        IKsControl *pKsControl = NULL;
        hr = m_pSinkConnect->QueryInterface(IID_IKsControl, (void**)&pKsControl);
        if (FAILED(hr))
        {
            TraceI(0, "Warning: Sink does not support IKsControl\n");
            pKsControl = NULL;
        }

        SetSinkKsControl(pKsControl);

        //The SetSinkKsControl does an AddRef() so we can release!
        RELEASE(pKsControl);
    }

    
    return hr;    
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::GetSink
//
STDMETHODIMP CDirectMusicSynthPort8::GetSink(
    IDirectSoundConnect **ppSinkConnect)
{
    V_INAME(IDirectMusicPort::GetSink);
    V_PTRPTR_WRITE(ppSinkConnect);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    *ppSinkConnect = m_pSinkConnect;
    m_pSinkConnect->AddRef();

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::GetFormat
//
STDMETHODIMP CDirectMusicSynthPort8::GetFormat(
    LPWAVEFORMATEX  pwfex,
    LPDWORD         pdwwfex,
    LPDWORD         pcbBuffer)
{
    V_INAME(IDirectMusicPort::GetFormat);
    V_PTR_WRITE(pdwwfex, DWORD);
    V_BUFPTR_WRITE_OPT(pwfex, *pdwwfex);
    V_PTR_WRITE_OPT(pcbBuffer, DWORD);

    HRESULT hr = m_pSynth->GetFormat(pwfex, pdwwfex);
    if (FAILED(hr))
    {
        return hr;
    }

    //>>>>>>>>>>>> NEED A MEMTHOD IN SYNTH 
    if ((pcbBuffer != NULL) && (pwfex != NULL))
    {
        *pcbBuffer = 2/*DSBUFFER_LENGTH_SEC*/ * pwfex->nAvgBytesPerSec;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::CreateAndConnectDefaultSink
//
// INTERNAL
//
//
HRESULT CDirectMusicSynthPort8::CreateAndConnectDefaultSink()
{
    HRESULT             hr;

    hr = AllocDefaultSink();

    // Give the sink's IKsControl to the base class. This needs to be
    // done here since the sink is a different type between 7 and 8.
    //
    if (SUCCEEDED(hr))
    {
        IKsControl *pKsControl = NULL;

        HRESULT hrTemp = m_pSinkConnect->QueryInterface(
            IID_IKsControl, 
            (void**)&pKsControl);
        if (FAILED(hrTemp))
        {
            TraceI(2, "NOTE: Sink has no property set interface.\n");
        }

        SetSinkKsControl(pKsControl);
        RELEASE(pKsControl);
    }

    // Connect the two together
    //
    if (SUCCEEDED(hr))
    {
        hr = m_pSource->SetSink(m_pSinkConnect);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pSinkConnect->AddSource(m_pSource);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::AllocDefaultSink
//
// INTERNAL
//
// Try to allocate a default sink and buses, releasing any current sink.
//
// Caller guarantees the port has never been activated. 
//
HRESULT CDirectMusicSynthPort8::AllocDefaultSink()
{
    IDirectSoundConnect *pSinkConnect = NULL;
	IReferenceClock     *pClock = NULL;
    IDirectSoundBuffer  *pdsb[4];
	WAVEFORMATEX        wfex;

    assert(!m_fHasActivated);

    memset(pdsb, 0, sizeof(pdsb));

    // Create a sink
    //

	// initialize with default
	wfex = s_wfexDefault; 

	//XXX 
	//>>>> NOTE:PETCHEY
	// We should also able to create a mono sink 
	// pPortParams->dwAudioChannels
    wfex.nSamplesPerSec  = m_dwSampleRate;
    wfex.nAvgBytesPerSec = wfex.nSamplesPerSec * wfex.nChannels * (wfex.wBitsPerSample/8);              // 

    IDirectSoundPrivate* pDSPrivate;
    HRESULT hr = m_pDirectSound->QueryInterface(IID_IDirectSoundPrivate, (void**)&pDSPrivate);

    if (SUCCEEDED(hr))
    {
        hr = pDSPrivate->AllocSink(&wfex, &pSinkConnect);
        pDSPrivate->Release();
    }

    // Standard bus connections
    //  
    DSBUFFERDESC dsbd;
	DWORD dwbus;

    if (SUCCEEDED(hr))
    {
        memset(&dsbd, 0, sizeof(dsbd));
        dsbd.dwSize  = sizeof(dsbd);
        dsbd.dwFlags = DSBCAPS_GLOBALFOCUS;
        dsbd.lpwfxFormat = &wfex;

		dwbus = DSBUSID_LEFT;

        hr = pSinkConnect->CreateSoundBuffer(&dsbd, &dwbus, 1, GUID_NULL, &pdsb[0]);
    }

    if (SUCCEEDED(hr))
    {
        memset(&dsbd, 0, sizeof(dsbd));
        dsbd.dwSize  = sizeof(dsbd);
        dsbd.dwFlags = DSBCAPS_GLOBALFOCUS;
        dsbd.lpwfxFormat = &wfex;

		dwbus = DSBUSID_RIGHT;

        hr = pSinkConnect->CreateSoundBuffer(&dsbd, &dwbus, 1, GUID_NULL, &pdsb[1]);
    }
    
    if (SUCCEEDED(hr))
    {
        memset(&dsbd, 0, sizeof(dsbd));
        dsbd.dwSize = sizeof(dsbd);
        dsbd.dwFlags = DSBCAPS_GLOBALFOCUS;
        dsbd.lpwfxFormat = &wfex;

      //XXX Set up effect

		dwbus = DSBUSID_REVERB_SEND;

        hr = pSinkConnect->CreateSoundBuffer(&dsbd, &dwbus, 1, GUID_NULL, &pdsb[2]);
    }
    
    if (SUCCEEDED(hr))
    {
        memset(&dsbd, 0, sizeof(dsbd));
        dsbd.dwSize  = sizeof(dsbd);
        dsbd.dwFlags = DSBCAPS_GLOBALFOCUS;
        dsbd.lpwfxFormat = &wfex;
        
      //XXX Set up effect

		dwbus = DSBUSID_CHORUS_SEND;

        hr = pSinkConnect->CreateSoundBuffer(&dsbd, &dwbus, 1, GUID_NULL, &pdsb[3]);
    }

    // Master clock
    //
    if (SUCCEEDED(hr))
    {
	    hr = m_pDM->GetMasterClock(NULL, &pClock);
    }

    if (SUCCEEDED(hr))
    {
        hr = pSinkConnect->SetMasterClock(pClock);
        RELEASE(pClock);
    }

    // If we got this far then we are going to replace any existing sink
    // with the new one
    //
    if (SUCCEEDED(hr))
    {
		if (m_pSinkConnect && m_pSource)
		{
	        m_pSinkConnect->RemoveSource(m_pSource);
		}
        
        RELEASE(m_pdsb[0]);
        RELEASE(m_pdsb[1]);
        RELEASE(m_pdsb[2]);
        RELEASE(m_pdsb[3]);
    
        RELEASE(m_pSinkConnect);

        assert(sizeof(m_pdsb) == sizeof(pdsb));
        memcpy(m_pdsb, pdsb, sizeof(m_pdsb));

        m_pSinkConnect = pSinkConnect;
    }

    if (FAILED(hr))
    {
        RELEASE(pdsb[0]);
        RELEASE(pdsb[1]);
        RELEASE(pdsb[2]);
        RELEASE(pdsb[3]);
    
        RELEASE(pSinkConnect);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmsysclk.cpp ===
//
// dmsysclk.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// @doc EXTERNAL
//
//
#include <objbase.h>
#include "dmusicp.h"
#include "debug.h"
#include "resource.h"

// RDTSC: Pentium instruction to read the cycle clock (increments once per clock cycle)
//
#define RDTSC _asm _emit 0x0f _asm _emit 0x31

#define MS_CALIBRATE    (100)           // How long to calibate the Pentium clock against timeGetTime?
#define REFTIME_PER_MS  (10 * 1000)     // 10 100-ns units per millisecond

// Registry constant to dispable Pentium clock
//
static const char cszUsePentiumClock[] = "UsePentiumClock";

// Only determine which clock to use once
//
typedef enum
{
    SYSCLOCK_UNKNOWN,
    SYSCLOCK_WINMM,
    SYSCLOCK_PENTIMER
} SYSCLOCK_T;

static SYSCLOCK_T gSysClock = SYSCLOCK_UNKNOWN;
static DWORD gdwCycPer100ns;

static HRESULT CreateSysClock(IReferenceClock **ppClock, CMasterClock *pMasterClock);
static void ProbeClock();

// Class implmentations, private to dmsysclk.cpp
//
class CReferenceClockWinmm : public IReferenceClock
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie); 
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie);
    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    CReferenceClockWinmm();

private:
    long m_cRef;
};

#ifdef _X86_
class CReferenceClockPentium : public IReferenceClock
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie); 
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie);
    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    CReferenceClockPentium(DWORD dwDivisor);

private:
    long m_cRef;
    DWORD m_dwDivisor;
};
#endif

// AddSysClocks
//
// Add system clock to the list of clocks.
//
HRESULT AddSysClocks(CMasterClock *pMasterClock)
{
    if (gSysClock == SYSCLOCK_UNKNOWN)
    {
        ProbeClock();
    }

    CLOCKENTRY ce;

    ZeroMemory(&ce, sizeof(ce));
    ce.cc.dwSize = sizeof(ce);
    ce.cc.guidClock = GUID_SysClock;
    ce.cc.ctType = DMUS_CLOCK_SYSTEM;
    ce.cc.dwFlags = DMUS_CLOCKF_GLOBAL;
    ce.pfnGetInstance = CreateSysClock;

    int cch;
    int cchMax = sizeof(ce.cc.wszDescription) / sizeof(WCHAR);

    char sz[sizeof(ce.cc.wszDescription) / sizeof(WCHAR)];
    cch = LoadString(g_hModule,
                     IDS_SYSTEMCLOCK,
                     sz,
                     sizeof(sz));
    if (cch)
    {
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            sz,
            -1,
            ce.cc.wszDescription,
            sizeof(ce.cc.wszDescription));
    }
    else
    {
        *ce.cc.wszDescription = 0;
    }

    return pMasterClock->AddClock(&ce);
}


// CreateSysClock
//
// Determine clock parameters if need be and create the appropriate type
// of system clock for this system.
//
HRESULT CreateSysClock(IReferenceClock **ppClock, CMasterClock *pMasterClock)
{
    HRESULT hr;

    switch (gSysClock)
    {
        case SYSCLOCK_WINMM:
        {
            TraceI(2, "Creating SysClock [WinMM]\n");
            CReferenceClockWinmm *pWinmmClock = new CReferenceClockWinmm;

            if (!pWinmmClock)
            {
                return E_OUTOFMEMORY;
            }

            hr = pWinmmClock->QueryInterface(IID_IReferenceClock, (void**)ppClock);
            pWinmmClock->Release();
            break;
        }
        
#ifdef _X86_
        case SYSCLOCK_PENTIMER:
        {
            TraceI(2, "Creating SysClock [PentTimer]\n");
            CReferenceClockPentium *pPentiumClock = new CReferenceClockPentium(gdwCycPer100ns);

            if (!pPentiumClock)
            {
                return E_OUTOFMEMORY;
            }

            hr = pPentiumClock->QueryInterface(IID_IReferenceClock, (void**)ppClock);
            pPentiumClock->Release();
            break;
        };
#endif

        case SYSCLOCK_UNKNOWN:
            TraceI(2, "CreateSysClock: Attempt to create w/o AddClock first??\n");
            return E_FAIL;
            break; 

        default:
            TraceI(0, "CreateSysClock: Unknown system clock type %d\n", (int)gSysClock);
            hr = E_FAIL;
            break;
    }

    return hr;
}

// ProbeClock
//
// Determine what type of clock to use. If we're on a Pentium (better be, it's required)
// then use the Pentium clock. This requires calibration.
//
// Otherwise fall back on timeGetTime. 
//
// Non-Intel compiles just default to setting the timeGetTime clock.
//
static void ProbeClock()
{
    int bIsPentium;


    // This code determines if we're running on a Pentium or better.
    //
    bIsPentium = 0;

#ifdef _X86_
    // First make sure this feature isn't disabled in the registry
    //

    HKEY hk;
    DWORD dwType;
    DWORD dwValue;
    DWORD cbValue;
    BOOL fUsePentium;

    // Default to use Pentium clock if not specified
    //
    fUsePentium = FALSE;

    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   REGSTR_PATH_DMUS_DEFAULTS,
                   &hk) == ERROR_SUCCESS)
    {
        cbValue = sizeof(dwValue);
        if (RegQueryValueEx(hk,
                            cszUsePentiumClock,
                            NULL,               // Reserved
                            &dwType,
                            (LPBYTE)&dwValue,
                            &cbValue) == ERROR_SUCCESS &&
            dwType == REG_DWORD &&
            cbValue == sizeof(DWORD))
        {
            fUsePentium = dwValue ? TRUE : FALSE;
        }

        RegCloseKey(hk);
    }

    // Only test for Pentium if allowed by the registry.
    //
    if (fUsePentium)
    {
        _asm 
        {
            pushfd                      // Store original EFLAGS on stack
            pop     eax                 // Get original EFLAGS in EAX
            mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
            xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
            push    eax                 // Save new EFLAGS value on stack
            popfd                       // Replace current EFLAGS value
            pushfd                      // Store new EFLAGS on stack
            pop     eax                 // Get new EFLAGS in EAX
            xor     eax, ecx            // Can we toggle ID bit?
            jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
            inc     dword ptr [bIsPentium]
Done:
        }
    }

#endif

    TraceI(2, "ProbeClock: bIsPentium %d\n", bIsPentium);

    if (!bIsPentium)
    {
        TraceI(2, "Using timeGetTime() as the system clock\n");
        gSysClock = SYSCLOCK_WINMM;
        return;        
    }

#ifdef _X86_
    TraceI(2, "Using the Pentium chip clock as the system clock\n");
    gSysClock = SYSCLOCK_PENTIMER;


    // If we have a Pentium, then we need to calibrate
    //
    _int64 cycStart;
    _int64 cycEnd;
    DWORD  msStart;
    DWORD  msEnd;

    // On NT, need this to make timeGetTime read with a reasonable accuracy
    //
    timeBeginPeriod(1);

    // Start as close to the start of a millisecond boundary as
    // possible.
    //
    msStart = timeGetTime() + 1;
    while (timeGetTime() < msStart)
        ;

    // Read the Pentium clock at that time
    //
    _asm
    {
        RDTSC                       // Get the time in EDX:EAX
        mov     dword ptr [cycStart], eax
        mov     dword ptr [cycStart+4], edx
    }

    // Wait for the number of milliseconds until end of calibration
    // Again, we're trying to get the time right when the timer switches
    // to msEnd.
    //
    msEnd = msStart + MS_CALIBRATE;
    
    while (timeGetTime() < msEnd)
        ;

    _asm
    {
        RDTSC                       // Get the time in EDX:EAX
        mov     dword ptr [cycEnd], eax
        mov     dword ptr [cycEnd+4], edx
    }

    // Done with the time critical part
    //
    timeEndPeriod(1);

    // We now know how many clock cycles per MS_CALIBRATE milliseconds. Use that
    // to figure out how many clock cycles per 100ns for IReferenceClock.
    //
    _int64 cycDelta = cycEnd - cycStart;
    
    gdwCycPer100ns = (DWORD)(cycDelta / (REFTIME_PER_MS * MS_CALIBRATE));

    TraceI(2, "ClockProbe: Processor clocked at %u Mhz\n", ((cycDelta / MS_CALIBRATE) + 500) / 1000);
#endif // _X86_
}


//////////////////////////////////////////////////////////////////////////////
//
// IReferenceClock wrapper for timeGetTime()
//
CReferenceClockWinmm::CReferenceClockWinmm() : m_cRef(1)
{
}

STDMETHODIMP
CReferenceClockWinmm::QueryInterface(
    const IID &iid,
    void **ppv)
{
    V_INAME(IReferenceClock::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CReferenceClockWinmm::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CReferenceClockWinmm::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CReferenceClockWinmm::GetTime(
    REFERENCE_TIME *pTime)
{
    *pTime = ((ULONGLONG)timeGetTime()) * (10L * 1000L);
    return S_OK;
}

STDMETHODIMP
CReferenceClockWinmm::AdviseTime(
    REFERENCE_TIME baseTime,  
    REFERENCE_TIME streamTime,
    HANDLE hEvent,            
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CReferenceClockWinmm::AdvisePeriodic(
    REFERENCE_TIME startTime,
    REFERENCE_TIME periodTime,
    HANDLE hSemaphore,   
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CReferenceClockWinmm::Unadvise(
    DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}

#ifdef _X86_
//////////////////////////////////////////////////////////////////////////////
//
// IReferenceClock wrapper for Pentium clock
//
CReferenceClockPentium::CReferenceClockPentium(DWORD dwDivisor) : m_cRef(1)
{
    m_dwDivisor = dwDivisor;
}

STDMETHODIMP
CReferenceClockPentium::QueryInterface(
    const IID &iid,
    void **ppv)
{
    V_INAME(IReferenceClock::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CReferenceClockPentium::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CReferenceClockPentium::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CReferenceClockPentium::GetTime(
    REFERENCE_TIME *pTime)
{
    _int64 cycNow;

    _asm
    {
        RDTSC                       // Get the time in EDX:EAX
        mov     dword ptr [cycNow], eax
        mov     dword ptr [cycNow+4], edx
    }

    cycNow /= m_dwDivisor;

    *pTime = (DWORD)cycNow;

    return S_OK;
}

STDMETHODIMP
CReferenceClockPentium::AdviseTime(
    REFERENCE_TIME baseTime,  
    REFERENCE_TIME streamTime,
    HANDLE hEvent,            
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CReferenceClockPentium::AdvisePeriodic(
    REFERENCE_TIME startTime,
    REFERENCE_TIME periodTime,
    HANDLE hSemaphore,   
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CReferenceClockPentium::Unadvise(
    DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}
#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmusicp.h ===
//
// DMusicP.H
//
// Private include for Dmusic.DLL
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//

#ifndef _DMUSICP_
#define _DMUSICP_

#include "tlist.h"
#include "alist.h"
#include "debug.h"
#include <devioctl.h>

#include "mmsystem.h"
#include "dsoundp.h"         // DSound must be before KS*.h

#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "dmksctrl.h"

#include "dmusicc.h"
#include "dmusici.h"
#include "dmusics.h"
#include "..\shared\dmusiccp.h"

#include "dmdload.h"
#include "dmportdl.h"

#include <stddef.h>
#include "dmusprop.h"
#include "tpool.h"

#define RELEASE(x) { if (x) (x)->Release(); (x) = NULL; }

#define HRFromP(x) ((x) ? S_OK : E_OUTOFMEMORY)

extern char g_szFriendlyName[];             // Module friendly name
extern char g_szVerIndProgID[];             // and program ID w/ version
extern char g_szProgID[];                   // Just program ID
extern HMODULE g_hModule;                   // DLL module handle (dmusic.dll)
extern HMODULE g_hModuleDM32;               // dmusic32.dll module handle if loaded
extern HMODULE g_hModuleKsUser;             // ksuser.dll module handle if loaded
extern long g_cComponent;                   // Component count for server locking
extern long g_cLock;                        // Lock count for server locking
extern DWORD g_fFlags;                      // DMI_F_XXX flags

#define DMI_F_WIN9X     0x00000001          // Running on Win9x

#define DWORD_ROUNDUP(x) (((x) + 3) & ~3)
#define QWORD_ROUNDUP(x) (((x) + 7) & ~7)

// Array elements in X
//
#define ELES(x)          (sizeof(x) / sizeof((x)[0]))

#define SafeAToW(w,a) \
                      { mbstowcs(w, a, ELES(w) - 1); (w)[ ELES(w) - 1] = L'\0'; }

#define SafeWToA(a,w) \
                      { wcstombs(a, w, ELES(a) - 1); (a)[ ELES(a) - 1] = '\0'; }

// Driver message for NT. Determines the number of ports on a driver
//
#ifndef DRV_QUERYDRVENTRY
#define DRV_QUERYDRVENTRY (0x0801)
#endif

// For selector tiling, the tile info is 16 bits of sel[0] and 16 bits of count
#define TILE_SEL0(x)  (((DWORD)((x) & 0xffff0000)) >> 16)
#define TILE_P1616(x) ((DWORD)((x) & 0xffff0000))
#define TILE_COUNT(x) ((x) & 0x0000ffff)

// Where are things in our registry?
#define REGSTR_PATH_DIRECTMUSIC  	"Software\\Microsoft\\DirectMusic"
#define REGSTR_PATH_DMUS_DEFAULTS	REGSTR_PATH_DIRECTMUSIC "\\Defaults"


// @struct PORTENTRY | Entry in the linked list of ports
typedef enum
{
    ptWDMDevice,
    ptLegacyDevice,
    ptSoftwareSynth
} PORTTYPE;

typedef struct tagPORTDEST
{
    ULONG   idxDevice;
    ULONG   idxPin;
    ULONG   idxNode;
    LPSTR   pstrInstanceId;
    BOOL    fOnPrefDev;
} PORTDEST;

typedef struct tagPORTENTRY PORTENTRY;
struct tagPORTENTRY
{
    PORTTYPE type;       // @field What type of port is this?
    

    BOOL fIsValid;       // @field TRUE if this entry is still an active driver after
                         // rebuilding the port list.
    
    ULONG idxDevice;     // @field If the port is a legacy driver, contains the device ID.
    ULONG idxPin;        
    ULONG idxNode;
    
    BOOL fPrefDev;       // @field TRUE if this is a preferred device
    
                         // Filter and pin to open through SysAudio
    int nSysAudioDevInstance;
    int nFilterPin;

    DMUS_PORTCAPS pc;    // @field Contains the port capabilities which will be returned to the application
                         // upon enumeration of the device.
                         
    BOOL fAudioDest;     // @field True if this port can be connected to multiple audio
                         // destinations (WDM transform filter; i.e. kernel SW synth)

    CList<PORTDEST *> lstDestinations;

    WCHAR wszDIName[256]; //@field contains the DeviceName for WDM devices
};

class CMasterClock;
typedef struct tagCLOCKENTRY CLOCKENTRY;
typedef struct tagCLOCKENTRY *PCLOCKENTRY;

struct tagCLOCKENTRY
{
    BOOL fIsValid;
    DMUS_CLOCKINFO cc;
    HRESULT (*pfnGetInstance)(IReferenceClock **ppClock, CMasterClock *pMasterClock);
};

// This structure is held in shared memory. All instances of DirectMusic use it to ensure that
// the same master clock is in place.
//
#define CLOCKSHARE_F_LOCKED         0x00000001      // If clock is locked; i.e. cannot change

typedef struct tagCLOCKSHARE CLOCKSHARE;
struct tagCLOCKSHARE
{
    GUID        guidClock;          // Current master clock
    DWORD       dwFlags;            // CLOCKSHARE_F_xxx
};

// Private interface to get parameters associated with specific master clocks
//
#undef  INTERFACE
#define INTERFACE  IMasterClockPrivate
DECLARE_INTERFACE_(IMasterClockPrivate, IUnknown)
{
	// IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    
    // IDirectMusicKsClockPrivate
    STDMETHOD(GetParam)             (THIS_ REFGUID rguidType, LPVOID pBuffer, DWORD cbSize) PURE;
};

// This class wraps the master clock and handles all the problems associated with only
// one instance per system.
//
class CMasterClock : public IReferenceClock, public IDirectSoundSinkSync, IMasterClockPrivate
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime,  
	        			    REFERENCE_TIME streamTime,
			        	    HANDLE hEvent,            
				            DWORD * pdwAdviseCookie); 

    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime,
					            REFERENCE_TIME periodTime,
					            HANDLE hSemaphore,   
					            DWORD * pdwAdviseCookie);

    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);
    STDMETHODIMP GetParam(REFGUID rguidType, 
                          LPVOID pBuffer, 
                          DWORD cbSize);
                          
    // IDirectSoundSyncSink
    //
    STDMETHODIMP SetClockOffset(LONGLONG llOffset);                         
    
    
    // Used by DirectMusic for communication with the
    // implementation
    //
    CMasterClock();
    ~CMasterClock();
    HRESULT Init();
    HRESULT GetMasterClockInterface(IReferenceClock **ppClock);
    
    HRESULT EnumMasterClock(DWORD dwIndex, LPDMUS_CLOCKINFO lpClockInfo, DWORD dwVer);
    HRESULT GetMasterClock(LPGUID pguidClock, IReferenceClock **ppClock);
    HRESULT SetMasterClock(REFGUID rguidClock);
    HRESULT SetMasterClock(IReferenceClock *pClock);
   
    LONG AddRefPrivate();
    LONG ReleasePrivate();
    
    HRESULT AddClock(PCLOCKENTRY pClock);
    
    // For clocks (Dsound clock) which need a clean clock to sync on
    //
    HRESULT CreateDefaultMasterClock(IReferenceClock **ppReferenceClock);


private:
    void Close();
    HRESULT UpdateClockList();
    void SyncToExternalClock();
    HRESULT CreateMasterClock();
    

private:
    LONG m_cRef;            // Ref count of wrapped clock
    LONG m_cRefPrivate;     // Ref count of CMasterClock object
    
    CList<CLOCKENTRY *>   m_lstClocks;
        
    GUID                  m_guidMasterClock;
    IReferenceClock      *m_pMasterClock;
    IDirectSoundSinkSync *m_pSinkSync;
    HANDLE                m_hClockMemory;
    HANDLE                m_hClockMutex;
    CLOCKSHARE           *m_pClockMemory;
    
    IReferenceClock      *m_pExtMasterClock;
    LONGLONG              m_llExtOffset;
};


// Helper functions for clocks
//
HRESULT AddSysClocks(CMasterClock *);
HRESULT AddDsClocks(CMasterClock *);
HRESULT AddPcClocks(CMasterClock *);
#ifdef DEAD_CODE
HRESULT AddKsClocks(CMasterClock *);
#endif

//HRESULT CreateSysClock(IReferenceClock **ppClock);

// IDirectMusicPortNotify
//
// A port uses this (private) interface from IDirectMusic to notify IDirectMusic when it goes away.
// 
#undef  INTERFACE
#define INTERFACE  IDirectMusicPortNotify
DECLARE_INTERFACE_(IDirectMusicPortNotify, IUnknown)
{
	// IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectMusicPortNotify
    STDMETHOD(NotifyFinalRelease)   (THIS_ IDirectMusicPort *pPort) PURE;
};

#define MIDI_CHANNELS               16

// DMEVENT as buffered by IDirectMusicBuffer
//
#include <pshpack4.h>
struct DMEVENT : public DMUS_EVENTHEADER
{
    BYTE        abEvent[sizeof(DWORD)];
};
#include <poppack.h>

// Encapsulated for queueing
//
struct QUEUED_EVENT
{
    QUEUED_EVENT    *pNext;
    DMEVENT         e;
};

#define QUEUED_EVENT_SIZE(cbEvent)  (DMUS_EVENT_SIZE(cbEvent) + sizeof(QUEUED_EVENT) - sizeof(DMEVENT))

// Free pool of 4-byte events
//
typedef CPool<QUEUED_EVENT> EVENT_POOL;

class EVENT_QUEUE
{
public:
    EVENT_QUEUE() { pFront = pRear = NULL; }
    
    QUEUED_EVENT    *pFront;
    QUEUED_EVENT    *pRear;
};

// How long to wait for the capture thread to die
//
#define THREAD_KILL_TIMEOUT         5000

// How big is the capture thread's work buffer?
//
#define THREAD_WORK_BUFFER_SIZE     4096

#define QWORD_ALIGN(x) (((x) + 7) & ~7)

typedef struct _DMUS_THRU_CHANNEL *LPDMUS_THRU_CHANNEL;
typedef struct _DMUS_THRU_CHANNEL
{
    DWORD               dwDestinationChannel;
    DWORD               dwDestinationChannelGroup;
    IDirectMusicPort    *pDestinationPort;
    BOOL                fThruInWin16;
} DMUS_THRU_CHANNEL;



// IDirectMusicPortPrivate
//
// A port implements this interface to expose methods to DirectMusic which are not exposed to the
// outside world
//
#undef  INTERFACE
#define INTERFACE  IDirectMusicPortPrivate
DECLARE_INTERFACE_(IDirectMusicPortPrivate, IUnknown)
{
	// IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectMusicPortPrivate
    STDMETHOD(Close)                (THIS_) PURE;
    
    // Voice management
    //
    STDMETHOD(StartVoice)          
        (THIS_
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart,
         DWORD dwDLId,
         LONG prPitch,
         LONG veVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd
        ) PURE;

    STDMETHOD(StopVoice)          
        (THIS_
         DWORD dwVoiceID,
         REFERENCE_TIME rtStop
        ) PURE;
        
    STDMETHOD(GetVoiceState)     
        (THIS_ DWORD dwVoice[], 
         DWORD cbVoice,
         DMUS_VOICE_STATE dwVoiceState[] 
        ) PURE;
        
    STDMETHOD(Refresh)
        (THIS_ DWORD dwDownloadID,
         DWORD dwFlags
        ) PURE;        
};

// @class Implementation of IDirectMusic
//
class CDirectMusic : public IDirectMusic8, public IDirectMusicPortNotify {
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusic
    //
    STDMETHODIMP EnumPort(DWORD dwIdx, LPDMUS_PORTCAPS lpPortCaps);
    STDMETHODIMP CreateMusicBuffer(LPDMUS_BUFFERDESC pBufferDesc, LPDIRECTMUSICBUFFER *ppBuffer, LPUNKNOWN pUnkOuter);
    STDMETHODIMP CreatePort(REFGUID ruidPort, LPDMUS_PORTPARAMS pPortParams, LPDIRECTMUSICPORT *ppPort, LPUNKNOWN pUnkOuter);
    STDMETHODIMP EnumMasterClock(DWORD dwIndex, LPDMUS_CLOCKINFO lpClockInfo);
    // NOTE: This is a GUID* rather than REFGUID so they can pass NULL if they don't care
    //
    STDMETHODIMP GetMasterClock(GUID *guidClock, IReferenceClock **ppReferenceClock);
    STDMETHODIMP SetMasterClock(REFGUID guidClock);
    STDMETHODIMP Activate(BOOL fEnable);
	STDMETHODIMP GetDefaultPort(GUID *guidPort);
	STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, HWND hwnd);
    STDMETHODIMP SetExternalMasterClock(IReferenceClock *pClock);
    

    // IDirectMusicPortNotify
    //
    STDMETHODIMP NotifyFinalRelease(IDirectMusicPort *pPort);
    

    // Class
    //
    CDirectMusic();
    ~CDirectMusic();
    HRESULT Init();
    HRESULT UpdatePortList();
    HRESULT AddWDMDevices();
    HRESULT AddLegacyDevices();
    HRESULT AddSoftwareSynths();
    HRESULT AddDevice(DMUS_PORTCAPS &dmpc, 
                      PORTTYPE pt, 
                      int idxDev, 
                      int idxPin, 
                      int idxNode, 
                      BOOL fIsPreferred, 
                      HKEY hkPortsRoot, 
                      LPWSTR wszDIName, 
                      LPSTR pstrInstanceId);
    HRESULT InitClockList();
    HRESULT UpdateClockList();
    HRESULT AddClock(DMUS_CLOCKINFO &dmcc);
	void GetDefaultPortI(GUID *pguidPort);

    HRESULT GetDirectSoundI(LPDIRECTSOUND *ppDirectSound);
    void ReleaseDirectSoundI();
    PORTENTRY *GetPortByGUID(GUID guid);
    
    inline CMasterClock *GetMasterClockWrapperI()
    { return m_pMasterClock; }
    
private:
    long m_cRef;                                // Reference count
    
    CList<PORTENTRY *> m_lstDevices;            // Enumerated ports
    CList<IDirectMusicPort *> m_lstOpenPorts;   // Open ports

    CMasterClock *m_pMasterClock;               // Current master clock

    long m_fDirectSound;                        // Has SetDirectSound been called?  
    BOOL m_fCreatedDirectSound;                 // True if DirectMusic was the one that created DirectSound  
    long m_cRefDirectSound;                     // Internal refs against DirectSound
    LPDIRECTSOUND m_pDirectSound;               // The DirectSound object, either from app or created
    HWND m_hWnd;                                // hWnd for DirectSound focus management    
    BOOL m_fDefaultToKernelSwSynth;             // (Reg) Default to kernel synth
    BOOL m_fDisableHWAcceleration;              // (Reg) Don't use any kernel devices
    BOOL m_nVersion;                            // DX Version QI'd for

    static LONG m_lInstanceCount;               // How many are there?
};

// WDM port
//
extern HRESULT
CreateCDirectMusicPort(
                       PORTENTRY *pPE, 
                       CDirectMusic *pDM, 
                       LPDMUS_PORTPARAMS pPortParams,
                       IDirectMusicPort **ppPort);

#define OVERLAPPED_ARRAY_SIZE 200

struct OverlappedStructs
{
    OVERLAPPED  aOverlappedIO[OVERLAPPED_ARRAY_SIZE];// Array of overlapped structures
    BOOL        afOverlappedInUse[OVERLAPPED_ARRAY_SIZE];// Array of flags set when correspondin overlapped structure is in use
    BYTE       *apOverlappedBuffer[OVERLAPPED_ARRAY_SIZE];// Array of buffers that store the events we sent down
};

class CPortLatencyClock;
class CDirectMusicPort : 
    public CDirectMusicPortDownload, 
    public IDirectMusicThru,
    public IDirectMusicPort, 
    public IDirectMusicPortP, 
    public IDirectMusicPortPrivate, 
    public IKsControl
{
friend DWORD WINAPI FreeWDMHandle(LPVOID);
friend DWORD WINAPI CaptureThread(LPVOID);

friend class CPortLatencyClock;
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPort
    //
    STDMETHODIMP PlayBuffer(LPDIRECTMUSICBUFFER pBuffer);
    STDMETHODIMP SetReadNotificationHandle(HANDLE hEvent);
    STDMETHODIMP Read(LPDIRECTMUSICBUFFER pBuffer);
	STDMETHODIMP DownloadInstrument(IDirectMusicInstrument* pInstrument,
	    							IDirectMusicDownloadedInstrument** pDownloadedInstrument,
									DMUS_NOTERANGE* NoteRanges,
									DWORD dwNumNoteRanges);
	STDMETHODIMP UnloadInstrument(IDirectMusicDownloadedInstrument* pDownloadedInstrument);

    STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
    STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    STDMETHODIMP Compact();
    STDMETHODIMP GetCaps(LPDMUS_PORTCAPS pPortCaps);
	STDMETHODIMP DeviceIoControl(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, 
	                                 LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNumChannelGroups(DWORD dwChannelGroups);
    STDMETHODIMP GetNumChannelGroups(LPDWORD pdwChannelGroups);
    STDMETHODIMP Activate(BOOL fActivate);
    STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
    STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize);
    
    STDMETHODIMP ThruChannel(DWORD dwSourceChannelGroup, DWORD dwSourceChannel, DWORD dwDestinationChannelGroup, DWORD dwDestinationChannel, LPDIRECTMUSICPORT pDestinationPort);

    // IDirectMusicPortP
    //
    STDMETHODIMP DownloadWave(
         IN  IDirectSoundWave *pWave,               
         OUT IDirectSoundDownloadedWaveP **ppWave,
         IN  REFERENCE_TIME rtStartHint
        );
        
    STDMETHODIMP UnloadWave(
         IN  IDirectSoundDownloadedWaveP *pWave      
        );
            
    STDMETHODIMP AllocVoice(
         IN  IDirectSoundDownloadedWaveP *pWave,     
         IN  DWORD dwChannel,                       
         IN  DWORD dwChannelGroup,                  
         IN  REFERENCE_TIME rtStart,                     
         IN  SAMPLE_TIME stLoopStart,
         IN  SAMPLE_TIME stLoopEnd,         
         OUT IDirectMusicVoiceP **ppVoice            
        );        
        
    STDMETHODIMP AssignChannelToBuses(
         IN DWORD dwChannelGroup,
         IN DWORD dwChannel,
         IN LPDWORD pdwBusses,
         IN DWORD cBussCount
        );        

    STDMETHODIMP SetSink(
        IN IDirectSoundConnect *pSinkConnect
       );        

    STDMETHODIMP GetSink(
        IN IDirectSoundConnect **ppSinkConnect
       );        

    // IKsControl
    //
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    // Override two methods from CDirectMusicPortDownload
	virtual STDMETHODIMP Download(IDirectMusicDownload* pIDMDownload);
	virtual STDMETHODIMP Unload(IDirectMusicDownload* pIDMDownload);
	virtual STDMETHODIMP GetAppend(DWORD* pdwAppend);

    // IDirectMusicPortPrivate
    STDMETHODIMP Close();
    
    STDMETHODIMP StartVoice(          
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart,
         DWORD dwDLId,
         LONG prPitch,
         LONG vrVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd);

    STDMETHODIMP StopVoice(
         DWORD dwVoiceID,
         REFERENCE_TIME rtStop);
    
    STDMETHODIMP GetVoiceState(
        DWORD dwVoice[], 
        DWORD cbVoice,
        DMUS_VOICE_STATE dwVoicePos[]);
         
    STDMETHODIMP Refresh(
        DWORD dwDownloadID,
        DWORD dwFlags);
        
    // Class
    //
    CDirectMusicPort(PORTENTRY *pPE, CDirectMusic *pDM);
    ~CDirectMusicPort();
    HRESULT Init(LPDMUS_PORTPARAMS pPortParams);

private:
    // General port stuff
    //
    long                    m_cRef;                 // Reference count
	CDirectMusic            *m_pDM;                 // Owning DirectMusic object
    BOOL                    m_fIsOutput;            // Capture or render port
    IDirectMusicPortNotify  *m_pNotify;             // Notification interface on destruction
    DMUS_PORTCAPS           dmpc;                   // Caps as given to EnumPort
    BOOL                    m_fHasActivated;        // Has this port ever been activated?
    LONG                    m_lActivated;           // Activation count
    LPDIRECTSOUND           m_pDirectSound;         // DirectSound object for destination
    DWORD                   m_dwChannelGroups;      // Channel groups allocated
    GUID                    m_guidPort;             // GUID associated with port
    BOOL                    m_fAudioDest;           // There was a destination found 
    BOOL                    m_fDirectSoundSet;      // DirectSound object was set by app
    BOOL                    m_fCanDownload;         // This port supports downloads
    
    // WDM stuff
    //
    DWORD                   m_idxDev;               // SysAudio: Device number
    DWORD                   m_idxPin;               // SysAudio: Pin number
    DWORD                   m_idxSynthNode;         // SysAudio: Node number of synth node
    HANDLE                  m_hSysAudio;            // Handle to sysaudio instance
    HANDLE                  m_hPin;                 // Handle to pin
    ULONG                   m_ulVirtualSourceIndex; // Virtual source index for volume
    CList<OverlappedStructs *> m_lstOverlappedStructs;// List of arrays of overlapped structures and flags
    CRITICAL_SECTION        m_OverlappedCriticalSection;// Overlapped structure access critical section
    
    // Clock stuff
    //
    IReferenceClock         *m_pMasterClock;        // Master clock wrapped by this port
    CPortLatencyClock       *m_pClock;              // Implementation of latency clock
    
    // DLS download tracking stuff
    //
	HANDLE                  m_hUnloadThread;        // Thread for unloading async downloads
	HANDLE                  *m_phUnloadEventList;   // Event array of async downloads
	HANDLE                  *m_phNewUnloadEventList;// ??? Wobert - investigate 
	HANDLE                  m_hCopiedEventList;     // ???
	DWORD                   m_dwNumEvents;          // ???
	DWORD                   m_dwNumEventsAllocated; // ???
	CDLBufferList           m_UnloadedList;         // ???
    
	CRITICAL_SECTION        m_DMPortCriticalSection;// Port critical section
    BOOL                    m_fPortCSInitialized;   // Critical section initialized properly
    
    // Capture stuff
    //
    HANDLE                  m_hCaptureWake;         // Wake capture thread up to die
    HANDLE                  m_hCaptureThread;       // Capture thread handle
    BOOL                    m_fShutdownThread;      // Flag capture thread to die
    EVENT_POOL              m_FreeEvents;           // Free 4-byte events for capture thread
    EVENT_QUEUE             m_ReadEvents;           // Events captured, waiting to be read
    CRITICAL_SECTION        m_csEventQueues;        // CS protects event queues
    BOOL                    m_fQueueCSInitialized;  // CS properly initialized
    HANDLE                  m_hAppEvent;            // Application event to kick on new capture data
    
    // Thruing stuff
    //
    IDirectMusicBuffer      *m_pThruBuffer;         // Temp buffer to use for thruing 
    LPDMUS_THRU_CHANNEL     m_pThruMap;             // Thruing channel/mute map
    
    // Clock sync stuff
    //
    bool                    m_fSyncToMaster;        // Need to sync to master clock
    LONGLONG                m_lTimeOffset;          // Time difference
    IReferenceClock        *m_pPCClock;             // PortCls clock
    
private:
    BOOL PinSetState(KSSTATE DeviceState);
    HRESULT InitializeDownloadObjects();
    HRESULT InitializeCapture();
	void FreeWDMHandle();
    void CaptureThread();
    void InputWorkerDataReady(REFERENCE_TIME rtStart, LPBYTE pbData, ULONG cbData);
    void ThruEvent(DMEVENT *pEvent);
    void InitChannelPriorities(UINT uLoCG, UINT uHighCG);
    HRESULT SetDirectSoundI(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer,
        BOOL fSetByUser);
    void MasterToSlave(REFERENCE_TIME *);
    void SlaveToMaster(REFERENCE_TIME *);
    void SyncClocks();
};

class CPortLatencyClock : public IReferenceClock
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    virtual STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    virtual STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime,  
				    REFERENCE_TIME streamTime,
				    HANDLE hEvent,            
				    DWORD * pdwAdviseCookie); 

    virtual STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime,
					REFERENCE_TIME periodTime,
					HANDLE hSemaphore,   
					DWORD * pdwAdviseCookie);

    virtual STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // Class
    //
    CPortLatencyClock(HANDLE hPin, ULONG ulNodeId, CDirectMusicPort *port);
    ~CPortLatencyClock();

private:
    long m_cRef;                   
    HANDLE m_hPin;                  
    ULONG m_ulNodeId;
    CDirectMusicPort *m_pPort;
};

// Synth port
//
extern HRESULT 
CreateCDirectMusicSynthPort(
    PORTENTRY               *pe, 
    CDirectMusic            *pDM, 
    UINT                    uVersion,
    DMUS_PORTPARAMS         *pPortParams,
    IDirectMusicPort        **ppPort);
class CDirectMusicSynthPort : 
    public CDirectMusicPortDownload, 
    public IDirectMusicPort, 
    public IDirectMusicPortP, 
    public IDirectMusicPortPrivate, 
    public IKsControl
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPort
    //
    STDMETHODIMP PlayBuffer(LPDIRECTMUSICBUFFER pBuffer);
    STDMETHODIMP SetReadNotificationHandle(HANDLE hEvent);
    STDMETHODIMP Read(LPDIRECTMUSICBUFFER pBuffer);

	STDMETHODIMP DownloadInstrument(IDirectMusicInstrument* pInstrument,
							 			    IDirectMusicDownloadedInstrument** pDownloadedInstrument,
											DMUS_NOTERANGE* NoteRanges,
											DWORD dwNumNoteRanges);
	STDMETHODIMP UnloadInstrument(IDirectMusicDownloadedInstrument* pDownloadedInstrument);

    STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
    STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    STDMETHODIMP Compact();
    STDMETHODIMP GetCaps(LPDMUS_PORTCAPS pPortCaps);
	STDMETHODIMP DeviceIoControl(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, 
	                                 LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNumChannelGroups(DWORD dwChannelGroups);
    STDMETHODIMP GetNumChannelGroups(LPDWORD pdwChannelGroups);
    STDMETHODIMP Activate(BOOL fActivate) PURE;
    STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
    STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize);

    // IDirectMusicPortP
    //
    STDMETHODIMP DownloadWave(
         IN  IDirectSoundWave *pWave,               
         OUT IDirectSoundDownloadedWaveP **ppWave,
         IN  REFERENCE_TIME rtStartHint
        );
        
    STDMETHODIMP UnloadWave(
         IDirectSoundDownloadedWaveP *pWave      
        );
            
    STDMETHODIMP AllocVoice(
         IDirectSoundDownloadedWaveP *pWave,     
         DWORD dwChannel,                       
         DWORD dwChannelGroup,                  
         IN  REFERENCE_TIME rtStart,                     
         IN  SAMPLE_TIME stLoopStart,
         IN  SAMPLE_TIME stLoopEnd,         
         IDirectMusicVoiceP **ppVoice            
        );        

    STDMETHODIMP AssignChannelToBuses(
         IN DWORD dwChannelGroup,
         IN DWORD dwChannel,
         IN LPDWORD pdwBusses,
         IN DWORD cBussCount
        );        
        
    // IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    STDMETHODIMP SetSink(
        IN IDirectSoundConnect *pSinkConnect
       );        

    STDMETHODIMP GetSink(
        IN IDirectSoundConnect **ppSinkConnect
       );        

    virtual STDMETHODIMP Download(IDirectMusicDownload* pIDMDownload);
	virtual STDMETHODIMP Unload(IDirectMusicDownload* pIDMDownload);
	virtual STDMETHODIMP GetAppend(DWORD* pdwAppend);

    // IDirectMusicPortPrivate
    STDMETHODIMP Close();

    STDMETHODIMP StartVoice(          
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart, 
         DWORD dwDLId,
         LONG prPitch,
         LONG vrVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd);

    STDMETHODIMP StopVoice(
         DWORD dwVoiceID,
         REFERENCE_TIME rtStop);
    
    STDMETHODIMP GetVoiceState(
        DWORD dwVoice[], 
        DWORD cbVoice,
        DMUS_VOICE_STATE dwVoiceState[]);

    STDMETHODIMP Refresh(
        DWORD dwDownloadID,
        DWORD dwFlags);

    // Class
    //
    static HRESULT CreateSynthPort(
        PORTENTRY               *pe, 
        CDirectMusic            *pDM, 
        UINT                    uVersion,
        DMUS_PORTPARAMS         *pPortParams,
        CDirectMusicSynthPort   **ppPort);
    
    CDirectMusicSynthPort(
        PORTENTRY               *pPE, 
        CDirectMusic            *pDM,
        IDirectMusicSynth       *pSynth);
        
    virtual ~CDirectMusicSynthPort();
    
protected:    
    HRESULT Initialize(LPDMUS_PORTPARAMS pPortParams);
    void InitChannelPriorities(UINT uLoCG, UINT uHighCG);
    void InitializeVolumeBoost();
    void SetSinkKsControl(IKsControl *pSinkKsControl);
    
protected:
    long                        m_cRef;             // COM reference count
    CDirectMusic                *m_pDM;             // Owning DirectMusic object
    IDirectMusicPortNotify      *m_pNotify;         // Notification interface
    IKsControl                  *m_pSynthPropSet;   // Synth property set
    IKsControl                  *m_pSinkPropSet;    //  and sink property set
    IDirectMusicSynth           *m_pSynth;          // Base level synth iface
    DWORD                       m_dwChannelGroups;  // Cached #channel groups
    DMUS_PORTCAPS               m_dmpc;
    DWORD                       m_dwFeatures;       // Features from portparams
};


// IDirectMusicBuffer implementation.
//
// Common to emulation/WDM.
//
class CDirectMusicBuffer : public IDirectMusicBuffer
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IDirectMusicBuffer
    //
    virtual STDMETHODIMP Flush();
    virtual STDMETHODIMP TotalTime(LPREFERENCE_TIME pdwTime);
    virtual STDMETHODIMP PackStructured(REFERENCE_TIME rt, DWORD dwChannelGroup, DWORD dwMsg);
    virtual STDMETHODIMP PackUnstructured(REFERENCE_TIME rt, DWORD dwChannelGroup, DWORD cb, LPBYTE lpb);
    virtual STDMETHODIMP ResetReadPtr();
    virtual STDMETHODIMP GetNextEvent(LPREFERENCE_TIME, LPDWORD, LPDWORD, LPBYTE *);
    
    virtual STDMETHODIMP GetRawBufferPtr(LPBYTE *);
    virtual STDMETHODIMP GetStartTime(LPREFERENCE_TIME);
    virtual STDMETHODIMP GetUsedBytes(LPDWORD);
    virtual STDMETHODIMP GetMaxBytes(LPDWORD);
    virtual STDMETHODIMP GetBufferFormat(LPGUID pGuidFormat);

    virtual STDMETHODIMP SetStartTime(REFERENCE_TIME);
    virtual STDMETHODIMP SetUsedBytes(DWORD);
    
    
    // Class
    //
    CDirectMusicBuffer(DMUS_BUFFERDESC &dmbd);
    ~CDirectMusicBuffer();
    HRESULT Init();
    DMUS_EVENTHEADER *AllocEventHeader(REFERENCE_TIME rt, DWORD cbEvent, DWORD dwChannelGroup, DWORD dwFlags);

private:
    long m_cRef;
    REFERENCE_TIME m_rtBase;
    REFERENCE_TIME m_totalTime;
    LPBYTE m_pbContents;
    DWORD m_maxContents;
    DWORD m_cbContents;
    DWORD m_idxRead;
    DMUS_BUFFERDESC m_BufferDesc;

    DWORD m_nEvents;
};

// Class factory
//
// Common to emulation/WDM.
// 
class CDirectMusicFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicFactory() : m_cRef(1) {}

    // Destructor
    // ~CMathFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicCollectionFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
	CDirectMusicCollectionFactory() : m_cRef(0) {AddRef();}

	// Destructor
	 ~CDirectMusicCollectionFactory() {} 

private:
	long m_cRef;
};


#ifdef USE_WDM_DRIVERS
// Enumeration of WDM devices
//
HRESULT EnumerateWDMDevices(CDirectMusic *pDirectMusic);
#endif


// Helper functions for dealing with SysAudio
//
BOOL OpenDefaultDevice(REFGUID rguidCategory, HANDLE *pHandle);
BOOL GetSysAudioProperty(HANDLE hFileObject, ULONG PropertyId, ULONG DeviceIndex, ULONG cbProperty, PVOID pProperty);
BOOL SetSysAudioProperty(HANDLE hFileObject, ULONG PropertyId, ULONG cbProperty, PVOID pProperty);
BOOL GetPinProperty(HANDLE pFileObject, ULONG PropertyId, ULONG PinId, ULONG cbProperty, PVOID pProperty);
BOOL SetPinProperty(HANDLE pFileObject, ULONG PropertyId, ULONG PinId, ULONG cbProperty, PVOID pProperty);
BOOL GetPinPropertyEx(HANDLE hFileObject, ULONG PropertyId, ULONG PinId, PVOID *ppProperty);
BOOL IsEqualInterface(const KSPIN_INTERFACE *pInterface1, const KSPIN_INTERFACE *pInterface2);
HRESULT CreatePin(HANDLE handleFilter, ULONG ulPinId, HANDLE *pHandle);
BOOL GetSizedProperty(HANDLE handle, ULONG ulPropSize, PKSPROPERTY pKsProperty, PVOID* ppvBuffer, PULONG pulBytesReturned);
BOOL Property(HANDLE handle, ULONG ulPropSize, PKSPROPERTY pKsProperty, ULONG ulBufferSize, PVOID pvBuffer, PULONG pulBytesReturned);
BOOL SyncIoctl(HANDLE handle, ULONG ulIoctl, PVOID pvInBuffer, ULONG ulInSize, PVOID   pvOutBuffer, ULONG ulOutSize, PULONG pulBytesReturned);

BOOL GetSysAudioDeviceCount(HANDLE hSysAudio, PULONG pulDeviceCount);
BOOL SetSysAudioDevice(HANDLE hSysAudio, ULONG idxDevice);
BOOL CreateVirtualSource(HANDLE hSysAudio, PULONG pulSourceIndex);
BOOL AttachVirtualSource(HANDLE hPin, ULONG ulSourceIndex);
int  FindGuidNode(HANDLE hSysAudio, ULONG ulPinId, REFGUID rguid);
BOOL GetFilterCaps(HANDLE hSysAudio, ULONG idxNode, PSYNTHCAPS pcaps);
BOOL GetNumPinTypes(HANDLE hSysAudio, PULONG pulPinTypes);
BOOL PinSupportsInterface(HANDLE hSysAudio, ULONG ulPinId, REFGUID rguidInterface, ULONG ulId);
BOOL PinSupportsDataRange(HANDLE hSysAudio, ULONG ulPinId, REFGUID rguidFormat, REFGUID rguidSubformat);
BOOL PinGetDataFlow(HANDLE hSysAudio, ULONG ulPinId, PKSPIN_DATAFLOW pkspdf);
BOOL GetDeviceFriendlyName(HANDLE hSysAudio, ULONG ulDeviceIndex, PWCHAR pwch, ULONG cbwch);
BOOL GetDeviceInterfaceName(HANDLE hSysAudio, ULONG ulDeviceIndex, PWCHAR pwch, ULONG cbwch);
BOOL DINameToInstanceId(char *pstrDIName, char **ppInstanceId);
BOOL InstanceIdOfPreferredAudioDevice(char **ppInstanceId);

// Helper functions for dealing with DirectSound
//
HRESULT DirectSoundDevice(LPDIRECTSOUND pDirectSound, LPSTR *pstrInterface);

HRESULT WIN32ERRORtoHRESULT(DWORD dwError);

// Helper functions from DMDLL.CPP
//
BOOL LoadDmusic32(void);
BOOL LoadKsUser(void);

DEFINE_GUID(GUID_Mapper,					 0x58d58418, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_SysClock,					 0x58d58419, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IDirectMusicPortNotify,		 0x58d5841a, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IDirectMusicPortPrivate,	 0x58d5841c, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_KsClock,					 0x58d5841d, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IMasterClockPrivate,         0x58d5841e, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_KsClockHandle,              0x58d5841f, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_WDMSynth,                   0x490a03e8, 0x742f, 0x11d2, 0x8f, 0x8a, 0x00, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(GUID_DsClock,                    0x58d58420, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_ExtClock,                   0x58d58421, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);


#if 0
// List o' unused UUID's
58d58422-71b4-11d1-a74c-0000f875ac12
58d58423-71b4-11d1-a74c-0000f875ac12
58d58424-71b4-11d1-a74c-0000f875ac12
58d58425-71b4-11d1-a74c-0000f875ac12
58d58426-71b4-11d1-a74c-0000f875ac12
58d58427-71b4-11d1-a74c-0000f875ac12
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmvoice.cpp ===
//
// dmvoice.cpp
// 
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
//

#include <windows.h>

#include "debug.h"
#include "dmusicp.h"
#include "validate.h"
#include "dmvoice.h"
#include "dswave.h"

// Class global: next available voice ID
//
DWORD CDirectMusicVoice::m_dwNextVoiceId = 1;

// Class global Voice Service Thread 
//
LONG CDirectMusicVoice::m_cRefVST           = 0;
HANDLE CDirectMusicVoice::m_hVSTWakeUp      = (HANDLE)NULL;
HANDLE CDirectMusicVoice::m_hVSTThread      = (HANDLE)NULL;
DWORD CDirectMusicVoice::m_dwVSTThreadId    = 0;
bool CDirectMusicVoice::m_fVSTStopping      = false;
CVSTClientList CDirectMusicVoice::m_ClientList;
CRITICAL_SECTION CDirectMusicVoice::m_csVST; 

DWORD WINAPI VoiceServiceThreadThk(LPVOID lpParameter);

//#############################################################################
//
// CDirectMusicVoice
//
//#############################################################################

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::QueryInterface
//
//
STDMETHODIMP CDirectMusicVoice::QueryInterface(
    const IID &iid,
    void **ppv) 
{
    V_INAME(IDirectMusicVoice::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicVoiceP)
    {
        *ppv = static_cast<IDirectMusicVoiceP*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::AddRef
//
//
STDMETHODIMP_(ULONG) CDirectMusicVoice::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::Release
//
//
STDMETHODIMP_(ULONG) CDirectMusicVoice::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::CDirectMusicVoice
//
//
CDirectMusicVoice::CDirectMusicVoice(
    CDirectMusicPortDownload *pPortDL,
    IDirectSoundDownloadedWaveP *pWave,
    DWORD dwChannel,
    DWORD dwChannelGroup,
    REFERENCE_TIME rtStart,
    REFERENCE_TIME rtReadAhead,
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd) :
    m_cRef(1)
{
    assert(pPortDL);
    assert(pWave);

    HRESULT hr = pPortDL->QueryInterface(IID_IDirectMusicPort, (void**)&m_pPort);
    assert(SUCCEEDED(hr));
    
    CDirectSoundWave *pDSWave = static_cast<CDirectSoundWave*>(pWave);

    m_nChannels         = pDSWave->GetNumChannels();
    m_dwVoiceId         = AllocVoiceId(m_nChannels);
    m_pPortDL           = pPortDL;
    m_pDSDLWave         = pWave;
    m_dwChannel         = dwChannel;
    m_dwChannelGroup    = dwChannelGroup;
    m_stStart           = pDSWave->RefToSampleTime(rtStart);
    m_stReadAhead       = pDSWave->RefToSampleTime(rtReadAhead);
    m_stLoopStart       = stLoopStart;
    m_stLoopEnd         = stLoopEnd;


    // HACKHACK make sure we fit into streaming buffers
    //
    SAMPLE_TIME stStream = pDSWave->GetStreamSize();
    
    if (stStream < 4 * m_stReadAhead)
    {
        m_stReadAhead = stStream / 4;
    }

    // rtReadAhead must fit in 32-bits worth of milliseconds (49 days)
    //
    m_msReadAhead       = (DWORD)(rtReadAhead / (10 * 1000));

    m_pDSWD             = NULL;

    //m_pPort->AddRef();
    m_pDSDLWave->AddRef();

    m_pPortPrivate      = NULL;

    m_fIsPlaying        = false;
    m_fIsStreaming      = pDSWave->IsStreaming();

    if (m_fIsStreaming)
    {
        m_stLoopStart = 0;
        m_stLoopEnd = 0;
    }
}
        
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::Init
//
//
HRESULT CDirectMusicVoice::Init()
{
    HRESULT hr = S_OK;

    CDirectSoundWave *pDSWave = (CDirectSoundWave*)m_pDSDLWave;

    m_fRunning = false; // Have not started running yet.
    if (m_fIsStreaming)
    {
        TraceI(2, "Voice doing streaming init\n");
        m_pDSWD = new CDirectSoundWaveDownload(
            static_cast<CDirectSoundWave*>(m_pDSDLWave),
            m_pPortDL,
            m_stStart,
            m_stReadAhead);
        
        hr = HRFromP(m_pDSWD);

        if (SUCCEEDED(hr))
        {
            // We download only the required wave data
            // So set the start time to 0
            m_stStart = 0;
            hr = m_pDSWD->Init();
        }

        if (SUCCEEDED(hr))
        {
             hr = m_pDSWD->Download();
        }

        if (SUCCEEDED(hr))
        {
            m_dwDLId = m_pDSWD->GetDLId();
        }
    }
    else
    {   
        // One-shot case
        //
        m_dwDLId = pDSWave->GetDLId();
        TraceI(2, "Got download ID %d from pDSWave %d\n", m_dwDLId);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pPort->QueryInterface(
            IID_IDirectMusicPortPrivate, 
            (void**)&m_pPortPrivate);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::~CDirectMusicVoice
//
//
CDirectMusicVoice::~CDirectMusicVoice()
{
    if(m_pDSWD)
    {
        // Voice is going away so unload the downloaded wave
        m_pDSWD->Unload();
        delete m_pDSWD;
    }

    RELEASE(m_pPortPrivate);
    RELEASE(m_pPort);
    RELEASE(m_pDSDLWave);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::Play
//
//
STDMETHODIMP CDirectMusicVoice::Play(
    REFERENCE_TIME rtStart,
    LONG prPitch,
    LONG vrVolume)
{
    HRESULT                 hr = S_OK;
    CVSTClient             *pClient = FindClientByPort(m_pPort);

    TraceI(2, "Starting voice %d [%p] using DLID %d\n", m_dwVoiceId, this, m_dwDLId);

    CDirectSoundWave *pDSWave = static_cast<CDirectSoundWave*>(m_pDSDLWave);

    //Check that FindClientByPort returned a clinet
    if (pClient == NULL)
    {
    	hr = E_FAIL;
    	return hr;
    }

    if (m_fIsStreaming)
    {
        EnterCriticalSection(&m_csVST);
    
        if (m_fIsPlaying) 
        {
            // XXX Error code
            //
            hr = E_INVALIDARG;
        }            
        else
        {
            // Add this voice to the proper client list.
            // This will cause the thread to be kicked to update
            // its wakeup interval.
            //
            if (pClient == NULL) 
            {
                TraceI(0, "Play: Port voice is to be played on has disappeared!\n");
                hr = E_FAIL;
            }                                    
            else
            {
                pClient->AddTail(this);
                hr = pClient->BuildVoiceIdList();
                if (FAILED(hr))
                {
                    pClient->Remove(this);
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        UpdateVoiceServiceThread();

        DWORD i;

        for (i = 0; SUCCEEDED(hr) && i < m_nChannels; i++) 
        {
            // Voice ID's and wave articulation download ID's are 
            // allocated sequentially, one per channel
            //
            hr = m_pPortPrivate->StartVoice(
                m_dwVoiceId + i,
                m_dwChannel,
                m_dwChannelGroup,
                rtStart,
                m_dwDLId + i,
                prPitch,
                vrVolume,
                m_stStart,
                m_stLoopStart,
                m_stLoopEnd);
        }
        if (FAILED(hr))
        {
            for (i = 0; i < m_nChannels; i++) 
            {
                m_pPortPrivate->StopVoice(
                    m_dwVoiceId + i,
                    rtStart + 1);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        // NOTE: We should still be in the critical section whenever this
        // is changed since the VST will change it as well.
        //
        m_fIsPlaying = true;
    }

    if (m_fIsStreaming)
    {
        if (FAILED(hr))
        {
            pClient->Remove(this);
        }

        LeaveCriticalSection(&m_csVST);
    }

    return hr;
}
    
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::Stop
//
//
STDMETHODIMP CDirectMusicVoice::Stop(
    REFERENCE_TIME rtStop)
{
    HRESULT                 hr = S_OK;

    if (m_fIsStreaming)
    {
        EnterCriticalSection(&m_csVST);
    
        if (!m_fIsPlaying)
        {
            // XXX Error code
            //
            hr = E_INVALIDARG;
        }
        else
        {
            CVSTClient *pClient = FindClientByPort(m_pPort);
            if (pClient == NULL) 
            {
                TraceI(0, "Play: Port voice is to be stopped on has disappeared!\n");
                hr = E_FAIL;
            }                                    
            else
            {
                pClient->Remove(this);
                pClient->BuildVoiceIdList();
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        UpdateVoiceServiceThread();

        DWORD i;

        for (i = 0; i < m_nChannels; i++)
        {
            HRESULT hrTemp;

            hrTemp = m_pPortPrivate->StopVoice(
                m_dwVoiceId + i,
                rtStop);

            if (FAILED(hrTemp))
            {
                hr = hrTemp;
            }
        }
    }
    
    if (SUCCEEDED(hr))
    {
        // NOTE: We should still be in the critical section whenever this
        // is changed since the VST will change it as well.
        //
        m_fIsPlaying = false;
    }

    if (m_fIsStreaming)
    {
        LeaveCriticalSection(&m_csVST);
    }

    return hr;                
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::StartVoiceServiceThread
//
//
HRESULT CDirectMusicVoice::StartVoiceServiceThread(
    IDirectMusicPort *pPort)
{
    HRESULT                 hr = S_OK;
    DWORD                   dwError;
    CVSTClient              *pClient = NULL;
    bool                    fShutdownOnFail = false;
    
    EnterCriticalSection(&m_csVST);

    pClient = new CVSTClient(pPort);
    hr = HRFromP(pClient);

    if (SUCCEEDED(hr) && ++m_cRefVST == 1) 
    {
        // This is the first time a port has requested the service thread,
        // so start it for real.
        //
        fShutdownOnFail = true;

        m_hVSTWakeUp = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (m_hVSTWakeUp == (HANDLE)NULL)
        {
            dwError = GetLastError();
            TraceI(0, "VoiceServiceThread: CreateEvent failed %d\n", dwError);

            hr = WIN32ERRORtoHRESULT(dwError);
        }

        m_fVSTStopping = false;
        if (SUCCEEDED(hr))
        {
            m_hVSTThread = CreateThread(
                NULL,               // Attributes
                0,                  // Stack size
                ::VoiceServiceThreadThk,
                0,
                0,                  // Flags
                &m_dwVSTThreadId);
            if (m_hVSTThread == (HANDLE)NULL)
            {
                dwError = GetLastError();
                TraceI(0, "VoiceServiceThread: CreateThread failed %d\n", dwError);

                hr = WIN32ERRORtoHRESULT(GetLastError());
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        m_ClientList.AddTail(pClient);        
    }

    if (FAILED(hr))
    {
        if (fShutdownOnFail)
        {
            if (m_hVSTWakeUp) 
            {
                CloseHandle(m_hVSTWakeUp);
                m_hVSTWakeUp = NULL;
            }

            assert(!m_hVSTThread);
        
            m_cRefVST = 0;        
        }

        delete pClient;
    }

    LeaveCriticalSection(&m_csVST);
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::StopVoiceServiceThread
//
//
HRESULT CDirectMusicVoice::StopVoiceServiceThread(IDirectMusicPort *pPort)
{
    HRESULT                 hr = S_OK;

    EnterCriticalSection(&m_csVST);

    CVSTClient *pClient = FindClientByPort(pPort);

    if (pClient == NULL) 
    {
        TraceI(0, "Port %p tried to stop the voice service thread without starting it\n", pPort);
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        // XXX Clean up still playing voices 
        //
        m_ClientList.Remove(pClient);
        delete pClient;
    }

    if (SUCCEEDED(hr) && --m_cRefVST == 0)
    {
        // Last user is releasing. Try to shut down the thread.
        //
        assert(m_hVSTWakeUp);
        assert(m_hVSTThread);

        TraceI(2, "Killing Voice Service Thread\n");
        m_fVSTStopping = true;
        SetEvent(m_hVSTWakeUp);

        if (WaitForSingleObject(m_hVSTThread, 5000) == WAIT_TIMEOUT)
        {
            TraceI(0, "Voice Service Thread refused to die!\n");
        }   

        CloseHandle(m_hVSTWakeUp);
        CloseHandle(m_hVSTThread);
    }

    LeaveCriticalSection(&m_csVST);
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::VoiceServiceThread
//
//
DWORD WINAPI VoiceServiceThreadThk(LPVOID lpParameter)
{
    CDirectMusicVoice::VoiceServiceThread();
    return 0;
}

void CDirectMusicVoice::VoiceServiceThread()
{
    DWORD                   dwTimeout = 500;    // Force it to recalculate the timeout after 500ms.
    DWORD                   dwWFSO;
    bool                    fService;
    bool                    fRecalcTimeout;

    for(;;)
    {
        dwWFSO = WaitForSingleObject(m_hVSTWakeUp, dwTimeout);
        if (m_fVSTStopping) 
        {
            break;
        }

        fService = false;
        fRecalcTimeout = false;
        switch(dwWFSO)
        {
            // If the timeout was hit, it's time to service voices.
            //
            case WAIT_TIMEOUT:
                fService = true;
                break;
        
            // If the event was triggered, we've received a request to 
            // either die (m_fVSTStopping will be set) or the voice list
            // changed, so we're supposed to recalculate the wakeup time.
            //
            case WAIT_OBJECT_0:
                if (!m_fVSTStopping) 
                {
                    fRecalcTimeout = true;  // Need to recalculate time out.
                    fService = true;        // Make sure any buffer refilling that
                                            // needs to be done is taken care of.
                }
                break;

            // These two should never happen.
            //            
            case WAIT_FAILED:
                TraceI(1, "VST: WaitForSingleObject failed %d; rewaiting.\n",
                    GetLastError());
                continue;
                
            default:
                TraceI(0, "VST: WaitForSingleObject: Unexpected return %d\n", 
                    dwWFSO);                
                continue;
        }

        EnterCriticalSection(&m_csVST);
        
        if (fService)
        {
            // If voices stop, then we should recalc the timeout.
            //
            ServiceVoiceQueue(&fRecalcTimeout);
        }                        

        if (fRecalcTimeout)
        {
            dwTimeout = (VoiceQueueMinReadahead() / 2);
        }
        LeaveCriticalSection(&m_csVST);
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::ServiceVoiceQueue
//
// Called from VoiceServiceThread() to walk the queue and see which voices
// need servicing. Assumes caller has the voice service critical section.
//
//
void CDirectMusicVoice::ServiceVoiceQueue(bool *pfRecalcTimeout)
{
    HRESULT                 hr;
    DMUS_VOICE_STATE       *psp;
    CDirectMusicVoice      *pVoice;

    for (CVSTClient *pClient = m_ClientList.GetHead(); pClient; pClient = pClient->GetNext()) 
    {
        hr = pClient->GetVoiceState(&psp);
        if (FAILED(hr))
        {
            continue;
        }

        // The DMUS_VOICE_STATE array returned by GetVoicePosition lines up
        // with the order of voices in the CVSTClient's voice list
        //
        bool fClientVoiceListChanged = false;

        for (pVoice = pClient->GetVoiceListHead();
             pVoice;
             pVoice = pVoice->GetNext(), psp++)
        {
            if (psp->bExists)
            {
                hr = pVoice->m_pDSWD->RefreshThroughSample(psp->spPosition);
                if (FAILED(hr))
                {
                    TraceI(0, "VST: RefreshThroughSample failed %08X\n", hr);
                    continue;
                }
                pVoice->m_fRunning = true; // Now that we've started writing data, 
                                           // psp->bExists failing will safely mean synth terminated it,
                                           // as opposed to not started yet.
            }
            
            // S_FALSE indicates that the end of data has been reached
            // on this voice. Also kill it if the synth has terminated
            // it.
            //
            if (hr == S_FALSE || (!psp->bExists && pVoice->m_fRunning))
            {
                pVoice->Stop(0);
                pVoice->m_fIsPlaying = false;
                fClientVoiceListChanged = true;
            }
        }

        // If anything changed in this client's voice list,
        // update it now.
        //
        if (!fClientVoiceListChanged)
        {
            continue;
        }

        // Something's changed, recalc the wakeup time before going
        // back to sleep
        //
        *pfRecalcTimeout = true;

        // Yank out the voices which have completed.
        //
        for (pVoice = pClient->GetVoiceListHead(); pVoice; )
        {
            // Voice is still playing, do nothing
            //
            if (pVoice->m_fIsPlaying)
            {
                pVoice = pVoice->GetNext();
                continue;
            }

            // Just finished, remove from list
            //
            CDirectMusicVoice *pNext = pVoice->GetNext();
            pClient->Remove(pVoice);
            pVoice = pNext;
        }

        // This call cannot fail because the only way it can is to run out of
        // memory, and memory allocation is not done when the list shrinks.
        //
        pClient->BuildVoiceIdList();
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::VoiceQueueMinReadahead
//
// Called from VoiceServiceThread() to walk the queue and determine the
// minimum readahead in milliseconds. Assumes caller has the voice service
// critical section.
//
DWORD CDirectMusicVoice::VoiceQueueMinReadahead()
{
    DWORD                   dwMin = INFINITE;
    for (CVSTClient *pClient = m_ClientList.GetHead(); pClient; pClient = pClient->GetNext()) 
    {
        for (CDirectMusicVoice *pVoice = pClient->GetVoiceListHead(); pVoice; pVoice = pVoice->GetNext())
        {
            dwMin = min(dwMin, pVoice->m_msReadAhead);            
        }
    }

    return dwMin;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::FindClientByPort
//
// Given a port pointer, find the matching CVSTClient if there is one.
//
CVSTClient *CDirectMusicVoice::FindClientByPort(IDirectMusicPort *pPort)
{
    CVSTClient *pCurr = m_ClientList.GetHead();

    while (pCurr)
    {
		IDirectMusicPort *pCurrPort = pCurr->GetPort();

        if (pCurrPort == pPort)
        {   
            break;
        }

        pCurr = pCurr->GetNext();
    }

    return pCurr;
}

//#############################################################################
//
// CVSTClient
//
//#############################################################################

const UINT CVSTClient::m_cAllocSize = 32;

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClient::CVSTClient
//
//
CVSTClient::CVSTClient(IDirectMusicPort *pPort)
{
    m_pPort = pPort;

    m_pdwVoiceIds = NULL;
    m_pspVoices   = NULL;
    m_cVoiceIdsAlloc = 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClient::~CVSTClient
//
//
CVSTClient::~CVSTClient()
{
    delete[] m_pdwVoiceIds;
    delete[] m_pspVoices;
}

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClient::BuildVoiceIdList
//
// Build the voice ID array, and make sure it and the sample position array 
// are big enough for all voices. These arrays are used to call into the
// synth to figure out how far each voice has rendered.
//
// The caller must have taken the voice service thread critical section.
//
// This method guarantees that on failure, the existing list will not be
// touched.
//
HRESULT CVSTClient::BuildVoiceIdList()
{
    // To minimize allocations, the arrays are allocated in chunks and never
    // shrink. (The amount of memory here is extremely small... 12 bytes per 
    // voice).
    //
    if (m_VoiceList.GetCount() > m_cVoiceIdsAlloc)
    {
        LONG cNewAlloc = ((m_VoiceList.GetCount() / m_cAllocSize) + 1) * m_cAllocSize;

        DWORD *pdw = new DWORD[cNewAlloc];
        DMUS_VOICE_STATE *psp = new DMUS_VOICE_STATE[cNewAlloc];

        // Check allocation
        if (pdw == NULL || psp == NULL) 
        {
        	delete[] pdw;
        	delete[] psp;
            return E_OUTOFMEMORY;
        }

        memset(pdw, 0, cNewAlloc * sizeof(DWORD));
        memset(psp, 0, cNewAlloc * sizeof(SAMPLE_POSITION));

        m_cVoiceIdsAlloc = cNewAlloc;

        delete[] m_pdwVoiceIds;
        delete[] m_pspVoices;
        
        m_pdwVoiceIds = pdw;
        m_pspVoices = psp;
    }

    // We know there's enough space now. Walk the voice list and
    // fill in the voice Id's.
    //
    // This assumes that the list order will not change and that 
    // the array is kept in sync with the list.
    //
    DWORD *pdwIds = m_pdwVoiceIds;

    CDirectMusicVoice *pVoice = GetVoiceListHead();
    for (; pVoice; pVoice = pVoice->GetNext())
    {
        *pdwIds++ = pVoice->GetVoiceId();
    }

    m_cVoiceIds = m_VoiceList.GetCount();

    return S_OK;  
}

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClient::GetVoiceState
//
// Wraps the port GetVoiceState call with the voice list the CVSTClient 
// maintains.
//
HRESULT CVSTClient::GetVoiceState(DMUS_VOICE_STATE **ppsp)
{
    HRESULT                 hr;
    IDirectMusicPortPrivate *pPrivate;

    if (m_pdwVoiceIds)
    {

        hr = m_pPort->QueryInterface(IID_IDirectMusicPortPrivate, (void**)&pPrivate);

        if (SUCCEEDED(hr))
        {
            hr = pPrivate->GetVoiceState(
                m_pdwVoiceIds,
                m_cVoiceIds,
                m_pspVoices);
            pPrivate->Release();
        }

        if (SUCCEEDED(hr))
        {
            *ppsp = m_pspVoices;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmwavobj.h ===
//
// dmwavobj.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay
//

#ifndef DMWAVOBJ_H
#define DMWAVOBJ_H

#include "dmextchk.h"

// Windows Media Audio codec Format Tags
#define MSAUDIO_FORMAT_TAG	352	// V1
#define WMAUDIO_FORMAT_TAG	353	// V2

// Key required for Windows Media Audio codecs
#define MSAUDIO_DEC_KEY "1A0F78F0-EC8A-11d2-BBBE-006008320064"


class CCopyright;
class CRiffParser;

class CWaveObj : public AListItem      
{       
friend class CCollection;
friend class CInstrument;
friend class CWaveObjList;

private:
	CWaveObj();
	~CWaveObj();

	CWaveObj* GetNext(){return (CWaveObj*)AListItem::GetNext();}
	HRESULT Load(DWORD dwId, CRiffParser *pParser, CCollection* pParent);

	void Cleanup();
	HRESULT Size(DWORD* pdwSize, DWORD * pdwSampleSize);
	HRESULT Write(void* pvoid);

	HRESULT GetData(BYTE* pdwBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead);
	HRESULT ReadData(IStream* pStream, BYTE* pdwBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead);
	HRESULT ReadCompressedData(IStream* pStream, BYTE* pdwBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead);
	HRESULT CanDecompress();
	HRESULT CalcDataSize(DWORD *pdwSize);
	HRESULT DecompressWave(WAVEFORMATEX *pwfxSrc, 
						   WAVEFORMATEX *pwfxDst, 
						   BYTE *pbCompressedBuffer,
						   BYTE *pbDecompressBuffer,
						   DWORD dwSizeCompressed, 
						   DWORD dwSizeDecompressed);

	HRESULT AllocWMAudioFormat(const WAVEFORMATEX* pwfxSrc, WAVEFORMATEX** ppwfxWMAudioWave);
	
private:
	CRITICAL_SECTION			m_DMWaveCriticalSection;
    BOOL                        m_fCSInitialized;
	BOOL                        m_fReadDecompressionFormat;
	WAVEFORMATEX				m_WaveFormatRead;
	WAVEFORMATEX				m_WaveFormatWrite;
	WAVEFORMATEX                m_WaveFormatDecompress;
	BYTE*						m_pExtractWaveFormatData;
	CExtensionChunkList			m_ExtensionChunkList;
	CCopyright*					m_pCopyright;
	DWORD                       m_dwDataOffset;
	DWORD						m_dwDataSizeWrite;      // Calculated size of wave buffer.
    DWORD                       m_dwDataSizeAfterACM;   // Actual size after decompression.
	DWORD						m_dwDataSizeRead;
	DWORD						m_dwId;

	CCollection*		        m_pParent;

	DWORD						m_cbSizeOffsetTable;
	DWORD						m_dwCountExtChk;
	DWORD						m_dwSize;
	bool						m_bLoaded;
    DWORD                       m_dwDecompressedStart;
};      

class CWaveObjList : public AList
{
friend class CInstrument;
	
private:
	CWaveObjList(){}
	~CWaveObjList() 
	{
		while(!IsEmpty())
		{
			CWaveObj* pWaveObj = RemoveHead();
			delete pWaveObj;
		}
	}

    CWaveObj *GetHead(){return (CWaveObj *)AList::GetHead();}
	CWaveObj *GetItem(LONG lIndex){return (CWaveObj*)AList::GetItem(lIndex);}
    CWaveObj *RemoveHead(){return (CWaveObj *)AList::RemoveHead();}
	void Remove(CWaveObj *pWaveObj){AList::Remove((AListItem *)pWaveObj);}
	void AddTail(CWaveObj *pWaveObj){AList::AddTail((AListItem *)pWaveObj);}
};

#endif // #ifndef DMWAVOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmwavobj.cpp ===
//
// dmwaveobj.cpp
// 
// Copyright (c) 1997-2001 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay
//
#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicc.h"
#include "alist.h"
#include "debug.h"
#include "dlsstrm.h"
#include <mmreg.h>
#include <msacm.h>
#include "debug.h"
#include "dmcollec.h"
#include "dmcrchk.h"
#include "dmwavobj.h"
#include "dmportdl.h"

//////////////////////////////////////////////////////////////////////
// Class CWaveObj
 
//////////////////////////////////////////////////////////////////////
// CWaveObj::CWaveObj

CWaveObj::CWaveObj() :
m_pExtractWaveFormatData(NULL),
m_pCopyright(NULL),
m_dwDataOffset(0),
m_dwDataSizeWrite(0),
m_dwDataSizeRead(0),
m_dwId(0),
m_pParent(NULL),
m_cbSizeOffsetTable(0),
m_dwCountExtChk(0),
m_dwSize(0),
m_fCSInitialized(FALSE),
m_fReadDecompressionFormat(FALSE),
m_dwDecompressedStart(0)
#ifdef DBG
,m_bLoaded(false)
#endif
{
	InitializeCriticalSection(&m_DMWaveCriticalSection);
    m_fCSInitialized = TRUE;
	ZeroMemory(&m_WaveFormatRead, sizeof(m_WaveFormatRead));
	ZeroMemory(&m_WaveFormatWrite, sizeof(m_WaveFormatWrite));
}

//////////////////////////////////////////////////////////////////////
// CWavebj::~CWavebj

CWaveObj::~CWaveObj()
{
    if (m_fCSInitialized)
    {
    	Cleanup();
	    DeleteCriticalSection(&m_DMWaveCriticalSection);
    }
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::Load

HRESULT CWaveObj::Load(DWORD dwId, CRiffParser *pParser, CCollection* pParent)
{
    // Argument validation
    assert(pParent);

#ifdef DBG
    if(dwId >= CDirectMusicPortDownload::sNextDLId)
    {
        assert(FALSE);
    }
#endif

    m_dwId = dwId;
    m_pParent = pParent;
    m_pParent->AddRef();

    HRESULT hr = S_OK;
    
    RIFFIO ck;
    EnterCriticalSection(&m_DMWaveCriticalSection);
    
    pParser->EnterList(&ck);
    while (pParser->NextChunk(&hr))
    {
        switch(ck.ckid)
        {
            case mmioFOURCC('w','a','v','u') :
            {
                // Read the flag which indiactes Runtime or Designtime File
                bool bTemp = false;;
                hr = pParser->Read(&bTemp, sizeof(bool));
                if(SUCCEEDED(hr))
                {
                    // Read the flag that indicates compression
                    hr = pParser->Read(&bTemp, sizeof(bool));
                    if(SUCCEEDED(hr))
                    {
                        // this is a compressed wave file
                        if(bTemp == true)
                        {
                            hr = pParser->Read(&m_WaveFormatDecompress, sizeof(WAVEFORMATEX));

                            if(FAILED(hr))
                            {
                                hr = E_FAIL;
                                m_fReadDecompressionFormat = FALSE;
                            }
                            else
                            {
                                m_WaveFormatDecompress.nAvgBytesPerSec = m_WaveFormatDecompress.nSamplesPerSec * m_WaveFormatDecompress.nBlockAlign;
                                m_fReadDecompressionFormat = TRUE;
                            }

                            // Read the actual start of the decompressed data
                            // This is important for MP3 and WMA codecs that insert silence in the beginning
                            if(ck.cksize > 2 + sizeof(WAVEFORMATEX))
                            {
                                m_dwDecompressedStart = 0;
                                hr = pParser->Read(&m_dwDecompressedStart, sizeof(DWORD));
                                if(FAILED(hr))
                                {
                                    hr = E_FAIL;
                                    m_fReadDecompressionFormat = FALSE;
                                }
                            }
                        }
                    }
                }

                break;
            }

            case FOURCC_LIST :
                switch(ck.fccType)
                {
                case mmioFOURCC('I','N','F','O') :
                    m_pCopyright = new CCopyright;
                    if(m_pCopyright)
                    {
                        hr = m_pCopyright->Load(pParser);
                        if((m_pCopyright->m_byFlags & DMC_FOUNDICOP) == 0)
                        {
                            delete m_pCopyright;
                            m_pCopyright = NULL;
                        }
                    }
                    else
                    {
                        hr =  E_OUTOFMEMORY;
                    }
                    break;
                default :
                    // If we get here we have an unknown chunk
                    CExtensionChunk* pExtensionChunk = new CExtensionChunk;
                    if(pExtensionChunk)
                    {
                        hr = pExtensionChunk->Load(pParser);
                        m_ExtensionChunkList.AddHead(pExtensionChunk);
                        m_dwCountExtChk++;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    break;
                }
                break;

            case mmioFOURCC('f','m','t',' ') :
                hr = pParser->Read(&m_WaveFormatRead, sizeof(WAVEFORMATEX));
                if(SUCCEEDED(hr))
                {
                    if(m_WaveFormatRead.wFormatTag != WAVE_FORMAT_PCM)
                    {
                        if(m_WaveFormatRead.cbSize)
                        {
                            m_pExtractWaveFormatData = new BYTE[m_WaveFormatRead.cbSize];
                            if(m_pExtractWaveFormatData)
                            {
                                hr = pParser->Read(m_pExtractWaveFormatData, m_WaveFormatRead.cbSize);
                            }
                        }
                        if(SUCCEEDED(hr))
                        {
                            hr = CanDecompress();
                        }
                    }
                    else
                    {
                        // If WAVE_FORMAT_PCM this member should be zero
                        m_WaveFormatRead.cbSize = 0;
                        CopyMemory(&m_WaveFormatWrite, &m_WaveFormatRead, sizeof(m_WaveFormatRead));
                    }
                }
                break;
            case mmioFOURCC('d','a','t','a') : {
                pParser->MarkPosition();
                m_dwDataOffset = (DWORD) ck.liPosition.QuadPart;
                m_dwDataSizeRead = ck.cksize;
                DWORD dwTotalOffset = m_dwDataOffset + m_dwDataSizeRead;
                if (dwTotalOffset < m_dwDataOffset) {
                    hr = DMUS_E_INVALIDOFFSET; // overflow
                }
                else {
                    hr = m_pParent->ValidateOffset(dwTotalOffset);
                }
                break;
            }

            default :
                // If we get here we have an unknown chunk
                CExtensionChunk* pExtensionChunk = new CExtensionChunk;
                if(pExtensionChunk)
                {
                    hr = pExtensionChunk->Load(pParser);
                    m_ExtensionChunkList.AddHead(pExtensionChunk);
                    m_dwCountExtChk++;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                break;
        }
    }
    pParser->LeaveList();
    
#ifdef DBG
    if(SUCCEEDED(hr))
    {
        m_bLoaded = true;
    }
#endif

    if(FAILED(hr))
    {
        Cleanup();
    }
    
    LeaveCriticalSection(&m_DMWaveCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::Cleanup

void CWaveObj::Cleanup()
{
	EnterCriticalSection(&m_DMWaveCriticalSection);

	delete [] m_pExtractWaveFormatData;
	m_pExtractWaveFormatData = NULL;
	
	while(!m_ExtensionChunkList.IsEmpty())
	{
		CExtensionChunk* pExtChk = m_ExtensionChunkList.RemoveHead();
		delete pExtChk;
	}

	delete m_pCopyright;
	m_pCopyright = NULL;
	
	if(m_pParent)
	{
		m_pParent->Release();
		m_pParent = NULL;
	}

#ifdef DBG
	m_bLoaded = false;
#endif
	
	LeaveCriticalSection(&m_DMWaveCriticalSection);
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::Size

HRESULT CWaveObj::Size(DWORD* pdwSize,DWORD *pdwSampleSize)
{
	// Assumption validation
#ifdef DBG
	assert(m_bLoaded);
#endif
 	assert(pdwSize);

	// If have already calculated the size we do not need to do it again
	if(m_dwSize)
	{
		*pdwSize = m_dwSize;
		*pdwSampleSize = m_WaveFormatWrite.wBitsPerSample;
		return S_OK;
	}
	
	HRESULT hr = S_OK;
	
	DWORD dwTotalSize = 0;
	DWORD dwOffsetCount = 0;
	DWORD dwCountExtChk = 0;

	EnterCriticalSection(&m_DMWaveCriticalSection);

	// Calculate the space needed for DMUS_DOWNLOADINFO 
	dwTotalSize += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

	// Calculate the space needed for Wave's extension chunks
	CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	for(; pExtChk; pExtChk = pExtChk->GetNext())
	{
        DWORD dwOriginalSize = dwTotalSize;
		dwTotalSize += pExtChk->Size();
		if (dwTotalSize < dwOriginalSize) {
		    hr = E_FAIL; // overflow
		    break;
		}
		dwOffsetCount += pExtChk->Count();
		dwCountExtChk++;
	}

	if(SUCCEEDED(hr)) {
        // We want to validate the number of extension chunks
    	if(m_dwCountExtChk == dwCountExtChk)
    	{
    		// Calculate the space needed for wave's copyright
    		if(m_pCopyright)
    		{
                DWORD dwOriginalSize = dwTotalSize;
    			dwTotalSize += m_pCopyright->Size();
        		if (dwTotalSize < dwOriginalSize) {
        		    hr = E_FAIL; // overflow
        		}
    			dwOffsetCount += m_pCopyright->Count();
    		}
    		// If wave does not have one use collection's
    		else if(SUCCEEDED(hr) && m_pParent && m_pParent->m_pCopyright && (m_pParent->m_pCopyright)->m_pDMCopyright)
    		{
                DWORD dwOriginalSize = dwTotalSize;
    			dwTotalSize += (m_pParent->m_pCopyright)->Size();
        		if (dwTotalSize < dwOriginalSize) {
        		    hr = E_FAIL; // overflow
        		}
    			dwOffsetCount += (m_pParent->m_pCopyright)->Count();
    		}
    
            if(SUCCEEDED(hr)) {
    		    // Calculate space needed for WAVE and WAVEDATA
                DWORD dwOriginalSize = dwTotalSize;
    		    dwTotalSize += CHUNK_ALIGN(sizeof(DMUS_WAVE)) + 
        			CHUNK_ALIGN(sizeof(DMUS_WAVEDATA));
        		if (dwTotalSize < dwOriginalSize) {
        		    hr = E_FAIL; // overflow
        		}
    	    	dwOffsetCount += 2;
            }
    
            if(SUCCEEDED(hr)) {
        		// Calculate space needed for offset table
        		m_cbSizeOffsetTable = dwOffsetCount * sizeof(ULONG);
                DWORD dwOriginalSize = dwTotalSize;
        		dwTotalSize += m_cbSizeOffsetTable;
        		if (dwTotalSize < dwOriginalSize) {
        		    hr = E_FAIL; // overflow
        		}
    		    m_dwDataSizeWrite = m_dwDataSizeRead;
            }

    		// Calculate space needed for wave data
            // We allocated DMUS_MIN_DATA_SIZE worth when we allocated for DMUS_WAVEDATA
    		if(SUCCEEDED(hr) && m_WaveFormatRead.wFormatTag != WAVE_FORMAT_PCM)
    		{
    			hr = CalcDataSize(&m_dwDataSizeWrite);
    		}
    		
    		if(SUCCEEDED(hr) && m_dwDataSizeWrite > DMUS_MIN_DATA_SIZE)
    		{
                DWORD dwOriginalSize = dwTotalSize;
    			dwTotalSize += (m_dwDataSizeWrite - DMUS_MIN_DATA_SIZE);		
        		if (dwTotalSize < dwOriginalSize) {
        		    hr = E_FAIL; // overflow
        		}
    		}

            if(SUCCEEDED(hr)) {
                DWORD dwOriginalSize = dwTotalSize;
                dwTotalSize = CHUNK_ALIGN(dwTotalSize);
        		if (dwTotalSize < dwOriginalSize) {
        		    hr = E_FAIL;
        		}
    	    }
    	}
    	else
    	{
    		hr = E_FAIL;
    	}
    }
	
	// If everything went well, we have the size
	if(SUCCEEDED(hr))
	{
		m_dwSize = dwTotalSize;
		*pdwSize = m_dwSize;
		*pdwSampleSize = m_WaveFormatWrite.wBitsPerSample;
	}

	LeaveCriticalSection(&m_DMWaveCriticalSection);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::Write

HRESULT CWaveObj::Write(void* pvoid)
{
	// Assumption and argument validation
#ifdef DBG
	assert(m_bLoaded);
#endif

	assert(pvoid);

	DWORD dwSize;
	DWORD dwSampleSize;

	HRESULT hr = Size(&dwSize,&dwSampleSize);
	
	if(FAILED(hr))
	{       
		return hr;
	}

	EnterCriticalSection(&m_DMWaveCriticalSection);

	DWORD dwCurIndex = 0;   // Used to determine what index to store offset in Offset Table
	DWORD dwCurOffset = 0;  // Offset relative to beginning of passed in memory

	// Write DMUS_DOWNLOADINFO
	DMUS_DOWNLOADINFO *pDLInfo = (DMUS_DOWNLOADINFO *) pvoid;
	pDLInfo->dwDLType = DMUS_DOWNLOADINFO_WAVE;
	pDLInfo->dwDLId = m_dwId;
	pDLInfo->dwNumOffsetTableEntries = (m_cbSizeOffsetTable/sizeof(DWORD));
	pDLInfo->cbSize = dwSize;
	
	dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

	DMUS_OFFSETTABLE* pDMOffsetTable = (DMUS_OFFSETTABLE *)(((BYTE*)pvoid) + dwCurOffset);
	
	// Increment pass the DMUS_OFFSETTABLE structure; we will fill the other members in later
	dwCurOffset += CHUNK_ALIGN(m_cbSizeOffsetTable);

	// First entry in ulOffsetTable is the first data chunk - the DMUS_WAVE in this case.
	pDMOffsetTable->ulOffsetTable[0] = dwCurOffset;

	dwCurIndex = 2;		// First two items are DMUS_WAVE and DMUS_WAVEDATA;

	DMUS_WAVE* pDMWave = (DMUS_WAVE*)(((BYTE*)pvoid) + dwCurOffset);
	pDMWave->ulWaveDataIdx = 1;		// Point to the DMUS_WAVEDATA chunk.

	dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_WAVE));

	DMUS_WAVEDATA* pDMWaveData = (DMUS_WAVEDATA*)(((BYTE*)pvoid) + dwCurOffset);
	pDMOffsetTable->ulOffsetTable[1] = dwCurOffset;
	
	DWORD dwPos = 0;
	DWORD dwRead = 0;
    m_dwDataSizeAfterACM = m_dwDataSizeWrite;
	hr = GetData(pDMWaveData->byData, m_dwDataSizeWrite, &dwPos, &dwRead);

	pDMWaveData->cbSize = m_dwDataSizeAfterACM; 
	
	if(SUCCEEDED(hr))
	{
		if(m_dwDataSizeWrite < DMUS_MIN_DATA_SIZE)
		{
			dwCurOffset += sizeof(DMUS_WAVEDATA);
		}
		else
		{
			dwCurOffset += sizeof(DMUS_WAVEDATA) + m_dwDataSizeWrite - DMUS_MIN_DATA_SIZE;
		}
		dwCurOffset = CHUNK_ALIGN(dwCurOffset);

		CopyMemory(&(pDMWave->WaveformatEx), &m_WaveFormatWrite, sizeof(WAVEFORMATEX));	

		// Write extension chunks
		CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
		if(pExtChk)
		{
			pDMWave->ulFirstExtCkIdx = dwCurIndex;
		}
		else
		{
			// If no extension chunks set to zero
			pDMWave->ulFirstExtCkIdx = 0;
		}

		DWORD dwCountExtChk = m_dwCountExtChk;
		DWORD dwIndexNextExtChk = 0;
		
		for(; pExtChk && SUCCEEDED(hr); pExtChk = pExtChk->GetNext())
		{
		
			if(dwCountExtChk == 1)
			{
				dwIndexNextExtChk = 0;
			}
			else
			{
				dwIndexNextExtChk = dwCurIndex + 1;
			}
			
			pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
			hr = pExtChk->Write(((BYTE *)pvoid + dwCurOffset), 
								&dwCurOffset,
								dwIndexNextExtChk);
			
			dwCountExtChk--;
			dwCurIndex++;
		}
	}

	if(SUCCEEDED(hr))
	{
		// Write copyright information
		if(m_pCopyright)
		{
			pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
			pDMWave->ulCopyrightIdx = dwCurIndex;
			hr = m_pCopyright->Write(((BYTE *)pvoid + dwCurOffset),
									 &dwCurOffset);
			dwCurIndex++;
		}
		// If instrument does not have one use collection's
		else if(m_pParent && m_pParent->m_pCopyright && (m_pParent->m_pCopyright)->m_pDMCopyright)
		{
			pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
			pDMWave->ulCopyrightIdx = dwCurIndex;
			hr = (m_pParent->m_pCopyright)->Write(((BYTE *)pvoid + dwCurOffset), 
												  &dwCurOffset);
			dwCurIndex++;
		}
		else
		{
			pDMWave->ulCopyrightIdx = 0;
		}
	}

	// We need to fix the offset table entries to be relative to the beginning of the data
	// They are currently relative to the beginning of allocated memory.
/*	if(SUCCEEDED(hr))
	{
		for(DWORD i = 0; i < (m_cbSizeOffsetTable/sizeof(DWORD)) ; i++)
		{
			pDMOffsetTable->ulOffsetTable[i] = 
				pDMOffsetTable->ulOffsetTable[i] - 
				CHUNK_ALIGN(m_cbSizeOffsetTable) - 
				CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));
		}
	}*/

	if(FAILED(hr))
	{
		ZeroMemory(pvoid, dwSize);
	}

	LeaveCriticalSection(&m_DMWaveCriticalSection);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::GetData

HRESULT CWaveObj::GetData(BYTE* pbBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead)
{
	// Argument validation
	assert(pbBuffer);
	assert(pdwPos);

#ifdef DBG
	if(pdwRead)
	{
		assert(pdwRead);
	}
#endif

	if(*pdwPos > (m_dwDataOffset + m_dwDataSizeWrite))
	{
		return DMUS_E_INVALIDPOS;
	}

    assert(m_pParent);

	IStream* pStream = m_pParent->m_pStream;

	// Validation
	assert(pStream);
	
	HRESULT hr = S_OK;

	LARGE_INTEGER li;
	li.QuadPart = m_dwDataOffset + *pdwPos;
	hr = pStream->Seek(li, STREAM_SEEK_SET,NULL);
	if(SUCCEEDED(hr))
	{
		if(m_WaveFormatRead.wFormatTag == WAVE_FORMAT_PCM)
		{
			hr = ReadData(pStream, pbBuffer, dwSize, pdwPos, pdwRead);
		}
		else
		{
			hr = ReadCompressedData(pStream, pbBuffer, dwSize, pdwPos, pdwRead);
		}
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::ReadCompressedData

HRESULT CWaveObj::ReadCompressedData(IStream* pStream, BYTE* pbBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead)
{
	// Argument validation
	assert(pbBuffer);
	assert(pdwPos);
	assert(pStream);

#ifdef DBG
	if(pdwRead)
	{
		assert(pdwRead);
	}
#endif
	HRESULT hr = E_FAIL;

	DWORD dwRead = 0;

	DWORD dwLeftToRead = m_dwDataSizeRead - *pdwPos;

	DWORD dwToRead  = dwLeftToRead < dwSize ? dwLeftToRead : dwSize;

	BYTE *pbCompressedBuffer = new  BYTE[dwToRead];
	
	if(pbCompressedBuffer == NULL)
	{
		return hr;
	}
	
	hr = pStream->Read(pbCompressedBuffer, dwToRead, &dwRead);
	
	DWORD temp = m_dwDataSizeWrite;
	
	if(SUCCEEDED(hr))
	{
		WAVEFORMATEX* pwfx = NULL;
		if(m_WaveFormatRead.wFormatTag == MSAUDIO_FORMAT_TAG || m_WaveFormatRead.wFormatTag == WMAUDIO_FORMAT_TAG)
		{
			if(FAILED(hr = AllocWMAudioFormat(&m_WaveFormatRead, &pwfx)))
			{
				delete[] pbCompressedBuffer;
				return hr;
			}
		}
		else
		{
			pwfx = (WAVEFORMATEX*) new BYTE[sizeof(m_WaveFormatRead) + m_WaveFormatRead.cbSize];
			if(pwfx == NULL)
			{
				delete[] pbCompressedBuffer;
				return E_OUTOFMEMORY;
			}
		
			CopyMemory(pwfx, &m_WaveFormatRead, sizeof(m_WaveFormatRead));
			if(m_pExtractWaveFormatData)
			{
				CopyMemory((((BYTE *)pwfx) + sizeof(m_WaveFormatRead)), m_pExtractWaveFormatData, m_WaveFormatRead.cbSize); 
			}
		}

		assert(pwfx);

		hr = DecompressWave(pwfx, 
							&m_WaveFormatWrite, 
							pbCompressedBuffer,
							pbBuffer,
							dwToRead, 
							temp);

		if(SUCCEEDED(hr))
		{
			*pdwPos += dwRead;
		}

		if(pdwRead)
		{
			if(SUCCEEDED(hr))
			{
				*pdwRead = dwRead;
			}
			else
			{
				*pdwRead = 0;
			}
		}

		if(pwfx)
		{
			delete[] pwfx;
		}
	}
	else
	{
		if(pdwRead)
		{
			*pdwRead = 0;
		}
	}

	delete[] pbCompressedBuffer;

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::ReadData

HRESULT CWaveObj::ReadData(IStream* pStream, BYTE* pbBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead)
{
	// Argument validation
	assert(pbBuffer);
	assert(pdwPos);
	assert(pStream);

#ifdef DBG
	if(pdwRead)
	{
		assert(pdwRead);
	}
#endif

	HRESULT hr = E_FAIL;

	DWORD dwRead = 0;

	DWORD dwLeftToRead = m_dwDataSizeRead - *pdwPos;

	DWORD dwToRead  = dwLeftToRead < dwSize ? dwLeftToRead : dwSize;

	hr = pStream->Read(pbBuffer, dwToRead, &dwRead);

	if(SUCCEEDED(hr))
	{
		if(pdwRead)
		{
			*pdwRead = dwRead;
		}

		*pdwPos += dwRead;
	}
	else
	{
		if(pdwRead)
		{
			*pdwRead = 0;
		}
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::CalcDataSize

HRESULT CWaveObj::CalcDataSize(DWORD *pdwSize)
{
	assert(pdwSize);

    WAVEFORMATEX *pwfx = NULL;
    if(m_WaveFormatRead.wFormatTag == MSAUDIO_FORMAT_TAG || m_WaveFormatRead.wFormatTag == WMAUDIO_FORMAT_TAG)
	{
		if(FAILED(AllocWMAudioFormat(&m_WaveFormatRead, &pwfx)))
		{
			return E_FAIL;
		}
	}
    else
    {
	    pwfx = (WAVEFORMATEX *) new BYTE[sizeof(m_WaveFormatRead) + m_WaveFormatRead.cbSize];

	    if(pwfx == NULL)
	    {
		    *pdwSize = 0;		
		    return E_FAIL;
	    }
	    
	    CopyMemory(pwfx, &m_WaveFormatRead, sizeof(m_WaveFormatRead));
	    if(m_pExtractWaveFormatData)
	    {
		    CopyMemory((((BYTE *)pwfx) + sizeof(m_WaveFormatRead)), m_pExtractWaveFormatData, m_WaveFormatRead.cbSize); 
	    }
    }

    assert(pwfx);

	HACMSTREAM has;
	MMRESULT mmr = acmStreamOpen(&has, NULL, pwfx, &m_WaveFormatWrite, NULL, 0, 0, 0);
	
	if(mmr != MMSYSERR_NOERROR)
	{
		*pdwSize = 0;
		delete [] (BYTE *)pwfx;
		return E_FAIL;	
	}

	mmr = acmStreamSize(has, m_dwDataSizeRead, pdwSize, ACM_STREAMSIZEF_SOURCE);

	if(mmr != MMSYSERR_NOERROR || *pdwSize == 0)
	{
		*pdwSize = 0;
		acmStreamClose(has, 0);
		delete [] (BYTE *)pwfx;
		return E_FAIL;	
	}

    // Check if we have to throw away some silent samples from the beginning
    //*pdwSize -= m_dwDecompressedStart;

	mmr = acmStreamClose(has, 0);

	if(mmr != MMSYSERR_NOERROR)
	{
		*pdwSize = 0;
		delete [] (BYTE *)pwfx;
		return E_FAIL;
	}

	delete [] (BYTE *)pwfx;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::CanDecompress

HRESULT CWaveObj::CanDecompress()
{
	HRESULT hr = E_FAIL;

	ZeroMemory(&m_WaveFormatWrite, sizeof(m_WaveFormatWrite));
	m_WaveFormatWrite.wFormatTag = WAVE_FORMAT_PCM;
	m_WaveFormatWrite.nChannels = 1;
	m_WaveFormatWrite.wBitsPerSample = 16;

	WAVEFORMATEX* pwfx = NULL; 
	
	if(SUCCEEDED(hr = AllocWMAudioFormat(&m_WaveFormatRead, &pwfx)))
	{
		pwfx = (WAVEFORMATEX *) new BYTE[sizeof(m_WaveFormatRead) + m_WaveFormatRead.cbSize];
		if(pwfx == NULL)
		{
			return E_OUTOFMEMORY;
		}
		
		CopyMemory(pwfx, &m_WaveFormatRead, sizeof(m_WaveFormatRead));
		if(m_pExtractWaveFormatData)
		{
			CopyMemory((((BYTE *)pwfx) + sizeof(m_WaveFormatRead)), m_pExtractWaveFormatData, m_WaveFormatRead.cbSize); 
		}
	}
	else
	{
	    pwfx = &m_WaveFormatRead;
	}

	assert(pwfx);

	if(m_fReadDecompressionFormat == TRUE)
    {
        CopyMemory(&m_WaveFormatWrite, &m_WaveFormatDecompress, sizeof(m_WaveFormatDecompress));
        hr = S_OK;
    }
    else
    {
		// We first try to find a driver that can support wBitsPerSample == 16 if we can not find one 
		// then we try to find a driver that can support wBitsPerSample == 8. If we do not find either we 
		// return an error since we can not decompress.
		MMRESULT mmr = acmFormatSuggest(NULL,
										pwfx,
										&m_WaveFormatWrite,
										sizeof(WAVEFORMATEX),
										ACM_FORMATSUGGESTF_NCHANNELS 
										| ACM_FORMATSUGGESTF_WBITSPERSAMPLE 
										| ACM_FORMATSUGGESTF_WFORMATTAG);


		if(mmr != MMSYSERR_NOERROR)
		{
			m_WaveFormatWrite.wBitsPerSample = 8;
			
			mmr = acmFormatSuggest(NULL,
								   pwfx,
								   &m_WaveFormatWrite,
								   sizeof(WAVEFORMATEX),
								   ACM_FORMATSUGGESTF_NCHANNELS |
								   ACM_FORMATSUGGESTF_WBITSPERSAMPLE |
								   ACM_FORMATSUGGESTF_WFORMATTAG);
		}

		if(mmr == MMSYSERR_NOERROR) 
		{
			hr = S_OK;
		}
	}

	if (pwfx && pwfx != &m_WaveFormatRead)
	{
		delete[] (BYTE*)pwfx;
	}

	return hr; 
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::DecompressWave

HRESULT CWaveObj::DecompressWave(WAVEFORMATEX *pwfxSrc, 
								 WAVEFORMATEX *pwfxDst, 
								 BYTE *pbCompressedBuffer,
								 BYTE *pbDecompressBuffer,
								 DWORD dwSizeCompressed, 
								 DWORD dwSizeDecompressed)
{
	// We're just fooling the compressor!
    WORD wOriginalSampleRate = (WORD)pwfxDst->nSamplesPerSec;
    if(pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
    {
        pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
        pwfxDst->nAvgBytesPerSec = pwfxDst->nSamplesPerSec * pwfxDst->nBlockAlign;
    }

	HACMSTREAM has;
	MMRESULT mmr = acmStreamOpen(&has, NULL, pwfxSrc, pwfxDst, NULL, 0, 0, 0);
	
	if(mmr != MMSYSERR_NOERROR)
	{
		return E_FAIL;	
	}

    BYTE* pbData = NULL;
    if(m_dwDecompressedStart > 0)
    {
        pbData = new BYTE[dwSizeDecompressed];
        if(pbData == NULL)
        {
            return E_OUTOFMEMORY;
        }

        ZeroMemory(pbData, dwSizeCompressed);
    }
    else
    {
        pbData = pbDecompressBuffer;
    }


	ACMSTREAMHEADER ashdr;
	ZeroMemory(&ashdr, sizeof(ashdr));
	ashdr.cbStruct = sizeof(ashdr);
	ashdr.pbSrc = pbCompressedBuffer;
	ashdr.cbSrcLength = dwSizeCompressed;
	ashdr.cbDstLength = dwSizeDecompressed;
	ashdr.pbDst = pbData;
	
	mmr = acmStreamPrepareHeader(has, &ashdr, 0);
	
	if(mmr != MMSYSERR_NOERROR || (ashdr.fdwStatus & ACMSTREAMHEADER_STATUSF_PREPARED) == 0)
	{
		acmStreamClose(has, 0);
		return E_FAIL;	
	}

	mmr = acmStreamConvert(has, &ashdr, 0);

	DWORD dwTemp = ashdr.cbDstLength;
    m_dwDataSizeAfterACM = ashdr.cbDstLengthUsed;

	// Need to reset or acmStreamUnprepareHeader will return with an error
	ashdr.cbSrcLength = dwSizeCompressed;
	ashdr.cbDstLength = dwSizeDecompressed;

	if(mmr != MMSYSERR_NOERROR)
	{
		acmStreamUnprepareHeader(has, &ashdr, 0);
		acmStreamClose(has, 0);
		return E_FAIL;	
	}

	mmr = acmStreamUnprepareHeader(has, &ashdr, 0);
	if(mmr != MMSYSERR_NOERROR)
	{
		acmStreamClose(has, 0);		
		return E_FAIL;	
	}
	
	m_dwDataSizeWrite = dwTemp;

	mmr = acmStreamClose(has, 0);

    // Do we have to throw away any silent samples from the beginning?
    if(m_dwDecompressedStart > 0)
    {
        DWORD dwStartByte = m_dwDecompressedStart * (m_WaveFormatDecompress.wBitsPerSample / 8);
        assert(dwSizeDecompressed > dwStartByte);
        DWORD dwBytesToCopy = dwSizeDecompressed - dwStartByte;
        CopyMemory(pbDecompressBuffer, pbData + dwStartByte, dwBytesToCopy);

        m_dwDataSizeWrite = dwBytesToCopy;
        m_dwDataSizeAfterACM = m_dwDataSizeWrite;

        delete[] pbData;
    }

	return mmr == MMSYSERR_NOERROR ? S_OK : E_FAIL;
}


HRESULT CWaveObj::AllocWMAudioFormat(const WAVEFORMATEX* pwfxSrc, WAVEFORMATEX** ppwfxWMAudioWave)
{
	assert(pwfxSrc);
	if(pwfxSrc == NULL)
	{
		return E_POINTER;
	}

	if(pwfxSrc->wFormatTag != 352 && pwfxSrc->wFormatTag != 353)
	{
		return E_FAIL;
	}

	// The new WAVEFORMATEX growsby the length of the key strings
	int nKeyLength = sizeof(MSAUDIO_DEC_KEY);
	DWORD nWaveFormatSize = sizeof(WAVEFORMATEX) + pwfxSrc->cbSize + nKeyLength;

	WAVEFORMATEX* pwfxTemp = (WAVEFORMATEX*)(new BYTE[nWaveFormatSize]);
    if(pwfxTemp == NULL)
    {
        return E_OUTOFMEMORY;
    }
	
	ZeroMemory(pwfxTemp, nWaveFormatSize);

	// Copy the old values
	CopyMemory(pwfxTemp, pwfxSrc, sizeof(WAVEFORMATEX));
	CopyMemory((((BYTE*)pwfxTemp) + sizeof(WAVEFORMATEX)), m_pExtractWaveFormatData, pwfxSrc->cbSize); 

	// Copy the key string 
	strcpy((char*)(pwfxTemp) + sizeof(WAVEFORMATEX) + pwfxTemp->cbSize, MSAUDIO_DEC_KEY);
	pwfxTemp->cbSize += sizeof(MSAUDIO_DEC_KEY);

	*ppwfxWMAudioWave = pwfxTemp;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmvoice.h ===
//
// dmvoice.h
// 
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Support for IDirectMusicVoice
//
//
#ifndef _DMVOICE_H_
#define _DMVOICE_H_

class CDirectMusicVoice;
class CVSTClient;

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoiceList
//
// Type-safe wrapper for AList of CDirectMusicVoice's
//
class CDirectMusicVoiceList : public AList
{
public:
    inline CDirectMusicVoice *GetHead();
    inline void AddTail(CDirectMusicVoice *pdmv);
    inline void Remove(CDirectMusicVoice *pdmv);
};

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClientList
//
// Type-safe wrapper for AList of CVSTClient's
//
class CVSTClientList : public AList
{
public:
    inline CVSTClient *GetHead();
    inline void AddTail(CVSTClient *pc);
    inline void Remove(CVSTClient *pc);
};

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClient
//
// Tracks one client (port) of the voice service thread.
//
class CVSTClient : public AListItem
{
public:
    // NOTE: No reference count to avoid circular count
    // Port will free its client before shutdown
    //
    CVSTClient(IDirectMusicPort *pPort);
    ~CVSTClient();
    
    HRESULT BuildVoiceIdList();
    
    HRESULT GetVoiceState(DMUS_VOICE_STATE **ppsp);
    
    inline CDirectMusicVoice *GetVoiceListHead() 
    { return static_cast<CDirectMusicVoice*>(m_VoiceList.GetHead()); }
    
    inline void AddTail(CDirectMusicVoice *pVoice)
    { m_VoiceList.AddTail(pVoice); }
    
    inline void Remove(CDirectMusicVoice *pVoice)
    { m_VoiceList.Remove(pVoice); }
    
    inline IDirectMusicPort *GetPort() const 
    { return m_pPort; }
    
    inline CVSTClient *GetNext()
    { return static_cast<CVSTClient*>(AListItem::GetNext()); }
    
private:
    IDirectMusicPort       *m_pPort;            // Client pointer
    CDirectMusicVoiceList   m_VoiceList;        // List of playing voices
    DWORD                  *m_pdwVoiceIds;      // Voice IDs of this client
    DMUS_VOICE_STATE       *m_pspVoices;        // Queried sample position
    LONG                    m_cVoiceIds;        // How many voice ID's
    LONG                    m_cVoiceIdsAlloc;   // How many slots allocated
    
    static const UINT       m_cAllocSize;       // Allocation block size
};

// Base class for IDirectMusicVoice. Contains the functionality for
// being in the voice service list.
//
class CDirectMusicVoice : public IDirectMusicVoiceP, public AListItem
{
public:
   
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    // IDirectMusicVoice
    //
    STDMETHODIMP Play
        (THIS_
         REFERENCE_TIME rtStart,                // Time to play
         LONG prPitch,                          // Initial pitch
         LONG veVolume                          // Initial volume
        );
    
    STDMETHODIMP Stop
        (THIS_
          REFERENCE_TIME rtStop                 // When to stop
        );
    
    // Class
    //        
    CDirectMusicVoice(
        CDirectMusicPortDownload *pPortDL,
        IDirectSoundDownloadedWaveP *pWave,
        DWORD dwChannel,
        DWORD dwChannelGroup,
        REFERENCE_TIME rtStart,
        REFERENCE_TIME rtReadAhead,
        SAMPLE_TIME stLoopStart,
        SAMPLE_TIME stLoopEnd);    
    ~CDirectMusicVoice();        

    HRESULT Init();        
    
    inline DWORD GetVoiceId() const
    { return m_dwVoiceId; } 
        
    inline CDirectMusicVoice *GetNext() 
    { return static_cast<CDirectMusicVoice*>(AListItem::GetNext()); }
    
    
    static DWORD m_dwNextVoiceId;                      // Global: Next voice ID
    
    static inline DWORD AllocVoiceId(DWORD nIDs)
    {
        EnterCriticalSection(&m_csVST);
            DWORD dwID = m_dwNextVoiceId;
            m_dwNextVoiceId += nIDs;
        LeaveCriticalSection(&m_csVST);

        return dwID;
    }
    
    static HRESULT StartVoiceServiceThread(IDirectMusicPort *pPort);
    static HRESULT StopVoiceServiceThread(IDirectMusicPort *pPort);
    static inline void UpdateVoiceServiceThread()
    { assert(m_hVSTWakeUp); SetEvent(m_hVSTWakeUp); }

private:
    LONG                        m_cRef;             // Reference count
    DWORD                       m_dwVoiceId;        // Voice id
    DWORD                       m_dwDLId;           // Download ID to trigger
    IDirectMusicPort            *m_pPort;           // What port attached to
    CDirectMusicPortDownload    *m_pPortDL;         //  and its download
    IDirectMusicPortPrivate     *m_pPortPrivate;    //  its private interface
    IDirectSoundDownloadedWaveP *m_pDSDLWave;       // Downloaded wave
    DWORD                       m_dwChannel;        // Channel and channel group
    DWORD                       m_dwChannelGroup;   //  to play on
    SAMPLE_TIME                 m_stStart;          // Starting point
    SAMPLE_TIME                 m_stReadAhead;      // Read ahead (buffer length)
    DWORD                       m_msReadAhead;      // Read ahead in milliseconds
    SAMPLE_TIME                 m_stLoopStart;      // Loop points
    SAMPLE_TIME                 m_stLoopEnd;

    CDirectSoundWaveDownload    *m_pDSWD;           // Download instance    
    DWORD                       m_nChannels;        // Channels in wave
    bool                        m_fIsPlaying;       // Is this voice playing?       
                                                    // (streaming voices)
    bool                        m_fRunning;         // Has streamed voice started playing?
    bool                        m_fIsStreaming;     // Cached from owning wave                                                    
    
    // Voice service thread
    //
    friend DWORD WINAPI VoiceServiceThreadThk(LPVOID);
    static void VoiceServiceThread();
    
    static LONG                 m_cRefVST;          // Voice Service Thread 
                                                    // refcount (1 per open port)
    static HANDLE               m_hVSTWakeUp;       // Wake up for any reason
    static HANDLE               m_hVSTThread;       // Thread handle
    static DWORD                m_dwVSTThreadId;    //  and id                                                        
    static bool                 m_fVSTStopping;     // Time to kill the VST
    static CVSTClientList       m_ClientList;       // List of open ports which
                                                    //  want VST services
    
public:    
    static CRITICAL_SECTION     m_csVST;            // VST Critical section
    
private:
    // Override GetNext list operator
    //    
    static void ServiceVoiceQueue(bool *pfRecalcTimeout);
    static DWORD VoiceQueueMinReadahead();
    static CVSTClient *FindClientByPort(IDirectMusicPort *pPort);
};

inline CDirectMusicVoice *CDirectMusicVoiceList::GetHead()
{ return (CDirectMusicVoice*)AList::GetHead(); }

inline void CDirectMusicVoiceList::AddTail(CDirectMusicVoice *pdmv)
{ AList::AddTail(static_cast<AListItem*>(pdmv)); }

inline void CDirectMusicVoiceList::Remove(CDirectMusicVoice *pdmv)
{ AList::Remove(static_cast<AListItem*>(pdmv)); }

inline CVSTClient *CVSTClientList::GetHead()
{ return static_cast<CVSTClient*>(AList::GetHead()); }

inline void CVSTClientList::AddTail(CVSTClient *pc)
{ AList::AddTail(static_cast<AListItem*>(pc)); }

inline void CVSTClientList::Remove(CVSTClient *pc)
{ AList::Remove(static_cast<AListItem*>(pc)); }

#endif // _DMVOICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dsutil.cpp ===
//
// dsutil.cpp
// 
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Note: Utility routines for DirectSound
//
// @doc EXTERNAL
//
//

// Be careful what headers get included here. We have to make sure we get
// the DSound IKsPropertySet definition rather than the incorrect Ks one.
//
#include <windows.h>

#include <objbase.h>
#include <initguid.h>       // Bring in guids from dsprv.h
#include <mmsystem.h>
#include <dsound.h>
#include <dsprv.h>

class CDirectSoundPrivate
{
public:
    CDirectSoundPrivate();
    ~CDirectSoundPrivate();
    HRESULT Init();

    // IKsPropertySet methods
    //
    HRESULT Get(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG, PULONG);
    HRESULT Set(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);
    HRESULT QuerySupport(REFGUID, ULONG, PULONG);

private:
    HINSTANCE m_hDSound;
    IKsPropertySet *m_pKsPropertySet;
};

CDirectSoundPrivate::CDirectSoundPrivate()
{
    m_hDSound = NULL;
    m_pKsPropertySet = NULL;
}

typedef HRESULT (*PDLLGETCLASSOBJECT)(const CLSID &clsid, const IID &iid, void **ppv);
HRESULT CDirectSoundPrivate::Init()
{
    PDLLGETCLASSOBJECT pDllGetClassObject;
    IClassFactory *pClassFactory;
    HRESULT hr;

    m_hDSound = LoadLibrary("dsound.dll");
    if (m_hDSound == NULL)
    {
        return E_NOINTERFACE;
    }

    pDllGetClassObject = (PDLLGETCLASSOBJECT)GetProcAddress(m_hDSound, "DllGetClassObject");
    if (pDllGetClassObject == NULL)
    {
        return E_NOINTERFACE;
    }

    hr = (*pDllGetClassObject)(CLSID_DirectSoundPrivate, 
                               IID_IClassFactory,
                               (void**)&pClassFactory);
    if (FAILED(hr)) 
    {
        return hr;
    }
    
    hr = pClassFactory->CreateInstance(NULL, IID_IKsPropertySet, (void**)&m_pKsPropertySet);
    pClassFactory->Release();

    return hr;
}

CDirectSoundPrivate::~CDirectSoundPrivate()
{
    if (m_pKsPropertySet) {
        m_pKsPropertySet->Release();
        m_pKsPropertySet = NULL;
    }

    if (m_hDSound) 
    {
        FreeLibrary(m_hDSound);
        m_hDSound = NULL;
    }
}

HRESULT CDirectSoundPrivate::Get(REFGUID rguidSet, ULONG ulItem, LPVOID pvInstance, ULONG cbInstance, LPVOID pvData, ULONG cbData, PULONG pcbData)
{
    if (m_pKsPropertySet) 
    {
        return m_pKsPropertySet->Get(rguidSet, ulItem, pvInstance, cbInstance, pvData, cbData, pcbData);
    }

    return E_NOINTERFACE;
}

HRESULT CDirectSoundPrivate::Set(REFGUID rguidSet, ULONG ulItem, LPVOID pvInstance, ULONG cbInstance, LPVOID pvData, ULONG cbData)
{
    if (m_pKsPropertySet) 
    {
        return m_pKsPropertySet->Set(rguidSet, ulItem, pvInstance, cbInstance, pvData, cbData);
    }

    return E_NOINTERFACE;
}

HRESULT CDirectSoundPrivate::QuerySupport(REFGUID rguidSet, ULONG ulItem, PULONG pulSupport)
{
    if (m_pKsPropertySet) 
    {
        return m_pKsPropertySet->QuerySupport(rguidSet, ulItem, pulSupport);
    }

    return E_NOINTERFACE;
}


// DirectSoundDevice
//
// Given an LPDIRECTSOUND, determine the device interface name associated with
// it.
//
HRESULT DirectSoundDevice(
    LPDIRECTSOUND                                   pDirectSound,
    LPSTR                                           *pstrInterface)
{
    HRESULT                                         hr;
    DSBUFFERDESC                                    BufferDesc;
    LPDIRECTSOUNDBUFFER                             pBuffer = NULL;
    DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA      DeviceId;
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA   DeviceDesc;
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA   *pDeviceDesc = NULL;
    ULONG                                           cb;
	PCMWAVEFORMAT                                   wfx;

    CDirectSoundPrivate                             DSPriv;
    
    hr = DSPriv.Init();

    if (FAILED(hr)) 
    {
        return hr;
    }


	ZeroMemory(&wfx, sizeof(wfx));
	wfx.wf.wFormatTag = WAVE_FORMAT_PCM;
	wfx.wf.nChannels = 1;
	wfx.wf.nSamplesPerSec = 22050;
	wfx.wf.nAvgBytesPerSec = 22050;
	wfx.wf.nBlockAlign = 1;
	wfx.wBitsPerSample = 8;

    ZeroMemory(&BufferDesc, sizeof(BufferDesc));
    BufferDesc.dwSize  = sizeof(BufferDesc);
    BufferDesc.dwBufferBytes = 32768;
    BufferDesc.lpwfxFormat = (LPWAVEFORMATEX)&wfx;
    
    hr = pDirectSound->CreateSoundBuffer(&BufferDesc, &pBuffer, NULL);
    if (FAILED(hr)) 
    {
        pBuffer = NULL;
        goto Cleanup;
    }
    
    DeviceId.Buffer = pBuffer;
    hr = DSPriv.Get(DSPROPSETID_DirectSoundBuffer,
                    DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID,
                    NULL,
                    0,
                    &DeviceId,
                    sizeof(DeviceId),
                    &cb);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    memset(&DeviceDesc, 0, sizeof(DeviceDesc));
    DeviceDesc.DeviceId = DeviceId.DeviceId;
    hr = DSPriv.Get(DSPROPSETID_DirectSoundDevice,
                    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
                    NULL,
                    0,
                    &DeviceDesc,
                    sizeof(DeviceDesc),
                    &cb);
    if (FAILED(hr)) 
    {
        goto Cleanup;
    } 

	pDeviceDesc = &DeviceDesc;
    if (cb > sizeof(DeviceDesc)) 
    {
        pDeviceDesc = (DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA*) new BYTE[cb];
        if (!pDeviceDesc)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        memset(pDeviceDesc, 0, cb);

        CopyMemory(pDeviceDesc, &DeviceDesc, sizeof(DeviceDesc));

        hr = DSPriv.Get(DSPROPSETID_DirectSoundDevice,
                        DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
                        NULL,
                        0,
                        pDeviceDesc,
                        cb,
                        &cb);
    }

    if (pDeviceDesc->Interface == NULL)
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    cb = strlen(pDeviceDesc->Interface);
    
    *pstrInterface = new char[cb + 1];
    if (!*pstrInterface)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    strcpy(*pstrInterface, pDeviceDesc->Interface);

Cleanup:
    if (pBuffer)        pBuffer->Release();
    if (pDeviceDesc && pDeviceDesc != &DeviceDesc)    
		delete[] (BYTE*)pDeviceDesc;

    return hr;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dmusic.cpp ===
//
// DMusic.CPP
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//
// @module DirectMusic | DirectMusic core services
//
// Provides the code DirectMusic services for delivering time-stamped data and managing
// DLS collections.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#define INITGUID
#include <objbase.h>
#include "debug.h"
#include <mmsystem.h>
#include "dlsstrm.h"
#include <regstr.h>
#include "oledll.h"

#include "dmusicp.h"
#include "..\dmusic32\dmusic32.h"
#include "debug.h"
#include "dmdlinst.h"
#include "dminstru.h"
#include "validate.h"
#include "dmusprop.h"

#include <string.h>

#ifdef UNICODE
#error This module cannot compile with UNICODE defined.
#endif



// @globalv:(INTERNAL) Registry key for description of synth
//
const char cszDescription[] = "Description";
const WCHAR cwszDescription[] = L"Description";

// @globalv:(INTERNAL) Format string for output ports under the legacy subtree
const char cszPortOut[] = "%s\\Out";
const WCHAR cwszPortOut[] = L"%s\\Out";

// @globalv:(INTERNAL) Format string for input ports under the legacy subtree
const char cszPortIn[] = "%s\\In";
const WCHAR cwszPortIn[] = L"%s\\In";

// @globalv:(INTERNAL) Key for the DirectMusic GUID anywhere in the registry
const char cszGUID[]   = "DMPortGUID";

// @globalv:(INTERNAL) Value for storing default output port
//
const char cszDefaultOutputPort[] = "DefaultOutputPort";

// @globalv:(INTERNAL) Value for turning off hw acceleration
//
const char cszDisableHWAcceleration[] = "DisableHWAcceleration";

//
//
const char cszDefaultToKernelSynth[] = "DefaultToMsKernelSynth";

// @globalv:(INTERNAL) Filename of the sysaudio device from Ring 3
const char cszSADName[] = "\\\\.\\sysaudio";

// @globalv:(INTERNAL) Entry point into Dmusic32.dll for enumeration of legacy devices
const char cszEnumLegacyDevices[] = "EnumLegacyDevices";

// @globalv:(INTERNAL) Entry point into Dmusic32.dll for creation of emulated port
const char cszCreateEmulatePort[] = "CreateCDirectMusicEmulatePort";

const GUID guidZero = {0};
static const int CLSID_STRING_SIZE = 39;

LONG CDirectMusic::m_lInstanceCount = 0;


// @doc EXTERNAL



// @mfunc:(INTERNAL) Constructor for <c CDirectMusic>
//
// @comm Just increments the global count of components.
//
CDirectMusic::CDirectMusic() :
    m_cRef(1),
    m_fDirectSound(0),
    m_cRefDirectSound(0),
    m_pDirectSound(NULL),
    m_fCreatedDirectSound(FALSE),
    m_nVersion(7)
{
    TraceI(2, "CDirectMusic::CDirectMusic()\n");
    InterlockedIncrement(&g_cComponent);
    InterlockedIncrement(&m_lInstanceCount);
}


// @mfunc:(INTERNAL) Destructor for <c CDirectMusic>
//
// @comm Decrements the global component counter and frees the port list.
//
CDirectMusic::~CDirectMusic()
{
    CNode<PORTENTRY *> *pNode;
    CNode<PORTENTRY *> *pNext;
    CNode<PORTDEST *> *pDest;
    CNode<PORTDEST *> *pNextDest;

    TraceI(2, "CDirectMusic::~CDirectMusic\n");

    InterlockedDecrement(&g_cComponent);
    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNext)
    {
        for (pDest = pNode->data->lstDestinations.GetListHead(); pDest; pDest = pNextDest)
        {
            pNextDest = pDest->pNext;
            delete[] pDest->data->pstrInstanceId;
            delete pDest->data;

            pNode->data->lstDestinations.RemoveNodeFromList(pDest);
            pDest = pNextDest;
        }

        pNext = pNode->pNext;
        delete pNode->data;
        m_lstDevices.RemoveNodeFromList(pNode);
    }

    /*CNode<IDirectMusicPort *> *pOpenNode;
    CNode<IDirectMusicPort *> *pOpenNext;

    // HACK HACK Close unreleased ports at exit HACK HACK
    //
    for (pOpenNode = m_lstOpenPorts.GetListHead(); pOpenNode; pOpenNode = pOpenNext)
    {
        pOpenNext = pOpenNode->pNext;
        IDirectMusicPort *pPort = pOpenNode->data;

        IDirectMusicPortPrivate *pPrivate;
        HRESULT hr = pPort->QueryInterface(IID_IDirectMusicPortPrivate, (LPVOID*)&pPrivate);

        if (SUCCEEDED(hr))
        {
            pPrivate->Close();
            pPrivate->Release();
        }

        m_lstOpenPorts.RemoveNodeFromList(pOpenNode);
    }*/

    if (m_pMasterClock)
    {
        m_pMasterClock->ReleasePrivate();
    }

    if (m_pDirectSound)
    {
        m_pDirectSound->Release();
    }

    if (InterlockedDecrement(&m_lInstanceCount) == 0 && g_hModuleKsUser)
    {
        HMODULE h = g_hModuleKsUser;
        g_hModuleKsUser  = NULL;

        FreeLibrary(h);
    }
}

// CDirectMusic::QueryInterface
//
//
STDMETHODIMP CDirectMusic::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(IDirectMusic::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusic || iid == IID_IDirectMusic2)
    {
        *ppv = static_cast<IDirectMusic*>(this);
    }
    else if (iid == IID_IDirectMusic8)
    {
        *ppv = static_cast<IDirectMusic8*>(this);
        m_nVersion = 8;
    }
    else if (iid == IID_IDirectMusicPortNotify)
    {
        *ppv = static_cast<IDirectMusicPortNotify*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// CDirectMusic::AddRef
//
//
STDMETHODIMP_(ULONG) CDirectMusic::AddRef()
{
//    DebugBreak();
    return InterlockedIncrement(&m_cRef);
}

// CDirectMusic::Release
//
//
STDMETHODIMP_(ULONG) CDirectMusic::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        if (m_lstOpenPorts.GetNodeCount() == 0)
        {
            delete this;
            return 0;
        }
    }

    return m_cRef;
}


// @mfunc:(INTERNAL) Initialization.
//
// Enumerate the WDM and legacy devices into the port list.
//
// @rdesc Returns one of the following:
//
// @flag S_OK | On success
// @flag E_NOINTERFACE | If there were no ports detected
// @flag E_OUTOFMEMORY | If there was insufficient memory to create the list
//
HRESULT CDirectMusic::Init()
{
    HRESULT hr = S_OK;

    m_pMasterClock = new CMasterClock;
    if (m_pMasterClock == NULL)
    {
        return E_OUTOFMEMORY;
    }

    m_pMasterClock->AddRefPrivate();

    hr = m_pMasterClock->Init();
    if (FAILED(hr))
    {
        TraceI(0, "Could not initialize clock stuff [%08X]\n", hr);
        return hr;
    }

    // Cache default port behavior
    //
    m_fDefaultToKernelSwSynth = FALSE;
    m_fDisableHWAcceleration = FALSE;

    HKEY hk;
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      REGSTR_PATH_DIRECTMUSIC,
                      0L,
                      KEY_READ,
                      &hk))
    {
        DWORD dw;
        DWORD dwValue;

        DWORD cb = sizeof(dwValue);

        if (!RegQueryValueExA(
            hk,
            cszDefaultToKernelSynth,
            NULL,
            &dw,
            (LPBYTE)&dwValue,
            &cb))
        {
            if (dwValue)
            {
                Trace(0, "Default port set to Microsoft kernel synth by registry key\n");
                m_fDefaultToKernelSwSynth = TRUE;
            }
        }

        cb = sizeof(dwValue);

        if (!RegQueryValueExA(
            hk,
            cszDisableHWAcceleration,
            NULL,
            &dw,
            (LPBYTE)&dwValue,
            &cb))
        {
            if (dwValue)
            {
                Trace(0, "Hardware acceleration and kernel synthesizers disabled by registry key\n");
                m_fDisableHWAcceleration = TRUE;
            }
        }

        RegCloseKey(hk);
    }


    return hr == S_OK ? S_OK : E_NOINTERFACE;
}

// @mfunc:(INTERNAL) Update the port list.
//
// Enumerate the WDM and legacy devices into the port list.
//
// @rdesc Returns one of the following:
//
// @flag S_OK | On success
// @flag S_FALSE | If there were no ports detected
// @flag E_OUTOFMEMORY | If there was insufficient memory to create the list
//
HRESULT CDirectMusic::UpdatePortList()
{
    CNode<PORTENTRY *> *pNode;
    CNode<PORTENTRY *> *pNext;
    CNode<PORTDEST *> *pDest;
    CNode<PORTDEST *> *pNextDest;
    HRESULT hr;

    TraceI(2, "UpdatePortList()\n");

    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNode->pNext)
    {
        pNode->data->fIsValid = FALSE;
    }

    // Only look for WDM devices if KS is around.
    //
    if (LoadKsUser())
    {
        TraceI(2, "Adding WDM devices\n");

        hr = AddWDMDevices();
        if (!SUCCEEDED(hr))
        {
            return hr;
        }
    }

    hr = AddLegacyDevices();
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    hr = AddSoftwareSynths();
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNext)
    {
        pNext = pNode->pNext;

        // Validate data
        if(pNode->data == NULL)
        {
            return DMUS_E_NOT_INIT;
        }

        if (!pNode->data->fIsValid)
        {
            for (pDest = pNode->data->lstDestinations.GetListHead(); pDest; pDest = pNextDest)
            {
                pNextDest = pDest->pNext;

                if(pNextDest == NULL)
                {
                    return DMUS_E_NOT_INIT;
                }

                if(pNextDest->data == NULL)
                {
                    return DMUS_E_NOT_INIT;
                }

                delete[] pNextDest->data->pstrInstanceId;
                delete pNextDest->data;

                pNode->data->lstDestinations.RemoveNodeFromList(pDest);
                pDest = pNextDest;
            }

            delete pNode->data;
            m_lstDevices.RemoveNodeFromList(pNode);
        }
    }

    TraceI(1, "UpdatePortList() end: %d devices\n", m_lstDevices.GetNodeCount());

    return m_lstDevices.GetNodeCount() ? S_OK : S_FALSE;
}


// @mfunc:(INTERNAL) Update the port list with WDM devices enumerated via the
// System Audio Device (SAD).
//
// @rdesc Returns one of the following:
//
// @flag S_OK | On success
// @flag S_FALSE | If there were no devices found
// @flag E_OUTOFMEMORY | If there was insufficient memory to build the port list
//
// @comm This must be implemented.
//
const GUID guidMusicFormat = KSDATAFORMAT_TYPE_MUSIC;
const GUID guidMIDIFormat  = KSDATAFORMAT_SUBTYPE_DIRECTMUSIC;

HRESULT CDirectMusic::AddWDMDevices()
{
#ifdef USE_WDM_DRIVERS
    return EnumerateWDMDevices(this);
#else
    return S_FALSE;
#endif
}

static HRESULT AddDeviceCallback(
    VOID *pInstance,           // @parm 'this' pointer
    DMUS_PORTCAPS &dmpc,       // @parm The already filled in portcaps
    PORTTYPE pt,               // @parm The port type
    int idxDev,                // @parm The WinMM or SysAudio device ID of this driver
    int idxPin,                // @parm The Pin ID of the device or -1 if the device is a legacy device
    int idxNode,               // @parm The Node ID of the synthesizer node; ignored if this is a legacy device
    HKEY hkPortsRoot)          // @parm Where port information is stored in the registry
{
    CDirectMusic *pdm = (CDirectMusic*)pInstance;

    //This should never be called to add a WDM device
    assert(pt != ptWDMDevice);

    return pdm->AddDevice(dmpc,
                          pt,
                          idxDev,
                          idxPin,
                          idxNode,
                          FALSE,        // Legacy device is never the preferred device
                          hkPortsRoot,
                          NULL,
                          NULL);
}


// @mfunc:(INTERNAL) Update the port list with legacy devices enumerated via
// the WinMM MIDI API.
//
// @rdesc Returns one of the following:
//
// @flag S_OK | On success
// @flag S_FALSE | If there were no devices found
// @flag E_OUTOFMEMORY | If there was insufficient memory to build the port list
//
// @comm This function needs to update the list rather than just add.
//
HRESULT CDirectMusic::AddLegacyDevices()
{
#ifdef WINNT
    return EnumLegacyDevices(this, AddDeviceCallback);
#else
    if ((!(g_fFlags & DMI_F_WIN9X)) ||
        (!LoadDmusic32()))
    {
        return S_FALSE;
    }

    PENUMLEGACYDEVICES peld = (PENUMLEGACYDEVICES)GetProcAddress(g_hModuleDM32,
                                                                 cszEnumLegacyDevices);

    if (NULL == peld)
    {
        TraceI(0, "Could not get EnumLegacyDevice entry point from DMusic32.dll!");
        return S_FALSE;
    }

    return (*peld)(this, AddDeviceCallback);
#endif
}

// @mfunc:(INTERNAL) Add software synthesizers from the registry.
//
//
HRESULT CDirectMusic::AddSoftwareSynths()
{
    HKEY hk;
    DWORD idxSynth;
    char szSynthGUID[256];
    HRESULT hr;
    CLSID clsid;
    DMUS_PORTCAPS dmpc;
    IDirectMusicSynth *pSynth;

    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      REGSTR_PATH_SOFTWARESYNTHS,
                      0L,
                      KEY_READ,
                      &hk))
    {
        for (idxSynth = 0; !RegEnumKey(hk, idxSynth, szSynthGUID, sizeof(szSynthGUID)); ++idxSynth)
        {
            hr = StrToCLSID(szSynthGUID, clsid, sizeof(szSynthGUID));
            if (!SUCCEEDED(hr))
            {
                continue;
            }

            // Create a synth instance
            //
            hr = CoCreateInstance(clsid,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IDirectMusicSynth,
                                  (LPVOID*)&pSynth);
            if (FAILED(hr))
            {
                TraceI(1, "Enum: Failed creation of synth %s hr=%08lX\n", szSynthGUID, hr);
                continue;
            }

            ZeroMemory(&dmpc, sizeof(dmpc));
            dmpc.dwSize = sizeof(dmpc);
            dmpc.guidPort = clsid;
            dmpc.dwType = DMUS_PORT_USER_MODE_SYNTH;

            hr = pSynth->GetPortCaps(&dmpc);
            if (FAILED(hr))
            {
                TraceI(1, "Enum: Synth %s returned %08lX for GetPortCaps\n", szSynthGUID, hr);
                pSynth->Release();
                continue;
            }

            if (dmpc.guidPort != clsid)
            {
                TraceI(0, "Enum: WARNING: Synth %s changed its CLSID!\n", szSynthGUID);
            }

            AddDevice(dmpc,
                      ptSoftwareSynth,
                      -1,
                      -1,
                      -1,
                      FALSE,
                      NULL,
                      NULL,
                      NULL);

            pSynth->Release();
        }

        RegCloseKey(hk);
    }

    return S_OK;
}


// @mfunc:(INTERNAL) Add one device to the master device list, possibly updating an existing
// entry.
//
// @rdesc One of the following
// @flag S_OK | On success
//
HRESULT CDirectMusic::AddDevice(
    DMUS_PORTCAPS &dmpc,       // @parm Already filled in port caps
    PORTTYPE pt,               // @parm The port type
    int idxDev,                // @parm The WinMM or SysAudio device ID of this driver
    int idxPin,                // @parm The pin # if this is a WDM device
    int idxNode,               // @parm The node # of the synth node if this is a WDM device
    BOOL fPrefDev,             // @parm This is on the preferred device
    HKEY hkPortsRoot,          // @parm Where port information is stored in the registry
    LPWSTR wszDIName,          // @parm The Device Interface name if this is a WDM Device.
    LPSTR pstrInstanceId)      // @parm The InstanceID if the device is a WDM device.
{
    CNode<PORTENTRY *> *pPortNode;
    PORTENTRY *pPort;
    BOOL fFound;
    HKEY hkPort;
    char szRegKey[sizeof(cszPortOut) + DMUS_MAX_DESCRIPTION + 1];
    WCHAR wszRegKey[sizeof(cszPortOut) + DMUS_MAX_DESCRIPTION + 1];
    DWORD cb;
    DWORD dw;
    BOOL fGotGUID;
    HRESULT hr;
    char sz[256];
    BOOL fGotRegKey;

    // First find out if this device is already in the list
    //
#ifdef DEBUG
    SafeWToA(sz, dmpc.wszDescription);

    TraceI(1, "AddDevice: Adding [%s] index %d class %d\n",
           sz,
           idxDev,
           dmpc.dwClass);
#endif

    for (pPortNode = m_lstDevices.GetListHead(), fFound = FALSE; pPortNode && !fFound; pPortNode = pPortNode->pNext)
    {
        pPort = pPortNode->data;

        if (pPort->type != pt || pPort->pc.dwClass != dmpc.dwClass)
        {
            continue;
        }

        switch(pt)
        {
            case ptWDMDevice:
                if (dmpc.guidPort == pPort->pc.guidPort)
                {
                    fFound = TRUE;
                }
                break;

            case ptLegacyDevice:
                if (!_wcsicmp(dmpc.wszDescription, pPort->pc.wszDescription))
                {
                    fFound = TRUE;
                }
                break;

            case ptSoftwareSynth:
                if (dmpc.guidPort == pPort->pc.guidPort)
                {
                    fFound = TRUE;
                }
                break;

            default:
                assert(FALSE);
        }
    }

    if (fFound)
    {
        // Already have an entry - just update the device index
        //
        TraceI(1, "AddDevice: Reusing entry\n");
        pPort->idxDevice = idxDev;
        pPort->idxPin = idxPin;
        pPort->fIsValid = TRUE;
        pPort->fPrefDev = fPrefDev;

        return S_OK;
    }

    // No existing entry - need to create a new one plus a GUID.
    //
    pPort = new PORTENTRY;
    if (NULL == pPort)
    {
        return E_OUTOFMEMORY;
    }

    //clean up the junk in the wszDIName member
    ZeroMemory(pPort->wszDIName,256 * sizeof(WCHAR));

    CopyMemory(&pPort->pc, &dmpc, sizeof(DMUS_PORTCAPS));

    fGotGUID = (dmpc.guidPort != guidZero) ? TRUE : FALSE;

    if (hkPortsRoot)
    {
        if (g_fFlags & DMI_F_WIN9X)
        {
            SafeWToA(sz, dmpc.wszDescription);
            wsprintfA(szRegKey,
                      dmpc.dwClass == DMUS_PC_INPUTCLASS ? cszPortIn : cszPortOut,
                      sz);
            fGotRegKey = !RegCreateKeyA(hkPortsRoot, szRegKey, &hkPort);
        }
        else
        {
            wsprintfW(wszRegKey,
                      dmpc.dwClass == DMUS_PC_INPUTCLASS ? cwszPortIn : cwszPortOut,
                      dmpc.wszDescription);
            fGotRegKey = !RegCreateKeyW(hkPortsRoot, wszRegKey, &hkPort);
        }

        if (fGotRegKey)
        {
            cb = sizeof(pPort->pc.guidPort);
            if (fGotGUID)
            {
                RegSetValueExA(hkPort, cszGUID, 0, REG_BINARY, (LPBYTE)&pPort->pc.guidPort, sizeof(pPort->pc.guidPort));
            }
            else if (RegQueryValueExA(hkPort, cszGUID, NULL, &dw, (LPBYTE)&pPort->pc.guidPort, &cb))
            {
                // No GUID yet for this device - create one
                //
                hr = UuidCreate(&pPort->pc.guidPort);
                if (SUCCEEDED(hr))
                {
                    TraceI(1, "AddDevice: Setting GUID in registry\n");
                    RegSetValueExA(hkPort, cszGUID, 0, REG_BINARY, (LPBYTE)&pPort->pc.guidPort, sizeof(pPort->pc.guidPort));
                    fGotGUID = TRUE;
                }
            }
            else
            {
                TraceI(1, "AddDevice: Pulled GUID from registry\n");
                fGotGUID = TRUE;
            }

            RegCloseKey(hkPort);
        }
    }

    if (!fGotGUID)
    {
        // Some registry call failed - get a one-time guid anyway
        //
        hr = UuidCreate(&pPort->pc.guidPort);
        if (SUCCEEDED(hr))
        {
            TraceI(1, "AddDevice: Registry failed, getting dynamic GUID\n");
            fGotGUID = TRUE;
        }
    }

    if (!fGotGUID)
    {
        TraceI(0, "AddDevice: Ignoring [%s]; could not get GUID!\n", dmpc.wszDescription);
        // Something really strange is failing
        //
        delete pPort;
        return E_OUTOFMEMORY;
    }

    TraceI(1, "AddDevice: Adding new list entry.\n");
    // We have an entry and a GUID, add other fields and put in the list
    //
    pPort->type = pt;
    pPort->fIsValid = TRUE;
    pPort->idxDevice = idxDev;
    pPort->idxPin = idxPin;
    pPort->idxNode = idxNode;
    pPort->fPrefDev = fPrefDev;
    pPort->fAudioDest = FALSE;

    //if we get a Device Interface name, copy it
    if (wszDIName != NULL)
    {
        wcscpy(pPort->wszDIName,wszDIName);
    }

    if (NULL == m_lstDevices.AddNodeToList(pPort))
    {
        delete pPort;
        return E_OUTOFMEMORY;
    }

    //One final piece of work.
    //If the device we added was a WDM device -- we need to check that the
    //destination port is up to date.

    if (pt == ptWDMDevice)
    {
        pPort->fAudioDest = TRUE;

        CNode<PORTDEST *> *pDestNode = NULL;
        PORTDEST *pDest = NULL;
        fFound = FALSE;

        for (pDestNode = pPort->lstDestinations.GetListHead(), fFound = FALSE;
             pDestNode && !fFound;
             pDestNode = pDestNode->pNext)
        {
            pDest = pDestNode->data;
            if (!strcmp(pDest->pstrInstanceId, pstrInstanceId))
            {
                fFound = TRUE;
            }
        }

        if (!fFound)
        {
            pDest = new PORTDEST;

            if (NULL == pDest) {
                return E_OUTOFMEMORY;
            }

            pDest->idxDevice = idxDev;
            pDest->idxPin = idxPin;
            pDest->idxNode = idxNode;
            pDest->fOnPrefDev = fPrefDev;

            pDest->pstrInstanceId = new char[strlen(pstrInstanceId) + 1];
            if (NULL == pDest->pstrInstanceId)
            {
                delete pDest;
                return E_OUTOFMEMORY;
            }
            strcpy(pDest->pstrInstanceId, pstrInstanceId);

            if (NULL == pPort->lstDestinations.AddNodeToList(pDest))
            {
                delete[] pDest->pstrInstanceId;
                delete pDest;
                return E_OUTOFMEMORY;
            }

            TraceI(1, "  This synth instance is on instance id %s\n", pstrInstanceId);
        }
    }

    return S_OK;
}


// @method:(EXTERNAL) HRESULT | IDirectMusic | EnumPort | Enumerates the available ports.
//
// @comm
//
// The IDirectMusic::EnumPort method enumerates and retrieves the
// capabilities of each DirectMusic port on the system.  Each time it is
// called, EnumPort returns information about a single port.
// Applications should not rely on or store the index number of a port.
// Rebooting, as well as adding and removing ports could cause the index
// number of a port to change.  The GUID identifying the port, however,
// does not change.
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully.
// @flag S_FALSE | Invalid index number
// @flag E_POINTER | If the pPortCaps parameter was invalid
// @flag E_NOINTERFACE | If there were no ports to enumerate
// @flag E_INVALIDARG | If the <p lpPortCaps> struct is not the correct size
//
STDMETHODIMP CDirectMusic::EnumPort(
    DWORD dwIndex,                        // @parm Specifies the index of the port for which the capabilities are to be returned.
                                        // This parameter should be zero on the first call and then incremented by one in each
                                        // subsequent call until S_FALSE is returned.
    LPDMUS_PORTCAPS lpPortCaps)            // @parm Pointer to the <c DMUS_PORTCAPS>a structure to receive the capabilities of the port.
{

    CNode<PORTENTRY *> *pNode;

    V_INAME(IDirectMusic::EnumPort);
    V_STRUCTPTR_READ(lpPortCaps, DMUS_PORTCAPS);

    pNode = m_lstDevices.GetListHead();
    if (dwIndex == 0 || pNode == NULL)
    {
        UpdatePortList();
    }

    pNode = m_lstDevices.GetListHead();
    if (NULL == pNode)
    {
        return E_NOINTERFACE;
    }

    while (dwIndex-- && pNode)
    {
        pNode = pNode->pNext;
    }

    if (pNode == NULL)
    {
        return S_FALSE;
    }

    *lpPortCaps = pNode->data->pc;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | CreateMusicBuffer | Creates a buffer which holds music data for input or output.
//
// @comm
//
// The IDirectMusic::CreateMusicBuffer method creates a
// DirectMusicBuffer object.  This buffer is then filled with music
// events to be sequenced or passed to IDirectMusicPort::Read to be
// filled with incoming music event.
//
//
// @rdesc Returns one of the following
//
// @flag S_OK | On success
// @flag E_POINTER | If any of the passed pointers is invalid.
// @flag E_INVALIDARG | If any of the other arguments is invalid
//
//
STDMETHODIMP CDirectMusic::CreateMusicBuffer(
    LPDMUS_BUFFERDESC pBufferDesc,           // @parm Address of the <c DMUS_BUFFERDESC> structure that contains
                                            // the description of the music buffer to be created.
    LPDIRECTMUSICBUFFER *ppBuffer,          // @parm Address of the IDirectMusicBuffer interface pointer if successful.
    LPUNKNOWN pUnkOuter)                    // @parm Address of the controlling object's IUnknown interface for COM
                                            // aggregation, or NULL if the interface is not aggregated. Most callers will pass NULL.
{
    V_INAME(IDirectMusic::CreateMusicBuffer);
    V_STRUCTPTR_READ(pBufferDesc, DMUS_BUFFERDESC);
    V_PTRPTR_WRITE(ppBuffer);
    V_PUNKOUTER_NOAGG(pUnkOuter);

    *ppBuffer = NULL;

    CDirectMusicBuffer *pBuffer = new CDirectMusicBuffer(*pBufferDesc);
    if (NULL == pBuffer)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pBuffer->Init();
    if (!SUCCEEDED(hr))
    {
        delete pBuffer;
        return hr;
    }

    *ppBuffer = pBuffer;

    return S_OK;
}

/*
 @method:(EXTERNAL) HRESULT | IDirectMusic | CreatePort | Creates a port to a hardware or software device for music input or output

 @comm

The IDirectMusic::CreatePort method is used to create a port object
for a particular DirectMusic port based on the GUID obtained through
the <om IDirectMusic::EnumPort> call.

The <p pPortParams> structure specifies parameters for the newly created port. If all parameters could not
be obtained, then the passed <p pPortParams> structure will be changed as follows to match the available
parameters of the port.

On entry, the dwValidParams field of the structure indicates which fields in the structure are valid. CreatePort
will never set flags in this field that the application did not set before the call. However, if the requested port
does not support a requested feature at all, then a flag may be cleared in dwValidParams, indicating that the
given field was ignored. In this case S_FALSE will be returned from the method instead of S_OK.

If the port supports a specified parameter, but the given value for the parameter is out of range, then the
parameter value in <p pPortParams> will be changed. In this case, the flag in dwValidParams will remain set, but
S_FALSE will be returned to indicate that the struct has been changed.

@ex For example, to request reverb and determine if it was obtained, an application might execute the following code:

    DMUS_PORTPARAMS params;
    ZeroMemory(&params, sizeof(params));
    params.dwSize = sizeof(params);
    params.dwValidParams = DMUS_PORTPARAMS_REVERB;
    params.fReverb = TRUE;

    HRESULT hr = pDirectMusic->CreatePort(guidPort, NULL, &params, &port, NULL);
    if (SUCCEEDED(hr))
    {
        fGotReverb = TRUE;

        if (hr == S_FALSE)
        {
            if (!(params.dwValidParams & DMUS_PORPARAMS_REVERB))
            {
                // Device does not know what reverb is
                //
                fGotReverb = FALSE;
            }
            else if (!params.fReverb)
            {
                // Device understands reverb, but could not allocate it
                //
                fGotReverb = FALSE;
            }
        }
    }


@rdesc Returns one of the following

@flag S_OK | On success
@flag S_FALSE | If the port was created, but some requested paramter is not available
@flag E_POINTER | If any of the passed pointers is invalid
@flag E_INVALIDARG | If the <p lpPortParams> struct is not the correct size
*/
STDMETHODIMP CDirectMusic::CreatePort(
    REFGUID rguidPort,              // @parm Reference to (C++) or address of (C) the GUID that identifies the
                                    // port for which the IDirectMusicPort interface is to be created.  This
                                    // parameter must be a GUID returned by <om IDirectMusic::EnumPort>.  If it
                                    // is GUID_NULL, then the returned port will be the port specified in
                                    // the registry.
                                    //

    LPDMUS_PORTPARAMS pPortParams,   // @parm The <c DMUS_PORTPARAMS> struct which contains open parameters for the port.

    LPDIRECTMUSICPORT *ppPort,      // @parm Address of the <i IDirectMusicPort> interface pointer if successful.

    LPUNKNOWN pUnkOuter)            // @parm Address of the controlling object's IUnknown interface for COM
                                    // aggregation, or NULL if the interface is not aggregated. Most callers will pass NULL.
{
    HRESULT                         hr;
    HRESULT                         hrInit;
#ifndef WINNT
    PCREATECDIRECTMUSICEMULATEPORT  pcdmep;
#endif
    DWORD                           dwParamsVer;

    V_INAME(IDirectMusic::CreatePort);
    V_PTRPTR_WRITE(ppPort);
    V_PUNKOUTER_NOAGG(pUnkOuter);
    V_REFGUID(rguidPort);

    V_STRUCTPTR_WRITE_VER(pPortParams, dwParamsVer);
    V_STRUCTPTR_WRITE_VER_CASE(DMUS_PORTPARAMS, 7);
    V_STRUCTPTR_WRITE_VER_CASE(DMUS_PORTPARAMS, 8);
    V_STRUCTPTR_WRITE_VER_END(DMUS_PORTPARAMS, pPortParams);

    GUID guid;

    if (!m_fDirectSound)
    {
        return DMUS_E_DSOUND_NOT_SET;
    }

    // First check for default port
    //
    if (rguidPort == GUID_NULL)
    {
        GetDefaultPortI(&guid);
    }
    else
    {
        guid = rguidPort;
    }

    *ppPort = NULL;

    // Find DMPORTCAP entry if there is one.
    //
    CNode<PORTENTRY *> *pNode;
    PORTENTRY *pCap = NULL;

    // If they used a cached GUID w/o calling EnumPort first, make sure we have
    // the list of ports up to date.
    //
    if (!m_lstDevices.GetListHead())
    {
        UpdatePortList();
    }

    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNode->pNext)
    {
        if (pNode->data->pc.guidPort == guid)
        {
            pCap = pNode->data;
            break;
        }
    }

    if (!pCap)
    {
        return E_NOINTERFACE;
    }

    // Now create the correct port implementation
    //
    switch(pCap->type)
    {
#ifdef USE_WDM_DRIVERS
        case ptWDMDevice:
            hrInit = CreateCDirectMusicPort(pCap, this, pPortParams, ppPort);
            break;
#endif

        case ptLegacyDevice:
#ifdef WINNT
            hrInit = CreateCDirectMusicEmulatePort(pCap, this, pPortParams, ppPort);
#else
            TraceI(1, "Create legacy device\n");
            if ((!(g_fFlags & DMI_F_WIN9X)) ||
                (!LoadDmusic32()))
            {
                return E_NOINTERFACE;
            }

            pcdmep =
                (PCREATECDIRECTMUSICEMULATEPORT)GetProcAddress(g_hModuleDM32,
                                                               cszCreateEmulatePort);

            if (NULL == pcdmep)
            {
                TraceI(0, "Could not get CreateCDirectMusicEmulatePort from DMusic32.dll");
                return E_NOINTERFACE;
            }

            hrInit = (*pcdmep)(pCap, this, pPortParams, ppPort);
#endif
            break;

        case ptSoftwareSynth:
            TraceI(1, "Create software synth\n");

            hrInit = CreateCDirectMusicSynthPort(
                pCap,
                this,
                dwParamsVer,
                pPortParams,
                ppPort);

            break;

        default:
            TraceI(0, "Attempt to create a port with an unknown type %u\n", pCap->type);
            return E_NOINTERFACE;
    }

    if (FAILED(hrInit))
    {
        return hrInit;
    }

    // Only synth supports dwFeatures
    //
    if (pCap->type != ptSoftwareSynth && dwParamsVer >= 8)
    {
        DMUS_PORTPARAMS8 *pp8 = (DMUS_PORTPARAMS8*)pPortParams;

        if ((pp8->dwValidParams & DMUS_PORTPARAMS_FEATURES) &&
            (pp8->dwFeatures != 0))
        {
            pp8->dwFeatures = 0;
            hrInit = S_FALSE;
        }
    }

    // Add port to the list of open ports
    //
    m_lstOpenPorts.AddNodeToList(*ppPort);

    // Set default volume setting
    //
    IKsControl *pControl;
    hr = (*ppPort)->QueryInterface(IID_IKsControl, (void**)&pControl);
    if (SUCCEEDED(hr))
    {
        KSPROPERTY ksp;
        LONG lVolume = 0;
        ULONG cb;

        ZeroMemory(&ksp, sizeof(ksp));
        ksp.Set   = KSPROPSETID_Synth;
        ksp.Id    = KSPROPERTY_SYNTH_VOLUME;
        ksp.Flags = KSPROPERTY_TYPE_SET;

        pControl->KsProperty(&ksp,
                             sizeof(ksp),
                             (LPVOID)&lVolume,
                             sizeof(lVolume),
                             &cb);
        pControl->Release();
    }

    // Possibly return S_FALSE if port initialization was not able to get all paramters
    //
    return hrInit;
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | SetDirectSound | Sets the default DirectSound for
// audio output.
//
// @comm
//
// This method must be called once and only once per instance of DirectMusic. The specified DirectSound
// will be the default used for rendering audio on all ports. This default can be overridden using
// the <om IDirectMusicPort::SetDirectSound> method.
//
// @rdesc Returns one of the following
// @flag S_OK | On success
// @flag E_POINTER | If pguidPort does not point to valid memory
//
STDMETHODIMP CDirectMusic::SetDirectSound(
    LPDIRECTSOUND pDirectSound,             // @parm Points to the DirectSound interface to use.
                                            // If this parameter is NULL, then SetDirectSound will
                                            // create a DirectSound to use. If a DirectSound interface
                                            // is provided, then the caller is responsible for
                                            // managing the DirectSound cooperative level.
    HWND hwnd)                              // @parm If <p pDirectSound> is NULL, then this parameter
                                            // will be used as the hwnd for DirectSound focus managment.
                                            // If the parameter is NULL, then the current foreground
                                            // window will be set as the focus window.
{
    V_INAME(IDirectMusic::SetDirectSound);
    V_INTERFACE_OPT(pDirectSound);
    V_HWND_OPT(hwnd);

    if (m_cRefDirectSound)
    {
        return DMUS_E_DSOUND_ALREADY_SET;
    }

    m_fDirectSound = 1;

    if (m_pDirectSound)
    {
        m_pDirectSound->Release();
    }

    if (pDirectSound)
    {
        pDirectSound->AddRef();
    }

    m_pDirectSound = pDirectSound;

    m_hWnd = hwnd;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// SetExternalMasterClock
//
// Let the caller specify their own IReferenceClock, overriding the default
// system one.
//
STDMETHODIMP CDirectMusic::SetExternalMasterClock(
    IReferenceClock *pClock)
{
    V_INAME(IDirectMusic::SetEsternalMasterClock);
    V_INTERFACE(pClock);

    return m_pMasterClock->SetMasterClock(pClock);
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | GetDefaultPort | Get the default output port
//
// @comm
//
// The IDirectMusic::GetDefaultPort method is used to determine what what port will be created if
// GUID_DMUS_DefaultPort is passed to <om IDirectMusic::CreatePort>.
//
// If the port specified in the registry does not
// exist, then the default output port will be the Microsoft Software Synthesizer. Otherwise,
// the port specified by the last call to SetDefaultPort will be returned. This setting is
// persistent across sessions.
//
// @rdesc Returns one of the following
// @flag S_OK | On success
// @flag E_POINTER | If pguidPort does not point to valid memory
//
STDMETHODIMP CDirectMusic::GetDefaultPort(
    LPGUID pguidPort)        // @parm Points to a GUID which will contain the default port GUID on success
{
    V_INAME(IDirectMusic::GetDefaultPort);
    V_PTR_WRITE(pguidPort, GUID);

    GetDefaultPortI(pguidPort);
    return S_OK;
}

// @method:(INTERNAL) HRESULT | CDirectMusic | GetDefaultPortI | Internal implementation of
// <om IDirectMusic::GetDefaultPort>.
//
// Internal implementation without parameter validation so <om IDirectMusic::CreatePort> can
// share the same code.
//
// This function cannot fail; it will just return CLSID_DirectMusicSynth on any error.
//
void CDirectMusic::GetDefaultPortI(
    GUID *pguidPort)
{
    CNode<PORTENTRY *> *pNode;
    BOOL fGotKernelSynth;

    // If they used a cached GUID w/o calling EnumPort first, make sure we have
    // the list of ports up to date.
    //
    if (!m_lstDevices.GetListHead())
    {
        UpdatePortList();
    }

    // If hardware acceleration is disabled, revert to 6.1 behavior -
    // just use our UM software synth
    //
    // If we have DX8, we must have an audio path synth. Since we have no
    // HW acceleration yet, this means forcing our SW Synth.
    //
    if (m_fDisableHWAcceleration || (m_nVersion >= 8))
    {
        *pguidPort = CLSID_DirectMusicSynth;
        return;
    }

    fGotKernelSynth = FALSE;
    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNode->pNext)
    {
        if (pNode->data->fPrefDev &&
            (pNode->data->pc.dwFlags & DMUS_PC_DLS))
        {
            *pguidPort = pNode->data->pc.guidPort;
            return;
        }

        if (pNode->data->pc.guidPort == GUID_WDMSynth &&
            m_fDefaultToKernelSwSynth)
        {
           fGotKernelSynth = TRUE;
        }
    }

    *pguidPort = fGotKernelSynth ? GUID_WDMSynth : CLSID_DirectMusicSynth;
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | Activate |
// Activates or deactivates all output ports created from this interface.
//
// @comm
//
// The IDirectMusic::Activate method tells DirectMusic when the ports
// allocated by the application should be enabled or disabled.
// Applications should call Activate(FALSE) when they lose input focus
// if they do not need to play music in the background.  This will allow
// another application that may have the input focus to have access to
// these port resources.  Once the application has input focus again, it
// should call Activate(TRUE) to enable all of its allocated ports.
// When the DirectMusic object is first created, its default state is
// set to active.  The state of any ports created with
// <om IDirectMusic::CreatePort> will reflect the current state of the
// DirectMusic object.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully
//
STDMETHODIMP
CDirectMusic::Activate(
    BOOL fActivate)                 // @parm Informs DirectMusic whether the allocated ports should be activated or deactivated.
                                    // @flag TRUE | Activate all port objects created with this instance of DirectMusic.
                                    // @flag FALSE | Deactivate all of the port objects created with this instance of DirectMusic.

{
    CNode<IDirectMusicPort*> *pNode;
    HRESULT hr = S_OK;
    HRESULT hrFirst = S_OK;

    for (pNode = m_lstOpenPorts.GetListHead(); pNode; pNode = pNode->pNext)
    {
        hr = pNode->data->Activate(fActivate);

        //record the first failure
        if (FAILED(hr) & SUCCEEDED(hrFirst))
        {
            hrFirst = hr;
        }

    }

    //if we are a post 7 version we'll return the hr of the
    //first failure.  If there were no failurs than we will
    //return S_OK.  Pre 7 versions, we'll return S_OK always.
    if (m_nVersion >= 8)
        return hrFirst;
    else
        return S_OK;
}


STDMETHODIMP
CDirectMusic::NotifyFinalRelease(
    IDirectMusicPort *pPort)
{
    CNode<IDirectMusicPort *> *pNode;

    TraceI(2, "CDirectMusic::NotifyFinalRelease\n");

    for (pNode = m_lstOpenPorts.GetListHead(); pNode; pNode = pNode->pNext)
    {
        if (pNode->data == pPort)
        {
            // NOTE: We DON'T Release here, because the matching Release to the port create AddRef
            // was the application Release which caused the port to turn around and call THIS function.
            //
            m_lstOpenPorts.RemoveNodeFromList(pNode);

            // If the last port just went away and DirectMusic was held open
            // by the ports, delete it
            //
            if (m_lstOpenPorts.GetNodeCount() == 0 && m_cRef == 0)
            {
                delete this;
            }

            return S_OK;
        }
    }

    TraceI(0, "CDirectMusic::NotifyFinalRelease(%p) - port not in list!", pPort);
    return E_INVALIDARG;
}




// @method:(EXTERNAL) HRESULT | IDirectMusic | EnumMasterClock | Enumerates the possible time sources for DirectMusic.
//
// @comm
//
// The IDirectMusic::EnumMasterClock method is used to enumerate and get
// the description of the clocks that DirectMusic can use as the master
// clock.  Each time it is called, this method retrieves information
// about a single clock.  Applications should not rely or store the
// index number of a clock.  Rebooting, as well as adding and removing
// hardware could cause the index number of a clock to change.
//
// The master clock is a high-resolution timer that is shared by all
// processes, devices, and applications that are using DirectMusic. The
// clock is used to synchronize all music playback in the system.  It is
// a standard <i IReferenceClock> that stores time as a 64-bit integer in
// increments of 100 nanoseconds. The <om IReferenceClock::GetTime> method
// returns the current time. The master clock must derive from a
// continuously running hardware source, usually the system crystal, but
// optionally a crystal on a hardware I/O device, for example the
// crystal used by a wave card for audio playback. All DirectMusic ports
// synchronize to this master clock.
//
// This sample code shows how to use this method. Similar code can be used to wrap
// the <om IDirectMusic::EnumPorts> method.
//
// DWORD idx;
// HRESULT hr;
// DMUS_CLOCKCAPS dmcc;
//
// for (;;)
// {
//     hr = pDirectMusic->EnumMasterClock(idx, &dmcc);
//     if (FAILED(hr))
//     {
//         // Something went wrong
//         break;
//     }
//
//     if (hr == S_FALSE)
//     {
//         // End of enumeration
//         break;
//     }
//
//     // Use dmcc
// }
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully
// @flag S_FALSE | Invalid index number
// @flag E_POINTER | If the pClockInfo pointer is invalid
// @flag E_INVALIDARG | If the <p lpClockInfo> struct is not the correct size
//
STDMETHODIMP
CDirectMusic::EnumMasterClock(
    DWORD           dwIndex,              // @parm Specifies the index of the clock for which the description is
                                        // to be returned.  This parameter should be zero on the first call
                                        // and then incremented by one in each subsequent call until S_FALSE is returned.
    LPDMUS_CLOCKINFO lpClockInfo)        // @parm Pointer to the <c DMUS_CLOCKINFO> structure to receive the description of the clock.
{
    DWORD dwVer;

    V_INAME(IDirectMusic::EnumMasterClock);

    V_STRUCTPTR_READ_VER(lpClockInfo, dwVer);
    V_STRUCTPTR_READ_VER_CASE(DMUS_CLOCKINFO, 7);
    V_STRUCTPTR_READ_VER_CASE(DMUS_CLOCKINFO, 8);
    V_STRUCTPTR_READ_VER_END(DMUS_CLOCKINFO, lpClockInfo);

    return m_pMasterClock->EnumMasterClock(dwIndex, lpClockInfo, dwVer);
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | GetMasterClock | Returns the GUID of and an <i IReferenceClock> interface to the current master clock.
//
// @comm
//
// The IDirectMusic::GetMasterClock method returns the GUID and/or the
// address of the <i IReferenceClock> interface pointer for the clock that
// is currently set as the DirectMusic master clock.  If a null pointer
// is passed for either of the pointer parameters below, this method
// assumes that that pointer value is not desired.  The <i IReferenceClock>
// interface pointer must be released once the application has finished
// using the interface.  See <om IDirectMusic::EnumMasterClock> for more
// information about the master clock.
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If either pointer was invalid
//
STDMETHODIMP
CDirectMusic::GetMasterClock(
    LPGUID pguidClock,               // @parm Pointer to the memory to be filled in with the master clock's GUID.
    IReferenceClock **ppClock)      // @parm Address of the <i IReferenceClock> interface pointer for this clock.
{
    V_INAME(IDirectMusic::GetMasterClock);
    V_PTR_WRITE_OPT(pguidClock, GUID);
    V_PTRPTR_WRITE_OPT(ppClock);

    return m_pMasterClock->GetMasterClock(pguidClock, ppClock);
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | SetMasterClock | Sets the global DirectMusic master clock.
//
// @comm
//
// The IDirectMusic::SetMasterClock sets the DirectMusic master clock to
// a specific clock based on a given GUID obtained through the
// <om IDirectMusic::EnumMasterClock> call.  There is only one master clock
// for all DirectMusic applications.  If another running application is
// also using DirectMusic, it will not be possible to change the master
// clock until that application is shut down.  See
// <om IDirectMusic::EnumMasterClock> for more information about the master
// clock.
//
// Most applications will not need to call SetMasterClock. It should not be called
// unless there is a compelling reason, such as a need to have very tight synchornization
// with a hardware timebase other than the system clock.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
//
STDMETHODIMP
CDirectMusic::SetMasterClock(
    REFGUID rguidClock)     // @parm Reference to (C++) or address of (C) the GUID that identifies the clock to
                            // set as the master clock for DirectMusic.  This parameter must be a GUID returned
                            // by <om IDirectMusic::EnumMasterClock>.
{
    V_INAME(IDirectMusic::SetMasterClock);
    V_REFGUID(rguidClock);

    return m_pMasterClock->SetMasterClock(rguidClock);

}

HRESULT CDirectMusic::GetDirectSoundI(
    LPDIRECTSOUND *ppDirectSound)
{
    if (InterlockedIncrement(&m_cRefDirectSound) == 1)
    {
        m_fCreatedDirectSound = FALSE;

        // If one is already created or given to us, use it
        //
        if (m_pDirectSound == NULL)
        {
            // No interface yet, create it
            //
            LPDIRECTSOUND8 pds = NULL;
            HRESULT hr = DirectSoundCreate8(NULL,
                                           &pds,
                                           NULL);
            if (FAILED(hr))
            {
                TraceI(0, "SetDirectSound: CreateDirectSound failed! %08X\n", hr);
                InterlockedDecrement(&m_cRefDirectSound);
                return hr;
            }

            hr = pds->QueryInterface(IID_IDirectSound, (void**)&m_pDirectSound);
            pds->Release();
            if (FAILED(hr))
            {
                TraceI(0, "SetDirectSound: CreateDirectSound failed! %08X\n", hr);
                InterlockedDecrement(&m_cRefDirectSound);
                return hr;
            }


            HWND hWnd = m_hWnd;

            if (!hWnd)
            {
                hWnd = GetForegroundWindow();

                if (!hWnd)
                {
                    hWnd = GetDesktopWindow();
                }
            }

            assert(hWnd);

            hr = m_pDirectSound->SetCooperativeLevel(
                hWnd,
                DSSCL_PRIORITY);

            if (FAILED(hr))
            {
                TraceI(0, "SetDirectSound: SetCooperativeLevel (DSCCL_PRIORITY) failed!\n");
                m_pDirectSound->Release();
                m_pDirectSound = NULL;

                InterlockedDecrement(&m_cRefDirectSound);
                return hr;
            }

            m_fCreatedDirectSound = TRUE;
        }
    }

    m_pDirectSound->AddRef();
    *ppDirectSound = m_pDirectSound;

    return S_OK;
}

void CDirectMusic::ReleaseDirectSoundI()
{
    if (m_pDirectSound == NULL)
    {
        // Hitting this assert means a port released one too many times
        //
        assert(m_pDirectSound);
        return;
    }

    // Release reference held by port
    //
    m_pDirectSound->Release();

    if (InterlockedDecrement(&m_cRefDirectSound) == 0 && m_fCreatedDirectSound)
    {
        // This was the last reference. If we created the DirectSound, release it
        //
        m_pDirectSound->Release();
        m_pDirectSound = NULL;
    }
}

// CDirectMusic::GetPortByGUID
//
PORTENTRY *CDirectMusic::GetPortByGUID(GUID guid)
{
    CNode<PORTENTRY *> *pNode;
    PORTENTRY *pPort;

    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNode->pNext)
    {
        pPort = pNode->data;

        if (pPort->pc.guidPort == guid)
        {
            return pPort;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\opnew.cpp ===
// OpNew.cpp
//
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\resource.h ===
// resource.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
#define IDS_SYSTEMCLOCK         1000
#define IDS_DSOUNDCLOCK         1001
#define IDS_EXTCLOCK            1002
#define IDS_EMULATED            1003
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dswave.h ===
//
// dswave.h
// 
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Support for streaming or oneshot waves from IDirectSoundWaveObject
//
//
#ifndef _DSWAVE_H_
#define _DSWAVE_H_

#include "alist.h"

#ifndef CHUNK_ALIGN
#define SIZE_ALIGN	sizeof(BYTE *)
#define CHUNK_ALIGN(x) (((x) + SIZE_ALIGN - 1) & ~(SIZE_ALIGN - 1))
#endif

#define MAX_CHANNELS    32                      // XXX Is this ok?

// Number of download buffers per streaming wave
//
const UINT gnDownloadBufferPerStream = 3;


class CDirectSoundWave;

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveArt
//
// Wraps wave articulation data
//
class CDirectSoundWaveArt
{
public:
    CDirectSoundWaveArt();
    ~CDirectSoundWaveArt();
    
    HRESULT Init(CDirectSoundWave *pDSWave, UINT nSegments, DWORD dwBus, DWORD dwFlags);

    inline DWORD GetSize() const
    { return m_cbSize; }
   
    void Write(void *pvoid, DWORD dwDLIdArt, DWORD dwDLIdWave, DWORD dwMasterDLId);
    
private:    
    CDirectSoundWave   *m_pDSWave;              // Owning CDirectSoundWave
    DMUS_WAVEARTDL      m_WaveArtDL;            // Wave articulation
    DWORD               m_cbSize;               // Size of download
    UINT                m_nDownloadIds;         // Expected # of download ID's
    DWORD               m_cbWaveFormat;         // Size needed to pack wave format
};

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload
//
// Tracks a set of downloaded wave buffers.
//
//
class CDirectSoundWaveDownload
{
public:
 